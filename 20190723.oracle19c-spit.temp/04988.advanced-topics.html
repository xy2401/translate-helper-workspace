<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Advanced Topics</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="datatypes-and-host-variables.html" title="Previous" type="text/html">
      <link rel="next" href="embedded-SQL.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="datatypes-and-host-variables.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="embedded-SQL.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name"> Introduction and Concepts </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Advanced Topics</li>
            </ol>
            <a id="GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5" name="GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5"></a><a id="LNPCC3253"></a>
            
            <h2 id="LNPCC-GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5" class="sect2"><span class="enumeration_chapter">5 </span> Advanced Topics
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses advanced techniques in Pro*C/C++ and contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="advanced-topics.html#GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616">Character Data </a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-84120650-DFD4-4623-B1ED-722CC4563DAC">Datatype Conversion </a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90">Datatype Equivalencing </a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2">The C Preprocessor</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B">Precompiled Header Files</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89">The Oracle Preprocessor</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-1C948990-B5FF-411D-BAC3-930E2FE82972">Evaluation of Numeric Constants</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-5A1F44A6-4B41-4610-B265-C56C85261379">SQLLIB Extensions for OCI Release 8 Interoperability</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">Interface to OCI Release 8</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45">Embedded OCI Release 7 Calls </a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">New Names for SQLLIB Public Functions</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207">X/Open Application Development</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3254"></a><div class="props_rev_3"><a id="GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616" name="GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616"></a><h3 id="LNPCC-GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616" class="sect3"><span class="enumeration_section">5.1 </span>Character Data 
               </h3>
               <div>
                  <p>This section explains how the Pro*C/C++ Precompiler handles character host variables. There are four host variable character types: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Character arrays </p>
                     </li>
                     <li>
                        <p>Pointers to strings </p>
                     </li>
                     <li>
                        <p>VARCHAR variables </p>
                     </li>
                     <li>
                        <p>Pointers to VARCHARs </p>
                     </li>
                  </ul>
                  <p>Do not confuse VARCHAR (a host variable data structure supplied by the precompiler) with VARCHAR2 (an Oracle internal datatype for variable-length character strings). </p>
               </div><a id="LNPCC3256"></a><a id="LNPCC3255"></a><div class="props_rev_3"><a id="GUID-B1D5E862-13FA-429B-9492-40785377256E" name="GUID-B1D5E862-13FA-429B-9492-40785377256E"></a><h4 id="LNPCC-GUID-B1D5E862-13FA-429B-9492-40785377256E" class="sect4"><span class="enumeration_section">5.1.1 </span>Precompiler Option CHAR_MAP
                  </h4>
                  <div>
                     <p>The CHAR_MAP precompiler option is available to specify the default mapping of char[n] and char host variables. Oracle maps them to CHARZ. CHARZ implements the ANSI Fixed Character format. Strings are fixed-length, blank-padded and null-terminated. VARCHAR2 values (including nulls) are always fixed-length and blank-padded. <a href="advanced-topics.html#GUID-B1D5E862-13FA-429B-9492-40785377256E__BABIDDHA" title="CHAR_MAP Settings">Table 5-1</a> shows the possible settings of CHAR_MAP:
                     </p>
                     <div class="tblformal" id="GUID-B1D5E862-13FA-429B-9492-40785377256E__BABIDDHA">
                        <p class="titleintable">Table 5-1 CHAR_MAP Settings</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="CHAR_MAP Settings" summary="CHAR_MAP Settings" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e137">CHAR_MAP Setting</th>
                                 <th align="left" valign="bottom" width="23%" id="d24171e140">Is Default for</th>
                                 <th align="left" valign="bottom" width="48%" id="d24171e143">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e148" headers="d24171e137 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e148 d24171e140 ">
                                    <p>-</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e148 d24171e143 ">
                                    <p>All values (including null) are fixed-length blank-padded.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e158" headers="d24171e137 ">
                                    <p>CHARZ</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e158 d24171e140 ">
                                    <p>DBMS=V7, DBMS=V8</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e158 d24171e143 ">
                                    <p>Fixed-length blank-padded, then null-terminated. Conforms to the ANSI Fixed Character type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e168" headers="d24171e137 ">
                                    <p>STRING</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e168 d24171e140 ">
                                    <p>New format</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e168 d24171e143 ">
                                    <p>null-terminated. Conforms to ASCII format used in C programs.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e178" headers="d24171e137 ">
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e178 d24171e140 ">
                                    <p>Previously, only through VAR or TYPE declarations.</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e178 d24171e143 ">
                                    <p>Fixed-length blank-padded. null is left unpadded. </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>The default mapping is CHAR_MAP=CHARZ, which was the case in previous versions of Pro*C/C++. </p>
                     <p>Use CHAR_MAP=VARCHAR2 instead of the old DBMS=V6_CHAR, which is obsolete.</p>
                  </div>
               </div><a id="LNPCC3257"></a><div class="props_rev_3"><a id="GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF" name="GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF"></a><h4 id="LNPCC-GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF" class="sect4"><span class="enumeration_section">5.1.2 </span>Inline Usage of the CHAR_MAP Option
                  </h4>
                  <div>
                     <p>Unless you declared a char or char[n] variable otherwise, the inline CHAR_MAP option determines its mapping. The following code fragment illustrates the results of setting this option inline in Pro*C/C++:</p><pre class="oac_no_warn" dir="ltr">char ch_array[5];

strncpy(ch_array, "12345", 5);
/* char_map=charz is the default in Oracle7 and Oracle8 */
EXEC ORACLE OPTION (char_map=charz);
/* Select retrieves a string "AB" from the database */
SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { 'A', 'B', ' ', ' ', '\0' } */

strncpy (ch_array, "12345", 5);
EXEC ORACLE OPTION (char_map=string) ;
/* Select retrieves a string "AB" from the database */
EXEC SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { 'A', 'B', '\0', '4', '5' } */

strncpy( ch_array, "12345", 5);
EXEC ORACLE OPTION (char_map=charf);
/* Select retrieves a string "AB" from the database */
EXEC SQL SELECT ... INTO :ch_array FROM ... WHERE ... ;
/* ch_array == { 'A', 'B', ' ', ' ', ' ' } */ 
</pre></div>
               </div><a id="LNPCC3258"></a><div class="props_rev_3"><a id="GUID-496E3205-71A3-44D6-91A5-0523903E24B9" name="GUID-496E3205-71A3-44D6-91A5-0523903E24B9"></a><h4 id="LNPCC-GUID-496E3205-71A3-44D6-91A5-0523903E24B9" class="sect4"><span class="enumeration_section">5.1.3 </span>Effect of the DBMS and CHAR_MAP Options
                  </h4>
                  <div>
                     <p>The DBMS and CHAR_MAP options determine how Pro*C/C++ treats data in character arrays and strings. These options allow your program to observe compatibility with ANSI fixed-length strings, or to maintain compatibility with previous releases of Oracle and Pro*C/C++ that use variable-length strings. </p>
                     <p>The DBMS option affects character data both on input (from your host variables to the Oracle table) and on output (from an Oracle table to your host variables). </p>
                     <p><span class="bold">Character Array and the CHAR_MAP Option</span></p>
                     <p>The mapping of character arrays can also be set by the CHAR_MAP option independent of the DBMS option. DBMS=V7 or DBMS=V8 both use CHAR_MAP=CHARZ, which can be overridden by specifying either CHAR_MAP=VARCHAR2 or STRING or CHARF.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">Precompiler Options</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC3260"></a><a id="LNPCC3261"></a><a id="LNPCC3259"></a><div class="props_rev_3"><a id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E" name="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E"></a><h5 id="LNPCC-GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E" class="sect5"><span class="enumeration_section">5.1.3.1 </span>On Input
                     </h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E__GUID-9619F88A-1CA4-46BB-B1B2-893A2777F9BF">Character Array</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>On input, the DBMS option determines the format that a host variable character array must have in your program. When the CHAR_MAP=VARCHAR2, host variable character arrays must be blank padded, and should not be null-terminated. When the DBMS=V7 or V8, character arrays must be null-terminated ('\0'). </p>
                           <p>When the CHAR_MAP option is set to VARCHAR2 trailing blanks are removed up to the first non-blank character before the value is sent to the database. An un-initialized character array can contain null characters. To make sure that the nulls are not inserted into the table, you must blank-pad the character array to its length. For example, if you execute the statements:</p><pre class="oac_no_warn" dir="ltr">char emp_name[10]; 
... 
strcpy(emp_name, "MILLER");     /* WRONG! Note no blank-padding */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre><p>you will find that the string "MILLER" was inserted as "MILLER\0\0\0\0" (with four null bytes appended to it). This value does not meet the following search condition: </p><pre class="oac_no_warn" dir="ltr">. . . WHERE ename = 'MILLER'; 
</pre><p>To INSERT the character array when CHAR_MAP is set to VARCHAR2, you should execute the statements </p><pre class="oac_no_warn" dir="ltr">strncpy(emp_name, "MILLER    ", 10); /* 4 trailing blanks */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre><p>When DBMS=V7 or V8, input data in a character array must be null-terminated. So, make sure that your data ends with a null. </p><pre class="oac_no_warn" dir="ltr">char emp_name[11];  /* Note: one greater than column size of 10 */ 
... 
strcpy(emp_name, "MILLER");        /* No blank-padding required */ 
EXEC SQL INSERT INTO emp (empno, ename, deptno) VALUES 
    (1234, :emp_name, 20); 
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E__GUID-AD18EF65-F221-4168-A596-A4056EA834F6">Character Pointer</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The pointer must address a null-terminated buffer that is large enough to hold the input data. Your program must allocate enough memory to do this.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3262"></a><div class="props_rev_3"><a id="GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B" name="GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B"></a><h5 id="LNPCC-GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B" class="sect5"><span class="enumeration_section">5.1.3.2 </span>On Input
                     </h5>
                     <div>
                        <p>The following example illustrates all possible combinations of the effects of the CHAR_MAP option settings on the value retrieved from a database into a character array.</p>
                        <p>Assume a database</p><pre class="oac_no_warn" dir="ltr">TABLE strdbase ( ..., strval VARCHAR2(6));
</pre><p>which contains the following strings in the column strval:</p><pre class="oac_no_warn" dir="ltr">""        -- string of length 0
"AB"      -- string of length 2
"KING"    -- string of length 4
"QUEEN"   -- string of length 5
"MILLER"  -- string of length 6
</pre><p>In a Pro*C/C++ program, initialize the 5-character host array<span class="italic"> str </span>with 'X' characters and use for the retrieval of all the values in column strval:
                        </p><pre class="oac_no_warn" dir="ltr">char  str[5] = {'X', 'X', 'X','X', 'X'} ;
short str_ind;
...
EXEC SQL SELECT strval INTO :str:str_ind WHERE ... ;
</pre><p>with the following results for the array, str, and the indicator variable, str_ind, as CHAR_MAP is set to VARCHAR2, CHARF, CHARZ and STRING:</p><pre class="oac_no_warn" dir="ltr">
strval = ""         "AB"       "KING"     "QUEEN"    "MILLER"
---------------------------------------------------------------
VARCHAR2 "     " -1 "AB   " 0  "KING "  0 "QUEEN"  0 "MILLE"  6
CHARF    "XXXXX" -1 "AB   " 0  "KING "  0 "QUEEN"  0 "MILLE"  6
CHARZ    "    0" -1 "AB  0" 0  "KING0"  0 "QUEE0"  5 "MILL0"  6
STRING   "0XXXX" -1 "AB0XX" 0  "KING0"  0 "QUEE0"  5 "MILL0"  6
</pre><p>where 0 stands for the null character, '\0'. </p>
                     </div>
                  </div><a id="LNPCC3264"></a><a id="LNPCC3265"></a><a id="LNPCC3263"></a><div class="props_rev_3"><a id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C" name="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C"></a><h5 id="LNPCC-GUID-F16E2C92-C93B-403E-8B14-EE32781B441C" class="sect5"><span class="enumeration_section">5.1.3.3 </span>On Output
                     </h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-FE2AFA92-4A3A-40EB-84D8-F19B146A4F48">Character Array</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>On output, the DBMS and CHAR_MAP options determines the format that a host variable character array will have in your program. When CHAR_MAP=VARCHAR2, host variable character arrays are blank padded up to the length of the array, but never null-terminated. When DBMS=V7 or V8 (or CHAR_MAP=CHARZ), character arrays are blank padded, then null-terminated in the final position in the array. </p>
                           <p>Consider the following example of character output: </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE test_char (C_col CHAR(10), V_col VARCHAR2(10)); 
 
INSERT INTO test_char VALUES ('MILLER', 'KING'); 
</pre><p>A precompiler program to select from this table contains the following embedded SQL: </p><pre class="oac_no_warn" dir="ltr">... 
char name1[10]; 
char name2[10]; 
... 
EXEC SQL SELECT C_col, V_col INTO :name1, :name2 
    FROM test_char; 
</pre><p>If you precompile the program with CHAR_MAP=VARCHAR2, <span class="italic">name1</span> will contain: 
                           </p><pre class="oac_no_warn" dir="ltr">"MILLER####" 
</pre><p>that is, the name "MILLER" followed by 4 blanks, with no null-termination. (If <span class="italic">name1</span> had been declared with a size of 15, there are 9 blanks following the name.) 
                           </p>
                           <p><span class="italic">name2</span> will contain: 
                           </p><pre class="oac_no_warn" dir="ltr">"KING######"      /* 6 trailing blanks */ 
</pre><p>If you precompile the program with DBMS=V7 or V8, <span class="italic">name1</span> will contain: 
                           </p><pre class="oac_no_warn" dir="ltr">"MILLER###\0" /* 3 trailing blanks, then a null-terminator */ 
</pre><p>that is, a string containing the name, blank-padded to the length of the column, followed by a null terminator. <span class="italic">name2</span> will contain: 
                           </p><pre class="oac_no_warn" dir="ltr">"KING#####\0" 
</pre><p>In summary, if CHAR_MAP=VARCHAR2, the output from either a CHARACTER column or a VARCHAR2 column is blank-padded to the length of the host variable array. If DBMS=V7 or V8, the output string is always null-terminated. </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-78A881CA-6481-4B5D-B858-8AF5EF703E1C">Character Pointer</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The DBMS and CHAR_MAP options do not affect the way character data are output to a pointer host variable. </p>
                           <p>When you output data to a character pointer host variable, the pointer must point to a buffer large enough to hold the output from the table, plus one extra byte to hold a null terminator. </p>
                           <p>The precompiler runtime environment calls <code class="codeph">strlen()</code> to determine the size of the output buffer, so make sure that the buffer does not contain any embedded nulls ('\0'). Fill allocated buffers with some value other than '\0', then null-terminate the buffer, before fetching the data. 
                           </p>
                           <div class="infoboxnote" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-4A7CF79C-EDFE-4DBE-AC07-B0D5E80EB2B9">
                              <p class="notep1">Note:</p>
                              <p>C pointers can be used in a Pro*C/C++ program that is precompiled with DBMS=V7 or V8 and MODE=ANSI. However, pointers are not legal host variable types in a SQL standard compliant program. The FIPS flagger warns you if you use pointers as host variables. <a id="d24171e380" class="indexterm-anchor"></a></p>
                           </div>
                           <p>The following code fragment uses the columns and table defined in the previous section, and shows how to declare and SELECT into character pointer host variables: </p><pre class="oac_no_warn" dir="ltr">... 
char *p_name1; 
char *p_name2; 
... 
p_name1 = (char *) malloc(11); 
p_name2 = (char *) malloc(11); 
strcpy(p_name1, "          "); 
strcpy(p_name2, "0123456789"); 
 
EXEC SQL SELECT C_col, V_col INTO :p_name1, :p_name2 
    FROM test_char; 
</pre><p>When the SELECT statement mentioned earlier is executed with any DBMS or CHAR_MAP setting, the value fetched is: </p><pre class="oac_no_warn" dir="ltr">"MILLER####\0"     /* 4 trailing blanks and a null terminator */ 
 
"KING######\0"    /* 6 blanks and null */ 
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3266"></a><div class="props_rev_3"><a id="GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498" name="GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498"></a><h4 id="LNPCC-GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498" class="sect4"><span class="enumeration_section">5.1.4 </span>VARCHAR Variables and Pointers 
                  </h4>
                  <div>
                     <p>The following example shows how VARCHAR host variables are declared: <a id="d24171e403" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">VARCHAR   emp_name1[10];   /* VARCHAR variable   */ 
VARCHAR  *emp_name2;       /* pointer to VARCHAR */</pre></div><a id="LNPCC3268"></a><a id="LNPCC3269"></a><a id="LNPCC3267"></a><div class="props_rev_3"><a id="GUID-FDC22564-2421-459E-A27A-35574AF36566" name="GUID-FDC22564-2421-459E-A27A-35574AF36566"></a><h5 id="LNPCC-GUID-FDC22564-2421-459E-A27A-35574AF36566" class="sect5"><span class="enumeration_section">5.1.4.1 </span>On Input
                     </h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-FDC22564-2421-459E-A27A-35574AF36566__GUID-12731BD2-E774-49C6-8CFC-7064D689DE48">VARCHAR Variables</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>When you use a VARCHAR variable as an input host variable, your program need only place the desired string in the array member of the expanded VARCHAR declaration (<span class="italic">emp_name1.arr</span> in our example) and set the length member (<span class="italic">emp_name1.len</span>). There is no need to blank-pad the array. Exactly <span class="italic">emp_name1.len</span> characters are sent to Oracle, counting any blanks and nulls. In the following example, you set <span class="italic">emp_name1.len</span> to 8: 
                           </p><pre class="oac_no_warn" dir="ltr">strcpy((char *)emp_name1.arr, "VAN HORN"); 
emp_name1.len = strlen((char *)emp_name1.arr); 
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-FDC22564-2421-459E-A27A-35574AF36566__GUID-2BBF9C9D-4BBA-4343-A082-FA91E3B4955E">Pointer to a VARCHAR</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>When you use a pointer to a VARCHAR as an input host variable, you must allocate enough memory for the expanded VARCHAR declaration. Then, you must place the desired string in the array member and set the length member, as shown in the following example: </p><pre class="oac_no_warn" dir="ltr">emp_name2 = malloc(sizeof(short) + 10)   /* len + arr */ 
strcpy((char *)emp_name2-&gt;arr, "MILLER"); 
emp_name2-&gt;len = strlen((char *)emp_name2-&gt;arr); 
</pre><p>Or, to make <span class="italic">emp_name2</span> point to an existing VARCHAR (<span class="italic">emp_name1</span> in this case), you could code the assignment 
                           </p><pre class="oac_no_warn" dir="ltr">emp_name2 = &amp;emp_name1;
 </pre><p>then use the VARCHAR pointer in the usual way, as in </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP (EMPNO, ENAME, DEPTNO) 
â€ƒ   VALUES (:emp_number, :emp_name2, :dept_number); 
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3271"></a><a id="LNPCC3272"></a><a id="LNPCC3270"></a><div class="props_rev_3"><a id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599" name="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599"></a><h5 id="LNPCC-GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599" class="sect5"><span class="enumeration_section">5.1.4.2 </span>On Output
                     </h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599__GUID-8D0CADBB-34A7-4E52-84B1-6F37FDAD1C14">VARCHAR Variables</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>When you use a VARCHAR variable as an output host variable, the program interface sets the length member but does <span class="italic">not</span> null-terminate the array member. As with character arrays, your program can null-terminate the <span class="italic">arr</span> member of a VARCHAR variable before passing it to a function such as <code class="codeph">printf()</code> or <code class="codeph">strlen()</code>. An example follows: 
                           </p><pre class="oac_no_warn" dir="ltr">emp_name1.arr[emp_name1.len] = '\0'; 
printf("%s", emp_name1.arr); 
</pre><p>Or, you can use the length member to limit the printing of the string, as in: </p><pre class="oac_no_warn" dir="ltr">printf("%.*s", emp_name1.len, emp_name1.arr); 
</pre><p>An advantage of VARCHAR variables over character arrays is that the length of the value returned by Oracle is available immediately. With character arrays, you might need to strip the trailing blanks yourself to get the actual length of the character string.<a id="d24171e499" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599__GUID-3DBF4759-843F-405E-BB15-8CD1AFFBCEA0">VARCHAR Pointers</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>When you use a pointer to a VARCHAR as an output host variable, the program interface determines the variable's maximum length by checking the length member (<span class="italic">emp_name2-&gt;len</span> in our example). So, your program must set this member before <span class="italic">every</span> fetch. The fetch then sets the length member to the actual number of characters returned, as the following example shows: 
                           </p><pre class="oac_no_warn" dir="ltr">emp_name2-&gt;len = 10;  /* Set maximum length of buffer. */ 
EXEC SQL SELECT ENAME INTO :emp_name2 WHERE EMPNO = 7934; 
printf("%d characters returned to emp_name2", emp_name2-&gt;len);
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3273"></a><div class="props_rev_3"><a id="GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3" name="GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3"></a><h4 id="LNPCC-GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3" class="sect4"><span class="enumeration_section">5.1.5 </span>Unicode Variables
                  </h4>
                  <div>
                     <p>Pro*C/C++ allows fixed-width Unicode data (character set Unicode Standard Version 3.0, known simply as UCS-16) in host <code class="codeph">char</code> variables. UCS-16 uses 2 bytes for each character, so it is an unsigned 2-byte datatype. SQL statement text in UCS-16 is not supported yet. 
                     </p>
                     <p>In the following example code a host variable, <code class="codeph">employee</code>, of the Unicode type <span class="italic">utext</span> is declared to be 20 Unicode characters long. A table <code class="codeph">emp</code> is created containing the column <code class="codeph">ename</code>, which is 60 bytes long, so that database character sets in Asian languages, where multibyte characters are up to three bytes long, will be supported. 
                     </p><pre class="oac_no_warn" dir="ltr">utext employee[20] ;                               /* Unicode host variable   */
EXEC SQL CREATE TABLE emp (ename CHAR(60));
/* ename is in the current database character set  */                                        
EXEC SQL INSERT INTO emp (ename) VALUES ('test') ; 
/* 'test' in NLS_LANG encoding converted to database character set */
EXEC SQL SELECT * INTO :employee FROM emp ;       
/* Database character set converted to Unicode */
</pre><p>A public header file, sqlucs2.h, must be included in your application code. It does the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Contains the statement:</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">    #include &lt;oratypes.h&gt;
</pre><ul style="list-style-type: disc;">
                        <li>
                           <p>Defines a "Unicode varchar", uvarchar, as:</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">    struct uvarchar
    {
       ub2 len;
       utext arr[1] ;
    };
    typedef struct uvarchar uvarchar ;
</pre><ul style="list-style-type: disc;">
                        <li>
                           <p>Defines a "Unicode long varchar", ulong_varchar, as:</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">    struct ulong_varchar
    {
       ub4 len ;
       utext arr[1] ;
    }
    typedef struct ulong_varchar ulong_varchar ;
</pre><p>The default datatype of utext is the same as the default for any character variables, CHARZ, which is blank-padded and null-terminated. </p>
                     <p>Use the CHAR_MAP precompiler option to change the default datatype, as follows:</p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt;
#include &lt;sqlucs2.h&gt;

main()
{
   utext employee1[20] ;

/* Change to STRING datatype:    */
   EXEC ORACLE OPTION (CHAR_MAP=STRING) ;
   utext employee2[20] ;

   EXEC SQL CREATE TABLE emp (ename CHAR(60)) ;
   ...
/***********************************************************  
  Initializing employee1 or employee2 is compiler-dependent.   
 **********************************************************/
   EXEC SQL INSERT INTO emp (ename) VALUES (:employee1) ;
   ...
   EXEC SQL SELECT ename INTO :employee2 FROM emp;
/* employee2 is now not blank-padded and is null-terminated  */
   ...</pre></div><a id="LNPCC3274"></a><div class="props_rev_3"><a id="GUID-621A2720-9724-400D-94DD-A42A08C10955" name="GUID-621A2720-9724-400D-94DD-A42A08C10955"></a><h5 id="LNPCC-GUID-621A2720-9724-400D-94DD-A42A08C10955" class="sect5"><span class="enumeration_section">5.1.5.1 </span>Restrictions on Unicode Variable Usage
                     </h5>
                     <div>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Static and dynamic SQL cannot contain Unicode in the SQL statement text. The following is <span class="italic">not</span> permitted:
                              </p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">#include oratypes.h
utext sqlstmt[100] ;
...
/* If sqlstmt contains a SQL statement: */
EXEC SQL PREPARE s1 FROM :sqlstmt ;
EXEC SQL EXECUTE IMMEDIATE :sqlstmt ;
...
</pre><ul style="list-style-type: disc;">
                           <li>
                              <p>You cannot use type equivalencing for utext variables. The following code is <span class="italic">not</span> permitted:
                              </p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">    typedef utext utext_5 ;
    EXEC SQL TYPE utext_5 IS STRING ;
</pre><ul style="list-style-type: disc;">
                           <li>
                              <p>CONVBUFSZ cannot be used as a conversion buffer size. Use the CHAR_MAP option instead.</p>
                           </li>
                           <li>
                              <p>Oracle dynamic SQL method 4 does not support Unicode.</p>
                           </li>
                           <li>
                              <p>Object types do not support Unicode. </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="datatypes-and-host-variables.html#GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D">CONVBUFSZ Clause in VAR</a></li>
                              <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI Dynamic SQL</a></li>
                              <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="LNPCC3275"></a><div class="props_rev_3"><a id="GUID-84120650-DFD4-4623-B1ED-722CC4563DAC" name="GUID-84120650-DFD4-4623-B1ED-722CC4563DAC"></a><h3 id="LNPCC-GUID-84120650-DFD4-4623-B1ED-722CC4563DAC" class="sect3"><span class="enumeration_section">5.2 </span>Datatype Conversion 
               </h3>
               <div>
                  <p>At precompile time, a default external datatype is assigned to each host variable. For example, the precompiler assigns the INTEGER external datatype to host variables of type <span class="bold">short int</span> and <span class="bold">int</span>. 
                  </p>
                  <p>At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes. </p>
                  <p>Before assigning a SELECTed column (or pseudocolumn) value to an output host variable, Oracle must convert the internal datatype of the source column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a column, Oracle must convert the external datatype of the host variable to the internal datatype of the target column.<a id="d24171e664" class="indexterm-anchor"></a> 
                  </p>
                  <p>Conversions between internal and external datatypes follow the usual data conversion rules. For example, you can convert a CHAR value of "1234" to a C<span class="italic"> short</span> value. You cannot convert a CHAR value of "65543" (number too large) or "10F" (number not decimal) to a C <span class="italic">short</span> value. Likewise, you cannot convert a <code class="codeph">char[n]</code> value that contains any alphabetic characters to a NUMBER value. 
                  </p>
               </div>
            </div><a id="LNPCC3276"></a><div class="props_rev_3"><a id="GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90" name="GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90"></a><h3 id="LNPCC-GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90" class="sect3"><span class="enumeration_section">5.3 </span>Datatype Equivalencing 
               </h3>
               <div>
                  <p>Datatype equivalencing lets you control the way Oracle interprets input data, and the way Oracle formats output data. It provides the ability to override the default external datatypes that the precompiler assigns. On a variable-by-variable basis, you can map (or make equivalent) supported C host variable datatypes to Oracle external datatypes. You can also map user-defined datatypes to Oracle external datatypes. </p>
               </div><a id="LNPCC3278"></a><a id="LNPCC3277"></a><div class="props_rev_3"><a id="GUID-68F55764-855D-4549-B587-980F0534EFF6" name="GUID-68F55764-855D-4549-B587-980F0534EFF6"></a><h4 id="LNPCC-GUID-68F55764-855D-4549-B587-980F0534EFF6" class="sect4"><span class="enumeration_section">5.3.1 </span>Host Variable Equivalencing 
                  </h4>
                  <div>
                     <p>By default, the Pro*C/C++ Precompiler assigns a specific external datatype to every host variable. </p>
                     <p><a href="advanced-topics.html#GUID-68F55764-855D-4549-B587-980F0534EFF6__G449968" title="Default Type Assignments">Table 5-2</a> lists the default assignments:
                     </p>
                     <div class="tblformal" id="GUID-68F55764-855D-4549-B587-980F0534EFF6__G449968">
                        <p class="titleintable">Table 5-2  Default Type Assignments</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title=" Default Type Assignments" summary="Default Type Assignments" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d24171e727">C Type, or Pseudotype</th>
                                 <th align="left" valign="bottom" width="26%" id="d24171e730">Oracle External Type</th>
                                 <th align="left" valign="bottom" width="38%" id="d24171e733">Notes</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e738" headers="d24171e727 ">
                                    <p>char</p>
                                    <p>char[n]</p>
                                    <p>char*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e738 d24171e730 ">
                                    <p>VARCHAR2</p>
                                    <p>CHARZ</p>
                                    <p>STRING</p>
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e738 d24171e733 ">
                                    <p>(CHAR_MAP=VARCHAR2)</p>
                                    <p>(DBMS=V7, V8 default)</p>
                                    <p>(CHAR_MAP=STRING)</p>
                                    <p>(CHAR_MAP=CHARF)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e764" headers="d24171e727 ">
                                    <p>int, int*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e764 d24171e730 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e764 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e774" headers="d24171e727 ">
                                    <p>short, short*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e774 d24171e730 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e774 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e784" headers="d24171e727 ">
                                    <p>long, long*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e784 d24171e730 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e784 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e794" headers="d24171e727 ">
                                    <p>long long, long long*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e794 d24171e730 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e794 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e804" headers="d24171e727 ">
                                    <p>float, float*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e804 d24171e730 ">
                                    <p>FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e804 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e814" headers="d24171e727 ">
                                    <p>double, double*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e814 d24171e730 ">
                                    <p>FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e814 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e824" headers="d24171e727 ">
                                    <p>VARCHAR*, VARCHAR[n]</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e824 d24171e730 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e824 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>With the VAR statement, you can override the default assignments by equivalencing host variables to Oracle external datatypes. The syntax you use is<a id="d24171e835" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL VAR host_variable IS type_name [ (length) ]; 
</pre><p>where <span class="italic">host_variable</span> is an input or output host variable (or host array) declared earlier, <span class="italic">type_name</span> is the name of a valid external datatype, and <span class="italic">length</span> is an integer literal specifying a valid length in bytes. 
                     </p>
                     <p>Host variable equivalencing is useful in several ways. For example, suppose you want to SELECT employee names from the EMP table, then pass them to a routine that expects null-terminated strings. You need not explicitly null-terminate the names. Simply equivalence a host variable to the STRING external datatype, as follows: </p><pre class="oac_no_warn" dir="ltr">... 
char  emp_name[11]; 
EXEC SQL VAR emp_name IS STRING(11); 
</pre><p>The length of the ENAME column in the EMP table is 10 characters, so you allot the new <span class="italic">emp_name</span> 11 characters to accommodate the null terminator. When you SELECT a value from the ENAME column into <span class="italic">emp_name</span>, the program interface null-terminates the value for you. 
                     </p>
                     <p>You can use any external datatypes except NUMBER (for example, VARNUM).</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952">External Datatypes</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3279"></a><div class="props_rev_3"><a id="GUID-F62EEF33-4BCC-472C-B812-5C257333FE50" name="GUID-F62EEF33-4BCC-472C-B812-5C257333FE50"></a><h4 id="LNPCC-GUID-F62EEF33-4BCC-472C-B812-5C257333FE50" class="sect4"><span class="enumeration_section">5.3.2 </span>User-Defined Type Equivalencing 
                  </h4>
                  <div>
                     <p>You can also map (or make equivalent) user-defined datatypes to Oracle external datatypes. First, define a new datatype structured like the external datatype that suits your needs. Then, map your new datatype to the external datatype using the TYPE statement. </p>
                     <p>With the TYPE statement, you can assign an Oracle external datatype to a whole class of host variables. The syntax you use is:<a id="d24171e889" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL TYPE user_type IS type_name [ (length) ] [REFERENCE]; 
</pre><p>Suppose you need a variable-length string datatype to hold graphics characters. First, declare a struct with a <span class="bold">short</span> length component followed by a 65533-byte data component. Second, use <span class="bold">typedef</span> to define a new datatype based on the struct. Then, equivalence your new user-defined datatype to the VARRAW external datatype, as shown in the following example: 
                     </p><pre class="oac_no_warn" dir="ltr">struct  screen 
{ 
    short  len; 
    char   buff[4000]; 
}; 
typedef struct screen graphics; 

EXEC SQL TYPE graphics IS VARRAW(4000); 
graphics  crt;  â€” host variable of type graphics 
â€ƒ   ... 
</pre><p>You specify a length of 4000 bytes for the new <span class="italic">graphics</span> type because that is the maximum length of the data component in your struct. The precompiler allows for the <span class="italic">len</span> component (and any padding) when it sends the length to the Oracle server. 
                     </p>
                  </div><a id="LNPCC3280"></a><div class="props_rev_3"><a id="GUID-406E4486-1ADF-4090-BE20-F53185EC7C85" name="GUID-406E4486-1ADF-4090-BE20-F53185EC7C85"></a><h5 id="LNPCC-GUID-406E4486-1ADF-4090-BE20-F53185EC7C85" class="sect5"><span class="enumeration_section">5.3.2.1 </span>REFERENCE Clause    
                     </h5>
                     <div>
                        <p>You can declare a user-defined type to be a pointer, either explicitly, as a pointer to a scalar or struct type, or implicitly, as an array, and use this type in an EXEC SQL TYPE statement. In this case, you must use the REFERENCE clause at the end of the statement, as shown in the following example: <a id="d24171e925" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">typedef unsigned char *my_raw; 
 
EXEC SQL TYPE my_raw IS VARRAW(4000) REFERENCE; 
my_raw    graphics_buffer; 
... 
graphics_buffer = (my_raw) malloc(4004); 
</pre><p>In this example, you allocated additional memory over the type length (4000). This is necessary because the precompiler also returns the length (the size of a <span class="italic">short</span>), and can add padding after the length due to word alignment restrictions on your system. If you do not know the alignment practices on your system, make sure to allocate sufficient extra bytes for the length and padding (9 should usually be sufficient). 
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="datatypes-and-host-variables.html#GUID-FA7D1173-C17F-4740-8E96-CB087D29394F">Example Program: Using sqlvcp()</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC3281"></a><div class="props_rev_3"><a id="GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47" name="GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47"></a><h4 id="LNPCC-GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47" class="sect4"><span class="enumeration_section">5.3.3 </span>CHARF External Datatype     
                  </h4>
                  <div>
                     <p><a id="d24171e956" class="indexterm-anchor"></a>CHARF is a fixed-length character string. You can use this datatype in VAR and TYPE statements to equivalence C datatypes to the fixed-length SQL standard datatype CHAR, regardless of the setting of the DBMS or CHAR_MAP option.
                     </p>
                     <p>When DBMS=V7 or V8, specifying the external datatype CHARACTER in a VAR or TYPE statement equivalences the C datatype to the fixed-length datatype CHAR (datatype code 96). However, when CHAR_MAP=VARCHAR2, the C datatype is equivalenced to the variable-length datatype VARCHAR2 (code 1).<a id="d24171e961" class="indexterm-anchor"></a><a id="d24171e963" class="indexterm-anchor"></a></p>
                     <p>Now, you can always equivalence C datatypes to the fixed-length SQL standard type CHARACTER by using the CHARF datatype in the VAR or TYPE statement. When you use CHARF, the equivalence is always made to the fixed-length character type, regardless of the setting of the DBMS or CHAR_MAP option.</p>
                  </div>
               </div><a id="LNPCC3282"></a><div class="props_rev_3"><a id="GUID-E3596E74-4425-40CD-8C06-F6891E1534C0" name="GUID-E3596E74-4425-40CD-8C06-F6891E1534C0"></a><h4 id="LNPCC-GUID-E3596E74-4425-40CD-8C06-F6891E1534C0" class="sect4"><span class="enumeration_section">5.3.4 </span>The EXEC SQL VAR and TYPE Directives
                  </h4>
                  <div>
                     <p>You can code an EXEC SQL VAR ... or EXEC SQL TYPE ... statement anywhere in your program. These statements are treated as executable statements that change the datatype of any variable affected by them from the point that the TYPE or VAR statement was made to the end of the scope of the variable. If you precompile with MODE=ANSI, you must use Declare Sections. In this case, the TYPE or VAR statement must be in a Declare Section.<a id="d24171e978" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-ADB0F592-9859-42A7-B89A-F6BB6E7BC6BA">TYPE (Oracle Embedded SQL Directive)</a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-E8C91676-9AED-4D25-99F2-C3A38E4D0129">VAR (Oracle Embedded SQL Directive)</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3283"></a><div class="props_rev_3"><a id="GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789" name="GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789"></a><h4 id="LNPCC-GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789" class="sect4"><span class="enumeration_section">5.3.5 </span>Example: Datatype Equivalencing (sample4.pc):
                  </h4>
                  <div>
                     <p>The demonstration program in this section shows you how you can use datatype equivalencing in your Pro*C/C++ programs. This program is available as <code class="codeph">sample4.pc</code> in the <code class="codeph">dem</code>o directory.It demonstrates the use of type equivalencing using the LONG VARRAW external datatype. In order to provide a useful example that is portable across different systems, the program inserts binary files into and retrieves them from the database. 
                     </p>
                     <p>This program uses LOB embedded SQL statements. </p>
                     <p>Please read the introductory comments for an explanation of the program's purpose.</p><pre class="oac_no_warn" dir="ltr">/***************************************************************
sample4.pc
This program demonstrates the use of type equivalencing using the
LONG VARRAW external datatype. In order to provide a useful example
that is portable across different systems, the program inserts
binary files into and retrieves them from the database.  For
example, suppose you have a file called 'hello' in the current
directory.  You can create this file by compiling the following
source code:

#include &lt;stdio.h&gt;

int main()
{
  printf("Hello World!\n");
}

When this program is run, we get:

$hello
Hello World!

Here is some sample output from a run of sample4:

$sample4
Connected.
Do you want to create (or re-create) the EXECUTABLES table (y/n)? y
EXECUTABLES table successfully dropped.  Now creating new table...
EXECUTABLES table created.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: l

Executables           Length (bytes)
--------------------  --------------

Total Executables: 0

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: i
Enter the key under which you will insert this executable: hello
Enter the filename to insert under key 'hello'.
If the file is not in the current directory, enter the full
path: hello
Inserting file 'hello' under key 'hello'...
Inserted.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: l

Executables           Length (bytes)
--------------------  --------------
hello                           5508

Total Executables: 1

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: r
Enter the key for the executable you wish to retrieve: hello
Enter the file to write the executable stored under key hello into.  If you
don't want the file in the current directory, enter the
full path: h1
Retrieving executable stored under key 'hello' to file 'h1'...
Retrieved.

Sample 4 Menu.  Would you like to:
(I)nsert a new executable into the database
(R)etrieve an executable from the database
(L)ist the executables stored in the database
(D)elete an executable from the database
(Q)uit the program

Enter i, r, l, or q: q

We now have the binary file 'h1' created, and we can run it:

$h1
Hello World!
***************************************************************/

#include &lt;oci.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;

/* Oracle error code for 'table or view does not exist'. */
#define NON_EXISTENT  -942
#define NOT_FOUND     1403

/* This is the definition of the long varraw structure.
 * Note that the first field, len, is a long instead
 * of a short.  This is becuase the first 4
 * bytes contain the length, not the first 2 bytes.
 */
typedef struct long_varraw {
  ub4  len;
  text buf[1];
} long_varraw;


/* Type Equivalence long_varraw to LONG VARRAW.
 * All variables of type long_varraw from this point
 * on in the file will have external type 95 (LONG VARRAW)
 * associated with them.
 */
EXEC SQL TYPE long_varraw IS LONG VARRAW REFERENCE;


/* This program's functions declared. */
#if defined(__STDC__)
  void do_connect(void);
  void create_table(void);
  void sql_error(char *);
  void list_executables(void);
  void print_menu(void);
  void do_insert(varchar *, char *);
  void do_retrieve(varchar *, char *);
  void do_delete(varchar *);
  ub4  read_file(char *, OCIBlobLocator *);
  void write_file(char *, OCIBlobLocator *);
#else
  void do_connect(/*_ void _*/);
  void create_table(/*_ void _*/);
  void sql_error(/*_ char * _*/);
  void list_executables(/*_ void _*/);
  void print_menu(/*_ void _*/);
  void do_insert(/*_ varchar *, char * _*/);
  void do_retrieve(/*_ varchar *, char * _*/);
  void do_delete(/*_ varchar * _*/);
  ub4  read_file(/*_ char *, OCIBlobLocator * _*/);
  void write_file(/*_ char *, OCIBlobLocator * _*/);
#endif

void main()
{
  char reply[20], filename[100];
  varchar key[20];
  short ok = 1;

  /* Connect to the database. */
  do_connect();

  printf("Do you want to create (or re-create) the EXECUTABLES table (y/n)? ");
  gets(reply);

  if ((reply[0] == 'y') || (reply[0] == 'Y'))
    create_table();

  /* Print the menu, and read in the user's selection. */
  print_menu();
  gets(reply);

  while (ok)
  {
    switch(reply[0]) {
    case 'I': case 'i':
      /* User selected insert - get the key and file name. */
      printf("Enter the key under which you will insert this executable: ");
      key.len = strlen(gets((char *)key.arr));
      printf("Enter the filename to insert under key '%.*s'.\n",
             key.len, key.arr);
      printf("If the file is not in the current directory, enter the full\n");
      printf("path: ");
      gets(filename);
      do_insert((varchar *)&amp;key, filename);
      break;
    case 'R': case 'r':
      /* User selected retrieve - get the key and file name. */
      printf("Enter the key for the executable you wish to retrieve: ");
      key.len = strlen(gets((char *)key.arr));
      printf("Enter the file to write the executable stored under key ");
      printf("%.*s into.  If you\n", key.len, key.arr);
      printf("don't want the file in the current directory, enter the\n");
      printf("full path: ");
      gets(filename);
      do_retrieve((varchar *)&amp;key, filename);
      break;
    case 'L': case 'l':
      /* User selected list - just call the list routine. */
      list_executables();
      break;
    case 'D': case 'd':
      /* User selected delete - get the key for the executable to delete. */
      printf("Enter the key for the executable you wish to delete: ");
      key.len = strlen(gets((char *)key.arr));
      do_delete((varchar *)&amp;key);
      break;
    case 'Q': case 'q':
      /* User selected quit - just end the loop. */
      ok = 0;
      break;
    default:
      /* Invalid selection. */
      printf("Invalid selection.\n");
      break;
    }

    if (ok)
    {
      /* Print the menu again. */
      print_menu();
      gets(reply);
    }
  }

  EXEC SQL COMMIT WORK RELEASE;
}


/* Connect to the database. */
void do_connect()
{
  /* Note this declaration: uid is a char * pointer, so Oracle
     will do a strlen() on it at runtime to determine the length.
   */
  char *uid = "scott/tiger";

  EXEC SQL WHENEVER SQLERROR DO sql_error("do_connect():CONNECT");
  EXEC SQL CONNECT :uid;

  printf("Connected.\n");
}


/* Creates the executables table. */
void create_table()
{
  /* We are going to check for errors ourselves for this statement. */
  EXEC SQL WHENEVER SQLERROR CONTINUE;

  EXEC SQL DROP TABLE EXECUTABLES;
  if (sqlca.sqlcode == 0)
    {
      printf("EXECUTABLES table successfully dropped.  ");
      printf("Now creating new table...\n");
    }
  else if (sqlca.sqlcode == NON_EXISTENT)
    {
      printf("EXECUTABLES table does not exist.  ");
      printf("Now creating new table...\n");
    }
  else
    sql_error("create_table()"); 

  /* Reset error handler. */
  EXEC SQL WHENEVER SQLERROR DO sql_error("create_table():CREATE TABLE");

  EXEC SQL CREATE TABLE EXECUTABLES
    ( name VARCHAR2(30), length NUMBER(10), binary BLOB ) ;

  printf("EXECUTABLES table created.\n");
}

/* Opens the binary file identified by 'filename' for reading, and writes
   it into into a Binary LOB.  Returns the actual length of the file read.
 */
ub4 read_file(filename, blob)
  char *filename;
  OCIBlobLocator *blob;
{
  long_varraw *lvr;
  ub4      bufsize;
  ub4      amt;
  ub4      filelen, remainder, nbytes;
  ub4      offset = 1;
  boolean  last = FALSE;
  FILE    *in_fd;

  /* Open the file for reading. */
  in_fd = fopen(filename, "r");
  if (in_fd == (FILE *)0)
    return (ub4)0;

  /* Determine Total File Length - Total Amount to Write to BLOB */
  (void) fseek(in_fd, 0L, SEEK_END);
  amt = filelen = (ub4)ftell(in_fd);

  /* Determine the Buffer Size and Allocate the LONG VARRAW Object */
  bufsize = 2048;
  lvr = (long_varraw *)malloc(sizeof(ub4) + bufsize);

  nbytes = (filelen &gt; bufsize) ? bufsize : filelen;
      
  /* Reset the File Pointer and Perform the Initial Read */
  (void) fseek(in_fd, 0L, SEEK_SET);
  lvr-&gt;len = fread((void *)lvr-&gt;buf, (size_t)1, (size_t)nbytes, in_fd);
  remainder = filelen - nbytes;

  EXEC SQL WHENEVER SQLERROR DO sql_error("read_file():WRITE");

  if (remainder == 0)
    {
      /* Write the BLOB in a Single Piece */
      EXEC SQL LOB WRITE ONE :amt
         FROM :lvr WITH LENGTH :nbytes INTO :blob AT :offset;
    }
  else
    {
      /* Write the BLOB in Multiple Pieces using Standard Polling */
      EXEC SQL LOB WRITE FIRST :amt
         FROM :lvr WITH LENGTH :nbytes INTO :blob AT :offset;

      do {

        if (remainder &gt; bufsize)
          nbytes = bufsize;
        else
          {
            nbytes = remainder;
            last = TRUE;
          }

        if ((lvr-&gt;len = fread(
              (void *)lvr-&gt;buf, (size_t)1, (size_t)nbytes, in_fd)) != nbytes)
          last = TRUE;

        if (last)
          {
            /* Write the Final Piece */
            EXEC SQL LOB WRITE LAST :amt
               FROM :lvr WITH LENGTH :nbytes INTO :blob;
          }
        else
          {
            /* Write an Interim Piece - Still More to Write */
            EXEC SQL LOB WRITE NEXT :amt
               FROM :lvr WITH LENGTH :nbytes INTO :blob;  
          }

        remainder -= nbytes;

      } while (!last &amp;&amp; !feof(in_fd));
    }

  /* Close the file, and return the total file size. */
  fclose(in_fd);
  free(lvr);
  return filelen;
}


/* Generic error handler.  The 'routine' parameter should contain the name
   of the routine executing when the error occured.  This would be specified
   in the 'EXEC SQL WHENEVER SQLERROR DO sql_error()' statement.
 */
void sql_error(routine)
  char *routine;
{
  char message_buffer[512];
  size_t buffer_size;
  size_t message_length;

  /* Turn off the call to sql_error() to avoid a possible infinite loop */
  EXEC SQL WHENEVER SQLERROR CONTINUE;

  printf("\nOracle error while executing %s!\n", routine);

  /* Use sqlglm() to get the full text of the error message. */
  buffer_size = sizeof(message_buffer);
  sqlglm(message_buffer, &amp;buffer_size, &amp;message_length);
  printf("%.*s\n", message_length, message_buffer);

  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);
}


/* Opens the binary file identified by 'filename' for writing, and copies
   the contents of the Binary LOB into it.
 */
void write_file(filename, blob)
  char *filename;
  OCIBlobLocator *blob;
{
  FILE        *out_fd;       /* File descriptor for the output file */
  ub4          amt;
  ub4          bufsize;
  long_varraw *lvr;

  /* Determine the Buffer Size and Allocate the LONG VARRAW Object */
  bufsize = 2048;
  lvr = (long_varraw *)malloc(sizeof(ub4) + bufsize);

  /* Open the output file for Writing */
  out_fd = fopen(filename, "w");
  if (out_fd == (FILE *)0)
    return;

  amt = 0;             /* Initialize for Standard Polling (Possibly) */
  lvr-&gt;len = bufsize;                       /* Set the Buffer Length */

  EXEC SQL WHENEVER SQLERROR DO sql_error("write_file():READ");

  /* READ the BLOB using a Standard Polling Loop */
  EXEC SQL WHENEVER NOT FOUND DO break;
  while (TRUE)
    {
      EXEC SQL LOB READ :amt FROM :blob INTO :lvr WITH LENGTH :bufsize;
      (void) fwrite((void *)lvr-&gt;buf, (size_t)1, (size_t)lvr-&gt;len, out_fd);
    }
  
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  /* Write the Final Piece (or First and Only Piece if not Polling) */
  (void) fwrite((void *)lvr-&gt;buf, (size_t)lvr-&gt;len, (size_t)1, out_fd);

  /* Close the Output File and Return */
  fclose(out_fd);
  free(lvr);
  return;
}



/* Inserts the binary file identified by file into the
 * executables table identified by key.
 */
void do_insert(key, file)
  varchar *key;
  char *file;
{
  OCIBlobLocator *blob;
  ub4 loblen, fillen;

  EXEC SQL ALLOCATE :blob;

  EXEC SQL WHENEVER SQLERROR DO sql_error("do_insert():INSERT/SELECT");

  EXEC SQL SAVEPOINT PREINSERT;
  EXEC SQL INSERT
    INTO executables (name, length, binary) VALUES (:key, 0, empty_blob());

  EXEC SQL SELECT binary INTO :blob 
             FROM executables WHERE name = :key FOR UPDATE;

  printf(
    "Inserting file '%s' under key '%.*s'...\n", file, key-&gt;len, key-&gt;arr); 

  fillen = read_file(file, blob);
  EXEC SQL LOB DESCRIBE :blob GET LENGTH INTO :loblen;

  if ((fillen == 0) || (fillen != loblen))
    {
      printf("Problem reading file '%s'\n", file);
      EXEC SQL ROLLBACK TO SAVEPOINT PREINSERT;
      EXEC SQL FREE :blob;
      return;
    }

  EXEC SQL WHENEVER SQLERROR DO sql_error("do_insert():UPDATE");
  EXEC SQL UPDATE executables
    SET length = :loblen, binary = :blob WHERE name = :key;

  EXEC SQL COMMIT WORK;

  EXEC SQL FREE :blob;
  EXEC SQL COMMIT;
  printf("Inserted.\n");
}


/* Retrieves the executable identified by key into file */
void do_retrieve(key, file)
  varchar *key;
  char *file;
{
  OCIBlobLocator *blob;

  printf("Retrieving executable stored under key '%.*s' to file '%s'...\n",
         key-&gt;len, key-&gt;arr, file);

  EXEC SQL ALLOCATE :blob;

  EXEC SQL WHENEVER NOT FOUND continue;
  EXEC SQL SELECT binary INTO :blob FROM executables WHERE name = :key;

  if (sqlca.sqlcode == NOT_FOUND)
    printf("Key '%.*s' not found!\n", key-&gt;len, key-&gt;arr);
  else 
    {
      write_file(file, blob);
      printf("Retrieved.\n");
    }
 
  EXEC SQL FREE :blob;
}


/* Delete an executable from the database */
void do_delete(key)
  varchar *key;
{
  EXEC SQL WHENEVER SQLERROR DO sql_error("do_delete():DELETE");
  EXEC SQL DELETE FROM executables WHERE name = :key;

  if (sqlca.sqlcode == NOT_FOUND)
    printf("Key '%.*s' not found!\n", key-&gt;len, key-&gt;arr);
  else
    printf("Deleted.\n");
}


/* List all executables currently stored in the database */
void list_executables()
{
  char key[21];
  ub4  length;

  EXEC SQL WHENEVER SQLERROR DO sql_error("list_executables");

  EXEC SQL DECLARE key_cursor CURSOR FOR
    SELECT name, length FROM executables;

  EXEC SQL OPEN key_cursor;

  printf("\nExecutables           Length (bytes)\n");
  printf("--------------------  --------------\n");

  EXEC SQL WHENEVER NOT FOUND DO break;
  while (1)
  {
    EXEC SQL FETCH key_cursor INTO :key, :length;
    printf("%s      %10d\n", key, length);
  }

  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL CLOSE key_cursor;

  printf("\nTotal Executables: %d\n", sqlca.sqlerrd[2]);  
}


/* Prints the menu selections. */
void print_menu()
{
  printf("\nSample 4 Menu.  Would you like to:\n");
  printf("(I)nsert a new executable into the database\n");
  printf("(R)etrieve an executable from the database\n");
  printf("(L)ist the executables stored in the database\n");
  printf("(D)elete an executable from the database\n");
  printf("(Q)uit the program\n\n");
  printf("Enter i, r, l, or q: ");
}
</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">LOBs</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3284"></a><div class="props_rev_3"><a id="GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2" name="GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2"></a><h3 id="LNPCC-GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2" class="sect3"><span class="enumeration_section">5.4 </span>The C Preprocessor
               </h3>
               <div>
                  <p>Pro*C/C++ supports most C preprocessor directives. Some of the things that you can do using the Pro*C/C++ preprocessor are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Define constants and macros using the <span class="bold">#define</span> directive, and use the defined entities to parameterize Pro*C/C++ datatype declarations, such as VARCHAR
                        </p>
                     </li>
                     <li>
                        <p>Read files required by the precompiler, such as <code class="codeph">sqlca.h</code>, using the <span class="bold">#include</span> directive 
                        </p>
                     </li>
                     <li>
                        <p>Define constants and macros in a separate file, and have the precompiler read this file using the <span class="bold">#include </span>directive 
                        </p>
                     </li>
                  </ul>
               </div><a id="LNPCC3285"></a><div class="props_rev_3"><a id="GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60" name="GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60"></a><h4 id="LNPCC-GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60" class="sect4"><span class="enumeration_section">5.4.1 </span>How the Pro*C/C++ Preprocessor Works 
                  </h4>
                  <div>
                     <p>The Pro*C/C++ preprocessor recognizes most C preprocessor commands, and effectively performs the required macro substitutions, file inclusions, and conditional source text inclusions or exclusions. The Pro*C/C++ preprocessor uses the values obtained from preprocessing, and alters the source output text (the generated <code class="codeph">.c</code> output file).
                     </p>
                     <p>An example should clarify this point. Consider the following program fragment: <a id="d24171e1095" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">#include "my_header.h" 
... 
VARCHAR name[VC_LEN];              /* a Pro*C-supplied datatype */ 
char    another_name[VC_LEN];              /* a pure C datatype */
... 
</pre><p>Suppose the file <code class="codeph">my_header.h</code> in the current directory contains, among other things, the line 
                     </p><pre class="oac_no_warn" dir="ltr">#define VC_LEN   20 
</pre><p>The precompiler reads the file <code class="codeph">my_header.h</code>, and uses the defined value of VC_LEN (20), declares the structure of <span class="italic">name</span> as VARCHAR[20]. 
                     </p>
                     <p><span class="bold">char</span> is a native type. The precompiler does not substitute 20 in the declaration of another_name[VC_LEN]. 
                     </p>
                     <p>This does not matter, since the precompiler does not need to process declarations of C datatypes, even when they are used as host variables. It is left up to the C compiler's preprocessor to actually include the file <code class="codeph">my_header.h</code>, and perform the substitution of 20 for VC_LEN in the declaration of <span class="italic">another_name</span>.<a id="d24171e1128" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC3286"></a><div class="props_rev_3"><a id="GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9" name="GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9"></a><h4 id="LNPCC-GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9" class="sect4"><span class="enumeration_section">5.4.2 </span>Preprocessor Directives 
                  </h4>
                  <div>
                     <p>The preprocessor directives that Pro*C/C++ supports are: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">#define</span>, to create macros for use by the precompiler and the C or C++ compiler
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#include</span>, to read other source files for use by the precompiler 
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#if</span>, to precompile and compile source text based on evaluation of a constant expression to 0
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#ifdef</span>, to precompile and compile source text conditionally, depending on the existence of a defined constant 
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#ifndef</span>, to exclude source text conditionally 
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#endif</span>, to end an <span class="bold">#if </span>or <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span> command 
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#else</span>, to select an alternative body of source text to be precompiled and compiled, in case an<span class="bold"> #if </span>or <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span> condition is not satisfied 
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">#elif</span>, to select an alternative body of source text to be precompiled and compiled, depending on the value of a constant or a macro argument 
                           </p>
                        </li>
                     </ul>
                  </div><a id="LNPCC3287"></a><div class="props_rev_3"><a id="GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D" name="GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D"></a><h5 id="LNPCC-GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D" class="sect5"><span class="enumeration_section">5.4.2.1 </span>Directives Ignored 
                     </h5>
                     <div>
                        <p>Some C preprocessor directives are not used by the Pro*C/C++ preprocessor. Most of these directives are not relevant for the precompiler. For example, <span class="bold">#pragma </span>is a directive for the C compilerâ€”the precompiler does not process it. The C preprocessor directives not processed by the precompiler are:  <a id="d24171e1217" class="indexterm-anchor"></a> 
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">#</span>, to convert a preprocessor macro parameter to a string constant
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">##</span>, to merge two preprocessor tokens in a macro definition 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">#error</span>, to produce a compile-time error message 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">#pragma</span>, to pass implementation-dependent information to the C compiler 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">#line</span>, to supply a line number for C compiler messages 
                              </p>
                           </li>
                        </ul>
                        <p>While your C compiler preprocessor may support these directives, Pro*C/C++ does not use them. Most of these directives are not used by the precompiler. You can use these directives in your Pro*C/C++ program if your compiler supports them, but only in C or C++ code, not in embedded SQL statements or declarations of variables using datatypes supplied by the precompiler, such as VARCHAR.</p>
                     </div>
                  </div>
               </div><a id="LNPCC3288"></a><div class="props_rev_3"><a id="GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE" name="GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE"></a><h4 id="LNPCC-GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE" class="sect4"><span class="enumeration_section">5.4.3 </span>ORA_PROC Macro
                  </h4>
                  <div>
                     <p>Pro*C/C++ predefines a C preprocessor macro called ORA_PROC that you can use to avoid having the precompiler process unnecessary or irrelevant sections of code. Some applications include large header files, which provide information that is unnecessary when precompiling. By conditionally excluding such header files based on the ORA_PROC macro, the precompiler never reads the file.</p>
                     <p>The following example uses the ORA_PROC macro to exclude the <code class="codeph">irrelevant.h</code> file:
                     </p><pre class="oac_no_warn" dir="ltr">#ifndef  ORA_PROC
#include &lt;irrelevant.h&gt;
#endif
</pre><p>Because ORA_PROC is defined during precompilation, the <code class="codeph">irrelevant.h</code> file is never included. 
                     </p>
                     <p>The ORA_PROC macro is available only for C preprocessor directives, such as <span class="bold">#ifdef</span> or <span class="bold">#ifndef</span>. The EXEC ORACLE conditional statements do <span class="italic">not</span> share the same namespaces as the C preprocessor macros. Therefore, the condition in the following example does <span class="italic">not</span> use the predefined ORA_PROC macro:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFNDEF ORA_PROC;
   &lt;section of code to be ignored&gt;
EXEC ORACLE ENDIF;
</pre><p>ORA_PROC, in this case, must be set using either the DEFINE option or an EXEC ORACLE DEFINE statement for this conditional code fragment to work properly.</p>
                  </div>
               </div><a id="LNPCC3289"></a><div class="props_rev_3"><a id="GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB" name="GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB"></a><h4 id="LNPCC-GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB" class="sect4"><span class="enumeration_section">5.4.4 </span>Location of Header File Specification
                  </h4>
                  <div>
                     <p>The Pro*C/C++ Precompiler for each system assumes a standard location for header files to be read by the preprocessor, such as <code class="codeph">sqlca.h</code>, <code class="codeph">oraca.h</code>, and <code class="codeph">sqlda.h</code>. For example, on most UNIX systems, the standard location is<code class="codeph"> $ORACLE_HOME/precomp/public</code>. For the default location on your system, see your system-specific Oracle documentation. If header files that you need to include are not in the default location, you must use the INCLUDE= option, on the command line or as an EXEC ORACLE option.
                     </p>
                     <p>To specify the location of system header files, such as <code class="codeph">stdio.h</code> or <code class="codeph">iostream.h</code>, where the location might be different from that hard-coded into Pro*C/C++ use the SYS_INCLUDE precompiler option. 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">Precompiler Options</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3290"></a><div class="props_rev_3"><a id="GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF" name="GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF"></a><h4 id="LNPCC-GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF" class="sect4"><span class="enumeration_section">5.4.5 </span>Some Preprocessor Examples 
                  </h4>
                  <div>
                     <p>You can use the <span class="bold">#define</span> command to create named constants, and use them in place of "magic numbers" in your source code. You can use <span class="bold">#define</span>d constants for declarations that the precompiler requires, such as VARCHAR[const]. For example, instead of code with bugs, such as: 
                     </p><pre class="oac_no_warn" dir="ltr">... 
VARCHAR  emp_name[10]; 
VARCHAR  dept_loc[14]; 
... 
... 
/* much later in the code ... */ 
f42() 
{ 
    /* did you remember the correct size? */
    VARCHAR new_dept_loc[10]; 
   ... 
} 
</pre><p>you can code:</p><pre class="oac_no_warn" dir="ltr">#define ENAME_LEN     10 
#define LOCATION_LEN  14 
VARCHAR  new_emp_name[ENAME_LEN]; 
   ... 
/* much later in the code ... */ 
f42() 
{ 
    VARCHAR new_dept_loc[LOCATION_LEN]; 
   ... 
} 
</pre><p>You can use preprocessor macros with arguments for objects that the precompiler must process, just as you can for C objects. For example: </p><pre class="oac_no_warn" dir="ltr">#define ENAME_LEN    10 
#define LOCATION_LEN 14 
#define MAX(A,B)  ((A) &gt; (B) ? (A) : (B)) 
 
   ... 
f43() 
{ 
    /* need to declare a temporary variable to hold either an 
       employee name or a department location */ 
    VARCHAR  name_loc_temp[MAX(ENAME_LEN, LOCATION_LEN)]; 
   ... 
} 
</pre><p>You can use the <span class="bold">#include</span>, <span class="bold">#ifdef</span> and <span class="bold">#endif</span> preprocessor directives to conditionally include a file that the precompiler requires. For example: 
                     </p><pre class="oac_no_warn" dir="ltr">#ifdef ORACLE_MODE 
#include &lt;sqlca.h&gt; 
#else 
    long SQLCODE; 
#endif </pre></div><a id="LNPCC3291"></a><div class="props_rev_3"><a id="GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7" name="GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7"></a><h5 id="LNPCC-GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7" class="sect5"><span class="enumeration_section">5.4.5.1 </span>About Using #define
                     </h5>
                     <div>
                        <p>There are restrictions on the use of the <span class="bold">#define</span> preprocessor directive in Pro*C/C++ You cannot use the <span class="bold">#define</span> directive to create symbolic constants for use in <span class="italic">executable</span> SQL statements. The following <span class="italic">invalid</span> example demonstrates this: <a id="d24171e1395" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">#define RESEARCH_DEPT   40 
... 
EXEC SQL SELECT empno, sal 
    INTO :emp_number, :salary /* host arrays */
    FROM emp 
    WHERE deptno = RESEARCH_DEPT;  /* INVALID! */
</pre><p>The only declarative SQL statements where you can legally use a <span class="bold">#define</span>d macro are TYPE and VAR statements. So, for example, the following uses of a macro are legal in Pro*C/C++
                        </p><pre class="oac_no_warn" dir="ltr">#define STR_LEN      40
...
typedef char asciiz[STR_LEN];
...
EXEC SQL TYPE asciiz IS STRING(STR_LEN) REFERENCE;
...
EXEC SQL VAR password IS STRING(STR_LEN);
</pre></div>
                  </div><a id="LNPCC3292"></a><div class="props_rev_3"><a id="GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A" name="GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A"></a><h5 id="LNPCC-GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A" class="sect5"><span class="enumeration_section">5.4.5.2 </span>Other Preprocessor Restrictions
                     </h5>
                     <div>
                        <p>The preprocessor ignores directives <span class="bold">#</span> and<span class="bold"> ## </span>to create tokens that the precompiler must recognize. You can use these commands (if your compiler supports them) in pure C code that the precompiler does not have to process. Using the preprocessor command <span class="bold">##</span> is <span class="italic">not</span> valid in this example: 
                        </p><pre class="oac_no_warn" dir="ltr">#define MAKE_COL_NAME(A)    col ## A 
... 
EXEC SQL SELECT MAKE_COL_NAME(1), MAKE_COL_NAME(2) 
    INTO :x, :y 
    FROM table1; 
</pre><p>The example is incorrect because the precompiler ignores <span class="bold">##</span>.
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3293"></a><div class="props_rev_3"><a id="GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C" name="GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C"></a><h4 id="LNPCC-GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C" class="sect4"><span class="enumeration_section">5.4.6 </span>SQL Statements Not Allowed in #include 
                  </h4>
                  <div>
                     <p>Because of the way the Pro*C/C++ preprocessor handles the <span class="bold">#include</span> directive, as described in the previous section, you cannot use the <span class="bold">#include</span> directive to include files that contain embedded SQL statements. You use <span class="bold">#include</span> to include files that contain purely declarative statements and directives; for example, <span class="bold">#define</span>s, and declarations of variables and structures required by the precompiler, such as in <code class="codeph">sqlca.h</code>. 
                     </p>
                  </div>
               </div><a id="LNPCC3294"></a><div class="props_rev_3"><a id="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6" name="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6"></a><h4 id="LNPCC-GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6" class="sect4"><span class="enumeration_section">5.4.7 </span>Include the SQLCA, ORACA, and SQLDA 
                  </h4>
                  <div>
                     <p>You can include the <code class="codeph">sqlca.h</code>, <code class="codeph">oraca.h</code>, and <code class="codeph">sqlda.h</code> declaration header files in your Pro*C/C++ program using either the C/C++ preprocessor <span class="bold">#include</span> command, or the precompiler EXEC SQL INCLUDE command. For example, you use the following statement to include the SQL Communications Area structure (SQLCA) in your program with the EXEC SQL option: 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INCLUDE sqlca; 
</pre><p>To include the SQLCA using the C/C++ preprocessor directive, add the following code: </p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; 
</pre><p>When you use the preprocessor <span class="bold">#include</span> directive, you must specify the file extension (such as <code class="codeph">.h</code>). 
                     </p>
                     <div class="infoboxnote" id="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6__GUID-C5D977AC-80FF-4B16-B86E-0AF5811F3BBA">
                        <p class="notep1">Note:</p>
                        <p>If you need to include the SQLCA in multiple places, using the <span class="bold">#include</span> directive, you should precede the<span class="bold"> #include</span> with the directive <span class="bold">#undef</span> SQLCA. This is because <code class="codeph">sqlca.h</code> starts with the lines
                        </p><pre class="oac_no_warn" dir="ltr">      #ifndef SQLCA
      #define SQLCA 1
</pre><p>and then declares the SQLCA struct only in the case that SQLCA is not defined. <a id="d24171e1521" class="indexterm-anchor"></a></p>
                     </div>
                     <p>When you precompile a file that contains a <span class="bold">#include</span> directive or an EXEC SQL INCLUDE statement, you have to tell the precompiler the location of all files to be included. You can use the INCLUDE= option, either in the command line, or in the system configuration file, or in the user configuration file. 
                     </p>
                     <p>The default location for standard preprocessor header files, such as <code class="codeph">sqlca.h</code>, <code class="codeph">oraca.h</code>, and <code class="codeph">sqlda.h</code>, is preset in the precompiler. The location varies from system to system. See your system-specific Oracle documentation for the default location on your system.
                     </p>
                     <p>When you compile the <code class="codeph">.c</code> output file that Pro*C/C++ generates, you must use the option provided by your compiler and operating system to identify the location of included files. 
                     </p>
                     <p>For example, on most UNIX systems, you can compile the generated C source file using the command </p><pre class="oac_no_warn" dir="ltr">cc -o progname -I$ORACLE_HOME/sqllib/public ... filename.c ... 
</pre><p>On VAX/OPENVMS systems, you pre-pend the include directory path to the value in the logical VAXC$INCLUDE.<a id="d24171e1553" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">Handling Runtime Errors</a></li>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">Precompiler Options</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3295"></a><div class="props_rev_3"><a id="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017" name="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017"></a><h4 id="LNPCC-GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017" class="sect4"><span class="enumeration_section">5.4.8 </span>EXEC SQL INCLUDE and #include Summary 
                  </h4>
                  <div>
                     <p>When you use an EXEC SQL INCLUDE statement in your program, the precompiler includes the source text in the output (<code class="codeph">.c</code>) file. Therefore, you can have declarative and executable embedded SQL statements in a file that is included using EXEC SQL INCLUDE.<a id="d24171e1587" class="indexterm-anchor"></a> 
                     </p>
                     <p>When you include a file using <span class="bold">#include</span>, the precompiler merely reads the file, and keeps track of <span class="bold">#define</span>d macros. 
                     </p>
                     <div class="infoboxnote" id="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017__GUID-37CDAC69-FBF8-4BFF-AC90-AC7E19C9C1C2">
                        <p class="notep1">Note:</p>
                        <p>VARCHAR declarations and SQL statements are <span class="italic">not</span> allowed in included (<code class="codeph">#include</code>) files. For this reason, you cannot use SQL statements in files included using the Pro*C/C++ preprocessor <code class="codeph">#include</code> directive.
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3296"></a><div class="props_rev_3"><a id="GUID-05080E2F-508F-40D9-A1EC-BFF638221B41" name="GUID-05080E2F-508F-40D9-A1EC-BFF638221B41"></a><h4 id="LNPCC-GUID-05080E2F-508F-40D9-A1EC-BFF638221B41" class="sect4"><span class="enumeration_section">5.4.9 </span>Defined Macros
                  </h4>
                  <div>
                     <p>If you define macros on the C compiler's command line, you might also have to define these macros on the precompiler command line, depending on the requirements of your application. For example, if you compile with a UNIX command line such as<a id="d24171e1624" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">cc -DDEBUG ...
</pre><p>you should precompile using the DEFINE= option, namely</p><pre class="oac_no_warn" dir="ltr">proc DEFINE=DEBUG ...</pre></div>
               </div><a id="LNPCC3297"></a><div class="props_rev_3"><a id="GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83" name="GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83"></a><h4 id="LNPCC-GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83" class="sect4"><span class="enumeration_section">5.4.10 </span>Include Files
                  </h4>
                  <div>
                     <p>The location of all included files that need to be precompiled must be specified on the command line, or in a configuration file. </p>
                     <p>For example, if you are developing under UNIX, and your application includes files in the directory <code class="codeph">/home/project42/include</code>, you must specify this directory both on the Pro*C/C++ command line and on the <code class="codeph">cc</code> command line. You use commands like these:
                     </p><pre class="oac_no_warn" dir="ltr">proc iname=my_app.pc include=/home/project42/include ...
cc -I/home/project42/include ... my_app.c
</pre><p>or you include the appropriate macros in a <span class="italic">makefile</span>. For complete information about compiling and linking your Pro*C/C++ application, see your system-specific Oracle documentation.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">INCLUDE</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3298"></a><div class="props_rev_3"><a id="GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B" name="GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B"></a><h3 id="LNPCC-GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B" class="sect3"><span class="enumeration_section">5.5 </span>Precompiled Header Files
               </h3>
               <div>
                  <p>Precompiled header files save time and resources by precompiling header files that contain many <code class="codeph">#include</code> statements. The two steps in using this feature are:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The precompiled header file is created first,</p>
                     </li>
                     <li>
                        <p>The precompiled header is then automatically used in subsequent precompilation of your application.</p>
                     </li>
                  </ul>
                  <p>Use this capability with large applications that have many modules.</p>
                  <p>The precompiler option, HEADER=<code class="codeph">hdr</code>, specifies
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>That precompiled headers are to be used,<a id="d24171e1711" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p>That the file extension for the output file to be generated is <code class="codeph">hdr</code>. 
                        </p>
                     </li>
                  </ul>
                  <p>This option can only be entered in a configuration file or on the command line. There is no default value for HEADER, but the input header must have a <code class="codeph">.h </code>extension. 
                  </p>
               </div><a id="LNPCC3299"></a><div class="props_rev_3"><a id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A" name="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A"></a><h4 id="LNPCC-GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A" class="sect4"><span class="enumeration_section">5.5.1 </span>Precompiled Header File Creation
                  </h4>
                  <div>
                     <p>Assume that you have a header file called <code class="codeph">top.h.</code>Then you can precompile it, specifying that HEADER=<code class="codeph">hdr</code>:
                     </p><pre class="oac_no_warn" dir="ltr">proc HEADER=hdr INAME=top.h
</pre><div class="infoboxnote" id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A__GUID-4D95932E-3B9D-48A1-BC69-4BAAADA2D37A">
                        <p class="notep1">Note:</p>
                        <p>You must provide the '.h' extension. You cannot use an absolute path element or relative path elements such as '/', '..', and so on., in the INAME value.</p>
                     </div>
                     <p>Pro*C/C++ precompiles the given input file, <code class="codeph">top.h</code>, and generates a new precompiled header file, <code class="codeph">top.hdr</code>, in the same directory. The output file, <code class="codeph">top.hdr</code>, can be moved to a directory that the <code class="codeph">#include</code> statement will cause to be searched.
                     </p>
                     <div class="infoboxnote" id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A__GUID-684056B7-EDCB-4F99-97D8-7B8ADC4912C4">
                        <p class="notep1">Note:</p>
                        <p>Do not use the ONAME option to name the output file; it is ignored when used with HEADER.</p>
                     </div>
                  </div>
               </div><a id="LNPCC3300"></a><div class="props_rev_3"><a id="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4" name="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4"></a><h4 id="LNPCC-GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4" class="sect4"><span class="enumeration_section">5.5.2 </span>Use of the Precompiled Header Files
                  </h4>
                  <div>
                     <p>Use the same value of the HEADER option with an application file that is to be precompiled. If simple.pc contains:</p><pre class="oac_no_warn" dir="ltr">#include &lt;top.h&gt;
...
</pre><p>and top.h contains:</p><pre class="oac_no_warn" dir="ltr">#include &lt;a.h&gt;
#include &lt;b.h&gt;
#include &lt;c.h&gt;
...
</pre><p>then precompile this way:</p><pre class="oac_no_warn" dir="ltr">proc HEADER=hdr INAME=simple.pc
</pre><p>When Pro*C/C++ reads the <code class="codeph">#include top.h</code> statement, it will search for a corresponding 'top.hdr' file and instantiate the data from that file instead of precompiling 'top.h' again.
                     </p>
                     <div class="infoboxnote" id="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4__GUID-0BFE1EFA-9304-4C3A-8D3C-4EED53E3FEEF">
                        <p class="notep1">Note:</p>
                        <p>A precompiled header file will always be used instead of its input header file even if the input (<code class="codeph">.h</code>) file appears first in the standard search hierarchy of the include directories.
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3301"></a><div class="props_rev_3"><a id="GUID-F3E14B60-02D3-4805-B1AF-F3341611D247" name="GUID-F3E14B60-02D3-4805-B1AF-F3341611D247"></a><h4 id="LNPCC-GUID-F3E14B60-02D3-4805-B1AF-F3341611D247" class="sect4"><span class="enumeration_section">5.5.3 </span>Examples
                  </h4>
                  <div>
                     <p>This section includes examples demonstrating several different cases.</p>
                  </div><a id="LNPCC3302"></a><div class="props_rev_3"><a id="GUID-C8669179-16CE-4269-8571-A6B71329CB57" name="GUID-C8669179-16CE-4269-8571-A6B71329CB57"></a><h5 id="LNPCC-GUID-C8669179-16CE-4269-8571-A6B71329CB57" class="sect5"><span class="enumeration_section">5.5.3.1 </span>Redundant File Inclusion
                     </h5>
                     <div>
                        <p>The following two cases illustrate two possibilities for redundant file inclusion.</p>
                     </div><a id="LNPCC3303"></a><div class="props_rev_3"><a id="GUID-77541D93-9989-415A-8FBB-E4341F59C083" name="GUID-77541D93-9989-415A-8FBB-E4341F59C083"></a><h6 id="LNPCC-GUID-77541D93-9989-415A-8FBB-E4341F59C083" class="sect6"><span class="enumeration_section">5.5.3.1.1 </span>Case 1: Top-Level Header File Inclusion
                        </h6>
                        <div>
                           <p></p>
                           <p>A precompiled header file will only be instantiated once regardless of how many times the file is included using a #include directive. </p>
                           <p>Suppose we precompile a top-level header file, top.h, with the value of HEADER set to 'hdr' as before. Next, we code multiple #include directives for that header file in a program:</p><pre class="oac_no_warn" dir="ltr">#include &lt;top.h&gt;
#include &lt;top.h&gt;
main(){}
</pre><p>When the first #include for top.h is encountered, the precompiled header file, top.hdr, will be instantiated. The second inclusion of that same header file will be redundant and thus, will be ignored.</p>
                        </div>
                     </div><a id="LNPCC3304"></a><div class="props_rev_3"><a id="GUID-65FEF4E3-1934-4159-868E-82006E03503A" name="GUID-65FEF4E3-1934-4159-868E-82006E03503A"></a><h6 id="LNPCC-GUID-65FEF4E3-1934-4159-868E-82006E03503A" class="sect6"><span class="enumeration_section">5.5.3.1.2 </span>Case 2: Nested Header File Inclusion
                        </h6>
                        <div>
                           <p></p>
                           <p>Suppose the file a.h contains the following statement:</p><pre class="oac_no_warn" dir="ltr">#include &lt;b.h&gt;
</pre><p>and that we precompile that header file specifying HEADER as before. Pro*C/C++ will precompile both a.h and b.h generating a.hdr as a result.</p>
                           <p>Now suppose we precompile this Pro*C/C++ program:</p><pre class="oac_no_warn" dir="ltr">#include &lt;a.h&gt;
#include &lt;b.h&gt;
main(){}
</pre><p>When the #include for a.h is encountered, the a.hdr precompiled header file will be instantiated instead of precompiling a.h again. This instantiation will also contain the entire contents of b.h. </p>
                           <p>Now, because b.h was included in the precompilation of a.h, and a.hdr was instantiated, the subsequent #include of b.h in our program is redundant and thus, will be ignored.</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3305"></a><div class="props_rev_3"><a id="GUID-5C049314-3F84-4349-92F7-2496716C7C5D" name="GUID-5C049314-3F84-4349-92F7-2496716C7C5D"></a><h5 id="LNPCC-GUID-5C049314-3F84-4349-92F7-2496716C7C5D" class="sect5"><span class="enumeration_section">5.5.3.2 </span>Multiple Precompiled Header Files
                     </h5>
                     <div>
                        <p>Pro*C/C++ is capable of instantiating more than one different precompiled header file in a single precompilation. However, one pitfall to avoid occurs when two or more precompiled header files share common header files.</p>
                        <p>For example, suppose topA.h contains the following lines:</p><pre class="oac_no_warn" dir="ltr">#include &lt;a.h&gt;
#include &lt;c.h&gt;
</pre><p>and that topB.h contains the following lines:</p><pre class="oac_no_warn" dir="ltr">#include &lt;b.h&gt;
#include &lt;c.h&gt;
</pre><p>Notice how topA.h and topB.h both include the same common header file, c.h. Precompiling topA.h and topB.h with the same HEADER value will yield topA.hdr and topB.hdr. Both, however, will contain the entire contents of c.h.</p>
                        <p>Now suppose we have a Pro*C/C++ program:</p><pre class="oac_no_warn" dir="ltr">#include &lt;topA.h&gt;
#include &lt;topB.h&gt;
main(){}
</pre><p>Both precompiled header files, topA.hdr and topB.hdr will be instantiated as before. However, because each shares the common header file, c.h, the contents of that file will be instantiated twice.</p>
                        <p>Pro*C/C++ cannot determine when such commonality is occurring among precompiled header files. Try to have each precompiled header file contain a unique set of included headers. Sharing headers should be avoided as much as possible because it will ultimately slow down precompilation and utilize more memory, thus undermining the basic intent of using precompiled header files.</p>
                     </div>
                  </div>
               </div><a id="LNPCC3307"></a><a id="LNPCC3306"></a><div class="props_rev_3"><a id="GUID-F263953E-099E-471D-9A90-82C820149D76" name="GUID-F263953E-099E-471D-9A90-82C820149D76"></a><h4 id="LNPCC-GUID-F263953E-099E-471D-9A90-82C820149D76" class="sect4"><span class="enumeration_section">5.5.4 </span>List of Header Files
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <span class="italic"><code class="codeph">ORACLE_BASE\ORACLE_HOME</code></span><code class="codeph">\precomp\public</code> directory contains the Pro*C/C++ header files. <a href="advanced-topics.html#GUID-F263953E-099E-471D-9A90-82C820149D76__g1008185" title="Header files table">Table 5-3</a> lists and describes the header files.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-F263953E-099E-471D-9A90-82C820149D76__g1008185">
                        <p class="titleintable">Table 5-3 Header Files</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Header Files" summary="Header files table" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d24171e1933">Header Files</th>
                                 <th align="left" valign="bottom" width="75%" id="d24171e1936">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1941" headers="d24171e1933 ">
                                    <p><code class="codeph">oraca.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1941 d24171e1936 ">
                                    <p>Contains the Oracle Communications Area (ORACA), which helps you to diagnose runtime errors and to monitor your program's use of various Oracle Database 10<span class="italic">g</span> resources.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1952" headers="d24171e1933 ">
                                    <p><code class="codeph">sql2oci.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1952 d24171e1936 ">
                                    <p>Contains SQLLIB functions that enable the Oracle Call Interface (OCI) environment handle and OCI service context to be obtained in a Pro*C/C++ application.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1960" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlapr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1960 d24171e1936 ">
                                    <p>Contains ANSI prototypes for externalized functions that can be used in conjunction with OCI.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1968" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlca.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1968 d24171e1936 ">
                                    <p>Contains the SQL Communications Area (SQLCA), which helps you to diagnose runtime errors. The SQLCA is updated after every executable SQL statement.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1976" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlcpr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1976 d24171e1936 ">
                                    <p>Contains platform-specific ANSI prototypes for SQLLIB functions that are generated by Pro*C/C++. By default, Pro*C/C++ does not support full-function prototyping of SQL programming calls. If you need this feature, include <code class="codeph">sqlcpr.h</code> before any EXEC SQL statements in your application source file.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1987" headers="d24171e1933 ">
                                    <p><code class="codeph">oraca.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1987 d24171e1936 ">
                                    <p>Contains the Oracle Communications Area (ORACA), which helps you to diagnose runtime errors and to monitor your program's use of various Oracle Database 10<span class="italic">g</span> resources.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1998" headers="d24171e1933 ">
                                    <p><code class="codeph">sql2oci.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1998 d24171e1936 ">
                                    <p>Contains SQLLIB functions that enable the Oracle Call Interface (OCI) environment handle and OCI service context to be obtained in a Pro*C/C++ application.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e2006" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlapr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e2006 d24171e1936 ">
                                    <p>Contains ANSI prototypes for externalized functions that can be used in conjunction with OCI.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3308"></a><div class="props_rev_3"><a id="GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86" name="GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86"></a><h4 id="LNPCC-GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86" class="sect4"><span class="enumeration_section">5.5.5 </span>Effects of Options
                  </h4>
                  <div>
                     <p>The following precompiler options are used with the precompilation of the application.</p>
                  </div><a id="LNPCC3309"></a><div class="props_rev_3"><a id="GUID-3DADC20B-4718-43DD-BD13-340351FD34E8" name="GUID-3DADC20B-4718-43DD-BD13-340351FD34E8"></a><h5 id="LNPCC-GUID-3DADC20B-4718-43DD-BD13-340351FD34E8" class="sect5"><span class="enumeration_section">5.5.5.1 </span>DEFINE and INCLUDE Options
                     </h5>
                     <div>
                        <p>During any precompilation using precompiled headers, you must use the same values for DEFINE and INCLUDE as when you created the precompiled header files. If the values of DEFINE or INCLUDE change, you must re-create the precompiled header files. </p>
                        <p>If development environments change, you must also re-create the precompiled header files. </p>
                     </div><a id="LNPCC3310"></a><div class="props_rev_3"><a id="GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E" name="GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E"></a><h6 id="LNPCC-GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E" class="sect6"><span class="enumeration_section">5.5.5.1.1 </span>Single User Scenario
                        </h6>
                        <div>
                           <p></p>
                           <p>Consider a single user. If the values of either the DEFINE or the INCLUDE options were to change, then the contents of the precompiled header files may no longer be suitable for use in subsequent Pro*C/C++ precompilations.</p>
                           <p>Because the values of the DEFINE and INCLUDE; DEFINE or INCLUDE options have changed, the contents of the precompiled header file may no longer be consistent with what a standard precompilation would result in had the corresponding .h file in the #include directive been processed normally.</p>
                           <p>In short, if the values of the DEFINE and INCLUDE; DEFINE or INCLUDE options change, any precompiled header files must be re-created and Pro*C/C++ programs which use them re-precompiled.</p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>Related Topics</strong></p>
                              <ul>
                                 <li><a href="precompiler-options.html#GUID-FB3D98E5-EDA9-4518-9C25-B7145476BF00">DEFINE</a></li>
                                 <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">INCLUDE</a></li>
                              </ul>
                           </div>
                        </div>
                        
                     </div><a id="LNPCC3311"></a><div class="props_rev_3"><a id="GUID-2241A146-D8F2-4C12-BC9C-00427971B125" name="GUID-2241A146-D8F2-4C12-BC9C-00427971B125"></a><h6 id="LNPCC-GUID-2241A146-D8F2-4C12-BC9C-00427971B125" class="sect6"><span class="enumeration_section">5.5.5.1.2 </span>Multiple User Scenario
                        </h6>
                        <div>
                           <p></p>
                           <p>Consider two users, A and B, who develop in totally separate environments, thus having completely different values for their DEFINE and INCLUDE options.</p>
                           <p>User A precompiles a common header file, common.h, creating a precompiled header file common.hdrA. User B also precompiles the same header file creating common.hdrB. However, given that the two environments are different, specifically with respect to the values of the DEFINE and INCLUDE options used by both users, it is not guaranteed that both user A's and B's versions of common.hdr will be the same.</p>
                           <p>To summarize</p><pre class="oac_no_warn" dir="ltr">A&gt; proc HEADER=hdrA DEFINE=&lt;A macros&gt; INCLUDE=&lt;A dirs&gt; common.h

B&gt; proc HEADER=hdrB DEFINE=&lt;B macros&gt; INCLUDE=&lt;B dirs&gt; common.h
</pre><p>The generated precompiled header files common.hdrA may not equal common.hdrB because of the different environments in which they where created. This means that neither user A nor user B would be guaranteed that using the common.hdr created by the other user would result in correct precompilation of the Pro*C/C++ programs in their respective development environments.</p>
                           <p>Therefore, care should be taken when sharing or exchanging precompiled header files between different users and different users' development environments.</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3312"></a><div class="props_rev_3"><a id="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3" name="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3"></a><h5 id="LNPCC-GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3" class="sect5"><span class="enumeration_section">5.5.5.2 </span>CODE and PARSE Options
                     </h5>
                     <div>
                        <p>Pro*C/C++ does not search for C++ header files with extensions such as <code class="codeph">hpp</code> or <code class="codeph">h++</code>. So do not use CODE=CPP when precompiling header files. You may use the CPP value when precompiling the application, as long as the source code only includes <code class="codeph">.h</code> header files.
                        </p>
                        <p>You can only use the values FULL or PARTIAL for the option PARSE when creating the precompiled header files, or when precompiling the modules. The value FULL is considered to be of higher value than PARTIAL. The value of PARSE used should be the same or lower when precompiling modules as when you created the precompiled header files. </p>
                        <div class="infoboxnote" id="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3__GUID-1EC735D8-5E63-41B2-B7D1-FD200CFAB6A5">
                           <p class="notep1">Note:</p>
                           <p>Precompiling the precompiled header file with PARSE=FULL and then precompiling modules with PARSE=PARTIAL requires that the host variables be declared inside a Declare Section. C++ code will only be understood when PARSE=PARTIAL.</p>
                        </div>
                        <p>Suppose we precompile a header file with PARSE set to PARTIAL as follows:</p><pre class="oac_no_warn" dir="ltr">proc HEADER=hdr PARSE=PARTIAL file.h
</pre><p>and then try to precompile a program that includes that header file using PARSE set to FULL:</p><pre class="oac_no_warn" dir="ltr">proc HEADER=hdr PARSE=FULL program.pc
</pre><p>Because file.h was precompiled using a PARTIAL setting for the PARSE option, not all of the header file would have been processed. It would therefore be possible for an error to occur during the precompilation of the Pro*C/C++ program if a reference was made to something in the unprocessed portion.</p>
                        <p>To illustrate, suppose that file.h contained the following code:</p><pre class="oac_no_warn" dir="ltr">#define LENGTH 10
typedef int myint;
</pre><p>and that our program.pc contained the following short program:</p><pre class="oac_no_warn" dir="ltr">#include &lt;file.h&gt;
main()
{
     VARCHAR ename[LENGTH];
     myint empno = ...;
     EXEC SQL SELECT ename INTO :ename WHERE JOB = :empno;
}
</pre><p>Because PARSE was set to PARTIAL when precompiling file.h, only the LENGTH macro would have been processed leaving the typedef unseen.</p>
                        <p>The VARCHAR declaration and subsequent use as a host variable would succeed. However, the use of the empno host variable would not because the <code class="codeph">myint</code> type declaration would never have been processed by Pro*C/C++.
                        </p>
                        <p>Precompiling the header file with the PARSE option set to FULL and then precompiling the program with PARSE set to PARTIAL would work. However, the host variables would have to be declared inside an explicit DECLARE SECTION.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="C-Plus-Plus-Applications.html#GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D">About Parsing Code</a></li>
                              <li><a href="precompiler-options.html#GUID-EA4E8928-3B92-4A29-BC1B-C726BFE4B79A">CODE</a></li>
                              <li><a href="precompiler-options.html#GUID-20415049-4CCA-4D5F-AA7D-794511D5FDD6">PARSE</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC3313"></a><div class="props_rev_3"><a id="GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85" name="GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85"></a><h4 id="LNPCC-GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85" class="sect4"><span class="enumeration_section">5.5.6 </span>Usage Notes
                  </h4>
                  <div>
                     <p>The file format of the generated output file of a precompiled header is not guaranteed to remain fixed from one release to the next. Pro*C/C++ has no way of determining which version of the precompiler was used to generate the precompiled header file output.</p>
                     <p>Because of this, it is strongly recommended that, in order to avoid the possibility of errors or other strange behavior during a precompilation that uses precompiled header files, those files be regenerated by re-precompiling the corresponding header files when upgrading to newer releases of Pro*C/C++.</p>
                     <p>The generated output from the precompilation of a header file is completely non-portable. This means that you cannot transfer the output file from the precompilation of a header file from one platform to another and use that file during the subsequent precompilation of another header file or Pro*C/C++ program.</p>
                  </div>
               </div>
            </div><a id="LNPCC3314"></a><div class="props_rev_3"><a id="GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89" name="GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89"></a><h3 id="LNPCC-GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89" class="sect3"><span class="enumeration_section">5.6 </span>The Oracle Preprocessor
               </h3>
               <div>
                  <p>Conditional sections of code are marked by EXEC ORACLE directives that define the environment and actions to take. You can code C statements as well as embedded SQL statements and directives in these sections. The following EXEC ORACLE directives let you exercise conditional control over precompilation:<a id="d24171e2216" class="indexterm-anchor"></a><a id="d24171e2218" class="indexterm-anchor"></a><a id="d24171e2220" class="indexterm-anchor"></a><a id="d24171e2222" class="indexterm-anchor"></a><a id="d24171e2224" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE symbol;    -- define a symbol 
EXEC ORACLE IFDEF symbol;     -- if symbol is defined 
EXEC ORACLE IFNDEF symbol;    -- if symbol is not defined 
EXEC ORACLE ELSE;             -- otherwise 
EXEC ORACLE ENDIF;            -- end this block 
</pre><p>All EXEC ORACLE statements must be terminated with a semi-colon.</p>
               </div><a id="LNPCC3315"></a><div class="props_rev_3"><a id="GUID-669E0976-D842-4E69-89ED-461BF8D40842" name="GUID-669E0976-D842-4E69-89ED-461BF8D40842"></a><h4 id="LNPCC-GUID-669E0976-D842-4E69-89ED-461BF8D40842" class="sect4"><span class="enumeration_section">5.6.1 </span>Symbol Definition
                  </h4>
                  <div>
                     <p>You can define a symbol in two ways. Either include the statement<a id="d24171e2241" class="indexterm-anchor"></a>:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE symbol;
</pre><p>in your host program or define the symbol on the command line using the syntax </p><pre class="oac_no_warn" dir="ltr">... INAME=filename ... DEFINE=symbol 
</pre><p>where <span class="italic">symbol</span> is not case-sensitive. 
                     </p>
                     <div class="infoboxnote" id="GUID-669E0976-D842-4E69-89ED-461BF8D40842__GUID-94C56D63-B000-4237-B93C-435129DFDB71">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">#define</code> preprocessor directive is not the same as the EXEC ORACLE DEFINE command.
                        </p>
                     </div>
                     <p>Some port-specific symbols are predefined for you when the Pro*C/C++ precompiler is installed on your system. </p>
                  </div>
               </div><a id="LNPCC3316"></a><div class="props_rev_3"><a id="GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752" name="GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752"></a><h4 id="LNPCC-GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752" class="sect4"><span class="enumeration_section">5.6.2 </span>An Oracle Preprocessor Example
                  </h4>
                  <div>
                     <p>In the following example, the SELECT statement is precompiled only when the symbol <span class="italic">site2</span> is defined:<a id="d24171e2285" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF site2; 
    EXEC SQL SELECT DNAME 
        INTO :dept_name 
        FROM DEPT 
        WHERE DEPTNO = :dept_number; 
EXEC ORACLE ENDIF; 
</pre><p>Blocks of conditions can be nested as shown in the following example: </p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF outer; 
    EXEC ORACLE IFDEF inner; 
    ... 
    EXEC ORACLE ENDIF; 
EXEC ORACLE ENDIF;
</pre><p>You can "Comment out" C or embedded SQL code by placing it between IFDEF and ENDIF and <span class="italic">not</span> defining the symbol.
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3317"></a><div class="props_rev_3"><a id="GUID-1C948990-B5FF-411D-BAC3-930E2FE82972" name="GUID-1C948990-B5FF-411D-BAC3-930E2FE82972"></a><h3 id="LNPCC-GUID-1C948990-B5FF-411D-BAC3-930E2FE82972" class="sect3"><span class="enumeration_section">5.7 </span>Evaluation of Numeric Constants
               </h3>
               <div>
                  <p>Previously, Pro*C/C++ allowed only numeric literals and simple constant expressions involving numeric literals to be used when declaring the sizes of host variables (such as <code class="codeph">char</code> or <code class="codeph">VARCHAR</code>), as in the following examples:
                  </p><pre class="oac_no_warn" dir="ltr">   #define LENGTH 10
   VARCHAR v[LENGTH];
   char c[LENGTH + 1];
</pre><p>You can now also use numeric constant declarations such as:</p><pre class="oac_no_warn" dir="ltr">   const int length = 10;
   VARCHAR v[length];
   char c[length + 1];
</pre><p>This is highly desirable, especially for programmers who use ANSI or C++ compilers that support such constant declarations.</p>
                  <p>Pro*C/C++ has always determined the values of constant expressions that can be evaluated, but it has never allowed the use of a numeric constant declaration in any constant expression.</p>
                  <p>Pro*C/C++ supports the use of numeric constant declarations anywhere that an ordinary numeric literal or macro is used, given the macro expands to some numeric literal.</p>
                  <p>This is used primarily for declaring the sizes of arrays for bind variables to be used in a SQL statement.</p>
               </div><a id="LNPCC3318"></a><div class="props_rev_3"><a id="GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875" name="GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875"></a><h4 id="LNPCC-GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875" class="sect4"><span class="enumeration_section">5.7.1 </span>Numeric Constants in Pro*C/C++
                  </h4>
                  <div>
                     <p>In Pro*C/C++, normal C scoping rules are used to find and locate the declaration of a numeric constant declaration.</p><pre class="oac_no_warn" dir="ltr">     const int g = 30;     /* Global declaration to both function_1()
                                                  and function_2() */
     void function_1()
     {
       const int a = 10;  /* Local declaration only to function_1() */
       char x[a];
       exec sql select ename into :x from emp where job = 'PRESIDENT';
     }

     void function_2()
     {
       const int a = 20;  /* Local declaration only to function_2() */
       VARCHAR v[a];
       exec sql select ename into :v from emp where job = 'PRESIDENT';
     }

     void main()
     {
       char m[g];                                   /* The global g */
       exec sql select ename into :m from emp where job = 'PRESIDENT';
     }</pre></div>
               </div><a id="LNPCC3319"></a><div class="props_rev_3"><a id="GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040" name="GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040"></a><h4 id="LNPCC-GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040" class="sect4"><span class="enumeration_section">5.7.2 </span>Numeric Constant Rules and Examples
                  </h4>
                  <div>
                     <p>Variables which are of specific static types need to be defined with <span class="bold">static </span>and initialized. The following rules must be kept in mind when declaring numeric constants in Pro*C/C++:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <span class="bold">const</span> qualifier must be used when declaring the constant<a id="d24171e2365" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>An initializer must be used to initialize the value of the constant. This initializer must be precompile-time evaluable.</p>
                        </li>
                     </ul>
                     <p>Any attempt to use an identifier that does not resolve to a constant declaration with a valid initializer is considered an error.</p>
                     <p>The following shows examples of what is not permitted and why:</p><pre class="oac_no_warn" dir="ltr">int a;
int b = 10;
volatile c;
volatile d = 10;
const e;
const f = b;

VARCHAR v1[a]; /* No const qualifier, missing initializer */
VARCHAR v2[b];                      /* No const qualifier */
VARCHAR v3[c];     /* Not a constant, missing initializer */
VARCHAR v4[d];                          /* Not a constant */
VARCHAR v5[e];                     /* Missing initializer */
VARCHAR v6[f];   /* Bad initializer.. b is not a constant */</pre></div>
               </div>
            </div><a id="LNPCC3320"></a><div class="props_rev_3"><a id="GUID-5A1F44A6-4B41-4610-B265-C56C85261379" name="GUID-5A1F44A6-4B41-4610-B265-C56C85261379"></a><h3 id="LNPCC-GUID-5A1F44A6-4B41-4610-B265-C56C85261379" class="sect3"><span class="enumeration_section">5.8 </span>SQLLIB Extensions for OCI Release 8 Interoperability
               </h3>
               <div>
                  <p>An OCI environment handle will be tied to the Pro*C/C++ runtime context, which is of the <span class="italic">sql_context</span> type. That is, one Pro*C/C++ runtime context maintained by SQLLIB during application execution will be associated with at most one OCI environment handle. Multiple database connections are allowed for each Pro*C/C++ runtime context, which will be associated to the OCI environment handle for the runtime context.
                  </p>
                  <div class="infoboxnote" id="GUID-5A1F44A6-4B41-4610-B265-C56C85261379__GUID-F220704B-4020-4471-91C5-4BD570C28EBA">
                     <p class="notep1">Note:</p>
                     <p>Precompiler applications can extract OCI handles and call OCI functions directly.  However, non-blocking mode is not supported because the precompilers are unable to handle the "still executing" error that might be returned.</p>
                  </div>
               </div><a id="LNPCC3321"></a><div class="props_rev_3"><a id="GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE" name="GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE"></a><h4 id="LNPCC-GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE" class="sect4"><span class="enumeration_section">5.8.1 </span>Runtime Context in the OCI Release 8 Environment
                  </h4>
                  <div>
                     <p>An EXEC SQL CONTEXT USE statement specifies a runtime context to be used in a Pro*C/C++ program. This context applies to all executable SQL statements that positionally follow it in a given Pro*C/C++ file until another EXEC SQL CONTEXT USE statement occurs. If no EXEC SQL CONTEXT USE appears in a source file, the default "global" context is assumed. Thus, the current runtime context, and therefore the current OCI environment handle, is known at any point in the program.</p>
                     <p>The runtime context and its associated OCI environment handle are initialized when a database logon is performed using EXEC SQL CONNECT in Pro*C/C++.</p>
                     <p>When a Pro*C/C++ runtime context is freed using the EXEC SQL CONTEXT FREE statement, the associated OCI environment handle is terminated and all of its resources, such as space allocated for the various OCI handles and LOB locators, are de-allocated. This command releases all other memory associated with the Pro*C/C++ runtime context. An OCI environment handle that is established for the default "global" runtime remains allocated until the Pro*C/C++ program terminates.</p>
                  </div>
               </div><a id="LNPCC3322"></a><div class="props_rev_3"><a id="GUID-16D7605D-0629-4345-AD0A-085BFE9214E7" name="GUID-16D7605D-0629-4345-AD0A-085BFE9214E7"></a><h4 id="LNPCC-GUID-16D7605D-0629-4345-AD0A-085BFE9214E7" class="sect4"><span class="enumeration_section">5.8.2 </span>Parameters in the OCI Release 8 Environment Handle
                  </h4>
                  <div>
                     <p>An OCI environment established through Pro*C/C++ will use the following parameters:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The callback functions used by the environment for allocating memory, freeing memory, writing to a text file, and flushing the output buffer will be trivial functions that call malloc(), free(), fprintf(stderr, ...), and fflush(stderr) respectively.</p>
                        </li>
                        <li>
                           <p>The language will be obtained from the Globalization Support variable NLS_LANG.</p>
                        </li>
                        <li>
                           <p>The error message buffer will be allocated in thread-specific storage.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC3323"></a><div class="props_rev_3"><a id="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58" name="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58"></a><h3 id="LNPCC-GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58" class="sect3"><span class="enumeration_section">5.9 </span>Interface to OCI Release 8
               </h3>
               <div>
                  <p>SQLLIB library provides routines to obtain the OCI environment and service context handles for database connections established through a Pro*C/C++ program. Once the OCI handles are obtained, the user can call various OCI routines, for example, to perform client-side DATE arithmetic, execute navigational operations on objects and so on. These SQLLIB functions are described later, and their prototypes are available in the public header file <code class="codeph">sql2oci.h</code>.
                  </p>
                  <p>A Pro*C/C++ user who mixes embedded SQL and calls in the other Oracle programmatic interfaces must exercise reasonable care. For example, if a user terminates a connection directly using the OCI interface, SQLLIB state is out-of-sync; the behavior for subsequent SQL statements in the Pro*C/C++ program is undefined in such cases.</p>
                  <div class="infoboxnote" id="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58__GUID-5D2FDEED-5499-4916-BF56-29DA0ED6DB4B">
                     <p class="notep1">Note:</p>
                     <p>Pro*C/C++, the Oracle Call Interface (OCI) release 8, and XA are <span class="italic">not</span> compatible. 
                     </p>
                  </div>
                  <p>The new SQLLIB functions that provide interoperability with the Oracle OCI are declared in header file <code class="codeph">sql2oci.h</code>:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">SQLEnvGet()</code>, to return a pointer to an OCI environment handle associated with a given SQLLIB runtime context. Used for both single and shared server environments.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">SQLSvcCtxGet()</code>, to return an OCI service context handle for a Pro*C/C++ database connection. Used for both single and shared server environments.
                        </p>
                     </li>
                     <li>
                        <p><a id="d24171e2510" class="indexterm-anchor"></a>Pass the constant <code class="codeph">SQL_SINGLE_RCTX</code>, defined as <code class="codeph">(dvoid *)0</code>, when you include sql2oci.h, as the first parameter in either function, when using single threaded runtime contexts.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">Objects</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3324"></a><div class="props_rev_3"><a id="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64" name="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64"></a><h4 id="LNPCC-GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64" class="sect4"><span class="enumeration_section">5.9.1 </span>SQLEnvGet()
                  </h4>
                  <div>
                     <p>The SQLLIB library function <code class="codeph">SQLEnvGet()</code> (SQLLIB OCI Environment Get) returns the pointer to the OCI environment handle associated with a given SQLLIB runtime context. The prototype for this function is:
                     </p><pre class="oac_no_warn" dir="ltr">sword SQLEnvGet(dvoid *rctx, OCIEnv **oeh);
</pre><p>where:</p>
                     <div class="tblformal" id="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64__GUID-5BA39C5C-A99D-4186-8CB7-6A038CEDFD52">
                        <table cellpadding="4" cellspacing="0" class="Formal" title summary="Terms" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e2564">Terms</th>
                                 <th align="left" valign="bottom" width="71%" id="d24171e2567">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2572" headers="d24171e2564 ">
                                    <p>Description</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2572 d24171e2567 ">
                                    <p>Sets<span class="italic"> oeh</span> to the OCIEnv corresponding to the runtime context
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2582" headers="d24171e2564 ">
                                    <p>Parameters</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2582 d24171e2567 ">
                                    <p><span class="italic">rctx </span>(IN)   pointer to a SQLLIB runtime context
                                    </p>
                                    <p><span class="italic">oeh</span> (OUT) pointer to OCIEnv
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2595" headers="d24171e2564 ">
                                    <p>Returns</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2595 d24171e2567 ">
                                    <p>SQL_SUCCESS on success</p>
                                    <p>SQL_ERROR   on failure</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2604" headers="d24171e2564 ">
                                    <p>Notes</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2604 d24171e2567 ">
                                    <p>The usual error status variables in Pro*C/C++ such as SQLCA and SQLSTATE will not be affected by a call to this function</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3325"></a><div class="props_rev_3"><a id="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE" name="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE"></a><h4 id="LNPCC-GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE" class="sect4"><span class="enumeration_section">5.9.2 </span>SQLSvcCtxGet()
                  </h4>
                  <div>
                     <p>The SQLLIB library function <code class="codeph">SQLSvcCtxGet()</code> (SQLLIB OCI Service Context Get) returns the OCI service context for the Pro*C/C++ database connection. The OCI service context can then be used in direct calls to OCI functions. The prototype for this function is:
                     </p><pre class="oac_no_warn" dir="ltr">sword SQLSvcCtxGet(dvoid *rctx, text *dbname,
       sb4 dbnamelen, OCISvcCtx **svc);
</pre><p>where:</p>
                     <div class="tblformal" id="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE__GUID-F5F7B899-4F95-4542-8AB0-9C98760D7B8C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title summary="Terms" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e2645">Terms</th>
                                 <th align="left" valign="bottom" width="71%" id="d24171e2648">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2653" headers="d24171e2645 ">
                                    <p>Description</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2653 d24171e2648 ">
                                    <p>Sets<span class="italic"> svc </span>to the OCI Service Context corresponding to the runtime context
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2663" headers="d24171e2645 ">
                                    <p>Parameters</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2663 d24171e2648 ">
                                    <p><span class="italic">rctx </span>(IN) = pointer to a SQLLIB runtime context
                                    </p>
                                    <p><span class="italic">dbname</span> (IN) = buffer containing the "logical" name for this connection
                                    </p>
                                    <p><span class="italic">dbnamelen</span> (IN) = length of the dbname buffer
                                    </p>
                                    <p><span class="italic">svc </span>(OUT) = address of an OCISvcCtx pointer
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2684" headers="d24171e2645 ">
                                    <p>Returns</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2684 d24171e2648 ">
                                    <p>SQL_SUCCESS on success</p>
                                    <p>SQL_ERROR   on failure</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2693" headers="d24171e2645 ">
                                    <p>Notes</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2693 d24171e2648 ">
                                    <p>1. The usual error status variables in Pro*C/C++ such as SQLCA and SQLSTATE will not be affected by a call to this function</p>
                                    <p><span class="italic">2. dbname</span> is the same identifier used in an AT clause in an embedded SQL statement.
                                    </p>
                                    <p>3. If <span class="italic">dbname</span> is a null pointer or <span class="italic">dbnamelen</span> is 0, then the default database connection is assumed, as in a SQL statement with no AT clause.
                                    </p>
                                    <p>4. A value of -1 for <span class="italic">dbnamelen</span> is used to indicate that <span class="italic">dbname</span> is a zero-terminated string.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3326"></a><div class="props_rev_3"><a id="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34" name="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34"></a><h4 id="LNPCC-GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34" class="sect4"><span class="enumeration_section">5.9.3 </span>Embedded OCI Release 8 Calls 
                  </h4>
                  <div>
                     <div class="section">
                        <p>To embed OCI release 8 calls in your Pro*C/C++ program:</p>
                        <p>1. Include the public header sql2oci.h</p>
                        <p>2. Declare an environment handle (type OCIEnv *) in your Pro*C/C++ program:</p><pre class="oac_no_warn" dir="ltr">OCIEnv *oeh;
</pre><p>3. Optionally, declare a service context handle (type OCISvcCtx *) in your    Pro*C/C++ program if the OCI function you wish to call requires the Service Context handle.</p><pre class="oac_no_warn" dir="ltr">OCISvcCtx *svc;
</pre><p>4. Declare an error handle (type OCIError *) in your Pro*C/C++ program:</p><pre class="oac_no_warn" dir="ltr">OCIError *err;
</pre><p>5. Connect to Oracle using the embedded SQL statement CONNECT. Do not connect using OCI.</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ...
</pre><p>6. Obtain the OCI Environment handle that is associated with the desired runtime context using the SQLEnvGet function. </p>
                        <p>For single threaded applications:</p><pre class="oac_no_warn" dir="ltr">retcode = SQLEnvGet(SQL_SINGLE_RCTX, &amp;oeh);
</pre><p>or for shared server applications:</p><pre class="oac_no_warn" dir="ltr">sql_context ctx1;
...
EXEC SQL CONTEXT ALLOCATE :ctx1;
EXEC SQL CONTEXT USE :ctx1;
...
EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;
...
retcode = SQLEnvGet(ctx1, &amp;oeh);
</pre><p>7. Allocate an OCI error handle using the retrieved environment handle:</p><pre class="oac_no_warn" dir="ltr">retcode = OCIHandleAlloc((dvoid *)oeh, (dvoid **)&amp;err, 
                    (ub4)OCI_HTYPE_ERROR, (ub4)0, (dvoid **)0);
</pre><p>8. Optionally, if needed by the OCI call you use, obtain the OCIServiceContext handle using the SQLSvcCtxGet call:</p>
                        <p>For single threaded applications:</p><pre class="oac_no_warn" dir="ltr">retcode = SQLSvcCtxGet(SQL_SINGLE_RCTX, (text *)dbname, (ub4)dbnlen, &amp;svc);
</pre><p>or, for shared server environment applications:</p><pre class="oac_no_warn" dir="ltr">sql_context ctx1;
...
EXEC SQL ALLOCATE :ctx1;
EXEC SQL CONTEXT USE :ctx1;
...
EXEC SQL CONNECT :uid IDENTIFIED BY :pwd AT :dbname
     USING :hst;
...
retcode = SQLSvcCtxGet(ctx1, (text *)dbname, (ub4)strlen(dbname), &amp;svc);
</pre><div class="infoboxnote" id="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34__GUID-58C2A81E-628B-4196-B62C-6A36E9404D27">
                           <p class="notep1">Note:</p>
                           <p>A null pointer may be passed as the <span class="italic">dbname</span> if the Pro*C/C++ connection is not named with an AT clause.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC3327"></a><div class="props_rev_3"><a id="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45" name="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45"></a><h3 id="LNPCC-GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45" class="sect3"><span class="enumeration_section">5.10 </span>Embedded OCI Release 7 Calls 
               </h3>
               <div>
                  <div class="infoboxnote" id="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45__GUID-79338607-F1E9-4EBD-B40D-09DDE8A7A6B7">
                     <p class="notep1">Note:</p>
                     <p>The Logon Data Area (LDA) is <span class="italic">no longer supported</span>. The ability to embed OCI Release 7 calls in your Pro*C/C++ program is not supported. 
                     </p>
                  </div>
                  <p>To embed OCI release 7 calls in your Pro*C/C++ program, take the following steps:<a id="d24171e2810" class="indexterm-anchor"></a><a id="d24171e2814" class="indexterm-anchor"></a><a id="d24171e2816" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Declare an OCI Logon Data Area (LDA) in your Pro*C/C++ program (outside the Declare Section if you precompile with MODE=ANSI). The LDA is a structure defined in the OCI header file <code class="codeph">oci.h</code>. For details, see the Oracle Call Interface programmer's Guide for Release 7.<span class="italic"></span></p>
                     </li>
                     <li>
                        <p>Connect to Oracle using the embedded SQL statement CONNECT, not the OCI <code class="codeph">orlon()</code> or <code class="codeph">onblon()</code> calls.<a id="d24171e2835" class="indexterm-anchor"></a><a id="d24171e2839" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p>Call the SQLLIB runtime library function <code class="codeph">sqllda(</code>) to set up the LDA.SQLLIB function
                        </p>
                     </li>
                  </ul>
                  <p>That way, the Pro*C/C++ Precompiler and the OCI "know" that they are working together. However, there is no sharing of Oracle cursors. </p>
                  <p>You need not worry about declaring the OCI Host Data Area (HDA) because the Oracle runtime library manages connections and maintains the HDA for you. </p>
               </div><a id="LNPCC3328"></a><div class="props_rev_3"><a id="GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C" name="GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C"></a><h4 id="LNPCC-GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C" class="sect4"><span class="enumeration_section">5.10.1 </span>Set Up the LDA
                  </h4>
                  <div>
                     <p>You set up the LDA by issuing the OCI call </p><pre class="oac_no_warn" dir="ltr">sqllda(&amp;lda); 
</pre><p>where <span class="italic">lda</span> identifies the LDA data structure. 
                     </p>
                     <p>If the setup fails, the <span class="italic">lda_rc</span> field in the <span class="italic">lda</span> is set to 1012 to indicate the error. 
                     </p>
                  </div>
               </div><a id="LNPCC3329"></a><div class="props_rev_3"><a id="GUID-032607D3-8000-469F-9CBA-249CAF45EC53" name="GUID-032607D3-8000-469F-9CBA-249CAF45EC53"></a><h4 id="LNPCC-GUID-032607D3-8000-469F-9CBA-249CAF45EC53" class="sect4"><span class="enumeration_section">5.10.2 </span>Remote and Multiple Connections 
                  </h4>
                  <div>
                     <p>A call to <code class="codeph">sqllda()</code> sets up an LDA for the connection used by the most recently executed SQL statement. To set up the different LDAs needed for additional connections, you <span class="italic">must</span> call <code class="codeph">sqllda()</code> with a different LDA <span class="italic">immediately</span> after each CONNECT. In the following example, you connect to two nondefault databases concurrently: 
                     </p><pre class="oac_no_warn" dir="ltr">#include &lt;ocidfn.h&gt;
Lda_Def lda1;
Lda_Def lda2;

char username[10], password[10], db_string1[20], dbstring2[20];
...
strcpy(username, "scott");
strcpy(password, "tiger");
strcpy(db_string1, "NYNON");
strcpy(db_string2, "CHINON");
/* give each database connection a unique name */
EXEC SQL DECLARE DB_NAME1 DATABASE;
EXEC SQL DECLARE DB_NAME2 DATABASE;
/* connect to first nondefault database */
EXEC SQL CONNECT :username IDENTIFIED BY :password;
    AT DB_NAME1 USING :db_string1;
/* set up first LDA */
sqllda(&amp;lda1);
/* connect to second nondefault database */
EXEC SQL CONNECT :username IDENTIFIED BY :password;
    AT DB_NAME2 USING :db_string2;
/* set up second LDA */
sqllda(&amp;lda2);
</pre><p>DB_NAME1 and DB_NAME2 are <span class="italic">not</span> C variables; they are SQL identifiers. You use them only to name the default databases at the two nondefault nodes, so that later SQL statements can refer to the databases by name. 
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3331"></a><a id="LNPCC3330"></a><div class="props_rev_3"><a id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712" name="GUID-3B79020D-735A-47A9-84DA-401D86E8F712"></a><h3 id="LNPCC-GUID-3B79020D-735A-47A9-84DA-401D86E8F712" class="sect3"><span class="enumeration_section">5.11 </span>New Names for SQLLIB Public Functions
               </h3>
               <div>
                  <p>The names of SQLLIB functions are listed in <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022" title="TSQLLIB Public Funcitons - New Names">Table 5-4</a>. You can use these SQLLIB functions for both threaded and nonthreaded applications. Previously, for example, <code class="codeph">sqlglm()</code> was documented as the nonthreaded or default context version of this function, while <code class="codeph">sqlglmt()</code> was the threaded or nondefault context version, with context as the first argument. The names <code class="codeph">sqlglm()</code> and <code class="codeph">sqlglmt()</code> are still available. The new function <code class="codeph">SQLErrorGetText()</code> requires the same arguments as <code class="codeph">sqlglmt()</code>. For nonthreaded or default context applications, pass the defined constant <a id="d24171e2963" class="indexterm-anchor"></a>SQL_SINGLE_RCTX as the context.
                  </p>
                  <p>Each standard SQLLIB public function is thread-safe and accepts the runtime context as the first argument. For example, the syntax for <code class="codeph">SQLErrorGetText()</code> is:
                  </p><pre class="oac_no_warn" dir="ltr">void SQLErrorGetText(dvoid *context,  char   *message_buffer, 
            size_t *buffer_size,
            size_t *message_length);
</pre><p>In summary, the old function names will continue to work in your existing applications. You can use the new function names in the new applications that you will write.</p>
                  <p><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022" title="TSQLLIB Public Funcitons - New Names">Table 5-4</a> lists all the SQLLIB public functions and their corresponding syntax. Cross-references to the nonthreaded or default-context usages are provided to help you find more complete descriptions.
                  </p>
                  <div class="tblformalwide" id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022">
                     <p class="titleintable">Table 5-4  SQLLIB Public Functions -- New Names</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title=" SQLLIB Public Functions -- New Names" summary="TSQLLIB Public Funcitons - New Names" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="25%" id="d24171e2994">Old Name</th>
                              <th align="left" valign="bottom" width="37%" id="d24171e2997">New Function Prototype</th>
                              <th align="left" valign="bottom" width="37%" id="d24171e3000">Cross-reference</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3005" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlaldt()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3005 d24171e2997 "><pre class="oac_no_warn" dir="ltr">struct SQLDA *SQLSQLDAAlloc(dvoid *context,
unsigned int     maximum_variables,
unsigned int     maximum_name_length,
unsigned int     maximum_ind_name_length);<a id="d24171e3012" class="indexterm-anchor"></a><a id="d24171e3016" class="indexterm-anchor"></a><a id="d24171e3018" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3005 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-0523C053-0F0C-40B2-A22E-4D2860001A8A">Allocating a SQLDA </a>"</span> .
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3031" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlcdat()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3031 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLCDAFromResultSetCursor(dvoid *context,
Cda_Def *cda,
void    *cursor,
sword   *return_value);<a id="d24171e3038" class="indexterm-anchor"></a><a id="d24171e3042" class="indexterm-anchor"></a><a id="d24171e3044" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3031 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="datatypes-and-host-variables.html#GUID-86514859-8929-47EA-AE78-9D8831BB5838">Cursor Variables with the OCI (Release 7 Only)</a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3059" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlclut()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3059 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLSQLDAFree(dvoid  *context, 
struct SQLDA             *descriptor_name);<a id="d24171e3066" class="indexterm-anchor"></a><a id="d24171e3070" class="indexterm-anchor"></a><a id="d24171e3072" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3059 d24171e3000 ">
                                 <p>See also<span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-25AAA0D6-7513-431C-A035-99A5D973E775">Deallocate Storage </a>"</span> .
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3085" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlcurt()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3085 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLCDAToResultSetCursor(dvoid  *context,
void    *cursor, 
Cda_Def *cda, 
sword   *return_value)<a id="d24171e3092" class="indexterm-anchor"></a><a id="d24171e3096" class="indexterm-anchor"></a><a id="d24171e3098" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3085 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="datatypes-and-host-variables.html#GUID-86514859-8929-47EA-AE78-9D8831BB5838">Cursor Variables with the OCI (Release 7 Only)</a>"</span> .
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3111" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlglmt()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3111 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLErrorGetText(dvoid  *context,
unsigned char *message_buffer, 
size_t  *buffer_size,
size_t  *message_length);<a id="d24171e3118" class="indexterm-anchor"></a><a id="d24171e3122" class="indexterm-anchor"></a><a id="d24171e3126" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3111 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="handling-run-time-errors.html#GUID-5E9B1F0B-8F5D-43F2-8485-650F27EEE8BC">About Getting the Full Text of Error Messages </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3137" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlglst()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3137 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLStmtGetText(dvoid   *context, 
char    *statement_buffer, 
size_t  *statement_length, 
size_t  *sqlfc);<a id="d24171e3144" class="indexterm-anchor"></a><a id="d24171e3146" class="indexterm-anchor"></a><a id="d24171e3150" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3137 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="handling-run-time-errors.html#GUID-0760D27A-BEB8-4576-AC09-1D2B04E2522B">About Obtaining the Text of SQL Statements </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3163" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlld2t()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3163 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLLDAGetName(dvoid   *context, 
Lda_Def *lda,
text    *cname,
int     *cname_length);<a id="d24171e3170" class="indexterm-anchor"></a><a id="d24171e3174" class="indexterm-anchor"></a><a id="d24171e3176" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3163 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="advanced-topics.html#GUID-72807525-DF42-47EA-AB69-17E8356D7DD3">OCI Calls (Release 7 Only)</a>"</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3188" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlldat()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3188 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLLDAGetCurrent(dvoid *context, 
Lda_Def   *lda);<a id="d24171e3195" class="indexterm-anchor"></a><a id="d24171e3199" class="indexterm-anchor"></a><a id="d24171e3203" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3188 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="advanced-topics.html#GUID-032607D3-8000-469F-9CBA-249CAF45EC53">Remote and Multiple Connections </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3214" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlnult()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3214 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLColumnNullCheck(dvoid *context, 
unsigned short *value_type, 
unsigned short *type_code, 
int            *null_status);<a id="d24171e3221" class="indexterm-anchor"></a><a id="d24171e3225" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3214 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-E8EB0987-EA56-40C4-94D6-0CDC4BF51188">Handling NULL/Not NULL Datatypes </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3238" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlprct()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3238 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLNumberPrecV6(dvoid  *context, 
unsigned long   *length, 
int             *precision, 
int             *scale);<a id="d24171e3245" class="indexterm-anchor"></a><a id="d24171e3249" class="indexterm-anchor"></a><a id="d24171e3253" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3238 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">Extracting Precision and Scale </a>"</span>. 
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3264" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlpr2t()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3264 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLNumberPrecV7(dvoid  *context, 
unsigned long   *length, 
int             *precision, 
int             *scale);<a id="d24171e3271" class="indexterm-anchor"></a><a id="d24171e3275" class="indexterm-anchor"></a><a id="d24171e3279" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3264 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">Extracting Precision and Scale </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3291" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlvcpt()</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3291 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLVarcharGetLength(dvoid  *context, 
unsigned long   *data_length, 
unsigned long   *total_length);<a id="d24171e3298" class="indexterm-anchor"></a><a id="d24171e3302" class="indexterm-anchor"></a><a id="d24171e3304" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3291 d24171e3000 ">
                                 <p>See also <span class="q">"<a href="datatypes-and-host-variables.html#GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5">Find the Length of the VARCHAR Array Component </a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3317" headers="d24171e2994 ">
                                 <p><code class="codeph">N/A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3317 d24171e2997 "><pre class="oac_no_warn" dir="ltr">sword <a id="d24171e3324" class="indexterm-anchor"></a><a id="d24171e3326" class="indexterm-anchor"></a>SQLEnvGet(dvoid *context,
OCIEnv          **oeh);</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3317 d24171e3000 ">
                                 <p>See <span class="q">"<a href="advanced-topics.html#GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64">SQLEnvGet()</a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3340" headers="d24171e2994 ">
                                 <p><code class="codeph">N/A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3340 d24171e2997 "><pre class="oac_no_warn" dir="ltr">sword <a id="d24171e3347" class="indexterm-anchor"></a><a id="d24171e3349" class="indexterm-anchor"></a>SQLSvcCtxGet(dvoid *context,
text            *dbname,
int             dbnamelen,
OCISvcCtx       **svc);</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3340 d24171e3000 ">
                                 <p>See <span class="q">"<a href="advanced-topics.html#GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE">SQLSvcCtxGet()</a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3363" headers="d24171e2994 ">
                                 <p><code class="codeph">N/A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3363 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void <a id="d24171e3370" class="indexterm-anchor"></a><a id="d24171e3372" class="indexterm-anchor"></a>SQLRowidGet(dvoid *context,
OCIRowid        **urid);</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3363 d24171e3000 ">
                                 <p>See <span class="q">"<a href="datatypes-and-host-variables.html#GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910">SQLRowidGet()</a>"</span>.
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3386" headers="d24171e2994 ">
                                 <p><code class="codeph">N/A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3386 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void <a id="d24171e3393" class="indexterm-anchor"></a><a id="d24171e3395" class="indexterm-anchor"></a>SQLExtProcError(dvoid *context,
char            *msg,
size_t          msglen);</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3386 d24171e3000 ">
                                 <p>See <span class="q">"<a href="embedded-PL-SQL.html#GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF">SQLExtProcError()</a>"</span> for a discussion of its use in external procedures.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712__GUID-85BC0CB9-C1A0-426E-8DD8-2616A8110507">
                     <p class="notep1">Note:</p>
                     <p>For the specific datatypes used in the argument lists for these functions, refer to your platform-specific version of the <code class="codeph">sqlcpr.h</code> header file.
                     </p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">Interface to OCI Release 8</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3333"></a><a id="LNPCC3332"></a><div class="props_rev_3"><a id="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207" name="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207"></a><h3 id="LNPCC-GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207" class="sect3"><span class="enumeration_section">5.12 </span>X/Open Application Development
               </h3>
               <div>
                  <p><a id="d24171e3435" class="indexterm-anchor"></a><a id="d24171e3439" class="indexterm-anchor"></a><a id="d24171e3441" class="indexterm-anchor"></a>X/Open applications run in a distributed transaction processing (DTP) environment. In an abstract model, an X/Open application calls on <span class="italic">resource managers</span> (RMs) to provide a variety of services. For example, a database resource manager provides access to data in a database. Resource managers interact with a <span class="italic">transaction manager</span> (TM), which controls all transactions for the application.
                  </p>
                  <div class="figure" id="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207__I421811">
                     <p class="titleinfigure">Figure 5-1  Hypothetical DTP Model</p><img src="img/lnpcc005.gif" width="516" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows" longdesc="img_text/lnpcc005.html"><br><a href="img_text/lnpcc005.html">Description of "Figure 5-1  Hypothetical DTP Model"</a></div>
                  <!-- class="figure" -->
                  <p><a href="advanced-topics.html#GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207__I421811">Figure 5-1</a> shows one way that components of the DTP model can interact to provide efficient access to data in an Oracle database. The DTP model specifies the <span class="italic">XA interface</span> between resource managers and the transaction manager. Oracle supplies an XA-compliant library, which you must link to your X/Open application. Also, you must specify the <span class="italic">native interface</span> between your application program and the resource managers. <a id="d24171e3464" class="indexterm-anchor"></a><a id="d24171e3466" class="indexterm-anchor"></a><a id="d24171e3468" class="indexterm-anchor"></a><a id="d24171e3470" class="indexterm-anchor"></a><a id="d24171e3474" class="indexterm-anchor"></a></p>
                  <p>The DTP model that specifies how a transaction manager and resource managers interact with an application program is described in the X/Open guide <span class="italic">Distributed Transaction Processing Reference Model</span> and related publications, which you can obtain by writing to<a id="d24171e3483" class="indexterm-anchor"></a></p>
                  <ul class="simple" style="list-style-type: none;padding-left:0;">
                     <li>The Open Group</li>
                     <li>1010 El Camino Real, Suite 380</li>
                     <li>Menlo Park, CA  94025-4345 USA</li>
                     <li></li>
                     <li><a href="http://www.opennc.org/" target="_blank">http://www.opennc.org/</a></li>
                     <li></li>
                  </ul>
                  <p>For instructions on using the XA interface, see your Transaction Processing (TP) Monitor user's guide. </p>
               </div><a id="LNPCC3334"></a><div class="props_rev_3"><a id="GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E" name="GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E"></a><h4 id="LNPCC-GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E" class="sect4"><span class="enumeration_section">5.12.1 </span>Oracle-Specific Issues 
                  </h4>
                  <div>
                     <p>You can use the precompiler to develop applications that comply with the X/Open standards. However, you must meet the following requirements. </p>
                  </div><a id="LNPCC3335"></a><div class="props_rev_3"><a id="GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F" name="GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F"></a><h5 id="LNPCC-GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F" class="sect5"><span class="enumeration_section">5.12.1.1 </span>Connecting to Oracle 
                     </h5>
                     <div>
                        <p>The X/Open application does not establish and maintain connections to a database. Instead, the transaction manager and the XA interface, which is supplied by Oracle, handle database connections and disconnections transparently. So, normally an X/Open-compliant application does not execute CONNECT statements. </p>
                     </div>
                  </div><a id="LNPCC3336"></a><div class="props_rev_3"><a id="GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9" name="GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9"></a><h5 id="LNPCC-GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9" class="sect5"><span class="enumeration_section">5.12.1.2 </span>Transaction Control 
                     </h5>
                     <div>
                        <p>The X/Open application must not execute statements such as COMMIT, ROLLBACK, SAVEPOINT, and SET TRANSACTION that affect the state of global transactions. For example, the application must not execute the COMMIT statement because the transaction manager handles commits. Also, the application must not execute SQL data definition statements such as CREATE, ALTER, and RENAME because they issue an implicit COMMIT. </p>
                        <p>The application can execute an internal ROLLBACK statement if it detects an error that prevents further SQL operations. However, this might change in later releases of the XA interface. </p>
                     </div>
                  </div><a id="LNPCC3337"></a><div class="props_rev_3"><a id="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3" name="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3"></a><h5 id="LNPCC-GUID-72807525-DF42-47EA-AB69-17E8356D7DD3" class="sect5"><span class="enumeration_section">5.12.1.3 </span>OCI Calls (Release 7 Only)
                     </h5>
                     <div>
                        <p>OCI Calls Release 7 are no longer supported.</p>
                        <div class="infoboxnote" id="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3__GUID-5866A82C-9602-4878-96D3-67B69DF9032F">
                           <p class="notep1">Note:</p>
                           <p>The Logon Data Area (LDA) is <span class="italic">no longer supported</span> in Oracle9<span class="italic">i</span>. The ability to embed OCI Release 7 calls in your Pro*C/C++ program will be phased out by the next major Oracle release.
                           </p>
                        </div>
                        <p>If you want your X/Open application to issue OCI calls, you must use the runtime library routine <code class="codeph">sqlld2()</code>, which sets up an LDA for a specified connection established through the XA interface. For a description of the <code class="codeph">sqlld2()</code> call, see the Oracle Call Interface Programmer's Guide for Release 7<span class="italic">. </span></p>
                        <p>The following OCI calls cannot be issued by an X/Open application: OCOM, OCON, OCOF, ONBLON, ORLON, OLON, OLOGOF.</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">Interface to OCI Release 8</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCC3338"></a><div class="props_rev_3"><a id="GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3" name="GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3"></a><h5 id="LNPCC-GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3" class="sect5"><span class="enumeration_section">5.12.1.4 </span>Linking 
                     </h5>
                     <div>
                        <p>To get XA functionality, you must link the XA library to your X/Open application object modules. For instructions, see your system-specific Oracle documentation. <a id="d24171e3584" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>