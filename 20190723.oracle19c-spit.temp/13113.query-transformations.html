<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes the most important optimizer techniques for transforming queries.">
      <meta name="description" content="This chapter describes the most important optimizer techniques for transforming queries.">
      <title>Query Transformations</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQL Tuning Guide">
      <meta property="og:description" content="This chapter describes the most important optimizer techniques for transforming queries.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQL Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00">
      <meta name="dcterms.title" content="SQL Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2013, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96095-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="query-optimizer-concepts.html" title="Previous" type="text/html">
      <link rel="next" href="query-execution-plans.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="query-optimizer-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="query-execution-plans.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-optimizer-fundamentals.html" property="item" typeof="WebPage"><span property="name">Query Optimizer Fundamentals</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Query Transformations</li>
            </ol>
            <a id="GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" name="GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0"></a><a id="TGSQL94896"></a>
            
            <h2 id="TGSQL-GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" class="sect2"><span class="enumeration_chapter">5 </span>Query Transformations
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the most important optimizer techniques for transforming queries.</p>
               <p>The optimizer decides whether to use an available transformation based on cost. Transformations may not be available to the optimizer for a variety of reasons, including hints or lack of constraints. For example, transformations such as subquery unnesting are not available for hybrid partitioned tables, which contain external partitions that do not support constraints.</p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD">OR Expansion</a><br>In <code class="codeph">OR</code> expansion, the optimizer transforms a query block containing top-level disjunctions into the form of a <code class="codeph">UNION ALL</code> query that contains two or more branches. 
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD">View Merging</a><br>In <strong class="term">view merging</strong>, the optimizer merges the <strong class="term">query block</strong> representing a view into the query block that contains it. 
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709">Predicate Pushing</a><br>In <strong class="term">predicate pushing</strong>, the optimizer "pushes" the relevant predicates from the containing query block into the view query block.
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-EBE60A08-5660-44BF-BC89-AD36E941B066">Subquery Unnesting</a><br>In <strong class="term">subquery unnesting</strong>, the optimizer transforms a nested query into an equivalent join statement, and then optimizes the join.
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB">Query Rewrite with Materialized Views</a><br>A <strong class="term">materialized view</strong> is a query result stored in a table. 
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A">Statistics-Based Query Transformation</a><br>In some cases, Oracle Database can satisfy a query by querying table statistics rather than the table itself.
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421">Star Transformation</a><br>Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema. 
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-91434A26-E81E-4609-800B-4E179A63EDBC">In-Memory Aggregation (VECTOR GROUP BY)</a><br>The key optimization of in-memory aggregation is to aggregate while scanning. 
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF">Cursor-Duration Temporary Tables</a><br>To materialize the intermediate results of a query, Oracle Database may implicitly create a <strong class="term">cursor-duration temporary table</strong> in memory during query compilation.
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481">Table Expansion</a><br>In <strong class="term">table expansion</strong>, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06">Join Factorization</a><br>In the cost-based transformation known as <strong class="term">join factorization</strong>, the optimizer can factorize common computations from branches of a <code class="codeph">UNION ALL</code> query.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="query-optimizer-fundamentals.html#GUID-EF45F82A-F17D-4C79-9B6A-8CBBB95F0684" title="To tune Oracle SQL, you must understand the query optimizer. The optimizer is built-in software that determines the most efficient method for a statement to access data.">Query Optimizer Fundamentals</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL207"></a><a id="TGSQL208"></a><a id="TGSQL94842"></a><a id="TGSQL206"></a><div class="props_rev_3"><a id="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD" name="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD"></a><h3 id="TGSQL-GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD" class="sect3"><span class="enumeration_section">5.1 </span>OR Expansion
               </h3>
               <div>
                  <p>In <code class="codeph">OR</code> expansion, the optimizer transforms a query block containing top-level disjunctions into the form of a <code class="codeph">UNION ALL</code> query that contains two or more branches. 
                  </p>
                  <p>The optimizer achieves this goal by splitting the disjunction into its components, and then associating each component with a branch of a <code class="codeph">UNION ALL</code> query. The optimizer can choose <code class="codeph">OR</code> expansion for various reasons. For example, it may enable more efficient access paths or alternative join methods that avoid Cartesian products. As always, the optimizer performs the expansion only if the cost of the transformed statement is lower than the cost of the original statement.
                  </p>
                  <p>In previous releases, the optimizer used the <code class="codeph">CONCATENATION</code> operator to perform the <code class="codeph">OR</code> expansion. Starting in <span>Oracle Database 12c</span> Release 2 (12.2), the optimizer uses the <code class="codeph">UNION-ALL</code> operator instead. The framework provides the following enhancements:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Enables interaction among various transformations</p>
                     </li>
                     <li>
                        <p>Avoids sharing query structures</p>
                     </li>
                     <li>
                        <p>Enables the exploration of various search strategies</p>
                     </li>
                     <li>
                        <p>Provides the reuse of cost annotation</p>
                     </li>
                     <li>
                        <p>Supports the standard SQL syntax</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD__BABJJCIC">
                     <p class="titleinexample">Example 5-1 Transformed Query: UNION ALL Condition</p>
                     <p>To prepare for this example, log in to the database as an administrator, execute the following statements to add a unique constraint to the <code class="codeph">hr.departments.department_name</code> column, and then add 100,000 rows to the <code class="codeph">hr.employees</code> table:
                     </p><pre class="pre codeblock"><code>ALTER TABLE hr.departments ADD CONSTRAINT department_name_uk UNIQUE (department_name);
DELETE FROM hr.employees WHERE employee_id &gt; 999;
DECLARE
v_counter NUMBER(7)&nbsp;:= 1000;
BEGIN
 FOR i IN 1..100000 LOOP    
 INSERT INTO hr.employees
    VALUES (v_counter,null,'Doe','Doe' || v_counter || '@example.com',null,'07-JUN-02','AC_ACCOUNT',null,null,null,50);
 v_counter&nbsp;:= v_counter + 1;
 END LOOP;
END;
/
COMMIT; 
EXEC DBMS_STATS.GATHER_TABLE_STATS ( ownname =&gt; 'hr', tabname =&gt; 'employees');</code></pre><p>You then connect as the user <code class="codeph">hr</code>, and execute the following query, which joins the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables:
                     </p><pre class="pre codeblock"><code>SELECT *
FROM   employees e, departments d
WHERE  (e.email='SSTILES' OR d.department_name='Treasury')
AND    e.department_id = d.department_id;
</code></pre><p>Without <code class="codeph">OR</code> expansion, the optimizer treats <code class="codeph">e.email='SSTILES' OR d.department_name='Treasury'</code> as a single unit. Consequently, the optimizer cannot use the index on either  the <code class="codeph">e.email</code> or <code class="codeph">d.department_name</code> column, and so performs a full table scan of <code class="codeph">employees</code> and <code class="codeph">departments</code>. 
                     </p>
                     <p>With <code class="codeph">OR</code> expansion, the optimizer breaks the disjunctive predicate into two independent predicates, as shown in the following example:
                     </p><pre class="pre codeblock"><code>SELECT *
FROM   employees e, departments d
WHERE  e.email = 'SSTILES'
AND    e.department_id = d.department_id
UNION ALL
SELECT *
FROM   employees e, departments d
WHERE  d.department_name = 'Treasury'
AND    e.department_id = d.department_id;</code></pre><p>This transformation enables the <code class="codeph">e.email</code> and <code class="codeph">d.department_name</code> columns to serve as index keys. Performance improves because the database filters data using two unique indexes instead of two full table scans, as shown in the following execution plan:
                     </p><pre class="pre codeblock"><code>Plan hash value: 2512933241

-----------------------------------------------------------------------------------------------
| Id| Operation                              | Name             |Rows|Bytes|Cost(%CPU)|Time   |
----------------------------------------------------------------------------------------------- 
| 0 | SELECT STATEMENT                       |                  |    |     |122 (100)|        |
| 1 |  VIEW                                  |VW_ORE_19FF4E3E   |9102|1679K|122  (5) |00:00:01|
| 2 |   UNION-ALL                            |                  |    |     |         |        |
| 3 |    NESTED LOOPS                        |                  |  1 |  78 |  4  (0) |00:00:01|
| 4 |     TABLE ACCESS BY INDEX ROWID        | EMPLOYEES        |  1 |  57 |  3  (0) |00:00:01|
|*5 |      INDEX UNIQUE SCAN                 | EMP_EMAIL_UK     |  1 |     |  2  (0) |00:00:01|
| 6 |     TABLE ACCESS BY INDEX ROWID        | DEPARTMENTS      |  1 |  21 |  1  (0) |00:00:01|
|*7 |      INDEX UNIQUE SCAN                 | DEPT_ID_PK       |  1 |     |  0  (0) |        |
| 8 |    NESTED LOOPS                        |                  |9101| 693K|118  (5) |00:00:01|
| 9 |     TABLE ACCESS BY INDEX ROWID        | DEPARTMENTS      |  1 |  21 |  1  (0) |00:00:01|
|*10|      INDEX UNIQUE SCAN                 |DEPARTMENT_NAME_UK|  1 |     |  0  (0) |        |
|*11|     TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES        |9101| 506K|117  (5) |00:00:01|
|*12|      INDEX RANGE SCAN                  |EMP_DEPARTMENT_IX |9101|     | 35  (6) |00:00:01|
-----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("E"."EMAIL"='SSTILES')
   7 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
  10 - access("D"."DEPARTMENT_NAME"='Treasury')
  11 - filter(LNNVL("E"."EMAIL"='SSTILES'))
  12 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")

35 rows selected.
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL209"></a><div class="props_rev_3"><a id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" name="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD"></a><h3 id="TGSQL-GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" class="sect3"><span class="enumeration_section">5.2 </span>View Merging
               </h3>
               <div>
                  <p>In <strong class="term">view merging</strong>, the optimizer merges the <strong class="term">query block</strong> representing a view into the query block that contains it. 
                  </p>
                  <p>View merging can improve plans by enabling the optimizer to consider additional join orders, access methods, and other transformations. For example, after a view has been merged and several tables reside in one query block, a table inside a view may permit the optimizer to use <a href="glossary.html#GUID-420638C3-79BE-4ED0-955F-B7EF70685DBC"><span class="xrefglossterm">join elimination</span></a> to remove a table outside the view. 
                  </p>
                  <p>For certain simple views in which merging always leads to a better plan, the optimizer automatically merges the view without considering cost. Otherwise, the optimizer uses cost to make the determination. The optimizer may choose not to merge a view for many reasons, including cost or validity restrictions. </p>
                  <p>If <code class="codeph">OPTIMIZER_SECURE_VIEW_MERGING</code> is <code class="codeph">true</code> (default), then Oracle Database performs checks to ensure that view merging and predicate pushing do not violate the security intentions of the view creator. To disable these additional security checks for a specific view, you can grant the <code class="codeph">MERGE VIEW</code> privilege to a user for this view. To disable additional security checks for all views for a specific user, you can grant the <code class="codeph">MERGE ANY VIEW</code> privilege to that user.
                  </p>
                  <div class="infoboxnote" id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD__GUID-FFE63A81-9918-4A8E-A0CC-7499D026B110">
                     <p class="notep1">Note:</p>
                     <p>You can use hints to override view merging rejected because of cost or heuristics, but not validity.</p>
                  </div>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED">Query Blocks in View Merging</a><br>The optimizer represents each nested <strong class="term">subquery</strong> or unmerged view by a separate query block. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B">Simple View Merging</a><br>In <strong class="term">simple view merging</strong>, the optimizer merges select-project-join views. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D">Complex View Merging</a><br>In <strong class="term">view merging</strong>, the optimizer merges views containing <code class="codeph">GROUP BY</code> and <code class="codeph">DISTINCT</code> views. Like simple view merging, complex merging enables the optimizer to consider additional join orders and access paths. 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD__GUID-EF1046B0-7581-4A82-8DE0-E169FF0A75AD">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../sqlrf/GRANT.html#SQLRF01603" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information about the <code class="codeph">MERGE ANY VIEW</code> and <code class="codeph">MERGE VIEW</code> privileges
                           </p>
                        </li>
                        <li>
                           <p><a href="../refrn/OPTIMIZER_SECURE_VIEW_MERGING.html#REFRN10262" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for more information about the <code class="codeph">OPTIMIZER_SECURE_VIEW_MERGING</code> initialization parameter
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94843"></a><div class="props_rev_3"><a id="GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED" name="GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED"></a><h4 id="TGSQL-GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED" class="sect4"><span class="enumeration_section">5.2.1 </span>Query Blocks in View Merging
                  </h4>
                  <div>
                     <p>The optimizer represents each nested <strong class="term">subquery</strong> or unmerged view by a separate query block. 
                     </p>
                     <p>The database optimizes query blocks separately from the bottom up. Thus, the database optimizes the innermost query block first, generates the part of the plan for it, and then generates the plan for the outer query block, representing the entire query.</p>
                     <p>The parser expands each view referenced in a query into a separate query block. The block essentially represents the view definition, and thus the result of a view. One option for the optimizer is to analyze the view query block separately, generate a view subplan, and then process the rest of the query by using the view subplan to generate an overall execution plan. However, this technique may lead to a suboptimal execution plan because the view is optimized separately. </p>
                     <p>View merging can sometimes improve performance. As shown in <span class="q">"<a href="query-transformations.html#GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__BABIIIJD">Example 5-2</a>"</span>, view merging merges the tables from the view into the outer query block, removing the inner query block. Thus, separate optimization of the view is not necessary.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="In view merging, the optimizer merges the query block representing a view into the query block that contains it.">View Merging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94845"></a><a id="TGSQL94844"></a><div class="props_rev_3"><a id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B" name="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B"></a><h4 id="TGSQL-GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B" class="sect4"><span class="enumeration_section">5.2.2 </span>Simple View Merging
                  </h4>
                  <div>
                     <p>In <strong class="term">simple view merging</strong>, the optimizer merges select-project-join views. 
                     </p>
                     <p>For example, a query of the <code class="codeph">employees</code> table contains a subquery that joins the <code class="codeph">departments</code> and <code class="codeph">locations</code> tables.
                     </p>
                     <p>Simple view merging frequently results in a more optimal plan because of the additional join orders and access paths available after the merge. A view may not be valid for simple view merging because:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The view contains constructs not included in select-project-join views, including:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">GROUP BY</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">DISTINCT</code></p>
                              </li>
                              <li>
                                 <p>Outer join</p>
                              </li>
                              <li>
                                 <p><code class="codeph">MODEL</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">CONNECT BY</code></p>
                              </li>
                              <li>
                                 <p>Set operators</p>
                              </li>
                              <li>
                                 <p>Aggregation</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>The view appears on the right side of a <a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">semijoin</span></a> or <a href="glossary.html#GUID-4EF44AED-32FD-4FF4-9ECB-24F0011A667E"><span class="xrefglossterm">antijoin</span></a>.
                           </p>
                        </li>
                        <li>
                           <p>The view contains subqueries in the <code class="codeph">SELECT</code> list.
                           </p>
                        </li>
                        <li>
                           <p>The outer query block contains PL/SQL functions.</p>
                        </li>
                        <li>
                           <p>The view participates in an outer join, and does not meet one of the several additional validity requirements that determine whether the view can be merged.</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__BABIIIJD">
                        <p class="titleinexample">Example 5-2 Simple View Merging</p>
                        <p>The following query joins the <code class="codeph">hr.employees</code> table with the <code class="codeph">dept_locs_v</code> view, which returns the street address for each department. <code class="codeph">dept_locs_v</code> is a join of the <code class="codeph">departments</code> and <code class="codeph">locations</code> tables.
                        </p><pre class="pre codeblock"><code>SELECT e.first_name, e.last_name, dept_locs_v.street_address,
       dept_locs_v.postal_code
FROM   employees e,
      ( SELECT d.department_id, d.department_name, 
               l.street_address, l.postal_code
        FROM   departments d, locations l
        WHERE  d.location_id = l.location_id ) dept_locs_v
WHERE  dept_locs_v.department_id = e.department_id
AND    e.last_name = 'Smith';
</code></pre><p>The database can execute the preceding query by joining <code class="codeph">departments</code> and <code class="codeph">locations</code> to generate the rows of the view, and then joining this result to <code class="codeph">employees</code>. Because the query contains the view <code class="codeph">dept_locs_v</code>, and this view contains two tables, the optimizer must use one of the following join orders:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">employees</code>, <code class="codeph">dept_locs_v</code> (<code class="codeph">departments</code>, <code class="codeph">locations</code>)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">employees</code>, <code class="codeph">dept_locs_v</code> (<code class="codeph">locations</code>, <code class="codeph">departments</code>)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">dept_locs_v</code> (<code class="codeph">departments</code>, <code class="codeph">locations</code>), <code class="codeph">employees</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">dept_locs_v</code> (<code class="codeph">locations</code>, <code class="codeph">departments</code>), <code class="codeph">employees</code></p>
                           </li>
                        </ul>
                        <p>Join methods are also constrained. The index-based nested loops join is not feasible for join orders that begin with <code class="codeph">employees</code> because no index exists on the column from this view. Without view merging, the optimizer generates the following execution plan:
                        </p><pre class="pre codeblock"><code>-----------------------------------------------------------------
| Id  | Operation                    | Name        | Cost (%CPU)|
-----------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     7  (15)|
|*  1 |  HASH JOIN                   |             |     7  (15)|
|   2 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |     2   (0)|
|*  3 |    INDEX RANGE SCAN          | EMP_NAME_IX |     1   (0)|
|   4 |   VIEW                       |             |     5  (20)|
|*  5 |    HASH JOIN                 |             |     5  (20)|
|   6 |     TABLE ACCESS FULL        | LOCATIONS   |     2   (0)|
|   7 |     TABLE ACCESS FULL        | DEPARTMENTS |     2   (0)|
-----------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
1 - access("DEPT_LOCS_V"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
3 - access("E"."LAST_NAME"='Smith')
5 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
</code></pre><p>View merging merges the tables from the view into the outer query block, removing the inner query block. After view merging, the query is as follows:</p><pre class="pre codeblock"><code>SELECT e.first_name, e.last_name, l.street_address, l.postal_code
FROM   employees e, departments d, locations l
WHERE  d.location_id = l.location_id
AND    d.department_id = e.department_id
AND    e.last_name = 'Smith';
</code></pre><p>Because all three tables appear in one query block, the optimizer can choose from the following six join orders:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">employees</code>, <code class="codeph">departments</code>, <code class="codeph">locations</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">employees</code>, <code class="codeph">locations</code>, <code class="codeph">departments</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">departments</code>, <code class="codeph">employees</code>, <code class="codeph">locations</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">departments</code>, <code class="codeph">locations</code>, <code class="codeph">employees</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">locations</code>, <code class="codeph">employees</code>, <code class="codeph">departments</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">locations</code>, <code class="codeph">departments</code>, <code class="codeph">employees</code></p>
                           </li>
                        </ul>
                        <p>The joins to <code class="codeph">employees</code> and <code class="codeph">departments</code> can now be index-based. After view merging, the optimizer chooses the following more efficient plan, which uses nested loops:
                        </p><pre class="pre codeblock"><code>-------------------------------------------------------------------
| Id  | Operation                      | Name        | Cost (%CPU)|
-------------------------------------------------------------------
|   0 | SELECT STATEMENT               |             |     4   (0)|
|   1 |  NESTED LOOPS                  |             |            |
|   2 |   NESTED LOOPS                 |             |     4   (0)|
|   3 |    NESTED LOOPS                |             |     3   (0)|
|   4 |     TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |     2   (0)|
|*  5 |      INDEX RANGE SCAN          | EMP_NAME_IX |     1   (0)|
|   6 |     TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |     1   (0)|
|*  7 |      INDEX UNIQUE SCAN         | DEPT_ID_PK  |     0   (0)|
|*  8 |    INDEX UNIQUE SCAN           | LOC_ID_PK   |     0   (0)|
|   9 |   TABLE ACCESS BY INDEX ROWID  | LOCATIONS   |     1   (0)|
-------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 5 - access("E"."LAST_NAME"='Smith')
 7 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
 8 - access("D"."LOCATION_ID"="L"."LOCATION_ID")</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__GUID-5319C04F-6E6E-445C-B8DD-8A8BB70EE44D">
                        <p class="notep1">See Also:</p>
                        <p>The Oracle Optimizer blog at <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=optimizer_blog" target="_blank"><code class="codeph">https://blogs.oracle.com/optimizer/</code></a> to learn about outer join view merging, which is a special case of simple view merging
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="In view merging, the optimizer merges the query block representing a view into the query block that contains it.">View Merging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94847"></a><a id="TGSQL94848"></a><a id="TGSQL94846"></a><div class="props_rev_3"><a id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D" name="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D"></a><h4 id="TGSQL-GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D" class="sect4"><span class="enumeration_section">5.2.3 </span>Complex View Merging
                  </h4>
                  <div>
                     <p>In <strong class="term">view merging</strong>, the optimizer merges views containing <code class="codeph">GROUP BY</code> and <code class="codeph">DISTINCT</code> views. Like simple view merging, complex merging enables the optimizer to consider additional join orders and access paths. 
                     </p>
                     <p>The optimizer can delay evaluation of <code class="codeph">GROUP BY</code> or <code class="codeph">DISTINCT</code> operations until after it has evaluated the joins. Delaying these operations can improve or worsen performance depending on the data characteristics. If the joins use filters, then delaying the operation until after joins can reduce the data set on which the operation is to be performed. Evaluating the operation early can reduce the amount of data to be processed by subsequent joins, or the joins could increase the amount of data to be processed by the operation. The optimizer uses cost to evaluate view merging and merges the view only when it is the lower cost option.
                     </p>
                     <p>Aside from cost, the optimizer may be unable to perform complex view merging for the following reasons:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The outer query tables do not have a rowid or unique column.</p>
                        </li>
                        <li>
                           <p>The view appears in a <code class="codeph">CONNECT BY</code> query block.
                           </p>
                        </li>
                        <li>
                           <p>The view contains <code class="codeph">GROUPING SETS</code>, <code class="codeph">ROLLUP</code>, or <code class="codeph">PIVOT</code> clauses.
                           </p>
                        </li>
                        <li>
                           <p>The view or outer query block contains the <code class="codeph">MODEL</code> clause.
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D__GUID-A04538AB-A8AE-4ADB-8AB2-A7F9AD56720D">
                        <p class="titleinexample">Example 5-3 Complex View Joins with GROUP BY</p>
                        <p>The following view uses a <code class="codeph">GROUP BY</code> clause:
                        </p><pre class="pre codeblock"><code>CREATE VIEW cust_prod_totals_v AS
SELECT SUM(s.quantity_sold) total, s.cust_id, s.prod_id
FROM   sales s
GROUP BY s.cust_id, s.prod_id;
</code></pre><p>The following query finds all of the customers from the United States who have bought at least 100 fur-trimmed sweaters: </p><pre class="pre codeblock"><code>SELECT c.cust_id, c.cust_first_name, c.cust_last_name, c.cust_email
FROM   customers c, products p, cust_prod_totals_v
WHERE  c.country_id = 52790
AND    c.cust_id = cust_prod_totals_v.cust_id
AND    cust_prod_totals_v.total &gt; 100
AND    cust_prod_totals_v.prod_id = p.prod_id
AND    p.prod_name = 'T3 Faux Fur-Trimmed Sweater';
</code></pre><p>The <code class="codeph">cust_prod_totals_v</code> view is eligible for complex view merging. After merging, the query is as follows:
                        </p><pre class="pre codeblock"><code>SELECT c.cust_id, cust_first_name, cust_last_name, cust_email
FROM   customers c, products p, sales s
WHERE  c.country_id = 52790
AND    c.cust_id = s.cust_id
AND    s.prod_id = p.prod_id
AND    p.prod_name = 'T3 Faux Fur-Trimmed Sweater'
GROUP BY s.cust_id, s.prod_id, p.rowid, c.rowid, c.cust_email, c.cust_last_name, 
         c.cust_first_name, c.cust_id
HAVING SUM(s.quantity_sold) &gt; 100;
</code></pre><p>The transformed query is cheaper than the untransformed query, so the optimizer chooses to merge the view. In the untransformed query, the <code class="codeph">GROUP BY</code> operator applies to the entire <code class="codeph">sales</code> table in the view. In the transformed query, the joins to <code class="codeph">products</code> and <code class="codeph">customers</code> filter out a large portion of the rows from the <code class="codeph">sales</code> table, so the <code class="codeph">GROUP BY</code> operation is lower cost. The join is more expensive because the <code class="codeph">sales</code> table has not been reduced, but it is not much more expensive because the <code class="codeph">GROUP BY</code> operation does not reduce the size of the row set very much in the original query. If any of the preceding characteristics were to change, merging the view might no longer be lower cost. The final plan, which does not include a view, is as follows: 
                        </p><pre class="pre codeblock"><code>--------------------------------------------------------
| Id  | Operation             | Name      | Cost (%CPU)|
--------------------------------------------------------
|   0 | SELECT STATEMENT      |           |  2101  (18)|
|*  1 |  FILTER               |           |            |
|   2 |   HASH GROUP BY       |           |  2101  (18)|
|*  3 |    HASH JOIN          |           |  2099  (18)|
|*  4 |     HASH JOIN         |           |  1801  (19)|
|*  5 |      TABLE ACCESS FULL| PRODUCTS  |    96   (5)|
|   6 |      TABLE ACCESS FULL| SALES     |  1620  (15)|
|*  7 |     TABLE ACCESS FULL | CUSTOMERS |   296  (11)|
--------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
1 - filter(SUM("QUANTITY_SOLD")&gt;100)
3 - access("C"."CUST_ID"="CUST_ID")
4 - access("PROD_ID"="P"."PROD_ID")
5 - filter("P"."PROD_NAME"='T3 Faux Fur-Trimmed Sweater')
7 - filter("C"."COUNTRY_ID"='US')</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D__GUID-0E0A4E8B-9D0A-4C83-97DA-FF16AFF543A6">
                        <p class="titleinexample">Example 5-4 Complex View Joins with DISTINCT</p>
                        <p>The following query of the <code class="codeph">cust_prod_v</code> view uses a <code class="codeph">DISTINCT</code> operator:
                        </p><pre class="pre codeblock"><code>SELECT c.cust_id, c.cust_first_name, c.cust_last_name, c.cust_email
FROM   customers c, products p,
       ( SELECT DISTINCT s.cust_id, s.prod_id
         FROM   sales s) cust_prod_v
WHERE  c.country_id = 52790
AND    c.cust_id = cust_prod_v.cust_id
AND    cust_prod_v.prod_id = p.prod_id
AND    p.prod_name = 'T3 Faux Fur-Trimmed Sweater';
</code></pre><p>After determining that view merging produces a lower-cost plan, the optimizer rewrites the query into this equivalent query:</p><pre class="pre codeblock"><code>SELECT nwvw.cust_id, nwvw.cust_first_name, nwvw.cust_last_name, nwvw.cust_email
FROM   ( SELECT DISTINCT(c.rowid), p.rowid, s.prod_id, s.cust_id,
                c.cust_first_name, c.cust_last_name, c.cust_email
         FROM   customers c, products p, sales s
         WHERE  c.country_id = 52790
         AND    c.cust_id = s.cust_id
         AND    s.prod_id = p.prod_id
         AND    p.prod_name = 'T3 Faux Fur-Trimmed Sweater' ) nwvw;
</code></pre><p>The plan for the preceding query is as follows:</p><pre class="pre codeblock"><code>-------------------------------------------
| Id  | Operation             | Name      |
-------------------------------------------
|   0 | SELECT STATEMENT      |           |
|   1 |  VIEW                 | VM_NWVW_1 |
|   2 |   HASH UNIQUE         |           |
|*  3 |    HASH JOIN          |           |
|*  4 |     HASH JOIN         |           |
|*  5 |      TABLE ACCESS FULL| PRODUCTS  |
|   6 |      TABLE ACCESS FULL| SALES     |
|*  7 |     TABLE ACCESS FULL | CUSTOMERS |
-------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
  3 - access("C"."CUST_ID"="S"."CUST_ID")
  4 - access("S"."PROD_ID"="P"."PROD_ID")
  5 - filter("P"."PROD_NAME"='T3 Faux Fur-Trimmed Sweater')
  7 - filter("C"."COUNTRY_ID"='US')
</code></pre><p>The preceding plan contains a view named <code class="codeph">vm_nwvw_1</code>, known as a <a href="glossary.html#GUID-D55A3D23-BD08-4112-AF78-98347EF1F0C3"><span class="xrefglossterm">projection view</span></a>, even after view merging has occurred. Projection views appear in queries in which a <code class="codeph">DISTINCT</code> view has been merged, or a <code class="codeph">GROUP BY</code> view is merged into an outer query block that also contains <code class="codeph">GROUP BY</code>, <code class="codeph">HAVING</code>, or aggregates. In the latter case, the projection view contains the <code class="codeph">GROUP BY</code>, <code class="codeph">HAVING</code>, and aggregates from the original outer query block. 
                        </p>
                        <p>In the preceding example of a projection view, when the optimizer merges the view, it moves the <code class="codeph">DISTINCT</code> operator to the outer query block, and then adds several additional columns to maintain semantic equivalence with the original query. Afterward, the query can select only the desired columns in the <code class="codeph">SELECT</code> list of the outer query block. The optimization retains all of the benefits of view merging: all tables are in one query block, the optimizer can permute them as needed in the final join order, and the <code class="codeph">DISTINCT</code> operation has been delayed until after all of the joins complete. 
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="In view merging, the optimizer merges the query block representing a view into the query block that contains it.">View Merging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL210"></a><div class="props_rev_3"><a id="GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709" name="GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709"></a><h3 id="TGSQL-GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709" class="sect3"><span class="enumeration_section">5.3 </span>Predicate Pushing
               </h3>
               <div>
                  <p>In <strong class="term">predicate pushing</strong>, the optimizer "pushes" the relevant predicates from the containing query block into the view query block.
                  </p>
                  <p>For views that are not merged, this technique improves the subplan of the unmerged view. The database can use the pushed-in predicates to access indexes or to use as filters.</p>
                  <p>For example, suppose you create a table <code class="codeph">hr.contract_workers</code> as follows:
                  </p><pre class="pre codeblock"><code>DROP TABLE contract_workers;
CREATE TABLE contract_workers AS (SELECT * FROM employees where 1=2);
INSERT INTO contract_workers VALUES (306, 'Bill', 'Jones', 'BJONES',
  '555.555.2000', '07-JUN-02', 'AC_ACCOUNT', 8300, 0,205, 110);
INSERT INTO contract_workers VALUES (406, 'Jill', 'Ashworth', 'JASHWORTH', 
  '555.999.8181', '09-JUN-05', 'AC_ACCOUNT', 8300, 0,205, 50);
INSERT INTO contract_workers VALUES (506, 'Marcie', 'Lunsford', 'MLUNSFORD', 
  '555.888.2233', '22-JUL-01', 'AC_ACCOUNT', 8300, 0,205, 110);
COMMIT;
CREATE INDEX contract_workers_index ON contract_workers(department_id);
</code></pre><p>You create a view that references <code class="codeph">employees</code> and <code class="codeph">contract_workers</code>. The view is defined with a query that uses the <code class="codeph">UNION</code> set operator, as follows:
                  </p><pre class="pre codeblock"><code>CREATE VIEW all_employees_vw AS
  ( SELECT employee_id, last_name, job_id, commission_pct, department_id
    FROM   employees )
  UNION
  ( SELECT employee_id, last_name, job_id, commission_pct, department_id
    FROM   contract_workers );
</code></pre><p>You then query the view as follows:</p><pre class="pre codeblock"><code>SELECT last_name
FROM   all_employees_vw
WHERE  <span class="bold">department_id = 50</span>;
</code></pre><p>Because the view is a <code class="codeph">UNION</code> set query, the optimizer cannot merge the view's query into the accessing query block. Instead, the optimizer can transform the accessing statement by pushing its predicate, the <code class="codeph">WHERE</code> clause condition <code class="codeph">department_id=50</code>, into the view's <code class="codeph">UNION</code> set query. The equivalent transformed query is as follows:
                  </p><pre class="pre codeblock"><code>SELECT last_name
FROM   ( SELECT employee_id, last_name, job_id, commission_pct, department_id
         FROM   employees
         WHERE  <span class="bold">department_id=50</span>
         UNION
         SELECT employee_id, last_name, job_id, commission_pct, department_id
         FROM   contract_workers
         WHERE  <span class="bold">department_id=50</span> );
</code></pre><p>The transformed query can now consider index access in each of the query blocks.</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL211"></a><div class="props_rev_3"><a id="GUID-EBE60A08-5660-44BF-BC89-AD36E941B066" name="GUID-EBE60A08-5660-44BF-BC89-AD36E941B066"></a><h3 id="TGSQL-GUID-EBE60A08-5660-44BF-BC89-AD36E941B066" class="sect3"><span class="enumeration_section">5.4 </span>Subquery Unnesting
               </h3>
               <div>
                  <p>In <strong class="term">subquery unnesting</strong>, the optimizer transforms a nested query into an equivalent join statement, and then optimizes the join.
                  </p>
                  <p>This transformation enables the optimizer to consider the subquery tables during access path, join method, and join order selection. The optimizer can perform this transformation only if the resulting join statement is guaranteed to return the same rows as the original statement, and if subqueries do not contain aggregate functions such as <code class="codeph">AVG</code>.
                  </p>
                  <p>For example, suppose you connect as user <code class="codeph">sh</code> and execute the following query:
                  </p><pre class="pre codeblock"><code>SELECT * 
FROM   sales
WHERE  cust_id IN ( SELECT cust_id 
                    FROM   customers );
</code></pre><p>Because the <code class="codeph">customers.cust_id</code> column is a primary key, the optimizer can transform the complex query into the following join statement that is guaranteed to return the same data:
                  </p><pre class="pre codeblock"><code>SELECT sales.* 
FROM   sales, customers
WHERE  sales.cust_id = customers.cust_id;
</code></pre><p>If the optimizer cannot transform a complex statement into a join statement, it selects execution plans for the parent statement and the subquery as though they were separate statements. The optimizer then executes the subquery and uses the rows returned to execute the parent query. To improve execution speed of the overall execution plan, the optimizer orders the subplans efficiently.</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL212"></a><div class="props_rev_3"><a id="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" name="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB"></a><h3 id="TGSQL-GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" class="sect3"><span class="enumeration_section">5.5 </span>Query Rewrite with Materialized Views
               </h3>
               <div>
                  <p>A <strong class="term">materialized view</strong> is a query result stored in a table. 
                  </p>
                  <p>When the optimizer finds a user query compatible with the query associated with a materialized view, the database can rewrite the query in terms of the materialized view. This technique improves query execution because the database has precomputed most of the query result.</p>
                  <p>The optimizer looks for materialized views that are compatible with the user query, and then uses a cost-based algorithm to select materialized views to rewrite the query. The optimizer does not rewrite the query when the plan generated unless the materialized views has a lower cost than the plan generated with the materialized views.</p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05">About Query Rewrite and the Optimizer</a><br>A query undergoes several checks to determine whether it is a candidate for query rewrite. If the query fails any check, then the query is applied to the detail tables rather than the materialized view. The inability to rewrite can be costly in terms of response time and processing power.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-51E02736-2656-4F44-8392-98980067A97F">About Initialization Parameters for Query Rewrite</a><br>Query rewrite behavior is controlled by certain database initialization parameters.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D">About the Accuracy of Query Rewrite</a><br>Query rewrite offers three levels of rewrite integrity that are controlled by the initialization parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code>.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-19F8E323-0EE4-45AE-A88D-D29E76420206">Example of Query Rewrite</a><br>This example illustrates the power of query rewrite with materialized views.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB__GUID-D965CAB2-A6F5-40C6-BE2A-1DF5991C4371">
                     <p class="notep1">See Also:</p>
                     <p><a href="../dwhsg/basic-query-rewrite-materialized-views.html#DWHSG-GUID-DB76286B-8557-446B-A6CC-BC987C378076" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> to learn more about query rewrite
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05" name="GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05"></a><h4 id="TGSQL-GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05" class="sect4"><span class="enumeration_section">5.5.1 </span>About Query Rewrite and the Optimizer
                  </h4>
                  <div>
                     <p>A query undergoes several checks to determine whether it is a candidate for query rewrite. If the query fails any check, then the query is applied to the detail tables rather than the materialized view. The inability to rewrite can be costly in terms of response time and processing power.</p>
                     <p>The optimizer uses two different methods to determine when to rewrite a query in terms of a materialized view. The first method matches the SQL text of the query to the SQL text of the materialized view definition. If the first method fails, then the optimizer uses the more general method in which it compares joins, selections, data columns, grouping columns, and aggregate functions between the query and materialized views.</p>
                     <p>Query rewrite operates on queries and subqueries in the following types of SQL statements:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">SELECT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE TABLE  AS SELECT</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">INSERT INTO  SELECT</code> 
                           </p>
                        </li>
                     </ul>
                     <p>It also operates on subqueries in the set operators <code class="codeph">UNION</code>, <code class="codeph">UNION ALL</code> , <code class="codeph">INTERSECT</code>, and <code class="codeph">MINUS</code>, and subqueries in DML statements such as <code class="codeph">INSERT</code>, <code class="codeph">DELETE</code>, and <code class="codeph">UPDATE</code>.
                     </p>
                     <p>Dimensions, constraints, and rewrite integrity levels affect whether a query is rewritten to use materialized views. Additionally, query rewrite can be enabled or disabled by <code class="codeph">REWRITE</code> and <code class="codeph">NOREWRITE</code> hints and the <code class="codeph">QUERY_REWRITE_ENABLED</code> session parameter.
                     </p>
                     <p>The <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> procedure advises whether query rewrite is possible on a query and, if so, which materialized views are used. It also explains why a query cannot be rewritten.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="A materialized view is a query result stored in a table.">Query Rewrite with Materialized Views</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-51E02736-2656-4F44-8392-98980067A97F" name="GUID-51E02736-2656-4F44-8392-98980067A97F"></a><h4 id="TGSQL-GUID-51E02736-2656-4F44-8392-98980067A97F" class="sect4"><span class="enumeration_section">5.5.2 </span>About Initialization Parameters for Query Rewrite
                  </h4>
                  <div>
                     <p>Query rewrite behavior is controlled by certain database initialization parameters.</p>
                     <div class="tblformal" id="GUID-51E02736-2656-4F44-8392-98980067A97F__GUID-A20BF7CE-ECB9-4FA6-9237-34D926C834C3">
                        <p class="titleintable">Table 5-1 Initialization Parameters that Control Query Rewrite Behavior</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Initialization Parameters that Control Query Rewrite Behavior" summary="This table describes the initialization parameters that control query rewrite behavior." frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d16801e2267">Initialization Parameter Name</th>
                                 <th align="left" valign="bottom" width="20%" id="d16801e2269">Initialization Parameter Value</th>
                                 <th align="left" valign="bottom" width="20%" id="d16801e2271">Behavior of Query Rewrite</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2275" headers="d16801e2267 "><code class="codeph">OPTIMIZER_MODE</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2275 d16801e2269 "><code class="codeph">ALL_ROWS</code> (default), <code class="codeph">FIRST_ROWS</code>, or <code class="codeph">FIRST_ROWS_</code><span class="italic"><code class="codeph">n</code></span></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2275 d16801e2271 ">
                                    <p>With <code class="codeph">OPTIMIZER_MODE</code> set to <code class="codeph">FIRST_ROWS</code>, the optimizer uses a mix of costs and heuristics to find a best plan for fast delivery of the first few rows. When set to <code class="codeph">FIRST_ROWS_</code><span class="italic"><code class="codeph">n</code></span>, the optimizer uses a cost-based approach and optimizes with a goal of best response time to return the first <span class="italic"><code class="codeph">n</code></span> rows (where n = 1, 10, 100, 1000).
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2310" headers="d16801e2267 "><code class="codeph">QUERY_REWRITE_ENABLED</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2310 d16801e2269 "><code class="codeph">TRUE</code> (default), <code class="codeph">FALSE</code>, or <code class="codeph">FORCE</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2310 d16801e2271 ">
                                    <p>This option enables the query rewrite feature of the optimizer, enabling the optimizer to utilize materialized views to enhance performance. If set to <code class="codeph">FALSE</code>, this option disables the query rewrite feature of the optimizer and directs the optimizer not to rewrite queries using materialized views even when the estimated query cost of the unrewritten query is lower.
                                    </p>
                                    <p>If set to <code class="codeph">FORCE</code>, this option enables the query rewrite feature of the optimizer and directs the optimizer to rewrite queries using materialized views even when the estimated query cost of the unrewritten query is lower.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2334" headers="d16801e2267 "><code class="codeph">QUERY_REWRITE_INTEGRITY</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2334 d16801e2269 "><code class="codeph">STALE_TOLERATED</code>, <code class="codeph">TRUSTED</code>, or <code class="codeph">ENFORCED</code> (the default)
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2334 d16801e2271 ">
                                    <p>This parameter is optional. However, if it is set, the value must be one of these specified in the Initialization Parameter Value column.</p>
                                    <p>By default, the integrity level is set to <code class="codeph">ENFORCED</code>. In this mode, all constraints must be validated. Therefore, if you use <code class="codeph">ENABLE NOVALIDATE RELY</code> , certain types of query rewrite might not work. To enable query rewrite in this environment (where constraints have not been validated), you should set the integrity level to a lower level of granularity such as <code class="codeph">TRUSTED</code> or <code class="codeph">STALE_TOLERATED</code>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="query-transformations.html#GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" title="Query rewrite offers three levels of rewrite integrity that are controlled by the initialization parameter QUERY_REWRITE_INTEGRITY.">About the Accuracy of Query Rewrite</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="A materialized view is a query result stored in a table.">Query Rewrite with Materialized Views</a></p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" name="GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D"></a><h4 id="TGSQL-GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" class="sect4"><span class="enumeration_section">5.5.3 </span>About the Accuracy of Query Rewrite
                  </h4>
                  <div>
                     <p>Query rewrite offers three levels of rewrite integrity that are controlled by the initialization parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code>.
                     </p>
                     <p>The values that you can set for the <code class="codeph">QUERY_REWRITE_INTEGRITY</code> parameter are as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ENFORCED</code></p>
                           <p>This is the default mode. The optimizer only uses fresh data from the materialized views and only use those relationships that are based on <code class="codeph">ENABLED VALIDATED</code> primary, unique, or foreign key constraints.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">TRUSTED</code></p>
                           <p>In <code class="codeph">TRUSTED</code> mode, the optimizer trusts that the relationships declared in dimensions and <code class="codeph">RELY</code> constraints are correct. In this mode, the optimizer also uses prebuilt materialized views or materialized views based on views, and it uses relationships that are not enforced as well as those that are enforced. It also trusts declared but not <code class="codeph">ENABLED VALIDATED</code> primary or unique key constraints and data relationships specified using dimensions. This mode offers greater query rewrite capabilities but also creates the risk of incorrect results if any of the trusted relationships you have declared are incorrect.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">STALE_TOLERATED</code></p>
                           <p>In <code class="codeph">STALE_TOLERATED</code> mode, the optimizer uses materialized views that are valid but contain stale data as well as those that contain fresh data. This mode offers the maximum rewrite capability but creates the risk of generating inaccurate results.
                           </p>
                        </li>
                     </ul>
                     <p>If rewrite integrity is set to the safest level, <code class="codeph">ENFORCED</code>, the optimizer uses only enforced primary key constraints and referential integrity constraints to ensure that the results of the query are the same as the results when accessing the detail tables directly.
                     </p>
                     <p>If the rewrite integrity is set to levels other than <code class="codeph">ENFORCED</code>, there are several situations where the output with rewrite can be different from that without it:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A materialized view can be out of synchronization with the master copy of the data. This generally happens because the materialized view refresh procedure is pending following bulk load or DML operations to one or more detail tables of a materialized view. At some data warehouse sites, this situation is desirable because it is not uncommon for some materialized views to be refreshed at certain time intervals.</p>
                        </li>
                        <li>
                           <p>The relationships implied by the dimension objects are invalid. For example, values at a certain level in a hierarchy do not roll up to exactly one parent value. </p>
                        </li>
                        <li>
                           <p>The values stored in a prebuilt materialized view table might be incorrect.</p>
                        </li>
                        <li>
                           <p>A wrong answer can occur because of bad data relationships defined by unenforced table or view constraints.</p>
                        </li>
                     </ul>
                     <p>You can set <code class="codeph">QUERY_REWRITE_INTEGRITY</code> either in your initialization parameter file or using an <code class="codeph">ALTER SYSTEM</code> or <code class="codeph">ALTER SESSION</code> statement. 
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="A materialized view is a query result stored in a table.">Query Rewrite with Materialized Views</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-19F8E323-0EE4-45AE-A88D-D29E76420206" name="GUID-19F8E323-0EE4-45AE-A88D-D29E76420206"></a><h4 id="TGSQL-GUID-19F8E323-0EE4-45AE-A88D-D29E76420206" class="sect4"><span class="enumeration_section">5.5.4 </span>Example of Query Rewrite
                  </h4>
                  <div>
                     <p>This example illustrates the power of query rewrite with materialized views.</p>
                     <div class="section">
                        <p>Consider the following materialized view, <code class="codeph">cal_month_sales_mv</code>, which provides an aggregation of the dollar amount sold in every month:
                        </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW cal_month_sales_mv
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_desc, SUM(s.amount_sold) AS dollars
FROM sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</code></pre><p>Let us assume that, in a typical month, the number of sales in the store is around one million. So this materialized aggregate view has the precomputed aggregates for the dollar amount sold for each month.</p>
                        <p>Consider the following query, which asks for the sum of the amount sold at the store for each calendar month:</p><pre class="pre codeblock"><code>SELECT t.calendar_month_desc, SUM(s.amount_sold)
FROM sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</code></pre><p>In the absence of the previous materialized view and query rewrite feature, Oracle Database must access the <code class="codeph">sales</code> table directly and compute the sum of the amount sold to return the results. This involves reading many million rows from the <code class="codeph">sales</code> table, which will invariably increase the query response time due to the disk access. The join in the query will also further slow down the query response as the join needs to be computed on many million rows.
                        </p>
                        <p>In the presence of the materialized view <code class="codeph">cal_month_sales_mv</code>, query rewrite will transparently rewrite the previous query into the following query:
                        </p><pre class="pre codeblock"><code>SELECT calendar_month, dollars
FROM cal_month_sales_mv;
</code></pre><p>Because there are only a few dozen rows in the materialized view <code class="codeph">cal_month_sales_mv</code> and no joins, Oracle Database returns the results instantly. 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="A materialized view is a query result stored in a table.">Query Rewrite with Materialized Views</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A" name="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A"></a><h3 id="TGSQL-GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A" class="sect3"><span class="enumeration_section">5.6 </span>Statistics-Based Query Transformation
               </h3>
               <div>
                  <p>In some cases, Oracle Database can satisfy a query by querying table statistics rather than the table itself.</p>
                  <p>The advantage of a statistics-based transformation is that table statistics are typically much smaller than the table. The performance of metadata queries does not depend on the number of rows in the table, and therefore scales much better with large tables.</p>
                  <p>Table statistics include the number of rows and column-level details such as the minimum and maximum values and the number of distinct values (NDV). If the database knows that statistics are current, then the database can potentially answer some queries using statistics. Whether the database chooses the transformation depends on several internal factors, including the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Type of aggregation</p>
                        <p>For example, the aggregation may be <code class="codeph">MIN</code>, <code class="codeph">MAX</code>, <code class="codeph">COUNT</code>, or <code class="codeph">APPROXIMATE_COUNT_DISTINCT</code>.
                        </p>
                     </li>
                     <li>
                        <p>Accuracy of the statistics</p>
                        <p>When the data might not match the statistics, the optimizer does not perform the transformation. Factors that can make statistics inaccurate include partial (sampled) statistics, DML occurred after the last statistics collection, the statistics are imported, and artificial statistics generated with <code class="codeph">DBMS_STATS.SET_STATS</code>.
                        </p>
                     </li>
                     <li>
                        <p>Type of query</p>
                        <p>Optimizer statistics do not retain aggregation information about a group of values. For example, <code class="codeph">WHERE</code> clause predicates may prevent the optimizer from choosing the transformation.
                        </p>
                     </li>
                     <li>
                        <p>Location of query</p>
                        <p>The optimizer cannot choose the transformation when the query is inside a transaction.</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A__GUID-3682B894-DB77-49ED-A764-15CA927C72EA">
                     <p class="titleinexample">Example 5-5 Sample Query</p>
                     <p>Assume that the <code class="codeph">sales</code> table has 81 million rows. You issue the following query:
                     </p><pre class="pre codeblock"><code>SELECT MAX(amt), MAX(volume) FROM sales;</code></pre><p>If the statistics are current, then the database can transform this query into a query of data dictionary tables. In the following plan, the view prefixed <code class="codeph">VW_SQT_</code> indicates that the statistics-based transformation was possible:
                     </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
| Id  | Operation                | Name            | Rows | Bytes | Cost (%CPU)|
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |                 |      |       |   636 (100)|
|   1 |  VIEW                    | <span class="bold">VW_SQT_65BBF4BE</span> |    1 |    26 |   624  (76)|
|   2 |   SORT AGGREGATE         |                 |    1 |     7 |            |
|   3 |    PX COORDINATOR        |                 |      |       |            |
|   4 |     PX SEND QC (RANDOM)  | :TQ10000        |    1 |     7 |            |
|   5 |      SORT AGGREGATE      |                 |    1 |     7 |            |
|   6 |       PX BLOCK ITERATOR  |                 |   81M|   546M|   624  (76)|
|   7 |        TABLE ACCESS FULL | SALES           |   81M|   546M|   624  (76)|
--------------------------------------------------------------------------------</code></pre><p>The <code class="codeph">VW_SQT_65BBF4BE</code> view does not <span class="italic">prove</span> that the database retrieved statistics from the data dictionary because a DML statement might have prevented it. The plan indicates that the database may have scanned the <code class="codeph">sales</code> table.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL94897"></a><div class="props_rev_3"><a id="GUID-EA178F1F-7564-4621-B884-19A202943421" name="GUID-EA178F1F-7564-4621-B884-19A202943421"></a><h3 id="TGSQL-GUID-EA178F1F-7564-4621-B884-19A202943421" class="sect3"><span class="enumeration_section">5.7 </span>Star Transformation
               </h3>
               <div>
                  <p>Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema. </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A">About Star Schemas</a><br>A <span class="bold">star schema</span> divides data into facts and dimensions. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B">Purpose of Star Transformations</a><br>In joins of fact and dimension tables, a star transformation can avoid a full scan of a fact table.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-959DE4A3-3536-470C-90D2-855E62EB85CB">How Star Transformation Works</a><br>Star transformation adds subquery predicates, called <span class="bold">bitmap semijoin predicates</span>, corresponding to the constraint dimensions. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F">Controls for Star Transformation</a><br>The <code class="codeph">STAR_TRANSFORMATION_ENABLED</code> initialization parameter controls star transformations.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D">Star Transformation: Scenario</a><br>This scenario demonstrates a star transformation of a star query.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C">Temporary Table Transformation: Scenario</a><br>In the preceding scenario, the optimizer does not join back the table <code class="codeph">channels</code> to the <code class="codeph">sales</code> table because it is not referenced outside and the <code class="codeph">channel_id</code> is unique.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94899"></a><a id="TGSQL94898"></a><div class="props_rev_3"><a id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A" name="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A"></a><h4 id="TGSQL-GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A" class="sect4"><span class="enumeration_section">5.7.1 </span>About Star Schemas
                  </h4>
                  <div>
                     <p>A <span class="bold">star schema</span> divides data into facts and dimensions. 
                     </p>
                     <p>Facts are the measurements of an event such as a sale and are typically numbers. Dimensions are the categories that identify facts, such as date, location, and product.</p>
                     <p>A fact table has a composite key made up of the primary keys of the dimension tables of the schema. Dimension tables act as lookup or reference tables that enable you to choose values that constrain your queries.</p>
                     <p>Diagrams typically show a central fact table with lines joining it to the dimension tables, giving the appearance of a star. The following graphic shows <code class="codeph">sales</code> as the fact table and <code class="codeph">products</code>, <code class="codeph">times</code>, <code class="codeph">customers</code>, and <code class="codeph">channels</code> as the dimension tables.
                     </p>
                     <div class="figure" id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A__BABIFIGF">
                        <p class="titleinfigure">Figure 5-1 Star Schema</p><img src="img/dwhsg007.gif" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows" longdesc="img_text/dwhsg007.html"><br><a href="img_text/dwhsg007.html">Description of "Figure 5-1 Star Schema"</a></div>
                     <!-- class="figure" -->
                     <p>A <a href="glossary.html#GUID-67C99435-C3A9-4314-8533-D95973B6F12F"><span class="xrefglossterm">snowflake schema</span></a> is a star schema in which the dimension tables reference other tables. A <a href="glossary.html#GUID-C78984EF-7A22-4DDC-A3F8-DBF9FB904BDF"><span class="xrefglossterm">snowstorm schema</span></a> is a combination of snowflake schemas.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A__GUID-E202C3B2-8E47-4722-B553-4253838BE67E">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=DWHSG9069" target="_blank"><span class="italic">Oracle Database Data Warehousing Guide</span></a> to learn more about star schemas
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94900"></a><div class="props_rev_3"><a id="GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B" name="GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B"></a><h4 id="TGSQL-GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B" class="sect4"><span class="enumeration_section">5.7.2 </span>Purpose of Star Transformations
                  </h4>
                  <div>
                     <p>In joins of fact and dimension tables, a star transformation can avoid a full scan of a fact table.</p>
                     <p> The star transformation improves performance by fetching only relevant fact rows that join to the constraint dimension rows. In some cases, queries have restrictive filters on other columns of the dimension tables. The combination of filters can dramatically reduce the data set that the database processes from the fact table.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94901"></a><div class="props_rev_3"><a id="GUID-959DE4A3-3536-470C-90D2-855E62EB85CB" name="GUID-959DE4A3-3536-470C-90D2-855E62EB85CB"></a><h4 id="TGSQL-GUID-959DE4A3-3536-470C-90D2-855E62EB85CB" class="sect4"><span class="enumeration_section">5.7.3 </span>How Star Transformation Works
                  </h4>
                  <div>
                     <p>Star transformation adds subquery predicates, called <span class="bold">bitmap semijoin predicates</span>, corresponding to the constraint dimensions. 
                     </p>
                     <p>The optimizer performs the transformation when indexes exist on the fact join columns. By driving bitmap <code class="codeph">AND</code> and <code class="codeph">OR</code> operations of key values supplied by the subqueries, the database only needs to retrieve relevant rows from the fact table. If the predicates on the dimension tables filter out significant data, then the transformation can be more efficient than a full scan on the fact table.
                     </p>
                     <p>After the database has retrieved the relevant rows from the fact table, the database may need to join these rows back to the dimension tables using the original predicates. The database can eliminate the join back of the dimension table when the following conditions are met:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>All the predicates on dimension tables are part of the semijoin subquery predicate.</p>
                        </li>
                        <li>
                           <p>The columns selected from the subquery are unique.</p>
                        </li>
                        <li>
                           <p>The dimension columns are not in the <code class="codeph">SELECT</code> list, <code class="codeph">GROUP BY</code> clause, and so on.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94902"></a><div class="props_rev_3"><a id="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F" name="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F"></a><h4 id="TGSQL-GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F" class="sect4"><span class="enumeration_section">5.7.4 </span>Controls for Star Transformation
                  </h4>
                  <div>
                     <p>The <code class="codeph">STAR_TRANSFORMATION_ENABLED</code> initialization parameter controls star transformations.
                     </p>
                     <p>This parameter takes the following values:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">true</code></p>
                           <p>The optimizer performs the star transformation by identifying the fact and constraint dimension tables automatically. The optimizer performs the star transformation only if the cost of the transformed plan is lower than the alternatives. Also, the optimizer attempts temporary table transformation automatically whenever materialization improves performance (see <span class="q">"<a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C" title="In the preceding scenario, the optimizer does not join back the table channels to the sales table because it is not referenced outside and the channel_id is unique.">Temporary Table Transformation: Scenario</a>"</span>).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">false</code> (default)
                           </p>
                           <p>The optimizer does not perform star transformations.</p>
                        </li>
                        <li>
                           <p><code class="codeph">TEMP_DISABLE</code></p>
                           <p>This value is identical to <code class="codeph">true</code> except that the optimizer does not attempt temporary table transformation.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F__GUID-6AA338AA-9AED-4622-B90B-A7870A3D1416">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=REFRN10213" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">STAR_TRANSFORMATION_ENABLED</code> initialization parameter
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94904"></a><a id="TGSQL94905"></a><a id="TGSQL94906"></a><a id="TGSQL94903"></a><div class="props_rev_3"><a id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" name="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D"></a><h4 id="TGSQL-GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" class="sect4"><span class="enumeration_section">5.7.5 </span>Star Transformation: Scenario
                  </h4>
                  <div>
                     <p>This scenario demonstrates a star transformation of a star query.</p>
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABFHIIH">
                        <p class="titleinexample">Example 5-6 Star Query</p>
                        <p>The following query finds the total Internet sales amount in all cities in California for quarters Q1 and Q2 of year 1999:</p><pre class="pre codeblock"><code>SELECT c.cust_city, 
       t.calendar_quarter_desc, 
       SUM(s.amount_sold) sales_amount
FROM   sales s, 
       times t, 
       customers c, 
       channels ch
WHERE  s.time_id = t.time_id
AND    s.cust_id = c.cust_id
AND    s.channel_id = ch.channel_id
AND    c.cust_state_province = 'CA'
AND    ch.channel_desc = 'Internet'
AND    t.calendar_quarter_desc IN ('1999-01','1999-02')
GROUP BY c.cust_city, t.calendar_quarter_desc;
</code></pre><p>Sample output is as follows:</p><pre class="pre codeblock"><code>CUST_CITY                      CALENDA SALES_AMOUNT
------------------------------ ------- ------------
Montara                        1999-02      1618.01
Pala                           1999-01      3263.93
Cloverdale                     1999-01        52.64
Cloverdale                     1999-02       266.28
. . .
</code></pre><p>In this example, <code class="codeph">sales</code> is the fact table, and the other tables are dimension tables. The <code class="codeph">sales</code> table contains one row for every sale of a product, so it could conceivably contain billions of sales records. However, only a few products are sold to customers in California through the Internet for the specified quarters. 
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">
                        <p class="titleinexample">Example 5-7 Star Transformation</p>
                        <p>This example shows a star transformation of the query in <a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABFHIIH">Example 5-6</a>. The transformation avoids a full table scan of <code class="codeph">sales</code>.
                        </p><pre class="pre codeblock"><code>SELECT c.cust_city, t.calendar_quarter_desc, SUM(s.amount_sold) sales_amount
FROM   sales s, times t, customers c
WHERE  s.time_id = t.time_id
AND    s.cust_id = c.cust_id
AND    c.cust_state_province = 'CA'
AND    t.calendar_quarter_desc IN ('1999-01','1999-02')
AND    s.time_id IN ( SELECT time_id
                      FROM   times 
                      WHERE  calendar_quarter_desc IN('1999-01','1999-02') )
AND    s.cust_id IN ( SELECT cust_id
                      FROM   customers
                      WHERE  cust_state_province='CA' )
AND    s.channel_id IN ( SELECT channel_id  
                         FROM   channels 
                         WHERE  channel_desc = 'Internet' )
GROUP BY c.cust_city, t.calendar_quarter_desc;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABJECFB">
                        <p class="titleinexample">Example 5-8 Partial Execution Plan for Star Transformation</p>
                        <p>This example shows an edited version of the execution plan for the star transformation in <a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">Example 5-7</a>.
                        </p>
                        <p>Line 26 shows that the <code class="codeph">sales</code> table has an index access path instead of a full table scan. For each key value that results from the subqueries of <code class="codeph">channels</code> (line 14), <code class="codeph">times</code> (line 19), and <code class="codeph">customers</code> (line 24), the database retrieves a bitmap from the indexes on the <code class="codeph">sales</code> fact table (lines 15, 20, 25). 
                        </p>
                        <p>Each bit in the bitmap corresponds to a row in the fact table. The bit is set when the key value from the subquery is same as the value in the row of the fact table. For example, in the bitmap <code class="codeph">101000... </code>(the ellipses indicates that the values for the remaining rows are <code class="codeph">0</code>), rows 1 and 3 of the fact table have matching key values from the subquery.
                        </p>
                        <p>The operations in lines 12, 17, and 22 iterate over the keys from the subqueries and retrieve the corresponding bitmaps. In <a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">Example 5-7</a>, the <code class="codeph">customers</code> subquery seeks the IDs of customers whose state or province is <code class="codeph">CA</code>. Assume that the bitmap <code class="codeph">101000... </code>corresponds to the customer ID key value <code class="codeph">103515</code> from the <code class="codeph">customers</code> table subquery. Also assume that the <code class="codeph">customers</code> subquery produces the key value <code class="codeph">103516</code> with the bitmap <code class="codeph">010000...</code>, which means that only row 2 in <code class="codeph">sales</code> has a matching key value from the subquery. 
                        </p>
                        <p>The database merges (using the <code class="codeph">OR</code> operator) the bitmaps for each subquery (lines 11, 16, 21). In our <code class="codeph">customers</code> example, the database produces a single bitmap <code class="codeph">111000...</code> for the <code class="codeph">customers</code> subquery after merging the two bitmaps:
                        </p><pre class="pre codeblock"><code>101000...   # bitmap corresponding to key 103515
010000...   # bitmap corresponding to key 103516
---------
111000...   # result of OR operation
</code></pre><p>In line 10, the database applies the <code class="codeph">AND</code> operator to the merged bitmaps. Assume that after the database has performed all <code class="codeph">OR</code> operations, the resulting bitmap for <code class="codeph">channels</code> is <code class="codeph">100000...</code> If the database performs an <code class="codeph">AND</code> operation on this bitmap and the bitmap from <code class="codeph">customers</code> subquery, then the result is as follows:
                        </p><pre class="pre codeblock"><code>100000...   # channels bitmap after all OR operations performed
111000...   # customers bitmap after all OR operations performed
---------
100000...   # bitmap result of AND operation for channels and customers
</code></pre><p>In line 9, the database generates the corresponding rowids of the final bitmap. The database retrieves rows from the <code class="codeph">sales</code> fact table using the rowids (line 26). In our example, the database generate only one rowid, which corresponds to the first row, and thus fetches only a single row instead of scanning the entire <code class="codeph">sales</code> table. 
                        </p><pre class="pre codeblock"><code>-------------------------------------------------------------------------------
| Id  | Operation                         | Name
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |    
|   1 |  HASH GROUP BY                    | 
|*  2 |   HASH JOIN                       |
|*  3 |    TABLE ACCESS FULL              | CUSTOMERS
|*  4 |    HASH JOIN                      | 
|*  5 |     TABLE ACCESS FULL             | TIMES 
|   6 |     VIEW                          | VW_ST_B1772830 
|   7 |      NESTED LOOPS                 | 
|   8 |       PARTITION RANGE SUBQUERY    |  
|   9 |        BITMAP CONVERSION TO ROWIDS|  
|  10 |         BITMAP AND                |
|  11 |          BITMAP MERGE             | 
|  12 |           BITMAP KEY ITERATION    | 
|  13 |            BUFFER SORT            |
|* 14 |             TABLE ACCESS FULL     | CHANNELS 
|* 15 |            BITMAP INDEX RANGE SCAN| SALES_CHANNEL_BIX 
|  16 |          BITMAP MERGE             | 
|  17 |           BITMAP KEY ITERATION    |
|  18 |            BUFFER SORT            |
|* 19 |             TABLE ACCESS FULL     | TIMES 
|* 20 |            BITMAP INDEX RANGE SCAN| SALES_TIME_BIX
|  21 |          BITMAP MERGE             |
|  22 |           BITMAP KEY ITERATION    | 
|  23 |            BUFFER SORT            | 
|* 24 |             TABLE ACCESS FULL     | CUSTOMERS 
|* 25 |            BITMAP INDEX RANGE SCAN| SALES_CUST_BIX 
|  26 |       TABLE ACCESS BY USER ROWID  | SALES
-------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("ITEM_1"="C"."CUST_ID")
   3 - filter("C"."CUST_STATE_PROVINCE"='CA')
   4 - access("ITEM_2"="T"."TIME_ID")
   5 - filter(("T"."CALENDAR_QUARTER_DESC"='1999-01' 
               OR "T"."CALENDAR_QUARTER_DESC"='1999-02'))
  14 - filter("CH"."CHANNEL_DESC"='Internet')
  15 - access("S"."CHANNEL_ID"="CH"."CHANNEL_ID")
  19 - filter(("T"."CALENDAR_QUARTER_DESC"='1999-01' 
               OR "T"."CALENDAR_QUARTER_DESC"='1999-02'))
  20 - access("S"."TIME_ID"="T"."TIME_ID")
  24 - filter("C"."CUST_STATE_PROVINCE"='CA')
  25 - access("S"."CUST_ID"="C"."CUST_ID")

Note
-----
   - star transformation used for this statement
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94908"></a><a id="TGSQL94909"></a><a id="TGSQL94907"></a><div class="props_rev_3"><a id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C" name="GUID-BAE74D96-194A-4168-9490-33523BB10C1C"></a><h4 id="TGSQL-GUID-BAE74D96-194A-4168-9490-33523BB10C1C" class="sect4"><span class="enumeration_section">5.7.6 </span>Temporary Table Transformation: Scenario
                  </h4>
                  <div>
                     <p>In the preceding scenario, the optimizer does not join back the table <code class="codeph">channels</code> to the <code class="codeph">sales</code> table because it is not referenced outside and the <code class="codeph">channel_id</code> is unique.
                     </p>
                     <p>If the optimizer cannot eliminate the join back, however, then the database stores the subquery results in a temporary table to avoid rescanning the dimension table for bitmap key generation and join back. Also, if the query runs in parallel, then the database materializes the results so that each parallel execution server can select the results from the temporary table instead of executing the subquery again.</p>
                     <div class="example" id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJIEJ">
                        <p class="titleinexample">Example 5-9 Star Transformation Using Temporary Table</p>
                        <p>In this example, the database materializes the results of the subquery on <code class="codeph">customers</code> into a temporary table:
                        </p><pre class="pre codeblock"><code>SELECT t1.c1 cust_city, t.calendar_quarter_desc calendar_quarter_desc, 
       SUM(s.amount_sold) sales_amount
FROM   sales s, sh.times t, sys_temp_0fd9d6621_e7e24 t1 
WHERE  s.time_id=t.time_id
AND    s.cust_id=t1.c0
AND    (t.calendar_quarter_desc='1999-q1' OR t.calendar_quarter_desc='1999-q2')
AND    s.cust_id IN    ( SELECT t1.c0 
                         FROM   sys_temp_0fd9d6621_e7e24 t1 )
AND    s.channel_id IN ( SELECT ch.channel_id 
                         FROM   channels ch
                         WHERE  ch.channel_desc='internet' )
AND    s.time_id IN    ( SELECT t.time_id
                         FROM   times t
                         WHERE  t.calendar_quarter_desc='1999-q1'
                         OR     t.calendar_quarter_desc='1999-q2' )
GROUP BY t1.c1, t.calendar_quarter_desc
</code></pre><div class="p">The optimizer replaces <code class="codeph">customers</code> with the temporary table <code class="codeph">sys_temp_0fd9d6621_e7e24</code>, and replaces references to columns <code class="codeph">cust_id</code> and <code class="codeph">cust_city</code> with the corresponding columns of the temporary table. The database creates the temporary table with two columns: <code class="codeph">(c0 NUMBER, c1 VARCHAR2(30))</code>. These columns correspond to <code class="codeph">cust_id</code> and <code class="codeph">cust_city</code> of the <code class="codeph">customers</code> table. The database populates the temporary table by executing the following query at the beginning of the execution of the previous query:<pre class="pre codeblock"><code>SELECT c.cust_id, c.cust_city FROM customers WHERE c.cust_state_province = 'CA'
</code></pre></div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJJCH">
                        <p class="titleinexample">Example 5-10 Partial Execution Plan for Star Transformation Using Temporary Table</p>
                        <p>The following example shows an edited version of the execution plan for the query in <a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJIEJ">Example 5-9</a>:
                        </p><pre class="pre codeblock"><code>-------------------------------------------------------------------------------
| Id  | Operation                          | Name
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                   |
|   1 |  TEMP TABLE TRANSFORMATION         |
|   2 |   LOAD AS SELECT                   |
|*  3 |    TABLE ACCESS FULL               | CUSTOMERS
|   4 |   HASH GROUP BY                    | 
|*  5 |    HASH JOIN                       | 
|   6 |     TABLE ACCESS FULL              | SYS_TEMP_0FD9D6613_C716F 
|*  7 |     HASH JOIN                      | 
|*  8 |      TABLE ACCESS FULL             | TIMES 
|   9 |      VIEW                          | VW_ST_A3F94988 
|  10 |       NESTED LOOPS                 | 
|  11 |        PARTITION RANGE SUBQUERY    | 
|  12 |         BITMAP CONVERSION TO ROWIDS| 
|  13 |          BITMAP AND                | 
|  14 |           BITMAP MERGE             | 
|  15 |            BITMAP KEY ITERATION    |  
|  16 |             BUFFER SORT            |  
|* 17 |              TABLE ACCESS FULL     | CHANNELS 
|* 18 |             BITMAP INDEX RANGE SCAN| SALES_CHANNEL_BIX 
|  19 |           BITMAP MERGE             |  
|  20 |            BITMAP KEY ITERATION    | 
|  21 |             BUFFER SORT            |  
|* 22 |              TABLE ACCESS FULL     | TIMES 
|* 23 |             BITMAP INDEX RANGE SCAN| SALES_TIME_BIX 
|  24 |           BITMAP MERGE             |  
|  25 |            BITMAP KEY ITERATION    |  
|  26 |             BUFFER SORT            | 
|  27 |              TABLE ACCESS FULL     | SYS_TEMP_0FD9D6613_C716F 
|* 28 |             BITMAP INDEX RANGE SCAN| SALES_CUST_BIX 
|  29 |        TABLE ACCESS BY USER ROWID  | SALES 
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter("C"."CUST_STATE_PROVINCE"='CA')
   5 - access("ITEM_1"="C0")
   7 - access("ITEM_2"="T"."TIME_ID")
   8 - filter(("T"."CALENDAR_QUARTER_DESC"='1999-01' OR 
               "T"."CALENDAR_QUARTER_DESC"='1999-02'))
  17 - filter("CH"."CHANNEL_DESC"='Internet')
  18 - access("S"."CHANNEL_ID"="CH"."CHANNEL_ID")
  22 - filter(("T"."CALENDAR_QUARTER_DESC"='1999-01' OR 
               "T"."CALENDAR_QUARTER_DESC"='1999-02'))
  23 - access("S"."TIME_ID"="T"."TIME_ID")
  28 - access("S"."CUST_ID"="C0")
</code></pre><p>Lines 1, 2, and 3 of the plan materialize the <code class="codeph">customers</code> subquery into the temporary table. In line 6, the database scans the temporary table (instead of the subquery) to build the bitmap from the fact table. Line 27 scans the temporary table for joining back instead of scanning <code class="codeph">customers</code>. The database does not need to apply the filter on <code class="codeph">customers</code> on the temporary table because the filter is applied while materializing the temporary table.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-91434A26-E81E-4609-800B-4E179A63EDBC" name="GUID-91434A26-E81E-4609-800B-4E179A63EDBC"></a><h3 id="TGSQL-GUID-91434A26-E81E-4609-800B-4E179A63EDBC" class="sect3"><span class="enumeration_section">5.8 </span>In-Memory Aggregation (VECTOR GROUP BY)
               </h3>
               <div>
                  <p>The key optimization of in-memory aggregation is to aggregate while scanning. </p>
                  <p>To optimize query blocks involving aggregation and joins from a single large table to multiple small tables, such as in a typical star query, the transformation uses <code class="codeph">KEY VECTOR</code> and <code class="codeph">VECTOR GROUP BY</code> operations. These operations use efficient in-memory arrays for joins and aggregation, and are especially effective when the underlying tables are in-memory columnar tables.
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-91434A26-E81E-4609-800B-4E179A63EDBC__GUID-750067BA-1F6C-4940-A511-94EED9B18972">
                     <p class="notep1">See Also:</p>
                     <p><a href="../inmem/optimizing-in-memory-aggregation.html#INMEM-GUID-2C4FA6C6-3DA8-4CEA-9EF0-294396D15077" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a> to learn more about in-memory aggregation
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" name="GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF"></a><h3 id="TGSQL-GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" class="sect3"><span class="enumeration_section">5.9 </span>Cursor-Duration Temporary Tables
               </h3>
               <div>
                  <p>To materialize the intermediate results of a query, Oracle Database may implicitly create a <strong class="term">cursor-duration temporary table</strong> in memory during query compilation.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB">Purpose of Cursor-Duration Temporary Tables</a><br>Complex queries sometimes process the same query block multiple times, which creates unnecessary performance overhead.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754">How Cursor-Duration Temporary Tables Work</a><br>The definition of the cursor-definition temporary table resides in memory. The table definition is associated with the cursor, and is only visible to the session executing the cursor.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26">Cursor-Duration Temporary Tables: Example</a><br>A <code class="codeph">WITH</code> query that repeats the same subquery can sometimes benefit from a cursor-duration temporary table.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB" name="GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB"></a><h4 id="TGSQL-GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB" class="sect4"><span class="enumeration_section">5.9.1 </span>Purpose of Cursor-Duration Temporary Tables
                  </h4>
                  <div>
                     <p>Complex queries sometimes process the same query block multiple times, which creates unnecessary performance overhead.</p>
                     <p>To avoid this scenario, Oracle Database can automatically create temporary tables for the query results and store them in memory for the duration of the cursor. For complex operations such as <code class="codeph">WITH</code> clause queries, star transformations, and grouping sets, this optimization enhances the materialization of intermediate results from repetitively used subqueries. In this way, cursor-duration temporary tables improve performance and optimize I/O.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="To materialize the intermediate results of a query, Oracle Database may implicitly create a cursor-duration temporary table in memory during query compilation.">Cursor-Duration Temporary Tables</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754" name="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754"></a><h4 id="TGSQL-GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754" class="sect4"><span class="enumeration_section">5.9.2 </span>How Cursor-Duration Temporary Tables Work
                  </h4>
                  <div>
                     <p>The definition of the cursor-definition temporary table resides in memory. The table definition is associated with the cursor, and is only visible to the session executing the cursor.</p>
                     <p>When using cursor-duration temporary tables, the database performs the following steps:</p>
                     <ol>
                        <li>
                           <p>Chooses a plan that uses a cursor-duration temporary table</p>
                        </li>
                        <li>
                           <p>Creates the temporary table using a unique name</p>
                        </li>
                        <li>
                           <p>Rewrites the query to refer to the temporary table</p>
                        </li>
                        <li>
                           <p>Loads data into memory until no memory remains, in which case it creates temporary segments on disk</p>
                        </li>
                        <li>
                           <p>Executes the query, returning data from the temporary table</p>
                        </li>
                        <li>
                           <p>Truncates the table, releasing memory and any on-disk temporary segments</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754__GUID-28464ECB-EDE7-450C-B854-9BC61914674C">
                        <p class="notep1">Note:</p>
                        <p>The metadata for the cursor-duration temporary table stays in memory as long as the cursor is in memory. The metadata is not stored in the data dictionary, which means it is not visible through data dictionary views. You cannot drop the metadata explicitly.</p>
                     </div>
                     <p>The preceding scenario depends on the availability of memory. For serial queries, the temporary tables use PGA memory.</p>
                     <p>The implementation of cursor-duration temporary tables is similar to sorts. If no more memory is available, then the database writes data to temporary segments. For cursor-duration temporary tables, the differences are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The database releases memory and temporary segments at the end of the query rather than when the <a href="glossary.html#GUID-BDE98BD8-BC33-45AD-97BF-81831BF94B04"><span class="xrefglossterm">row source</span></a> is no longer active.
                           </p>
                        </li>
                        <li>
                           <p>Data in memory stays in memory, unlike in sorts where data can move between memory and temporary segments.</p>
                        </li>
                     </ul>
                     <p>When the database uses cursor-duration temporary tables, the keyword&nbsp;<code class="codeph">CURSOR DURATION MEMORY</code> appears in the execution plan. 
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="To materialize the intermediate results of a query, Oracle Database may implicitly create a cursor-duration temporary table in memory during query compilation.">Cursor-Duration Temporary Tables</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26" name="GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26"></a><h4 id="TGSQL-GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26" class="sect4"><span class="enumeration_section">5.9.3 </span>Cursor-Duration Temporary Tables: Example
                  </h4>
                  <div>
                     <p>A <code class="codeph">WITH</code> query that repeats the same subquery can sometimes benefit from a cursor-duration temporary table.
                     </p>
                     <div class="section">
                        <p>The following query uses a <code class="codeph">WITH</code> clause to create three subquery blocks:
                        </p><pre class="pre codeblock"><code>WITH 
  q1 AS (SELECT department_id, SUM(salary) sum_sal FROM hr.employees GROUP BY department_id),
  q2 AS (SELECT * FROM q1),
  q3 AS (SELECT department_id, sum_sal FROM q1)
SELECT * FROM q1
UNION ALL
SELECT * FROM q2
UNION ALL
SELECT * FROM q3;</code></pre><p>The following sample plan shows the transformation:</p><pre class="pre codeblock"><code>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(FORMAT=&gt;'BASIC +ROWS +COST'));

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------
| Id | Operation                                 | Name                  |Rows |Cost (%CPU)|
--------------------------------------------------------------------------------------------
|  0 | SELECT STATEMENT                          |                           |     |6 (100)|
|  1 |  TEMP TABLE TRANSFORMATION                |                           |     |       |
|  2 |   LOAD AS SELECT (<span class="bold">CURSOR DURATION MEMORY</span>) | SYS_TEMP_0FD9D6606_1AE004 |     |       |
|  3 |    HASH GROUP BY                          |                           |  11 | 3 (34)|
|  4 |     TABLE ACCESS FULL                     | EMPLOYEES                 | 107 | 2 (0) |
|  5 |   UNION-ALL                               |                           |     |       |
|  6 |    VIEW                                   |                           |  11 | 2 (0) |
|  7 |     TABLE ACCESS FULL                     | SYS_TEMP_0FD9D6606_1AE004 |  11 | 2 (0) |
|  8 |    VIEW                                   |                           |  11 | 2 (0) |
|  9 |     TABLE ACCESS FULL                     | SYS_TEMP_0FD9D6606_1AE004 |  11 | 2 (0) |
| 10 |    VIEW                                   |                           |  11 | 2 (0) |
| 11 |     TABLE ACCESS FULL                     | SYS_TEMP_0FD9D6606_1AE004 |  11 | 2 (0) |
--------------------------------------------------------------------------------------------</code></pre><p>In the preceding plan, <code class="codeph">TEMP TABLE TRANSFORMATION</code> in Step 1 indicates that the database used cursor-duration temporary tables to execute the query. The <code class="codeph">CURSOR DURATION MEMORY</code> keyword in Step 2 indicates that the database used memory, if available, to store the results of <code class="codeph">SYS_TEMP_0FD9D6606_1AE004</code>. If memory was unavailable, then the database wrote the temporary data to disk.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="To materialize the intermediate results of a query, Oracle Database may implicitly create a cursor-duration temporary table in memory during query compilation.">Cursor-Duration Temporary Tables</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL94910"></a><div class="props_rev_3"><a id="GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" name="GUID-6A6748FA-5803-4837-9A9F-525ED09BE481"></a><h3 id="TGSQL-GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" class="sect3"><span class="enumeration_section">5.10 </span>Table Expansion
               </h3>
               <div>
                  <p>In <strong class="term">table expansion</strong>, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21">Purpose of Table Expansion</a><br>Index-based plans can improve performance, but index maintenance creates overhead. In many databases, DML affects only a small portion of the data.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0">How Table Expansion Works</a><br>Table partitioning makes table expansion possible.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-74BE3861-35D4-453C-A983-F3317CDA8338">Table Expansion: Scenario</a><br>The optimizer keeps track of which partitions must be accessed from each table, based on predicates that appear in the query. Partition pruning enables the optimizer to use table expansion to generate more optimal plans.
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9">Table Expansion and Star Transformation: Scenario</a><br>Star transformation enables specific types of queries to avoid accessing large portions of big fact tables.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94911"></a><div class="props_rev_3"><a id="GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21" name="GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21"></a><h4 id="TGSQL-GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21" class="sect4"><span class="enumeration_section">5.10.1 </span>Purpose of Table Expansion
                  </h4>
                  <div>
                     <p>Index-based plans can improve performance, but index maintenance creates overhead. In many databases, DML affects only a small portion of the data.</p>
                     <p>Table expansion uses index-based plans for high-update tables. You can create an index only on the read-mostly data, eliminating index overhead on the active data. In this way, table expansion improves performance while avoiding index maintenance.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="In table expansion, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.">Table Expansion</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94912"></a><div class="props_rev_3"><a id="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0" name="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0"></a><h4 id="TGSQL-GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0" class="sect4"><span class="enumeration_section">5.10.2 </span>How Table Expansion Works
                  </h4>
                  <div>
                     <p>Table partitioning makes table expansion possible.</p>
                     <p>If a local index exists on a partitioned table, then the optimizer can mark the index as unusable for specific partitions. In effect, some partitions are not indexed. </p>
                     <p>In table expansion, the optimizer transforms the query into a <code class="codeph">UNION ALL</code> statement, with some subqueries accessing indexed partitions and other subqueries accessing unindexed partitions. The optimizer can choose the most efficient access method available for a partition, regardless of whether it exists for all of the partitions accessed in the query.
                     </p>
                     <p>The optimizer does not always choose table expansion:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Table expansion is cost-based.</p>
                           <p>While the database accesses each partition of the expanded table only once across all branches of the <code class="codeph">UNION ALL</code>, any tables that the database joins to it are accessed in each branch.
                           </p>
                        </li>
                        <li>
                           <p>Semantic issues may render expansion invalid.</p>
                           <p>For example, a table appearing on the right side of an outer join is not valid for table expansion.</p>
                        </li>
                     </ul>
                     <p>You can control table expansion with the hint <code class="codeph">EXPAND_TABLE</code> hint. The hint overrides the cost-based decision, but not the semantic checks.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0__GUID-A49F5B51-DA14-4F51-8FA0-5AC8CFFD0C1C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-C558F7CF-446E-4078-B045-0B3BB026CB3C" title="Optimizer hints are special comments in a SQL statement that pass instructions to the optimizer.">Influencing the Optimizer with Hints</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Comments.html#SQLRF00219" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about SQL hints
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="In table expansion, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.">Table Expansion</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94914"></a><a id="TGSQL94913"></a><div class="props_rev_3"><a id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338" name="GUID-74BE3861-35D4-453C-A983-F3317CDA8338"></a><h4 id="TGSQL-GUID-74BE3861-35D4-453C-A983-F3317CDA8338" class="sect4"><span class="enumeration_section">5.10.3 </span>Table Expansion: Scenario
                  </h4>
                  <div>
                     <p>The optimizer keeps track of which partitions must be accessed from each table, based on predicates that appear in the query. Partition pruning enables the optimizer to use table expansion to generate more optimal plans.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-D7D5B988-6B9F-4142-8159-DFF3F7304753">Assumptions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This scenario assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You want to run a star query against the <code class="codeph">sh.sales</code> table, which is range-partitioned on the <code class="codeph">time_id</code> column.
                              </p>
                           </li>
                           <li>
                              <p>You want to disable indexes on specific partitions to see the benefits of table expansion.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-6C7901A3-FE3B-4E46-8D2F-437A378F230A">To use table expansion:</p>
                        <ol>
                           <li>
                              <p>Log in to the database as the <code class="codeph">sh</code> user.
                              </p>
                           </li>
                           <li>
                              <p>Run the following query: </p><pre class="pre codeblock"><code>SELECT * 
FROM   sales 
WHERE  time_id &gt;= TO_DATE('2000-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS') 
AND    prod_id = 38;
</code></pre></li>
                           <li>
                              <p>Explain the plan by querying <code class="codeph">DBMS_XPLAN</code>:
                              </p><pre class="pre codeblock"><code>SET LINESIZE 150
SET PAGESIZE 0
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format =&gt; 'BASIC,PARTITION'));
</code></pre><p>As shown in the <code class="codeph">Pstart</code> and <code class="codeph">Pstop</code> columns in the following plan, the optimizer determines from the filter that only 16 of the 28 partitions in the table must be accessed:
                              </p><pre class="pre codeblock"><code>Plan hash value: 3087065703
 
--------------------------------------------------------------------------
|Id| Operation                                  | Name      |Pstart|Pstop|
--------------------------------------------------------------------------
| 0| SELECT STATEMENT                           |              |    |    |
| 1|  PARTITION RANGE ITERATOR                  |              | 13 | 28 |
| 2|   TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES        | 13 | 28 |
| 3|    BITMAP CONVERSION TO ROWIDS             |              |    |    |
|*4|     BITMAP INDEX SINGLE VALUE              |SALES_PROD_BIX| 13 | 28 |
--------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("PROD_ID"=38)
</code></pre><p>After the optimizer has determined the partitions to be accessed, it considers any index that is usable on all of those partitions. In the preceding plan, the optimizer chose to use the <code class="codeph">sales_prod_bix</code> bitmap index.
                              </p>
                           </li>
                           <li>
                              <p>Disable the index on the <code class="codeph">SALES_1995</code> partition of the <code class="codeph">sales</code> table:
                              </p><pre class="pre codeblock"><code>i</code></pre><p>The preceding DDL disables the index on partition 1, which contains all sales from before 1996.</p>
                              <div class="infoboxnote" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-29D9127A-F87D-49B3-AEC0-85DBFFA916B8">
                                 <p class="notep1">Note:</p>
                                 <p>You can obtain the partition information by querying the <code class="codeph">USER_IND_PARTITIONS</code> view.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>Execute the query of sales again, and then query <code class="codeph">DBMS_XPLAN</code> to obtain the plan.
                              </p>
                              <p>The output shows that the plan did not change:</p><pre class="pre codeblock"><code>Plan hash value: 3087065703
 
---------------------------------------------------------------------------
|Id| Operation                                  | Name        |Pstart|Pstop
---------------------------------------------------------------------------
| 0| SELECT STATEMENT                           |               |    |    |
| 1|  PARTITION RANGE ITERATOR                  |               | 13 | 28 |
| 2|   TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES         | 13 | 28 |
| 3|    BITMAP CONVERSION TO ROWIDS             |               |    |    |
|*4|     BITMAP INDEX SINGLE VALUE              | SALES_PROD_BIX| 13 | 28 |
---------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("PROD_ID"=38)
</code></pre><p>The plan is the same because the disabled index partition is not relevant to the query. If all partitions that the query accesses are indexed, then the database can answer the query using the index. Because the query only accesses partitions 16 through 28, disabling the index on partition 1 does not affect the plan.</p>
                           </li>
                           <li>
                              <p>Disable the indexes for partition 28 (<code class="codeph">SALES_Q4_2003</code>), which is a partition that the query needs to access:
                              </p><pre class="pre codeblock"><code>ALTER INDEX sales_prod_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;
ALTER INDEX sales_time_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;
</code></pre><p>By disabling the indexes on a partition that the query does need to access, the query can no longer use this index (without table expansion). </p>
                           </li>
                           <li>
                              <p>Query the plan using <code class="codeph">DBMS_XPLAN</code>.
                              </p>
                              <p>As shown in the following plan, the optimizer does not use the index:</p><pre class="pre codeblock"><code>Plan hash value: 3087065703
 
---------------------------------------------------------------------------
| Id| Operation                              | Name           |Pstart|Pstop
---------------------------------------------------------------------------
| 0 | SELECT STATEMENT                       |                |      |    |
| 1 |  PARTITION RANGE ITERATOR              |                |  13  | 28 |
|*2 |   TABLE ACCESS FULL                    | SALES          |  13  | 28 |
---------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("PROD_ID"=38)
</code></pre><p>In the preceding example, the query accesses 16 partitions. On 15 of these partitions, an index is available, but no index is available for the final partition. Because the optimizer has to choose one access path or the other, the optimizer cannot use the index on any of the partitions. </p>
                           </li>
                           <li>
                              <p>With table expansion, the optimizer rewrites the original query as follows:</p><pre class="pre codeblock"><code>SELECT * 
FROM   sales 
WHERE  time_id &gt;= TO_DATE('2000-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS') 
AND    time_id <span class="bold">&lt;</span>  TO_DATE('2003-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS')
AND    prod_id = 38
UNION ALL
SELECT * 
FROM   sales 
WHERE  time_id &gt;= TO_DATE('2003-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS') 
AND    time_id <span class="bold">&lt;</span> TO_DATE('2004-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS')
AND    prod_id = 38;
</code></pre><p>In the preceding query, the first query block in the <code class="codeph">UNION ALL</code> accesses the partitions that are indexed, while the second query block accesses the partition that is not. The two subqueries enable the optimizer to choose to use the index in the first query block, if it is more optimal than using a table scan of all of the partitions that are accessed.
                              </p>
                           </li>
                           <li>
                              <p>Query the plan using <code class="codeph">DBMS_XPLAN</code>. 
                              </p>
                              <p>The plan appears as follows:</p><pre class="pre codeblock"><code>Plan hash value: 2120767686
 
---------------------------------------------------------------------------
|Id| Operation                                    | Name     |Pstart|Pstop|
---------------------------------------------------------------------------
| 0| SELECT STATEMENT                             |               |   |   |
| 1|  VIEW                                        | VW_TE_2       |   |   |
| 2|   UNION-ALL                                  |               |   |   |
| 3|    PARTITION RANGE ITERATOR                  |               | 13| 27|
| 4|     TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES         | 13| 27|
| 5|      BITMAP CONVERSION TO ROWIDS             |               |   |   |
|*6|       BITMAP INDEX SINGLE VALUE              | SALES_PROD_BIX| 13| 27|
| 7|    PARTITION RANGE SINGLE                    |               | 28| 28|
|*8|     TABLE ACCESS FULL                        | SALES         | 28| 28|
---------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   6 - access("PROD_ID"=38)
   8 - filter("PROD_ID"=38)
</code></pre><p>As shown in the preceding plan, the optimizer uses a <code class="codeph">UNION ALL</code> for two query blocks (Step 2). The optimizer chooses an index to access partitions 13 to 27 in the first query block (Step 6). Because no index is available for partition 28, the optimizer chooses a full table scan in the second query block (Step 8).
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="In table expansion, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.">Table Expansion</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94916"></a><a id="TGSQL94915"></a><div class="props_rev_3"><a id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9" name="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9"></a><h4 id="TGSQL-GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9" class="sect4"><span class="enumeration_section">5.10.4 </span>Table Expansion and Star Transformation: Scenario
                  </h4>
                  <div>
                     <p>Star transformation enables specific types of queries to avoid accessing large portions of big fact tables.</p>
                     <div class="section">
                        <p>Star transformation requires defining several indexes, which in an actively updated table can have overhead. With table expansion, you can define indexes on only the inactive partitions so that the optimizer can consider star transformation on only the indexed portions of the table.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9__GUID-FCFEED11-4D8A-4933-AEEB-8FC4C04745FB">Assumptions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This scenario assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You query the same schema used in <span class="q">"<a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" title="This scenario demonstrates a star transformation of a star query.">Star Transformation: Scenario</a>"</span>. 
                              </p>
                           </li>
                           <li>
                              <p>The last partition of <code class="codeph">sales</code> is actively being updated, as is often the case with time-partitioned tables.
                              </p>
                           </li>
                           <li>
                              <p>You want the optimizer to take advantage of table expansion.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9__GUID-62BA2BF6-BFE1-4327-BC17-923935B4B477">To take advantage of table expansion in a star query:</p>
                        <ol>
                           <li>
                              <p>Disable the indexes on the last partition as follows:</p><pre class="pre codeblock"><code>ALTER INDEX sales_channel_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;
ALTER INDEX sales_cust_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;
</code></pre></li>
                           <li>
                              <p>Execute the following star query:</p><pre class="pre codeblock"><code>SELECT t.calendar_quarter_desc, SUM(s.amount_sold) sales_amount 
FROM   sales s, times t, customers c, channels ch
WHERE  s.time_id = t.time_id 
AND    s.cust_id = c.cust_id 
AND    s.channel_id = ch.channel_id 
AND    c.cust_state_province = 'CA' 
AND    ch.channel_desc = 'Internet'
AND    t.calendar_quarter_desc IN ('1999-01','1999-02') 
GROUP BY t.calendar_quarter_desc;
</code></pre></li>
                           <li>
                              <p>Query the cursor using <code class="codeph">DBMS_XPLAN</code>, which shows the following plan:
                              </p><pre class="pre codeblock"><code>---------------------------------------------------------------------------
|Id| Operation                          | Name            | Pstart| Pstop |
---------------------------------------------------------------------------
| 0| SELECT STATEMENT                   |                 |       |       |
| 1|  HASH GROUP BY                     |                 |       |       |
| 2|   VIEW                             |VW_TE_14         |       |       |
| 3|    UNION-ALL                       |                 |       |       |
| 4|     HASH JOIN                      |                 |       |       |
| 5|      TABLE ACCESS FULL             |TIMES            |       |       |
| 6|      VIEW                          |VW_ST_1319B6D8   |       |       |
| 7|       NESTED LOOPS                 |                 |       |       |
| 8|        PARTITION RANGE SUBQUERY    |                 |KEY(SQ)|KEY(SQ)|
| 9|         BITMAP CONVERSION TO ROWIDS|                 |       |       |
|10|          BITMAP AND                |                 |       |       |
|11|           BITMAP MERGE             |                 |       |       |
|12|            BITMAP KEY ITERATION    |                 |       |       |
|13|             BUFFER SORT            |                 |       |       |
|14|              TABLE ACCESS FULL     |CHANNELS         |       |       |
|15|             BITMAP INDEX RANGE SCAN|SALES_CHANNEL_BIX|KEY(SQ)|KEY(SQ)|
|16|           BITMAP MERGE             |                 |       |       |
|17|            BITMAP KEY ITERATION    |                 |       |       |
|18|             BUFFER SORT            |                 |       |       |
|19|              TABLE ACCESS FULL     |TIMES            |       |       |
|20|             BITMAP INDEX RANGE SCAN|SALES_TIME_BIX   |KEY(SQ)|KEY(SQ)|
|21|           BITMAP MERGE             |                 |       |       |
|22|            BITMAP KEY ITERATION    |                 |       |       |
|23|             BUFFER SORT            |                 |       |       |
|24|              TABLE ACCESS FULL     |CUSTOMERS        |       |       |
|25|             BITMAP INDEX RANGE SCAN|SALES_CUST_BIX   |KEY(SQ)|KEY(SQ)|
|26|        TABLE ACCESS BY USER ROWID  |SALES            | ROWID | ROWID |
|27|     NESTED LOOPS                   |                 |       |       |
|28|      NESTED LOOPS                  |                 |       |       |
|29|       NESTED LOOPS                 |                 |       |       |
|30|        NESTED LOOPS                |                 |       |       |
|31|         PARTITION RANGE SINGLE     |                 |    28 |    28 |
|32|          <span class="bold">TABLE ACCESS FULL</span>         |<span class="bold">SALES</span>            |    <span class="bold">28</span> |    <span class="bold">28</span> |
|33|         TABLE ACCESS BY INDEX ROWID|CHANNELS         |       |       |
|34|          INDEX UNIQUE SCAN         |CHANNELS_PK      |       |       |
|35|        TABLE ACCESS BY INDEX ROWID |CUSTOMERS        |       |       |
|36|         INDEX UNIQUE SCAN          |CUSTOMERS_PK     |       |       |
|37|       INDEX UNIQUE SCAN            |TIMES_PK         |       |       |
|38|      TABLE ACCESS BY INDEX ROWID   |TIMES            |       |       |
---------------------------------------------------------------------------
</code></pre><p>The preceding plan uses table expansion. The <code class="codeph">UNION ALL</code> branch that is accessing every partition except the last partition uses star transformation. Because the indexes on partition 28 are disabled, the database accesses the final partition using a full table scan.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="In table expansion, the optimizer generates a plan that uses indexes on the read-mostly portion of a partitioned table, but not on the active portion of the table.">Table Expansion</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL94931"></a><div class="props_rev_3"><a id="GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" name="GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06"></a><h3 id="TGSQL-GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" class="sect3"><span class="enumeration_section">5.11 </span>Join Factorization
               </h3>
               <div>
                  <p>In the cost-based transformation known as <strong class="term">join factorization</strong>, the optimizer can factorize common computations from branches of a <code class="codeph">UNION ALL</code> query.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-41FA8384-23FF-4683-B1FC-61853209565C">Purpose of Join Factorization</a><br><code class="codeph">UNION ALL</code> queries are common in database applications, especially in data integration applications. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD">How Join Factorization Works</a><br>Join factorization can factorize multiple tables and from more than two <code class="codeph">UNION ALL</code> branches. 
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D">Factorization and Join Orders: Scenario</a><br>Join factorization can create more possibilities for join orders
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225">Factorization of Outer Joins: Scenario</a><br>The database supports join factorization of outer joins, antijoins, and semijoins, but only for the right tables in such joins. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="This chapter describes the most important optimizer techniques for transforming queries.">Query Transformations</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94932"></a><div class="props_rev_3"><a id="GUID-41FA8384-23FF-4683-B1FC-61853209565C" name="GUID-41FA8384-23FF-4683-B1FC-61853209565C"></a><h4 id="TGSQL-GUID-41FA8384-23FF-4683-B1FC-61853209565C" class="sect4"><span class="enumeration_section">5.11.1 </span>Purpose of Join Factorization
                  </h4>
                  <div>
                     <p><code class="codeph">UNION ALL</code> queries are common in database applications, especially in data integration applications. 
                     </p>
                     <p>Often, branches in a <code class="codeph">UNION ALL</code> query refer to the same base tables. Without join factorization, the optimizer evaluates each branch of a <code class="codeph">UNION ALL</code> query independently, which leads to repetitive processing, including data access and joins. Join factorization transformation can share common computations across the <code class="codeph">UNION ALL</code> branches. Avoiding an extra scan of a large base table can lead to a huge performance improvement.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="In the cost-based transformation known as join factorization, the optimizer can factorize common computations from branches of a UNION ALL query.">Join Factorization</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94934"></a><a id="TGSQL94935"></a><a id="TGSQL94933"></a><div class="props_rev_3"><a id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD" name="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD"></a><h4 id="TGSQL-GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD" class="sect4"><span class="enumeration_section">5.11.2 </span>How Join Factorization Works
                  </h4>
                  <div>
                     <p>Join factorization can factorize multiple tables and from more than two <code class="codeph">UNION ALL</code> branches. 
                     </p>
                     <p>Join factorization is best explained through examples. </p>
                     <div class="example" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">
                        <p class="titleinexample">Example 5-11 UNION ALL Query</p>
                        <p>The following query shows a query of four tables (<code class="codeph">t1</code>, <code class="codeph">t2</code>, <code class="codeph">t3</code>, and <code class="codeph">t4</code>) and two <code class="codeph">UNION ALL</code> branches:
                        </p><pre class="pre codeblock"><code>SELECT t1.c1, t2.c2
FROM   <span class="bold">t1</span>, t2, t3
WHERE  <span class="bold">t1.c1 = t2.c1</span> 
AND    <span class="bold">t1.c1 &gt; 1</span>
AND    t2.c2 = 2
AND    t2.c2 = t3.c2 
UNION ALL
SELECT t1.c1, t2.c2
FROM   <span class="bold">t1</span>, t2, t4
WHERE  <span class="bold">t1.c1 = t2.c1</span> 
AND    <span class="bold">t1.c1 &gt; 1</span>
AND    t2.c3 = t4.c3
</code></pre><p>In the preceding query, table <code class="codeph">t1</code> appears in both <code class="codeph">UNION ALL</code> branches, as does the filter predicate <code class="codeph">t1.c1 &gt; 1</code> and the join predicate <code class="codeph">t1.c1 = t2.c1</code>. Without any transformation, the database must perform the scan and the filtering on table <code class="codeph">t1</code> twice, one time for each branch.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABFAEBB">
                        <p class="titleinexample">Example 5-12 Factorized Query </p>The following query uses join factorization to transform the query in <a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">Example 5-11</a>.<pre class="pre codeblock"><code>SELECT t1.c1, VW_JF_1.item_2
FROM   <span class="bold">t1</span>, (SELECT t2.c1 item_1, t2.c2 item_2
            FROM   t2, t3
            WHERE  t2.c2 = t3.c2 
            AND    t2.c2 = 2                 
            UNION ALL
            SELECT t2.c1 item_1, t2.c2 item_2
            FROM   t2, t4 
            WHERE  t2.c3 = t4.c3) VW_JF_1
WHERE  <span class="bold">t1.c1 = VW_JF_1.item_1</span> 
AND    <span class="bold">t1.c1 &gt; 1</span>
</code></pre><p>In this case, because table <code class="codeph">t1</code> is factorized, the database performs the table scan and the filtering on <code class="codeph">t1</code> only one time. If <code class="codeph">t1</code> is large, then this factorization avoids the huge performance cost of scanning and filtering <code class="codeph">t1</code> twice.
                        </p>
                        <div class="infoboxnote" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__GUID-0A2942E9-58DE-454D-8690-1662E9A9027A">
                           <p class="notep1">Note:</p>
                           <p>If the branches in a <code class="codeph">UNION ALL</code> query have clauses that use the <code class="codeph">DISTINCT</code> function, then join factorization is not valid.
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="In the cost-based transformation known as join factorization, the optimizer can factorize common computations from branches of a UNION ALL query.">Join Factorization</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94937"></a><a id="TGSQL94938"></a><a id="TGSQL94939"></a><a id="TGSQL94936"></a><div class="props_rev_3"><a id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D" name="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D"></a><h4 id="TGSQL-GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D" class="sect4"><span class="enumeration_section">5.11.3 </span>Factorization and Join Orders: Scenario
                  </h4>
                  <div>
                     <p>Join factorization can create more possibilities for join orders</p>
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABFEJHJ">
                        <p class="titleinexample">Example 5-13 Query Involving Five Tables</p>
                        <p>In the following query, view <code class="codeph">V</code> is same as the query as in <a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">Example 5-11</a>:
                        </p><pre class="pre codeblock"><code>SELECT *
FROM   t5, (SELECT t1.c1, t2.c2
            FROM   t1, t2, t3
            WHERE  t1.c1 = t2.c1 
            AND    t1.c1 &gt; 1 
            AND    t2.c2 = 2 
            AND    t2.c2 = t3.c2 
            UNION ALL
            SELECT t1.c1, t2.c2
            FROM   t1, t2, t4
            WHERE  t1.c1 = t2.c1 
            AND    t1.c1 &gt; 1 
            AND    t2.c3 = t4.c3) V
WHERE  t5.c1 = V.c1</code></pre>Before join factorization, the database must join <code class="codeph">t1</code>, <code class="codeph">t2</code>, and <code class="codeph">t3</code> before joining them with <code class="codeph">t5</code>. 
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABIGECD">
                        <p class="titleinexample">Example 5-14 Factorization of t1 from View V</p>
                        <p>If join factorization factorizes <code class="codeph">t1</code> from view <code class="codeph">V</code>, as shown in the following query, then the database can join <code class="codeph">t1</code> with <code class="codeph">t5</code>.:
                        </p><pre class="pre codeblock"><code>SELECT *
FROM   <span class="bold">t5</span>, ( SELECT t1.c1, VW_JF_1.item_2
             FROM   <span class="bold">t1</span>, (SELECT t2.c1 item_1, t2.c2 item_2
                         FROM   t2, t3
                         WHERE  t2.c2 = t3.c2
                         AND    t2.c2 = 2
                         UNION ALL
                         SELECT t2.c1 item_1, t2.c2 item_2
                         FROM   t2, t4
                         WHERE  t2.c3 = t4.c3) VW_JF_1 
             WHERE  t1.c1 = VW_JF_1.item_1 
             AND    t1.c1 &gt; 1 )
WHERE  t5.c1 = V.c1
</code></pre><p>The preceding query transformation opens up new join orders. However, join factorization imposes specific join orders. For example, in the preceding query, tables <code class="codeph">t2</code> and <code class="codeph">t3</code> appear in the first branch of the <code class="codeph">UNION ALL</code> query in view <code class="codeph">VW_JF_1</code>. The database must join <code class="codeph">t2</code> with <code class="codeph">t3</code> before it can join with <code class="codeph">t1</code>, which is not defined within the <code class="codeph">VW_JF_1</code> view. The imposed join order may not necessarily be the best join order. For this reason, the optimizer performs join factorization using the cost-based transformation framework. The optimizer calculates the cost of the plans with and without join factorization, and then chooses the cheapest plan.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABFAEGB">
                        <p class="titleinexample">Example 5-15 Factorization of t1 from View V with View Definition Removed</p>
                        <p>The following query is the same query in <a href="query-transformations.html#GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABIGECD">Example 5-14</a>, but with the view definition removed so that the factorization is easier to see:
                        </p><pre class="pre codeblock"><code>SELECT *
FROM   <span class="bold">t5</span>, (SELECT t1.c1, VW_JF_1.item_2
            FROM   <span class="bold">t1</span>, VW_JF_1
            WHERE  t1.c1 = VW_JF_1.item_1
            AND    t1.c1 &gt; 1)
WHERE  t5.c1 = V.c1
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="In the cost-based transformation known as join factorization, the optimizer can factorize common computations from branches of a UNION ALL query.">Join Factorization</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94941"></a><a id="TGSQL94942"></a><a id="TGSQL94940"></a><div class="props_rev_3"><a id="GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225" name="GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225"></a><h4 id="TGSQL-GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225" class="sect4"><span class="enumeration_section">5.11.4 </span>Factorization of Outer Joins: Scenario
                  </h4>
                  <div>
                     <p>The database supports join factorization of outer joins, antijoins, and semijoins, but only for the right tables in such joins. </p>
                     <p>For example, join factorization can transform the following <code class="codeph">UNION ALL</code> query by factorizing <code class="codeph">t2</code>:
                     </p><pre class="pre codeblock"><code>SELECT t1.c2, t2.c2
FROM   t1, t2
WHERE  t1.c1 = t2.c1(+) 
AND    t1.c1 = 1
UNION ALL
SELECT t1.c2, t2.c2
FROM   t1, t2
WHERE  t1.c1 = t2.c1(+) 
AND    t1.c1 = 2
</code></pre><p>The following example shows the transformation. Table <code class="codeph">t2</code> now no longer appears in the <code class="codeph">UNION ALL</code> branches of the subquery.
                     </p><pre class="pre codeblock"><code>SELECT VW_JF_1.item_2, t2.c2
FROM   t2, (SELECT t1.c1 item_1, t1.c2 item_2
            FROM   t1
            WHERE  t1.c1 = 1
            UNION ALL
            SELECT t1.c1 item_1, t1.c2 item_2
            FROM   t1
            WHERE  t1.c1 = 2) VW_JF_1
WHERE  VW_JF_1.item_1 = t2.c1(+)</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="In the cost-based transformation known as join factorization, the optimizer can factorize common computations from branches of a UNION ALL query.">Join Factorization</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>