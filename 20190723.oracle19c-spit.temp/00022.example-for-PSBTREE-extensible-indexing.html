<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>PSBTREE: Extensible Indexing Example</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Cartridge Developer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Cartridge Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00">
      <meta name="dcterms.title" content="Data Cartridge Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96431-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="example-for-power-demand-cartridge.html" title="Previous" type="text/html">
      <link rel="next" href="example-for-pipelined-table-functions-interface-approach.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="example-for-power-demand-cartridge.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="example-for-pipelined-table-functions-interface-approach.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Cartridge Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="scenarios-and-examples.html" property="item" typeof="WebPage"><span property="name">Scenarios and Examples</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PSBTREE: Extensible Indexing Example</li>
            </ol>
            <a id="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" name="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF"></a><a id="ADDCI3160"></a>
            
            <h2 id="ADDCI-GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" class="sect2"><span class="enumeration_chapter">16 </span>PSBTREE: Extensible Indexing Example
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This an example of extensible indexing, with C-language implementation of <code class="codeph">ODCIIndex</code> interface routines.
               </p>
            </div><a id="ADDCI4877"></a><div class="props_rev_3"><a id="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" name="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D"></a><h3 id="ADDCI-GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" class="sect3"><span class="enumeration_section">16.1 </span>About the PSBTREE Example
               </h3>
               <div>
                  <div class="section">
                     <p>Consider how to implement the extensible indexing interface routines in C. The example's focus is on topics that are common to all implementations; it does not expose domain-specific details. </p>
                     <p>The code for the example is in the demo directory, in the file <code class="codeph">extdemo6.sql</code>. It extends an earlier example (<code class="codeph">extdemo2.sql</code>, also in demo directory) by adding to the indextype support for <a id="d56830e120" class="indexterm-anchor"></a>local domain indexes on range partitioned tables.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADDCI4878"></a><div class="props_rev_3"><a id="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" name="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE"></a><h3 id="ADDCI-GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" class="sect3"><span class="enumeration_section">16.2 </span>Design of the Indextype
               </h3>
               <div>
                  <p>The <a id="d56830e178" class="indexterm-anchor"></a>indextype implemented here, called <code class="codeph">PSBtree,</code> operates like a b-tree index. It supports three user-defined operators: <code class="codeph">eq</code> (equals), <code class="codeph">lt</code> (less than), and <code class="codeph">gt</code> (greater than). These operators operate on operands of <code class="codeph">VARCHAR2</code> data type. 
                  </p>
                  <p>The index data consists of records of the form <code class="codeph">&lt;key, rid&gt;</code> where <code class="codeph">key</code> is the value of the indexed column and <code class="codeph">rid</code> is the row identifier of the corresponding row. To simplify the implementation of the indextype, the index data is stored in an system-partitioned table. 
                  </p>
                  <p>When an index is a system-managed local domain index, one partition in a system-partitioned table is created for each partition to store the index data for that partition. Thus, the index manipulation routines merely translate operations on the <code class="codeph">PSBtree</code> into operations on the table partition that stores the index data. 
                  </p>
                  <p>When a user creates a <code class="codeph">PSBtree</code> index (a local index), <code class="codeph">n</code> table partitions are created consisting of the indexed column and a <code class="codeph">rowid</code> column, where <code class="codeph">n</code> is the number of partitions in the base table. Inserts into the base table cause appropriate insertions into the affected index table partition. Deletes and updates are handled similarly. When the <code class="codeph">PSBtree</code> is queried based on a user-defined operator (one of <code class="codeph">gt</code>, <code class="codeph">lt</code> and <code class="codeph">eq</code>), an appropriate query is issued against the index table partitions to retrieve all the satisfying rows. Appropriate partition pruning occurs, and only the index table partitions that correspond to the relevant, or "interesting", partitions are accessed. 
                  </p>
               </div>
            </div><a id="ADDCI4879"></a><div class="props_rev_3"><a id="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" name="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F"></a><h3 id="ADDCI-GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" class="sect3"><span class="enumeration_section">16.3 </span>Implementing Operators
               </h3>
               <div>
                  <p>The <code class="codeph">PSBtree</code> indextype supports three operators: <code class="codeph">eq</code>, <code class="codeph">gt</code> and <code class="codeph">lt</code>. Each operator has a corresponding functional implementation.
                  </p>
               </div><a id="ADDCI4880"></a><div class="props_rev_3"><a id="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" name="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155"></a><h4 id="ADDCI-GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" class="sect4"><span class="enumeration_section">16.3.1 </span>Functional Implementations
                  </h4>
                  <div>
                     <p>Consider the functional implementation of comparison operators. The <a href="example-for-PSBTREE-extensible-indexing.html#GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B">Implementing the EQUALS Operator</a> section explains how to implement <code class="codeph">eq</code> (equals), the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">Implementing the LESS THAN Operator</a> section explains how to implement <code class="codeph">lt</code> (less than), and the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242">Implementing the GREATER THAN Operator</a> section explains how to implement <code class="codeph">gt</code> (greater than) operators.
                     </p>
                  </div><a id="CACFGDEF"></a><div class="props_rev_3"><a id="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" name="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B"></a><h5 id="ADDCI-GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" class="sect5"><span class="enumeration_section">16.3.1.1 </span>Implementing the EQUALS Operator
                     </h5>
                     <div>
                        <div class="section">
                           <p>The functional implementation for <code class="codeph">eq</code> is provided by a function (<code class="codeph">bt_eq</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if they are equal and <code class="codeph">0</code> otherwise. 
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_eq(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a = b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBEEIH"></a><div class="props_rev_3"><a id="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" name="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF"></a><h5 id="ADDCI-GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" class="sect5"><span class="enumeration_section">16.3.1.2 </span>Implementing the LESS THAN Operator
                     </h5>
                     <div>
                        <div class="section">
                           <p>The functional implementation for <code class="codeph">lt</code> is provided by a function (<code class="codeph">bt_lt</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if the first parameter is less than the second, <code class="codeph">0</code> otherwise. 
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_lt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a &lt; b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDGGHF"></a><div class="props_rev_3"><a id="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" name="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242"></a><h5 id="ADDCI-GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" class="sect5"><span class="enumeration_section">16.3.1.3 </span>Implementing the GREATER THAN Operator
                     </h5>
                     <div>
                        <div class="section">
                           <p>The functional implementation for <code class="codeph">gt</code> is provided by a function (<code class="codeph">bt_gt</code>) that takes in two <code class="codeph">VARCHAR2</code> parameters and returns <code class="codeph">1</code> if the first parameter is greater than the second, <code class="codeph">0</code> otherwise. 
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_gt(a VARCHAR2, b VARCHAR2) RETURN NUMBER AS
BEGIN 
&nbsp;&nbsp;IF a &gt; b then
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 1;
&nbsp;&nbsp;ELSE
&nbsp;&nbsp;&nbsp;&nbsp;RETURN 0;
&nbsp;&nbsp;END IF;
END;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4885"></a><a id="ADDCI4886"></a><a id="ADDCI4887"></a><a id="ADDCI4884"></a><div class="props_rev_3"><a id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" name="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B"></a><h4 id="ADDCI-GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" class="sect4"><span class="enumeration_section">16.3.2 </span>Operators
                  </h4>
                  <div>
                     <p>To create the operator, you must specify the signature of the operator along with its return type and its functional implementation. <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">Example 16-1</a> shows how to create <code class="codeph">eq</code> (equals), <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">Example 16-2</a> shows how to create <code class="codeph">lt</code> (less than), and <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">Example 16-3</a> shows how to create <code class="codeph">gt</code> (greater than) operators.
                     </p>
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">
                        <p class="titleinexample">Example 16-1 Creating the EQUALS Operator</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR eq 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_eq;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">
                        <p class="titleinexample">Example 16-2 Creating the LESS THAN Operator</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR lt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_lt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">
                        <p class="titleinexample">Example 16-3 Creating the GREATER THAN Operator</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR gt 
BINDING (VARCHAR2, VARCHAR2) RETURN NUMBER 
USING bt_gt;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4888"></a><div class="props_rev_3"><a id="GUID-F76F035E-4432-4555-9039-2E66E064D67E" name="GUID-F76F035E-4432-4555-9039-2E66E064D67E"></a><h3 id="ADDCI-GUID-F76F035E-4432-4555-9039-2E66E064D67E" class="sect3"><span class="enumeration_section">16.4 </span>Implementing the ODCIIndex Interfaces
               </h3>
               <div>
                  <p>To implement the <code class="codeph">PSBTREE</code>, you must implement the <code class="codeph">ODCIIndex</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">()</code> routines. You can implement the index routines in any language supported by Oracle. This discussion implements the <a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces()</a> routine in the C programming language. Note that these require advance setup, such as creating a library object, <code class="codeph">extdemo6l</code>, for your compiled C code.
                  </p>
               </div><a id="ADDCI4890"></a><a id="ADDCI4889"></a><div class="props_rev_3"><a id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" name="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1"></a><h4 id="ADDCI-GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" class="sect4"><span class="enumeration_section">16.4.1 </span>Defining an Implementation Type for PSBTREE
                  </h4>
                  <div>
                     <div class="section">
                        <p>Define an implementation type that implements the <code class="codeph">ODCIIndex</code> interface routines, as demonstrated in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">Example 16-4</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">
                        <p class="titleinexample">Example 16-4 Creating a PSBTREE Index Type</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE psbtree_im AUTHID CURRENT_USER AS OBJECT
(
&nbsp;&nbsp;scanctx RAW(4),
&nbsp;&nbsp;STATIC FUNCTION ODCIGetInterfaces(ifclist OUT SYS.ODCIObjectList)
&nbsp;&nbsp;&nbsp;&nbsp;RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexCreate (ia SYS.ODCIIndexInfo, parms VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexAlter (ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;&nbsp;&nbsp;parms IN OUT VARCHAR2, altopt number, env sys.ODCIEnv) RETURN NUMBER, 
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexDrop(ia SYS.ODCIIndexInfo, env SYS.ODCIEnv) 
&nbsp;&nbsp;&nbsp;&nbsp;RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexExchangePartition(ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;&nbsp;&nbsp;ia1 SYS.ODCIIndexInfo, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexUpdPartMetadata(ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;&nbsp;&nbsp;palist sys.ODCIPartInfoList, env sys.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexInsert(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexDelete(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;oldval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexUpdate(ia SYS.ODCIIndexInfo, rid VARCHAR2,
&nbsp;&nbsp;&nbsp;&nbsp;oldval VARCHAR2, newval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;STATIC FUNCTION ODCIIndexStart(sctx IN OUT psbtree_im, ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;&nbsp;&nbsp;op SYS.ODCIPredInfo, qi sys.ODCIQueryInfo, strt number, stop number,
&nbsp;&nbsp;&nbsp;&nbsp;cmpval VARCHAR2, env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;MEMBER FUNCTION ODCIIndexFetch(nrows NUMBER, rids OUT SYS.ODCIridlist,
&nbsp;&nbsp;&nbsp;&nbsp;env SYS.ODCIEnv) RETURN NUMBER,
&nbsp;&nbsp;MEMBER FUNCTION ODCIIndexClose(env SYS.ODCIEnv) RETURN NUMBER
);
/
SHOW ERRORS</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4892"></a><a id="ADDCI4891"></a><div class="props_rev_3"><a id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" name="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8"></a><h4 id="ADDCI-GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" class="sect4"><span class="enumeration_section">16.4.2 </span>Creating the Implementation Type Body
                  </h4>
                  <div>
                     <div class="section">
                        <p>Define the implementation type body, as demonstrated in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">Example 16-5</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">
                        <p class="titleinexample">Example 16-5 Creating the Implementation Body for PBSTREE</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE BODY psbtree_im IS </pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4893"></a><div class="props_rev_3"><a id="GUID-385BF144-F676-468E-A9A6-7633E0939A1A" name="GUID-385BF144-F676-468E-A9A6-7633E0939A1A"></a><h4 id="ADDCI-GUID-385BF144-F676-468E-A9A6-7633E0939A1A" class="sect4"><span class="enumeration_section">16.4.3 </span>Defining PL/SQL Routines in the Implementation Body
                  </h4>
                  <div>
                     <div class="section">
                        <p>Consider how to implement the index definition routines in PL/SQL.</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADDCI4894"></a><div class="props_rev_3"><a id="GUID-CD482284-5973-4954-9086-DAFD9E872FE7" name="GUID-CD482284-5973-4954-9086-DAFD9E872FE7"></a><h5 id="ADDCI-GUID-CD482284-5973-4954-9086-DAFD9E872FE7" class="sect5"><span class="enumeration_section">16.4.3.1 </span>Implementing ODCIGetInterfaces() for PBSTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces()</a> routine returns the expected interface name through its <code class="codeph">OUT</code> parameter.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIGetInterfaces(
&nbsp;&nbsp;ifclist OUT sys.ODCIObjectList) 
RETURN NUMBER IS
BEGIN
&nbsp;&nbsp;ifclist := sys.ODCIObjectList(sys.ODCIObject('SYS','ODCIINDEX2'));
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIGetInterfaces;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGFBIH"></a><div class="props_rev_3"><a id="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" name="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83"></a><h5 id="ADDCI-GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" class="sect5"><span class="enumeration_section">16.4.3.2 </span>Implementing ODCIIndexCreate() for PBSTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <a href="extensible-indexing-interface.html#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate()</a> routine creates a system-partitioned index storage table with two columns. The first column stores the <code class="codeph">VARCHAR2</code> indexed column value. The routine makes use of the information passed in to determine the context in which it is invoked. Dynamic SQL is used to execute the dynamically constructed SQL statement. 
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexCreate (
  ias sys.ODCIIndexInfo,
  parms VARCHAR2,
  env sys.ODCIEnv)
RETURN NUMBER IS
  i INTEGER;
  stmt VARCHAR2(2000);
  cursor cur1(ianame VARCHAR2) IS
    SELECT partition_name, parameters
    FROM user_ind_partitions
    WHERE index_name = ianame
    ORDER BY partition_position;
  cursor cur2(ianame VARCHAR2) IS
    SELECT subpartition_name, parameters
    FROM user_ind_subpartitions
    WHERE index_name = ianame
    ORDER BY partition_position, subpartition_position;
BEGIN
  stmt := '';
  
  IF (env.CallProperty is null) THEN
    stmt := 'create table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree(f1 VARCHAR2(1000), f2 rowid)';
  
  ELSIF (env.CallProperty = sys.ODCIConst.FirstCall) THEN
    stmt := '';
    i := 1;
    
    IF (bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0) THEN
      FOR c1 in cur1(ia.IndexName) LOOP
        IF (i &gt; 1) THEN
          stmt := stmt || ',';
        END IF;
        stmt := stmt || 'partition ' || c2.partition_name;
        i := i + 1;
      END LOOP;
    ELSE
      FOR c1 in cur1(ia.IndexName) LOOP
        IF (i &gt; 1) THEN
          stmt := stmt || ',';
        END IF;
        stmt := stmt || 'partition ' || c2.subpartition_name;
        i := i + 1;
      END LOOP;
    END IF;
    stmt := 'create table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree (f1 VARCHAR2(1000), f2 rowid) partition by system ' ||
      '(' || stmt || ')';
  
  ELSIF (env.CallProperty = sys.ODCIConst.FinalCall) THEN
    stmt := 'create index ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbti on ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree (f1) local';
  END IF;
  
  dbms_output.put_line('Create');
  dbms_output.put_line(stmt);
  
  -- execute the statement
  IF ((env.CallProperty is null) OR
      (env.CallProperty = sys.ODCIConst.FirstCall) OR
      (env.CallProperty = sys.ODCIConst.FinalCall) ) THEN
    execute immediate stmt;
  
    IF (env.CallProperty is null) THEN
      execute immediate 'insert into ' || ia.IndexSchema || '.' || ia.IndexName
        || '_sbtree select ' || ia.IndexCols(1).ColName || ', ROWID from ' ||
        ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName;
      execute immediate 'create index ' || ia.IndexSchema || '.' ||
        ia.IndexName || '_sbti on ' || ia.IndexSchema || '.' ||
        ia.IndexName || '_sbtree (f1)';
    END IF;
  END IF;
  
  RETURN ODCIConst.Success;
END ODCIIndexCreate;
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDJCFF"></a><div class="props_rev_3"><a id="GUID-43232667-0102-4BCD-9C00-D106F8D049D2" name="GUID-43232667-0102-4BCD-9C00-D106F8D049D2"></a><h5 id="ADDCI-GUID-43232667-0102-4BCD-9C00-D106F8D049D2" class="sect5"><span class="enumeration_section">16.4.3.3 </span>Implementing ODCIIndexDrop() for PBSTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p> The <a href="extensible-indexing-interface.html#GUID-F128CB3B-6B3E-41C3-A623-67BCB5BC9292">ODCIIndexDrop()</a> routine drops the index storage tables.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexDrop(
&nbsp;&nbsp;ia sys.ODCIIndexInfo,
&nbsp;&nbsp;env sys.ODCIEnv) 
RETURN NUMBER IS
&nbsp;&nbsp;stmt VARCHAR2(1000);
&nbsp;&nbsp;cnum INTEGER;
&nbsp;&nbsp;junk INTEGER;
BEGIN
&nbsp;&nbsp;-- construct the sql statement
&nbsp;&nbsp;stmt := '';

&nbsp;&nbsp;IF (env.CallProperty is null) THEN
&nbsp;&nbsp;&nbsp;&nbsp;stmt := 'drop table ' || ia.IndexSchema || '.' || ia.IndexName || '_sbtree';
&nbsp;&nbsp;&nbsp;&nbsp;dbms_output.put_line('Drop');
&nbsp;&nbsp;&nbsp;&nbsp;dbms_output.put_line(stmt);
&nbsp;&nbsp;&nbsp;&nbsp;execute immediate stmt;
&nbsp;&nbsp;END IF;
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIIndexDrop;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACCCEAE"></a><div class="props_rev_3"><a id="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" name="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878"></a><h5 id="ADDCI-GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" class="sect5"><span class="enumeration_section">16.4.3.4 </span>Implementing ODCIIndexAlter() for PSBTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <a href="extensible-indexing-interface.html#GUID-9DB1D609-69C3-483B-AA77-087AD51A3A55">ODCIIndexAlter()</a> routine can perform many index alteration tasks, such as rebuilding and renaming an index.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexAlter (
  ia sys.ODCIIndexInfo,
  parms IN OUT VARCHAR2,
  altopt NUMBER,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(2000);
BEGIN
  stmt := '';
  IF (altopt = ODCIConst.AlterIndexRebuild) THEN
    IF (ia.IndexPartition is null) THEN
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select ' || ia.IndexCols(1).ColName || ', ROWID from ' ||
				ia.IndexCols(1).ColName || ', ROWID from ' ||
				ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName;
    ELSIF (bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0) THEN
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select partition (' || ia.IndexPartition || ')' ||
				ia.IndexCols(1).ColName || ', ROWID from ' ||     
        ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName ||
        ' partition (' || ia.IndexCols(1).TablePartition || ')';
    ELSE
      stmt := 'insert into ' || ia.IndexSchema || '.' || ia.IndexName ||
				'_sbtree select partition (' || ia.IndexPartition || ')' || 
				ia.IndexCols(1).ColName || ', ROWID from ' ||
        ia.IndexCols(1).TableSChema || '.' || ia.IndexCols(1).TableName ||
        ' subpartition (' || ia.IndexCols(1).TablePartition || ')';
    END IF;
    
  ELSIF (altopt = ODCIConst.AlterIndexRename) THEN
    IF (ia.IndexPartition is not null) THEN
      stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
        '_sbtree rename partition ' || ia.IndexPartition || ' to ' || parms;
    ELSE
      stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
        '_sbtree rename to ' || parms || '_sbtree';
    END IF;
  END IF;
  
  dbms_output.put_line('Alter');
  IF ((altopt = ODCIConst.AlterIndexRebuild) OR (altopt = ODCIConst.AlterIndexRename))
  THEN
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
  RETURN ODCIConst.Success;
END ODCIIndexAlter;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFDJC"></a><div class="props_rev_3"><a id="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" name="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA"></a><h5 id="ADDCI-GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" class="sect5"><span class="enumeration_section">16.4.3.5 </span>Implementing ODCIIndexUpdPartMetadata() for PSBTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>To handle partition maintenance operations, the kernel performs the maintenance tasks on behalf of the user. The indextype, to maintain its metadata, should have the <a href="extensible-indexing-interface.html#GUID-C2C4DB40-106A-491C-B241-985B69DC2FE1">ODCIIndexUpdPartMetadata()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexUpdPartMetadata(
&nbsp;&nbsp;ia sys.ODCIIndexInfo, 
&nbsp;&nbsp;palist sys.ODCIPartInfoList, 
&nbsp;&nbsp;env sys.ODCIEnv) 
RETURN NUMBER IS
&nbsp;&nbsp;col  number;
BEGIN
&nbsp;&nbsp;dbms_output.put_line('ODCIUpdPartMetadata');
&nbsp;&nbsp;sys.ODCIIndexInfoDump(ia);
&nbsp;&nbsp;sys.ODCIPartInfoListDump(palist);
&nbsp;&nbsp;sys.ODCIEnvDump(env);
&nbsp;&nbsp;RETURN ODCIConst.Success;
END ODCIIndexUpdPartMetadata;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJCGBH"></a><div class="props_rev_3"><a id="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" name="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF"></a><h5 id="ADDCI-GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" class="sect5"><span class="enumeration_section">16.4.3.6 </span>Implementing ODCIIndexExchangePartition() for PSBTREE in PL/SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>The <a href="extensible-indexing-interface.html#GUID-7914F874-620F-48F1-ADDC-040CC82D46ED">ODCIIndexExchangePartition()</a> exchanges the index storage tables for the index partition being exchanged, with the index storage table for the global domain index.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexExchangePartition(
  ia sys.ODCIIndexInfo,
  ia1 sys.ODCIIndexInfo,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(2000);
  cnum INTEGER;
  junk INTEGER;
BEGIN
  stmt := '';
  dbms_output.put_line('Exchange Partition');
 
  -- construct the sql statements
  IF bitand(ia.IndexInfoFlags, ODCIConst.CompPartn) = 0 OR
     bitand(ia.IndexInfoFlags, ODCIConst.SubPartn) = ODCIConst.SubPartn THEN
    -- non-composite partitioned or exchanging subpartition
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      ia1.IndexSchema || '.' || ia1.IndexName || '_sbtree';
     
    dbms_output.put_line(stmt);
    execute immediate stmt;
  ELSE
    -- composite partition exchange
    stmt := 'create table temp_exch (f1 VARCHAR2(1000), f2 rowid)';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia1.IndexSchema || '.' || ia1.IndexName ||
      '_sbtree exchange partition ' || ia1.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    stmt := 'alter table ' || ia.IndexSchema || '.' || ia.IndexName ||
      '_sbtree exchange partition ' || ia.IndexPartition || ' with table ' ||
      'temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
   
    -- exchange done, drop temporal table
    stmt := 'drop table temp_exch';
    dbms_output.put_line(stmt);
    execute immediate stmt;
  END IF;
 
  RETURN ODCIConst.Success;
END ODCIIndexExchangePartition;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4900"></a><div class="props_rev_3"><a id="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" name="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0"></a><h4 id="ADDCI-GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" class="sect4"><span class="enumeration_section">16.4.4 </span>Registering the C Implementation of the ODCIIndex<span class="italic">XXX</span>() Methods
                  </h4>
                  <div>
                     <div class="section">
                        <p>After creating the <code class="codeph">extdemo6l</code> library object for the compiled C methods, you must register the implementations of each of the routines. The <a href="example-for-PSBTREE-extensible-indexing.html#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">Registering the Implementation of ODCIIndexInsert()</a> section demonstrates how to register the ODCIIndexInsert() implementation, the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3">Registering the Implementation of ODCIIndexDelete()</a> section registers the ODCIIndexDelete() implementation, the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-20EAB399-76F5-4C79-AE81-63B8956504F7">Registering the Implementation of ODCIIndexUpdate()</a> section registers the ODCIIndexUpdate() implementation, the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">Registering the Implementation of ODCIIndexStart()</a> section registers the ODCIIndexStart() implementation, the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE">Registering the Implementation of ODCIIndexFetch()</a> section registers the ODCIIndexFetch() implementation, and the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32">Registering the Implementation of ODCIIndexClose()</a> section registers the ODCIIndexClose() implementation.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="CACGAHCG"></a><div class="props_rev_3"><a id="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" name="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB"></a><h5 id="ADDCI-GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" class="sect5"><span class="enumeration_section">16.4.4.1 </span>Registering the Implementation of ODCIIndexInsert()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexInsert(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;newval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspi"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;newval,
&nbsp;&nbsp;newval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBHAHC"></a><div class="props_rev_3"><a id="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" name="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3"></a><h5 id="ADDCI-GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" class="sect5"><span class="enumeration_section">16.4.4.2 </span>Registering the Implementation of ODCIIndexDelete()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-4B2E080D-FE8B-4598-9084-56FBE255196B">ODCIIndexDelete()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexDelete(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo, 
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;oldval VARCHAR2, 
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspd"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;oldval,
&nbsp;&nbsp;oldval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBCCEH"></a><div class="props_rev_3"><a id="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" name="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7"></a><h5 id="ADDCI-GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" class="sect5"><span class="enumeration_section">16.4.4.3 </span>Registering the Implementation of ODCIIndexUpdate()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-CB42E738-EFD1-4053-9DDF-BEF455F92815">ODCIIndexUpdate()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexUpdate(
&nbsp;&nbsp;ia SYS.ODCIIndexInfo, 
&nbsp;&nbsp;rid VARCHAR2,
&nbsp;&nbsp;oldval VARCHAR2,
&nbsp;&nbsp;newval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspu"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;rid,
&nbsp;&nbsp;rid indicator,
&nbsp;&nbsp;oldval,
&nbsp;&nbsp;oldval indicator,
&nbsp;&nbsp;newval,
&nbsp;&nbsp;newval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJADGC"></a><div class="props_rev_3"><a id="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" name="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3"></a><h5 id="ADDCI-GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" class="sect5"><span class="enumeration_section">16.4.4.4 </span>Registering the Implementation of ODCIIndexStart()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-53F2321C-B0F8-4783-AC1B-056372A0C073">ODCIIndexStart()</a> routine. 
                           </p><pre class="oac_no_warn" dir="ltr">STATIC FUNCTION ODCIIndexStart(
&nbsp;&nbsp;sctx IN OUT psbtree_im,
&nbsp;&nbsp;ia SYS.ODCIIndexInfo,
&nbsp;&nbsp;op SYS.ODCIPredInfo,
&nbsp;&nbsp;qi SYS.ODCIQueryInfo,
&nbsp;&nbsp;strt NUMBER,
&nbsp;&nbsp;stop NUMBER,
&nbsp;&nbsp;cmpval VARCHAR2,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbsps"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;sctx,
&nbsp;&nbsp;sctx indicator struct,
&nbsp;&nbsp;ia,
&nbsp;&nbsp;ia indicator struct,
&nbsp;&nbsp;op,
&nbsp;&nbsp;op indicator struct,
&nbsp;&nbsp;qi,
&nbsp;&nbsp;qi indicator struct,
&nbsp;&nbsp;strt,
&nbsp;&nbsp;strt indicator,
&nbsp;&nbsp;stop,
&nbsp;&nbsp;stop indicator,
&nbsp;&nbsp;cmpval,
&nbsp;&nbsp;cmpval indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADDCI4905"></a><div class="props_rev_3"><a id="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" name="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE"></a><h5 id="ADDCI-GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" class="sect5"><span class="enumeration_section">16.4.4.5 </span>Registering the Implementation of ODCIIndexFetch()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-BB601420-A858-46E3-A9AC-3433220D4F82">ODCIIndexFetch()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">MEMBER FUNCTION ODCIIndexFetch(
&nbsp;&nbsp;nrows NUMBER,
&nbsp;&nbsp;rids OUT SYS.ODCIRidList,
&nbsp;&nbsp;env SYS.ODCIEnv)
RETURN NUMBER AS EXTERNAL
name "qxiqtbspf"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;self,
&nbsp;&nbsp;self indicator struct,
&nbsp;&nbsp;nrows,
&nbsp;&nbsp;nrows indicator,
&nbsp;&nbsp;rids,
&nbsp;&nbsp;rids indicator,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
 );</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACIDHBA"></a><div class="props_rev_3"><a id="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" name="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32"></a><h5 id="ADDCI-GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" class="sect5"><span class="enumeration_section">16.4.4.6 </span>Registering the Implementation of ODCIIndexClose()
                     </h5>
                     <div>
                        <div class="section">
                           <p>Register the implementation of the <a href="extensible-indexing-interface.html#GUID-2F49CDE4-C064-4644-948C-BBF014FDD8C8">ODCIIndexClose()</a> routine.
                           </p><pre class="oac_no_warn" dir="ltr">MEMBER FUNCTION ODCIIndexClose (
&nbsp;&nbsp;env SYS.ODCIEnv) 
RETURN NUMBER AS EXTERNAL
name "qxiqtbspc"
library extdemo6l
with context
parameters (
&nbsp;&nbsp;context,
&nbsp;&nbsp;self,
&nbsp;&nbsp;self indicator struct,
&nbsp;&nbsp;env,
&nbsp;&nbsp;env indicator struct,
&nbsp;&nbsp;return OCINumber
);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4908"></a><a id="ADDCI4909"></a><a id="ADDCI4907"></a><div class="props_rev_3"><a id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" name="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE"></a><h4 id="ADDCI-GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" class="sect4"><span class="enumeration_section">16.4.5 </span>Defining Additional Structures in C Implementation
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">stuct</code> <code class="codeph">qxiqtim</code>, <code class="codeph">struct qciqtin</code>, and <code class="codeph">struct</code> <code class="codeph">qxiqtcx</code> are used for mapping the object type and its <code class="codeph">null</code> value (demonstrated in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 16-6</a>), and for keeping state during fetching calls (demonstrated in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 16-7</a>). These structures are used by the methods described in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">Defining C Methods in the Implementation Body</a>.
                        </p>
                        <p>The C <code class="codeph">struct</code>s for mapping the ODCI types are defined in the file <code class="codeph">odci.h</code>. For example, the C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo</code> is the mapping for the corresponding ODCI object type. The C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo_ind</code> is the mapping for the <code class="codeph">null</code> object.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">
                        <p class="titleinexample">Example 16-6 Defining Mappings for the Object Type and Its Null Value</p>
                        <p>We have defined a C <code class="codeph">struct</code>, <code class="codeph">qxiqtim</code>, as a mapping for the object type. There is an additional C <code class="codeph">struct</code>, <code class="codeph">qxiqtin</code>, for the corresponding <code class="codeph">null</code> object. The C <code class="codeph">struct</code>s for the object type and its <code class="codeph">null</code> object can be generated from the Object Type Translator (OTT).
                        </p><pre class="oac_no_warn" dir="ltr">/* The index implementation type is an object type with a single RAW attribute
 * used to store the context key value. 
 * C mapping of the implementation type : */

struct qxiqtim{
&nbsp;&nbsp;OCIRaw *sctx_qxiqtim;
}; 
typedef struct qxiqtim qxiqtim;

struct qxiqtin{
  short atomic_qxiqtin;
  short scind_qxiqtin;
}; 
typedef struct qxiqtin qxiqtin;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">
                        <p class="titleinexample">Example 16-7 Keeping the Scan State During Fetching Calls</p>
                        <p>There are a set of OCI handles that must be cached away and retrieved during fetch calls. A C <code class="codeph">struct</code>, <code class="codeph">qxiqtcx</code>, is defined to hold all the necessary scan state. This structure is allocated out of <code class="codeph">OCI_DURATION_STATEMENT</code> memory to ensure that it persists till the end of <code class="codeph">fetch</code>. After populating the structure with the required info, a pointer to the structure is saved in OCI context. The context is identified by a 4-byte key that is generated by calling an OCI routine. The 4-byte key is stashed away in the scan context - <code class="codeph">exiting</code>. This object is returned back to the Oracle server and is passed in as a parameter to the next fetch call. 
                        </p><pre class="oac_no_warn" dir="ltr">/* The index scan context - should be stored in "statement" duration memory
 * and used by start, fetch and close routines.
 */
struct qxiqtcx
{
&nbsp;&nbsp;OCIStmt *stmthp;
&nbsp;&nbsp;OCIDefine *defnp;
&nbsp;&nbsp;OCIBind *bndp;
&nbsp;&nbsp;char ridp[19];
}; 
typedef struct qxiqtcx qxiqtcx;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4910"></a><div class="props_rev_3"><a id="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" name="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4"></a><h4 id="ADDCI-GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" class="sect4"><span class="enumeration_section">16.4.6 </span>Defining C Methods in the Implementation Body
                  </h4>
                  <div>
                     <p>Consider how to implemented PSBEETree methods in the C language.</p>
                  </div><a id="CACJIECE"></a><div class="props_rev_3"><a id="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" name="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C"></a><h5 id="ADDCI-GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" class="sect5"><span class="enumeration_section">16.4.6.1 </span>Implementing a Common Error Processing Routine in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>This function is used to check and process the return code from all <code class="codeph">OCI</code> routines. It checks the status code and raises an exception in case of errors.
                           </p><pre class="oac_no_warn" dir="ltr">static int qxiqtce(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;OCIError *errhp,
&nbsp;&nbsp;sword status)
{
&nbsp;&nbsp;text errbuf[512];
&nbsp;&nbsp;sb4 errcode = 0;
&nbsp;&nbsp;int errnum = 29400;  /* choose some oracle error number */
&nbsp;&nbsp;int rc = 0;

&nbsp;&nbsp;switch (status)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;case OCI_SUCCESS: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case OCI_ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) OCIErrorGet((dvoid *)errhp, (ub4)1, (text *)NULL, &amp;errcode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errbuf, (ub4)sizeof(errbuf), OCI_HTYPE_ERROR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Raise exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) sprintf((char *)errbuf, "Warning - some error\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Raise exception */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIExtProcRaiseExcpWithMsg(ctx, errnum, errbuf, strlen((char *)errbuf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;}
&nbsp;&nbsp;return (rc);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJJDAC"></a><div class="props_rev_3"><a id="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" name="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB"></a><h5 id="ADDCI-GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" class="sect5"><span class="enumeration_section">16.4.6.2 </span>Implementing ODCIIndexInsert() for PSBTREE in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The insert routine, <a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert()</a>, parses and executes a statement that inserts a new row into the index table. The new row consists of the new value of the indexed column and the <code class="codeph">rowid</code> that have been passed in as parameters.
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspi(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *newval,
&nbsp;&nbsp;short             newval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;char insstmt[2000];                       /* sql insert statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  

&nbsp;&nbsp;/* allocate memory for OCINumber first */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct insert Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(insstmt, "INSERT into %s.%s_sbtree values (:newval, :mrid)",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;(void)sprintf(insstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"INSERT into %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUES (:newval, :mrid)",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/***************************************
&nbsp;&nbsp;* Parse and Execute Create Statement   *
&nbsp;&nbsp;****************************************/

&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)insstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(insstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for newval */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":newval",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":newval")-1, (dvoid *)newval, (sb4)(strlen(newval)+1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":mrid",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":mrid")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACFICAJ"></a><div class="props_rev_3"><a id="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" name="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19"></a><h5 id="ADDCI-GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" class="sect5"><span class="enumeration_section">16.4.6.3 </span>Implementing ODCIIndexDelete() for PSBTREE in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The delete routine constructs a SQL statement to delete a row from the index table corresponding to the row being deleted from the base table. The row in the index table is identified by the value of <code class="codeph">rowid</code> that is passed in as a parameter to this routine.
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspd(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *oldval,
&nbsp;&nbsp;short             oldval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */
 
&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;
 
&nbsp;&nbsp;char delstmt[2000];                       /* sql delete statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  
 
&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
 
&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct delete Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ((idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(delstmt, "DELETE FROM %s.%s_sbtree WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, (OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(delstmt, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"DELETE FROM %s.%s_sbtree partition (DATAOBJ_TO_PARTITION(%s, :partiden))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/***************************************
&nbsp;&nbsp;* Parse and Execute delete Statement   *
&nbsp;&nbsp;****************************************/

/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)delstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(delstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":rr")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1, (ub4)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" name="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9"></a><h5 id="ADDCI-GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" class="sect5"><span class="enumeration_section">16.4.6.4 </span>Implementing ODCIIndexUpdate() for PSBTree in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The update routine constructs a SQL statement to update a row in the index table corresponding to the row being updated in the base table. The row in the index table is identified by the value of <code class="codeph">rowid</code> that is passed in as a parameter to this routine. The old column value (<code class="codeph">oldval</code>) is replaced by the new value (<code class="codeph">newval</code>).
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspu(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;char              *rid,
&nbsp;&nbsp;short             rid_ind,
&nbsp;&nbsp;char              *oldval,
&nbsp;&nbsp;short             oldval_ind,
&nbsp;&nbsp;char              *newval,
&nbsp;&nbsp;short             newval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;             /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;       /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;         /* error handle */
&nbsp;&nbsp;OCIStmt *stmthp = (OCIStmt *) 0;          /* statement handle */
&nbsp;&nbsp;OCIBind *bndp = (OCIBind *) 0;            /* bind handle */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;           /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;char updstmt[2000];                       /* sql upate statement */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                    /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                    /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                     /* index info flag  

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/*****************************
&nbsp;&nbsp;* Construct update Statement *
&nbsp;&nbsp;******************************/
&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(updstmt, "UPDATE %s.%s_sbtree SET f1 = :newval WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName));
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(updstmt, "UPDATE %s.%s_sbtree partition 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DATAOBJ_TO_PARTITION(%s, :partiden)) SET f1 = :newval WHERE f2 = :rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName));
&nbsp;&nbsp;}

&nbsp;&nbsp;/****************************************
&nbsp;&nbsp;* Parse and Execute Create Statement   *
&nbsp;&nbsp;****************************************/

&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;stmthp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(stmthp, errhp, (text *)updstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(updstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) == ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;(colinfo-&gt;TablePartitionIden), sizeof(partiden), OCI_NUMBER_UNSIGNED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Set up bind for partiden */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":partiden", sizeof(":partiden")-1, (dvoid *)&amp;partiden,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(partiden)), (ub2)SQLT_INT, (dvoid *)0, (ub2 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* Set up bind for newval */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":newval",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":newval")-1, (dvoid *)newval, (sb4)(strlen(newval)+1), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up bind for rid */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(stmthp, &amp;bndp, errhp, (text *)":rr",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(":rr")-1, (dvoid *)rid, (sb4)(strlen(rid)+1), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Execute statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4)1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free stmt handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)stmthp, (ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" name="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83"></a><h5 id="ADDCI-GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" class="sect5"><span class="enumeration_section">16.4.6.5 </span>Implementing ODCIIndexStart() for PSBTREE in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The start routine performs the setup for an <code class="codeph">psbtree</code> index scan. The query information in terms of the operator predicate, its arguments, and the bounds on return values are passed in as parameters to this function. The scan context that is shared among the index scan routines is an instance of the type <code class="codeph">psbtree_im</code>. 
                           </p>
                           <p>This function sets up a cursor that scans the index table. The scan retrieves the stored rowids for the rows in the index table that satisfy the specified predicate. The predicate for the index table is generated based on the operator predicate information that is passed in as parameters. For example, if the operator predicate is of the form <code class="codeph"> eq(col, 'joe') = 1</code>, then the predicate on the index table is set up to be <code class="codeph"> f1 = 'joe'</code>.
                           </p>
                           <p>This function uses the <code class="codeph">struct</code>s <code class="codeph">qxiqtim</code>, <code class="codeph">qxiqtin</code>, and <code class="codeph">qxiqtcx</code>, which were demonstrated in <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 16-6</a> and <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 16-7</a>.
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbsps(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *sctx,
&nbsp;&nbsp;qxiqtin           *sctx_ind,
&nbsp;&nbsp;ODCIIndexInfo     *ix,
&nbsp;&nbsp;ODCIIndexInfo_ind *ix_ind,
&nbsp;&nbsp;ODCIPredInfo      *pr,
&nbsp;&nbsp;ODCIPredInfo_ind  *pr_ind,
&nbsp;&nbsp;ODCIQueryInfo     *qy,
&nbsp;&nbsp;ODCIQueryInfo_ind *qy_ind,
&nbsp;&nbsp;OCINumber         *strt,
&nbsp;&nbsp;short             strt_ind,
&nbsp;&nbsp;OCINumber         *stop,
&nbsp;&nbsp;short             stop_ind,
&nbsp;&nbsp;char              *cmpval,
&nbsp;&nbsp;short             cmpval_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int strtval;                   /* start bound */
&nbsp;&nbsp;int stopval;                   /* stop bound */

&nbsp;&nbsp;int errnum = 29400;            /* choose some oracle error number */
&nbsp;&nbsp;char errmsg[512];              /* error message buffer */
&nbsp;&nbsp;size_t errmsglen;              /* Length of error message */

&nbsp;&nbsp;char relop[3];                 /* relational operator used in sql stmt */
&nbsp;&nbsp;char selstmt[2000];            /* sql select statement */

&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;       /* return from this function */
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;
&nbsp;&nbsp;ub4 key;                              /* key value set in "sctx" */

&nbsp;&nbsp;ub1 *rkey;                            /* key to retrieve context */
&nbsp;&nbsp;ub4 rkeylen;                          /* length of key */
&nbsp;&nbsp;ODCIColInfo  *colinfo;                /* column info */
&nbsp;&nbsp;ODCIColInfo_ind  *colinfo_ind;
&nbsp;&nbsp;boolean exists = TRUE;
&nbsp;&nbsp;unsigned int partiden;                /* table partition iden */ 
&nbsp;&nbsp;unsigned int idxflag;                 /* index info flag  

&nbsp;&nbsp;/* Get oci handles */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/**********************************************/
&nbsp;&nbsp;/* Allocate memory to hold index scan context */
&nbsp;&nbsp;/**********************************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryAlloc((dvoid *)usrhp, errhp, (dvoid **)&amp;icx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_DURATION_STATEMENT, (ub4)(sizeof(qxiqtcx)), OCI_MEMORY_CLEARED)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;icx-&gt;stmthp = (OCIStmt *)0;
&nbsp;&nbsp;icx-&gt;defnp = (OCIDefine *)0;
&nbsp;&nbsp;icx-&gt;bndp = (OCIBind *)0;
&nbsp;&nbsp;}

&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*************************/
&nbsp;&nbsp;&nbsp;&nbsp;/* Retrieve scan context */
&nbsp;&nbsp;&nbsp;&nbsp;/*************************/
&nbsp;&nbsp;&nbsp;&nbsp;rkey = OCIRawPtr(envhp, sctx-&gt;sctx_qxiqtim);
&nbsp;&nbsp;&nbsp;&nbsp;rkeylen = OCIRawSize(envhp, sctx-&gt;sctx_qxiqtim);

&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rkey, (ub1)rkeylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* Check that the bounds are valid */
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* convert from oci numbers to native numbers */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, strt, sizeof(strtval), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;strtval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, stop, sizeof(stopval),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;stopval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* verify that strtval/stopval are both either 0 or 1 */
&nbsp;&nbsp;if (!(((strtval == 0) &amp;&amp; (stopval == 0)) || ((strtval == 1) &amp;&amp; (stopval == 1))))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;strcpy(errmsg, (char *)"Incorrect predicate for sbtree operator");
&nbsp;&nbsp;&nbsp;&nbsp;errmsglen = (size_t)strlen(errmsg);
&nbsp;&nbsp;&nbsp;&nbsp;if (OCIExtProcRaiseExcpWithMsg(ctx, errnum, (text *)errmsg, errmsglen)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!= OCIEXTPROC_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Use cartridge error services here */;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;/*********************************************/
&nbsp;&nbsp;/* Generate the SQL statement to be executed */
&nbsp;&nbsp;/*********************************************/
&nbsp;&nbsp;if (memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)"EQ", 2) == 0)
&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"=");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"!=");
&nbsp;&nbsp;&nbsp;&nbsp;else if 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memcmp((dvoid *)OCIStringPtr(envhp, pr-&gt;ObjectName), (dvoid *)"LT",2) == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&lt;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&gt;=");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (strtval == 1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&gt;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(relop, (char *)"&lt;=");

&nbsp;&nbsp;/* Convert idxflag to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(ix-&gt;IndexInfoFlags),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(idxflag), OCI_NUMBER_UNSIGNED, ( void *)&amp;idxflag)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if ( (idxflag &amp; ODCI_INDEX_RANGE_PARTN) != ODCI_INDEX_RANGE_PARTN)
&nbsp;&nbsp;&nbsp;&nbsp;(void)sprintf(selstmt, "select f2 from %s.%s_sbtree where f1 %s :val",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relop);
&nbsp;&nbsp;else
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollGetElem(envhp, errhp, OCIColl *)ix-&gt;IndexCols,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)0, &amp;exists, (void **) &amp;colinfo, (void **) &amp;colinfo_ind)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* Convert partiden to integer from OCINumber */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, &amp;(colinfo-&gt;TablePartitionIden),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(partiden), OCI_NUMBER_UNSIGNED, ( void *)&amp;partiden)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;(void)sprintf(selstmt, "select f2 from %s.%s_sbtree partition 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DATAOBJ_TO_PARTITION(%s, %d)) where f1 %s :val",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, ix-&gt;IndexSchema), OCIStringPtr(envhp, ix-&gt;IndexName),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringPtr(envhp, colinfo-&gt;TableName), partiden, relop);
&nbsp;&nbsp;}
&nbsp;&nbsp;
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;/* Parse, bind, define and execute */
&nbsp;&nbsp;/***********************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* allocate stmt handle */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleAlloc((dvoid *)envhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid **)&amp;(icx-&gt;stmthp), (ub4)OCI_HTYPE_STMT, (size_t)0, (dvoid **)0)))  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;/* prepare the statement */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtPrepare(icx-&gt;stmthp, errhp, (text *)selstmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)strlen(selstmt), OCI_NTV_SYNTAX, OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up bind for compare value */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIBindByName(icx-&gt;stmthp, &amp;(icx-&gt;bndp), errhp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(text *)":val", sizeof(":val")-1, (dvoid *)cmpval, (sb4)(strlen(cmpval)+1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub2)SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Set up define */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIDefineByPos(icx-&gt;stmthp, &amp;(icx-&gt;defnp), errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)1, (dvoid *)(icx-&gt;ridp), (sb4) sizeof(icx-&gt;ridp), (ub2)SQLT_STR, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (ub2 *)0, (ub2 *)0, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* execute */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIStmtExecute(svchp, icx-&gt;stmthp, errhp, (ub4)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)0, (OCISnapshot *)NULL, (OCISnapshot *)NULL, (ub4)OCI_DEFAULT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/************************************/
&nbsp;&nbsp;/* Set index context to be returned */
&nbsp;&nbsp;/************************************/
&nbsp;&nbsp;if (sctx_ind -&gt;atomic_qxiqtin == OCI_IND_NULL ||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind -&gt;scind_qxiqtin == OCI_IND_NULL)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/* generate a key */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGenerateKey((dvoid *)usrhp, errhp, &amp;key)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* set the memory address of the struct to be saved in the context */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextSetValue((dvoid *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_DURATION_STATEMENT, (ub1 *)&amp;key, (ub1)sizeof(key), (dvoid *)icx)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* statement duration memory alloc for key */ 
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryAlloc(( void *)usrhp, errhp,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( void **)&amp;(sctx-&gt;sctx_qxiqtim), OCI_DURATION_STATEMENT,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sb4)(sizeof(key)+sizeof(ub4)), OCI_MEMORY_CLEARED)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;/* set the key as the member of "sctx" */
&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIRawAssignBytes(envhp, errhp, (ub1 *)&amp;key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4)sizeof(key), &amp;(sctx-&gt;sctx_qxiqtim))))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind-&gt;atomic_qxiqtin = OCI_IND_NOTNULL;
&nbsp;&nbsp;&nbsp;&nbsp;sctx_ind-&gt;scind_qxiqtin = OCI_IND_NOTNULL;

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;}

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGCEBA"></a><div class="props_rev_3"><a id="GUID-9034448B-7A7C-4A11-A904-6E8954792162" name="GUID-9034448B-7A7C-4A11-A904-6E8954792162"></a><h5 id="ADDCI-GUID-9034448B-7A7C-4A11-A904-6E8954792162" class="sect5"><span class="enumeration_section">16.4.6.6 </span>Implementing ODCIIndexFetch() for PSBTREE in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The scan context set up by the start routine is passed in as a parameter to the fetch routine. This function first retrieves the 4-byte key from the scan context. The C mapping for the scan context is <code class="codeph">qxiqtim</code> (see <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 16-6</a>). Next, key is used to look up the OCI context. This gives the memory address of the <code class="codeph">qxiqtcx</code> structure (see <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 16-7</a>) that holds the OCI handles. 
                           </p>
                           <p>This function returns the next batch of rowids that satisfy the operator predicate. It uses the value of the <code class="codeph">nrows</code> parameter as the size of the batch. It repeatedly fetches rowids from the open cursor and populates the <code class="codeph">rowid</code> list. When the batch is full or when there are no more rowids left, the function returns them back to the Oracle server.
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspf(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *self,
&nbsp;&nbsp;qxiqtin           *self_ind,
&nbsp;&nbsp;OCINumber         *nrows,
&nbsp;&nbsp;short             nrows_ind,
&nbsp;&nbsp;OCIArray          **rids,
&nbsp;&nbsp;short             *rids_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int idx = 1;
&nbsp;&nbsp;int nrowsval;

&nbsp;&nbsp;OCIArray *ridarrp = *rids;                  /* rowid collection */
&nbsp;&nbsp;OCIString *ridstr = (OCIString *)0;

&nbsp;&nbsp;int done = 0;
&nbsp;&nbsp;int retval = (int)ODCI_SUCCESS;
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;ub1 *key;                                   /* key to retrieve context */
&nbsp;&nbsp;ub4 keylen;                                 /* length of key */

&nbsp;&nbsp;/*******************/
&nbsp;&nbsp;/* Get OCI handles */
&nbsp;&nbsp;/*******************/
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0, (ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;/* Retrieve context from key    */
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
&nbsp;&nbsp;keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get value of nrows */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberToInt(errhp, nrows, sizeof(nrowsval),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCI_NUMBER_SIGNED, (dvoid *)&amp;nrowsval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/****************/
&nbsp;&nbsp;/* Fetch rowids */
&nbsp;&nbsp;/****************/
&nbsp;&nbsp;while (!done)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if (idx &gt; nrowsval)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = 1;
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status =OCIStmtFetch(icx-&gt;stmthp, errhp, (ub4)1, (ub2) 0, (ub4)OCI_DEFAULT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (status == OCI_NO_DATA)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short col_ind = OCI_IND_NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* have to create dummy oci string */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringAssignText(envhp, errhp, (text *)"dummy", (ub2)5, &amp;ridstr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* append null element to collection */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;col_ind, (OCIColl *)ridarrp)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (status == OCI_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIStringAssignText(envhp, errhp, (text *)icx-&gt;ridp, (ub2)18, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OCIString **)&amp;ridstr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* append rowid to collection */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCICollAppend(envhp, errhp, (dvoid *)ridstr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)0, (OCIColl *)ridarrp)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (qxiqtce(ctx, errhp, status))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}

&nbsp;&nbsp;/* free ridstr finally */
&nbsp;&nbsp;if (ridstr &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qxiqtce(ctx, errhp, OCIStringResize(envhp, errhp, (ub4)0, &amp;ridstr))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;*rids_ind = OCI_IND_NOTNULL;

&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFHDA"></a><div class="props_rev_3"><a id="GUID-43F5A575-F265-43F0-A513-6495057E0BC4" name="GUID-43F5A575-F265-43F0-A513-6495057E0BC4"></a><h5 id="ADDCI-GUID-43F5A575-F265-43F0-A513-6495057E0BC4" class="sect5"><span class="enumeration_section">16.4.6.7 </span>Implementing ODCIIndexClose() for PSBTREE in C
                     </h5>
                     <div>
                        <div class="section">
                           <p>The scan context set up by the start routine is passed in as a parameter to the close routine. This function first retrieves the 4-byte key from the scan context. The C mapping for the scan context is <code class="codeph">qxiqtim</code> (see <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">Example 16-6</a>). Next, the OCI context is looked up based on the key. This gives the memory address of the structure that holds the OCI handles, the <code class="codeph">qxiqtcx</code> structure (see <a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">Example 16-7</a>). 
                           </p>
                           <p>This function closes and frees all the OCI handles. It also frees the memory that was allocated in the start routine. </p><pre class="oac_no_warn" dir="ltr">OCINumber *qxiqtbspc(
&nbsp;&nbsp;OCIExtProcContext *ctx,
&nbsp;&nbsp;qxiqtim           *self,
&nbsp;&nbsp;qxiqtin           *self_ind,
&nbsp;&nbsp;ODCIEnv           *env,
&nbsp;&nbsp;ODCIEnv_ind       *env_ind)
{
&nbsp;&nbsp;sword status;
&nbsp;&nbsp;OCIEnv *envhp = (OCIEnv *) 0;                               /* env. handle */
&nbsp;&nbsp;OCISvcCtx *svchp = (OCISvcCtx *) 0;                      /* service handle */
&nbsp;&nbsp;OCIError *errhp = (OCIError *) 0;                          /* error handle */
&nbsp;&nbsp;OCISession *usrhp = (OCISession *) 0;                       /* user handle */
&nbsp;&nbsp;qxiqtcx *icx = (qxiqtcx *) 0;         /* state to be saved for later calls */

&nbsp;&nbsp;int retval = (int) ODCI_SUCCESS;
&nbsp;&nbsp;OCINumber *rval = (OCINumber *)0;

&nbsp;&nbsp;ub1 *key;                                   /* key to retrieve context */
&nbsp;&nbsp;ub4 keylen;                                 /* length of key */

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIExtProcGetEnv(ctx, &amp;envhp, &amp;svchp, &amp;errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* set up return code */
&nbsp;&nbsp;rval = (OCINumber *)OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber));
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCINumberFromInt(errhp, (dvoid *)&amp;retval,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(retval), OCI_NUMBER_SIGNED, rval)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* get the user handle */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIAttrGet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dvoid *)&amp;usrhp, (ub4 *)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_ATTR_SESSION, errhp)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;/* Retrieve context using key   */
&nbsp;&nbsp;/********************************/
&nbsp;&nbsp;key = OCIRawPtr(envhp, self-&gt;sctx_qxiqtim);
&nbsp;&nbsp;keylen = OCIRawSize(envhp, self-&gt;sctx_qxiqtim);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextGetValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen, (dvoid **)&amp;(icx))))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* Free handles and memory */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIHandleFree((dvoid *)icx-&gt;stmthp, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub4)OCI_HTYPE_STMT)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIMemoryFree((dvoid *)usrhp, errhp, (dvoid *)icx)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;/* free the memory allocated for the index context. */
&nbsp;&nbsp;if (qxiqtce(ctx, errhp, OCIContextClearValue((dvoid *)usrhp, errhp, key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ub1)keylen)))
&nbsp;&nbsp;&nbsp;&nbsp;return(rval);

&nbsp;&nbsp;&nbsp;&nbsp;return(rval);
}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="CACGICCC"></a><div class="props_rev_3"><a id="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" name="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2"></a><h4 id="ADDCI-GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" class="sect4"><span class="enumeration_section">16.4.7 </span>Implementing the Indextype for PSBTREE
                  </h4>
                  <div>
                     <p>You should create the indextype object and specify the list of operators that it supports. In addition, specify the name of the implementation type that implements the ODCIIndexXXX() interface routines.</p><pre class="oac_no_warn" dir="ltr">CREATE INDEXTYPE psbtree
FOR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eq(VARCHAR2, VARCHAR2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt(VARCHAR2, VARCHAR2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt(VARCHAR2, VARCHAR2)
USING psbtree_im
WITH LOCAL RANGE PARTITION
WITH SYSTEM MANAGED STORAGE TABLES</pre></div>
               </div>
            </div><a id="ADDCI4920"></a><div class="props_rev_3"><a id="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" name="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F"></a><h3 id="ADDCI-GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" class="sect3"><span class="enumeration_section">16.5 </span>Using PSBTREE
               </h3>
               <div>
                  <p>You should next create the indextype object and specify the list of operators that it supports. In addition, specify the name of the implementation type that implements the <code class="codeph">ODCIIndex</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">()</code> interface routines. This step is demonstrated in the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">Implementing the Indextype for PSBTREE</a> section.
                  </p>
                  <p>One typical usage scenario is to create a range partitioned table and populate it, as demonstrated in the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">Creating and Populating a Partitioned Table for PSBTREE</a> section. 
                  </p>
                  <p>You can then create a <code class="codeph">psbtree</code> index on column <code class="codeph">f2</code>. The <code class="codeph">CREATE INDEX</code> statement specifies the indextype that should be used, as demonstrated in the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">Creating a PSBTREE Index on a Column</a> section. 
                  </p>
                  <p>To execute a query that uses one of the <code class="codeph">psbtree</code> operators, use the code in the <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">Using PSBTREE Operators in a Query</a> section.
                  </p>
               </div><a id="CACCEACF"></a><div class="props_rev_3"><a id="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" name="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2"></a><h4 id="ADDCI-GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" class="sect4"><span class="enumeration_section">16.5.1 </span>Creating and Populating a Partitioned Table for PSBTREE
                  </h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE TABLE t1 (f1 NUMBER, f2 VARCHAR2(200))
PARTITION BY RANGE(f1)
(
&nbsp;&nbsp;PARTITION p1 VALUES LESS THAN (101),
&nbsp;&nbsp;PARTITION p2 VALUES LESS THAN (201),
&nbsp;&nbsp;PARTITION p3 VALUES LESS THAN (301),
&nbsp;&nbsp;PARTITION p4 VALUES LESS THAN (401)
 );
INSERT INTO t1 VALUES (10, 'aaaa');
INSERT INTO t1 VALUES (200, 'bbbb');
INSERT INTO t1 VALUES (100, 'cccc');
INSERT INTO t1 VALUES (300, 'dddd');
INSERT INTO t1 VALUES (400, 'eeee');
COMMIT;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACJJHIG"></a><div class="props_rev_3"><a id="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" name="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D"></a><h4 id="ADDCI-GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" class="sect4"><span class="enumeration_section">16.5.2 </span>Creating a PSBTREE Index on a Column
                  </h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE INDEX it1 ON t1(f2) iINDEXTYPE IS psbtree LOCAL 
(PARTITION pe1 PARAMETERS('test1'), PARTITION pe2,
 PARTITION pe3, PARTITION pe4 PARAMETERS('test4')) 
PARAMETERS('test');
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACHDCED"></a><div class="props_rev_3"><a id="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" name="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C"></a><h4 id="ADDCI-GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" class="sect4"><span class="enumeration_section">16.5.3 </span>Using PSBTREE Operators in a Query
                  </h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT * FROMM t1 WHERE eq(f2, 'dddd') = 1 AND f1&gt;101 ;
</pre><p>The explain plan output for this query should look like this:</p><pre class="oac_no_warn" dir="ltr">OPERATION            OPTIONS                PARTITION_START       PARTITION_STOP
--------------------------------------------------------------------------------
SELECT STATEMENT
PARTITION RANGE      ITERATOR               2                     4
TABLE ACCESS         BY LOCAL INDEX ROWID   2                     4
DOMAIN INDEX</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>