<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">
      <meta name="description" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">
      <title>SQL/JSON Function JSON_TABLE</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JSON Developer's Guide">
      <meta property="og:description" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JSON Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="json-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-22T10:58:31-08:00">
      <meta name="dcterms.title" content="JSON Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96227-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="function-JSON_QUERY.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-sql-function-json_serialize.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADJSN">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="function-JSON_QUERY.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-sql-function-json_serialize.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JSON Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-json-data.html" property="item" typeof="WebPage"><span property="name">Query JSON Data</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL/JSON Function JSON_TABLE</li>
            </ol>
            <a id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" name="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A"></a>
            
            <h2 id="ADJSN-GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" class="sect2"><span class="enumeration_chapter">18 </span>SQL/JSON Function JSON_TABLE
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>SQL/JSON function <code class="codeph">json_table</code> projects specific JSON data
    to columns of various SQL data types. You use it to map parts of a JSON document into the rows
    and columns of a new, virtual table, which you can also think of as an inline view.
               </p>
               <div class="section">
                  <p>You can then insert this virtual table into a pre-existing database table, or
        you can query it using SQL — in a join expression, for example.</p>
                  <p>A common
        use of <code class="codeph">json_table</code> is to create a <span class="italic">view</span> of JSON data. You can use such
        a view just as you would use any table or view. This lets applications, tools, and
        programmers operate on JSON data without consideration of the syntax of JSON or JSON path
        expressions.
                  </p>
                  <p>Defining a view over JSON data in effect maps a kind of
          <span class="italic">schema</span> onto that data. This mapping is <span class="italic">after the fact</span>: the underlying JSON
        data can be defined and created without any regard to a schema or any particular pattern of
        use. Data first, schema later. 
                  </p>
                  <p>Such a schema (mapping) imposes no
        restriction on the kind of JSON documents that can be stored in the database (other than
        being well-formed JSON data). The view exposes only data that conforms to the mapping
        (schema) that defines the view. To change the schema, just redefine the view — no need to
        reorganize the underlying JSON data.</p>
                  <p>You use <code class="codeph">json_table</code>
        in a SQL <code class="codeph">FROM</code> clause. It is a <strong class="term">row source</strong>: it
        generates a row of virtual-table data for each JSON value selected by a <span class="italic">row path
          expression</span> (row pattern). The columns of each generated row are defined by the
          <span class="italic">column path expressions</span> of the <code class="codeph">COLUMNS</code> clause.
                  </p>
                  <p>Typically a <code class="codeph">json_table</code> invocation is laterally joined, implicitly, with a
        source table in the <code class="codeph">FROM</code> list, whose rows each contain a JSON document that
        is used as input to the function. <code class="codeph">json_table</code> generates zero or more new
        rows, as determined by evaluating the row path expression against the input document.
                  </p>
                  <p>The first argument to <code class="codeph">json_table</code> is a SQL expression. It can
        be a table or view column value, a PL/SQL variable, or a bind variable with proper casting.
        The result of evaluating the expression is used as the <span class="italic">context item</span> for evaluating
        the row path expression.
                  </p>
                  <p>The second argument to
          <code class="codeph">json_table</code> is the SQL/JSON row path expression followed by an optional
        error clause for handling the row and the (required) <code class="codeph">COLUMNS</code> clause, which
        defines the columns of the virtual table to be created. There is no
          <code class="codeph">RETURNING</code> clause. 
                  </p>
                  <p>There are two levels of error
        handling for <code class="codeph">json_table</code>, corresponding to the two levels of path
        expressions: row and column. When present, a column error handler overrides row-level error
        handling. The default error handler for both levels is <code class="codeph">NULL ON ERROR</code>.
        
                  </p>
                  <p>As an alternative to passing the context-item argument and the row path
        expression, you can use simple dot-notation syntax. (You can still use an error clause, and
        the <code class="codeph">COLUMNS</code> clause is still required.) Dot notation specifies a table or
        view column together with a simple path to the targeted JSON data. For example, these two
        queries are
        equivalent:
                  </p><pre class="pre codeblock"><code>json_table(<span class="bold">t.j, '$.ShippingInstructions.Phone[*]'</span> ...)

json_table(<span class="bold">t.j.ShippingInstructions.Phone[*]</span> ...)</code></pre><p>And in cases where the row path expression is only <code class="codeph">'$'</code>, which
        targets the entire document, you can omit the path part. These queries are
        equivalent:
                  </p><pre class="pre codeblock"><code>json_table(<span class="bold">t.j, '$'</span> ...)

json_table(<span class="bold">t.j</span> ...)</code></pre><p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">Example 18-1</a> illustrates the difference between using the simple dot notation and using
        the fuller, more explicit notation.
                  </p>
               </div>
               <!-- class="section" -->
               <div class="example" id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">
                  <p class="titleinexample">Example 18-1 Equivalent JSON_TABLE Queries: Simple and
        Full
        Syntax</p>
                  <p>This example uses <code class="codeph">json_table</code> for two equivalent queries. The
        first query uses the simple, dot-notation syntax for the expressions that target the row and
        column data. The second uses the full syntax.
                  </p>
                  <p>Except for column
          <code class="codeph">Special Instructions</code>, whose SQL identifier is quoted, the SQL column
        names are, in effect, uppercase. (Identifier <code class="codeph">Special Instructions</code> contains
        a space character.)
                  </p>
                  <p>In the first query the column names are written
        exactly the same as the names of the targeted object fields, including with respect to
        letter case. Regardless of whether they are quoted, they are interpreted case-sensitively
        for purposes of establishing the default path (the path used when there is no explicit
          <code class="codeph">PATH</code> clause).
                  </p>
                  <p>The second query has:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Separate arguments of a JSON column-expression and a SQL/JSON
            row path-expression</p>
                     </li>
                     <li>
                        <p>Explicit column data types of
            <code class="codeph">VARCHAR2(4000)</code></p>
                     </li>
                     <li>
                        <p>Explicit <code class="codeph">PATH</code> clauses with SQL/JSON column
            path expressions, to target the object fields that are projected
                        </p>
                     </li>
                  </ul><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder po,
       json_table(po.po_document
         COLUMNS (<span class="bold">"Special Instructions"</span>,
                  NESTED LineItems[*]
                    COLUMNS (<span class="bold">ItemNumber</span> NUMBER,
                             <span class="bold">Description</span> PATH Part.Description))) AS "JT";</code></pre><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder po,
       json_table(po.po_document<span class="bold">,</span> 
         <span class="bold">'$'</span>
         COLUMNS (
           "Special Instructions" <span class="bold">VARCHAR2(4000) PATH '$."Special Instructions"'</span>,
           NESTED <span class="bold">PATH '$.LineItems[*]</span>'
             COLUMNS (
               ItemNumber  NUMBER        <span class="bold">PATH '$.ItemNumber'</span>,
               Description <span class="bold">VARCHAR(4000)</span> PATH '$.Part.Description'))) AS "JT";
</code></pre></div>
               <!-- class="example" -->
               <div class="section">
                  <div class="infoboxnotealso" id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-10170DA4-D38A-4502-8DC3-58B1CB24AA1E">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/JSON_TABLE.html#SQLRF56973" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about <code class="codeph">json_table</code></p>
                  </div>
               </div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5">SQL NESTED Clause Instead of JSON_TABLE</a><br>In a <code class="codeph">SELECT</code> clause you can often use a             <code class="codeph">NESTED</code> clause instead of SQL/JSON function <code class="codeph">json_table</code>.         This can mean a simpler query expression. It also has the advantage of including rows with             non-<code class="codeph">NULL</code> relational columns when the JSON column is             <code class="codeph">NULL</code>.
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-142213E5-F856-458C-A71F-18524DEDF430">COLUMNS Clause of SQL/JSON Function JSON_TABLE</a><br>The mandatory <code class="codeph">COLUMNS</code> clause for SQL/JSON function <code class="codeph">json_table</code> defines the columns of the virtual table that the function creates.
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903">JSON_TABLE Generalizes SQL/JSON Query Functions and Conditions</a><br>SQL/JSON function <code class="codeph">json_table</code> generalizes SQL/JSON condition <code class="codeph">json_exists</code> and SQL/JSON functions <code class="codeph">json_value</code> and <code class="codeph">json_query</code>. Everything that you can do using these functions you can do using <code class="codeph">json_table</code>. For the jobs they accomplish, the syntax of these functions is simpler to use than is the syntax of <code class="codeph">json_table</code>.
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5">Using JSON_TABLE with JSON Arrays</a><br>A JSON value can be an array or can include one or more arrays, nested to     any number of levels inside other JSON arrays or objects. You can use a       <code class="codeph">json_table</code>     <code class="codeph">NESTED</code> path clause to project specific elements of an array.
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5">Creating a View Over JSON Data Using JSON_TABLE</a><br>To improve query performance you can create a view over JSON data that you project to columns using SQL/JSON function <code class="codeph">json_table</code>. To further improve query performance you can create a <span class="italic">materialized view</span> and place the JSON data <span class="italic">in memory</span>.
                  </li>
               </ul>
               <div class="relinfo">
                  <p><strong>Related Topics</strong></p>
                  <ul>
                     <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some SQL query functions and conditions accept an optional error clause, which specifies handling for a runtime error that is raised by the function or condition. This clause and the default behavior (no error clause) are summarized here.">Error Clause for SQL Query Functions and Conditions</a></li>
                     <li><a href="function-JSON_QUERY.html#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" title="SQL/JSON function json_query selects one or more values from JSON data and returns a string (VARCHAR2, CLOB, or BLOB instance) that represents the JSON values. You can thus use json_query to retrieve fragments of a JSON document.">SQL/JSON Function JSON_QUERY</a></li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="query-json-data.html#GUID-119E5069-77F2-45DC-B6F0-A1B312945590" title="You can query JSON data using a simple dot notation or, for more functionality, using SQL/JSON functions and conditions. You can create and query a data guide that summarizes the structure and type information of a set of JSON documents.">Query JSON Data</a></p>
                  </div>
               </div>
            </div>
            
            <div class="sect2"><a id="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5" name="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5"></a><h3 id="ADJSN-GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5" class="sect3"><span class="enumeration_section">18.1 </span>SQL NESTED Clause Instead of
        JSON_TABLE
               </h3>
               <div>
                  <p>In a <code class="codeph">SELECT</code> clause you can often use a
            <code class="codeph">NESTED</code> clause instead of SQL/JSON function <code class="codeph">json_table</code>.
        This can mean a simpler query expression. It also has the advantage of including rows with
            non-<code class="codeph">NULL</code> relational columns when the JSON column is
            <code class="codeph">NULL</code>.
                  </p>
                  <p>The <code class="codeph">NESTED</code> clause is a shortcut for using
                <code class="codeph">json_table</code> with an ANSI left outer join. That is, these two queries
            are equivalent:
                  </p><pre class="pre codeblock"><code>SELECT ... 
  FROM mytable <span class="bold">NESTED</span> jcol COLUMNS (...);</code></pre><pre class="pre codeblock"><code>SELECT ...
  FROM mytable <span class="bold">t1</span> <span class="bold">LEFT OUTER JOIN</span>
       <span class="bold">json_table</span>(<span class="bold">t1.</span>jcol COLUMNS (...)
       <span class="bold">ON 1=1</span>;</code></pre><p>Using a left outer join with <code class="codeph">json_table</code>, or using the
                <code class="codeph">NESTED</code> clause, allows the selection result to include rows with
            relational columns where there is no corresponding JSON-column data, that is, where the
            JSON column is <code class="codeph">NULL</code>. The only semantic difference between the two is
            that if you use a <code class="codeph">NESTED</code> clause then the JSON column itself is not
            included in the result.
                  </p>
                  <p>The <code class="codeph">NESTED</code> clause provides the same <code class="codeph">COLUMNS</code>
            clause as <code class="codeph">json_table</code>, including the possibility of nested columns.
            Advantages of using <code class="codeph">NESTED</code> are that you need not provide an <code class="codeph">is
                json</code> check constraint (needed for <code class="codeph">json_table</code> with the
            simple dot notation) or a table alias, and you need not specify <code class="codeph">LEFT OUTER
                JOIN</code>. The <code class="codeph">NESTED</code> clause syntax is simpler, it allows all
            of the flexibility of the <code class="codeph">COLUMNS</code> clause, and it performs an implicit
            left outer join.
                  </p>
                  <div class="example" id="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5__GUID-4A73163A-D191-4798-8DD8-AC6F96B68D46">
                     <p class="titleinexample">Example 18-2  Equivalent: SQL NESTED and
                JSON_TABLE with LEFT OUTER JOIN</p>
                     <p>These two queries are
                equivalent. One uses SQL/JSON function <code class="codeph">json_table</code> with an explicit
                    <code class="codeph">LEFT OUTER JOIN</code>. The other uses a SQL <code class="codeph">NESTED</code>
                clause.
                     </p><pre class="pre codeblock"><code>SELECT id, requestor, type, "number"
  FROM j_purchaseorder <span class="bold">LEFT OUTER JOIN</span>
       <span class="bold">json_table</span>(po_document
         COLUMNS (Requestor,
                  NESTED ShippingInstructions.Phone[*]
                    COLUMNS (type, "number")))
       ON 1=1);

SELECT id, requestor, type, "number"
  FROM j_purchaseorder <span class="bold">NESTED</span>
       po_document
         COLUMNS (Requestor,
                  NESTED ShippingInstructions.Phone[*]
                    COLUMNS (type, "number");</code></pre><p>The output is the same in both
                cases:</p><pre class="pre codeblock"><code>7C3A54B183056369E0536DE05A0A15E4 Alexis Bull Office 909-555-7307
7C3A54B183056369E0536DE05A0A15E4 Alexis Bull Mobile 415-555-1234
7C3A54B183066369E0536DE05A0A15E4 Sarah Bell</code></pre><p>If table <code class="codeph">j_purchaseorder</code> had a row with
                    non-<code class="codeph">NULL</code> values for columns <code class="codeph">id</code> and
                    <code class="codeph">requestor</code>, but a <code class="codeph">NULL</code> value for column
                    <code class="codeph">po_document</code> then that row would appear in both cases. But it
                would not appear in the <code class="codeph">json_table</code> case if <code class="codeph">LEFT OUTER
                    JOIN</code> were absent.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-142213E5-F856-458C-A71F-18524DEDF430" name="GUID-142213E5-F856-458C-A71F-18524DEDF430"></a><h3 id="ADJSN-GUID-142213E5-F856-458C-A71F-18524DEDF430" class="sect3"><span class="enumeration_section">18.2 </span>COLUMNS Clause of SQL/JSON
        Function JSON_TABLE
               </h3>
               <div>
                  <p>The mandatory <code class="codeph">COLUMNS</code> clause for SQL/JSON function <code class="codeph">json_table</code> defines the columns of the virtual table that the function creates.
                  </p>
                  <p> It consists of the keyword <span class="bold"><code class="codeph">COLUMNS</code></span> followed by the
            following entries, enclosed in parentheses. Other than the optional <code class="codeph">FOR
                ORDINALITY</code> entry, each entry in the <code class="codeph">COLUMNS</code> clause is
            either a <span class="italic">regular</span> column specification or a <span class="italic">nested</span> columns specification. 
                  </p>
                  <ul style="list-style-type: disc;" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_SWL_J5V_SFB">
                     <li>
                        <p>At most one entry in the <code class="codeph">COLUMNS</code> clause
                    can be a column name followed by the keywords <span class="bold"><code class="codeph">FOR
                        ORDINALITY</code></span>, which specifies a column of generated row numbers
                    (SQL data type <code class="codeph">NUMBER</code>). These numbers start with one. For
                    example:
                        </p><pre class="pre codeblock"><code>COLUMNS (linenum FOR ORDINALITY, ProductID)</code></pre></li>
                     <li>
                        <p>A <strong class="term">regular column</strong> specification consists of
                    a column name followed by an optional scalar data type for the column, which can
                    be SQL data type <code class="codeph">VARCHAR2</code>, <code class="codeph">NUMBER</code>,
                        <code class="codeph">DATE</code>, <code class="codeph">TIMESTAMP</code>, <code class="codeph">TIMESTAMP WITH
                        TIME ZONE</code>, or <code class="codeph">SDO_GEOMETRY</code> (the same as for the
                        <code class="codeph">RETURNING</code> clause of <code class="codeph">json_value</code>), followed
                    by an optional value clause and an optional <code class="codeph">PATH</code> clause. The
                    default data type is <code class="codeph">VARCHAR2(4000)</code>. 
                        </p>
                        <p>Data
                    type <code class="codeph">SDO_GEOMETRY</code> is used for Oracle Spatial and Graph data. In
                    particular, this means that you can use <code class="codeph">json_table</code> with GeoJSON
                    data, which is a format for encoding geographic data in
                    JSON.
                        </p>
                        <p>Oracle extends the SQL/JSON standard in the case when the returning
                    data type for a column is <code class="codeph">VARCHAR2(<span class="codeinlineitalic">N</span>)</code>, by allowing
                    optional keyword <code class="codeph"><span class="bold">TRUNCATE</span></code> immediately after the data
                    type. When <code class="codeph">TRUNCATE</code> is present and the value to return is wider
                    than <code class="codeph"><span class="codeinlineitalic">N</span></code>, the value is truncated — only the first
                            <code class="codeph"><span class="codeinlineitalic">N</span></code> characters are returned. If
                        <code class="codeph">TRUNCATE</code> is absent then this case is treated as an error,
                    handled as usual by an error clause or the default error-handling
                behavior.
                        </p>
                     </li>
                     <li>
                        <p>A <strong class="term">nested columns </strong>specification consists of
                    the keyword <span class="bold"><code class="codeph">NESTED</code></span> followed by an optional
                        <code class="codeph">PATH</code> keyword, a SQL/JSON row path expression, and then a
                        <code class="codeph">COLUMNS</code> clause. This <code class="codeph">COLUMNS</code> clause
                    specifies columns that represent nested data. The row path expression used here
                    provides a refined context for the specified nested columns: each nested column
                    path expression is relative to the row path expression. You can nest columns
                    clauses to project values that are present in arrays at different levels to
                    columns of the same row.
                        </p>
                        <p>A <code class="codeph">COLUMNS</code> clause at
                    any level (nested or not) has the same characteristics. In other words, the
                        <code class="codeph">COLUMNS</code> clause is defined recursively. For each level of
                    nesting (that is, for each use of keyword <code class="codeph">NESTED</code>), the nested
                        <code class="codeph">COLUMNS</code> clause is said to be the <strong class="term">child</strong> of the <code class="codeph">COLUMNS</code> clause within which it is
                    nested, which is its <strong class="term">parent</strong>. Two or more
                        <code class="codeph">COLUMNS</code> clauses that have the same parent clause are <strong class="term">siblings</strong>.
                        </p>
                        <p>The virtual tables defined by
                    parent and child <code class="codeph">COLUMNS</code> clauses are joined using an
                        <span class="italic">outer</span> join, with the parent being the outer table. The virtual
                    columns defined by sibling <code class="codeph">COLUMNS</code> clauses are joined using a
                        <code class="codeph">union</code> join.
                        </p>
                        <p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">Example 18-1</a> and <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 18-8</a> illustrate the use of a nested columns
                    clause.
                        </p>
                     </li>
                  </ul>
                  <p>The only thing required in a regular column specification is the column
            name. Defining the column projection in more detail, by specifying a scalar data type,
            value handling, or a target path, is optional.</p>
                  <ul style="list-style-type: disc;" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_TWL_J5V_SFB">
                     <li>
                        <p>The optional <strong class="term">value</strong> clause
                    specifies how to handle the data projected to the column: whether to handle it
                    as would <code class="codeph">json_value</code>, <code class="codeph">json_exists</code>, or
                        <code class="codeph">json_query</code>. This value handling includes the return data
                    type, return format (pretty or ASCII), wrapper, and error treatment.
                        </p>
                        <p>By default, the projected data is handled as if by
                        <code class="codeph">json_value</code>. If you use keyword
                        <span class="bold"><code class="codeph">EXISTS</code></span> then it is handled as if by
                        <code class="codeph">json_exists</code>. If you use keywords <span class="bold"><code class="codeph">FORMAT
                            JSON</code></span> then it is handled as if by
                        <code class="codeph">json_query</code>. 
                        </p>
                        <p>For <code class="codeph">FORMAT
                        JSON</code> you can override the default wrapping behavior by adding an
                    explicit wrapper clause. 
                        </p>
                        <p>You can override the default error
                    handling for the given handler (<code class="codeph">json_value</code>,
                        <code class="codeph">json_exists</code>, or <code class="codeph">json_query</code>) by adding an
                    explicit error clause appropriate for it.
                        </p>
                     </li>
                     <li>
                        <p>The optional <span class="bold"><code class="codeph">PATH</code></span> clause specifies the
                    portion of the row that is to be used as the column content. The column path
                    expression following keyword <code class="codeph">PATH</code> is matched against the
                    context item provided by the virtual row. The column path expression must
                    represent a <span class="italic">relative</span> path; it is relative to the path specified by the
                    row path expression.
                        </p>
                        <p>If the <code class="codeph">PATH</code> clause is
                    not present then the behavior is the same as if it were present with a path of
                            <code class="codeph">'$.<span class="codeinlineitalic">&lt;column-name&gt;</span>'</code>, where
                            <code class="codeph"><span class="codeinlineitalic">&lt;column-name&gt;</span></code> is the column name. That is,
                    the name of the object field that is targeted is taken implicitly as the column
                    name. For purposes of specifying the targeted field <span class="italic">only</span>, the SQL
                    identifier used for <code class="codeph"><span class="codeinlineitalic">&lt;column-name&gt;</span></code> is interpreted
                        <span class="italic">case-sensitively</span>, even if it is not quoted. The SQL name of the
                    column follows the usual rule: if it is enclosed in double quotation marks
                        (<code class="codeph">"</code>) then the letter case used is significant; otherwise, it
                    is not (it is treated as if uppercase).
                        </p>
                        <p>For example, these two
                        <code class="codeph">COLUMNS</code> clauses are equivalent. For SQL, case is
                    significant <span class="italic">only</span> for column
                    <code class="codeph">Comments</code>.
                        </p><pre class="pre codeblock"><code>COLUMNS(ProductId, quantity NUMBER, "Comments")

COLUMNS(ProductId   VARCHAR2(4000) PATH '$.ProductId',
        quantity    NUMBER         PATH '$.quantity',
        <span class="bold">"</span>Comments<span class="bold">"</span>  VARCHAR2(4000) PATH '$.Comments')
</code></pre><p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">Example 18-1</a> presents equivalent queries that illustrate
                    this.
                        </p>
                     </li>
                  </ul>
                  <p>If you use <code class="codeph"><span class="bold">FORMAT JSON</span></code> in a given
                <code class="codeph">json_table</code> column specification then <code class="codeph">json_query</code>
            semantics are used when projecting the JSON data to the column. The data type specified
            for the column can be any of the SQL data types that <code class="codeph">json_query</code> can
            return: <code class="codeph">VARCHAR2</code>, <code class="codeph">CLOB</code>, or <code class="codeph">BLOB</code>.
                  </p>
                  <p><code class="codeph"><span class="bold">json_query</span></code> semantics imply the following:
                  </p>
                  <ul style="list-style-type: disc;" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_UWL_J5V_SFB">
                     <li>
                        <p>The projected JSON data is always well-formed. This
                    includes ensuring that non-ASCII characters in string values are escaped as
                    needed. For example, a TAB character (CHARACTER TABULATION, U+0009) is escaped
                    as <code class="codeph">\t</code>.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">json_query</code> error handling
                applies.
                        </p>
                     </li>
                     <li>
                        <p>You can use a wrapper clause, to project multiple JSON
                    values as elements in an array.</p>
                     </li>
                  </ul>
                  <p>If you do <span class="italic">not</span> use <code class="codeph">FORMAT JSON</code> in a given
                <code class="codeph">json_table</code> column specification then <code class="codeph">json_value</code>
            semantics are used when projecting the JSON data. The data type specified for the column
            can be any of the SQL data types that <code class="codeph">json_value</code> can return:
                <code class="codeph">VARCHAR2</code>, <code class="codeph">NUMBER</code>, <code class="codeph">DATE</code>,
                <code class="codeph">TIMESTAMP</code>, <code class="codeph">TIMESTAMP WITH TIME ZONE</code>,
                <code class="codeph">SDO_GEOMETRY</code>, or <code class="codeph">CLOB</code>. <code class="codeph">json_value</code>
            error handling applies (and you cannot use a wrapper clause).
                  </p>
                  <p>For example, here the value of column <code class="codeph">FirstName</code> is projected
            directly using <code class="codeph">json_value</code> semantics, and the value of column
                <code class="codeph">Address</code> is projected as a JSON string using
                <code class="codeph">json_query</code> semantics:
                  </p><pre class="pre codeblock"><code>COLUMNS (FirstName, Address FORMAT JSON)</code></pre><p>You typically use <code class="codeph">FORMAT JSON</code> when the projected data is a
            JSON object or array. You typically do not use <code class="codeph">FORMAT JSON</code> when the
            projected data is a JSON scalar.
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="SQL functions json_value, json_query, json_serialize, and json_mergepatch accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for SQL Query Functions</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="SQL/JSON query functions json_query and json_table accept an optional wrapper clause, which specifies the form of the value returned by json_query or used for the data in a json_table column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.">Wrapper Clause for SQL/JSON Query Functions JSON_QUERY and JSON_TABLE</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="Some SQL query functions and conditions accept an optional error clause, which specifies handling for a runtime error that is raised by the function or condition. This clause and the default behavior (no error clause) are summarized here.">Error Clause for SQL Query Functions and Conditions</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-3176ECEA-BBCE-4C7C-AB24-7FCE250B8443" title="SQL/JSON query functions json_value, json_query, and json_table accept an optional ON EMPTY clause, which specifies the handling to use when a targeted JSON field is absent from the data queried. This clause and the default behavior (no ON EMPTY clause) are described here.">Empty-Field Clause for SQL/JSON Query Functions</a></li>
                        <li><a href="function-JSON_QUERY.html#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" title="SQL/JSON function json_query selects one or more values from JSON data and returns a string (VARCHAR2, CLOB, or BLOB instance) that represents the JSON values. You can thus use json_query to retrieve fragments of a JSON document.">SQL/JSON Function JSON_QUERY</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__NOTE_BQD_TVV_SFB">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_AFJ_S5V_SFB">
                        <li>
                           <p><a href="../sqlrf/JSON_TABLE.html#SQLRF56973" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                        </li>
                        <li>
                           <p>
                              <a href="../spatl/spatial-concepts.html#SPATL-GUID-D703DF4D-57D1-4990-8F53-CAAA9C8FCB2F" target="_blank"><span><cite>Oracle Spatial and Graph Developer's Guide</cite></span></a> for
                            information about using Oracle Spatial and Graph data
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adjsn&amp;id=geojson_org" target="_blank">GeoJSON.org</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6289"></a><a id="ADXDB6290"></a><a id="ADXDB6288"></a><div class="props_rev_3"><a id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" name="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903"></a><h3 id="ADJSN-GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" class="sect3"><span class="enumeration_section">18.3 </span>JSON_TABLE Generalizes SQL/JSON Query Functions and Conditions
               </h3>
               <div>
                  <p>SQL/JSON function <code class="codeph">json_table</code> generalizes SQL/JSON condition <code class="codeph">json_exists</code> and SQL/JSON functions <code class="codeph">json_value</code> and <code class="codeph">json_query</code>. Everything that you can do using these functions you can do using <code class="codeph">json_table</code>. For the jobs they accomplish, the syntax of these functions is simpler to use than is the syntax of <code class="codeph">json_table</code>.
                  </p>
                  <p>If you use any of <code class="codeph">json_exists</code>, <code class="codeph">json_value</code>, or <code class="codeph">json_query</code> more than once, or in combination, to access the same data then a single invocation of <code class="codeph">json_table</code> presents the advantage that the data is parsed only once.
                  </p>
                  <p>Because of this, the optimizer often automatically rewrites multiple invocations of <code class="codeph">json_exists</code>, <code class="codeph">json_value</code> and <code class="codeph">json_query</code> (any combination) to fewer invocations of <code class="codeph">json_table</code> instead, so the data is parsed only once.
                  </p>
                  <p><a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">Example 18-3</a> and <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a> illustrate this. They each select the requestor and the set of phones used by each object in column <code class="codeph">j_purchaseorder.po_document</code>. But <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a> parses that column only once, not four times.
                  </p>
                  <p>Note the following in connection with <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a>:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>A JSON value of <code class="codeph">null</code> is a <span class="italic">value</span> as far as SQL is concerned; it is <span class="italic">not</span> <code class="codeph">NULL</code>, which in SQL represents the absence of a value (missing, unknown, or inapplicable data). In <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a>, if the JSON value of object attribute <code class="codeph">zipCode</code> is <code class="codeph">null</code> then the SQL string <code class="codeph">'true'</code> is returned.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">json_exists</code> is a SQL <span class="italic">condition</span>; you can use it in a SQL <code class="codeph">WHERE</code> clause, a <code class="codeph">CASE</code> statement, or a check constraint. In <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">Example 18-3</a> it is used in a <code class="codeph">WHERE</code> clause. Function <code class="codeph">json_table</code> employs the semantics of <code class="codeph">json_exists</code> implicitly when you specify keyword <code class="codeph">EXISTS</code>. It must return a SQL <span class="italic">value</span> in the virtual column. Since Oracle SQL has no Boolean data type, a SQL string <code class="codeph">'true'</code> or <code class="codeph">'false'</code> is used to represent the Boolean value. This is the case in <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a>: the <code class="codeph">VARCHAR2</code> value is stored in column <code class="codeph">jt.has_zip</code>, and it is then tested explicitly for equality against the literal SQL string <code class="codeph">'true'</code>.
                        </p>
                     </li>
                     <li>
                        <p>JSON field <code class="codeph">AllowPartialShipment</code> has a JSON Boolean value. When <code class="codeph">json_value</code> is applied to that value it is returned as a string. In <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">Example 18-4</a>, data type <code class="codeph">VARCHAR2</code> is used as the column data type. Function <code class="codeph">json_table</code> implicitly uses <code class="codeph">json_value</code> for this column, returning the value as a <code class="codeph">VARCHAR2</code> value, which is then tested for equality against the literal SQL string <code class="codeph">'true'</code>.
                        </p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">
                     <p class="titleinexample">Example 18-3 Accessing JSON Data Multiple Times to Extract Data</p><pre class="pre codeblock"><code>SELECT json_<span class="bold">value</span>(po_document, '$.Requestor' RETURNING VARCHAR2(32)),
       json_<span class="bold">query</span>(po_document, '$.ShippingInstructions.Phone'
                               RETURNING VARCHAR2(100))
  FROM j_purchaseorder
  WHERE json_<span class="bold">exists</span>(po_document, '$.ShippingInstructions.Address.zipCode')
    AND json_<span class="bold">value</span>(po_document,  '$.AllowPartialShipment' RETURNING VARCHAR2(5 CHAR))
        = <span class="bold">'true'</span>;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">
                     <p class="titleinexample">Example 18-4 Using JSON_TABLE to Extract Data Without Multiple Parses</p><pre class="pre codeblock"><code>SELECT jt.requestor, jt.phones
  FROM j_purchaseorder,
       json_table(po_document, '$'
         COLUMNS (requestor VARCHAR2(32 CHAR) PATH '$.Requestor',
                  phones    VARCHAR2(100 CHAR) FORMAT JSON
                            PATH '$.ShippingInstructions.Phone',
                  <span class="bold">partial</span>   <span class="bold">VARCHAR2</span>(5 CHAR) PATH '$.AllowPartialShipment',
                  <span class="bold">has_zip</span>   <span class="bold">VARCHAR2</span>(5 CHAR) <span class="bold">EXISTS</span>
                            PATH '$.ShippingInstructions.Address.zipCode')) jt
  WHERE <span class="bold">jt.partial = 'true'</span> AND <span class="bold">jt.has_zip = 'true'</span>;
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="function-JSON_VALUE.html#GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50" title="JSON has the Boolean values true and false. When SQL/JSON function json_value evaluates a SQL/JSON path expression and the result is JSON true or false, it can be returned to PL/SQL as a BOOLEAN value, or it can be returned to SQL as the VARCHAR2 value 'true' or 'false'.">Using SQL/JSON Function JSON_VALUE With a Boolean JSON Value</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6386"></a><a id="ADXDB6387"></a><a id="ADXDB6388"></a><a id="ADXDB6389"></a><a id="ADXDB6390"></a><a id="ADXDB6291"></a><div class="props_rev_3"><a id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" name="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5"></a><h3 id="ADJSN-GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" class="sect3"><span class="enumeration_section">18.4 </span>Using JSON_TABLE with JSON Arrays
               </h3>
               <div>
                  <p>A JSON value can be an array or can include one or more arrays, nested to
    any number of levels inside other JSON arrays or objects. You can use a
      <code class="codeph">json_table</code>
                     <code class="codeph">NESTED</code> path clause to project specific elements of an array.
                  </p>
                  <div class="section">
                     <p><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 18-5</a> projects the requestor and associated phone numbers from
        the JSON data in column <code class="codeph">po_document</code>. The entire JSON array
          <code class="codeph">Phone</code> is projected as a column of JSON data, <code class="codeph">ph_arr</code>. To
        format this JSON data as a <code class="codeph">VARCHAR2</code> column, the keywords <code class="codeph">FORMAT
          JSON</code> are needed.
                     </p>
                     <p>What if you wanted to project the individual
          <span class="italic">elements</span> of JSON array <code class="codeph">Phone</code> and not the array as a whole? <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">Example 18-6</a> shows one way to do this, which you can use if the array
        elements are the only data you need to project.
                     </p>
                     <p>If you want to project
        both the requestor and the corresponding phone data then the row path expression of <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">Example 18-6</a> (<code class="codeph">$.Phone[*]</code>) is not appropriate: it
        targets only the (phone object) elements of array <code class="codeph">Phone</code>. 
                     </p>
                     <p><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 18-7</a> shows one way to target both: use a <span class="italic">row path
          expression</span> that targets both the name and the entire phones array, and use <span class="italic">column
          path expressions</span> that target fields <code class="codeph">type</code> and <code class="codeph">number</code>
        of individual phone objects. 
                     </p>
                     <p>In <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 18-7</a> as in <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 18-5</a>, keywords <code class="codeph">FORMAT JSON</code> are needed because
        the resulting <code class="codeph">VARCHAR2</code> columns contain JSON data, namely arrays of phone
        types or phone numbers, with one array element for each phone. In addition, unlike the case
        for <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">Example 18-5</a>, a wrapper clause is needed for column
          <code class="codeph">phone_type</code> and column <code class="codeph">phone_num</code>, because array
          <code class="codeph">Phone</code> contains multiple objects with fields <code class="codeph">type</code> and
          <code class="codeph">number</code>.
                     </p>
                     <p>Sometimes you might not want the effect of
          <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">Example 18-7</a>. For example, you might want a column that contains a
        single phone number (one row per number), rather than one that contains a JSON array of
        phone numbers (one row for all numbers for a given purchase order). 
                     </p>
                     <p>To
        obtain that result, you need to tell <code class="codeph">json_table</code> to project the array
        elements, by using a <code class="codeph">json_table</code>
                        <span class="bold"><code class="codeph">NESTED</code></span> path clause for the array. A <code class="codeph">NESTED</code> path
        clause acts, in effect, as an additional row source (row pattern). <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 18-8</a> illustrates this.
                     </p>
                     <p>You can use any number
        of <code class="codeph">NESTED</code> keywords in a given <code class="codeph">json_table</code> invocation.
                     </p>
                     <p>In <a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">Example 18-8</a> the outer <code class="codeph">COLUMNS</code> clause is the parent of
        the nested (inner) <code class="codeph">COLUMNS</code> clause. The virtual tables defined are joined
        using an outer join, with the table defined by the parent clause being the outer table in
        the join.
                     </p>
                     <p>(If there were a second columns clause nested directly under
        the same parent, the two nested clauses would be sibling <code class="codeph">COLUMNS</code>
        clauses.)
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">
                     <p class="titleinexample">Example 18-5 Projecting an
        Entire JSON Array as JSON
      Data</p><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, '$'
         COLUMNS (requestor VARCHAR2(32 CHAR) PATH '$.Requestor',
                  ph_arr    VARCHAR2(100 CHAR) <span class="bold">FORMAT JSON</span>
                            PATH '$.ShippingInstructions.<span class="bold">Phone</span>')) AS "JT";
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">
                     <p class="titleinexample">Example 18-6 Projecting Elements
        of a JSON
      Array</p><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, '$.ShippingInstructions.<span class="bold">Phone[*]</span>'
         COLUMNS (phone_type VARCHAR2(10) PATH '$.type',
                  phone_num  VARCHAR2(20) PATH '$.number')) AS "JT";

PHONE_TYPE     PHONE_NUM
----------     ---------
Office         909-555-7307
Mobile         415-555-1234
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">
                     <p class="titleinexample">Example 18-7 Projecting Elements
        of a JSON Array Plus Other
      Data</p><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder,
       json_table(po_document, '$'
         COLUMNS (
           requestor  VARCHAR2(32 CHAR) PATH '$.Requestor',
           phone_type VARCHAR2(50 CHAR) <span class="bold">FORMAT JSON WITH WRAPPER</span>
                      PATH '$.ShippingInstructions.<span class="bold">Phone[*]</span>.type',
           phone_num  VARCHAR2(50 CHAR) <span class="bold">FORMAT JSON WITH WRAPPER</span>
                      PATH '$.ShippingInstructions.<span class="bold">Phone[*]</span>.number')) AS "JT";

REQUESTOR    PHONE_TYPE            PHONE_NUM
---------    ----------            ---------
Alexis Bull  ["Office", "Mobile"]  ["909-555-7307", "415-555-1234"]
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">
                     <p class="titleinexample">Example 18-8 JSON_TABLE:
        Projecting Array Elements Using NESTED</p>
                     <p>This example shows two
        equivalent queries that project array elements. The first query uses the simple,
        dot-notation syntax for the expressions that target the row and column data. The second uses
        the full syntax.</p>
                     <p>Except for column <code class="codeph">number</code>, whose SQL
        identifier is quoted (<code class="codeph">"number"</code>), the SQL column names are, in effect,
        uppercase. (Column <code class="codeph">number</code> is lowercase.)
                     </p>
                     <p>In the first
        query the column names are written exactly the same as the field names that are targeted,
        including with respect to letter case. Regardless of whether they are quoted, they are
        interpreted case-sensitively for purposes of establishing the proper path.</p>
                     <p>The second query has:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Separate arguments of a JSON column-expression and a SQL/JSON
            row path-expression</p>
                        </li>
                        <li>
                           <p>Explicit column data types of
            <code class="codeph">VARCHAR2(4000)</code></p>
                        </li>
                        <li>
                           <p>Explicit <code class="codeph">PATH</code> clauses with SQL/JSON column
            path expressions, to target the object fields that are projected
                           </p>
                        </li>
                     </ul><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder po,
       <span class="bold">json_table</span>(po.po_document
         COLUMNS (Requestor,
                  <span class="bold">NESTED</span> ShippingInstructions.<span class="bold">Phone[*]</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COLUMNS (type, <span class="bold">"</span>number<span class="bold">"</span>))) AS "JT";</code></pre><pre class="pre codeblock"><code>SELECT jt.*
  FROM j_purchaseorder po,
       <span class="bold">json_table</span>(po.po_document, '$'
         COLUMNS (Requestor VARCHAR2(4000) PATH '$.Requestor',
                  <span class="bold">NESTED</span>                   PATH '$.ShippingInstructions.<span class="bold">Phone[*]</span>'
                    COLUMNS (type     VARCHAR2(4000) PATH '$.type',
                             <span class="bold">"</span>number<span class="bold">"</span> VARCHAR2(4000) PATH '$.number'))) AS "JT";
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" title="To improve query performance you can create a view over JSON data that you project to columns using SQL/JSON function json_table. To further improve query performance you can create a materialized view and place the JSON data in memory.">Creating a View Over JSON Data Using JSON_TABLE</a></li>
                        <li><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" name="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5"></a><h3 id="ADJSN-GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" class="sect3"><span class="enumeration_section">18.5 </span>Creating a View Over JSON Data Using JSON_TABLE
               </h3>
               <div>
                  <p>To improve query performance you can create a view over JSON data that you project to columns using SQL/JSON function <code class="codeph">json_table</code>. To further improve query performance you can create a <span class="italic">materialized view</span> and place the JSON data <span class="italic">in memory</span>.
                  </p>
                  <div class="section">
                     <p><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">Example 18-9</a> defines a view over JSON data. It uses a <code class="codeph">NESTED</code> path clause to project the elements of array <code class="codeph">LineItems</code>.
                     </p>
                     <p><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">Example 18-10</a> defines a materialized view that has the same data and structure as <a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">Example 18-9</a>. You cannot update such a materialized view directly; you must treat it as a read-only view and update it indirectly by updating the base table. An error is raised if you try to modify the view directly. If the materialized view is created using keywords <code class="codeph">REFRESH</code> and <code class="codeph">ON STATEMENT</code> then the view is updated automatically whenever you update the base table.
                     </p>
                     <p>The only differences between <a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">Example 18-9</a> and <a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">Example 18-10</a> are: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The use of keyword <code class="codeph">MATERIALIZED</code>.
                           </p>
                        </li>
                        <li>
                           <p>The use of <code class="codeph">BUILD IMMEDIATE</code>.
                           </p>
                        </li>
                        <li>
                           <p>The use of <code class="codeph">REFRESH FAST ON STATEMENT WITH PRIMARY KEY</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The use of <code class="codeph">REFRESH FAST</code> means that the materialized view will be refreshed incrementally. For this to occur, you must use either <code class="codeph">WITH PRIMARY KEY</code> or <code class="codeph">WITH ROWID</code> (if there is no primary key). Oracle recommends that you specify a primary key for a table that has a JSON column and that you use <code class="codeph">WITH PRIMARY KEY</code> when creating a materialized view based on it.
                     </p>
                     <p>You could use <code class="codeph">ON COMMIT</code> in place of <code class="codeph">ON STATEMENT</code> for the view creation. The former synchronizes the view with the base table only when your table-updating transaction is committed. Until then the table changes are not reflected in the view. If you use <code class="codeph">ON STATEMENT</code> then the view is immediately synchronized after each DML statement. This also means that a view created using <code class="codeph">ON STATEMENT</code> reflects any rollbacks that you might perform. (A subsequent <code class="codeph">COMMIT</code> statement ends the transaction, preventing a rollback.)
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__GUID-E21D6F51-8A85-4198-91B4-E7C5B5D4D5DE">
                        <p class="notep1">See Also:</p>
                        <p><a href="../dwhsg/refreshing-materialized-views.html#DWHSG-GUID-64068234-BDB0-4C12-AE70-75571046A586" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">
                     <p class="titleinexample">Example 18-9 Creating a View Over JSON Data</p><pre class="pre codeblock"><code>CREATE OR REPLACE VIEW j_purchaseorder_detail_view
  AS SELECT jt.*
       FROM j_purchaseorder po,
            json_table(po.po_document, '$'
              COLUMNS (
                po_number        NUMBER(10)         PATH '$.PONumber',
                reference        VARCHAR2(30 CHAR)  PATH '$.Reference',
                requestor        VARCHAR2(128 CHAR) PATH '$.Requestor',
                userid           VARCHAR2(10 CHAR)  PATH '$.User',
                costcenter       VARCHAR2(16)       PATH '$.CostCenter',
                ship_to_name     VARCHAR2(20 CHAR)
                                 PATH '$.ShippingInstructions.name',
                ship_to_street   VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.street',
                ship_to_city     VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.city',
                ship_to_county   VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.county',
                ship_to_postcode VARCHAR2(10 CHAR)
                                 PATH '$.ShippingInstructions.Address.postcode',
                ship_to_state    VARCHAR2(2 CHAR)
                                 PATH '$.ShippingInstructions.Address.state',
                ship_to_zip      VARCHAR2(8 CHAR)
                                 PATH '$.ShippingInstructions.Address.zipCode',
                ship_to_country  VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.country',
                ship_to_phone    VARCHAR2(24 CHAR)
                                 PATH '$.ShippingInstructions.Phone[0].number',
                NESTED PATH '$.LineItems[*]'
                  COLUMNS (
                    itemno      NUMBER(38)         PATH '$.ItemNumber', 
                    description VARCHAR2(256 CHAR) PATH '$.Part.Description', 
                    upc_code    VARCHAR2(14 CHAR)  PATH '$.Part.UPCCode', 
                    quantity    NUMBER(12,4)       PATH '$.Quantity', 
                    unitprice   NUMBER(14,2)       PATH '$.Part.UnitPrice'))) jt;
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">
                     <p class="titleinexample">Example 18-10 Creating a Materialized View Over JSON Data</p><pre class="pre codeblock"><code>CREATE OR REPLACE <span class="bold">MATERIALIZED</span> VIEW j_purchaseorder_materialized_view
  <span class="bold">BUILD IMMEDIATE</span>
  <span class="bold">REFRESH FAST ON STATEMENT WITH PRIMARY KEY</span>
  AS SELECT jt.*
       FROM j_purchaseorder po,
            json_table(po.po_document, '$'
              COLUMNS (
                po_number        NUMBER(10)         PATH '$.PONumber',
                reference        VARCHAR2(30 CHAR)  PATH '$.Reference',
                requestor        VARCHAR2(128 CHAR) PATH '$.Requestor',
                userid           VARCHAR2(10 CHAR)  PATH '$.User',
                costcenter       VARCHAR2(16)       PATH '$.CostCenter',
                ship_to_name     VARCHAR2(20 CHAR)
                                 PATH '$.ShippingInstructions.name',
                ship_to_street   VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.street',
                ship_to_city     VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.city',
                ship_to_county   VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.county',
                ship_to_postcode VARCHAR2(10 CHAR)
                                 PATH '$.ShippingInstructions.Address.postcode',
                ship_to_state    VARCHAR2(2 CHAR)
                                 PATH '$.ShippingInstructions.Address.state',
                ship_to_zip      VARCHAR2(8 CHAR)
                                 PATH '$.ShippingInstructions.Address.zipCode',
                ship_to_country  VARCHAR2(32 CHAR)
                                 PATH '$.ShippingInstructions.Address.country',
                ship_to_phone    VARCHAR2(24 CHAR)
                                 PATH '$.ShippingInstructions.Phone[0].number',
                NESTED PATH '$.LineItems[*]'
                  COLUMNS (
                    itemno      NUMBER(38)         PATH '$.ItemNumber', 
                    description VARCHAR2(256 CHAR) PATH '$.Part.Description', 
                    upc_code    VARCHAR2(14 CHAR)  PATH '$.Part.UPCCode', 
                    quantity    NUMBER(12,4)       PATH '$.Quantity', 
                    unitprice   NUMBER(14,2)       PATH '$.Part.UnitPrice'))) jt;
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" title="A JSON value can be an array or can include one or more arrays, nested to any number of levels inside other JSON arrays or objects. You can use a json_table NESTED path clause to project specific elements of an array.">Using JSON_TABLE with JSON Arrays</a></li>
                        <li><a href="using-GeoJSON-geographic-data.html#GUID-2AD827B4-871E-4652-87F3-AC33FE7839AE" title="GeoJSON objects are JSON objects that represent geographic data. Examples are provided of creating GeoJSON data, indexing it, and querying it.">Using GeoJSON Geographic Data</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>