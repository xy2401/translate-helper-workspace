<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Data Warehousing Physical Design</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="data-warehouse-logical-design.html" title="Previous" type="text/html">
      <link rel="next" href="data-warehouse-optimizations-techniques.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="data-warehouse-logical-design.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="data-warehouse-optimizations-techniques.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-dw-fundamentals.html" property="item" typeof="WebPage"><span property="name">Data Warehouse - Fundamentals </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Data Warehousing Physical Design </li>
            </ol>
            <a id="GUID-442BF782-BE78-4D7A-A2D0-A9F4FA2B7ACD" name="GUID-442BF782-BE78-4D7A-A2D0-A9F4FA2B7ACD"></a>
            
            <h2 id="DWHSG-GUID-442BF782-BE78-4D7A-A2D0-A9F4FA2B7ACD" class="sect2"><span class="enumeration_chapter">3 </span>Data Warehousing Physical Design 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the physical design of a data warehousing environment, and includes the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="data-warehouse-physical-design.html#GUID-8DA56C59-F42E-4553-A9DF-5FFA3DADE2CE">Moving from Logical to Physical Design</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-physical-design.html#GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7" title="To convert your logical design into a physical design, you must create some or all of the following structures: tablespaces, tables, partitions on tables or index-organized tables, indexes including partitioned indexes, views, integrity constraints, materialized views, and dimensions.">About Physical Design</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG9259"></a><div class="props_rev_3"><a id="GUID-8DA56C59-F42E-4553-A9DF-5FFA3DADE2CE" name="GUID-8DA56C59-F42E-4553-A9DF-5FFA3DADE2CE"></a><h3 id="DWHSG-GUID-8DA56C59-F42E-4553-A9DF-5FFA3DADE2CE" class="sect3"><span class="enumeration_section">3.1 </span>Moving from Logical to Physical Design
               </h3>
               <div>
                  <p>Logical design is what <a id="d9077e55" class="indexterm-anchor"></a><a id="d9077e57" class="indexterm-anchor"></a>you draw with a pen and paper or design with a tool such as Oracle Designer before building your data warehouse. Physical design is the creation of the database with SQL statements.
                  </p>
                  <p>During the physical <a id="d9077e64" class="indexterm-anchor"></a><a id="d9077e66" class="indexterm-anchor"></a><a id="d9077e70" class="indexterm-anchor"></a>design process, you convert the data gathered during the logical design phase into a description of the physical database structure. Physical design decisions are mainly driven by query performance and database maintenance aspects. For example, choosing a partitioning strategy that meets common query requirements enables Oracle Database to take advantage of partition pruning, a way of narrowing a search before performing it.
                  </p>
                  <div class="infoboxnotealso" id="GUID-8DA56C59-F42E-4553-A9DF-5FFA3DADE2CE__GUID-15EC7C49-ACC2-47B9-A382-8E1899EE43FB">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../vldbg/partition-concepts.html#VLDBG002" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for further information regarding partitioning
                           </p>
                        </li>
                        <li>
                           <p><a href="../cncpt/physical-storage-structures.html#CNCPT-GUID-FFA872E1-7F63-4DC5-8A35-F21394AB4595" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for further conceptual material regarding design matters.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG9261"></a><a id="DWHSG9260"></a><div class="props_rev_3"><a id="GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7" name="GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7"></a><h3 id="DWHSG-GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7" class="sect3"><span class="enumeration_section">3.2 </span>About Physical Design
               </h3>
               <div>
                  <p>During the logical design phase, you defined a model for your data warehouse consisting of entities, attributes, and relationships. The entities are linked together using relationships. Attributes are used to describe the entities. Th<a id="d9077e116" class="indexterm-anchor"></a>e unique identifier (UID) distinguishes between one instance of an entity and another.
                  </p>
                  <p><a href="data-warehouse-physical-design.html#GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7__CHDDHAJD">Figure 3-1</a> illustrates a graphical way of distinguishing between logical and physical designs.
                  </p>
                  <div class="figure" id="GUID-A04E2DCB-B5E4-43CD-8D24-37AD690667E7__CHDDHAJD">
                     <p class="titleinfigure">Figure 3-1 Logical Design Compared with Physical Design</p><img src="img/dwhsg006.gif" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" longdesc="img_text/dwhsg006.html"><br><a href="img_text/dwhsg006.html">Description of "Figure 3-1 Logical Design Compared with Physical Design"</a></div>
                  <!-- class="figure" -->
                  <p>During the physical design process, you translate the expected schemas into actual database structures. At this time, you must map:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Entities to tables</p>
                     </li>
                     <li>
                        <p>Relationships to foreign key constraints</p>
                     </li>
                     <li>
                        <p>Attributes to columns</p>
                     </li>
                     <li>
                        <p>Primary unique identifiers to primary key constraints</p>
                     </li>
                     <li>
                        <p>Unique identifiers to unique key constraints</p>
                     </li>
                  </ul>
               </div><a id="DWHSG9262"></a><div class="props_rev_3"><a id="GUID-74DD4AF7-1E40-48A4-935D-A2D688E0FC3A" name="GUID-74DD4AF7-1E40-48A4-935D-A2D688E0FC3A"></a><h4 id="DWHSG-GUID-74DD4AF7-1E40-48A4-935D-A2D688E0FC3A" class="sect4"><span class="enumeration_section">3.2.1 </span>Physical Design Structures
                  </h4>
                  <p>To convert your logical design into a physical design, you must create some or all of the following structures: tablespaces, tables, partitions on tables or index-organized tables, indexes including partitioned indexes, views, integrity constraints, materialized views, and dimensions.</p><a id="DWHSG9263"></a><div class="props_rev_3"><a id="GUID-DCA1641F-B4D0-4D6C-AC7B-F9CFBE795390" name="GUID-DCA1641F-B4D0-4D6C-AC7B-F9CFBE795390"></a><h5 id="DWHSG-GUID-DCA1641F-B4D0-4D6C-AC7B-F9CFBE795390" class="sect5"><span class="enumeration_section">3.2.1.1 </span>About Tablespaces in Data Warehouses
                     </h5>
                     <div>
                        <p>A tablespace consists of one or more datafiles, which are physical structures within the operating system you are using. A datafile is associated with only one tablespace. From a design perspective, tablespaces are containers for physical design structures.</p>
                        <p>Tablespaces need to be separated by differences. For example, tables should be separated from their indexes and small tables should be separated from large tables. Tablespaces should also represent logical business units if possible. Because a tablespace is the coarsest granularity for backup and recovery or the transportable tablespaces mechanism, the logical business design affects availability and maintenance operations.</p>
                        <p>You can now use <a id="d9077e200" class="indexterm-anchor"></a><a id="d9077e202" class="indexterm-anchor"></a>ultralarge data files, a significant improvement in very large databases.
                        </p>
                     </div>
                  </div><a id="DWHSG9264"></a><div class="props_rev_3"><a id="GUID-9CCE68CF-DECB-4F69-80A3-AD0A666C0650" name="GUID-9CCE68CF-DECB-4F69-80A3-AD0A666C0650"></a><h5 id="DWHSG-GUID-9CCE68CF-DECB-4F69-80A3-AD0A666C0650" class="sect5"><span class="enumeration_section">3.2.1.2 </span>About Partitioning in Data Warehouses
                     </h5>
                     <div>
                        <p><a id="d9077e228" class="indexterm-anchor"></a><a id="d9077e230" class="indexterm-anchor"></a>Oracle partitioning is an extremely important functionality for data warehousing, improving manageability, performance and availability. This section presents the key concepts and benefits of partitioning noting special value for data warehousing.
                        </p>
                        <p>Partitioning allows tables, indexes or index-organized tables to be subdivided into smaller pieces. Each piece of the database object is called a partition. Each partition has its own name, and may optionally have its own storage characteristics. From the perspective of a database administrator, a partitioned object has multiple pieces that can be managed either collectively or individually. This gives the administrator considerable flexibility in managing a partitioned object. However, from the perspective of the user, a partitioned table is identical to a non-partitioned table; no modifications are necessary when accessing a partitioned table using SQL DML commands.</p>
                        <p>Database objects - tables, indexes, and index-organized tables - are partitioned using a partitioning key, a set of columns that determine in which partition a given row will reside. For example a sales table partitioned on sales date, using a monthly partitioning strategy; the table appears to any application as a single, normal table. However, the DBA can manage and store each monthly partition individually, potentially using different storage tiers, applying table compression to the older data, or store complete ranges of older data in read only tablespaces.</p>
                     </div><a id="DWHSG9265"></a><div class="props_rev_3"><a id="GUID-2BF051B8-E901-48AF-B891-58A7AB22F90E" name="GUID-2BF051B8-E901-48AF-B891-58A7AB22F90E"></a><h6 id="DWHSG-GUID-2BF051B8-E901-48AF-B891-58A7AB22F90E" class="sect6"><span class="enumeration_section">3.2.1.2.1 </span>Basic Partitioning Strategies Used in Data Warehouses
                        </h6>
                        <div>
                           <p>Oracle partitioning offers three fundamental data distribution methods that control how the data is actually placed into the various individual partitions, namely:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Range</p>
                                 <p>The data is distributed based on a range of values of the partitioning key (for a date column as the partitioning key, the 'January-2012' partition contains rows with the partitioning key values between '01-JAN-2012' and '31-JAN-2012'). The data distribution is a continuum without any holes and the lower boundary of a range is automatically defined by the upper boundary of the preceding range.</p>
                              </li>
                              <li>
                                 <p>List</p>
                                 <p>The data distribution is defined by a list of values of the partitioning key (for a region column as the partitioning key, the <code class="codeph">North_America</code> partition may contain values <code class="codeph">Canada</code>, <code class="codeph">USA</code>, and <code class="codeph">Mexico</code>). A special <code class="codeph">DEFAULT</code> partition can be defined to catch all values for a partition key that are not explicitly defined by any of the lists.
                                 </p>
                              </li>
                              <li>
                                 <p>Hash</p>
                                 <p>A hash algorithm is applied to the partitioning key to determine the partition for a given row. Unlike the other two data distribution methods, hash does not provide any logical mapping between the data and any partition.</p>
                              </li>
                           </ul>
                           <p>Along with these fundamental approaches Oracle Database provides several more:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Interval Partitioning</p>
                                 <p>An extension to range partitioning that enhances manageability. Partitions are defined by an interval, providing equi-width ranges. With the exception of the first partition all partitions are automatically created on-demand when matching data arrives.</p>
                              </li>
                              <li>
                                 <p>Partitioning by Reference</p>
                                 <p>Partitioning for a child table is inherited from the parent table through a primary key - foreign key relationship. Partition maintenance is simplified and partition-wise joins enabled.</p>
                              </li>
                              <li>
                                 <p>Virtual column based Partitioning</p>
                                 <p>Defined by one of the above mentioned partition techniques and the partitioning key is based on a virtual column. Virtual columns are not stored on disk and only exist as metadata. This approach enables a more flexible and comprehensive match of the business requirements.</p>
                              </li>
                           </ul>
                           <p>Using the above-mentioned data distribution methods, a table can be partitioned either as single or composite partitioned table:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Single (one-level) Partitioning</p>
                                 <p>A table is defined by specifying one of the data distribution methodologies, using one or more columns as the partitioning key. For example consider a table with a number column as the partitioning key and two partitions <code class="codeph">less_than_five_hundred</code> and <code class="codeph">less_than_thousand</code>, the <code class="codeph">less_than_thousand</code> partition contains rows where the following condition is true: <code class="codeph">500 &lt;= Partitioning key &lt;1000</code>.
                                 </p>
                                 <p>You can specify range, list, and hash partitioned tables.</p>
                              </li>
                              <li>
                                 <p>Composite Partitioning</p>
                              </li>
                              <li>
                                 <p>Combinations of two data distribution methods are used to define a composite partitioned table. First, the table is partitioned by data distribution method one and then each partition is further subdivided into subpartitions using a second data distribution method. All sub-partitions for a given partition together represent a logical subset of the data. For example, a range-hash composite partitioned table is first range-partitioned, and then each individual range-partition is further subpartitioned using the hash partitioning technique.</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-2BF051B8-E901-48AF-B891-58A7AB22F90E__GUID-3D5ED214-C087-496A-BFBE-7BDE1EB7AFB7">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../vldbg/partition-availability.html#VLDBG004" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for more information about Hybrid Columnar Compression
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="DWHSG9267"></a><div class="props_rev_3"><a id="GUID-7F428935-74E9-4D6B-ACBD-8F66D142CCE9" name="GUID-7F428935-74E9-4D6B-ACBD-8F66D142CCE9"></a><h5 id="DWHSG-GUID-7F428935-74E9-4D6B-ACBD-8F66D142CCE9" class="sect5"><span class="enumeration_section">3.2.1.3 </span>Index Partitioning in Data Warehouses
                     </h5>
                     <div>
                        <p>Irrespective of the chosen index partitioning strategy, an index is either coupled or uncoupled with the partitioning strategy of the underlying table. The appropriate index partitioning strategy is chosen based on the business requirements, making partitioning well suited to support any kind of application. Oracle Database 12<span class="italic">c</span> differentiates between three types of partitioned indexes.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Local Indexes</p>
                              <p>A local index is an index on a partitioned table that is coupled with the underlying partitioned table, 'inheriting' the partitioning strategy from the table. Consequently, each partition of a local index corresponds to one - and only one - partition of the underlying table. The coupling enables optimized partition maintenance; for example, when a table partition is dropped, Oracle Database simply has to drop the corresponding index partition as well. No costly index maintenance is required. Local indexes are most common in data warehousing environments.</p>
                           </li>
                           <li>
                              <p>Global Partitioned Indexes</p>
                              <p>A global partitioned index is an index on a partitioned or nonpartitioned table that is partitioned using a different partitioning-key or partitioning strategy than the table. Global-partitioned indexes can be partitioned using range or hash partitioning and are uncoupled from the underlying table. For example, a table could be range-partitioned by month and have twelve partitions, while an index on that table could be hash-partitioned using a different partitioning key and have a different number of partitions. Global partitioned indexes are more common for OLTP than for data warehousing environments.</p>
                           </li>
                           <li>
                              <p>Global Non-Partitioned Indexes</p>
                              <p>A global non-partitioned index is essentially identical to an index on a non-partitioned table. The index structure is not partitioned and uncoupled from the underlying table. In data warehousing environments, the most common usage of global non-partitioned indexes is to enforce primary key constraints.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9268"></a><div class="props_rev_3"><a id="GUID-D93AC0FB-B992-4EC7-9DE4-D78AD95EA7E7" name="GUID-D93AC0FB-B992-4EC7-9DE4-D78AD95EA7E7"></a><h5 id="DWHSG-GUID-D93AC0FB-B992-4EC7-9DE4-D78AD95EA7E7" class="sect5"><span class="enumeration_section">3.2.1.4 </span>About Partitioning for Manageability
                     </h5>
                     <div>
                        <p>A typical usage of partitioning for manageability is to support a 'rolling window' load process in a data warehouse. Suppose that a DBA loads new data into a table on a daily basis. That table could be range partitioned so that each partition contains one day of data. The load process is simply the addition of a new partition. Adding a single partition is much more efficient than modifying the entire table, because the DBA does not need to modify any other partitions. Another advantage of using partitioning is when it is time to remove data. In this situation, an entire partition can be dropped, which is very efficient and fast, compared to deleting each row individually.</p>
                     </div>
                  </div><a id="DWHSG9269"></a><div class="props_rev_3"><a id="GUID-5DEDD044-0B49-4C2D-8D29-395122D2E160" name="GUID-5DEDD044-0B49-4C2D-8D29-395122D2E160"></a><h5 id="DWHSG-GUID-5DEDD044-0B49-4C2D-8D29-395122D2E160" class="sect5"><span class="enumeration_section">3.2.1.5 </span>About Partitioning for Performance
                     </h5>
                     <div>
                        <p>By limiting the amount of data to be examined or operated on, partitioning provides a number of performance benefits. Two features specially worth noting are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Partitioning pruning: Partitioning pruning is the simplest and also the most substantial means to improve performance using partitioning. Partition pruning can often improve query performance by several orders of magnitude. For example, suppose an application contains an <code class="codeph">ORDERS</code> table containing an historical record of orders, and that this table has been partitioned by day. A query requesting orders for a single week would only access seven partitions of the <code class="codeph">ORDERS</code> table. If the table had two years of historical data, this query would access seven partitions instead of 730 partitions. This query could potentially execute 100x faster simply because of partition pruning. Partition pruning works with all of Oracle's other performance features. Oracle Database will utilize partition pruning in conjunction with any indexing technique, join technique, or parallel access method.
                              </p>
                           </li>
                           <li>
                              <p>Partition-wise joins: Partitioning can also improve the performance of multi-table joins, by using a technique known as partition-wise joins. Partition-wise joins can be applied when two tables are being joined together, and at least one of these tables is partitioned on the join key. Partition-wise joins break a large join into smaller joins of 'identical' data sets for the joined tables. 'Identical' here is defined as covering exactly the same set of partitioning key values on both sides of the join, thus ensuring that only a join of these 'identical' data sets will produce a result and that other data sets do not have to be considered. Oracle Database is using either the fact of already (physical) equi-partitioned tables for the join or is transparently redistributing ("repartitioning") one table at runtime to create equipartitioned data sets matching the partitioning of the other table, completing the overall join in less time. This offers significant performance benefits both for serial and parallel execution.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9270"></a><div class="props_rev_3"><a id="GUID-8B52DF7A-566B-4ADD-A26C-4601D992901F" name="GUID-8B52DF7A-566B-4ADD-A26C-4601D992901F"></a><h5 id="DWHSG-GUID-8B52DF7A-566B-4ADD-A26C-4601D992901F" class="sect5"><span class="enumeration_section">3.2.1.6 </span>About Partitioning for Availability
                     </h5>
                     <div>
                        <p>Partitioned database objects provide partition independence. This characteristic of partition independence can be an important part of a high-availability strategy. For example, if one partition of a partitioned table is unavailable, all of the other partitions of the table remain online and available. The application can continue to execute queries and transactions against this partitioned table, and these database operations will run successfully if they do not need to access the unavailable partition. The database administrator can specify that each partition be stored in a separate tablespace; this would allow the administrator to do backup and recovery operations on an individual partition or sets of partitions (by virtue of the partition-to-tablespace mapping), independent of the other partitions in the table. Therefore in the event of a disaster, the database could be recovered with just the partitions comprising the active data, and then the inactive data in the other partitions could be recovered at a convenient time, thus decreasing the system down-time.In light of the manageability, performance and availability benefits, it should be part of every data warehouse.</p>
                        <div class="infoboxnotealso" id="GUID-8B52DF7A-566B-4ADD-A26C-4601D992901F__GUID-2ED90893-C73B-47A6-BCF2-77B1A8C2F0FD">
                           <p class="notep1">See Also:</p>
                           <p><a href="../vldbg/partition-availability.html#VLDBG004" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9271"></a><div class="props_rev_3"><a id="GUID-17362D0D-E1BE-4B1E-8A8B-8AEACF300580" name="GUID-17362D0D-E1BE-4B1E-8A8B-8AEACF300580"></a><h4 id="DWHSG-GUID-17362D0D-E1BE-4B1E-8A8B-8AEACF300580" class="sect4"><span class="enumeration_section">3.2.2 </span>About Views in Data Warehouses
                  </h4>
                  <div>
                     <p>A view is a tailored presentation of the data contained in one or more tables or other views. A view takes the output of a query and treats it as a table. Views do not require any space in the database.</p>
                     <div class="infoboxnotealso" id="GUID-17362D0D-E1BE-4B1E-8A8B-8AEACF300580__GUID-3A0E6A77-08A8-4C3E-8253-1C3DF14B5CAB">
                        <p class="notep1">See Also:</p>
                        <p><a href="../cncpt/partitions-views-and-other-schema-objects.html#CNCPT311" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG9272"></a><div class="props_rev_3"><a id="GUID-897B250D-EEAB-4D77-8972-58C1368E4037" name="GUID-897B250D-EEAB-4D77-8972-58C1368E4037"></a><h4 id="DWHSG-GUID-897B250D-EEAB-4D77-8972-58C1368E4037" class="sect4"><span class="enumeration_section">3.2.3 </span>About Integrity Constraints in Data Warehouses
                  </h4>
                  <div>
                     <p>Integrity constraints are used to enforce business rules associated with your database and to prevent having invalid information in the tables. Integrity constraints in data warehousing differ from constraints in OLTP environments. In OLTP environments, they primarily prevent the insertion of invalid data into a record, which is not a big problem in data warehousing environments because accuracy has already been guaranteed. In data warehousing environments, constraints are only used for query rewrite. <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints are particularly common in data warehouses. Under some specific circumstances, constraints need space in the database. These constraints are in the form of the underlying unique index.
                     </p>
                     <div class="infoboxnotealso" id="GUID-897B250D-EEAB-4D77-8972-58C1368E4037__GUID-C50FD89B-A07D-4050-90B5-ED25CD10A0FA">
                        <p class="notep1">See Also:</p>
                        <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT88816" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG9273"></a><div class="props_rev_3"><a id="GUID-57D0E959-C246-42E7-83DD-9159945773D2" name="GUID-57D0E959-C246-42E7-83DD-9159945773D2"></a><h4 id="DWHSG-GUID-57D0E959-C246-42E7-83DD-9159945773D2" class="sect4"><span class="enumeration_section">3.2.4 </span>About Indexes and Partitioned Indexes in Data Warehouses
                  </h4>
                  <div>
                     <p>Indexes are optional structures associated with tables or clusters. In addition to the classical B-tree indexes, bitmap indexes are very common in data warehousing environments. Bitmap indexes are optimized index structures for set-oriented operations. Additionally, they are necessary for some optimized data access methods such as star transformations.</p>
                     <p>Indexes are just like tables in that you can partition them, although the partitioning strategy is not dependent upon the table structure. Partitioning indexes makes it easier to manage the data warehouse during refresh and improves query performance.</p>
                     <div class="infoboxnotealso" id="GUID-57D0E959-C246-42E7-83DD-9159945773D2__GUID-A5AB03C7-B64E-47C4-ABDA-1CB90421BAD4">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="data-warehouse-physical-design.html#GUID-7F428935-74E9-4D6B-ACBD-8F66D142CCE9">Index Partitioning in Data Warehouses</a></p>
                           </li>
                           <li>
                              <p><a href="../cncpt/indexes-and-index-organized-tables.html#CNCPT721" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG9274"></a><div class="props_rev_3"><a id="GUID-D9F22787-BF66-41A7-8A42-B2DF7A5B1EBF" name="GUID-D9F22787-BF66-41A7-8A42-B2DF7A5B1EBF"></a><h4 id="DWHSG-GUID-D9F22787-BF66-41A7-8A42-B2DF7A5B1EBF" class="sect4"><span class="enumeration_section">3.2.5 </span>About Materialized Views in Data Warehouses
                  </h4>
                  <div>
                     <p>Materialized views are query results that have been stored in advance so long-running calculations are not necessary when you actually execute your SQL statements. From a physical design point of view, materialized views resemble tables or partitioned tables and behave like indexes in that they are used transparently and improve performance.</p>
                     <div class="infoboxnotealso" id="GUID-D9F22787-BF66-41A7-8A42-B2DF7A5B1EBF__GUID-8F9D3015-B511-423C-B618-F848A5E93D7A">
                        <p class="notep1">See Also:</p>
                        <p><a href="basic-materialized-views.html#GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.A materialized view can be created with the CREATE MATERIALIZED VIEW statement or using Enterprise Manager.Use the CREATE MATERIALIZED VIEW statement to create a materialized view that is based on a hybrid partitioned table.A materialized view based on approximate queries uses SQL functions that return approximate functions in its defining query.Materialized views based on COUNT(DISTINCT) functions can provide enhanced performance by using bitmap-based operations on integer columns.">Basic Materialized Views</a> 
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG9275"></a><div class="props_rev_3"><a id="GUID-79542EF2-E102-46CA-A1F3-AF63E9DE9A02" name="GUID-79542EF2-E102-46CA-A1F3-AF63E9DE9A02"></a><h4 id="DWHSG-GUID-79542EF2-E102-46CA-A1F3-AF63E9DE9A02" class="sect4"><span class="enumeration_section">3.2.6 </span>About Dimensions in Data Warehouses
                  </h4>
                  <div>
                     <p><a id="d9077e665" class="indexterm-anchor"></a>A dimension is a structure, often composed of one or more hierarchies, that categorizes data. Dimensional attributes help to describe the dimensional value. They are normally descriptive, textual values. Several distinct dimensions, combined with facts, enable you to answer business questions. Commonly used dimensions are customers, products, and time.
                     </p>
                     <p>A dimension schema object defines hierarchical relationships between columns or column sets. A hierarchical relationship is a functional dependency from one level of a hierarchy to the next one. A dimension object is a container of logical relationships and does not require any space in the database. A typical dimension is city, state (or province), region, and country.</p>
                     <p>Dimension data is typically collected at the lowest level<a id="d9077e672" class="indexterm-anchor"></a> of detail and then aggregated into higher level totals that are more useful for analysis. These natural rollups or aggregations within a dimension table are called hierarchies.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="data-warehouse-physical-design.html#GUID-FA240A84-3197-4D5E-B412-2274CD6A84B1">About Dimension Hierarchies</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-physical-design.html#GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9">Typical Dimension Hierarchy</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9276"></a><div class="props_rev_3"><a id="GUID-FA240A84-3197-4D5E-B412-2274CD6A84B1" name="GUID-FA240A84-3197-4D5E-B412-2274CD6A84B1"></a><h5 id="DWHSG-GUID-FA240A84-3197-4D5E-B412-2274CD6A84B1" class="sect5"><span class="enumeration_section">3.2.6.1 </span>About Dimension Hierarchies
                     </h5>
                     <div>
                        <p>Hierarchies<a id="d9077e710" class="indexterm-anchor"></a> are logical structures that use ordered levels to organize data. A hierarchy can be used to define data aggregation. For example, in a time dimension, a hierarchy might aggregate data from the month level to the quarter level to the year level. A hierarchy can also be used to define a navigational drill path and to establish a family structure. 
                        </p>
                        <p>Within a hierarchy, each level is logically connected to the levels above and below it. Data values at lower levels aggregate into the data values at higher levels. A dimension can be composed of more than one hierarchy. For example, in the product dimension, there might be two hierarchiesâ€”one for product categories and one for product suppliers.</p>
                        <p>Dimension hierarchies<a id="d9077e719" class="indexterm-anchor"></a> also group levels from general to granular. Q<a id="d9077e724" class="indexterm-anchor"></a>uery tools use hierarchies to enable you to drill down into your data to view different levels of granularity. This is one of the key benefits of a data warehouse. 
                        </p>
                        <p>When designing hierarchies, you must consider the relationships in business structures. For example, a divisional multilevel sales organization can have complicated structures.</p>
                        <p>Hierarchies impose a family structure on dimension values. For a particular level value, a value at the next higher level is its parent, and values at the next lower level are its children. These familial relationships<a id="d9077e733" class="indexterm-anchor"></a> enable analysts to access data quickly.
                        </p>
                        <div class="infoboxnotealso" id="GUID-FA240A84-3197-4D5E-B412-2274CD6A84B1__GUID-0B72F7D4-D857-4F9E-AE6C-390B3943134F">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="data-warehouse-physical-design.html#GUID-F32C081D-606A-40BE-93F6-8285914E93C5">About Levels</a></p>
                              </li>
                              <li>
                                 <p><a href="data-warehouse-physical-design.html#GUID-42BCFDC5-9BAF-4A87-9BC1-CD2C2998886D">About Level Relationships</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="DWHSG9277"></a><div class="props_rev_3"><a id="GUID-F32C081D-606A-40BE-93F6-8285914E93C5" name="GUID-F32C081D-606A-40BE-93F6-8285914E93C5"></a><h6 id="DWHSG-GUID-F32C081D-606A-40BE-93F6-8285914E93C5" class="sect6"><span class="enumeration_section">3.2.6.1.1 </span>About Levels
                        </h6>
                        <div>
                           <p><a id="d9077e769" class="indexterm-anchor"></a>A level represents a position in a hierarchy. For example, a time dimension might have a hierarchy that represents data at the month, quarter, and year levels. Levels range from general to specific, with the <a id="d9077e772" class="indexterm-anchor"></a>root level as the highest or most general level. The levels in a dimension are organized into one or more hierarchies.
                           </p>
                        </div>
                     </div><a id="DWHSG9278"></a><div class="props_rev_3"><a id="GUID-42BCFDC5-9BAF-4A87-9BC1-CD2C2998886D" name="GUID-42BCFDC5-9BAF-4A87-9BC1-CD2C2998886D"></a><h6 id="DWHSG-GUID-42BCFDC5-9BAF-4A87-9BC1-CD2C2998886D" class="sect6"><span class="enumeration_section">3.2.6.1.2 </span>About Level Relationships
                        </h6>
                        <div>
                           <p>Level relationships<a id="d9077e797" class="indexterm-anchor"></a> specify top-to-bottom ordering of levels from most general (the root) to most specific information. They define the parent-child relationship between the levels in a hierarchy.
                           </p>
                           <p>Hierarchies are also essential components in enabling more complex rewrites. For example, the database can aggregate an existing sales revenue on a quarterly base to a yearly aggregation when the dimensional dependencies between quarter and year are known.</p>
                        </div>
                     </div>
                  </div><a id="DWHSG9280"></a><a id="DWHSG9279"></a><div class="props_rev_3"><a id="GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9" name="GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9"></a><h5 id="DWHSG-GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9" class="sect5"><span class="enumeration_section">3.2.6.2 </span>Typical Dimension Hierarchy
                     </h5>
                     <div>
                        <p><a href="data-warehouse-physical-design.html#GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9__CHDDDBAF">Figure 3-2</a> illustrates a dimension hierarchy based on <code class="codeph">customers</code>.
                        </p>
                        <div class="figure" id="GUID-6B479702-1F98-498B-BE43-34C4DF90F0F9__CHDDDBAF">
                           <p class="titleinfigure">Figure 3-2 Typical Levels in a Dimension Hierarchy</p><img width="97" src="img/dwhsg023.gif" alt="Description of Figure 3-2 follows" title="Description of Figure 3-2 follows" longdesc="img_text/dwhsg023.html"><br><a href="img_text/dwhsg023.html">Description of "Figure 3-2 Typical Levels in a Dimension Hierarchy"</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>