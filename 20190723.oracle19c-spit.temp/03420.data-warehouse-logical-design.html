<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Data Warehousing Logical Design</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="introduction-data-warehouse-concepts.html" title="Previous" type="text/html">
      <link rel="next" href="data-warehouse-physical-design.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction-data-warehouse-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="data-warehouse-physical-design.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-dw-fundamentals.html" property="item" typeof="WebPage"><span property="name">Data Warehouse - Fundamentals </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Data Warehousing Logical Design </li>
            </ol>
            <a id="GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3" name="GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3"></a>
            
            <h2 id="DWHSG-GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3" class="sect2"><span class="enumeration_chapter">2 </span>Data Warehousing Logical Design 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter <a id="d7845e19" class="indexterm-anchor"></a><a id="d7845e23" class="indexterm-anchor"></a>explains how to create a logical design for a data warehousing environment and includes the following topics:
               </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-48D381BE-15FD-4C92-B486-6071BEBD7801">Logical Versus Physical Design in Data Warehouses</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C">Creating a Logical Design</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822">About Third Normal Form Schemas</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF">About Star Schemas</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-43410030-C84A-4978-B286-6A3361D172FB" title="The In-Memory column store (IM column store) is an optional portion of the system global area (SGA) that stores copies of tables, table partitions, and other database objects in a compressed columnar format that is optimized for rapid scans.">Improved Analytics Using the In-Memory Column Store</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-BD54F705-627B-4460-AB83-AFA992D8798C">Automatic Big Table Caching to Improve the Performance of In-Memory Parallel Queries</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG9226"></a><div class="props_rev_3"><a id="GUID-48D381BE-15FD-4C92-B486-6071BEBD7801" name="GUID-48D381BE-15FD-4C92-B486-6071BEBD7801"></a><h3 id="DWHSG-GUID-48D381BE-15FD-4C92-B486-6071BEBD7801" class="sect3"><span class="enumeration_section">2.1 </span>Logical Versus Physical Design in Data Warehouses
               </h3>
               <div>
                  <p>Your organization has decided to build an enterprise data warehouse. You have defined the business requirements and agreed upon the scope of your business goals, and created a conceptual design. Now you need to translate your requirements into a system deliverable. To do so, you create the logical and physical design for the data warehouse. You then define:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The specific data content</p>
                     </li>
                     <li>
                        <p>Relationships within and between groups of data</p>
                     </li>
                     <li>
                        <p>The system environment supporting your data warehouse</p>
                     </li>
                     <li>
                        <p>The data transformations required</p>
                     </li>
                     <li>
                        <p>The frequency with which data is refreshed</p>
                     </li>
                  </ul>
                  <p>The logical design is more conceptual and abstract than the physical design. In the logical design, you look at the logical relationships among the objects. In the physical design, you look at the most effective way of storing and retrieving the objects as well as handling them from a transportation and backup/recovery perspective.</p>
                  <p>Orient your design toward the needs of the end users. End users typically want to perform analysis and look at aggregated data, rather than at individual transactions. However, end users might not know what they need until they see it. In addition, a well-planned design allows for growth and changes as the needs of users change and evolve.</p>
                  <p>By beginning with the logical design, you focus on the information requirements and save the implementation details for later.</p>
               </div>
            </div><a id="DWHSG9227"></a><div class="props_rev_3"><a id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C" name="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C"></a><h3 id="DWHSG-GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C" class="sect3"><span class="enumeration_section">2.2 </span>Creating a Logical Design
               </h3>
               <div>
                  <p>A logical design is conceptual and abstract. You do not deal with the physical implementation details yet. You deal only with defining the types of information that you need.</p>
                  <p>One technique you can use to model your organization's logical information requirements is entity-relationship modeling. Entity-relationship modeling involves identifying the things of importance (entities), the properties of these things (attributes), and how they are related to one another (relationships).</p>
                  <p>The process of logical design involves arranging data into a series of logical relationships called entities and attributes. <a id="d7845e131" class="indexterm-anchor"></a>An entity represents a chunk of information. In relational databases, an entity often maps to a table. <a id="d7845e134" class="indexterm-anchor"></a>An attribute is a component of an entity that helps define the uniqueness of the entity. In relational databases, an attribute maps to a column.
                  </p>
                  <p>To ensure that your data is consistent, you must use unique<a id="d7845e139" class="indexterm-anchor"></a> identifiers. A unique identifier is something you add to tables so that you can differentiate between the same item when it appears in different places. In a physical design, this is usually a primary key.
                  </p>
                  <p>Entity-relationship modeling is purely logical and applies to both OLTP and data warehousing systems. It is also applicable to the various common physical schema modeling techniques found in data warehousing environments, namely normalized (3NF) schemas in Enterprise Data Warehousing environments, star or snowflake schemas in data marts, or hybrid schemas with components of both of these classical modeling techniques.</p>
                  <div class="infoboxnotealso" id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C__GUID-CE0A1E37-859E-4388-8B99-887DD4ED3237">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/dwhsg&amp;id=ODIDG171" target="_blank"><span class="italic">Oracle Fusion Middleware Developing Integration Projects with Oracle Data Integrator</span></a> for more details regarding ODI
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9290"></a><div class="props_rev_3"><a id="GUID-3507EE0E-F92E-4781-8341-549791A3EE7D" name="GUID-3507EE0E-F92E-4781-8341-549791A3EE7D"></a><h4 id="DWHSG-GUID-3507EE0E-F92E-4781-8341-549791A3EE7D" class="sect4"><span class="enumeration_section">2.2.1 </span>What is a Schema?
                  </h4>
                  <div>
                     <p>A schema<a id="d7845e177" class="indexterm-anchor"></a><a id="d7845e181" class="indexterm-anchor"></a> is a collection of database objects, including tables, views, indexes, and synonyms. You can arrange schema objects in the schema models designed for data warehousing in a variety of ways. Most data warehouses use a dimensional model.
                     </p>
                     <p>The model of your source data and the requirements of your users help you design the data warehouse schema. You can sometimes get the source model from your company's enterprise data model and reverse-engineer the logical data model for the data warehouse from this. The physical implementation of the logical data warehouse model may require some changes to adapt it to your system parametersâ€”size of computer, number of users, storage capacity, type of network, and software. A key part of designing the schema is whether to use a third normal form, star, or snowflake schema, and these are discussed later.</p>
                  </div>
               </div>
            </div><a id="DWHSG9230"></a><a id="DWHSG9229"></a><div class="props_rev_3"><a id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822" name="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822"></a><h3 id="DWHSG-GUID-FD474327-4F5C-4D7E-AC7B-91739F229822" class="sect3"><span class="enumeration_section">2.3 </span>About Third Normal Form Schemas
               </h3>
               <div>
                  <p>Third Normal For<a id="d7845e212" class="indexterm-anchor"></a><a id="d7845e214" class="indexterm-anchor"></a><a id="d7845e216" class="indexterm-anchor"></a>m design seeks to minimize data redundancy and avoid anomalies in data insertion, updates and deletion. 3NF design has a long heritage in online transaction processing (OLTP) systems. OLTP systems must maximize performance and accuracy when inserting, updating and deleting data. Transactions must be handled as quickly as possible or the business may be unable to handle the flow of events, perhaps losing sales or incurring other costs. Therefore, 3NF designs avoid redundant data manipulation and minimize table locks, both of which can slow inserts, updates and deletes. 3NF designs also works well to abstract the data from specific application needs. If new types of data are added to the environment, you can extend the data model with relative ease and minimal impact to existing applications. Likewise, if you have completely new types of analyses to perform in your data warehouse, a well-designed 3NF schema will be able to handle them without requiring redesigned data structures.3NF designs have great flexibility, but it comes at a cost. 3NF databases use very many tables and this requires complex queries with many joins. For full scale enterprise models built in 3NF form, over one thousand tables are commonly encountered in the schema. With the kinds of queries involved in data warehousing, which will often need access to many rows from many tables, this design imposes understanding and performance penalties. It can be complex for query builders, whether they are humans or business intelligence tools and applications, to choose and join the tables needed for a given piece of data when there are very large numbers of tables available. Even when the tables are readily chosen by the query generator, the 3NF schema often requires that a large number of tables be used in a single query. More tables in a query mean more potential data access paths, which makes the database query optimizer's job harder. The end result can be slow query performance.
                  </p>
                  <p>The issue of slow query performance in a 3NF system is not necessarily limited to the core queries used to create reports and analyses. It can also show up in the simpler task of users browsing subsets of data to understand the contents. Similarly, the complexity of a 3NF schema may impact generating the pick-lists of data used to constrain queries and reports. Although these may seem relatively minor issues, speedy response time for such processes makes a big impact on user satisfaction.</p>
                  <p><a href="data-warehouse-logical-design.html#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">Figure 2-1</a> presents a tiny fragment of a 3NF Schema. Note how order information is broken into order and order items to avoid redundant data storage. The "crow's feet" markings on the relationship between tables indicate one-to-many relationships among the entities. Thus, one order may have multiple order items, a single customer may have many orders, and a single product may be found in many order items. Although this diagram shows a very small case, you can see that minimizing data redundancy can lead to many tables in the schema.
                  </p>
                  <div class="figure" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">
                     <p class="titleinfigure">Figure 2-1 Fragment of a Third Normal Form Schema</p><img src="img/dwhsg108.gif" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" longdesc="img_text/dwhsg108.html"><br><a href="img_text/dwhsg108.html">Description of "Figure 2-1 Fragment of a Third Normal Form Schema"</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__GUID-B3F28A2E-2AB2-48B8-9338-948A9A223EE9">
                     <p class="notep1">See Also:</p>
                     <p><a href="data-warehouse-logical-design.html#GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578">Design Concepts for 3NF Schemas</a></p>
                  </div>
               </div><a id="DWHSG9231"></a><div class="props_rev_3"><a id="GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80" name="GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80"></a><h4 id="DWHSG-GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80" class="sect4"><span class="enumeration_section">2.3.1 </span>About Normalization
                  </h4>
                  <div>
                     <p>Normalization is a data design process that has a high level goal of keeping each fact in just one place to avoid data redundancy and insert, update, and delete anomalies. There are multiple levels of normalization, and this section describes the first three of them. Considering how fundamental the term third normal form (3NF) term is, it only makes sense to see how 3NF is reached.</p>
                     <p>Consider a situation where you are tracking sales. The core entity you track is sales orders, where each sales order contains details about each item purchased (referred to as a line item): its name, price, quantity, and so on. The order also holds the name and address of the customer and more. Some orders have many different line items, and some orders have just one.</p>
                     <p>In first normal form (1NF), there are no repeating groups of data and no duplicate rows. Every intersection of a row and column (a field) contains just one value, and there are no groups of columns that contain the same facts. To avoid duplicate rows, there is a primary key. For sales orders, in first normal form, multiple line items of each sales order in a single field of the table are not displayed. Also, there will not be multiple columns showing line items.</p>
                     <p>Then comes second normal form (2NF), where the design is in first normal form and every non-key column is dependent on the complete primary key. Thus, the line items are broken out into a table of sales order line items where each row represents one line item of one order. You can look at the line item table and see that the names of the items sold are not dependent on the primary key of the line items table: the sales item is its own entity. Therefore, you move the sales item to its own table showing the item name. Prices charged for each item can vary by order (for instance, due to discounts) so these remain in the line items table. In the case of sales order, the name and address of the customer is not dependent on the primary key of the sales order: customer is its own entity. Thus, you move the customer name and address columns out into their own table of customer information.</p>
                     <p>Next is third normal form, where the goal is to ensure that there are no dependencies on non-key attributes. So the goal is to take columns that do not directly relate to the subject of the row (the primary key), and put them in their own table. So details about customers, such as customer name or customer city, should be put in a separate table, and then a customer foreign key added into the orders table.</p>
                     <p>Another example of how a 2NF table differs from a 3NF table would be a table of the winners of tennis tournaments that contained columns of tournament, year, winner, and winner's date of birth. In this case, the winner's date of birth is vulnerable to inconsistencies, as the same person could be shown with different dates of birth in different records. The way to avoid this potential problem is to break the table into one for tournament winners, and another for the player dates of birth.</p>
                  </div>
               </div><a id="DWHSG9311"></a><div class="props_rev_3"><a id="GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578" name="GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578"></a><h4 id="DWHSG-GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578" class="sect4"><span class="enumeration_section">2.3.2 </span>Design Concepts for 3NF Schemas
                  </h4>
                  <div>
                     <p>The following section discusses some basic concepts when modeling for a data warehousing environment using a 3NF schema approach. The intent is not to discuss the theoretical foundation for 3NF modeling (or even higher levels of normalization), but to highlight some key components relevant for data warehousing.</p>
                     <p>Some key 3NF schema design concepts that are relevant to data warehousing are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2">Identifying Candidate Primary Keys</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-AD7D5938-1B52-44A6-815E-D73834303871">Foreign Key Relationships and Referential Integrity Constraints</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-75BD1411-C19C-436B-8FB9-47F3708272D9">Denormalization</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9312"></a><div class="props_rev_3"><a id="GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2" name="GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2"></a><h5 id="DWHSG-GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2" class="sect5"><span class="enumeration_section">2.3.2.1 </span>Identifying Candidate Primary Keys
                     </h5>
                     <div>
                        <p>A primary key is an attribute that uniquely identifies a specific record in a table. Primary keys can be identified through single or multiple columns. It is normally preferred to achieve unique identification through as little columns as possible - ideally one or two - and to either use a column that is most likely not going to be updated or even changed in bulk. If your data model does not lead to a simple unique identification through its attributes, you would require too many attributes to uniquely identify a single records, or the data is prone to changes, the usage of a surrogate key is highly recommended.</p>
                        <p>Specifically, 3NF schemas rely on proper and simple unique identification since queries tend to have many table joins and all columns necessary to uniquely identify a record are needed as join condition to avoid row duplication through the join.</p>
                     </div>
                  </div><a id="DWHSG9313"></a><div class="props_rev_3"><a id="GUID-AD7D5938-1B52-44A6-815E-D73834303871" name="GUID-AD7D5938-1B52-44A6-815E-D73834303871"></a><h5 id="DWHSG-GUID-AD7D5938-1B52-44A6-815E-D73834303871" class="sect5"><span class="enumeration_section">2.3.2.2 </span>Foreign Key Relationships and Referential Integrity Constraints
                     </h5>
                     <div>
                        <p>3NF schemas in data warehousing environments often resemble the data model of its OLTP source systems, in which the logical consistency between data entities is expressed and enforced through primary key - foreign key relationships, also known as parent-child relationship. A foreign key resolves a 1-to-many relationship in relational system and ensures logical consistency: for example, you cannot have an order line item without an order header, or an employee working for a non-existent department.</p>
                        <p>While such referential are always enforced in OLTP system, data warehousing systems often implement them as declarative, non-enforced conditions, relying on the ETL process to ensure data consistency. Whenever possible, foreign keys and referential integrity constraints should be defined as non-enforced conditions, since it enables better query optimization and cardinality estimates.</p>
                     </div>
                  </div><a id="DWHSG9314"></a><div class="props_rev_3"><a id="GUID-75BD1411-C19C-436B-8FB9-47F3708272D9" name="GUID-75BD1411-C19C-436B-8FB9-47F3708272D9"></a><h5 id="DWHSG-GUID-75BD1411-C19C-436B-8FB9-47F3708272D9" class="sect5"><span class="enumeration_section">2.3.2.3 </span>Denormalization
                     </h5>
                     <div>
                        <p>Proper normalized modelling tends to decompose logical entities - such as a customer. a product, or an order - into many physical tables, making even the retrieval of perceived simple information requiring to join many tables. While this is not a problem from a query processing perspective, it can put some unnecessary burden on both the application developer (for writing code) as well as the database (for joining information that is always used together). It is not uncommon to see some sensible level of denormalization in 3NF data warehousing models, in a logical form as views or in a physical form through slightly denormalized tables.</p>
                        <p>Care has to be taken with the physical denormalization to preserve the subject-neutral shape and therefore the flexibility of the physical implementation of the 3NF schema.</p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9233"></a><div class="props_rev_3"><a id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF" name="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF"></a><h3 id="DWHSG-GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF" class="sect3"><span class="enumeration_section">2.4 </span>About Star Schemas
               </h3>
               <div>
                  <p>Star schemas are often found in data warehousing systems with embedded logical or physical data marts. The term star schema is another way of referring to a "dimensional modeling" approach to defining your data model. Most descriptions of dimensional modeling use terminology drawn from the work of Ralph Kimball, the pioneering consultant and writer in this field. Dimensional modeling creates multiple star schemas, each based on a business process such as sales tracking or shipments. Each star schema can be considered a data mart, and perhaps as few as 20 data marts can cover the business intelligence needs of an enterprise. Compared to 3NF designs, the number of tables involved in dimensional modeling is a tiny fraction. Many star schemas will have under a dozen tables. The star schemas are knit together through conformed dimensions and conformed facts. Thus, users are able to get data from multiple star schemas with minimal effort.</p>
                  <p>The goal for star schemas is structural simplicity and high performance data retrieval. Because most queries in the modern era are generated by reporting tools and applications, it's vital to make the query generation convenient and reliable for the tools and application. In fact, many business intelligence tools and applications are designed with the expectation that a star schema representation will be available to them.</p>
                  <p>Discussions of star schemas are less abstracted from the physical database than 3NF descriptions. This is due to the pragmatic emphasis of dimensional modeling on the needs of business intelligence users.</p>
                  <p>Note how different the dimensional modeling style is from the 3NF approach that minimizes data redundancy and the risks of update/inset/delete anomalies. The star schema accepts data redundancy (denormalization) in its dimension tables for the sake of easy user understanding and better data retrieval performance. A common criticism of star schemas is that they limit analysis flexibility compared to 3NF designs. However, a well designed dimensional model can be extended to enable new types of analysis, and star schemas have been successful for many years at the largest enterprises.</p>
                  <p>As noted earlier, the modern approach to data warehousing does not pit star schemas and 3NF against each other. Rather, both techniques are used, with a foundation layer of 3NF - the Enterprise Data Warehouse of 3NF, acting as the bedrock data, and star schemas as a central part of an access and performance optimization layer.</p>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF__GUID-D40EA285-8F0E-4476-82F8-E1B2CE618747">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F">About Facts and Dimensions in Star Schemas</a></p>
                           </li>
                           <li><a href="data-warehouse-logical-design.html#GUID-787CD3B1-0131-47F4-A904-4F7221A29448">Design Concepts in Star Schemas</a></li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9235"></a><a id="DWHSG9234"></a><div class="props_rev_3"><a id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F" name="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F"></a><h4 id="DWHSG-GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F" class="sect4"><span class="enumeration_section">2.4.1 </span>About Facts and Dimensions in Star Schemas
                  </h4>
                  <div>
                     <p>Star schemas divide data into facts and dimensions. Facts are the measurements of some event such as a sale and are typically numbers. Dimensions are the categories you use to identify facts, such as date, location, and product.</p>
                     <p>The name "star schema" comes from the fact that the diagrams of the schemas typically show a<a id="d7845e446" class="indexterm-anchor"></a> central fact table with lines joining it to the dimension tables, so the graphic impression is similar to a star. <a href="data-warehouse-logical-design.html#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">Figure 2-2</a> is a simple example with sales as the fact table and products, times, customers, and channels as the dimension table.
                     </p>
                     <div class="figure" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">
                        <p class="titleinfigure">Figure 2-2 Star Schema</p><img width="336" src="img/td007.gif" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" longdesc="img_text/td007.html"><br><a href="img_text/td007.html">Description of "Figure 2-2 Star Schema"</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__GUID-F5436257-7D99-45BF-9ECE-7F2640293B25">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE">About Fact Tables in Data Warehouses</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1">About Dimension Tables in Data Warehouses</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9236"></a><div class="props_rev_3"><a id="GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE" name="GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE"></a><h5 id="DWHSG-GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE" class="sect5"><span class="enumeration_section">2.4.1.1 </span>About Fact Tables in Data Warehouses
                     </h5>
                     <div>
                        <p>Fact tables have measurement data. They have many rows but typically not many columns. Fact tables for a large enterprise can easily hold billions of rows. For many star schemas, the fact table will represent well over 90 percent of the total storage space. A fact table has a composite key made up of the primary keys of the dimension tables of the schema.</p>
                        <p>A fact table contains either detail-level facts or facts that have been aggregated. Fact tables that contain aggregated facts are often called summary tables. A fact table usually contains facts with the same level of aggregation. Though most facts are additive, they can also be semi-additive or non-additive. Additive facts can be aggregated by simple arithmetical addition. A common example of this is sales. Non-additive facts cannot be added at all. An example of this is averages. Semi-additive facts can be aggregated along some of the dimensions and not along others. An example of this is inventory levels stored in physical warehouses, where you may be able to add across a dimension of warehouse sites, but you cannot aggregate across time.</p>
                        <p>In terms of adding rows to data in a fact table, there are three main approaches:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Transaction-based</p>
                              <p>Shows a row for the finest level detail in a transaction. A row is entered only if a transaction has occurred for a given combination of dimension values. This is the most common type of fact table.</p>
                           </li>
                           <li>
                              <p>Periodic Snapshot</p>
                              <p>Shows data as of the end of a regular time interval, such as daily or weekly. If a row for the snapshot exists in a prior period, a row is entered for it in the new period even if no activity related to it has occurred in the latest interval. This type of fact table is useful in complex business processes where it is difficult to compute snapshot values from individual transaction rows.</p>
                           </li>
                           <li>
                              <p>Accumulating Snapshot</p>
                              <p>Shows one row for each occurrence of a short-lived process. The rows contain multiple dates tracking major milestones of a short-lived process. Unlike the other two types of fact tables, rows in an accumulating snapshot are updated multiple times as the tracked process moves forward.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9237"></a><div class="props_rev_3"><a id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1" name="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1"></a><h5 id="DWHSG-GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1" class="sect5"><span class="enumeration_section">2.4.1.2 </span>About Dimension Tables in Data Warehouses
                     </h5>
                     <div>
                        <p>Dimension tables provide category data to give context to the fact data. For instance, a star schema for sales data will have dimension tables for product, date, sales location, promotion and more. Dimension tables act as lookup or reference tables because their information lets you choose the values used to constrain your queries. The values in many dimension tables may change infrequently. As an example, a dimension of geographies showing cities may be fairly static. But when dimension values do change, it is vital to update them fast and reliably. Of course, there are situations where data warehouse dimension values change frequently. The customer dimension for an enterprise will certainly be subject to a frequent stream of updates and deletions.</p>
                        <p>A key aspect of dimension tables is the hierarchy information they provide. Dimension data typically has rows for the lowest level of detail plus rows for aggregated dimension values. These natural rollups or aggregations within a dimension table are called hierarchies and add great value for analyses. For instance, if you want to calculate the share of sales that a specific product represents within its specific product category, it is far easier and more reliable to have a predefined hierarchy for product aggregation than to specify all the elements of the product category in each query. Because hierarchy information is so valuable, it is common to find multiple hierarchies reflected in a dimension table.</p>
                        <p>Dimension tables are usually textual and descriptive, and you will use their values as the row headers, column headers and page headers of the reports generated by your queries. While dimension tables have far fewer rows than fact tables, they can be quite wide, with dozens of columns. A location dimension table might have columns indicating every level of its rollup hierarchy, and may show multiple hierarchies reflected in the table. The location dimension table could have columns for its geographic rollup, such as street address, postal code, city, state/province, and country. The same table could include a rollup hierarchy set up for the sales organization, with columns for sales district, sales territory, sales region, and characteristics.</p>
                        <div class="infoboxnotealso" id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1__GUID-CFCF03B1-97E6-4929-81D0-6059E57DA38F">
                           <p class="notep1">See Also:</p>
                           <p> <a href="dimensions.html#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">Dimensions</a> for further information regarding dimensions
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9238"></a><div class="props_rev_3"><a id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448" name="GUID-787CD3B1-0131-47F4-A904-4F7221A29448"></a><h4 id="DWHSG-GUID-787CD3B1-0131-47F4-A904-4F7221A29448" class="sect4"><span class="enumeration_section">2.4.2 </span>Design Concepts in Star Schemas
                  </h4>
                  <div>
                     <p>Here we touch on some of the key terms used in star schemas. This is by no means a full set, but is intended to highlight some of the areas worth your consideration.</p>
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHCCIEF">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-B126B71A-80D8-4717-82D3-A5C102B2B9FF">Data Grain</p>
                        <p>One of the most important tasks when designing your model is to consider the level of detail it will provide, referred to as the grain of the data. Consider a sales schema: will the grain be very fine, storing every single item purchased by each customer? Or will it be a coarse grain, storing only the daily totals of sales for each product at each store? In modern data warehousing there is a strong emphasis on providing the finest grain data possible, because this allows for maximum analytic power. Dimensional modeling experts generally recommend that each fact table store just one grain level. Presenting fact data in single-grain tables supports more reliable querying and table maintenance, because there is no ambiguity about the scope of any row in a fact table.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHICGJA">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-AE989781-8DE7-4038-A6FA-6A18233E0E67">Working with Multiple Star Schemas</p>
                        <p>Because the star schema design approach is intended to chunk data into distinct processes, you need reliable and performant ways to traverse the schemas when queries span multiple schemas. One term for this ability is a data warehouse bus architecture. A data warehouse bus architecture can be achieved with conformed dimensions and conformed facts.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHAGIB">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-E958D393-CACD-4E33-AAFE-B2EFCC42DB19">Conformed Dimensions</p>
                        <p>Conformed dimensions means that dimensions are designed identically across the various star schemas. Conformed dimensions use the same values, column names and data types consistently across multiple stars. The conformed dimensions do not have to contain the same number of rows in each schema's copy of the dimension table, as long as the rows in the shorter tables are a true subset of the larger tables.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEGEGE">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-DC7F38AC-F5EF-41A1-968C-EA6117BB7DA7">Conformed Facts</p>
                        <p>If the fact columns in multiple fact tables have exactly the same meaning, then they are considered conformed facts. Such facts can be used together reliably in calculations even though they are from different tables. Conformed facts should have the same column names to indicate their conformed status. Facts that are not conformed should always have different names to highlight their different meanings.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEIJJC">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-6BE11CAB-499A-494F-AB56-C3F7BCAF40BF">Surrogate Keys</p>
                        <p>Surrogate or artificial keys, usually sequential integers, are recommended for dimension tables. By using surrogate keys, the data is insulated from operational changes. Also, compact integer keys may allow for better performance than large and complex alphanumeric keys.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-9CDA668A-8912-488F-8D9C-2B4029B5A088">Degenerate Dimensions</p>
                        <p id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHDFJEG">Degenerate dimensions are dimension columns in fact tables that do not join to a dimension table. They are typically items such as order numbers and invoice numbers. You will see them when the grain of a fact table is at the level of an order line-item or a single transaction.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHIGFH">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-CA40ACAC-B824-445E-AA56-4FD567B5746C">Junk Dimensions</p>
                        <p>Junk dimensions are abstract dimension tables used to hold text lookup values for flags and codes in fact tables. These dimensions are referred to as junk, not because they have low value, but because they hold an assortment of columns for convenience, analogous to the idea of a "junk drawer" in your home. The number of distinct values (cardinality) of each column in a junk dimension table is typically small.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHIFGHD">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-39D088B4-9AD9-4317-B242-2D6A42FE8BA8">Embedded Hierarchy</p>
                        <p>Classic dimensional modeling with star schemas advocates that each table contain data at a single grain. However, there are situations where designers choose to have multiple grains in a table, and these commonly represent a rollup hierarchy. A single sales fact table, for instance, might contain both transaction-level data, then a day-level rollup by product, then a month-level rollup by product. In such cases, the fact table will need to contain a level column indicating the hierarchy level applying to each row, and queries against the table will need to include a level predicate.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHFBFFH">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-36FA5EB0-4F89-436F-95D4-A6BC8563BF24">Factless Fact Tables</p>
                        <p>Factless fact tables do not contain measures such as sales price or quantity sold. Instead, the rows of a factless fact table are used to show events not represented by other fact tables. Another use for factless tables is as a "coverage table" which holds all the possible events that could have occurred in a given situation, such as all the products that were part of a sales promotion and might have been sold at the promotional price.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHHCGF">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-B45F2AC4-B7F9-4C45-BDAB-620A3F445816">Slowly Changing Dimensions</p>
                        <p>One of the certainties of data warehousing is that the way data is categorized will change. Product names and category names will change. Characteristics of a store will change. The areas included in sales territories will change. The timing and extent of these changes will not always be predictable. How can these slowly changing dimensions be handled? Star schemas treat these in three main ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Type 1</p>
                              <p>The dimension values that change are simply overwritten, with no history kept. This creates a problem for time-based analyses. Also, it invalidates any existing aggregates that depended on the old value of the dimension.</p>
                           </li>
                           <li>
                              <p>Type 2</p>
                              <p>When a dimension value changes, a new dimension row showing the new value and having a new surrogate key is created. You may choose to include date columns in our dimension showing when the new row is valid and when it is expired. No changes need be made to the fact table.</p>
                           </li>
                           <li>
                              <p>Type 3</p>
                              <p>When a dimension value is changed, the prior value is stored in a different column of the same row. This enables easy query generation if you want to compare results using the current and prior value of the column.</p>
                           </li>
                        </ul>
                        <p>In practice, Type 2 is the most common treatment for slowly changing dimensions.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9250"></a><a id="DWHSG9249"></a><div class="props_rev_3"><a id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD" name="GUID-B88263A2-708E-4750-9CE5-273F03B233DD"></a><h4 id="DWHSG-GUID-B88263A2-708E-4750-9CE5-273F03B233DD" class="sect4"><span class="enumeration_section">2.4.3 </span>About Snowflake Schemas
                  </h4>
                  <div>
                     <p>The snowflake schema<a id="d7845e659" class="indexterm-anchor"></a> is a more complex data warehouse model than a star schema, and is a type of star schema. It is called a snowflake schema because the diagram of the schema resembles a snowflake.
                     </p>
                     <p>Snowflake schemas normalize dimensions to eliminate redundancy. That is, the dimension data has been grouped into multiple tables instead of one large table. For example, a product dimension table in a star schema might be normalized into a <code class="codeph">products</code> table, a <code class="codeph">product_category</code> table, and a <code class="codeph">product_manufacturer</code> table in a snowflake schema. While this saves space, it increases the number of dimension tables and requires more foreign key joins<a id="d7845e673" class="indexterm-anchor"></a>. The result is more complex queries<a id="d7845e680" class="indexterm-anchor"></a><a id="d7845e684" class="indexterm-anchor"></a> and reduced query performance. <a href="data-warehouse-logical-design.html#GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">Figure 2-3</a> presents a graphical representation of a snowflake schema.
                     </p>
                     <div class="figure" id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">
                        <p class="titleinfigure">Figure 2-3 Snowflake Schema</p><img src="img/td008.gif" alt="Description of Figure 2-3 follows" title="Description of Figure 2-3 follows" longdesc="img_text/td008.html"><br><a href="img_text/td008.html">Description of "Figure 2-3 Snowflake Schema"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-43410030-C84A-4978-B286-6A3361D172FB" name="GUID-43410030-C84A-4978-B286-6A3361D172FB"></a><h3 id="DWHSG-GUID-43410030-C84A-4978-B286-6A3361D172FB" class="sect3"><span class="enumeration_section">2.5 </span>Improved Analytics Using the In-Memory Column Store
               </h3>
               <div>
                  <p>The In-Memory column store (IM column store) is an optional portion of the system global area (SGA) that stores copies of tables, table partitions, and other database objects in a compressed columnar format that is optimized for rapid scans.</p>
                  <p></p>
                  <p>Columnar format lends itself easily to vector processing thus making aggregations, joins, and certain types of data retrieval faster than the traditional on-disk formats. The columnar format exists only in memory and does not replace the on-disk or buffer cache format. Instead, it supplements the buffer cache and provides an additional, transaction-consistent, copy of the table that is independent of the disk format.</p>
                  <p>Traditional analytics have certain limitations or requirements that need to be managed to obtain good performance for analytic queries. You need to know user access patterns and then customize your data structures to provide optimal performance for these access patterns. Existing indexes, materialized views, and OLAP cubes need to be tuned. Certain data marts and reporting databases have complex ETL and thus need specialized tuning. Additionally, you need to strike a balance between performing analytics on stale data and slowing down OLTP operations on the production databases.</p>
                  <p>The Oracle In-Memory Column Store (IM column store) within the Oracle Database provides improved performance for both ad-hoc queries and analytics on live data. The live transactional database is used to provide instant answers to queries, thus enabling you to seamlessly use the same database for OLTP transactions and data warehouse analytics.</p>
                  <p>The IM column store integrates seamlessly with the Oracle Database and provides the following benefits in data warehousing environments:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Improved query performance</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Processing of ad-hoc queries with unanticipated access patterns is faster</p>
                              <p>IM column store provides fast throughput for analyzing large amounts of data. Querying a subset of columns in a table provides quick results because only the columns necessary for the specific data analysis task are scanned.</p>
                           </li>
                           <li>
                              <p>Scanning of large number of rows and the application of filters that use operators such as =,&lt;,&gt;, and IN are faster with the use of SIMD vector processing</p>
                           </li>
                           <li>
                              <p></p>
                              <p>Storing frequently evaluated expressions using IM expressions reduces repeated computations of the same expressions</p>
                           </li>
                           <li>
                              <p></p>
                              <p>Using IM virtual columns and populating specified virtual columns into the IM column store avoids repeated evaluation of virtual columns</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>Enhanced join performance using bloom filters</p>
                        <p>Certain types of joins run faster when the tables being joined are stored in the IM column store. IM column store takes advantage of bloom filters with hash joins that speed up joins by converting predicates on small dimension tables to filters on a large fact table.</p>
                     </li>
                     <li>
                        <p>Efficient aggregation using <code class="codeph">VECTOR GROUP BY</code> transformation and vector array processing
                        </p>
                        <p>Queries that aggregate data and join one or more relatively small tables to a larger table, as often occurs in a star query, run faster. VECTOR GROUP BY will be chosen by the optimizer based on cost estimates.</p>
                     </li>
                     <li>
                        <p>Reduced storage space and significantly less processing overhead because fewer indexes, materialized views, and OLAP cubes are required when IM column store is used.</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-43410030-C84A-4978-B286-6A3361D172FB__GUID-34A0519B-5AF8-4C4E-BE5F-B1590D2C5D27">
                     <p class="notep1">See Also:</p>
                     <p><a href="../inmem/optimizing-in-memory-aggregation.html#INMEM-GUID-2C4FA6C6-3DA8-4CEA-9EF0-294396D15077" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a> for detailed information about using the IM column store
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5FFB571F-A173-4270-9451-AC677C963C37" name="GUID-5FFB571F-A173-4270-9451-AC677C963C37"></a><h4 id="DWHSG-GUID-5FFB571F-A173-4270-9451-AC677C963C37" class="sect4"><span class="enumeration_section">2.5.1 </span>About Improving Query Performance Using In-Memory Expressions
                  </h4>
                  <div>
                     <p>When you use the In-Memory Column Store (IM column store), query performance can be further enhanced by using In-Memory Expressions (IM expressions) for frequently evaluated expressions.</p>
                     <p>Most queries in a data warehousing environment involve querying large data sets and are computationally intensive as they contain complex expressions or calculations. IM expressions provide enhanced performance for queries that contain frequently evaluated expressions. The optimizer automatically identifies and records repeatedly used expressions in the Expression Statistics Store (ESS). Expressions captured in the ESS are candidates for IM expressions. To facilitate reuse, IM expressions are materialized and populated into In-Memory Expression Units (IMEUs) within the IM column store. The database then maintains IM expressions and ensures that they are consistent with any modifications made to the source columns on which these expressions are based. Populating IM expressions into the IM column store reduces repeated computations of the same expressions.</p>
                     <p>For example, total cost, which is a product of the price and number of units sold, is a candidate for an IM expression. Without IM expressions, the value of total cost needs to be recomputed for every query and for every row returned by the query. With IM expressions, this frequently evaluated expression can be materialized and stored in the IM column store. This eliminates the need to repeatedly recompute the expression used in the query. Oracle Database rewrites the queries at runtime to use expression results stored in the IM column store thereby improving query performance.</p>
                     <p>The initialization parameter <code class="codeph">INMEMORY_EXPRESSIONS_USAGE</code> controls which IM expressions must be populated into the IM column store. Procedures in the <code class="codeph">DBMS_INMEMORY_ADMIN</code> package specify when IM expressions are identified, populated, and used.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../inmem/optimizing-in-memory-expressions.html#INMEM-GUID-5F82168D-A024-4F96-B3AF-7DA4C52908B8" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694" name="GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694"></a><h4 id="DWHSG-GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694" class="sect4"><span class="enumeration_section">2.5.2 </span>About Using In-Memory Virtual Columns to Improve Query Performance
                  </h4>
                  <div>
                     <p>When you use the In-Memory Column Store (IM column store), In-Memory virtual columns (IM virtual columns) enable you to avoid repeated evaluations of virtual columns by populating specified virtual columns into the IM column store.</p>
                     <p>Virtual columns are user-created, named expressions that Oracle treats like regular columns. For example, if the <code class="codeph">SALARY</code> table contains the column <code class="codeph">monthly_salary</code>, you can define a virtual column called <code class="codeph">annual_salary</code> as <code class="codeph">monthly_salary</code> * 12. IM virtual columns are virtual columns that can be populated into the IM column store. You can populate all or a subset of the virtual columns defined in a table into the IM column store. Storing precomputed virtual columns in the IM column store improves query performance by avoiding repeated evaluations. Virtual column values can also be scanned and filtered using in-memory techniques such as SIMD vector processing.
                     </p>
                     <p>The initialization parameter <code class="codeph">INMEMORY_VIRTUAL_COLUMNS</code> determines if IM virtual columns must be created for tables enabled for IM column store.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../inmem/populating-objects-in-memory.html#INMEM-GUID-452D19AE-EB5F-44AC-A1AD-70CF10D2D347" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6" name="GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6"></a><h4 id="DWHSG-GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6" class="sect4"><span class="enumeration_section">2.5.3 </span>About In-Memory Column Store and Automatic Data Optimization
                  </h4>
                  <div>
                     <p> Automatic Data Optimization (ADO) can be used to manage the contents of the In-Memory Column Store (IM column store).</p>
                     <p>The performance benefits provided by the IM column store can be optimized by effectively managing the contents of the IM column store. Objects that benefit most from being stored in the IM column store must be retained. This requires a constant monitoring of the IM column store to determine which objects must be retained and which objects must be removed from the IM column store.</p>
                     <p>Automatic Data Optimization (ADO) automates the management of the IM column store contents. Heat map statistics are gathered for objects in the IM column store and these statistics are used to determine the least active and the most active objects. You can define ADO policies to specify when objects are eligible to be moved out of the IM column store.</p>
                     <p></p>
                     <p>In data warehousing applications, the frequency with which objects are accessed typically decreases over time. Therefore, objects are accessed most frequently when they are first loaded in to the data warehouse and the activity levels decrease subsequently. Data warehouse performance can be enhanced by defining ADO policies that move objects that are accessed the least out of the IM column store.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../inmem/configuring-memory-management.html#INMEM-GUID-895C9AF1-7FD3-47D2-B8E7-079A39A88068" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9327"></a><div class="props_rev_3"><a id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C" name="GUID-BD54F705-627B-4460-AB83-AFA992D8798C"></a><h3 id="DWHSG-GUID-BD54F705-627B-4460-AB83-AFA992D8798C" class="sect3"><span class="enumeration_section">2.6 </span>Automatic Big Table Caching to Improve the Performance of In-Memory Parallel Queries
               </h3>
               <div>
                  <p>Automatic <a id="d7845e934" class="indexterm-anchor"></a>big table caching enhances the in-memory query capabilities of Oracle Database. When a table does not fit in memory, the database decides which buffers to cache based on access patterns. This provides efficient caching for large tables, even if they do not fully fit in the buffer cache.
                  </p>
                  <p>An optional section of the buffer cache, called the big table cache, is used to store data for table scans. The big table cache is integrated with the buffer cache and uses a temperature-based, object-level replacement algorithm to manage the big table cache contents. This is different from the access-based, block level LRU algorithm used by the buffer cache.</p>
                  <div class="infoboxnote" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-781FCD0A-43A3-48C8-81E4-DE5C22392116">
                     <p class="notep1">Note:</p>
                     <p>The automatic big table caching feature is available starting with Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.2).
                     </p>
                  </div>
                  <p>Typical data warehousing workloads scan multiple tables. Performance may be impacted if the combined size of these tables is greater than the combined size of the buffer cache. With automatic big table caching, the scanned tables are stored in the big table cache instead of the buffer cache. The temperature-based, object-level replacement algorithm used by the big table cache can provide enhanced performance for data warehousing workloads by:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Selectively caching the "hot" objects</p>
                        <p>Each time an object is accessed, Oracle Database increments the temperature of that object. An object in the big table cache can be replaced only by another object whose temperature is higher than its own temperature.</p>
                     </li>
                     <li>
                        <p>Avoiding thrashing</p>
                        <p>Partial objects are cached when objects cannot be fully cached.</p>
                     </li>
                  </ul>
                  <p>In Oracle Real Application Clusters (Oracle RAC) environments, automatic big table caching is supported only for parallel queries. In single instance environments, this functionality is supported for both serial and parallel queries.</p>
                  <p>To use automatic big table caching, you must enable the big table cache. To use automatic big table caching for serial queries, you must set the <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> initialization parameter to a nonzero value. To use automatic big table caching for parallel queries, you must set <code class="codeph">PARALLEL_DEGREE_POLICY</code> to <code class="codeph">AUTO</code> or <code class="codeph">ADAPTIVE</code> and <code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code> to a nonzero value.
                  </p>
                  <div class="infoboxnotealso" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-F6834BA7-D22E-4EE2-96C0-5F3D2C8A248A">
                     <p class="notep1">See Also:</p>
                     <p><a href="../vldbg/inmemory-parallel-exec.html#VLDBG-GUID-A553169D-C6CD-443E-88C3-B746D5E32923" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for more information about the big table cache and how it can be used
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>