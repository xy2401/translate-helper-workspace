<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Defining and Controlling Transactions</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="running-Oracle-precompilers.html" title="Previous" type="text/html">
      <link rel="next" href="error-handling-diagnostics.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="running-Oracle-precompilers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="error-handling-diagnostics.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Defining and Controlling Transactions</li>
            </ol>
            <a id="GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5" name="GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5"></a><a id="ZZPRE734"></a>
            
            <h2 id="ZZPRE-GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5" class="sect2"><span class="enumeration_chapter">7 </span> Defining and Controlling Transactions
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter explains how to perform transaction processing. You learn the basic techniques that safeguard the consistency of your database, including how to control whether changes to Oracle data are made permanent or undone. The following topics are discussed:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA">Some Terms You Should Know</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-DA8414EA-887F-4A22-829F-5296ED333300">How Transactions Guard Your Database</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE">How to Begin and End Transactions</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7">About Using the COMMIT Statement</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E">About Using the ROLLBACK Statement</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249">About Using the SAVEPOINT Statement</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9">About Using the RELEASE Option</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5">About Using the SET TRANSACTION Statement</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-F1679173-0361-43D1-AE04-E5365ED03274">About Overriding Default Locking</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190">About Fetching Across Commits</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1">About Handling Distributed Transactions</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12">Guidelines</a></p>
                  </li>
               </ul>
            </div><a id="ZZPRE735"></a><div class="props_rev_3"><a id="GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA" name="GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA"></a><h3 id="ZZPRE-GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA" class="sect3"><span class="enumeration_section">7.1 </span>Some Terms You Should Know
               </h3>
               <div>
                  <p>Before delving into the subject of transactions, you should know the terms defined in this section.</p>
                  <p>The jobs or tasks that Oracle manages are called <span class="italic">sessions</span>. A <span class="italic">user session</span> is started when you run an application program or a tool such as Oracle Forms and connect to Oracle. Oracle allows user sessions to work "simultaneously" and share computer resources. To do this, Oracle must control <a id="d49462e122" class="indexterm-anchor"></a><span class="italic">concurrency</span>, which means many user accessing the same data. Without adequate concurrency controls, there might be a loss of <span class="italic">data integrity</span><a id="d49462e129" class="indexterm-anchor"></a>. That is, changes to data or structures might be made incorrectly.
                  </p>
                  <p><a id="d49462e133" class="indexterm-anchor"></a>Oracle uses <span class="italic">locks</span> to control concurrent access to data. A lock gives you temporary ownership of a database resource such as a table or row of data. Thus, data cannot be changed by other users until you finish with it. You need never explicitly lock a resource, because default locking mechanisms protect Oracle data and structures. However, you can request <span class="italic">data locks</span> on tables or rows when it is to your advantage to override default locking. You can choose from several <a id="d49462e142" class="indexterm-anchor"></a><span class="italic">modes</span> of locking such as <span class="italic">row share</span> and <span class="italic">exclusive</span>.
                  </p>
                  <p>A <span class="italic">deadlock</span><a id="d49462e160" class="indexterm-anchor"></a> can occur when two or more users try to access the same database object. For example, two users updating the same table might wait if each tries to update a row currently locked by the other. Because each user is waiting for resources held by another user, neither can continue until Oracle breaks the deadlock. Oracle signals an error to the participating transaction that had completed the least amount of work, and the "deadlock detected while waiting for resource" Oracle error code is returned to SQLCODE in the SQLCA.
                  </p>
                  <p>When a table is being queried by one user and updated by another at the same time, Oracle generates a <span class="italic">read-consistent</span> view of the table's data for the query. That is, after a query begins and as it proceeds, the data read by the query does not change. As update activity continues, Oracle takes <span class="italic">snapshots</span> of the table's data and records changes in a <span class="italic">rollback segment</span>. Oracle uses information in the rollback segment to build <a id="d49462e174" class="indexterm-anchor"></a>read-consistent query results and to undo changes if necessary.
                  </p>
               </div>
            </div><a id="ZZPRE736"></a><div class="props_rev_3"><a id="GUID-DA8414EA-887F-4A22-829F-5296ED333300" name="GUID-DA8414EA-887F-4A22-829F-5296ED333300"></a><h3 id="ZZPRE-GUID-DA8414EA-887F-4A22-829F-5296ED333300" class="sect3"><span class="enumeration_section">7.2 </span>How Transactions Guard Your Database
               </h3>
               <div>
                  <p>Oracle is transaction oriented; that is, it uses transactions to ensure data integrity. A <a id="d49462e199" class="indexterm-anchor"></a>transaction is a series of one or more logically related SQL statements you define to accomplish some task. Oracle treats the series of SQL statements as a unit so that all the changes brought about by the statements are either <span class="italic">committed</span> (made permanent) or <a id="d49462e205" class="indexterm-anchor"></a><span class="italic">rolled back</span> (undone) at the same time. If your application program fails in the middle of a transaction, the database is automatically restored to its former (pre-transaction) state. 
                  </p>
                  <p><a id="d49462e213" class="indexterm-anchor"></a>The <a id="d49462e216" class="indexterm-anchor"></a>subsequent sections show you how to define and control transactions. Specifically, you learn how to 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Begin and end transactions</p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">COMMIT</code> statement to make transactions permanent
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">SAVEPOINT</code> statement with the <code class="codeph">ROLLBACK</code> <code class="codeph">TO</code> statement to undo parts of transactions
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">ROLLBACK</code> statement to undo whole transactions
                        </p>
                     </li>
                     <li>
                        <p>Specify the <code class="codeph">RELEASE</code> option to free resources and log off the database
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> statement to set read-only transactions
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> clause or <code class="codeph">LOCK</code> <code class="codeph">TABLE</code> statement to override default locking
                        </p>
                     </li>
                  </ul>
                  <p>For details about the SQL statements discussed in this chapter, see the  <a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF-GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                  </p>
               </div>
            </div><a id="ZZPRE737"></a><div class="props_rev_3"><a id="GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE" name="GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE"></a><h3 id="ZZPRE-GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE" class="sect3"><span class="enumeration_section">7.3 </span>How to Begin and End Transactions
               </h3>
               <div>
                  <p><a id="d49462e308" class="indexterm-anchor"></a><a id="d49462e310" class="indexterm-anchor"></a>You begin a transaction with the first executable SQL statement (other than <code class="codeph">CONNECT</code>) in your program. When one transaction ends, the next executable SQL statement automatically begins another transaction. Thus, every executable statement is part of a transaction. Because they cannot be rolled back and need not be committed, <a id="d49462e318" class="indexterm-anchor"></a>declarative SQL statements are not considered part of a transaction. 
                  </p>
                  <p><a id="d49462e324" class="indexterm-anchor"></a>You end a transaction in one of the following ways:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a id="d49462e332" class="indexterm-anchor"></a>Code a <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> statement, with or without the <code class="codeph">RELEASE</code> option. This <span class="italic">explicitly</span> makes permanent or undoes changes to the database.
                        </p>
                     </li>
                     <li>
                        <p>Code a data definition statement (<code class="codeph">ALTER</code>, <code class="codeph">CREATE</code>, or <code class="codeph">GRANT</code>, for example) that issues an <a id="d49462e361" class="indexterm-anchor"></a>automatic commit before <span class="italic">and</span> after executing. This <span class="italic">implicitly</span> makes permanent changes to the database.
                        </p>
                     </li>
                  </ul>
                  <p><a id="d49462e374" class="indexterm-anchor"></a>A transaction also ends when there is a system failure or your user session stops unexpectedly because of software problems, hardware problems, or a forced interruption. Oracle rolls back the transaction.
                  </p>
                  <p><a id="d49462e378" class="indexterm-anchor"></a>If your program fails in the middle of a transaction, Oracle detects the error and rolls back the transaction. If your operating system fails, Oracle restores the database to its former (pre-transaction) state.
                  </p>
                  <p></p>
               </div>
            </div><a id="ZZPRE738"></a><div class="props_rev_3"><a id="GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7" name="GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7"></a><h3 id="ZZPRE-GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7" class="sect3"><span class="enumeration_section">7.4 </span>About Using the COMMIT Statement
               </h3>
               <div>
                  <p><a id="d49462e405" class="indexterm-anchor"></a>You use the <code class="codeph">COMMIT</code> statement to make changes to the database permanent. Until changes are committed, other users cannot access the changed data; they see it as it <a id="d49462e411" class="indexterm-anchor"></a>was before your transaction began. The <code class="codeph">COMMIT</code> statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the <code class="codeph">COMMIT</code> statement
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a id="d49462e425" class="indexterm-anchor"></a>Makes permanent all changes made to the database during the current transaction
                        </p>
                     </li>
                     <li>
                        <p>Makes these changes visible to other users</p>
                     </li>
                     <li>
                        <p>Erases all savepoints (refer to <a href="defining-controlling-transactions.html#GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E">About Using the ROLLBACK Statement</a>)
                        </p>
                     </li>
                     <li>
                        <p>Releases all row and table locks, but not parse locks</p>
                     </li>
                     <li>
                        <p>Closes cursors referenced in a CURRENT OF clause or, when <code class="codeph">MODE={ANSI13|ORACLE}</code>, closes <span class="italic">all</span> explicit cursors
                        </p>
                     </li>
                     <li>
                        <p>Ends the transaction</p>
                     </li>
                  </ul>
                  <p>When <code class="codeph">MODE={ANSI13|ORACLE}</code>, explicit cursors not referenced in a <code class="codeph">CURRENT OF </code>clause remain open across commits. This can boost performance. For an example, refer to <span class="q">"<a href="defining-controlling-transactions.html#GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190">About Fetching Across Commits</a>"</span>.
                  </p>
                  <p>Because they are part of normal processing, <code class="codeph">COMMIT</code> statements should be placed inline, on the main path through your program. Before your program terminates, it must explicitly commit pending changes. Otherwise, Oracle rolls them back. In the following example, you commit your transaction and disconnect from Oracle:
                  </p><pre class="oac_no_warn" dir="ltr"><a id="d49462e474" class="indexterm-anchor"></a>EXEC SQL COMMIT WORK RELEASE;
</pre><p>The optional keyword WORK provides ANSI compatibility. The <a id="d49462e481" class="indexterm-anchor"></a><a id="d49462e485" class="indexterm-anchor"></a>RELEASE option frees all Oracle resources (locks and cursors) held by your program and logs off the database.
                  </p>
                  <p><a id="d49462e491" class="indexterm-anchor"></a>You need not follow a data definition statement with a COMMIT statement because data definition statements issue an automatic commit before <span class="italic">and</span> after executing. So, whether they succeed or fail, the prior transaction is committed.
                  </p>
               </div>
            </div><a id="ZZPRE739"></a><div class="props_rev_3"><a id="GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E" name="GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E"></a><h3 id="ZZPRE-GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E" class="sect3"><span class="enumeration_section">7.5 </span>About Using the ROLLBACK Statement
               </h3>
               <div>
                  <p><a id="d49462e524" class="indexterm-anchor"></a>You use the <code class="codeph">ROLLBACK</code> statement to undo pending changes made to the database. For example, if you make a mistake such as deleting the wrong row from a table, you can use <code class="codeph">ROLLBACK</code> to restore the original data. The <a id="d49462e535" class="indexterm-anchor"></a><code class="codeph">ROLLBACK</code> statement has no effect on the values of host variables or on the flow of control in your program. Specifically, the <code class="codeph">ROLLBACK</code> statement
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Undoes all changes made to the database during the current transaction</p>
                     </li>
                     <li>
                        <p>Erases all savepoints</p>
                     </li>
                     <li>
                        <p>Ends The Transaction</p>
                     </li>
                     <li>
                        <p>Releases All Row And Table Locks, But Not Parse Locks</p>
                     </li>
                     <li>
                        <p>Closes cursors referenced in a CURRENT OF clause or, when <code class="codeph">MODE={ANSI|ANSI14}</code>, closes <span class="italic">all</span> explicit cursors
                        </p>
                     </li>
                  </ul>
                  <p>When <code class="codeph">MODE={ANSI13|ORACLE}</code>, explicit cursors not referenced in a <code class="codeph">CURRENT OF</code> clause remain open across rollbacks.
                  </p>
                  <p><a id="d49462e576" class="indexterm-anchor"></a>Because they are part of exception processing, <code class="codeph">ROLLBACK</code> statements should be placed in error handling routines, off the main path through your program. In the following <a id="d49462e584" class="indexterm-anchor"></a>example, you roll back your transaction and disconnect from Oracle:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK WORK RELEASE;
</pre><p><a id="d49462e592" class="indexterm-anchor"></a>The optional keyword <code class="codeph">WORK</code> provides ANSI compatibility. The <a id="d49462e600" class="indexterm-anchor"></a><code class="codeph">RELEASE</code> option frees all resources held by your program and logs off the database.
                  </p>
                  <p>If a <code class="codeph">WHENEVER</code> SQLERROR <code class="codeph">GOTO</code> statement branches to an error handling routine that includes a <code class="codeph">ROLLBACK</code> statement, your program might enter an infinite loop if the rollback fails with an error. You can avoid this by coding <code class="codeph">WHENEVER</code> SQLERROR <code class="codeph">CONTINUE</code> before the <code class="codeph">ROLLBACK</code> statement.
                  </p>
                  <p><a id="d49462e629" class="indexterm-anchor"></a>For example, consider the following:
                  </p><pre class="oac_no_warn" dir="ltr"><a id="d49462e635" class="indexterm-anchor"></a>EXEC SQL WHENEVER SQLERROR GOTO sql_error;
FOR EACH new employee
 display 'Employee number? ';
 read emp_number;
 display 'Employee name? ';
 read emp_name;
 EXEC SQL INSERT INTO EMP (EMPNO, ENAME)
 VALUES (:emp_number, :emp_name);
ENDFOR;
...
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display 'Processing error';
 exit program with an error;
</pre><p><a id="d49462e641" class="indexterm-anchor"></a><a id="d49462e645" class="indexterm-anchor"></a>Oracle rolls back transactions if your program terminates abnormally.
                  </p>
               </div><a id="ZZPRE740"></a><div class="props_rev_3"><a id="GUID-95768D5C-6964-47D2-A033-A41810677953" name="GUID-95768D5C-6964-47D2-A033-A41810677953"></a><h4 id="ZZPRE-GUID-95768D5C-6964-47D2-A033-A41810677953" class="sect4"><span class="enumeration_section">7.5.1 </span>Statement-Level Rollbacks
                  </h4>
                  <div>
                     <p>Before executing any SQL statement, Oracle marks an implicit savepoint (not available to you). Then, if the statement fails, Oracle rolls it back automatically and returns the applicable error code to SQLCODE in the SQLCA. For example, if an INSERT statement causes an error by trying to insert a duplicate value in a unique index, the statement is rolled back.</p>
                     <p>Only work started by the failed SQL statement is lost; work done before that statement in the current transaction is kept. Thus, if a data definition statement fails, the automatic commit that precedes it is not undone.</p>
                     <p>Note that before executing a SQL statement, Oracle must parse it, that is, examine it to make sure it follows syntax rules and refers to valid database objects. Errors detected while executing a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
                     <p><a id="d49462e685" class="indexterm-anchor"></a>Oracle can also roll back single SQL statements to break deadlocks. <a id="d49462e690" class="indexterm-anchor"></a>Oracle signals an error to one of the participating transactions and rolls back the current statement in that transaction.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE741"></a><div class="props_rev_3"><a id="GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249" name="GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249"></a><h3 id="ZZPRE-GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249" class="sect3"><span class="enumeration_section">7.6 </span>About Using the SAVEPOINT Statement
               </h3>
               <div>
                  <p><a id="d49462e721" class="indexterm-anchor"></a>You use the <code class="codeph">SAVEPOINT</code> statement to mark and name the current point in the processing of a transaction. Each marked point is called a <span class="italic">savepoint</span>. For <a id="d49462e730" class="indexterm-anchor"></a>example, the following statement marks a savepoint named <span class="italic">start_delete</span>:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SAVEPOINT start_delete;
</pre><p><a id="d49462e741" class="indexterm-anchor"></a>Savepoints let you divide long transactions, giving you more control over complex procedures. For example, if a transaction performs several functions, you can mark a savepoint before each function. Then, if a function fails, you can easily restore the Oracle data to its former state, recover, then reexecute the function.
                  </p>
                  <p><a id="d49462e747" class="indexterm-anchor"></a><a id="d49462e749" class="indexterm-anchor"></a>To undo part of a transaction, you use savepoints with the <code class="codeph">ROLLBACK</code> statement and its <a id="d49462e757" class="indexterm-anchor"></a>T<code class="codeph">O SAVEPOINT</code> clause. The <code class="codeph">TO SAVEPOINT </code>clause lets you roll back to an intermediate statement in the current transaction, so you do not have to undo all your changes. Specifically, the <code class="codeph">ROLLBACK TO SAVEPOINT</code> statement
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Undoes changes made to the database since the specified savepoint was marked</p>
                     </li>
                     <li>
                        <p>Erases all savepoints marked after the specified savepoint</p>
                     </li>
                     <li>
                        <p>Releases all row and table locks acquired since the specified savepoint was marked</p>
                     </li>
                  </ul>
                  <p>In the example, you access the table <code class="codeph">MAIL_LIST</code> to insert new listings, update old <a id="d49462e787" class="indexterm-anchor"></a>listings, and delete (a few) inactive listings. After the delete, you check SQLERRD(3) in the SQLCA for the number of rows deleted. If the number is unexpectedly large, you roll back to the savepoint <span class="italic">start_delete</span>, undoing just the delete.
                  </p><pre class="oac_no_warn" dir="ltr">FOR EACH new customer
 display 'Customer number? ';
 read cust_number;
 display 'Customer name? ';
 read cust_name;
EXEC SQL INSERT INTO MAIL_LIST (CUSTNO, CNAME, STAT)
 VALUES (:cust_number, :cust_name, 'ACTIVE');
ENDFOR;
FOR EACH revised status
 display 'Customer number? ';
 read cust_number;
 display 'New status? ';
 read new_status;
 EXEC SQL UPDATE MAIL_LIST
 SET STAT = :new_status WHERE CUSTNO = :cust_number;
ENDFOR;
-- mark savepoint
EXEC SQL SAVEPOINT start_delete;
EXEC SQL DELETE FROM MAIL_LIST WHERE STAT = 'INACTIVE';
IF sqlca.sqlerrd(3) &lt; 25 THEN -- check number of rows deleted
 display 'Number of rows deleted is ', sqlca.sqlerrd(3);
ELSE
 display 'Undoing deletion of ', sqlca.sqlerrd(3), ' rows';
 EXEC SQL WHENEVER SQLERROR GOTO sql_error;
 EXEC SQL ROLLBACK TO SAVEPOINT start_delete;
ENDIF;
EXEC SQL WHENEVER SQLERROR CONTINUE;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display 'Processing error';
 exit program with an error;
</pre><p><a id="d49462e798" class="indexterm-anchor"></a><a id="d49462e802" class="indexterm-anchor"></a>Note that you cannot specify the <code class="codeph">RELEASE</code> option in a <code class="codeph">ROLLBACK TO SAVEPOINT </code>statement.
                  </p>
                  <p><a id="d49462e814" class="indexterm-anchor"></a>Rolling back to a savepoint erases any savepoints marked after that savepoint. The savepoint to which you roll back, however, is not erased. For example, if you mark five savepoints, then roll back to the third, only the fourth and fifth are erased. A <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> statement erases all savepoints.
                  </p>
                  <p>By default, the number of active savepoints in each user session is limited to 5. An <span class="italic">active</span> savepoint is one that you marked since the last commit or rollback. Your Database Administrator (DBA) can raise the limit by increasing the value of the Oracle <a id="d49462e828" class="indexterm-anchor"></a>initialization parameter <code class="codeph">SAVEPOINTS</code>. If you give two savepoints the same name, the earlier savepoint is erased.
                  </p>
               </div>
            </div><a id="ZZPRE742"></a><div class="props_rev_3"><a id="GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9" name="GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9"></a><h3 id="ZZPRE-GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9" class="sect3"><span class="enumeration_section">7.7 </span>About Using the RELEASE Option
               </h3>
               <div>
                  <p>Oracle rolls back changes automatically if your program terminates abnormally. Abnormal termination occurs when your program does not explicitly commit or roll back work and disconnect from Oracle using the RELEASE option.</p>
                  <p>Normal termination occurs when your program runs its course, closes open cursors, <a id="d49462e862" class="indexterm-anchor"></a>explicitly commits or rolls back work, disconnects from Oracle, and returns control to the user. Your program will exit gracefully if the last SQL statement it executes is either 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT RELEASE;
</pre><p>or</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK RELEASE;
</pre><p><a id="d49462e872" class="indexterm-anchor"></a>Otherwise, locks and cursors acquired by your user session are held after program termination until Oracle recognizes that the user session is no longer active. This might cause other users in a multiuser environment to wait longer than necessary for the locked resources. 
                  </p>
               </div>
            </div><a id="ZZPRE743"></a><div class="props_rev_3"><a id="GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5" name="GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5"></a><h3 id="ZZPRE-GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5" class="sect3"><span class="enumeration_section">7.8 </span>About Using the SET TRANSACTION Statement
               </h3>
               <div>
                  <p>You use the <code class="codeph">SET TRANSACTION</code> statement to begin a read-only or read/write transaction, or to assign your current transaction to a specified rollback segment. A <code class="codeph">COMMIT</code>, <code class="codeph">ROLLBACK</code>, or data definition statement ends a read-only transaction.
                  </p>
                  <p><a id="d49462e913" class="indexterm-anchor"></a>Because they allow "repeatable reads," read-only transactions are useful for running multiple queries against one or more tables while other users update the same tables. <a id="d49462e916" class="indexterm-anchor"></a>During a read-only transaction, all queries refer to the same snapshot of the database, providing a multitable, multiquery, read-consistent view. Other users can continue to query or update data as usual. An <a id="d49462e919" class="indexterm-anchor"></a>example of the <code class="codeph">SET TRANSACTION</code> statement follows: 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY;
</pre><p><a id="d49462e930" class="indexterm-anchor"></a><a id="d49462e934" class="indexterm-anchor"></a>The <code class="codeph">SET TRANSACTION</code> statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. The <a id="d49462e940" class="indexterm-anchor"></a><code class="codeph">READ ONLY</code> parameter is <a id="d49462e947" class="indexterm-anchor"></a>required. Its use does not affect other transactions. Only the <code class="codeph">SELECT</code> (without <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>), <code class="codeph">LOCK TABLE</code>,<code class="codeph"> SET ROLE</code>, <code class="codeph">ALTER SESSION</code>, <code class="codeph">ALTER SYSTEM</code>, <code class="codeph">COMMIT</code>, and <code class="codeph">ROLLBACK</code> statements are allowed in a read-only transaction. 
                  </p>
                  <p>In the <a id="d49462e983" class="indexterm-anchor"></a>example, as a store manager, you check sales activity for the day, the past week, and the past month by using a read-only transaction to generate a summary report. The report is unaffected by other users updating the database during the transaction. 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :daily FROM SALES 
 WHERE SALEDATE = SYSDATE; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :weekly FROM SALES 
 WHERE SALEDATE &gt; SYSDATE - 7; 
 EXEC SQL SELECT SUM(SALEAMT) INTO :monthly FROM SALES 
 WHERE SALEDATE &gt; SYSDATE - 30; 
 EXEC SQL COMMIT WORK; 
-- simply ends the transaction since there are no changes 
-- to make permanent 
-- format and print report</pre></div>
            </div><a id="ZZPRE744"></a><div class="props_rev_3"><a id="GUID-F1679173-0361-43D1-AE04-E5365ED03274" name="GUID-F1679173-0361-43D1-AE04-E5365ED03274"></a><h3 id="ZZPRE-GUID-F1679173-0361-43D1-AE04-E5365ED03274" class="sect3"><span class="enumeration_section">7.9 </span>About Overriding Default Locking
               </h3>
               <div>
                  <p><a id="d49462e1012" class="indexterm-anchor"></a>By default, Oracle <a id="d49462e1015" class="indexterm-anchor"></a>implicitly (automatically) locks many data structures for you. However, you can request specific data locks on rows or tables when it is to your advantage to override default locking. Explicit locking lets you share or deny access to a table for the duration of a transaction or ensure multitable and multiquery read consistency.
                  </p>
                  <p>With the <code class="codeph">SELECT FOR UPDATE OF</code> statement, you can explicitly lock specific rows of a table to make sure they do not change before an update or delete is executed. However, Oracle automatically obtains row-level locks at update or delete time. So, use the <code class="codeph">FOR UPDATE OF</code> clause only if you want to lock the rows <span class="italic">before</span> the update or delete.
                  </p>
                  <p>You can explicitly lock entire tables using the <code class="codeph">LOCK TABLE</code> statement.
                  </p>
               </div><a id="ZZPRE745"></a><div class="props_rev_3"><a id="GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC" name="GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC"></a><h4 id="ZZPRE-GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC" class="sect4"><span class="enumeration_section">7.9.1 </span>About Using the FOR UPDATE OF Clause
                  </h4>
                  <div>
                     <p><a id="d49462e1057" class="indexterm-anchor"></a>When you <code class="codeph">DECLARE</code> a cursor that is referenced in the <code class="codeph">CURRENT</code> <code class="codeph">OF</code> clause of an <code class="codeph">UPDATE</code> or <code class="codeph">DELETE</code> statement, you use the FOR UPDATE OF clause to acquire <a id="d49462e1078" class="indexterm-anchor"></a>exclusive row locks. <code class="codeph">SELECT FOR UPDATE OF</code> identifies the rows that will be updated or deleted, then locks each row in the active set. (All rows are locked at the open, not as they are fetched.) This is useful, for example, when you want to base an update on the existing values in a row. You must make sure the row is not changed by another user before your update.
                     </p>
                     <p>The <code class="codeph">FOR UPDATE OF </code>clause is optional. For instance, instead of
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20 
 FOR UPDATE OF SAL;</pre><p>you can drop the <code class="codeph">FOR UPDATE OF</code> clause and simply code
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR 
 SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 20;
</pre><p>The <code class="codeph">CURRENT OF</code> clause signals the precompiler to add a FOR UPDATE clause if necessary. You use the <code class="codeph">CURRENT OF</code> clause to refer to the latest row fetched from a cursor. 
                     </p>
                  </div>
               </div><a id="ZZPRE746"></a><div class="props_rev_3"><a id="GUID-D860488C-475A-411D-B28E-B31CBF961244" name="GUID-D860488C-475A-411D-B28E-B31CBF961244"></a><h4 id="ZZPRE-GUID-D860488C-475A-411D-B28E-B31CBF961244" class="sect4"><span class="enumeration_section">7.9.2 </span>Restrictions
                  </h4>
                  <div>
                     <p>If you use the <code class="codeph">FOR UPDATE OF</code> clause, you cannot reference multiple tables. Also, an <a id="d49462e1133" class="indexterm-anchor"></a><a id="d49462e1137" class="indexterm-anchor"></a>explicit <code class="codeph">FOR UPDATE OF</code> or an implicit <code class="codeph">FOR UPDATE </code>acquires exclusive row locks. Row locks are released when you commit or rollback (except when you rollback to a savepoint). If you try to fetch from a <code class="codeph">FOR UPDATE</code> cursor after a commit, Oracle generates the following error:
                     </p><pre class="oac_no_warn" dir="ltr">ORA-01002: fetch out of sequence
</pre></div>
               </div><a id="ZZPRE747"></a><div class="props_rev_3"><a id="GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA" name="GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA"></a><h4 id="ZZPRE-GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA" class="sect4"><span class="enumeration_section">7.9.3 </span>About Using the LOCK TABLE Statement
                  </h4>
                  <div>
                     <p><a id="d49462e1181" class="indexterm-anchor"></a>You<a id="d49462e1186" class="indexterm-anchor"></a><a id="d49462e1188" class="indexterm-anchor"></a> use the<code class="codeph"> LOCK TABLE</code> statement to lock one or more tables in a specified lock mode. For example, the statement locks the EMP table in <span class="italic">row share</span> mode. Row share locks allow concurrent access to a table; they prevent other users from locking the entire table for exclusive use.
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL LOCK TABLE EMP IN ROW SHARE MODE NOWAIT;
</pre><p>The lock mode determines what other locks can be placed on the table. For <a id="d49462e1203" class="indexterm-anchor"></a>example, <a id="d49462e1208" class="indexterm-anchor"></a>many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an <span class="italic">exclusive</span> lock. While one user has an exclusive lock on a table, no other users can insert, update, or delete rows in that table. For more information about lock modes, see <a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-912124B7-0F39-47BD-863C-320ED61014E9" target="_blank">SQL Processing for Application Developers</a>.
                     </p>
                     <p><a id="d49462e1221" class="indexterm-anchor"></a>The optional keyword <a id="d49462e1226" class="indexterm-anchor"></a>NOWAIT<a id="d49462e1231" class="indexterm-anchor"></a> tells Oracle not to wait for a table if it has been locked by another user. Control is immediately returned to your program, so it can do other work before trying again to acquire the lock. (You can check SQLCODE in the SQLCA to see if the table lock failed.) If you omit <code class="codeph">NOWAIT</code>, Oracle waits until the table is available; the wait has no set limit.
                     </p>
                     <p><a id="d49462e1240" class="indexterm-anchor"></a>A table lock never keeps other users from querying a table, and a query never acquires a table lock. So, a query never blocks another query or an update, and an update never blocks a query. Only if two different transactions try to update the same row will one transaction wait for the other to complete. Table locks are released when your transaction issues a commit or rollback.
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE748"></a><div class="props_rev_3"><a id="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190" name="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190"></a><h3 id="ZZPRE-GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190" class="sect3"><span class="enumeration_section">7.10 </span>About Fetching Across Commits
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d49462e1267" class="indexterm-anchor"></a>If you want to intermix commits and fetches, do not use the <code class="codeph">CURRENT OF</code> clause. Instead, select the rowid of each row, then use that value to identify the current row during the update or delete. Consider the following example:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR
 SELECT ENAME, SAL, ROWID FROM EMP WHERE JOB = 'CLERK';
...
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND GOTO ...
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary, :row_id;
 ... 
 EXEC SQL UPDATE EMP SET SAL = :new_salary
 WHERE ROWID = :row_id;
 EXEC SQL COMMIT;
ENDLOOP;
</pre><div class="infoboxnote" id="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190__GUID-C6CEFC06-C571-434E-A001-1865F339C9B6">
                        <p class="notep1">Note:</p>
                        <p>The fetched rows are <span class="italic">not</span> locked. So, you might get inconsistent results if another user modifies a row after you read it but before you update or delete it.
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE749"></a><div class="props_rev_3"><a id="GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1" name="GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1"></a><h3 id="ZZPRE-GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1" class="sect3"><span class="enumeration_section">7.11 </span>About Handling Distributed Transactions
               </h3>
               <div>
                  <p>A <span class="italic">distributed database</span> is a single logical database comprising multiple physical databases at different nodes. A <span class="italic">distributed statement</span> is any SQL statement that accesses a remote node using a database link. A <span class="italic">distributed transaction</span> includes at least one distributed statement that updates data at multiple nodes of a distributed database. If the update affects only one node, the transaction is non-distributed.
                  </p>
                  <p><a id="d49462e1315" class="indexterm-anchor"></a>When you issue a commit, changes to each database affected by the distributed transaction are made permanent. If you issue a rollback instead, all the changes are undone. However, if a network or computer fails during the commit or rollback, the state of the distributed transaction might be unknown or <a id="d49462e1320" class="indexterm-anchor"></a><span class="italic">in doubt</span>. In such cases, if you have F<code class="codeph">ORCE TRANSACTION</code> system privileges, you can manually commit or roll back the transaction at your local database by using the <code class="codeph">FORCE</code> clause. The transaction must be identified by a quoted literal containing the transaction ID, which can be found in the data dictionary view <code class="codeph">DBA_2PC_PENDING</code>. Some examples follow:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT FORCE '22.31.83';
...
EXEC SQL ROLLBACK FORCE '25.33.86';
</pre><p><code class="codeph">FORCE</code> commits or rolls back only the specified transaction and does not affect your current transaction. Note that you cannot manually roll back in-doubt transactions to a savepoint.
                  </p>
                  <p>The <code class="codeph">COMMENT</code> clause in the <code class="codeph">COMMIT</code> statement lets you specify a comment to be associated with a distributed transaction. If ever the transaction is in doubt, Oracle stores the text specified by <code class="codeph">COMMENT</code> in the data dictionary view <code class="codeph">DBA_2PC_PENDING </code>along with the transaction ID. The text must be a quoted literal &lt;= 50 characters in length. An example follows:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT COMMENT 'In-doubt trans; notify Order Entry';
</pre><p>For more information about distributed transactions, see <a href="../cncpt/transactions.html#CNCPT-GUID-B97790CB-DF82-442D-B9D5-50CCE6BF9FBD" target="_blank">Transactions</a>.
                  </p>
               </div>
            </div><a id="ZZPRE750"></a><div class="props_rev_3"><a id="GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12" name="GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12"></a><h3 id="ZZPRE-GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12" class="sect3"><span class="enumeration_section">7.12 </span>Guidelines
               </h3>
               <div>
                  <p><a id="d49462e1390" class="indexterm-anchor"></a>The following guidelines will help you avoid some common problems.
                  </p>
               </div><a id="ZZPRE751"></a><div class="props_rev_3"><a id="GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538" name="GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538"></a><h4 id="ZZPRE-GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538" class="sect4"><span class="enumeration_section">7.12.1 </span>About Designing Applications
                  </h4>
                  <div>
                     <p>When designing your application, group logically related actions together in one transaction. A well-designed transaction includes all the steps necessary to accomplish a given task -- no more and no less.</p>
                     <p>Data in the tables you reference must be left in a consistent state. So, the SQL statements in a transaction should change the data in a consistent way. For example, a transfer of funds between two bank accounts should include a debit to one account and a credit to another. Both updates should either succeed or fail together. An unrelated update, such as a new deposit to one account, should not be included in the transaction.</p>
                  </div>
               </div><a id="ZZPRE752"></a><div class="props_rev_3"><a id="GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476" name="GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476"></a><h4 id="ZZPRE-GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476" class="sect4"><span class="enumeration_section">7.12.2 </span>About Obtaining Locks
                  </h4>
                  <div>
                     <p><a id="d49462e1440" class="indexterm-anchor"></a>If your application programs include SQL locking statements, make sure the Oracle users requesting locks have the privileges needed to obtain the locks. Your DBA can lock any table. Other users can lock tables they own or tables for which they have a privilege, such as <code class="codeph">ALTER</code>, <code class="codeph">SELECT</code>, <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>.
                     </p>
                  </div>
               </div><a id="ZZPRE753"></a><div class="props_rev_3"><a id="GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095" name="GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095"></a><h4 id="ZZPRE-GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095" class="sect4"><span class="enumeration_section">7.12.3 </span>About Using PL/SQL
                  </h4>
                  <div>
                     <p><a id="d49462e1488" class="indexterm-anchor"></a>If a PL/SQL block is part of a transaction, commits and rollbacks inside the block affect the whole transaction. In the following example, the rollback undoes changes made by the update <span class="italic">and</span> the insert:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP ...
EXEC SQL EXECUTE
 BEGIN UPDATE emp 
...
 ...
 EXCEPTION
 WHEN DUP_VAL_ON_INDEX THEN
 ROLLBACK;
 END;
END-EXEC;
...
</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>