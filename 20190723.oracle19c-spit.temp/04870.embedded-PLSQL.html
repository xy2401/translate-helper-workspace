<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Embedded PL/SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96466-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="embedded-SQL.html" title="Previous" type="text/html">
      <link rel="next" href="host-tables.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="host-tables.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name"> Introduction and Concepts </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Embedded PL/SQL</li>
            </ol>
            <a id="GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F" name="GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F"></a><a id="LNPCB006"></a>
            
            <h2 id="LNPCB-GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F" class="sect2"><span class="enumeration_chapter">6 </span> Embedded PL/SQL
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter shows you how to improve performance by embedding PL/SQL transaction processing blocks in your program. This chapter has the following sections: </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-5875AEF0-38CC-4BA3-A480-491B91164D66">Embedding PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-E650544F-77AB-40AC-AC1B-46063E12354C">Advantages of PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-4E2650AD-0169-4550-A756-BB649BFF04BA">Embedding PL/SQL Blocks</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-B5776E2F-BD5E-4CD2-8CBC-C266498B006B">Host Variables and PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-1C3A5AAA-B45D-4CFE-A086-BFDCD942EB9F">Indicator Variables and PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-F737A34F-47BC-4E36-A264-C26165B3EE19">Host Tables and PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1">Cursor Usage in Embedded PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-0CE314F6-4867-44C3-B14F-9580BDB621FC">Stored PL/SQL and Java Subprograms</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-8516DBAD-41AE-4A03-8331-6DEF3A2DE831">Sample Program 9: Calling a Stored Procedure</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-PLSQL.html#GUID-78B25FD8-15B5-4253-BC9C-5C7C907DE354">Cursor Variables</a> 
                     </p>
                  </li>
               </ul>
            </div><a id="LNPCB398"></a><div class="props_rev_3"><a id="GUID-5875AEF0-38CC-4BA3-A480-491B91164D66" name="GUID-5875AEF0-38CC-4BA3-A480-491B91164D66"></a><h3 id="LNPCB-GUID-5875AEF0-38CC-4BA3-A480-491B91164D66" class="sect3"><span class="enumeration_section">6.1 </span>Embedding PL/SQL
               </h3>
               <div>
                  <p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement. You can place a PL/SQL block anywhere in a host program that you can place a SQL statement.<a id="d38166e98" class="indexterm-anchor"></a><a id="d38166e102" class="indexterm-anchor"></a></p>
                  <p>To embed a PL/SQL block in your host program, declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the EXEC SQL EXECUTE and END-EXEC keywords.<a id="d38166e108" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB399"></a><div class="props_rev_3"><a id="GUID-7C917325-F581-4308-9633-FF1972F4F8C3" name="GUID-7C917325-F581-4308-9633-FF1972F4F8C3"></a><h4 id="LNPCB-GUID-7C917325-F581-4308-9633-FF1972F4F8C3" class="sect4"><span class="enumeration_section">6.1.1 </span>Host Variables
                  </h4>
                  <div>
                     <p>Inside a PL/SQL block, host variables are global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.<a id="d38166e136" class="indexterm-anchor"></a><a id="d38166e140" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB400"></a><div class="props_rev_3"><a id="GUID-9F511045-8D92-4BA2-AEAC-CE4BD7CBA3BE" name="GUID-9F511045-8D92-4BA2-AEAC-CE4BD7CBA3BE"></a><h4 id="LNPCB-GUID-9F511045-8D92-4BA2-AEAC-CE4BD7CBA3BE" class="sect4"><span class="enumeration_section">6.1.2 </span>VARCHAR Variables
                  </h4>
                  <div>
                     <p>When entering a PL/SQL block, Oracle automatically checks the length fields of VARCHAR host variables. Therefore, you must set the length fields <span class="italic">before</span> the block is entered. For input variables, set the length field to the length of the value stored in the string field. For output variables, set the length field to the maximum length allowed by the string field.<a id="d38166e171" class="indexterm-anchor"></a><a id="d38166e175" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB401"></a><div class="props_rev_3"><a id="GUID-D897BA41-8C02-4B21-BF7D-0E6C33268FCB" name="GUID-D897BA41-8C02-4B21-BF7D-0E6C33268FCB"></a><h4 id="LNPCB-GUID-D897BA41-8C02-4B21-BF7D-0E6C33268FCB" class="sect4"><span class="enumeration_section">6.1.3 </span>Indicator Variables
                  </h4>
                  <div>
                     <p>In a PL/SQL block, you cannot refer to an indicator variable by itself; it must be appended to its associated host variable. Further, if you refer to a host variable with its indicator variable, you must always refer to it that way in the same block.<a id="d38166e204" class="indexterm-anchor"></a><a id="d38166e208" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB402"></a><div class="props_rev_3"><a id="GUID-FEFE1D9C-2490-43D1-8ABF-56286883AAD7" name="GUID-FEFE1D9C-2490-43D1-8ABF-56286883AAD7"></a><h5 id="LNPCB-GUID-FEFE1D9C-2490-43D1-8ABF-56286883AAD7" class="sect5"><span class="enumeration_section">6.1.3.1 </span>Handling NULLs
                     </h5>
                     <div>
                        <p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a NULL to the host variable. When exiting the block, if a host variable is NULL, PL/SQL automatically assigns a value of -1 to the indicator variable.<a id="d38166e236" class="indexterm-anchor"></a><a id="d38166e242" class="indexterm-anchor"></a></p>
                     </div>
                  </div><a id="LNPCB403"></a><div class="props_rev_3"><a id="GUID-EDB24807-508C-434D-83CF-0907751997AD" name="GUID-EDB24807-508C-434D-83CF-0907751997AD"></a><h5 id="LNPCB-GUID-EDB24807-508C-434D-83CF-0907751997AD" class="sect5"><span class="enumeration_section">6.1.3.2 </span>Handling Truncated Values
                     </h5>
                     <div>
                        <p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string.<a id="d38166e270" class="indexterm-anchor"></a><a id="d38166e274" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div><a id="LNPCB404"></a><div class="props_rev_3"><a id="GUID-10E4FE55-5F1C-4C58-860A-666085A14E41" name="GUID-10E4FE55-5F1C-4C58-860A-666085A14E41"></a><h4 id="LNPCB-GUID-10E4FE55-5F1C-4C58-860A-666085A14E41" class="sect4"><span class="enumeration_section">6.1.4 </span>SQLCHECK
                  </h4>
                  <div>
                     <p>You must specify SQLCHECK=SEMANTICS when precompiling a program with an embedded PL/SQL block. You must also use the USERID option.</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-B0794F03-C488-4F87-92D2-6B4BEF74EBFB">Precompiler Options</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB405"></a><div class="props_rev_3"><a id="GUID-E650544F-77AB-40AC-AC1B-46063E12354C" name="GUID-E650544F-77AB-40AC-AC1B-46063E12354C"></a><h3 id="LNPCB-GUID-E650544F-77AB-40AC-AC1B-46063E12354C" class="sect3"><span class="enumeration_section">6.2 </span>Advantages of PL/SQL
               </h3>
               <div>
                  <p>This section looks at some of the features and benefits offered by PL/SQL, such as: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Better performance </p>
                     </li>
                     <li>
                        <p>Integration with Oracle </p>
                     </li>
                     <li>
                        <p>Cursor FOR loops </p>
                     </li>
                     <li>
                        <p>Procedures and functions </p>
                     </li>
                     <li>
                        <p>Packages </p>
                     </li>
                     <li>
                        <p>PL/SQL tables </p>
                     </li>
                     <li>
                        <p>User-defined records </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-E650544F-77AB-40AC-AC1B-46063E12354C__GUID-0CF846CE-3511-473F-B07B-B0F8BCE56C1F">
                     <p class="notep1">See Also:</p><a href="../lnpls/index.html" target="_blank"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about PL/SQL.
                  </div>
               </div><a id="LNPCB406"></a><div class="props_rev_3"><a id="GUID-B15FA86A-5C5B-40DD-8D2D-119D37554C62" name="GUID-B15FA86A-5C5B-40DD-8D2D-119D37554C62"></a><h4 id="LNPCB-GUID-B15FA86A-5C5B-40DD-8D2D-119D37554C62" class="sect4"><span class="enumeration_section">6.2.1 </span>Better Performance
                  </h4>
                  <div>
                     <p>PL/SQL can help you reduce overhead, improve performance, and increase productivity. For example, without PL/SQL, Oracle must process SQL statements one at a time. Each SQL statement results in another call to the Server and higher overhead. However, with PL/SQL, you can send an entire block of SQL statements to the server. This minimizes communication between your application and the server.<a id="d38166e383" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB407"></a><div class="props_rev_3"><a id="GUID-FE1148A5-B0B7-4B35-ADCE-212AB849353F" name="GUID-FE1148A5-B0B7-4B35-ADCE-212AB849353F"></a><h4 id="LNPCB-GUID-FE1148A5-B0B7-4B35-ADCE-212AB849353F" class="sect4"><span class="enumeration_section">6.2.2 </span>Integration with Oracle
                  </h4>
                  <div>
                     <p>PL/SQL is tightly integrated with the server. For example, most PL/SQL datatypes are native to the data dictionary. Furthermore, you can use the %TYPE attribute to base variable declarations on column definitions stored in the data dictionary, as the following example shows:<a id="d38166e411" class="indexterm-anchor"></a><a id="d38166e415" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">job_title  emp.job%TYPE; 
</pre><p>That way, you need not know the exact datatype of the column. Furthermore, if a column definition changes, the variable declaration changes accordingly and automatically. This provides data independence, reduces maintenance costs, and allows programs to adapt as the database changes. </p>
                  </div>
               </div><a id="LNPCB408"></a><div class="props_rev_3"><a id="GUID-41A875C7-C367-48B9-890C-ED82B6A9B758" name="GUID-41A875C7-C367-48B9-890C-ED82B6A9B758"></a><h4 id="LNPCB-GUID-41A875C7-C367-48B9-890C-ED82B6A9B758" class="sect4"><span class="enumeration_section">6.2.3 </span>Cursor FOR Loops
                  </h4>
                  <div>
                     <p>With PL/SQL, you need not use the DECLARE, OPEN, FETCH, and CLOSE statements to define and manipulate a cursor. Instead, you can use a cursor FOR loop, which implicitly declares its loop index as a record, opens the cursor associated with a given query, repeatedly fetches data from the cursor into the record and then closes the cursor. An example follows:<a id="d38166e449" class="indexterm-anchor"></a><a id="d38166e453" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE 
    ... 
BEGIN 
    FOR emprec IN (SELECT empno, sal, comm FROM emp) LOOP 
        IF emprec.comm / emprec.sal &gt; 0.25 THEN ... 
        ... 
    END LOOP; 
END; 
</pre><p>Notice that you use dot notation to reference fields in the record. </p>
                  </div>
               </div><a id="LNPCB409"></a><div class="props_rev_3"><a id="GUID-2BADA87D-DA15-4218-BA7E-C1512A5EB942" name="GUID-2BADA87D-DA15-4218-BA7E-C1512A5EB942"></a><h4 id="LNPCB-GUID-2BADA87D-DA15-4218-BA7E-C1512A5EB942" class="sect4"><span class="enumeration_section">6.2.4 </span>Subprograms
                  </h4>
                  <div>
                     <p>PL/SQL has two types of subprograms called <span class="italic">procedures</span> and <span class="italic">functions</span>, which aid application development by letting you isolate operations. Generally, you use a procedure to perform an action and a function to compute a value. <a id="d38166e492" class="indexterm-anchor"></a><a id="d38166e496" class="indexterm-anchor"></a><a id="d38166e500" class="indexterm-anchor"></a></p>
                     <p>Procedures and functions provide <span class="italic">extensibility</span>. That is, they let you tailor the PL/SQL language to suit your needs. For example, if you need a procedure that creates a new department, you can write your own, such as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">PROCEDURE create_dept 
    (new_dname  IN CHAR(14), 
     new_loc    IN CHAR(13), 
     new_deptno OUT NUMBER(2)) IS 
BEGIN 
    SELECT deptno_seq.NEXTVAL INTO new_deptno FROM dual; 
    INSERT INTO dept VALUES (new_deptno, new_dname, new_loc); 
END create_dept; 
</pre><p>When called, this procedure accepts a new department name and location, selects the next value in a department-number database sequence, inserts the new number, name, and location into the <span class="italic">dept</span> table and then returns the new number to the caller. 
                     </p>
                     <p>You can store subprograms in the database (using CREATE FUNCTION and CREATE PROCEDURE) that can be called from multiple applications without needing to be re-compiled each time.</p>
                  </div><a id="LNPCB410"></a><div class="props_rev_3"><a id="GUID-6A6B5E5A-7255-4C75-9C33-3E688BDD215B" name="GUID-6A6B5E5A-7255-4C75-9C33-3E688BDD215B"></a><h5 id="LNPCB-GUID-6A6B5E5A-7255-4C75-9C33-3E688BDD215B" class="sect5"><span class="enumeration_section">6.2.4.1 </span>Parameter Modes
                     </h5>
                     <div>
                        <p>You use <span class="italic">parameter modes</span> to define the behavior of formal parameters. There are three parameter modes: IN (the default), OUT, and IN OUT. An IN parameter lets you pass values to the subprogram being called. An OUT parameter lets you return values to the caller of a subprogram. An IN OUT parameter lets you pass initial values to the subprogram being called and return updated values to the caller.<a id="d38166e543" class="indexterm-anchor"></a><a id="d38166e545" class="indexterm-anchor"></a><a id="d38166e547" class="indexterm-anchor"></a><a id="d38166e549" class="indexterm-anchor"></a><a id="d38166e551" class="indexterm-anchor"></a> 
                        </p>
                        <p>The datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. <a href="embedded-PLSQL.html#GUID-F737A34F-47BC-4E36-A264-C26165B3EE19__BEIDDGEA" title="q">Table 6-1</a> shows the legal conversions between datatypes. 
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB411"></a><div class="props_rev_3"><a id="GUID-C1BEF847-BA1F-414E-B5CE-EAAB36BAD7F5" name="GUID-C1BEF847-BA1F-414E-B5CE-EAAB36BAD7F5"></a><h4 id="LNPCB-GUID-C1BEF847-BA1F-414E-B5CE-EAAB36BAD7F5" class="sect4"><span class="enumeration_section">6.2.5 </span>Packages
                  </h4>
                  <div>
                     <p>PL/SQL lets you bundle logically related types, program objects, and subprograms into a <span class="italic">package</span>. Packages can be compiled and stored in a database, where their contents can be shared by multiple applications.<a id="d38166e588" class="indexterm-anchor"></a><a id="d38166e592" class="indexterm-anchor"></a></p>
                     <p>Packages usually have two parts: a specification and a body. The <span class="italic">specification</span> is the interface to your applications; it declares the types, constants, variables, exceptions, cursors, and subprograms available for use. The <span class="italic">body</span> defines cursors and subprograms and so implements the specification. The following example  "packages" two employment procedures: 
                     </p><pre class="oac_no_warn" dir="ltr">PACKAGE emp_actions IS  -- package specification 
    PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...); 
    PROCEDURE fire_employee (emp_id NUMBER); 
END emp_actions; 

PACKAGE BODY emp_actions IS  -- package body 
    PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...) IS 
    BEGIN 
        INSERT INTO emp VALUES (empno, ename, ...); 
    END hire_employee; 
    PROCEDURE fire_employee (emp_id NUMBER) IS 
    BEGIN 
        DELETE FROM emp WHERE empno = emp_id; 
    END fire_employee; 
END emp_actions; 
</pre><p>Only the declarations in the package specification are visible and accessible to applications. Implementation details in the package body are hidden and inaccessible. </p>
                  </div>
               </div><a id="LNPCB412"></a><div class="props_rev_3"><a id="GUID-992D2D7E-7387-40F8-94EA-E8F90DB57932" name="GUID-992D2D7E-7387-40F8-94EA-E8F90DB57932"></a><h4 id="LNPCB-GUID-992D2D7E-7387-40F8-94EA-E8F90DB57932" class="sect4"><span class="enumeration_section">6.2.6 </span>PL/SQL Tables
                  </h4>
                  <div>
                     <p>PL/SQL provides a composite datatype named TABLE. Objects of type TABLE are called <span class="italic">PL/SQL tables</span>, which are modeled as (but not the same as) database tables. PL/SQL tables have only one column and use a primary key to give you array-like access to rows. The column can belong to any scalar type (such as CHAR, DATE, or NUMBER), but the primary key must belong to type BINARY_INTEGER, PLS_INTEGER or VARCHAR2.<a id="d38166e636" class="indexterm-anchor"></a><a id="d38166e638" class="indexterm-anchor"></a> 
                     </p>
                     <p>You can declare PL/SQL table types in the declarative part of any block, procedure, function, or package. The following example declares a TABLE type called <span class="italic">NumTabTyp</span>: 
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE 
    TYPE NumTabTyp IS TABLE OF NUMBER 
        INDEX BY BINARY_INTEGER; 
    ... 
BEGIN 
    ... 
END; 
</pre><p>Once you define type <span class="italic">NumTabTyp</span>, you can declare PL/SQL tables of that type, as the next example shows: 
                     </p><pre class="oac_no_warn" dir="ltr">num_tab  NumTabTyp; 
</pre><p>The identifier <span class="italic">num_tab</span> represents an entire PL/SQL table. 
                     </p>
                     <p>You reference rows in a PL/SQL table using array-like syntax to specify the primary key value. For example, you reference the ninth row in the PL/SQL table named <span class="italic">num_tab</span> as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">num_tab(9) ... </pre></div>
               </div><a id="LNPCB413"></a><div class="props_rev_3"><a id="GUID-9852B57C-505E-4DBE-BFEC-E0793CF18AA9" name="GUID-9852B57C-505E-4DBE-BFEC-E0793CF18AA9"></a><h4 id="LNPCB-GUID-9852B57C-505E-4DBE-BFEC-E0793CF18AA9" class="sect4"><span class="enumeration_section">6.2.7 </span>User-Defined Records
                  </h4>
                  <div>
                     <p>You can use the %ROWTYPE attribute to declare a record that represents a row in a database table or a row fetched by a cursor. However, you cannot specify the datatypes of fields in the record or define fields of your own. The composite datatype RECORD lifts those restrictions.<a id="d38166e693" class="indexterm-anchor"></a><a id="d38166e695" class="indexterm-anchor"></a><a id="d38166e697" class="indexterm-anchor"></a><a id="d38166e701" class="indexterm-anchor"></a> 
                     </p>
                     <p>Objects of type RECORD are called <span class="italic">records</span>. Unlike PL/SQL tables, records have uniquely named fields, which can belong to different datatypes. For example, suppose you have different kinds of data about an employee such as name, salary, hire date, and so on. This data is dissimilar in type but logically related. A record that contains such fields as the name, salary, and hire date of an employee would let you treat the data as a logical unit. 
                     </p>
                     <p>You can declare record types and objects in the declarative part of any block, procedure, function, or package. The following example declares a RECORD type called <span class="italic">DeptRecTyp</span>: 
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE 
    TYPE DeptRecTyp IS RECORD 
        (deptno  NUMBER(4) NOT NULL := 10,  -- must initialize
         dname   CHAR(9), 
         loc     CHAR(14)); 
</pre><p>Notice that the field declarations are like variable declarations. Each field has a unique name and specific datatype. You can add the NOT NULL option to any field declaration and so prevent the assigning of NULLs to that field. However, you must initialize NOT NULL fields.</p>
                     <p>Once you define type <span class="italic">DeptRecTyp</span>, you can declare records of that type, as the next example shows: 
                     </p><pre class="oac_no_warn" dir="ltr">dept_rec  DeptRecTyp; 
</pre><p>The identifier <span class="italic">dept_rec</span> represents an entire record. 
                     </p>
                     <p>You use dot notation to reference individual fields in a record. For example, you reference the <span class="italic">dname</span> field in the <span class="italic">dept_rec</span> record as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">dept_rec.dname ... </pre></div>
               </div>
            </div><a id="LNPCB414"></a><div class="props_rev_3"><a id="GUID-4E2650AD-0169-4550-A756-BB649BFF04BA" name="GUID-4E2650AD-0169-4550-A756-BB649BFF04BA"></a><h3 id="LNPCB-GUID-4E2650AD-0169-4550-A756-BB649BFF04BA" class="sect3"><span class="enumeration_section">6.3 </span>Embedding PL/SQL Blocks
               </h3>
               <div>
                  <p>Pro*COBOL treats a PL/SQL block like a single embedded SQL statement. Thus, you can place a PL/SQL block anywhere in a host program that you can place a SQL statement.<a id="d38166e767" class="indexterm-anchor"></a><a id="d38166e771" class="indexterm-anchor"></a> 
                  </p>
                  <p>To embed a PL/SQL block in your host program, simply bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC as follows: </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
         DECLARE 
         ... 
         BEGIN 
         ... 
         END;
     END-EXEC. 
</pre><p>When your program embeds PL/SQL blocks, you must specify the precompiler option SQLCHECK=SEMANTICS because PL/SQL must be parsed by Pro*COBOL. To connect to the server, you must also specify the option USERID.<a id="d38166e782" class="indexterm-anchor"></a><a id="d38166e786" class="indexterm-anchor"></a></p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-4FAE1823-EDA0-4A86-B904-FC7FA3CD472B">Using Pro*COBOL Precompiler Options</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCB415"></a><div class="props_rev_3"><a id="GUID-B5776E2F-BD5E-4CD2-8CBC-C266498B006B" name="GUID-B5776E2F-BD5E-4CD2-8CBC-C266498B006B"></a><h3 id="LNPCB-GUID-B5776E2F-BD5E-4CD2-8CBC-C266498B006B" class="sect3"><span class="enumeration_section">6.4 </span>Host Variables and PL/SQL
               </h3>
               <div>
                  <p>Host variables are the key to communication between a host language and a PL/SQL block. Host variables can be shared with PL/SQL, meaning that PL/SQL can set and reference host variables. </p>
                  <p>For example, you can prompt a user for information and use host variables to pass that information to a PL/SQL block. Then, PL/SQL can access the database and use host variables to pass the results back to your host program.<a id="d38166e821" class="indexterm-anchor"></a> 
                  </p>
                  <p>Inside a PL/SQL block, host variables are treated as global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects. </p>
               </div><a id="LNPCB416"></a><div class="props_rev_3"><a id="GUID-9BEF31AA-DA7E-4642-8C22-FE3EC8118657" name="GUID-9BEF31AA-DA7E-4642-8C22-FE3EC8118657"></a><h4 id="LNPCB-GUID-9BEF31AA-DA7E-4642-8C22-FE3EC8118657" class="sect4"><span class="enumeration_section">6.4.1 </span>PL/SQL Examples
                  </h4>
                  <div>
                     <p>The following example illustrates the use of host variables with PL/SQL. The program prompts the user for an employee number and then displays the job title, hire date, and salary of that employee.<a id="d38166e858" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 USERNAME   PIC X(20) VARYING.
 01 PASSWORD   PIC X(20) VARYING.
 01 EMP-NUMBER PIC S9(4) COMP.
 01 JOB-TITLE  PIC X(20) VARYING.
 01 HIRE-DATE  PIC X(9) VARYING.
 01 SALARY     PIC S9(6)V99
                          DISPLAY SIGN LEADING SEPARATE.
     EXEC SQL END DECLARE SECTION END-EXEC. 
     EXEC SQL INCLUDE SQLCA END-EXEC. 
     ...
     DISPLAY 'Connected to Oracle'. 
 PERFORM
     DISPLAY 'Employee Number (0 to end)? 'WITH NO ADVANCING 
     ACCEPT EMP-NUMBER 
     IF EMP-NUMBER = 0  
         EXEC SQL COMMIT WORK RELEASE END-EXEC 
         DISPLAY 'Exiting program' 
         STOP RUN
     END-IF. 
*   ---------------- begin PL/SQL block ----------------- 
     EXEC SQL EXECUTE 
        BEGIN 
            SELECT job, hiredate, sal 
                INTO :JOB-TITLE, :HIRE-DATE, :SALARY 
                FROM EMP 
                WHERE EMPNO = :EMP-NUMBER; 
        END; 
     END-EXEC. 
*    ---------------- end PL/SQL block ----------------- 
     DISPLAY 'Number  Job Title  Hire Date  Salary'. 
     DISPLAY '------------------------------------'. 
     DISPLAY EMP-NUMBER, JOB-TITLE, HIRE-DATE, SALARY. 
 END-PERFORM. 
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC. 
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC. 
     DISPLAY 'Processing error'. 
     STOP RUN.
</pre><p>Notice that the host variable <span class="italic">EMP-NUMBER </span>is set before the PL/SQL block is entered, and the host variables <span class="italic">JOB-TITLE, HIRE-DATE</span>, and <span class="italic">SALARY</span> are set inside the block. 
                     </p>
                  </div>
               </div><a id="LNPCB417"></a><div class="props_rev_3"><a id="GUID-8919B1B9-30CB-4231-A032-8CCE74E28C2C" name="GUID-8919B1B9-30CB-4231-A032-8CCE74E28C2C"></a><h4 id="LNPCB-GUID-8919B1B9-30CB-4231-A032-8CCE74E28C2C" class="sect4"><span class="enumeration_section">6.4.2 </span>A More Complex PL/SQL Example
                  </h4>
                  <div>
                     <p>In the following example the user is prompted for a bank account number, transaction type, and transaction amount. The account is then debited or credited. If the account does not exist, an exception is raised. When the transaction is complete its status is displayed.<a id="d38166e900" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
 01 USERNAME   PIC X(20) VARYING.
 01 ACCT-NUM   PIC S9(4) COMP.
 01 TRANS-TYPE PIC X(1).
 01 TRANS-AMT  PIC PIC S9(6)V99
                       DISPLAY SIGN LEADING SEPARATE.
 01 STATUS     PIC X(80) VARYING.
    EXEC SQL END DECLARE SECTION END-EXEC.
     EXEC SQL INCLUDE SQLCA END-EXEC. 
     DISPLAY 'Username? 'WITH NO ADVANCING. 
     ACCEPT USERNAME. 
     DISPLAY 'Password? '. 
     ACCEPT PASSWORD. 
     EXEC SQL WHENEVER SQLERROR DO PERFORM SQL-ERROR. 
     EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD. 
     PERFORM 
     DISPLAY 'Account Number (0 to end)? '
         WITH NO ADVANCING 
     ACCEPT ACCT_NUM 
     IF ACCT-NUM = 0
         EXEC SQL COMMIT WORK RELEASE END-EXEC 
         DISPLAY 'Exiting program' WITH NO ADVANCING 
         STOP RUN 
     END-IF.
     DISPLAY 'Transaction Type - D)ebit or C)redit? ' 
         WITH NO ADVANCING
     ACCEPT TRANS-TYPE 
     DISPLAY 'Transaction Amount? ' 
     ACCEPT trans_amt 
*   --------------------- begin PL/SQL block ------------------- 
     EXEC SQL EXECUTE 
        DECLARE 
            old_bal      NUMBER(9,2); 
            err_msg      CHAR(70); 
            nonexistent  EXCEPTION; 
        BEGIN 
           IF :TRANS-TYP-TYPE = 'C' THEN       -- credit the account 
                UPDATE accts SET bal = bal + :TRANS-AMT 
                    WHERE acctid = :acct-num; 
                IF SQL%ROWCOUNT = 0 THEN    -- no rows affected 
                    RAISE nonexistent; 
                ELSE 
                   :STATUs := 'Credit applied'; 
                END IF; 
            ELSIF :TRANS-TYPe = 'D' THEN    -- debit the account 
                SELECT bal INTO old_bal FROM accts 
                    WHERE acctid = :ACCT-NUM; 
                IF old_bal &gt;= :TRANS-AMT THEN   -- enough funds 
                    UPDATE accts SET bal = bal - :TRANS-AMT 
                        WHERE acctid = :ACCT-NUM; 
                    :STATUS := 'Debit applied'; 
                ELSE 
                    :STATUS := 'Insufficient funds'; 
                END IF; 
            ELSE 
              :STATUS := 'Invalid type: ' || :TRANS-TYPE; 
            END IF; 
            COMMIT; 
        EXCEPTION 
            WHEN NO_DATA_FOUND OR nonexistent THEN 
                :STATUS := 'Nonexistent account'; 
            WHEN OTHERS THEN 
                err_msg := SUBSTR(SQLERRM, 1, 70); 
               :STATUS := 'Error: ' || err_msg; 
        END; 
     END-EXEC. 
*     ------------------- end PL/SQL block ----------------------- 
     DISPLAY 'Status: ', STATUS 
 END-PERFORM.
     ...
 SQL-ERROR.
     EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC. 
     EXEC SQL ROLLBACK WORK RELEASE END-EXEC. 
     DISPLAY 'Processing error'. 
     STOP RUN. 
</pre></div>
               </div><a id="LNPCB418"></a><div class="props_rev_3"><a id="GUID-823348E3-97F8-4020-91F2-4B1F087C62DB" name="GUID-823348E3-97F8-4020-91F2-4B1F087C62DB"></a><h4 id="LNPCB-GUID-823348E3-97F8-4020-91F2-4B1F087C62DB" class="sect4"><span class="enumeration_section">6.4.3 </span>VARCHAR Pseudotype
                  </h4>
                  <div>
                     <p>Recall that you can use the VARCHAR pseudotype to declare variable-length character strings. If the VARCHAR is an input host variable, you must tell Pro*COBOL what length to expect. Therefore, set the length field to the actual length of the value stored in the string field. </p>
                     <p>If the VARCHAR is an output host variable, Pro*COBOL automatically sets the length field. However, to use a VARCHAR output host variable in your PL/SQL block, you must initialize the length field <span class="italic">before</span> entering the block. Therefore, set the length field to the declared (maximum) length of the VARCHAR, as shown in the following example:<a id="d38166e937" class="indexterm-anchor"></a><a id="d38166e941" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
        01 EMP-NUM   PIC S9(4) COMP.
        01 EMP-NAME  PIC X(10) VARYING.
        01 SALARY    PIC S9(6)V99
                     DISPLAY SIGN LEADING SEPARATE.
     ... 
     EXEC SQL END DECLARE SECTION END-EXEC.
 PROCEDURE DIVISION.
     ...
* -- initialize length field 
     MOVE 10 TO EMP-NAME-LEN.
     EXEC SQL EXECUTE 
     BEGIN 
        SELECT ename, sal INTO :EMP-NAME, :SALARY 
            FROM emp 
            WHERE empno = :EMP-NUM; 
        ... 
     END; 
     END-EXEC. </pre></div>
               </div>
            </div><a id="LNPCB419"></a><div class="props_rev_3"><a id="GUID-1C3A5AAA-B45D-4CFE-A086-BFDCD942EB9F" name="GUID-1C3A5AAA-B45D-4CFE-A086-BFDCD942EB9F"></a><h3 id="LNPCB-GUID-1C3A5AAA-B45D-4CFE-A086-BFDCD942EB9F" class="sect3"><span class="enumeration_section">6.5 </span>Indicator Variables and PL/SQL
               </h3>
               <div>
                  <p>PL/SQL does not need indicator variables because it can manipulate NULLs. For example, within PL/SQL, you can use the IS NULL operator to test for NULLs, as follows:<a id="d38166e972" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">IF variable IS NULL THEN ... 
</pre><p>You can use the assignment operator (:=) to assign NULLs, as follows: </p><pre class="oac_no_warn" dir="ltr">variable := NULL; 
</pre><p>However, host languages need indicator variables because they cannot manipulate NULLs. Embedded PL/SQL meets this need by letting you use indicator variables to:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Accept NULLs input from a host program </p>
                     </li>
                     <li>
                        <p>Output NULLs or truncated values to a host program </p>
                     </li>
                  </ul>
                  <p>When used in a PL/SQL block, indicator variables are subject to the following rule:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>If you refer to a host variable with an indicator variable, you must always refer to it that way in the same block. </p>
                     </li>
                  </ul>
                  <p>In the following example, the indicator variable <span class="italic">IND-COMM</span> appears with its host variable <span class="italic">COMMISSION</span> in the SELECT statement, so it must appear that way in the IF statement: 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
     BEGIN 
        SELECT ename, comm 
            INTO :EMP-NAME, :COMMISSION:IND-COMM FROM emp 
            WHERE empno = :EMP-NUM; 
        IF :COMMISSION:IND-COMM IS NULL THEN ... 
        ... 
     END; 
     END-EXEC. 
</pre><p>Notice that PL/SQL treats <span class="italic">:COMMISSION:IND-COMM</span> like any other simple variable. Though you cannot refer directly to an indicator variable inside a PL/SQL block, PL/SQL checks the value of the indicator variable when entering the block and sets the value correctly when exiting the block. 
                  </p>
               </div><a id="LNPCB420"></a><div class="props_rev_3"><a id="GUID-188BFFC2-65EE-4787-A817-094DC0B2F24B" name="GUID-188BFFC2-65EE-4787-A817-094DC0B2F24B"></a><h4 id="LNPCB-GUID-188BFFC2-65EE-4787-A817-094DC0B2F24B" class="sect4"><span class="enumeration_section">6.5.1 </span>Handling NULLs
                  </h4>
                  <div>
                     <p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a NULL to the host variable. When exiting the block, if a host variable is NULL, PL/SQL automatically assigns a value of -1 to the indicator variable. In the next example, if <span class="italic">IND-SAL</span> had a value of -1 before the PL/SQL block was entered, the <span class="italic">salary_missing</span> exception is raised. An <span class="italic">exception</span> is a named error condition. <a id="d38166e1045" class="indexterm-anchor"></a><a id="d38166e1047" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">    EXEC SQL EXECUTE 
    BEGIN 
        IF :SALARY:IND-SAL IS NULL THEN 
            RAISE salary_missing; 
        END IF; 
        ... 
    END; 
    END-EXEC. </pre></div>
               </div><a id="LNPCB421"></a><div class="props_rev_3"><a id="GUID-DB2A26EF-30A1-4BBE-ACB0-BBC540657042" name="GUID-DB2A26EF-30A1-4BBE-ACB0-BBC540657042"></a><h4 id="LNPCB-GUID-DB2A26EF-30A1-4BBE-ACB0-BBC540657042" class="sect4"><span class="enumeration_section">6.5.2 </span>Handling Truncated Values
                  </h4>
                  <div>
                     <p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string. The following example the host program will be able to tell, by checking the value of <span class="italic">IND-NAME</span>, if a truncated value was assigned to <span class="italic">EMP-NAME</span>: <a id="d38166e1083" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
     DECLARE 
        ... 
        new_name  CHAR(10); 
     BEGIN 
        ... 
        :EMP_NAME:IND-NAME := new_name; 
        ... 
     END; 
     END-EXEC. </pre></div>
               </div>
            </div><a id="LNPCB423"></a><a id="LNPCB422"></a><div class="props_rev_3"><a id="GUID-F737A34F-47BC-4E36-A264-C26165B3EE19" name="GUID-F737A34F-47BC-4E36-A264-C26165B3EE19"></a><h3 id="LNPCB-GUID-F737A34F-47BC-4E36-A264-C26165B3EE19" class="sect3"><span class="enumeration_section">6.6 </span>Host Tables and PL/SQL
               </h3>
               <div>
                  <p>You can pass input host tables and indicator tables to a PL/SQL block. They can be indexed by a PL/SQL variable of type BINARY_INTEGER or PLS_INTEGER; VARCHAR2 key types are not permitted. Normally, the entire host table is passed to PL/SQL, but you can use the ARRAYLEN statement (discussed later) to specify a smaller table dimension. </p>
                  <p>Furthermore, you can use a subprogram call to assign all the values in a host table to rows in a PL/SQL table. Given that the table subscript range is <span class="italic">m</span> .. <span class="italic">n</span>, the corresponding PL/SQL table index range is always 1 ..<span class="italic"> (n</span> -<span class="italic"> m</span> + 1). For example, if the table subscript range is 5 .. 10, the corresponding PL/SQL table index range is 1 .. (10 - 5 + 1) or 1 .. 6. 
                  </p>
                  <p><span class="bold">Note: </span> Pro*COBOL does not check your usage of host tables. For instance, no index range checking is done. 
                  </p>
                  <p>In the following example, you pass a host table named <span class="italic">salary</span> to a PL/SQL block, which uses the host table in a function call. The function is named <span class="italic">median</span> because it finds the middle value in a series of numbers. Its formal parameters include a PL/SQL table named <span class="italic">num_tab</span>. The function call assigns all the values in the actual parameter <span class="italic">salary</span> to rows in the formal parameter <span class="italic">num_tab</span>. 
                  </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC. 
     ... 
 01  SALARY OCCURS 100 TIMES PIC S9(6)V99 COMP-3.
 01  MEDIAN-SALARY  PIC S9(6)V99 COMP-3.
     EXEC SQL END DECLARE SECTION END-EXEC. 
* -- populate the host table 
     EXEC SQL EXECUTE 
     DECLARE 
        TYPE NumTabTyp IS TABLE OF REAL 
            INDEX BY BINARY_INTEGER; 
        n  BINARY_INTEGER; 
        ... 
        FUNCTION median (num_tab NumTabTyp, n INTEGER) 
            RETURN REAL IS 
        BEGIN 
* -- compute median 
        END; 
     BEGIN 
        n := 100; 
        :MEDIAN-SALARY := median(:SALARY    END; 
     END-EXEC. 
</pre><p>You can also use a subprogram call to assign all row values in a PL/SQL table to corresponding elements in a host table. For an example, see <span class="q">"<a href="embedded-PLSQL.html#GUID-0CE314F6-4867-44C3-B14F-9580BDB621FC">Stored PL/SQL and Java Subprograms</a>"</span>.
                  </p>
                  <p>The interface between Host Tables and PL/SQL strictly controls datatypes. The default external type for PIC X is CHARF (fixed length character string) and this can only be mapped to PL/SQL tables of type CHAR.</p>
                  <p><a href="embedded-PLSQL.html#GUID-F737A34F-47BC-4E36-A264-C26165B3EE19__BEIDDGEA" title="q">Table 6-1</a> shows the legal conversions between row values in a PL/SQL table and elements in a host table. The most notable fact is that you cannot pass a PIC X variable to a table of type VARCHAR2 without using datatype equivalencing to equivalence the variable to VARCHAR2, or using PICX=VARCHAR2 on the command line. 
                  </p>
                  <div class="tblformalwide" id="GUID-F737A34F-47BC-4E36-A264-C26165B3EE19__BEIDDGEA">
                     <p class="titleintable">Table 6-1 Legal Datatype Conversions </p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Legal Datatype Conversions " summary="q" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="15%" id="d38166e1182">PL/SQL Table</th>
                              <th align="left" valign="bottom" width="8%" id="d38166e1185">-</th>
                              <th align="left" valign="bottom" width="9%" id="d38166e1188">-</th>
                              <th align="left" valign="bottom" width="11%" id="d38166e1191">-</th>
                              <th align="left" valign="bottom" width="13%" id="d38166e1194">-</th>
                              <th align="left" valign="bottom" width="12%" id="d38166e1197">-</th>
                              <th align="left" valign="bottom" width="8%" id="d38166e1200">-</th>
                              <th align="left" valign="bottom" width="11%" id="d38166e1203">-</th>
                              <th align="left" valign="bottom" width="13%" id="d38166e1206">-</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1211" headers="d38166e1182 ">
                                 <p>Host Table</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1211 d38166e1185 ">
                                 <p>CHAR</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1211 d38166e1188 ">
                                 <p>DATE</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1211 d38166e1191 ">
                                 <p>LONG</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1211 d38166e1194 ">
                                 <p>LONG RAW</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1211 d38166e1197 ">
                                 <p>NUMBER</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1211 d38166e1200 ">
                                 <p>RAW</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1211 d38166e1203 ">
                                 <p>ROWID</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1211 d38166e1206 ">
                                 <p>VARCHAR2</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1239" headers="d38166e1182 ">
                                 <p>CHARF</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1239 d38166e1185 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1239 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1239 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1239 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1239 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1239 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1239 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1239 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1267" headers="d38166e1182 ">
                                 <p>CHARZ</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1267 d38166e1185 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1267 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1267 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1267 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1267 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1267 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1267 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1267 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1295" headers="d38166e1182 ">
                                 <p>DATE</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1295 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1295 d38166e1188 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1295 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1295 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1295 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1295 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1295 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1295 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1323" headers="d38166e1182 ">
                                 <p>DECIMAL</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1323 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1323 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1323 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1323 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1323 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1323 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1323 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1323 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1351" headers="d38166e1182 ">
                                 <p>DISPLAY</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1351 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1351 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1351 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1351 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1351 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1351 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1351 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1351 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1379" headers="d38166e1182 ">
                                 <p>FLOAT</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1379 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1379 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1379 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1379 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1379 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1379 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1379 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1379 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1407" headers="d38166e1182 ">
                                 <p>INTEGER</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1407 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1407 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1407 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1407 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1407 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1407 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1407 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1407 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1435" headers="d38166e1182 ">
                                 <p>LONG</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1435 d38166e1185 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1435 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1435 d38166e1191 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1435 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1435 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1435 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1435 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1435 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1463" headers="d38166e1182 ">
                                 <p>LONG VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1463 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1463 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1463 d38166e1191 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1463 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1463 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1463 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1463 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1463 d38166e1206 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1491" headers="d38166e1182 ">
                                 <p>LONG VARRAW</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1491 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1491 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1491 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1491 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1491 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1491 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1491 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1491 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1520" headers="d38166e1182 ">
                                 <p>NUMBER</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1520 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1520 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1520 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1520 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1520 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1520 d38166e1200 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1520 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1520 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1547" headers="d38166e1182 ">
                                 <p>RAW</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1547 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1547 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1547 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1547 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1547 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1547 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1547 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1547 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1575" headers="d38166e1182 ">
                                 <p>ROWID</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1575 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1575 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1575 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1575 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1575 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1575 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1575 d38166e1203 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1575 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1603" headers="d38166e1182 ">
                                 <p>STRING</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1603 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1603 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1603 d38166e1191 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1603 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1603 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1603 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1603 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1603 d38166e1206 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1631" headers="d38166e1182 ">
                                 <p>UNSIGNED</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1631 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1631 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1631 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1631 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1631 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1631 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1631 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1631 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1659" headers="d38166e1182 ">
                                 <p>VARCHAR</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1659 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1659 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1659 d38166e1191 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1659 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1659 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1659 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1659 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1659 d38166e1206 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1687" headers="d38166e1182 ">
                                 <p>VARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1687 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1687 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1687 d38166e1191 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1687 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1687 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1687 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1687 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1687 d38166e1206 ">
                                 <p>X</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1715" headers="d38166e1182 ">
                                 <p>VARNUM</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1715 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1715 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1715 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1715 d38166e1194 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1715 d38166e1197 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1715 d38166e1200 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1715 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1715 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d38166e1743" headers="d38166e1182 ">
                                 <p>VARRAW</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1743 d38166e1185 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="9%" headers="d38166e1743 d38166e1188 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1743 d38166e1191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1743 d38166e1194 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d38166e1743 d38166e1197 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="8%" headers="d38166e1743 d38166e1200 ">
                                 <p>X</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d38166e1743 d38166e1203 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d38166e1743 d38166e1206 ">
                                 <p>-</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="LNPCB424"></a><div class="props_rev_3"><a id="GUID-FD098D13-2067-40A8-99E6-F99DDC475CFE" name="GUID-FD098D13-2067-40A8-99E6-F99DDC475CFE"></a><h4 id="LNPCB-GUID-FD098D13-2067-40A8-99E6-F99DDC475CFE" class="sect4"><span class="enumeration_section">6.6.1 </span>ARRAYLEN Statement
                  </h4>
                  <div>
                     <p>Suppose you must pass an input host table to a PL/SQL block for processing. By default, when binding such a host table, Pro*COBOL use its declared dimension. However, you might not want to process the entire table. In that case, you can use the ARRAYLEN statement to specify a smaller table dimension. ARRAYLEN associates the host table with a host variable, which stores the smaller dimension. The statement syntax is:<a id="d38166e1794" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL ARRAYLEN host_array (dimension) EXECUTE END-EXEC. 
</pre><p>where <span class="italic">dimension</span> is a 4-byte, integer host variable, <span class="italic">not</span> a literal or an expression. 
                     </p>
                     <p>The ARRAYLEN statement must appear somewhere after the declarations of <span class="italic">host_array</span> and <span class="italic">dimension</span>. You cannot specify an offset into the host table. However, you might be able to use COBOL features for that purpose. 
                     </p>
                     <p>The following example uses ARRAYLEN to override the default dimension of a host table named <span class="italic">BONUS</span>: 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01 BONUS OCCURS 100 TIMES PIC S9(6)V99
         DISPLAY SIGN LEADING SEPARATE.
 01 MY-DIM  PIC S9(9) COMP. 
     ...
     EXEC SQL ARRAYLEN BONUS (MY-DIM) END-EXEC. 
     EXEC SQL END DECLARE SECTION END-EXEC. 
* -- populate the host table 
     ... 
* -- set smaller table dimension 
     MOVE 25 TO MY-DIM.
     EXEC SQL EXECUTE 
     DECLARE 
        TYPE NumTabTyp IS TABLE OF REAL 
            INDEX BY BINARY_INTEGER; 
        median_bonus  REAL; 
        FUNCTION median (num_tab NumTabTyp, n INTEGER) 
            RETURN REAL IS 
        BEGIN 
* -- compute median 
        END; 
     BEGIN 
        median_bonus := median(:BONUS, :MY-DIM); 
        ... 
     END; 
     END-EXEC. 
</pre><p>Only 25 table elements are passed to the PL/SQL block because ARRAYLEN reduces the host table from 100 to 25 elements. As a result, when the PL/SQL block is sent to the server for execution, a much smaller host table is sent along. This saves time and, in a networked environment, reduces network traffic. </p>
                  </div><a id="LNPCB425"></a><div class="props_rev_3"><a id="GUID-695A2355-3097-44EB-AAE9-69E7097575D1" name="GUID-695A2355-3097-44EB-AAE9-69E7097575D1"></a><h5 id="LNPCB-GUID-695A2355-3097-44EB-AAE9-69E7097575D1" class="sect5"><span class="enumeration_section">6.6.1.1 </span>Optional Keyword EXECUTE to ARRAYLEN Statement
                     </h5>
                     <div>
                        <p>The use of host tables used in a dynamic SQL Method 2 statement (see <span class="q">"<a href="Oracle-dynamic-SQL.html#GUID-0C0E313A-0142-4B10-8A29-BF59AFEE52D3">Using Method 2</a>"</span>) may have two different interpretations based on the presence or absence of the keyword to EXECUTE the ARRAYLEN statement. .
                        </p>
                        <p>If the EXECUTE keyword is absent: </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The PL/SQL block will be executed multiple times, with the actual number determined by the minimum dimension of ARRAYLEN used. </p>
                           </li>
                           <li>
                              <p>The host array cannot be bound to a PL/SQL table. </p>
                           </li>
                        </ul>
                        <p>If EXECUTE is present: </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p> The host table must be bound to an index table. </p>
                           </li>
                           <li>
                              <p> The PL/SQL block will be executed once. </p>
                           </li>
                           <li>
                              <p> All host variables specified in the EXEC SQL EXECUTE statement must: </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Be specified in an ARRAYLEN ... EXECUTE statement, or</p>
                                 </li>
                                 <li>
                                    <p>Be a scalar.</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>The following Pro*COBOL example demonstrates how host tables can be used to determine how many times a given PL/SQL block is executed. In this case, the PL/SQL block will be execute 3 times resulting in 3 new rows in the <span class="italic">emp</span> table. 
                        </p><pre class="oac_no_warn" dir="ltr">       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  EMPNOTAB  PIC S9(4) COMPUTATIONAL OCCURS 5 TIMES. 
 01  ENAMETAB  PIC X(10) OCCURS 3 TIMES. 
       ... 
           MOVE 1111 TO EMPNOTAB(1). 
           MOVE 2222 TO EMPNOTAB(2). 
           MOVE 3333 TO EMPNOTAB(3). 
           MOVE 4444 TO EMPNOTAB(4). 
           MOVE 5555 TO EMPNOTAB(5). 
  
           MOVE "MICKEY" TO ENAMETAB(1). 
           MOVE "MINNIE" TO ENAMETAB(2). 
           MOVE "GOOFY" TO ENAMETAB(3). 
  
           MOVE "BEGIN INSERT INTO emp(empno, ename) VALUES :b1, :b2; END;" 
             TO DYNSTMT-ARR. 
           MOVE 57 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :EMPNOTAB, :ENAMETAB END-EXEC. 
       ... 
  </pre><p>Given the following PL/SQL procedure: </p><pre class="oac_no_warn" dir="ltr">  CREATE OR REPLACE PACKAGE pkg AS  
     TYPE tab IS TABLE OF NUMBER(5) INDEX BY BINARY_INTEGER;  
     PROCEDURE proc1 (parm1 tab, parm2 NUMBER, parm3 tab);  
  END;  
  </pre><p>The following Pro*COBOL example demonstrates how to bind a host table to a PL/SQL index table through dynamic method 2. Note the presence of the ARRAYLEN...EXECUTE statement for all host arrays specified in the EXEC SQL EXECUTE statement. </p><pre class="oac_no_warn" dir="ltr">       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  II        PIC S9(4) COMP VALUE 2. 
 01  INTTAB    PIC S9(9) COMP OCCURS 3 TIMES. 
 01  DIM       PIC S9(9) COMP VALUE 3. 
  
           EXEC SQL ARRAYLEN INTTAB (DIM) EXECUTE END-EXEC. 
       ... 
           MOVE 1 TO INTTAB(1). 
           MOVE 2 TO INTTAB(2). 
           MOVE 3 TO INTTAB(3). 
  
           MOVE "BEGIN pkg.proc1 (:v1, :v2, :v3); end;"; 
             TO DYNSTMT-ARR. 
           MOVE 37 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :INTTAB, :II, :INTTAB END-EXEC. 
       ... 
  </pre><p>However, the following Pro*COBOL example will result in a precompile-time error because there is no ARRAYLEN...EXECUTE statement for INTTAB2. </p><pre class="oac_no_warn" dir="ltr">       ... 
 01  DYNSTMT   PIC X(80) VARYING. 
 01  INTTAB    PIC S9(9) COMP OCCURS 3 TIMES. 
 01  INTTAB2   PIC S9(9) COMP OCCURS 3 TIMES. 
 01  DIM       PIC S9(9) COMP VALUE 3. 
  
           EXEC SQL ARRAYLEN INTTAB (DIM) EXECUTE END-EXEC. 
       ... 
           MOVE 1 TO INTTAB(1). 
           MOVE 2 TO INTTAB(2). 
           MOVE 3 TO INTTAB(3). 
  
           MOVE "BEGIN pkg.proc1 (:v1, :v2, :v3); end;"; 
             TO DYNSTMT-ARR. 
           MOVE 37 TO DYNSTMT-LEN. 
   
           EXEC SQL PREPARE s1 FROM :DYNSTMT END-EXEC. 
           EXEC SQL EXECUTE s1 USING :INTTAB, :INTTAB2, :INTTAB END-EXEC. 
       ... </pre></div>
                  </div>
               </div>
            </div><a id="LNPCB427"></a><a id="LNPCB426"></a><div class="props_rev_3"><a id="GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1" name="GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1"></a><h3 id="LNPCB-GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1" class="sect3"><span class="enumeration_section">6.7 </span>Cursor Usage in Embedded PL/SQL
               </h3>
               <div>
                  <p>The maximum number of cursors your program can simultaneously use is determined by the database initialization parameter OPEN_CURSORS. Normally, to prevent OPEN_CURSORS being exceeded, the precompiler allows management of statement cursors. The precompiler options  HOLD_CURSOR, RELEASE_CURSOR and MAXOPENCURSORS are used. While executing an embedded PL/SQL block there will be one cursor, the parent cursor, associated with the entire PL/SQL block and a separate child cursor for each statement executed during the execution of the PL/SQL block. Because the PL/SQL block is passed to the server for execution, only the parent cursor can be tracked by the precompiler runtime library. Thus, it is possible for applications that use a lot of cursors in this way to exceed OPEN_CURSORS. <a href="embedded-PLSQL.html#GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1__I24512">Figure 6-1</a> shows how to calculate the maximum number of cursors used.
                  </p>
                  <div class="figure" id="GUID-FDFEDCF5-F2C0-4624-A303-6B54038371B1__I24512">
                     <p class="titleinfigure">Figure 6-1 Maximum Cursors in Use</p><img src="img/pco81054.gif" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows" longdesc="img_text/pco81054.html"><br><a href="img_text/pco81054.html">Description of "Figure 6-1 Maximum Cursors in Use"</a></div>
                  <!-- class="figure" -->
                  <p>Developers should be aware of this situation and plan for this in the setting of OPEN_CURSORS and MAXOPENCURSORS.</p>
                  <p>If there are problems with this, you may wish to free all child cursors after a SQL statement is executed.</p>
                  <p>This can be achieved by setting RELEASE_CURSOR=YES and HOLD_CURSOR=NO. Because the use of the first setting for the entire program is likely to have an impact on performance, you can set these options in line as follows:</p><pre class="oac_no_warn" dir="ltr">     EXEC ORACLE OPTION (RELEASE_CURSOR=YES) END-EXEC. 
* --  first embedded PL/SQL block 
     EXEC ORACLE OPTION (RELEASE_CURSOR=NO)END-EXEC. 
* --  embedded SQL statements
     EXEC ORACLE OPTION (RELEASE_CURSOR=YES)END-EXEC. 
* --  second embedded PL/SQL block 
     EXEC ORACLE OPTION (RELEASE_CURSOR=NO)END-EXEC. 
* --  embedded SQL statements </pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="performance-tuning.html#GUID-96CB266B-EDFD-458B-B43F-B278D6BCE866">Embedded PL/SQL Considerations</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCB428"></a><div class="props_rev_3"><a id="GUID-0CE314F6-4867-44C3-B14F-9580BDB621FC" name="GUID-0CE314F6-4867-44C3-B14F-9580BDB621FC"></a><h3 id="LNPCB-GUID-0CE314F6-4867-44C3-B14F-9580BDB621FC" class="sect3"><span class="enumeration_section">6.8 </span>Stored PL/SQL and Java Subprograms
               </h3>
               <div>
                  <p>Unlike anonymous blocks, PL/SQL subprograms (procedures and functions) and <a id="d38166e1974" class="indexterm-anchor"></a><a id="d38166e1978" class="indexterm-anchor"></a>Java methods can be compiled separately, stored in the database, and invoked. 
                  </p>
                  <p>A subprogram explicitly created using an Oracle tool such as SQL*Plus is called a <span class="italic">stored</span> subprogram. Once compiled and stored in the data dictionary, it is a database object can be re-executed without being re-compiled. <a id="d38166e1988" class="indexterm-anchor"></a><a id="d38166e1990" class="indexterm-anchor"></a></p>
                  <p>When a subprogram within a PL/SQL block or stored subprogram is sent to the database by your application, it is called an <span class="bold">inline</span> subprogram and is compiled by the database. Pro*COBOL sends the statement to the server for execution.<a id="d38166e1997" class="indexterm-anchor"></a> 
                  </p>
                  <p>Subprograms defined within a package are considered part of the package, and so are called <span class="bold">packaged</span> subprograms. Stored subprograms not defined within a package are called <span class="bold">standalone</span> subprograms.<a id="d38166e2008" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCB429"></a><div class="props_rev_3"><a id="GUID-C54B632A-9A73-4ED5-B982-09608A149306" name="GUID-C54B632A-9A73-4ED5-B982-09608A149306"></a><h4 id="LNPCB-GUID-C54B632A-9A73-4ED5-B982-09608A149306" class="sect4"><span class="enumeration_section">6.8.1 </span>Creating Stored Subprograms
                  </h4>
                  <div>
                     <p>You can embed the SQL statements CREATE FUNCTION, CREATE PROCEDURE, and CREATE PACKAGE in a COBOL program, as the following example shows:<a id="d38166e2037" class="indexterm-anchor"></a><a id="d38166e2041" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CREATE 
     FUNCTION sal_ok (salary REAL, title CHAR) 
      RETURN BOOLEAN AS 
        min_sal  REAL; 
        max_sal  REAL; 
     BEGIN 
        SELECT losal, hisal INTO min_sal, max_sal 
            FROM sals 
            WHERE job = title; 
        RETURN (salary &gt;= min_sal) AND 
               (salary &lt;= max_sal); 
     END sal_ok; 
     END-EXEC. 
</pre><p>Notice that the embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement is a hybrid. Like all other embedded CREATE statements, it begins with the keywords EXEC SQL (not EXEC SQL EXECUTE). </p>
                     <p>If an embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement fails, Oracle generates a warning, not an error.</p>
                     <div class="infoboxnotealso" id="GUID-C54B632A-9A73-4ED5-B982-09608A149306__GUID-2BB13F5D-35A6-42E1-871A-F94023896999">
                        <p class="notep1">See Also:</p><a href="../sqlrf/index.html" target="_blank"><span class="italic"> Oracle Database SQL Language Reference.</span></a> for the full syntax of the CREATE statement.
                     </div>
                  </div>
               </div><a id="LNPCB430"></a><div class="props_rev_3"><a id="GUID-4C1FD863-5957-4C22-9D68-9F01F436702E" name="GUID-4C1FD863-5957-4C22-9D68-9F01F436702E"></a><h4 id="LNPCB-GUID-4C1FD863-5957-4C22-9D68-9F01F436702E" class="sect4"><span class="enumeration_section">6.8.2 </span>Calling a Stored PL/SQL or Java Subprogram
                  </h4>
                  <div>
                     <p>To call a stored subprogram from your host program, you can use either an anonymous PL/SQL block or the CALL embedded SQL statement.</p>
                  </div><a id="LNPCB431"></a><div class="props_rev_3"><a id="GUID-C6673F11-CD6F-46D7-AA61-DFA8B566FD0D" name="GUID-C6673F11-CD6F-46D7-AA61-DFA8B566FD0D"></a><h5 id="LNPCB-GUID-C6673F11-CD6F-46D7-AA61-DFA8B566FD0D" class="sect5"><span class="enumeration_section">6.8.2.1 </span>Anonymous PL/SQL Block
                     </h5>
                     <div>
                        <p>The following example calls a standalone procedure named <span class="italic">raise_salary</span>:<a id="d38166e2107" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
     BEGIN 
        raise_salary(:emp_id, :increase); 
     END; 
     END-EXEC. 
</pre><p>Notice that stored subprograms can take parameters. In this example, the actual parameters <span class="italic">emp_id</span> and <span class="italic">increase</span> are host variables. 
                        </p>
                        <p>In the next example, the procedure <span class="italic">raise_salary</span> is stored in a package named <span class="italic">emp_actions</span>, so you must use dot notation to fully qualify the procedure call: 
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
     BEGIN 
        emp_actions.raise_salary(:emp_id, :increase); 
     END; 
     END-EXEC. 
</pre><p>An actual IN parameter can be a literal, host variable, host table, PL/SQL constant or variable, PL/SQL table, PL/SQL user-defined record, subprogram call, or expression. However, an actual OUT parameter cannot be a literal, subprogram call, or expression. </p>
                        <p>You must use precompiler option SQLCHECK=SEMANTICS with an embedded PL/SQL block.</p>
                     </div>
                  </div><a id="LNPCB432"></a><div class="props_rev_3"><a id="GUID-263CF6A4-7092-44C2-BC8B-ED72FDCD631B" name="GUID-263CF6A4-7092-44C2-BC8B-ED72FDCD631B"></a><h5 id="LNPCB-GUID-263CF6A4-7092-44C2-BC8B-ED72FDCD631B" class="sect5"><span class="enumeration_section">6.8.2.2 </span>CALL Statement
                     </h5>
                     <div>
                        <p>The concepts presented earlier for the embedded PL/SQL block holds true for the CALL statement. The CALL embedded SQL statement has the form:</p><pre class="oac_no_warn" dir="ltr">      EXEC SQL 
        CALL [schema.][package.]stored_proc[@db_link](arg1, ...) 
        [INTO :ret_var[[INDICATOR]:ret_ind]] 
     END-EXEC.
</pre><p>where:</p><pre class="oac_no_warn" dir="ltr">schema</pre><p>the schema containing the procedure</p><pre class="oac_no_warn" dir="ltr">package</pre><p>the package containing the procedure</p><pre class="oac_no_warn" dir="ltr">stored_proc</pre><p> is the Java or PL/SQL stored procedure to be called</p><pre class="oac_no_warn" dir="ltr">db_link</pre><p>is the optional remote database link</p><pre class="oac_no_warn" dir="ltr">arg1...</pre><p>is the list of arguments (variables, literals, or expressions) passed, </p><pre class="oac_no_warn" dir="ltr">ret_var</pre><p> is the optional host variable which receives the result</p><pre class="oac_no_warn" dir="ltr">ind_var</pre><p>the optional indicator variable for ret_var. </p>
                        <p>You can use either SQLCHECK=SYNTAX, or SQLCHECK=SEMANTICS with the CALL statement.</p>
                     </div>
                  </div><a id="LNPCB433"></a><div class="props_rev_3"><a id="GUID-71FBBD2E-17F7-47A3-B787-7E91247281C1" name="GUID-71FBBD2E-17F7-47A3-B787-7E91247281C1"></a><h5 id="LNPCB-GUID-71FBBD2E-17F7-47A3-B787-7E91247281C1" class="sect5"><span class="enumeration_section">6.8.2.3 </span>CALL Example
                     </h5>
                     <div>
                        <p>If you have created a PL/SQL function <code class="codeph">fact</code> (stored in the package <code class="codeph">mathpkg</code>) that takes an integer as input and returns its factorial in an integer:
                        </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CREATE OR REPLACE PACKAGE BODY mathpkg as 
       function fact(n IN INTEGER) RETURN INTEGER AS
         BEGIN
           IF (n &lt;= 0) then return 1;
           ELSE return n * fact(n - 1);
           END IF;
         END fact;
       END mathpkge;
     END-EXEC.
</pre><p>then to use<code class="codeph"> fact</code> in a Pro*COBOL application:
                        </p>
                        <p> ...</p><pre class="oac_no_warn" dir="ltr">          01 N      PIC S9(4) COMP.
          01 FACT   PIC S9(9) COMP.
...
     EXEC SQL CALL mathpkge.fact(:N) INTO :FACT END-EXEC.
...
</pre><div class="infoboxnotealso" id="GUID-71FBBD2E-17F7-47A3-B787-7E91247281C1__GUID-1CB0C3CE-443F-4407-A296-6E5AD2FEB676">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-C5814720-95DF-45AB-89D0-9A355D03F040">CALL (Executable Embedded SQL)</a>"</span> for more information about the CALL statement.
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../adfns/external-procedures.html#ADFNS-GUID-230B2B41-2A6F-4756-AEC0-DBC99DCA8A37" target="_blank">Developing Applications with Multiple Programming Languages</a> for a complete explanation of passing arguments and other issues.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB434"></a><div class="props_rev_3"><a id="GUID-B8F64E19-0350-4AF9-B8A5-C85C7897DF32" name="GUID-B8F64E19-0350-4AF9-B8A5-C85C7897DF32"></a><h4 id="LNPCB-GUID-B8F64E19-0350-4AF9-B8A5-C85C7897DF32" class="sect4"><span class="enumeration_section">6.8.3 </span>Using Dynamic PL/SQL
                  </h4>
                  <div>
                     <p>Recall that Pro*COBOL treats an entire PL/SQL block like a single SQL statement. Therefore, you can store a PL/SQL block in a string host variable. Then, if the block contains no host variables, you can use dynamic SQL Method 1 to execute the PL/SQL string. Or, if the block contains a known number of host variables, you can use dynamic SQL Method 2 to prepare and execute the PL/SQL string. If the block contains an unknown number of host variables, you must use dynamic SQL Method 4.<a id="d38166e2291" class="indexterm-anchor"></a></p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-C325218F-3DFF-4551-A5EB-483ADB24E324">Oracle Dynamic SQL</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-D6E9ACBE-EFF4-42F6-A855-B510004F4164">ANSI Dynamic SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle Dynamic SQL: Method 4</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB435"></a><div class="props_rev_3"><a id="GUID-90FCE22F-0F78-426F-B638-6EE5735BD8EF" name="GUID-90FCE22F-0F78-426F-B638-6EE5735BD8EF"></a><h4 id="LNPCB-GUID-90FCE22F-0F78-426F-B638-6EE5735BD8EF" class="sect4"><span class="enumeration_section">6.8.4 </span>Subprograms Restriction
                  </h4>
                  <div>
                     <p>In dynamic SQL Method 4, a host table cannot be bound to a PL/SQL procedure with a parameter of type TABLE.</p>
                  </div>
               </div>
            </div><a id="LNPCB436"></a><div class="props_rev_3"><a id="GUID-8516DBAD-41AE-4A03-8331-6DEF3A2DE831" name="GUID-8516DBAD-41AE-4A03-8331-6DEF3A2DE831"></a><h3 id="LNPCB-GUID-8516DBAD-41AE-4A03-8331-6DEF3A2DE831" class="sect3"><span class="enumeration_section">6.9 </span>Sample Program 9: Calling a Stored Procedure
               </h3>
               <div>
                  <div class="section">
                     <p>Before trying the sample program, you must create a PL/SQL package named <span class="italic">calldemo</span>, by running the following script, titled CALLDEMO.SQL, which is supplied with Pro*COBOL. The script can be found in the Pro*COBOL demo library. Check your system-specific Oracle documentation for exact spelling of the the name of the script.<a id="d38166e2371" class="indexterm-anchor"></a><a id="d38166e2375" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE calldemo AS

   TYPE name_array IS TABLE OF emp.ename%type
       INDEX BY BINARY_INTEGER;
   TYPE job_array IS TABLE OF emp.job%type
       INDEX BY BINARY_INTEGER;
   TYPE sal_array IS TABLE OF emp.sal%type
       INDEX BY BINARY_INTEGER;

   PROCEDURE get_employees(
     dept_number IN     number,    -- department to query
     batch_size  IN     INTEGER,   -- rows at a time
     found       IN OUT INTEGER,   -- rows actually returned
     done_fetch  OUT    INTEGER,   -- all done flag
     emp_name    OUT    name_array,
     job         OUT    job_array,
     sal         OUT    sal_array);

END calldemo;
/

CREATE OR REPLACE PACKAGE BODY calldemo AS

   CURSOR get_emp (dept_number IN number) IS
       SELECT ename, job, sal FROM emp
           WHERE deptno = dept_number;


   -- Procedure "get_employees" fetches a batch of employee
   -- rows (batch size is determined by the client/caller
   -- of the procedure).  It can be called from other
   -- stored procedures or client application programs.
   -- The procedure opens the cursor if it is not
   -- already open, fetches a batch of rows, and
   -- returns the number of rows actually retrieved. At
   -- end of fetch, the procedure closes the cursor.

   PROCEDURE get_employees(
     dept_number IN     number,
     batch_size  IN     INTEGER,
     found       IN OUT INTEGER,
     done_fetch  OUT    INTEGER,
     emp_name    OUT    name_array,
     job         OUT    job_array,
     sal         OUT    sal_array) IS

   BEGIN
       IF NOT get_emp%ISOPEN THEN      -- open the cursor if
           OPEN get_emp(dept_number);  -- not already open
       END IF;

       -- Fetch up to "batch_size" rows into PL/SQL table,
       -- tallying rows found as they are retrieved. When all
       -- rows have been fetched, close the cursor and exit
       -- the loop, returning only the last set of rows found.

       done_fetch := 0;  -- set the done flag FALSE
       found := 0;

       FOR i IN 1..batch_size LOOP
           FETCH get_emp INTO emp_name(i), job(i), sal(i);
           IF get_emp%NOTFOUND THEN    -- if no row was found
               CLOSE get_emp;
               done_fetch := 1;   -- indicate all done
               EXIT;
           ELSE
               found := found + 1;  -- count row
           END IF;
       END LOOP;
   END;
END;
/
</pre><p>The following sample program connects to the database, prompts the user for a department number and then calls a PL/SQL procedure named <span class="italic">get_employees</span>, which is stored in package <span class="italic">calldemo</span>. The procedure declares three PL/SQL tables as OUT formal parameters and then fetches a batch of employee data into the PL/SQL tables. The matching actual parameters are host tables. When the procedure finishes, row values in the PL/SQL tables are automatically assigned to the corresponding elements in the host tables. The program calls the procedure repeatedly, displaying each batch of employee data, until no more data is found.
                     </p><pre class="oac_no_warn" dir="ltr">      *****************************************************************
      * Sample Program 9: Calling a Stored Procedure
      * 
      * This program connects to ORACLE, prompts the user for a
      * department number, then calls a PL/SQL stored procedure named
      * GET_EMPLOYEES, which is stored in package CALLDEMO.  The 
      * procedure declares three PL/SQL tables ast OUT formal
      * parameters, then fetches a batch of employee data into the 
      * PL/SQL tables.  The matching actual parameters are host tables.
      * When the procedure finishes, it automatically assigns all row
      * values in the PL/SQL tables to corresponding elements in the
      * host tables.  The program calls the procedure repeatedly,
      * displaying each batch of employee data, until no more data
      * is found.
      * Use option picx=varchar2 when precompiling this sample program.
      *****************************************************************

       IDENTIFICATION DIVISION.
       PROGRAM-ID. CALL-STORED-PROC.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME         PIC X(15) VARYING.
       01  PASSWD           PIC X(15) VARYING.
       01  DEPT-NUM         PIC S9(9) COMP.
       01  EMP-TABLES.
           05  EMP-NAME     OCCURS 10 TIMES PIC X(10).
           05  JOB-TITLE    OCCURS 10 TIMES PIC X(10).

           05  SALARY       OCCURS 10 TIMES COMP-2.

       01  DONE-FLAG        PIC S9(9) COMP.
       01  TABLE-SIZE       PIC S9(9) COMP VALUE 10.
       01  NUM-RET          PIC S9(9) COMP.
       01  SQLCODE          PIC S9(9) COMP.
           EXEC SQL END DECLARE SECTION END-EXEC.

       01  COUNTER          PIC S9(9) COMP.
       01  DISPLAY-VARIABLES.
           05  D-EMP-NAME   PIC X(10).
           05  D-JOB-TITLE  PIC X(10).

           05  D-SALARY     PIC Z(5)9.

           05  D-DEPT-NUM   PIC 9(2).

           EXEC SQL INCLUDE SQLCA END-EXEC.

       PROCEDURE DIVISION.

       BEGIN-PGM.
           EXEC SQL WHENEVER SQLERROR DO
               PERFORM SQL-ERROR END-EXEC.

           PERFORM LOGON.
           PERFORM INIT-TABLES VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; 10.
           PERFORM GET-DEPT-NUM.
           PERFORM DISPLAY-HEADER.
           MOVE ZERO TO DONE-FLAG.
           MOVE ZERO TO NUM-RET.
           PERFORM FETCH-BATCH UNTIL DONE-FLAG = 1.
           PERFORM LOGOFF.

       INIT-TABLES.
           MOVE SPACE TO EMP-NAME(COUNTER).
           MOVE SPACE TO JOB-TITLE(COUNTER).
           MOVE ZERO TO SALARY(COUNTER).

       GET-DEPT-NUM.
           MOVE ZERO TO DEPT-NUM.
           DISPLAY " ".
           DISPLAY "ENTER DEPARTMENT NUMBER: "
               WITH NO ADVANCING.

           ACCEPT D-DEPT-NUM.

           MOVE D-DEPT-NUM TO DEPT-NUM.

       DISPLAY-HEADER.
           DISPLAY " ".
           DISPLAY "EMPLOYEE    JOB TITLE    SALARY".
           DISPLAY "--------    ---------    ------".

       FETCH-BATCH.
           EXEC SQL EXECUTE
               BEGIN
                   CALLDEMO.GET_EMPLOYEES
                       (:DEPT-NUM, :TABLE-SIZE,
                        :NUM-RET,  :DONE-FLAG,
                        :EMP-NAME, :JOB-TITLE, :SALARY);
               END;
           END-EXEC.
           PERFORM PRINT-ROWS VARYING COUNTER FROM 1 BY 1
               UNTIL COUNTER &gt; NUM-RET.

       PRINT-ROWS.
           MOVE EMP-NAME(COUNTER) TO D-EMP-NAME.
           MOVE JOB-TITLE(COUNTER) TO D-JOB-TITLE.
           MOVE SALARY(COUNTER) TO D-SALARY.
           DISPLAY D-EMP-NAME, "  ",
                   D-JOB-TITLE, "   ",
                   D-SALARY.

       LOGON.
           MOVE "SCOTT" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "TIGER" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY " ".
           DISPLAY "CONNECTED TO ORACLE AS USER: ", USERNAME-ARR.

       LOGOFF.
           DISPLAY " ".
           DISPLAY "HAVE A GOOD DAY.".
           DISPLAY " ".
           EXEC SQL COMMIT WORK RELEASE END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL ROLLBACK WORK RELEASE END-EXEC.
           STOP RUN.
</pre><p>Remember that the datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. Further, before a stored subprogram exits, all OUT formal parameters must be assigned values. Otherwise, the values of corresponding actual parameters are indeterminate. </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB437"></a><div class="props_rev_3"><a id="GUID-0F3CFCF3-D63F-4148-85F8-AE5E2625FEF5" name="GUID-0F3CFCF3-D63F-4148-85F8-AE5E2625FEF5"></a><h4 id="LNPCB-GUID-0F3CFCF3-D63F-4148-85F8-AE5E2625FEF5" class="sect4"><span class="enumeration_section">6.9.1 </span>Remote Access
                  </h4>
                  <div>
                     <p>PL/SQL lets you access remote databases through <span class="italic">database links</span>. Typically, database links are established by your DBA and stored in the data dictionary. A database link tells your program where the remote database is located, the path to it, and what username and password to use. The following example uses the database link <span class="italic">dallas</span> to call the <span class="italic">raise_salary</span> procedure: 
                     </p><pre class="oac_no_warn" dir="ltr">     EXEC SQL EXECUTE 
        BEGIN 
        raise_salary@dallas(:emp_id, :increase); 
        END; 
     END-EXEC. 
</pre><p>You can create synonyms to provide location transparency for remote subprograms, as the following example shows: </p><pre class="oac_no_warn" dir="ltr"> CREATE PUBLIC SYNONYM raise_salary FOR raise_salary@dallas;</pre><p></p>
                  </div>
               </div>
            </div><a id="LNPCB438"></a><div class="props_rev_3"><a id="GUID-78B25FD8-15B5-4253-BC9C-5C7C907DE354" name="GUID-78B25FD8-15B5-4253-BC9C-5C7C907DE354"></a><h3 id="LNPCB-GUID-78B25FD8-15B5-4253-BC9C-5C7C907DE354" class="sect3"><span class="enumeration_section">6.10 </span>Cursor Variables
               </h3>
               <div>
                  <p>You can use <span class="italic">cursor variables</span> in your Pro*COBOL programs to process multi-row queries using static embedded SQL. A cursor variable identifies a <span class="italic">cursor reference</span> that is defined and opened on the database server, using PL/SQL.<a id="d38166e2463" class="indexterm-anchor"></a><a id="d38166e2465" class="indexterm-anchor"></a></p>
                  <p>Like a cursor, a cursor variable points to the current row in the active set of a multi-row query. Cursors differ from cursor variables the way constants differ from variables. While a cursor is static, a cursor variable is dynamic, because it is not tied to a specific query. You can open a cursor variable for any type-compatible query.<a id="d38166e2471" class="indexterm-anchor"></a></p>
                  <p>You can assign new values to a cursor variable and pass it as a parameter to subprograms, including subprograms stored in a database. This gives you a convenient way to centralize data retrieval.</p>
                  <p>First, you declare the cursor variable. After declaring the variable, you use these statements to control a cursor variable:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>ALLOCATE</p>
                     </li>
                     <li>
                        <p>OPEN ... FOR</p>
                     </li>
                     <li>
                        <p>FETCH</p>
                     </li>
                     <li>
                        <p>CLOSE</p>
                     </li>
                     <li>
                        <p>FREE</p>
                     </li>
                  </ul>
                  <p>After you declare the cursor variable and allocate memory for it, you must pass it as an input host variable (bind variable) to PL/SQL, OPEN it FOR a multi-row query on the server side, FETCH from it on the client side and then CLOSE it on either side.</p>
                  <p>The advantages of cursor variables are</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Ease of maintenance.  Queries are centralized, in the stored procedure that opens the cursor variable. If you need to change the cursor, you only need to make the change in one place: the stored procedure. There is no need to change each application.</p>
                     </li>
                     <li>
                        <p>Increased Security. The user of the application (the username when the Pro*COBOL application connected to the database) must have execute permission on the stored procedure that opens the cursor. This user, however, does not need to have read permission on the tables used in the query. This capability can be used to limit access to the columns in the table.</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-78B25FD8-15B5-4253-BC9C-5C7C907DE354__GUID-E0794108-9D32-4570-9765-3295CB1A28DD">
                     <p class="notep1">See Also:</p><a href="../lnpls/static-sql.html#LNPLS-GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" target="_blank">Cursor Variables</a> for complete information about cursor variables.
                  </div>
               </div><a id="LNPCB439"></a><div class="props_rev_3"><a id="GUID-A5C78F81-DF3A-4028-A931-3DE556BF0195" name="GUID-A5C78F81-DF3A-4028-A931-3DE556BF0195"></a><h4 id="LNPCB-GUID-A5C78F81-DF3A-4028-A931-3DE556BF0195" class="sect4"><span class="enumeration_section">6.10.1 </span>Declaring a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>You declare a Pro*COBOL cursor variable using the SQL-CURSOR pseudotype. For example:<a id="d38166e2534" class="indexterm-anchor"></a><a id="d38166e2538" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION.
     ...
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
         ...
         01  CUR-VAR  SQL-CURSOR.
         ...
     EXEC SQL END DECLARE SECTION END-EXEC.
</pre><p>A SQL-CURSOR variable is implemented as a COBOL group item in the code that Pro*COBOL generates. A cursor variable is just like any other Pro*COBOL host variable.<a id="d38166e2546" class="indexterm-anchor"></a><a id="d38166e2550" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB440"></a><div class="props_rev_3"><a id="GUID-6951AC37-66EA-423D-B536-CCB1646B0B62" name="GUID-6951AC37-66EA-423D-B536-CCB1646B0B62"></a><h4 id="LNPCB-GUID-6951AC37-66EA-423D-B536-CCB1646B0B62" class="sect4"><span class="enumeration_section">6.10.2 </span>Allocating a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>Before you can OPEN or FETCH from a cursor variable, you must initialize it using the Pro*COBOL ALLOCATE command. For example, to initialize the cursor variable CUR-VAR that was declared in the previous section, write the following statement:<span class="bold"></span></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL ALLOCATE :CUR-VAR END-EXEC.
</pre><p>Allocating a cursor variable does <span class="italic">not</span> require a call to the server, either at precompile time or at runtime. 
                        </p>
                        <p>The AT clause cannot be used in an ALLOCATE statement.</p>
                        <p><span class="bold">Caution:</span> Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, avoid allocating a cursor variable in a program loop.<a id="d38166e2608" class="indexterm-anchor"></a><a id="d38166e2612" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB441"></a><div class="props_rev_3"><a id="GUID-FBAD94C3-302E-433C-B8AE-4D8377AA9CC6" name="GUID-FBAD94C3-302E-433C-B8AE-4D8377AA9CC6"></a><h4 id="LNPCB-GUID-FBAD94C3-302E-433C-B8AE-4D8377AA9CC6" class="sect4"><span class="enumeration_section">6.10.3 </span>Opening a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>You must use an embedded anonymous PL/SQL block to open a cursor variable on the database server. The anonymous PL/SQL block may open the cursor either indirectly by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement) or directly from the Pro*COBOL program.<a id="d38166e2642" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB442"></a><div class="props_rev_3"><a id="GUID-5EF600D0-4E0A-4BDD-93E9-C3A270602D41" name="GUID-5EF600D0-4E0A-4BDD-93E9-C3A270602D41"></a><h5 id="LNPCB-GUID-5EF600D0-4E0A-4BDD-93E9-C3A270602D41" class="sect5"><span class="enumeration_section">6.10.3.1 </span>Opening Indirectly through a Stored PL/SQL Procedure
                     </h5>
                     <div>
                        <div class="section">
                           <p>Consider the following PL/SQL package stored in the database:<a id="d38166e2669" class="indexterm-anchor"></a><a id="d38166e2675" class="indexterm-anchor"></a><a id="d38166e2681" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE demo_cur_pkg AS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE cur_type IS REF CURSOR RETURN EmpName;
    PROCEDURE open_emp_cur (
               curs     IN OUT curtype,
               dept_num IN     number);
END;

CREATE PACKAGE BODY demo_cur_pkg AS
    CREATE PROCEDURE open_emp_cur (
               curs     IN OUT curtype,
               dept_num IN     number) IS
    BEGIN
        OPEN curs FOR
            SELECT ename FROM emp
                WHERE deptno = dept_num
                ORDER BY ename ASC;
    END;
END;
</pre><p>After this package has been stored, you can open the cursor<span class="italic"> curs</span> by first calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*COBOL program and then issuing a FETCH from the cursor variable emp_cursor in the program. For example:<span class="italic"> </span></p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION.
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
 01  emp_cursor     sql-cursor.
 01  DEPT-NUM      PIC S9(4).
 01  EMP-NAME      PIC X(10) VARYING.
     EXEC SQL END DECLARE SECTION END-EXEC.
     ...

 PROCEDURE DIVISION.
     ...
*    Allocate the cursor variable.
     EXEC SQL 
         ALLOCATE :emp-cursor 
     END-EXEC.
     ...
     MOVE 30 TO dept_num.
*    Open the cursor on the Oracle Server.
     EXEC SQL EXECUTE
         begin
             demo_cur_pkg.open_emp_cur(:emp-cursor, :dept-num);
         END;
     END-EXEC.
     EXEC SQL 
         WHENEVER NOT FOUND DO PERFORM SIGN-OFF
     END-EXEC.
 FETCH-LOOP.
     EXEC SQL 
         FETCH :emp_cursor INTO :EMP-NAME 
     END-EXEC.
     DISPLAY "Employee Name: ",:EMP-NAME.
     GO TO FETCH-LOOP.
     ...
 SIGN-OFF.
     ...</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB443"></a><div class="props_rev_3"><a id="GUID-838E3DBA-11C4-4A53-8FAD-EE0A22698483" name="GUID-838E3DBA-11C4-4A53-8FAD-EE0A22698483"></a><h5 id="LNPCB-GUID-838E3DBA-11C4-4A53-8FAD-EE0A22698483" class="sect5"><span class="enumeration_section">6.10.3.2 </span>Opening Directly from Your Pro*COBOL Application
                     </h5>
                     <div>
                        <div class="section">
                           <p>To open a cursor using a PL/SQL anonymous block in a Pro*COBOL program, define the cursor in the anonymous block. Consider the following example:<a id="d38166e2724" class="indexterm-anchor"></a><a id="d38166e2730" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> PROCEDURE DIVISION.
     ...
     EXEC SQL EXECUTE
         begin
             OPEN :emp_cursor FOR SELECT ename FROM emp
                 WHERE deptno = :DEPT-NUM;
         end;
     END-EXEC.
     ...</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB444"></a><div class="props_rev_3"><a id="GUID-41D6F6FB-03BF-4A1F-BD9B-DBE5B7FB9E98" name="GUID-41D6F6FB-03BF-4A1F-BD9B-DBE5B7FB9E98"></a><h4 id="LNPCB-GUID-41D6F6FB-03BF-4A1F-BD9B-DBE5B7FB9E98" class="sect4"><span class="enumeration_section">6.10.4 </span>Fetching from a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>After opening a cursor variable for a multi-row query, you use the FETCH statement to retrieve rows as you would from a static cursor. The syntax follows:<a id="d38166e2763" class="indexterm-anchor"></a><a id="d38166e2767" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL FETCH cursor_variable_name 
         INTO {record_name | variable_name[, variable_name, ...]} 
     END-EXEC.
</pre><p>Each column value returned by the cursor variable is assigned to a corresponding field or variable in the INTO clause, providing that their datatypes are compatible. <a id="d38166e2775" class="indexterm-anchor"></a></p>
                        <p>The FETCH statement must be executed on the client side. The following example fetches rows into a host record named <span class="italic">EMP-REC</span>:
                        </p><pre class="oac_no_warn" dir="ltr">* -- exit loop when done fetching
     EXEC SQL
         WHENEVER NOT FOUND DO PERFORM NO-MORE
     END-EXEC.
     PERFORM
* -- fetch row into record
     EXEC SQL FETCH :EMP-CUR INTO :EMP-REC END-EXEC 
* -- test for transfer out of loop
     ...
* -- process the data
     ...
     END-PERFORM.
     ...
 NO-MORE.
     ...
</pre><p>Use the embedded SQL FETCH .... INTO command to retrieve the rows selected when you opened the cursor variable. For example:<a id="d38166e2786" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr"> EXEC SQL
     FETCH :emp_cursor INTO :EMP-INFO:EMP-INFO-IND
 END-EXEC.
</pre><p>Before you can FETCH from a cursor variable, the variable must be initialized and opened. You cannot FETCH from an unopened cursor variable.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB445"></a><div class="props_rev_3"><a id="GUID-2329DD40-53A6-40F4-A7E0-09DD8CC8134F" name="GUID-2329DD40-53A6-40F4-A7E0-09DD8CC8134F"></a><h4 id="LNPCB-GUID-2329DD40-53A6-40F4-A7E0-09DD8CC8134F" class="sect4"><span class="enumeration_section">6.10.5 </span>Closing a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>Use the embedded SQL CLOSE statement to close a cursor variable. At this point its active set becomes undefined. The syntax follows: <a id="d38166e2819" class="indexterm-anchor"></a><a id="d38166e2823" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">     EXEC SQL CLOSE cursor_variable_name END-EXEC.
</pre><p>The CLOSE statement can be executed on the client side or the server side. The following example closes the cursor variable <span class="italic">CUR-VAR </span>when the last row is processed:
                        </p><pre class="oac_no_warn" dir="ltr"> WORKING-STORAGE SECTION.
     EXEC SQL BEGIN DECLARE SECTION END-EXEC.
*    Declare the cursor variable.
         01  CUR-VAR       SQL-CURSOR.
         ...
     EXEC SQL END DECLARE SECTION END-EXEC.

 PROCEDURE DIVISION.
*    Allocate and open the cursor variable, then
*    Fetch one or more rows.
     ...
*    Close the cursor variable.
     EXEC SQL
         CLOSE :CUR-VAR
     END-EXEC.</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB446"></a><div class="props_rev_3"><a id="GUID-0BAED95B-F1FF-4323-A9B9-4B2E20552194" name="GUID-0BAED95B-F1FF-4323-A9B9-4B2E20552194"></a><h4 id="LNPCB-GUID-0BAED95B-F1FF-4323-A9B9-4B2E20552194" class="sect4"><span class="enumeration_section">6.10.6 </span>Freeing a Cursor Variable
                  </h4>
                  <div>
                     <div class="section">
                        <p>To free memory allocated for the cursor variable, <span class="italic">CUR-VAR, </span>use the FREE statement after the CLOSE:
                        </p><pre class="oac_no_warn" dir="ltr">*    Free the cursor variable memory.
     EXEC SQL 
         FREE :CUR-VAR
     END-EXEC.</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB447"></a><div class="props_rev_3"><a id="GUID-892A17BA-2AAE-4F3D-A2D4-CEE0D8EEFA22" name="GUID-892A17BA-2AAE-4F3D-A2D4-CEE0D8EEFA22"></a><h4 id="LNPCB-GUID-892A17BA-2AAE-4F3D-A2D4-CEE0D8EEFA22" class="sect4"><span class="enumeration_section">6.10.7 </span>Restrictions on Cursor Variables
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following restrictions apply to the use of cursor variables:<span class="bold"></span></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Cursor variables are not supported in dynamic SQL.</p>
                           </li>
                           <li>
                              <p>You can only use cursor variables with the ALLOCATE, FETCH, FREE, and CLOSE commands. The DECLARE CURSOR command does <span class="italic">not</span> apply to cursor variables. 
                              </p>
                           </li>
                           <li>
                              <p>You cannot use the AT clause with the ALLOCATE command.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB448"></a><div class="props_rev_3"><a id="GUID-5D3A4E72-61A1-463F-918E-D1A015B7EEF7" name="GUID-5D3A4E72-61A1-463F-918E-D1A015B7EEF7"></a><h4 id="LNPCB-GUID-5D3A4E72-61A1-463F-918E-D1A015B7EEF7" class="sect4"><span class="enumeration_section">6.10.8 </span>Sample Program 11: Cursor Variables
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following sample programs—a SQL script (SAMPLE11.sql) and a Pro*COBOL program (SAMPLE11.pco)—demonstrate how you can use cursor variables in Pro*COBOL.<a id="d38166e2957" class="indexterm-anchor"></a><a id="d38166e2961" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB449"></a><div class="props_rev_3"><a id="GUID-C1988AA8-26D7-48AB-B1F8-864BFFCBF503" name="GUID-C1988AA8-26D7-48AB-B1F8-864BFFCBF503"></a><h5 id="LNPCB-GUID-C1988AA8-26D7-48AB-B1F8-864BFFCBF503" class="sect5"><span class="enumeration_section">6.10.8.1 </span>SAMPLE11.SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>Following is the PL/SQL source code for a creating a package that declares and opens a cursor variable:<a id="d38166e2990" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CONNECT SCOTT/TIGER
CREATE OR REPLACE PACKAGE emp_demo_pkg AS
    TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
    PROCEDURE open_cur (
        cursor   IN OUT emp_cur_type,
        dept_num IN     number);
END emp_demo_pkg;
/  
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS

    PROCEDURE open_cur (
        cursor   IN OUT emp_cur_type, 
        dept_num IN     number) IS
    BEGIN 
        OPEN cursor FOR SELECT * FROM emp
        WHERE deptno = dept_num
        ORDER BY ename ASC;
    END;
END emp_demo_pkg;
/</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB450"></a><div class="props_rev_3"><a id="GUID-B0D9357F-9FD3-4FC9-AD82-343751D3C485" name="GUID-B0D9357F-9FD3-4FC9-AD82-343751D3C485"></a><h5 id="LNPCB-GUID-B0D9357F-9FD3-4FC9-AD82-343751D3C485" class="sect5"><span class="enumeration_section">6.10.8.2 </span>SAMPLE11.PCO
                     </h5>
                     <div>
                        <div class="section">
                           <p>Following is a Pro*COBOL sample program, SAMPLE11.PCO, that uses the cursor variable declared in the SAMPLE11.sql example to fetch employee names, salaries, and commissions from the EMP table:</p><pre class="oac_no_warn" dir="ltr">
      *****************************************************************
      * Sample Program 11:  Cursor Variable Operations                *
      *                                                               *
      * This program logs on to ORACLE, allocates and opens a cursor  *
      * variable fetches the names, salaries, and commissions of all  *
      * salespeople, displays the results, then closes the cursor.    *
      *****************************************************************
                                          
       IDENTIFICATION DIVISION.
       PROGRAM-ID. CURSOR-VARIABLES.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  USERNAME          PIC X(15) VARYING.
       01  PASSWD            PIC X(15) VARYING.
       01  HOST              PIC X(15) VARYING.
       01  EMP-CUR           SQL-CURSOR.
       01  EMP-INFO.
           05  EMP-NUM       PIC S9(4) COMP.
           05  EMP-NAM       PIC X(10) VARYING.
           05  EMP-JOB       PIC X(10) VARYING.
           05  EMP-MGR       PIC S9(4) COMP.
           05  EMP-DAT       PIC X(10) VARYING.
           05  EMP-SAL       PIC S9(6)V99 
                               DISPLAY SIGN LEADING SEPARATE.
           05  EMP-COM       PIC S9(6)V99 
                               DISPLAY SIGN LEADING SEPARATE.
           05  EMP-DEP       PIC S9(4) COMP.
       01  EMP-INFO-IND.
           05  EMP-NUM-IND   PIC S9(4) COMP.
           05  EMP-NAM-IND   PIC S9(4) COMP.
           05  EMP-JOB-IND   PIC S9(4) COMP.
           05  EMP-MGR-IND   PIC S9(4) COMP.
           05  EMP-DAT-IND   PIC S9(4) COMP.
           05  EMP-SAL-IND   PIC S9(4) COMP.
           05  EMP-COM-IND   PIC S9(4) COMP.
           05  EMP-DEP-IND   PIC S9(4) COMP.
           EXEC SQL END DECLARE SECTION END-EXEC.
      
           EXEC SQL INCLUDE SQLCA END-EXEC.   

       01  DISPLAY-VARIABLES.
           05  D-DEP-NUM     PIC Z(3)9.
           05  D-EMP-NAM     PIC X(10).
           05  D-EMP-SAL     PIC Z(4)9.99.
           05  D-EMP-COM     PIC Z(4)9.99.
           05  D-EMP-DEP     PIC 9(2).


       PROCEDURE DIVISION.
      
       BEGIN-PGM.
           EXEC SQL
               WHENEVER SQLERROR DO PERFORM SQL-ERROR
           END-EXEC.
           PERFORM LOGON.
           EXEC SQL
               ALLOCATE :EMP-CUR
           END-EXEC.
           DISPLAY "Enter department number (0 to exit):  " 
               WITH NO ADVANCING.
           ACCEPT D-EMP-DEP.
           MOVE D-EMP-DEP TO EMP-DEP.
           IF EMP-DEP &lt;= 0
               GO TO SIGN-OFF
           END-IF.
           MOVE EMP-DEP TO D-DEP-NUM.
           EXEC SQL EXECUTE
               BEGIN
                   emp_demo_pkg.open_cur(:EMP-CUR, :EMP-DEP);
               END;
           END-EXEC.
           DISPLAY " ".
           DISPLAY "For department ", D-DEP-NUM, ":".
           DISPLAY " ".
           DISPLAY "EMPLOYEE   SALARY     COMMISSION".
           DISPLAY "---------- ---------- ----------".
                 
       FETCH-LOOP.
           EXEC SQL
               WHENEVER NOT FOUND GOTO CLOSE-UP
           END-EXEC.
           MOVE SPACES TO EMP-NAM-ARR.
           EXEC SQL FETCH :EMP-CUR
               INTO :EMP-NUM:EMP-NUM-IND,
                    :EMP-NAM:EMP-NAM-IND,
                    :EMP-JOB:EMP-JOB-IND,
                    :EMP-MGR:EMP-MGR-IND,
                    :EMP-DAT:EMP-DAT-IND,
                    :EMP-SAL:EMP-SAL-IND,
                    :EMP-COM:EMP-COM-IND,
                    :EMP-DEP:EMP-DEP-IND
           END-EXEC.
           MOVE EMP-SAL TO D-EMP-SAL.
           IF EMP-COM-IND = 0
               MOVE EMP-COM TO D-EMP-COM
               DISPLAY EMP-NAM-ARR, "   ", D-EMP-SAL, 
                       "   ", D-EMP-COM
           ELSE
               DISPLAY EMP-NAM-ARR, "   ", D-EMP-SAL, 
                       "        N/A"
           END-IF.
           GO TO FETCH-LOOP. 
      
       LOGON.
           MOVE "SCOTT" TO USERNAME-ARR.
           MOVE 5 TO USERNAME-LEN.
           MOVE "TIGER" TO PASSWD-ARR.
           MOVE 5 TO PASSWD-LEN.
           MOVE "INST1_ALIAS" TO HOST-ARR.
           MOVE 11 TO HOST-LEN.
           EXEC SQL
               CONNECT :USERNAME IDENTIFIED BY :PASSWD
           END-EXEC.
           DISPLAY " ".
           DISPLAY "CONNECTED TO ORACLE AS USER: ", USERNAME-ARR.

       CLOSE-UP.
           EXEC SQL
               CLOSE :EMP-CUR
           END-EXEC.
           EXEC SQL
               FREE :EMP-CUR
           END-EXEC.
       SIGN-OFF.
           DISPLAY " ".
           DISPLAY "HAVE A GOOD DAY.".
           DISPLAY " ".
           EXEC SQL
               COMMIT WORK RELEASE
           END-EXEC.
           STOP RUN.

       SQL-ERROR.
           EXEC SQL
               WHENEVER SQLERROR CONTINUE
           END-EXEC.
           DISPLAY " ".
           DISPLAY "ORACLE ERROR DETECTED:".
           DISPLAY " ".
           DISPLAY SQLERRMC.
           EXEC SQL
               ROLLBACK WORK RELEASE
           END-EXEC.
           STOP RUN.
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>