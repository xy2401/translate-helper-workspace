<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">
      <meta name="description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">
      <title>Loading Objects, LOBs, and Collections</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Utilities ">
      <meta property="og:description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Utilities">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96081-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="oracle-sql-loader-field-list-contents.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-sql-loader-conventional-and-direct-loads.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities">
    <meta name="dcterms.isVersionOf" content="SUTIL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-sql-loader-field-list-contents.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-sql-loader-conventional-and-direct-loads.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Utilities </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-sql-loader.html" property="item" typeof="WebPage"><span property="name"> SQL*Loader</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Loading Objects, LOBs, and Collections</li>
            </ol>
            <a id="GUID-A1828462-FD32-457C-976F-C85BA3A995DA" name="GUID-A1828462-FD32-457C-976F-C85BA3A995DA"></a><a id="SUTIL007"></a>
            
            <h2 id="SUTIL-GUID-A1828462-FD32-457C-976F-C85BA3A995DA" class="sect2"><span class="enumeration_chapter">11 </span> Loading Objects, LOBs, and Collections
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections. </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776">Loading Column Objects</a><br>Column objects in the control file are described in terms of their attributes.
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7">Loading Object Tables</a><br>The control file syntax required to load an object table is nearly identical to that used to load a typical relational table.
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8">Loading REF Columns</a><br>SQL*Loader can load system-generated OID <code class="codeph">REF</code> columns, primary-key-based <code class="codeph">REF</code> columns, and unscoped <code class="codeph">REF</code> columns that allow primary keys.
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80">Loading LOBs</a><br>The section describes loading LOBs.
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40">Loading BFILE Columns</a><br>The <code class="codeph">BFILE</code> data type stores unstructured binary data in operating system files outside the database. 
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C">Loading Collections (Nested Tables and VARRAYs)</a><br>Like LOBs, collections can be loaded either from a primary data file (data inline) or from secondary data files (data out of line).
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737">Dynamic Versus Static SDF Specifications</a><br>You can specify SDFs either statically (specifing the actual name of the file) or dynamically (using a <code class="codeph">FILLER</code> field as the source of the file name). 
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34">Loading a Parent Table Separately from Its Child Table</a><br>When you load a table that contains a nested table column, it may be possible to load the parent table separately from the child table. 
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="oracle-sql-loader.html#GUID-8D037494-07FA-4226-B507-E1B2ED10C144">SQL*Loader</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1247"></a><div class="props_rev_3"><a id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" name="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776"></a><h3 id="SUTIL-GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" class="sect3"><span class="enumeration_section">11.1 </span>Loading Column Objects
               </h3>
               <div>
                  <p>Column objects in the control file are described in terms of their attributes.</p>
                  <p>If the object type on which the column object is based is declared to be nonfinal, then the column object in the control file may be described in terms of the attributes, both derived and declared, of any subtype derived from the base object type. In the data file, the data corresponding to each of the attributes of a column object is in a data field similar to that corresponding to a simple relational column.</p>
                  <div class="infoboxnote" id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776__GUID-E2FBFA07-7E3E-40FD-9E52-C87001DF8292">
                     <p class="notep1">Note:</p>
                     <p>With SQL*Loader support for complex data types such as column objects, the possibility arises that two identical field names could exist in the control file, one corresponding to a column, the other corresponding to a column object's attribute. Certain clauses can refer to fields (for example, <code class="codeph">WHEN</code>, <code class="codeph">NULLIF</code>, <code class="codeph">DEFAULTIF</code>, <code class="codeph">SID</code>, <code class="codeph">OID</code>, <code class="codeph">REF</code>, <code class="codeph">BFILE</code>, and so on), causing a naming conflict if identically named fields exist in the control file. 
                     </p>
                     <p>Therefore, if you use clauses that refer to fields, then you must specify the full name. For example, if field <code class="codeph">fld1</code> is specified to be a <code class="codeph">COLUMN</code> <code class="codeph">OBJECT</code> and it contains field <code class="codeph">fld2</code>, then when you specify <code class="codeph">fld2</code> in a clause such as <code class="codeph">NULLIF</code>, you must use the full field name <code class="codeph">fld1.fld2</code>.
                     </p>
                  </div>
                  <p>The following sections show examples of loading column objects:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22">Loading Column Objects in Stream Record Format</a><br>You can load column objects in stream record format.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166">Loading Column Objects in Variable Record Format</a><br>You can load column objects in variable record format.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D">Loading Nested Column Objects</a><br>You can load nested column objects.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270">Loading Column Objects with a Derived Subtype</a><br>You can load column objects with a derived subtype.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43">Specifying Null Values for Objects</a><br>You can specify null values for objects.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB">Loading Column Objects with User-Defined Constructors</a><br>You can load column objects with user-defined constructors.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3356"></a><a id="SUTIL3355"></a><a id="SUTIL1248"></a><div class="props_rev_3"><a id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" name="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22"></a><h4 id="SUTIL-GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" class="sect4"><span class="enumeration_section">11.1.1 </span>Loading Column Objects in Stream Record Format
                  </h4>
                  <div>
                     <p>You can load column objects in stream record format.</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">Example 11-1</a> shows a case in which the data is in predetermined size fields. The newline character marks the end of a physical record. You can also mark the end of a physical record by using a custom record separator in the operating system file-processing clause (<code class="codeph">os_file_proc_clause</code>).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">
                        <p class="titleinexample">Example 11-1 Loading Column Objects in Stream Record Format</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments
   (dept_no     POSITION(01:03)    CHAR,
    dept_name   POSITION(05:15)    CHAR,
<span class="bold">1</span>   dept_mgr    COLUMN OBJECT
      (name     POSITION(17:33)    CHAR,
       age      POSITION(35:37)    INTEGER EXTERNAL,
       emp_id   POSITION(40:46)    INTEGER EXTERNAL) )
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">101 Mathematics  Johny Quest       30   1024
237 Physics      Albert Einstein   65   0000</pre><div class="infoboxnote" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__GUID-8C044CFD-5B1C-4E33-A5F2-890D8EC8B538">
                           <p class="notep1">Note:</p>
                           <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                           <ol>
                              <li>
                                 <p>This type of column object specification can be applied recursively to describe nested column objects.</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3358"></a><a id="SUTIL3357"></a><a id="SUTIL1249"></a><div class="props_rev_3"><a id="GUID-6A23F378-18B9-4F60-848E-C367A9978166" name="GUID-6A23F378-18B9-4F60-848E-C367A9978166"></a><h4 id="SUTIL-GUID-6A23F378-18B9-4F60-848E-C367A9978166" class="sect4"><span class="enumeration_section">11.1.2 </span>Loading Column Objects in Variable Record Format
                  </h4>
                  <div>
                     <p>You can load column objects in variable record format.</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">Example 11-2</a> shows a case in which the data is in delimited fields.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">
                        <p class="titleinexample">Example 11-2 Loading Column Objects in Variable Record Format</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
<span class="bold">1</span> INFILE 'sample.dat' "var 6"
INTO TABLE departments
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
<span class="bold">2</span>  (dept_no
   dept_name, 
   dept_mgr       COLUMN OBJECT
      (name       CHAR(30), 
      age         INTEGER EXTERNAL(5), 
      emp_id      INTEGER EXTERNAL(5)) )
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span>  <span class="italic">000034</span>101,Mathematics,Johny Q.,30,1024,
   <span class="italic">000039237</span>,Physics,"Albert Einstein",65,0000,</pre><div class="infoboxnote" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__GUID-84AB0DEF-B2CC-4EE9-A998-47D7B90616D0">
                           <p class="notep1">Note:</p>
                           <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                           <ol>
                              <li>
                                 <p>The <code class="codeph">"var"</code> string includes the number of bytes in the length field at the beginning of each record (in this example, the number is 6). If no value is specified, then the default is 5 bytes. The maximum size of a variable record is 2^32-1. Specifying larger values will result in an error.
                                 </p>
                              </li>
                              <li>
                                 <p>Although no positional specifications are given, the general syntax remains the same (the column object's name followed by the list of its attributes enclosed in parentheses). Also note that an omitted type specification defaults to <code class="codeph">CHAR</code> of length 255.
                                 </p>
                              </li>
                              <li>
                                 <p>The first 6 bytes (italicized) specify the length of the forthcoming record. These length specifications include the newline characters, which are ignored thanks to the terminators after the <code class="codeph">emp_id</code> field.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3360"></a><a id="SUTIL3359"></a><a id="SUTIL1250"></a><div class="props_rev_3"><a id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" name="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D"></a><h4 id="SUTIL-GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" class="sect4"><span class="enumeration_section">11.1.3 </span>Loading Nested Column Objects
                  </h4>
                  <div>
                     <p>You can load nested column objects.</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">Example 11-3</a> shows a control file describing nested column objects (one column object nested in another column object).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">
                        <p class="titleinexample">Example 11-3 Loading Nested Column Objects</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE `sample.dat'
INTO TABLE departments_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (dept_no      CHAR(5), 
   dept_name     CHAR(30), 
   dept_mgr      COLUMN OBJECT
      (name      CHAR(30), 
      age        INTEGER EXTERNAL(3),
      emp_id     INTEGER EXTERNAL(7),
<span class="bold">1</span>     em_contact COLUMN OBJECT
         (name      CHAR(30), 
         phone_num  CHAR(20))))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">101,Mathematics,Johny Q.,30,1024,"Barbie",650-251-0010,
237,Physics,"Albert Einstein",65,0000,Wife Einstein,654-3210,</pre><div class="infoboxnote" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__GUID-B0236F5A-4D48-45FB-BE77-68B077C39CEF">
                           <p class="notep1">Note:</p>
                           <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                           <ol>
                              <li>
                                 <p>This entry specifies a column object nested within a column object.</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3362"></a><a id="SUTIL3361"></a><a id="SUTIL1251"></a><div class="props_rev_3"><a id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" name="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270"></a><h4 id="SUTIL-GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" class="sect4"><span class="enumeration_section">11.1.4 </span>Loading Column Objects with a Derived Subtype
                  </h4>
                  <div>
                     <p>You can load column objects with a derived subtype.</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">Example 11-4</a> shows a case in which a nonfinal base object type has been extended to create a new derived subtype. Although the column object in the table definition is declared to be of the base object type, SQL*Loader allows any subtype to be loaded into the column object, provided that the subtype is derived from the base object type.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">
                        <p class="titleinexample">Example 11-4 Loading Column Objects with a Subtype</p>
                        <p>Object Type Definitions</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT
  (name     VARCHAR(30),
   ssn      NUMBER(9)) not final;

CREATE TYPE employee_type UNDER person_type
  (empid    NUMBER(5));

CREATE TABLE personnel
  (deptno   NUMBER(3),
   deptname VARCHAR(30),
   person   person_type);
</pre><p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE personnel
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (deptno        INTEGER EXTERNAL(3),
    deptname      CHAR,
<span class="bold">1</span>   person        COLUMN OBJECT TREAT AS employee_type
      (name       CHAR,
       ssn        INTEGER EXTERNAL(9),
<span class="bold">2</span>      empid      INTEGER EXTERNAL(5)))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">101,Mathematics,Johny Q.,301189453,10249,
237,Physics,"Albert Einstein",128606590,10030,</pre><div class="infoboxnote" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__GUID-F3D7F6D8-32B3-4C9C-908D-0AFD71F0BAB4">
                           <p class="notep1">Note:</p>
                           <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                           <ol>
                              <li>
                                 <p>The <code class="codeph">TREAT</code> <code class="codeph">AS</code> clause indicates that SQL*Loader should treat the column object <code class="codeph">person</code> as if it were declared to be of the derived type <code class="codeph">employee_type</code>, instead of its actual declared type, <code class="codeph">person_type</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">empid</code> attribute is allowed here because it is an attribute of the <code class="codeph">employee_type</code>. If the <code class="codeph">TREAT</code> <code class="codeph">AS</code> clause had not been specified, then this attribute would have resulted in an error, because it is not an attribute of the column's declared type.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1252"></a><div class="props_rev_3"><a id="GUID-C2940706-C809-4E42-886B-F13D35E54A43" name="GUID-C2940706-C809-4E42-886B-F13D35E54A43"></a><h4 id="SUTIL-GUID-C2940706-C809-4E42-886B-F13D35E54A43" class="sect4"><span class="enumeration_section">11.1.5 </span>Specifying Null Values for Objects
                  </h4>
                  <div>
                     <p>You can specify null values for objects.</p>
                     <div class="section">
                        <p>Specifying null values for nonscalar data types is somewhat more complex than for scalar data types. An object can have a subset of its attributes be null, it can have all of its attributes be null (an attributively null object), or it can be null itself (an atomically null object).</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357">Specifying Attribute Nulls</a><br>You can specify attribute nulls.
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3">Specifying Atomic Nulls</a><br>You can specify atomic nulls.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3364"></a><a id="SUTIL3363"></a><a id="SUTIL1253"></a><div class="props_rev_3"><a id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" name="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357"></a><h5 id="SUTIL-GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" class="sect5"><span class="enumeration_section">11.1.5.1 </span>Specifying Attribute Nulls
                     </h5>
                     <div>
                        <p>You can specify attribute nulls.</p>
                        <div class="section">
                           <p>In fields corresponding to column objects, you can use the <code class="codeph">NULLIF</code> clause to specify the field conditions under which a particular attribute should be initialized to <code class="codeph">NULL</code>. <a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">Example 11-5</a> demonstrates this.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">
                           <p class="titleinexample">Example 11-5 Specifying Attribute Nulls Using the NULLIF Clause</p>
                           <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments
  (dept_no      POSITION(01:03)    CHAR,
  dept_name     POSITION(05:15)    CHAR NULLIF dept_name=BLANKS,
  dept_mgr      COLUMN OBJECT
<span class="bold">1</span>    ( name     POSITION(17:33)    CHAR NULLIF&nbsp;dept_mgr.name=BLANKS,
<span class="bold">1</span>    age        POSITION(35:37)    INTEGER&nbsp;EXTERNAL NULLIF&nbsp;dept_mgr.age=BLANKS,
<span class="bold">1</span>    emp_id     POSITION(40:46)    INTEGER&nbsp;EXTERNAL NULLIF dept_mgr.empid=BLANKS))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span>  101             Johny Quest            1024
   237   Physics   Albert Einstein   65   0000</pre><div class="infoboxnote" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__GUID-9E838423-5CA3-4238-881B-8E4BD49EF0F0">
                              <p class="notep1">Note:</p>
                              <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                              <ol>
                                 <li>
                                    <p>The <code class="codeph">NULLIF</code> clause corresponding to each attribute states the condition under which the attribute value should be <code class="codeph">NULL</code></p>
                                 </li>
                                 <li>
                                    <p>The age attribute of the <code class="codeph">dept_mgr </code>value is null. The <code class="codeph">dept_name</code> value is also null.
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="You can specify null values for objects.">Specifying Null Values for Objects</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3366"></a><a id="SUTIL3365"></a><a id="SUTIL1254"></a><div class="props_rev_3"><a id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" name="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3"></a><h5 id="SUTIL-GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" class="sect5"><span class="enumeration_section">11.1.5.2 </span>Specifying Atomic Nulls
                     </h5>
                     <div>
                        <p>You can specify atomic nulls.</p>
                        <div class="section">
                           <p>To specify in the control file the condition under which a particular object should take a null value (atomic null), you must follow that object's name with a <code class="codeph">NULLIF</code> clause based on a logical combination of any of the mapped fields (for example, in <a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">Example 11-5</a>, the named mapped fields would be <code class="codeph">dept_no</code>, <code class="codeph">dept_name</code>, <code class="codeph">name</code>, <code class="codeph">age</code>, <code class="codeph">emp_id</code>, but <code class="codeph">dept_mgr</code> would not be a named mapped field because it does not correspond (is not mapped) to any field in the data file). 
                           </p>
                           <p>Although the preceding is workable, it is not ideal when the condition under which an object should take the value of null is<span class="italic"> independent of any of the mapped fields.</span> In such situations, you can use filler fields. 
                           </p>
                           <p>You can map a filler field to the field in the data file (indicating if a particular object is atomically null or not) and use the filler field in the field condition of the <code class="codeph">NULLIF</code> clause of the particular object. This is shown in <a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">Example 11-6</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">
                           <p class="titleinexample">Example 11-6 Loading Data Using Filler Fields</p>
                           <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (dept_no         CHAR(5),
   dept_name        CHAR(30),
<span class="bold">1</span>  is_null          FILLER CHAR,
<span class="bold">2</span>  dept_mgr         COLUMN OBJECT NULLIF is_null=BLANKS
      (name         CHAR(30) NULLIF dept_mgr.name=BLANKS, 
      age           INTEGER EXTERNAL(3) NULLIF dept_mgr.age=BLANKS,
      emp_id        INTEGER EXTERNAL(7) 
                    NULLIF dept_mgr.emp_id=BLANKS,
      em_contact    COLUMN OBJECT NULLIF is_null2=BLANKS
         (name      CHAR(30) 
                    NULLIF dept_mgr.em_contact.name=BLANKS, 
         phone_num  CHAR(20) 
                    NULLIF dept_mgr.em_contact.phone_num=BLANKS)),
<span class="bold">1</span>  is_null2         FILLER CHAR)	
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">101,Mathematics,n,Johny Q.,,1024,"Barbie",608-251-0010,,
237,Physics,,"Albert Einstein",65,0000,,650-654-3210,n,
</pre><div class="infoboxnote" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__GUID-2910EC31-5FC5-497B-9541-EE8BBDA98686">
                              <p class="notep1">Note:</p>
                              <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                              <ol>
                                 <li>
                                    <p>The filler field (data file mapped; no corresponding column) is of type <code class="codeph">CHAR</code> (because it is a delimited field, the <code class="codeph">CHAR</code> defaults to <code class="codeph">CHAR(255)</code>). Note that the <code class="codeph">NULLIF</code> clause is not applicable to the filler field itself
                                    </p>
                                 </li>
                                 <li>
                                    <p>Gets the value of null (atomic null) if the <code class="codeph">is_null</code> field is blank.
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="You can specify null values for objects.">Specifying Null Values for Objects</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL3368"></a><a id="SUTIL3371"></a><a id="SUTIL3367"></a><a id="SUTIL3369"></a><a id="SUTIL3370"></a><a id="SUTIL1255"></a><div class="props_rev_3"><a id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" name="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB"></a><h4 id="SUTIL-GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" class="sect4"><span class="enumeration_section">11.1.6 </span>Loading Column Objects with User-Defined Constructors
                  </h4>
                  <div>
                     <p>You can load column objects with user-defined constructors.</p>
                     <div class="section">
                        <p>The Oracle database automatically supplies a default constructor for every object type. This constructor requires that all attributes of the type be specified as arguments in a call to the constructor. When a new instance of the object is created, its attributes take on the corresponding values in the argument list. This constructor is known as the attribute-value constructor. SQL*Loader uses the attribute-value constructor by default when loading column objects.</p>
                        <p>It is possible to override the attribute-value constructor by creating one or more user-defined constructors. When you create a user-defined constructor, you must supply a type body that performs the user-defined logic whenever a new instance of the object is created. A user-defined constructor may have the same argument list as the attribute-value constructor but differ in the logic that its type body implements.</p>
                        <p>When the argument list of a user-defined constructor function matches the argument list of the attribute-value constructor, there is a difference in behavior between conventional and direct path SQL*Loader. Conventional path mode results in a call to the user-defined constructor. Direct path mode results in a call to the attribute-value constructor. <a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">Example 11-7</a> illustrates this difference.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">
                        <p class="titleinexample">Example 11-7 Loading a Column Object with Constructors That Match</p>
                        <p>Object Type Definitions</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT
     (name     VARCHAR(30),
      ssn      NUMBER(9)) not final;

   CREATE TYPE employee_type UNDER person_type
     (empid    NUMBER(5),
   -- User-defined constructor that looks like an attribute-value constructor
      CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER, empid NUMBER)
        RETURN SELF AS RESULT);

   CREATE TYPE BODY employee_type AS
     CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER, empid NUMBER)
      RETURN SELF AS RESULT AS
   --User-defined constructor makes sure that the name attribute is uppercase.
      BEGIN
        SELF.name  := UPPER(name);
        SELF.ssn   := ssn;
        SELF.empid := empid;
        RETURN;
      END;

   CREATE TABLE personnel
     (deptno   NUMBER(3),
      deptname VARCHAR(30),
      employee employee_type);
</pre><p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
   INFILE *
   REPLACE
   INTO TABLE personnel
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (deptno        INTEGER EXTERNAL(3),
       deptname      CHAR,
       employee      COLUMN OBJECT
         (name       CHAR,
          ssn        INTEGER EXTERNAL(9),
          empid      INTEGER EXTERNAL(5)))

   BEGINDATA
<span class="bold">1</span>  101,Mathematics,Johny Q.,301189453,10249,
   237,Physics,"Albert Einstein",128606590,10030,</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-443036F0-BC42-46A4-BA03-67BF5AFD39D2">
                           <p class="notep1">Note:</p>
                           <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                           <ol>
                              <li>
                                 <p>When this control file is run in conventional path mode, the name fields, <code class="codeph">Johny</code> <code class="codeph">Q.</code> and <code class="codeph">Albert</code> <code class="codeph">Einstein</code>, are both loaded in uppercase. This is because the user-defined constructor is called in this mode. In contrast, when this control file is run in direct path mode, the name fields are loaded exactly as they appear in the input data. This is because the attribute-value constructor is called in this mode.
                                 </p>
                              </li>
                           </ol>
                           <p>It is possible to create a user-defined constructor whose argument list does not match that of the attribute-value constructor. In this case, both conventional and direct path modes will result in a call to the attribute-value constructor. Consider the definitions in <a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">Example 11-8</a>.
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">
                        <p class="titleinexample">Example 11-8 Loading a Column Object with Constructors That Do Not Match</p>
                        <p>Object Type Definitions</p><pre class="oac_no_warn" dir="ltr">CREATE SEQUENCE employee_ids
    START     WITH  1000
    INCREMENT BY    1;

   CREATE TYPE person_type AS OBJECT
     (name     VARCHAR(30),
      ssn      NUMBER(9)) not final;

   CREATE TYPE employee_type UNDER person_type
     (empid    NUMBER(5),
   -- User-defined constructor that does not look like an attribute-value 
   -- constructor
      CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER)
        RETURN SELF AS RESULT);

   CREATE TYPE BODY employee_type AS
     CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER)
      RETURN SELF AS RESULT AS
   -- This user-defined constructor makes sure that the name attribute is in
   -- lowercase and assigns the employee identifier based on a sequence.
        nextid     NUMBER;
        stmt       VARCHAR2(64);
      BEGIN

        stmt := 'SELECT employee_ids.nextval FROM DUAL';
        EXECUTE IMMEDIATE stmt INTO nextid;

        SELF.name  := LOWER(name);
        SELF.ssn   := ssn;
        SELF.empid := nextid; 
        RETURN;
      END;

   CREATE TABLE personnel
     (deptno   NUMBER(3),
      deptname VARCHAR(30),
      employee employee_type);
</pre><p>If the control file described in <a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">Example 11-7</a> is used with these definitions, then the name fields are loaded exactly as they appear in the input data (that is, in mixed case). This is because the attribute-value constructor is called in both conventional and direct path modes.
                        </p>
                        <p>It is still possible to load this table using conventional path mode by explicitly making reference to the user-defined constructor in a SQL expression. <a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">Example 11-9</a> shows how this can be done.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">
                        <p class="titleinexample">Example 11-9 Using SQL to Load Column Objects When Constructors Do Not Match</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
   INFILE *
   REPLACE
   INTO TABLE personnel
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (deptno        INTEGER EXTERNAL(3),
       deptname      CHAR,
       name          BOUNDFILLER CHAR,
       ssn           BOUNDFILLER INTEGER EXTERNAL(9),
<span class="bold">1</span>      employee      EXPRESSION "employee_type(:NAME, :SSN)")

   BEGINDATA
<span class="bold">1</span>  101,Mathematics,Johny Q.,301189453,
   237,Physics,"Albert Einstein",128606590,</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-33CE2A54-788D-4ADC-ABDB-D12184DC4CBF">
                           <p class="notep1">Note:</p>
                           <p>The callouts, in bold, to the left of the example correspond to the following note:</p>
                           <ol>
                              <li>
                                 <p>When this control file is run in conventional path mode, the name fields, <code class="codeph">Johny</code> <code class="codeph">Q.</code> and <code class="codeph">Albert</code> <code class="codeph">Einstein</code>, are both loaded in uppercase. This is because the user-defined constructor is called in this mode. In contrast, when this control file is run in direct path mode, the name fields are loaded exactly as they appear in the input data. This is because the attribute-value constructor is called in this mode.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>If the control file in <a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">Example 11-9</a> is used in direct path mode, then the following error is reported:
                        </p><pre class="oac_no_warn" dir="ltr">SQL*Loader-951: Error calling once/load initialization
ORA-26052: Unsupported type 121 for SQL expression on column EMPLOYEE.</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3374"></a><a id="SUTIL3372"></a><a id="SUTIL3373"></a><a id="SUTIL1256"></a><div class="props_rev_3"><a id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" name="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7"></a><h3 id="SUTIL-GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" class="sect3"><span class="enumeration_section">11.2 </span>Loading Object Tables
               </h3>
               <div>
                  <p>The control file syntax required to load an object table is nearly identical to that used to load a typical relational table.</p>
                  <div class="section">
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">Example 11-10</a> demonstrates loading an object table with primary-key-based object identifiers (OIDs).
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">
                     <p class="titleinexample">Example 11-10 Loading an Object Table with Primary Key OIDs</p>
                     <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
DISCARDFILE 'sample.dsc'
BADFILE 'sample.bad'
REPLACE
INTO TABLE employees 
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (name    CHAR(30)                NULLIF name=BLANKS,
   age      INTEGER EXTERNAL(3)     NULLIF age=BLANKS,
   emp_id   INTEGER EXTERNAL(5))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Johny Quest, 18, 007,
Speed Racer, 16, 000,
</pre><p>By looking only at the preceding control file you might not be able to determine if the table being loaded was an object table with system-generated OIDs, an object table with primary-key-based OIDs, or a relational table. </p>
                     <p>You may want to load data that already contains system-generated OIDs and to specify that instead of generating new OIDs, the existing OIDs in the data file should be used. To do this, you would follow the <code class="codeph">INTO</code> <code class="codeph">TABLE</code> clause with the <code class="codeph">OID</code> clause:
                     </p><pre class="oac_no_warn" dir="ltr">OID (<span class="italic">fieldname</span>)
</pre><p>In this clause, <span class="italic"><code class="codeph">fieldname</code></span> is the name of one of the fields (typically a filler field) from the field specification list that is mapped to a data field that contains the system-generated OIDs. SQL*Loader assumes that the OIDs provided are in the correct format and that they preserve OID global uniqueness. Therefore, to ensure uniqueness, you should use the Oracle OID generator to generate the OIDs to be loaded. 
                     </p>
                     <p>The <code class="codeph">OID</code> clause can only be used for system-generated OIDs, not primary-key-based OIDs.
                     </p>
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">Example 11-11</a> demonstrates loading system-generated OIDs with the row objects.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">
                     <p class="titleinexample">Example 11-11 Loading OIDs</p>
                     <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">   LOAD DATA
   INFILE 'sample.dat'
   INTO TABLE employees_v2 
<span class="bold">1</span>  OID (s_oid)
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (name    CHAR(30)                NULLIF name=BLANKS,
      age      INTEGER EXTERNAL(3)    NULLIF age=BLANKS,
      emp_id   INTEGER EXTERNAL(5),
<span class="bold">2</span>     s_oid    FILLER CHAR(32))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span>  Johny Quest, 18, 007, 21E978406D3E41FCE03400400B403BC3,
   Speed Racer, 16, 000, 21E978406D4441FCE03400400B403BC3,</pre><div class="infoboxnote" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__GUID-27E9E7A0-00BC-4899-A68B-224F13DA73DF">
                        <p class="notep1">Note:</p>
                        <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                        <ol>
                           <li>
                              <p>The <code class="codeph">OID</code> clause specifies that the <code class="codeph">s_oid</code> loader field contains the OID. The parentheses are required
                              </p>
                           </li>
                           <li>
                              <p>If <code class="codeph">s_oid</code> does not contain a valid hexadecimal number, then the particular record is rejected.
                              </p>
                           </li>
                           <li>
                              <p>The OID in the data file is a character string and is interpreted as a 32-digit hexadecimal number. The 32-digit hexadecimal number is later converted into a 16-byte <code class="codeph">RAW</code> and stored in the object table.
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E">Loading Object Tables with a Subtype</a><br>If an object table's row object is based on a nonfinal type, then SQL*Loader allows for any derived subtype to be loaded into the object table.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3376"></a><a id="SUTIL3375"></a><a id="SUTIL1257"></a><div class="props_rev_3"><a id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" name="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E"></a><h4 id="SUTIL-GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" class="sect4"><span class="enumeration_section">11.2.1 </span>Loading Object Tables with a Subtype
                  </h4>
                  <div>
                     <p>If an object table's row object is based on a nonfinal type, then SQL*Loader allows for any derived subtype to be loaded into the object table.</p>
                     <div class="section">
                        <p>As previously mentioned, the syntax required to load an object table with a derived subtype is almost identical to that used for a typical relational table. However, in this case, the actual subtype to be used must be named, so that SQL*Loader can determine if it is a valid subtype for the object table. This concept is illustrated in <a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">Example 11-12</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">
                        <p class="titleinexample">Example 11-12 Loading an Object Table with a Subtype</p>
                        <p>Object Type Definitions</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employees_type AS OBJECT
  (name     VARCHAR2(30),
   age      NUMBER(3),
   emp_id   NUMBER(5)) not final;

CREATE TYPE hourly_emps_type UNDER employees_type
  (hours    NUMBER(3));

CREATE TABLE employees_v3 of employees_type;
</pre><p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">   LOAD DATA

   INFILE 'sample.dat'
   INTO TABLE employees_v3
<span class="bold">1</span>  TREAT AS hourly_emps_type
   FIELDS TERMINATED BY ','
     (name     CHAR(30),
      age      INTEGER EXTERNAL(3),
      emp_id   INTEGER EXTERNAL(5),
<span class="bold">2</span>     hours    INTEGER EXTERNAL(2))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">   Johny Quest, 18, 007, 32,
   Speed Racer, 16, 000, 20,</pre><div class="infoboxnote" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__GUID-1DDDD770-D862-4499-AD69-7B28D777E46F">
                           <p class="notep1">Note:</p>
                           <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                           <ol>
                              <li>
                                 <p>The <code class="codeph">TREAT</code> <code class="codeph">AS</code> clause indicates that SQL*Loader should treat the object table as if it were declared to be of type <code class="codeph">hourly_emps_type</code>, instead of its actual declared type, <code class="codeph">employee_type</code></p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">hours</code> attribute is allowed here because it is an attribute of the <code class="codeph">hourly_emps_type</code>. If the <code class="codeph">TREAT</code> <code class="codeph">AS</code> clause had not been specified, then this attribute would have resulted in an error, because it is not an attribute of the object table's declared type.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" title="The control file syntax required to load an object table is nearly identical to that used to load a typical relational table.">Loading Object Tables</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1258"></a><div class="props_rev_3"><a id="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" name="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8"></a><h3 id="SUTIL-GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" class="sect3"><span class="enumeration_section">11.3 </span>Loading REF Columns
               </h3>
               <div>
                  <p>SQL*Loader can load system-generated OID <code class="codeph">REF</code> columns, primary-key-based <code class="codeph">REF</code> columns, and unscoped <code class="codeph">REF</code> columns that allow primary keys.
                  </p>
                  <p>For each of these, the way in which table names are specified is important, as described in the following section.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02">Specifying Table Names in a REF Clause</a><br>You can specify table names in a REF clause.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E">System-Generated OID REF Columns</a><br>SQL*Loader assumes, when loading system-generated <code class="codeph">REF</code> columns, that the actual OIDs from which the <code class="codeph">REF</code> columns are to be constructed are in the data file with the rest of the data.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54">Primary Key REF Columns</a><br>To load a primary key <code class="codeph">REF</code> column, the SQL*Loader control-file field description must provide the column name followed by a <code class="codeph">REF</code> clause.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E">Unscoped REF Columns That Allow Primary Keys</a><br>An unscoped <code class="codeph">REF</code> column that allows primary keys can reference both system-generated and primary key <code class="codeph">REF</code>s.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1259"></a><div class="props_rev_3"><a id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" name="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02"></a><h4 id="SUTIL-GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" class="sect4"><span class="enumeration_section">11.3.1 </span>Specifying Table Names in a REF Clause
                  </h4>
                  <div>
                     <p>You can specify table names in a REF clause.</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02__GUID-460B1246-3443-42E7-B86C-02669480DEDF">
                           <p class="notep1">Note:</p>
                           <p>The information in this section applies only to environments in which the release of both SQL*Loader and Oracle Database are 11<span class="italic">g</span> release 1 (11.1) or later. It does not apply to environments in which either SQL*Loader, Oracle Database, or both are at an earlier release.
                           </p>
                        </div>
                        <p>In the SQL*Loader control file, the description of the field corresponding to a <code class="codeph">REF</code> column consists of the column name followed by a REF clause. The REF clause takes as arguments the table name and any attributes applicable to the type of <code class="codeph">REF</code> column being loaded. The table names can either be specified dynamically (using filler fields) or as constants. The table name can also be specified with or without the schema name. 
                        </p>
                        <p>Whether the table name specified in the REF clause is specified as a constant or by using a filler field, it is interpreted as case-sensitive. This could result in the following situations:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If user <code class="codeph">SCOTT</code> creates a table named <code class="codeph">table2</code> in lowercase without quotation marks around the table name, then it can be used in a REF clause in any of the following ways:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">REF(constant 'TABLE2', ...)</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF(constant '"TABLE2"', ...)</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF(constant 'SCOTT.TABLE2', ...)</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>If user <code class="codeph">SCOTT</code> creates a table named <code class="codeph">"Table2"</code> using quotation marks around a mixed-case name, then it can be used in a REF clause in any of the following ways: 
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">REF(constant 'Table2', ...)</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF(constant '"Table2"', ...)</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF(constant 'SCOTT.Table2', ...)</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>In both of those situations, if <code class="codeph">constant</code> is replaced with a filler field, then the same values as shown in the examples will also work if they are placed in the data section.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL*Loader can load system-generated OID REF columns, primary-key-based REF columns, and unscoped REF columns that allow primary keys.">Loading REF Columns</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3378"></a><a id="SUTIL3377"></a><a id="SUTIL1260"></a><div class="props_rev_3"><a id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" name="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E"></a><h4 id="SUTIL-GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" class="sect4"><span class="enumeration_section">11.3.2 </span>System-Generated OID REF Columns
                  </h4>
                  <div>
                     <p>SQL*Loader assumes, when loading system-generated <code class="codeph">REF</code> columns, that the actual OIDs from which the <code class="codeph">REF</code> columns are to be constructed are in the data file with the rest of the data.
                     </p>
                     <div class="section">
                        <p>The description of the field corresponding to a <code class="codeph">REF</code> column consists of the column name followed by the <code class="codeph">REF</code> clause. 
                        </p>
                        <p>The <code class="codeph">REF</code> clause takes as arguments the table name and an OID. Note that the arguments can be specified either as constants or dynamically (using filler fields). See <a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a> for the appropriate syntax. <a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">Example 11-13</a> demonstrates loading system-generated OID <code class="codeph">REF</code> columns.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">
                        <p class="titleinexample">Example 11-13 Loading System-Generated REF Columns</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_alt_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  (dept_no      CHAR(5),
   dept_name    CHAR(30),
<span class="bold">1</span> dept_mgr     REF(t_name, s_oid),
   s_oid        FILLER CHAR(32),
   t_name       FILLER CHAR(30))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">22345, QuestWorld, 21E978406D3E41FCE03400400B403BC3, EMPLOYEES_V2,
23423, Geography, 21E978406D4441FCE03400400B403BC3, EMPLOYEES_V2,</pre><div class="infoboxnote" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__GUID-C7ABDD8B-A9B0-4B5D-8FC5-229D452C0EB9">
                           <p class="notep1">Note:</p>
                           <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                           <ol>
                              <li>
                                 <p>If the specified table does not exist, then the record is rejected. The <code class="codeph">dept_mgr</code> field itself does not map to any field in the data file.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL*Loader can load system-generated OID REF columns, primary-key-based REF columns, and unscoped REF columns that allow primary keys.">Loading REF Columns</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3379"></a><a id="SUTIL1261"></a><div class="props_rev_3"><a id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54" name="GUID-99A7B7BD-B555-4457-975C-C4E038632B54"></a><h4 id="SUTIL-GUID-99A7B7BD-B555-4457-975C-C4E038632B54" class="sect4"><span class="enumeration_section">11.3.3 </span>Primary Key REF Columns
                  </h4>
                  <div>
                     <p>To load a primary key <code class="codeph">REF</code> column, the SQL*Loader control-file field description must provide the column name followed by a <code class="codeph">REF</code> clause.
                     </p>
                     <div class="section">
                        <p>The <code class="codeph">REF</code> clause takes for arguments a comma-delimited list of field names and constant values. The first argument is the table name, followed by arguments that specify the primary key OID on which the <code class="codeph">REF</code> column to be loaded is based. See <a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a> for the appropriate syntax.
                        </p>
                        <p>SQL*Loader assumes that the ordering of the arguments matches the relative ordering of the columns making up the primary key OID in the referenced table. <a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">Example 11-14</a> demonstrates loading primary key <code class="codeph">REF</code> columns.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">
                        <p class="titleinexample">Example 11-14 Loading Primary Key REF Columns</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_alt
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
 (dept_no       CHAR(5),
 dept_name      CHAR(30),
 dept_mgr       REF(CONSTANT 'EMPLOYEES', emp_id),
 emp_id         FILLER CHAR(32))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">22345, QuestWorld, 007,
23423, Geography, 000,</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL*Loader can load system-generated OID REF columns, primary-key-based REF columns, and unscoped REF columns that allow primary keys.">Loading REF Columns</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1262"></a><div class="props_rev_3"><a id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" name="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E"></a><h4 id="SUTIL-GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" class="sect4"><span class="enumeration_section">11.3.4 </span>Unscoped REF Columns That Allow Primary Keys
                  </h4>
                  <div>
                     <p>An unscoped <code class="codeph">REF</code> column that allows primary keys can reference both system-generated and primary key <code class="codeph">REF</code>s.
                     </p>
                     <p>The syntax for loading into such a <code class="codeph">REF</code> column is the same as if you were loading into a system-generated OID <code class="codeph">REF</code> column or into a primary-key-based <code class="codeph">REF</code> column. See <a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">Example 11-13</a> and <a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">Example 11-14</a>.
                     </p>
                     <p>The following restrictions apply when loading into an unscoped <code class="codeph">REF</code> column that allows primary keys:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Only one type of <code class="codeph">REF</code> can be referenced by this column during a single-table load, either system-generated or primary key, but not both. If you try to reference both types, then the data row will be rejected with an error message indicating that the referenced table name is invalid.
                           </p>
                        </li>
                        <li>
                           <p>If you are loading unscoped primary key <code class="codeph">REF</code>s to this column, then only one object table can be referenced during a single-table load. That is, to load unscoped primary key <code class="codeph">REF</code>s, some pointing to object table X and some pointing to object table Y, you would have to do one of the following: 
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Perform two single-table loads. </p>
                              </li>
                              <li>
                                 <p>Perform a single load using multiple <code class="codeph">INTO</code> <code class="codeph">TABLE</code> clauses for which the <code class="codeph">WHEN</code> clause keys off some aspect of the data, such as the object table name for the unscoped primary key <code class="codeph">REF</code>. For example:
                                 </p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'data.dat' 

INTO TABLE orders_apk 
APPEND 
when CUST_TBL = "CUSTOMERS_PK" 
fields terminated by "," 
( 
  order_no   position(1)  char, 
  cust_tbl FILLER     char, 
  cust_no  FILLER     char, 
  cust   REF (cust_tbl, cust_no) NULLIF order_no='0' 
) 

INTO TABLE orders_apk 
APPEND 
when CUST_TBL = "CUSTOMERS_PK2" 
fields terminated by "," 
( 
  order_no  position(1)  char, 
  cust_tbl FILLER     char, 
  cust_no  FILLER     char, 
  cust   REF (cust_tbl, cust_no) NULLIF order_no='0' 
) 
</pre></li>
                           </ul>
                           <p>If you do not use either of these methods, then the data row will be rejected with an error message indicating that the referenced table name is invalid. </p>
                        </li>
                        <li>
                           <p>Unscoped primary key <code class="codeph">REF</code>s in collections are not supported by SQL*Loader.
                           </p>
                        </li>
                        <li>
                           <p>If you are loading system-generated <code class="codeph">REF</code>s into this <code class="codeph">REF</code> column, then any limitations described in <a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" title="SQL*Loader assumes, when loading system-generated REF columns, that the actual OIDs from which the REF columns are to be constructed are in the data file with the rest of the data.">System-Generated OID REF Columns</a> also apply here.
                           </p>
                        </li>
                        <li>
                           <p>If you are loading primary key <code class="codeph">REF</code>s into this <code class="codeph">REF</code> column, then any limitations described in <a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54" title="To load a primary key REF column, the SQL*Loader control-file field description must provide the column name followed by a REF clause.">Primary Key REF Columns</a> also apply here.
                           </p>
                           <div class="infoboxnote" id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E__GUID-812DC3BE-E73D-468F-A047-6A7CAC5DC4A7">
                              <p class="notep1">Note:</p>
                              <p>For an unscoped <code class="codeph">REF</code> column that allows primary keys, SQL*Loader takes the first valid object table parsed (either from the <code class="codeph">REF</code> directive or from the data rows) and uses that object table's OID type to determine the <code class="codeph">REF</code> type that can be referenced in that single-table load.
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL*Loader can load system-generated OID REF columns, primary-key-based REF columns, and unscoped REF columns that allow primary keys.">Loading REF Columns</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1263"></a><div class="props_rev_3"><a id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80" name="GUID-3637F462-436A-4F6B-B243-03FB3177CA80"></a><h3 id="SUTIL-GUID-3637F462-436A-4F6B-B243-03FB3177CA80" class="sect3"><span class="enumeration_section">11.4 </span>Loading LOBs
               </h3>
               <div>
                  <p>The section describes loading LOBs.</p>
                  <p>A LOB is a <span class="italic">large object type.</span> SQL*Loader supports the following types of LOBs:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">BLOB</code>: an internal LOB containing unstructured binary data
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOB</code>: an internal LOB containing character data
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">NCLOB</code>: an internal LOB containing characters from a national character set
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">BFILE</code>: a <code class="codeph">BLOB</code> stored outside of the database tablespaces in a server-side operating system file
                        </p>
                     </li>
                  </ul>
                  <p>LOBs can be column data types, and except for <code class="codeph">NCLOB</code>, they can be an object's attribute data types. LOBs can have actual values, they can be null, or they can be empty. SQL*Loader creates an empty LOB when there is a 0-length field to store in the LOB. (Note that this is different than other data types where SQL*Loader sets the column to NULL for any 0-length string.) This means that <span class="italic">the only way to load NULL values into a LOB column is to use the NULLIF clause.</span></p>
                  <p><code class="codeph">XML</code> columns are columns declared to be of type <code class="codeph">SYS</code>.<code class="codeph">XMLTYPE</code>. SQL*Loader treats <code class="codeph">XML</code> columns as if they were <code class="codeph">CLOB</code>s. All of the methods described in the following sections for loading LOB data from the primary data file or from LOBFILEs are applicable to loading <code class="codeph">XML</code> columns.
                  </p>
                  <div class="infoboxnote" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-06840CCC-CAEF-418F-8AB7-BC1F35FA2F30">
                     <p class="notep1">Note:</p>
                     <p>You cannot specify a SQL string for LOB fields. This is true even if you specify <code class="codeph">LOBFILE_spec</code>.
                     </p>
                  </div>
                  <p>Because LOBs can be quite large, SQL*Loader can load LOB data from either a primary data file (in line with the rest of the data) or from LOBFILEs, as described in the following sections:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9">Loading LOB Data from a Primary Data File</a><br>You can load LOB columns from a primary data file.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3">Loading LOB Data from LOBFILEs</a><br>LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file. 
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB">Loading Data Files that Contain LLS Fields</a><br>If a field in a data file is a LOB location Specifier (LLS) field, then you can indicate this by using the <code class="codeph">LLS</code> clause.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-C59A3A12-0A60-4069-BC84-B6107D75F3D6">
                     <p class="notep1">See Also:</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50994" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about large object (LOB) data types
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1264"></a><div class="props_rev_3"><a id="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" name="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9"></a><h4 id="SUTIL-GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" class="sect4"><span class="enumeration_section">11.4.1 </span>Loading LOB Data from a Primary Data File 
                  </h4>
                  <div>
                     <p>You can load LOB columns from a primary data file.</p>
                     <p>To load internal LOBs (<code class="codeph">BLOB</code>s, <code class="codeph">CLOB</code>s, and <code class="codeph">NCLOB</code>s) or <code class="codeph">XML</code> columns from a primary data file, you can use the following standard SQL*Loader formats:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Predetermined size fields</p>
                        </li>
                        <li>
                           <p>Delimited fields</p>
                        </li>
                        <li>
                           <p>Length-value pair fields</p>
                        </li>
                     </ul>
                     <p>Each of these formats is described in the following sections.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0">LOB Data in Predetermined Size Fields</a><br>You can load LOB data into predetermined size fields.
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB">LOB Data in Delimited Fields</a><br>You can load LOB data into delimited fields.
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200">LOB Data in Length-Value Pair Fields</a><br>You can use <code class="codeph">VARCHAR</code>, <code class="codeph">VARCHARC</code>, or <code class="codeph">VARRAW</code> data types to load LOB data organized in length-value pair fields. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="The section describes loading LOBs.">Loading LOBs</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3381"></a><a id="SUTIL3380"></a><a id="SUTIL1265"></a><div class="props_rev_3"><a id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" name="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0"></a><h5 id="SUTIL-GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" class="sect5"><span class="enumeration_section">11.4.1.1 </span>LOB Data in Predetermined Size Fields
                     </h5>
                     <div>
                        <p>You can load LOB data into predetermined size fields.</p>
                        <div class="section">
                           <p>This is a very fast and conceptually simple format in which to load LOBs, as shown in <a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">Example 11-15</a>. 
                           </p>
                           <div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-C2207E1E-1554-40A4-BD9F-4DE696F36D9D">
                              <p class="notep1">Note:</p>
                              <p>Because the LOBs you are loading may not be of equal size, you can use whitespace to pad the LOB data to make the LOBs all of equal length within a particular data field. </p>
                           </div>
                           <p>To load LOBs using this format, you should use either <code class="codeph">CHAR</code> or <code class="codeph">RAW</code> as the loading data type. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">
                           <p class="titleinexample">Example 11-15 Loading LOB Data in Predetermined Size Fields</p>
                           <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat' "fix 501"
INTO TABLE person_table
   (name       POSITION(01:21)       CHAR,
<span class="bold">1</span>  "RESUME"    POSITION(23:500)      CHAR   DEFAULTIF "RESUME"=BLANKS)
</pre><p>Data File (sample.dat)	</p><pre class="oac_no_warn" dir="ltr">Julia Nayer      Julia Nayer
             500 Example Parkway
             jnayer@us.example.com ...</pre><div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-E336CB2A-06F4-4B14-B89D-D6E5AE6257F1">
                              <p class="notep1">Note:</p>
                              <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                              <ol>
                                 <li>
                                    <p>Because the <code class="codeph">DEFAULTIF</code> clause is used, if the data field containing the resume is empty, then the result is an empty LOB rather than a null LOB. However, if a <code class="codeph">NULLIF</code> clause had been used instead of <code class="codeph">DEFAULTIF</code>, then the empty data field would be null.
                                    </p>
                                    <p>You can use SQL*Loader data types other than <code class="codeph">CHAR</code> to load LOBs. For example, when loading <code class="codeph">BLOB</code>s, you would probably want to use the <code class="codeph">RAW</code> data type.
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="You can load LOB columns from a primary data file.">Loading LOB Data from a Primary Data File</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3383"></a><a id="SUTIL3382"></a><a id="SUTIL1266"></a><div class="props_rev_3"><a id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" name="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB"></a><h5 id="SUTIL-GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" class="sect5"><span class="enumeration_section">11.4.1.2 </span>LOB Data in Delimited Fields
                     </h5>
                     <div>
                        <p>You can load LOB data into delimited fields.</p>
                        <p>This format handles LOBs of different sizes within the same column (data file field) without a problem. However, this added flexibility can affect performance because SQL*Loader must scan through the data, looking for the delimiter string. </p>
                        <p>As with single-character delimiters, when you specify string delimiters, you should consider the character set of the data file. When the character set of the data file is different than that of the control file, you can specify the delimiters in hexadecimal notation (that is, <span class="italic"><code class="codeph">X'hexadecimal</code></span> <span class="italic"><code class="codeph">string</code></span><code class="codeph">'</code>). If the delimiters are specified in hexadecimal notation, then the specification must consist of characters that are valid in the character set of the input data file. In contrast, if hexadecimal notation is not used, then the delimiter specification is considered to be in the client's (that is, the control file's) character set. In this case, the delimiter is converted into the data file's character set before SQL*Loader searches for the delimiter in the data file.
                        </p>
                        <p>Note the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Stutter syntax is supported with string delimiters (that is, the closing enclosure delimiter can be stuttered).</p>
                           </li>
                           <li>
                              <p>Leading whitespaces in the initial multicharacter enclosure delimiter are not allowed.</p>
                           </li>
                           <li>
                              <p>If a field is terminated by <code class="codeph">WHITESPACE</code>, then the leading whitespaces are trimmed.
                              </p>
                              <div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-F57761C4-9E21-43DA-853D-881E7E4B5114">
                                 <p class="notep1">Note:</p>
                                 <p>SQL*Loader defaults to 255 bytes when moving <code class="codeph">CLOB</code> data, but a value of up to 2 gigabytes can be specified. For a delimited field, if a length is specified, then that length is used as a maximum. If no maximum is specified, then it defaults to 255 bytes. For a <code class="codeph">CHAR</code> field that is delimited and is also greater than 255 bytes, you must specify a maximum length. See <a href="oracle-sql-loader-field-list-contents.html#GUID-34A526C6-C2E6-4D17-8F53-D0CDEF38874B">CHAR</a> for more information about the <code class="codeph">CHAR</code> data type.
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">Example 11-16</a> shows an example of loading LOB data in delimited fields.
                        </p>
                        <div class="example" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">
                           <p class="titleinexample">Example 11-16 Loading LOB Data in Delimited Fields</p>
                           <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat' "str '|'"
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name        CHAR(25),
<span class="bold">1</span>  "RESUME"     CHAR(507) ENCLOSED BY '&lt;startlob&gt;' AND '&lt;endlob&gt;')
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Julia Nayer,&lt;startlob&gt;        Julia Nayer
                          500 Example Parkway
                          jnayer@us.example.com ...   &lt;endlob&gt;
<span class="bold">2</span>  |Bruce Ernst, .......</pre><div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-A951C3DE-B7F4-4785-951F-559B8B4A09FF">
                              <p class="notep1">Note:</p>
                              <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                              <ol>
                                 <li>
                                    <p><code class="codeph">&lt;startlob&gt;</code> and <code class="codeph">&lt;endlob&gt;</code> are the enclosure strings. With the default byte-length semantics, the maximum length for a LOB that can be read using <code class="codeph">CHAR(507)</code> is 507 bytes. If character-length semantics were used, then the maximum would be 507 characters. See <a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="Byte-length semantics are the default for all data files except those that use the UTF16 character set (which uses character-length semantics by default).">Character-Length Semantics</a></p>
                                 </li>
                                 <li>
                                    <p>If the record separator <code class="codeph">'|'</code> had been placed right after <code class="codeph">&lt;endlob&gt;</code> and followed with the newline character, then the newline would have been interpreted as part of the next record. An alternative would be to make the newline part of the record separator (for example, <code class="codeph">'|\n' </code>or, in hexadecimal notation, <code class="codeph">X'7C0A'</code>).
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="You can load LOB columns from a primary data file.">Loading LOB Data from a Primary Data File</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3385"></a><a id="SUTIL3384"></a><a id="SUTIL1267"></a><div class="props_rev_3"><a id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" name="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200"></a><h5 id="SUTIL-GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" class="sect5"><span class="enumeration_section">11.4.1.3 </span>LOB Data in Length-Value Pair Fields
                     </h5>
                     <div>
                        <p>You can use <code class="codeph">VARCHAR</code>, <code class="codeph">VARCHARC</code>, or <code class="codeph">VARRAW</code> data types to load LOB data organized in length-value pair fields. 
                        </p>
                        <p>This method of loading provides better performance than using delimited fields, but can reduce flexibility (for example, you must know the LOB length for each LOB before loading). <a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">Example 11-17</a> demonstrates loading LOB data in length-value pair fields.
                        </p>
                        <div class="example" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">
                           <p class="titleinexample">Example 11-17 Loading LOB Data in Length-Value Pair Fields</p>
                           <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">  LOAD DATA 
<span class="bold">1</span> INFILE 'sample.dat' "str '&lt;endrec&gt;\n'"
  INTO TABLE person_table
  FIELDS TERMINATED BY ','
     (name       CHAR(25),
<span class="bold">2</span>    "RESUME"    VARCHARC(3,500))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">  Julia Nayer,479                Julia Nayer
                             500 Example Parkway
                             jnayer@us.example.com
                                    ... &lt;endrec&gt;
<span class="bold">3</span>    Bruce Ernst,000&lt;endrec&gt;</pre><div class="infoboxnote" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__GUID-AEF0A144-BF31-49A5-9F67-40F8EF97BA98">
                              <p class="notep1">Note:</p>
                              <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                              <ol>
                                 <li>
                                    <p>If the backslash escape character is not supported, then the string used as a record separator in the example could be expressed in hexadecimal notation.</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">"RESUME"</code> is a field that corresponds to a <code class="codeph">CLOB</code> column. In the control file, it is a <code class="codeph">VARCHARC</code>, whose length field is 3 bytes long and whose maximum size is 500 bytes (with byte-length semantics). If character-length semantics were used, then the length would be 3 characters and the maximum size would be 500 characters. See <a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="Byte-length semantics are the default for all data files except those that use the UTF16 character set (which uses character-length semantics by default).">Character-Length Semantics</a>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The length subfield of the <code class="codeph">VARCHARC</code> is 0 (the value subfield is empty). Consequently, the LOB instance is initialized to empty.
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="You can load LOB columns from a primary data file.">Loading LOB Data from a Primary Data File</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1268"></a><div class="props_rev_3"><a id="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" name="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3"></a><h4 id="SUTIL-GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" class="sect4"><span class="enumeration_section">11.4.2 </span>Loading LOB Data from LOBFILEs
                  </h4>
                  <div>
                     <p>LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file. </p>
                     <p>In LOBFILEs, LOB data instances are still considered to be in fields (predetermined size, delimited, length-value), but these fields are not organized into records (the concept of a record does not exist within LOBFILEs). Therefore, the processing overhead of dealing with records is avoided. This type of organization of data is ideal for LOB loading.</p>
                     <p>There is no requirement that a LOB from a LOBFILE fit in memory. SQL*Loader reads LOBFILEs in 64 KB chunks.</p>
                     <p> In LOBFILEs the data can be in any of the following types of fields:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A single LOB field into which the entire contents of a file can be read</p>
                        </li>
                        <li>
                           <p>Predetermined size fields (fixed-length fields)</p>
                        </li>
                        <li>
                           <p>Delimited fields (that is, <code class="codeph">TERMINATED</code> <code class="codeph">BY</code> or <code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>)
                           </p>
                           <p>The clause <code class="codeph">PRESERVE</code> <code class="codeph">BLANKS</code> is not applicable to fields read from a LOBFILE.
                           </p>
                        </li>
                        <li>
                           <p>Length-value pair fields (variable-length fields)</p>
                           <p>To load data from this type of field, use the <code class="codeph">VARRAW</code>, <code class="codeph">VARCHAR</code>, or <code class="codeph">VARCHARC</code> SQL*Loader data types.
                           </p>
                        </li>
                     </ul>
                     <p>See <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="This section contains examples of loading data from different types of fields in LOBFILEs.">Examples of Loading LOB Data from LOBFILEs</a> for examples of using each of these field types. All of the previously mentioned field types can be used to load <code class="codeph">XML</code> columns.
                     </p>
                     <p>See <a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABEHEID">lobfile_spec</a> for LOBFILE syntax.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E488305F-90E5-4FE8-B122-A9341F99C450">Dynamic Versus Static LOBFILE Specifications</a><br>You can specify LOBFILEs either statically (the name of the file is specified in the control file) or dynamically (a <code class="codeph">FILLER</code> field is used as the source of the file name). 
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475">Examples of Loading LOB Data from LOBFILEs</a><br>This section contains examples of loading data from different types of fields in LOBFILEs.
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60">Considerations When Loading LOBs from LOBFILEs</a><br>There are considerations to take into account when loading LOBs from LOBFILEs.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="The section describes loading LOBs.">Loading LOBs</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1269"></a><div class="props_rev_3"><a id="GUID-E488305F-90E5-4FE8-B122-A9341F99C450" name="GUID-E488305F-90E5-4FE8-B122-A9341F99C450"></a><h5 id="SUTIL-GUID-E488305F-90E5-4FE8-B122-A9341F99C450" class="sect5"><span class="enumeration_section">11.4.2.1 </span>Dynamic Versus Static LOBFILE Specifications
                     </h5>
                     <div>
                        <p>You can specify LOBFILEs either statically (the name of the file is specified in the control file) or dynamically (a <code class="codeph">FILLER</code> field is used as the source of the file name). 
                        </p>
                        <p>In either case, if the LOBFILE is <span class="italic">not</span> terminated by EOF, then when the end of the LOBFILE is reached, the file is closed and further attempts to read data from that file produce results equivalent to reading data from an empty field. 
                        </p>
                        <p>However, if you have a LOBFILE that <span class="italic">is</span> terminated by EOF, then the entire file is always returned on each attempt to read data from that file.
                        </p>
                        <p>You should not specify the same LOBFILE as the source of two different fields. If you do, then the two fields typically read the data independently. </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file.">Loading LOB Data from LOBFILEs</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1270"></a><div class="props_rev_3"><a id="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" name="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475"></a><h5 id="SUTIL-GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" class="sect5"><span class="enumeration_section">11.4.2.2 </span>Examples of Loading LOB Data from LOBFILEs
                     </h5>
                     <div>
                        <p>This section contains examples of loading data from different types of fields in LOBFILEs.</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E">One LOB per File</a><br>Each LOBFILE is the source of a single LOB when loading LOB data.
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6">Predetermined Size LOBs</a><br>You can load LOB data using predetermined size LOBs.
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84">Delimited LOBs</a><br>You can load LOB data using delimited LOBs.
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258">Length-Value Pair Specified LOBs</a><br>You can load LOB data using length-value pair specified LOBs.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file.">Loading LOB Data from LOBFILEs</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="SUTIL3387"></a><a id="SUTIL3386"></a><a id="SUTIL1271"></a><div class="props_rev_3"><a id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" name="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E"></a><h6 id="SUTIL-GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" class="sect6"><span class="enumeration_section">11.4.2.2.1 </span>One LOB per File
                        </h6>
                        <div>
                           <p>Each LOBFILE is the source of a single LOB when loading LOB data.</p>
                           <div class="section">
                              <p>In <a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">Example 11-18</a>, each LOBFILE is the source of a single LOB. To load LOB data that is organized in this way, the column or field name is followed by the LOBFILE data type specifications. 
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">
                              <p class="titleinexample">Example 11-18 Loading LOB Data with One LOB per LOBFILE</p>
                              <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat'
   INTO TABLE person_table
   FIELDS TERMINATED BY ','
   (name      CHAR(20),
<span class="bold">1</span>  ext_fname    FILLER CHAR(40),
<span class="bold">2</span>  "RESUME"     LOBFILE(ext_fname) TERMINATED BY EOF)
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Johny Quest,jqresume.txt,
Speed Racer,'/private/sracer/srresume.txt',
</pre><p>Secondary Data File (jqresume.txt)</p><pre class="oac_no_warn" dir="ltr">             Johny Quest
         500 Oracle Parkway
            ...</pre><p>Secondary Data File (srresume.txt)</p><pre class="oac_no_warn" dir="ltr">         Speed Racer
     400 Oracle Parkway
        ...</pre><div class="infoboxnote" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__GUID-96CCBFC1-F848-4D9F-BF58-CDF14A9C878A">
                                 <p class="notep1">Note:</p>
                                 <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                                 <ol>
                                    <li>
                                       <p>The filler field is mapped to the 40-byte data field, which is read using the SQL*Loader <code class="codeph">CHAR</code> data type. This assumes the use of default byte-length semantics. If character-length semantics were used, then the field would be mapped to a 40-character data field
                                       </p>
                                    </li>
                                    <li>
                                       <p>SQL*Loader gets the LOBFILE name from the <code class="codeph">ext_fname</code> filler field. It then loads the data from the LOBFILE (using the <code class="codeph">CHAR</code> data type) from the first byte to the EOF character. If no existing LOBFILE is specified, then the <code class="codeph">"RESUME"</code> field is initialized to empty.
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="This section contains examples of loading data from different types of fields in LOBFILEs.">Examples of Loading LOB Data from LOBFILEs</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3389"></a><a id="SUTIL3388"></a><a id="SUTIL1272"></a><div class="props_rev_3"><a id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" name="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6"></a><h6 id="SUTIL-GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" class="sect6"><span class="enumeration_section">11.4.2.2.2 </span>Predetermined Size LOBs
                        </h6>
                        <div>
                           <p>You can load LOB data using predetermined size LOBs.</p>
                           <div class="section">
                              <p>In <a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">Example 11-19</a>, you specify the size of the LOBs to be loaded into a particular column in the control file. During the load, SQL*Loader assumes that any LOB data loaded into that particular column is of the specified size. The predetermined size of the fields allows the data-parser to perform optimally. However, it is often difficult to guarantee that all LOBs are the same size.
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">
                              <p class="titleinexample">Example 11-19 Loading LOB Data Using Predetermined Size LOBs</p>
                              <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name     CHAR(20),
<span class="bold">1</span>  "RESUME"    LOBFILE(CONSTANT '/usr/private/jquest/jqresume.txt')
               CHAR(2000))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Johny Quest,
Speed Racer,</pre><p>Secondary Data File (jqresume.txt)</p><pre class="oac_no_warn" dir="ltr">             Johny Quest
         500 Oracle Parkway
            ...
             Speed Racer
         400 Oracle Parkway
            ...</pre><div class="infoboxnote" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__GUID-662CA784-A08B-4576-8C0E-34F3D066B87B">
                                 <p class="notep1">Note:</p>
                                 <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                                 <ol>
                                    <li>
                                       <p>This entry specifies that SQL*Loader load 2000 bytes of data from the <code class="codeph">jqresume.txt</code> LOBFILE, using the <code class="codeph">CHAR</code> data type, starting with the byte following the byte loaded last during the current loading session. This assumes the use of the default byte-length semantics. If character-length semantics were used, then SQL*Loader would load 2000 characters of data, starting from the first character after the last-loaded character. See <a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="Byte-length semantics are the default for all data files except those that use the UTF16 character set (which uses character-length semantics by default).">Character-Length Semantics</a>.
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="This section contains examples of loading data from different types of fields in LOBFILEs.">Examples of Loading LOB Data from LOBFILEs</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3391"></a><a id="SUTIL3390"></a><a id="SUTIL1273"></a><div class="props_rev_3"><a id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" name="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84"></a><h6 id="SUTIL-GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" class="sect6"><span class="enumeration_section">11.4.2.2.3 </span>Delimited LOBs
                        </h6>
                        <div>
                           <p>You can load LOB data using delimited LOBs.</p>
                           <div class="section">
                              <p>In <a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">Example 11-20</a>, the LOB data instances in the LOBFILE are delimited. In this format, loading different size LOBs into the same column is not a problem. However, this added flexibility can affect performance, because SQL*Loader must scan through the data, looking for the delimiter string. 
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">
                              <p class="titleinexample">Example 11-20 Loading LOB Data Using Delimited LOBs</p>
                              <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name     CHAR(20),
<span class="bold">1</span>  "RESUME"    LOBFILE( CONSTANT 'jqresume') CHAR(2000) 
               TERMINATED BY "&lt;endlob&gt;\n")
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Johny Quest,
Speed Racer,
</pre><p>Secondary Data File (jqresume.txt)</p><pre class="oac_no_warn" dir="ltr">             Johny Quest
         500 Oracle Parkway
            ... &lt;endlob&gt;
             Speed Racer
         400 Oracle Parkway
            ... &lt;endlob&gt;</pre><div class="infoboxnote" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__GUID-3471D8D4-23D6-4652-BCDA-08B9235DD881">
                                 <p class="notep1">Note:</p>
                                 <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                                 <ol>
                                    <li>
                                       <p>Because a maximum length of 2000 is specified for <code class="codeph">CHAR</code>, SQL*Loader knows what to expect as the maximum length of the field, which can result in memory usage optimization. <span class="italic">If you choose to specify a maximum length, then you should be sure not to underestimate its value.</span> The <code class="codeph">TERMINATED</code> <code class="codeph">BY</code> clause specifies the string that terminates the LOBs. Alternatively, you could use the <code class="codeph">ENCLOSED</code> <code class="codeph">BY</code> clause. The <code class="codeph">ENCLOSED</code> <code class="codeph">BY</code> clause allows a bit more flexibility as to the relative positioning of the LOBs in the LOBFILE (the LOBs in the LOBFILE need not be sequential).
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="This section contains examples of loading data from different types of fields in LOBFILEs.">Examples of Loading LOB Data from LOBFILEs</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3393"></a><a id="SUTIL3392"></a><a id="SUTIL1274"></a><div class="props_rev_3"><a id="GUID-C04366D7-247F-421E-BBFC-446A61C15258" name="GUID-C04366D7-247F-421E-BBFC-446A61C15258"></a><h6 id="SUTIL-GUID-C04366D7-247F-421E-BBFC-446A61C15258" class="sect6"><span class="enumeration_section">11.4.2.2.4 </span>Length-Value Pair Specified LOBs
                        </h6>
                        <div>
                           <p>You can load LOB data using length-value pair specified LOBs.</p>
                           <div class="section">
                              <p>In <a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">Example 11-21</a>each LOB in the LOBFILE is preceded by its length. You could use <code class="codeph">VARCHAR</code>, <code class="codeph">VARCHARC</code>, or <code class="codeph">VARRAW</code> data types to load LOB data organized in this way. 
                              </p>
                              <p>This method of loading can provide better performance over delimited LOBs, but at the expense of some flexibility (for example, you must know the LOB length for each LOB before loading).</p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">
                              <p class="titleinexample">Example 11-21 Loading LOB Data Using Length-Value Pair Specified LOBs</p>
                              <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name          CHAR(20),
<span class="bold">1</span>  "RESUME"       LOBFILE(CONSTANT 'jqresume') VARCHARC(4,2000))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">Johny Quest,
Speed Racer,
</pre><p>Secondary Data File (jqresume.txt)</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span>      0501Johny Quest
       500 Oracle Parkway
          ... 
<span class="bold">3</span>      0000	</pre><div class="infoboxnote" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__GUID-91E8ACBD-800D-42C4-AF59-26ACA2BB691C">
                                 <p class="notep1">Note:</p>
                                 <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                                 <ol>
                                    <li>
                                       <p>The entry <code class="codeph">VARCHARC(4,2000)</code> tells SQL*Loader that the LOBs in the LOBFILE are in length-value pair format and that the first 4 bytes should be interpreted as the length. The value of <code class="codeph">2000</code> tells SQL*Loader that the maximum size of the field is 2000 bytes. This assumes the use of the default byte-length semantics. If character-length semantics were used, then the first 4 characters would be interpreted as the length in characters. The maximum size of the field would be 2000 characters. See <a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="Byte-length semantics are the default for all data files except those that use the UTF16 character set (which uses character-length semantics by default).">Character-Length Semantics</a>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>The entry <code class="codeph">0501</code> preceding <code class="codeph">Johny</code> <code class="codeph">Quest</code> tells SQL*Loader that the LOB consists of the next 501 characters.
                                       </p>
                                    </li>
                                    <li>
                                       <p>This entry specifies an empty (not null) LOB.</p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="This section contains examples of loading data from different types of fields in LOBFILEs.">Examples of Loading LOB Data from LOBFILEs</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="SUTIL1275"></a><div class="props_rev_3"><a id="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" name="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60"></a><h5 id="SUTIL-GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" class="sect5"><span class="enumeration_section">11.4.2.3 </span>Considerations When Loading LOBs from LOBFILEs
                     </h5>
                     <div>
                        <p>There are considerations to take into account when loading LOBs from LOBFILEs.</p>
                        <p>Keep in mind the following when you load data using LOBFILEs:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Only LOBs and <code class="codeph">XML</code> columns can be loaded from LOBFILEs.
                              </p>
                           </li>
                           <li>
                              <p>The failure to load a particular LOB does not result in the rejection of the record containing that LOB. Instead, you will have a record that contains an empty LOB. In the case of an <code class="codeph">XML</code> column, a null value will be inserted if there is a failure loading the LOB.
                              </p>
                           </li>
                           <li>
                              <p>It is not necessary to specify the maximum length of a field corresponding to a LOB column. If a maximum length <span class="italic">is</span> specified, then SQL*Loader uses it as a hint to optimize memory usage. Therefore, it is important that the maximum length specification does not understate the true maximum length.
                              </p>
                           </li>
                           <li>
                              <p>You cannot supply a position specification (<code class="codeph">pos_spec</code>) when loading data from a LOBFILE.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">NULLIF</code> or <code class="codeph">DEFAULTIF</code> field conditions cannot be based on fields read from LOBFILEs.
                              </p>
                           </li>
                           <li>
                              <p>If a nonexistent LOBFILE is specified as a data source for a particular field, then that field is initialized to empty. If the concept of empty does not apply to the particular field type, then the field is initialized to null.</p>
                           </li>
                           <li>
                              <p>Table-level delimiters are not inherited by fields that are read from a LOBFILE.</p>
                           </li>
                           <li>
                              <p>When loading an <code class="codeph">XML</code> column or referencing a LOB column in a SQL expression in conventional path mode, SQL*Loader must process the LOB data as a temporary LOB. To ensure the best load performance possible in these cases, refer to the guidelines concerning temporary LOB performance in<a href="../adlob/performance-guidelines.html#ADLOB105" target="_blank"><span class="italic"> Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file.">Loading LOB Data from LOBFILEs</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" name="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB"></a><h4 id="SUTIL-GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" class="sect4"><span class="enumeration_section">11.4.3 </span>Loading Data Files that Contain LLS Fields
                  </h4>
                  <div>
                     <p>If a field in a data file is a LOB location Specifier (LLS) field, then you can indicate this by using the <code class="codeph">LLS</code> clause.
                     </p>
                     <p>An LLS field contains the file name, offset, and length of the LOB data in the data file. SQL*Loader uses this information to read data for the LOB column. </p>
                     <p>The syntax for the <code class="codeph">LLS</code> clause is as follows:
                     </p>
                     <div class="figure" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-709D99CC-FAD6-40E0-B11A-2639252306AC"><img src="img/lls_field_spec.gif" alt="Description of lls_field_spec.eps follows" title="Description of lls_field_spec.eps follows" longdesc="img_text/lls_field_spec.html"><br><a href="img_text/lls_field_spec.html">Description of the illustration lls_field_spec.eps</a></div>
                     <!-- class="figure" -->
                     <p>The LOB can be loaded in part or in whole and it can start from an arbitrary position and for an arbitrary length. SQL Loader expects the expects the contents of the LLS field to be  <code class="codeph"><span class="variable" translate="no">filename.ext.nnn.mmm</span>/</code> where each element is defined as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">filename.ext</span></code> is the name of the file that contains the LOB.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">nnn</span></code> is the offset in bytes of the LOB within the file.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">mmm</span></code> is the length of the LOB in bytes.  A value of -1 means the LOB is NULL.  A value of 0 means the LOB exists, but is empty.
                           </p>
                        </li>
                        <li>
                           <p>The forward slash (<code class="codeph">/</code>) terminates the field
                           </p>
                        </li>
                     </ul>
                     <p>If the SQL*Loader parameter, <code class="codeph">SDF_PREFIX</code>, is specified, then SQL*Loader looks for the files in the directory specified by <code class="codeph">SDF_PREFIX</code>.  Otherwise, SQL*Loader looks in the same directory as the data file.
                     </p>
                     <p>An error is reported and the row is rejected if any of the following are true:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The file name contains a relative or absolute path specification.</p>
                        </li>
                        <li>
                           <p>The file is not found, the offset is invalid, or the length extends beyond the end of the file.</p>
                        </li>
                        <li>
                           <p>The contents of the field do not match the expected format.</p>
                        </li>
                        <li>
                           <p>The data type for the column associated with an LLS field is not a <code class="codeph">CLOB</code>, <code class="codeph">BLOB</code>, or <code class="codeph">NCLOB</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-A951F0F5-6447-4ED5-B219-9B2C0F5FE111">Usage Notes</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If an LLS field is referenced by a clause for any other field (for example a <code class="codeph">NULLIF</code> clause) in the control file, then the value used for evaluating the clause is the string in the data file, not the data in the file pointed to by that string.
                              </p>
                           </li>
                           <li>
                              <p> The character set for the data in the file pointed to by the <code class="codeph">LLS</code> clause is assumed to be the same character set as the data file.
                              </p>
                           </li>
                           <li>
                              <p>The user running SQL*Loader must have read access to the data files.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-000E3A66-BA5E-4ED5-B102-8F2B1860AC1C">
                        <p class="titleinexample">Example 11-22 Example Specification of an LLS Clause</p>
                        <p>The following is an example of a SQL*Loader control file that contains an <code class="codeph">LLS</code> clause. Note that a data type is not needed on the column specification because the column must be of type <code class="codeph">LOB</code>.
                        </p><pre class="pre codeblock"><code>LOAD DATA
INFILE *
TRUNCATE
INTO TABLE tklglls
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' TRAILING NULLCOLS
(col1 , col2 NULLIF col1 = '1' LLS)
BEGINDATA
1,"tklglls1.dat.1.11/"</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="The section describes loading LOBs.">Loading LOBs</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3395"></a><a id="SUTIL3397"></a><a id="SUTIL3394"></a><a id="SUTIL3396"></a><a id="SUTIL1276"></a><div class="props_rev_3"><a id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" name="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40"></a><h3 id="SUTIL-GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" class="sect3"><span class="enumeration_section">11.5 </span>Loading BFILE Columns
               </h3>
               <div>
                  <p>The <code class="codeph">BFILE</code> data type stores unstructured binary data in operating system files outside the database. 
                  </p>
                  <p>A <code class="codeph">BFILE</code> column or attribute stores a file locator that points to the external file containing the data. The file to be loaded as a <code class="codeph">BFILE</code> does not have to exist at the time of loading; it can be created later. SQL*Loader assumes that the necessary directory objects have already been created (a logical alias name for a physical directory on the server's file system). For more information, see the <a href="../adlob/managing-LOBs.html#ADLOB45157" target="_blank"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>. 
                  </p>
                  <p>A control file field corresponding to a <code class="codeph">BFILE</code> column consists of a column name followed by the <code class="codeph">BFILE</code> clause. The <code class="codeph">BFILE</code> clause takes as arguments a directory object (the server_directory alias) name followed by a <code class="codeph">BFILE</code> name. Both arguments can be provided as string constants, or they can be dynamically loaded through some other field. See the<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50996" target="_blank"><span class="italic"> Oracle Database SQL Language Reference</span></a> for more information.
                  </p>
                  <p>In the next two examples of loading <code class="codeph">BFILE</code>s, <a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">Example 11-23</a> has only the file name specified dynamically, while <a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">Example 11-24</a> demonstrates specifying both the <code class="codeph">BFILE</code> and the directory object dynamically.
                  </p>
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">
                     <p class="titleinexample">Example 11-23 Loading Data Using BFILEs: Only File Name Specified Dynamically</p>
                     <p>The following are the control file contents. The directory name, <code class="codeph">scott_dir1</code>, is in quotation marks; therefore, the string is used as is and is not capitalized.
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE sample.dat
INTO TABLE planets
FIELDS TERMINATED BY ','
   (pl_id    CHAR(3), 
   pl_name   CHAR(20),
   fname     FILLER CHAR(30),
   pl_pict   BFILE(CONSTANT "scott_dir1", fname))
</pre><p>The following are the contents of the data file, <code class="codeph">sample.dat</code>.
                     </p><pre class="oac_no_warn" dir="ltr">1,Mercury,mercury.jpeg,
2,Venus,venus.jpeg,
3,Earth,earth.jpeg,</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">
                     <p class="titleinexample">Example 11-24 Loading Data Using BFILEs: File Name and Directory Specified Dynamically</p>
                     <p>The following are the control file contents. Note that <code class="codeph">dname</code> is mapped to the data file field containing the directory name that corresponds to the file being loaded.
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE sample.dat
INTO TABLE planets
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (pl_id    NUMBER(4), 
   pl_name   CHAR(20), 
   fname     FILLER CHAR(30),
   dname     FILLER CHAR(20),
   pl_pict   BFILE(dname, fname) )
</pre><p>The following are the contents of the data file, <code class="codeph">sample.dat</code>.
                     </p><pre class="oac_no_warn" dir="ltr">1, Mercury, mercury.jpeg, scott_dir1,
2, Venus, venus.jpeg, scott_dir1,
3, Earth, earth.jpeg, scott_dir2,</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1277"></a><div class="props_rev_3"><a id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" name="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C"></a><h3 id="SUTIL-GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" class="sect3"><span class="enumeration_section">11.6 </span>Loading Collections (Nested Tables and VARRAYs)
               </h3>
               <div>
                  <p>Like LOBs, collections can be loaded either from a primary data file (data inline) or from secondary data files (data out of line).</p>
                  <p>When you load collection data, a mechanism must exist by which SQL*Loader can tell when the data belonging to a particular collection instance has ended. You can achieve this in two ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>To specify the number of rows or elements that are to be loaded into each nested table or <code class="codeph">VARRAY</code> instance, use the DDL <code class="codeph">COUNT</code> function. The value specified for <code class="codeph">COUNT</code> must either be a number or a character string containing a number, and it must be previously described in the control file before the <code class="codeph">COUNT</code> clause itself. This positional dependency is specific to the <code class="codeph">COUNT</code> clause. <code class="codeph">COUNT(0)</code> or <code class="codeph">COUNT(cnt_field)</code>, where <code class="codeph">cnt_field</code> is 0 for the current row, results in a empty collection (not null), unless overridden by a <code class="codeph">NULLIF</code> clause. See <a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABIHJAH">count_spec</a>. 
                        </p>
                        <p>If the <code class="codeph">COUNT</code> clause specifies a field in a control file and if that field is set to null for the current row, then the collection that uses that count will be set to empty for the current row as well.
                        </p>
                     </li>
                     <li>
                        <p>Use the <code class="codeph">TERMINATED</code> <code class="codeph">BY</code> and <code class="codeph">ENCLOSED</code> <code class="codeph">BY</code> clauses to specify a unique collection delimiter. This method cannot be used if an <code class="codeph">SDF</code> clause is used.
                        </p>
                     </li>
                  </ul>
                  <p>In the control file, collections are described similarly to column objects. There are some differences:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Collection descriptions employ the two mechanisms discussed in the preceding list.</p>
                     </li>
                     <li>
                        <p>Collection descriptions can include a secondary data file (SDF) specification. </p>
                     </li>
                     <li>
                        <p>A <code class="codeph">NULLIF</code> or <code class="codeph">DEFAULTIF</code> clause cannot refer to a field in an SDF unless the clause is on a field in the same SDF.
                        </p>
                     </li>
                     <li>
                        <p>Clauses that take field names as arguments cannot use a field name that is in a collection unless the DDL specification is for a field in the same collection. </p>
                     </li>
                     <li>
                        <p>The field list must contain only one nonfiller field and any number of filler fields. If the <code class="codeph">VARRAY</code> is a <code class="codeph">VARRAY</code> of column objects, then the attributes of each column object will be in a nested field list.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553">Restrictions in Nested Tables and VARRAYs</a><br> There are restrictions for nested tables and <code class="codeph">VARRAY</code>s.
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC">Secondary Data Files (SDFs)</a><br>Secondary data files (SDFs) are similar in concept to primary data files.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C__GUID-7F1193EF-765D-458B-8AC1-910D286B5985">
                     <p class="notep1">See Also:</p>
                     <p>For details about SDFs, see <a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" title="Secondary data files (SDFs) are similar in concept to primary data files.">Secondary Data Files (SDFs)</a>.
                     </p>
                     <p> For details about loading column objects, see <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="Column objects in the control file are described in terms of their attributes.">Loading Column Objects</a>. 
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3398"></a><a id="SUTIL3399"></a><a id="SUTIL1278"></a><div class="props_rev_3"><a id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" name="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553"></a><h4 id="SUTIL-GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" class="sect4"><span class="enumeration_section">11.6.1 </span>Restrictions in Nested Tables and VARRAYs
                  </h4>
                  <div>
                     <p> There are restrictions for nested tables and <code class="codeph">VARRAY</code>s.
                     </p>
                     <div class="section">
                        <p>The following restrictions exist for nested tables and <code class="codeph">VARRAY</code>s:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A <code class="codeph">field_list</code> cannot contain a <code class="codeph">collection_fld_spec</code>.
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">col_obj_spec</code> nested within a <code class="codeph">VARRAY</code> cannot contain a <code class="codeph">collection_fld_spec</code>.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">column_name</code> specified as part of the <code class="codeph">field_list</code> must be the same as the <code class="codeph">column_name</code> preceding the <code class="codeph">VARRAY</code> parameter. 
                              </p>
                           </li>
                        </ul>
                        <p>Also, be aware that if you are loading into a table containing nested tables, then SQL*Loader will not automatically split the load into multiple loads and generate a set ID.</p>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">Example 11-25</a> demonstrates loading a <code class="codeph">VARRAY</code> and a nested table.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">
                        <p class="titleinexample">Example 11-25 Loading a VARRAY and a Nested Table</p>
                        <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">   LOAD DATA
   INFILE 'sample.dat' "str '\n' "
   INTO TABLE dept
   REPLACE
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (
     dept_no       CHAR(3),
     dname         CHAR(25) NULLIF dname=BLANKS,
<span class="bold">1</span>    emps          VARRAY TERMINATED BY ':'
     (
       emps        COLUMN OBJECT
       (
         name      CHAR(30),
         age       INTEGER EXTERNAL(3),
<span class="bold">2</span>        emp_id    CHAR(7) NULLIF emps.emps.emp_id=BLANKS
     )
   ),
<span class="bold">3</span>   proj_cnt      FILLER CHAR(3),
<span class="bold">4</span>   projects      NESTED TABLE SDF (CONSTANT "pr.txt" "fix 57") COUNT (proj_cnt)
  (
    projects    COLUMN OBJECT
    (
      project_id        POSITION (1:5) INTEGER EXTERNAL(5),
      project_name      POSITION (7:30) CHAR 
                        NULLIF projects.projects.project_name = BLANKS
    )
  )
)
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr"> 101,MATH,"Napier",28,2828,"Euclid", 123,9999:0
 210,"Topological Transforms",:2
</pre><p>Secondary Data File (SDF) (pr.txt)</p><pre class="oac_no_warn" dir="ltr">21034 Topological Transforms
77777 Impossible Proof</pre><div class="infoboxnote" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__GUID-5C1AA2C6-2295-42AE-A072-6B83086C2A14">
                           <p class="notep1">Note:</p>
                           <p>The callouts, in bold, to the left of the example correspond to the following notes:</p>
                           <ol>
                              <li>
                                 <p>The <code class="codeph">TERMINATED</code> <code class="codeph">BY</code> clause specifies the <code class="codeph">VARRAY</code> instance terminator (note that no <code class="codeph">COUNT</code> clause is used).
                                 </p>
                              </li>
                              <li>
                                 <p>Full name field references (using dot notation) resolve the field name conflict created by the presence of this filler field.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">proj_cnt</code> is a filler field used as an argument to the <code class="codeph">COUNT</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <div class="p">This entry specifies the following:
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>An SDF called <code class="codeph">pr</code>.<code class="codeph">txt</code> as the source of data. It also specifies a fixed-record format within the SDF.
                                          </p>
                                       </li>
                                       <li>
                                          <p>If <code class="codeph">COUNT</code> is 0, then the collection is initialized to empty. Another way to initialize a collection to empty is to use a <code class="codeph">DEFAULTIF</code> clause. The main field name corresponding to the nested table field description is the same as the field name of its nested nonfiller-field, specifically, the name of the column object field description.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="Like LOBs, collections can be loaded either from a primary data file (data inline) or from secondary data files (data out of line).">Loading Collections (Nested Tables and VARRAYs)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1279"></a><div class="props_rev_3"><a id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" name="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC"></a><h4 id="SUTIL-GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" class="sect4"><span class="enumeration_section">11.6.2 </span>Secondary Data Files (SDFs)
                  </h4>
                  <div>
                     <p>Secondary data files (SDFs) are similar in concept to primary data files.</p>
                     <p>Like primary data files, SDFs are a collection of records, and each record is made up of fields. The SDFs are specified on a per control-file-field basis. They are useful when you load large nested tables and <code class="codeph">VARRAY</code>s.
                     </p>
                     <div class="infoboxnote" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-7ECDA72B-2C94-4B04-9968-C5AE90296508">
                        <p class="notep1">Note:</p>
                        <p>Only a <code class="codeph">collection_fld_spec</code> can name an SDF as its data source.
                        </p>
                     </div>
                     <p>SDFs are specified using the <code class="codeph">SDF</code> parameter. The <code class="codeph">SDF</code> parameter can be followed by either the file specification string, or a <code class="codeph">FILLER</code> field that is mapped to a data field containing one or more file specification strings.
                     </p>
                     <p>As for a primary data file, the following can be specified for each SDF:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The record format (fixed, stream, or variable). Also, if stream record format is used, then you can specify the record separator.</p>
                        </li>
                        <li>
                           <p>The record size.</p>
                        </li>
                        <li>
                           <p>The character set for an SDF can be specified using the <code class="codeph">CHARACTERSET</code> clause (see <a href="oracle-sql-loader-control-file-contents.html#GUID-E0D390F1-1078-4955-9B55-B19C971D616D" title="SQL*Loader supports different character encoding schemes (called character sets, or code pages).">Handling Different Character Encoding Schemes</a>).
                           </p>
                        </li>
                        <li>
                           <p>A default delimiter (using the delimiter specification) for the fields that inherit a particular SDF specification (all member fields or attributes of the collection that contain the SDF specification, with exception of the fields containing their own LOBFILE specification).</p>
                        </li>
                     </ul>
                     <p>Also note the following regarding SDFs:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If a nonexistent SDF is specified as a data source for a particular field, then that field is initialized to empty. If the concept of empty does not apply to the particular field type, then the field is initialized to null.</p>
                        </li>
                        <li>
                           <p>Table-level delimiters are not inherited by fields that are read from an SDF. </p>
                        </li>
                        <li>
                           <p>To load SDFs larger than 64 KB, you must use the <code class="codeph">READSIZE</code> parameter to specify a larger physical record size. You can specify the <code class="codeph">READSIZE</code> parameter either from the command line or as part of an <code class="codeph">OPTIONS</code> clause.
                           </p>
                           <div class="infoboxnotealso" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-FA6BCAFD-3B2E-4DDC-86EF-D0CF9ECE84CA">
                              <p class="notep1">See Also:</p>
                              <p></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="oracle-sql-loader-commands.html#GUID-846265A6-3B66-45FD-99AE-009EC9380490" title="The READSIZE SQL*Loader command-line parameter specifies (in bytes) the size of the read buffer, if you choose not to use the default.">READSIZE</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-control-file-contents.html#GUID-2BB41EA6-C94D-41C1-94DE-966B291943E6" title="The following command-line parameters can be specified using the OPTIONS clause.">OPTIONS Clause</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABHGFGG">sdf_spec</a></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="Like LOBs, collections can be loaded either from a primary data file (data inline) or from secondary data files (data out of line).">Loading Collections (Nested Tables and VARRAYs)</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1280"></a><div class="props_rev_3"><a id="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" name="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737"></a><h3 id="SUTIL-GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" class="sect3"><span class="enumeration_section">11.7 </span>Dynamic Versus Static SDF Specifications
               </h3>
               <div>
                  <p>You can specify SDFs either statically (specifing the actual name of the file) or dynamically (using a <code class="codeph">FILLER</code> field as the source of the file name). 
                  </p>
                  <p>In either case, when the EOF of an SDF is reached, the file is closed and further attempts at reading data from that particular file produce results equivalent to reading data from an empty field. </p>
                  <p>In a dynamic secondary file specification, this behavior is slightly different. Whenever the specification changes to reference a new file, the old file is closed, and the data is read from the beginning of the newly referenced file. </p>
                  <p>The dynamic switching of the data source files has a resetting effect. For example, when SQL*Loader switches from the current file to a previously opened file, the previously opened file is reopened, and the data is read from the beginning of the file.</p>
                  <p>You should not specify the same SDF as the source of two different fields. If you do, then the two fields will typically read the data independently. </p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL3401"></a><a id="SUTIL3403"></a><a id="SUTIL3400"></a><a id="SUTIL3402"></a><a id="SUTIL1281"></a><div class="props_rev_3"><a id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34" name="GUID-2D079012-0733-4172-AD8B-E97690CDFA34"></a><h3 id="SUTIL-GUID-2D079012-0733-4172-AD8B-E97690CDFA34" class="sect3"><span class="enumeration_section">11.8 </span>Loading a Parent Table Separately from Its Child Table
               </h3>
               <div>
                  <p>When you load a table that contains a nested table column, it may be possible to load the parent table separately from the child table. </p>
                  <div class="section">
                     <p>You can load the parent and child tables independently if the SIDs (system-generated or user-defined) are already known at the time of the load (that is, the SIDs are in the data file with the data). </p>
                     <p>The following examples illustrate how to load parent and child tables with user-provided SIDs.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008679">
                     <p class="titleinexample">Example 11-26 Loading a Parent Table with User-Provided SIDs</p>
                     <p>Control File Contents</p><pre class="oac_no_warn" dir="ltr">   LOAD DATA
   INFILE 'sample.dat' "str '|\n' "
   INTO TABLE dept
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   TRAILING NULLCOLS
   ( dept_no   CHAR(3),
   dname       CHAR(20) NULLIF dname=BLANKS ,
   mysid       FILLER CHAR(32),
<span class="bold">1</span>  projects    SID(mysid))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">101,Math,21E978407D4441FCE03400400B403BC3,|
210,"Topology",21E978408D4441FCE03400400B403BC3,|</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-E37DB40E-33DA-47D0-9FB9-E7B10BE54352">
                        <p class="notep1">Note:</p>
                        <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                        <ol>
                           <li>
                              <p><code class="codeph">mysid</code> is a filler field that is mapped to a data file field containing the actual set IDs and is supplied as an argument to the <code class="codeph">SID</code> clause.
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008683">
                     <p class="titleinexample">Example 11-27 Loading a Child Table with User-Provided SIDs</p>
                     <p>Control File Contents&nbsp;&nbsp;&nbsp;&nbsp;</p><pre class="oac_no_warn" dir="ltr">   LOAD DATA
   INFILE 'sample.dat'
   INTO TABLE dept
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   TRAILING NULLCOLS
<span class="bold">1</span>  SID(sidsrc)
   (project_id     INTEGER EXTERNAL(5),
   project_name   CHAR(20) NULLIF project_name=BLANKS,
   sidsrc FILLER  CHAR(32))
</pre><p>Data File (sample.dat)</p><pre class="oac_no_warn" dir="ltr">21034, "Topological Transforms", 21E978407D4441FCE03400400B403BC3,
77777, "Impossible Proof", 21E978408D4441FCE03400400B403BC3,</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-76CE1F3E-1E6A-44B8-A2D8-69863679F18D">
                        <p class="notep1">Note:</p>
                        <p>The callout, in bold, to the left of the example corresponds to the following note:</p>
                        <ol>
                           <li>
                              <p>The table-level <code class="codeph">SID</code> clause tells SQL*Loader that it is loading the storage table for nested tables. <code class="codeph">sidsrc</code> is the filler field name that is the source of the real set IDs.
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA">Memory Issues When Loading VARRAY Columns</a><br>There are some memory issues when you load <code class="codeph">VARRAY</code> columns.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections.">Loading Objects, LOBs, and Collections</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1282"></a><div class="props_rev_3"><a id="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" name="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA"></a><h4 id="SUTIL-GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" class="sect4"><span class="enumeration_section">11.8.1 </span>Memory Issues When Loading VARRAY Columns
                  </h4>
                  <div>
                     <p>There are some memory issues when you load <code class="codeph">VARRAY</code> columns.
                     </p>
                     <p>The following list describes some issues to keep in mind when you load <code class="codeph">VARRAY</code> columns:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">VARRAY</code>s are created in the client's memory before they are loaded into the database. Each element of a <code class="codeph">VARRAY</code> requires 4 bytes of client memory before it can be loaded into the database. Therefore, when you load a <code class="codeph">VARRAY</code> with a thousand elements, you will require at least 4000 bytes of client memory for each <code class="codeph">VARRAY</code> instance before you can load the <code class="codeph">VARRAY</code>s into the database. In many cases, SQL*Loader requires two to three times that amount of memory to successfully construct and load a <code class="codeph">VARRAY</code>.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">BINDSIZE</code> parameter specifies the amount of memory allocated by SQL*Loader for loading records. Given the value specified for <code class="codeph">BINDSIZE</code>, SQL*Loader takes into consideration the size of each field being loaded, and determines the number of rows it can load in one transaction. The larger the number of rows, the fewer transactions, resulting in better performance. But if the amount of memory on your system is limited, then at the expense of performance, you can specify a lower value for <code class="codeph">ROWS</code> than SQL*Loader calculated. 
                           </p>
                        </li>
                        <li>
                           <p>Loading very large <code class="codeph">VARRAY</code>s or a large number of smaller <code class="codeph">VARRAY</code>s could cause you to run out of memory during the load. If this happens, then specify a smaller value for <code class="codeph">BINDSIZE</code> or <code class="codeph">ROWS</code> and retry the load.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34" title="When you load a table that contains a nested table column, it may be possible to load the parent table separately from the child table.">Loading a Parent Table Separately from Its Child Table</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>