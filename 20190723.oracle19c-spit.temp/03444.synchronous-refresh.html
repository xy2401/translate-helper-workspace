<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Synchronous Refresh</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="refreshing-materialized-views.html" title="Previous" type="text/html">
      <link rel="next" href="monitoring-materialized-view-refresh.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="refreshing-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="monitoring-materialized-view-refresh.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">Optimizing Data Warehouses</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Synchronous Refresh</li>
            </ol>
            <a id="GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889" name="GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889"></a>
            
            <h2 id="DWHSG-GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889" class="sect2"><span class="enumeration_chapter">8 </span>Synchronous Refresh
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This cha<a id="d34570e19" class="indexterm-anchor"></a><a id="d34570e23" class="indexterm-anchor"></a><a id="d34570e27" class="indexterm-anchor"></a><a id="d34570e29" class="indexterm-anchor"></a><a id="d34570e31" class="indexterm-anchor"></a>pter describes a method to synchronize changes to the tables and materialized views in a data warehouse. This method is based on synchronizing updates to tables and materialized views, and is called synchronous refresh.
               </p>
               <p>This chapter includes the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113">About Synchronous Refresh for Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-8C78842C-8A78-4206-A303-7B74B8803A1C">Using Synchronous Refresh for Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0">Using Synchronous Refresh Groups</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65">Specifying and Preparing Change Data for Synchronous Refresh</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6">Troubleshooting Synchronous Refresh Operations</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3">Performing Synchronous Refresh Eligibility Analysis</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB">Overview of Synchronous Refresh Security Considerations</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG9083"></a><div class="props_rev_3"><a id="GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113" name="GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113"></a><h3 id="DWHSG-GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113" class="sect3"><span class="enumeration_section">8.1 </span>About Synchronous Refresh for Materialized Views
               </h3>
               <div>
                  <p>Synchronous refresh is a refresh method introduced in Oracle Database 12<span class="italic">c</span> Release 1 that enables you to keep a set of tables and the materialized views defined on them to be always in sync. It is well-suited for data warehouses, where the loading of incremental data is tightly controlled and occurs at periodic intervals.
                  </p>
                  <p>In most data warehouses, the fact tables are partitioned along the time dimension and, very often, the incremental data load consists mainly of changes to recent time periods. Synchronous refresh exploits these characteristics to greatly improve refresh performance and throughput. This results in fast query performance for both planned and ad hoc queries, which is key to a successful data warehouse.</p>
                  <p>This section describes the main requirements and basic concepts of synchronous refresh, and includes the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D">What Is Synchronous Refresh?</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA">Why Use Synchronous Refresh?</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B">Registering Tables and Materialized Views for Synchronous Refresh</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF">Specifying Change Data for Refresh</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF">Synchronous Refresh Preparation and Execution</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F">Materialized View Eligibility Rules and Restrictions for Synchronous Refresh</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9283"></a><div class="props_rev_3"><a id="GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D" name="GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D"></a><h4 id="DWHSG-GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D" class="sect4"><span class="enumeration_section">8.1.1 </span>What Is Synchronous Refresh?
                  </h4>
                  <div>
                     <p>Synchronous refresh is a new approach for maintaining tables and materialized views in a data warehouse where tables and materialized views are refreshed at the same time. In traditional refresh methods, the changes are applied to the base tables and the materialized views are refreshed separately with one of the following refresh methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Log-based incremental (fast) refresh using materialized view logs if such logs are available</p>
                        </li>
                        <li>
                           <p>PCT refresh if it is applicable</p>
                        </li>
                        <li>
                           <p>Complete refresh</p>
                        </li>
                     </ul>
                     <p>Synchronous refresh combines some elements of log-based incremental (fast) refresh and PCT refresh methods, but it is applicable only to <code class="codeph">ON</code> <code class="codeph">DEMAND</code> materialized views, unlike the other two methods. There are three major differences between it and the other refresh methods:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Synchronous refresh requires you to register the tables and materialized views.</p>
                        </li>
                        <li>
                           <p>Synchronous refresh requires you to specify changes to the data according to some formally specified rules.</p>
                        </li>
                        <li>
                           <p>Synchronous refresh works by dividing the refresh operation into two steps: preparation and execution. This approach provides some important advantages over the other methods, such as better performance and more control.</p>
                        </li>
                     </ul>
                     <p>Synchronous refresh APIs are defined in a new package called <code class="codeph">DBMS_SYNC_REFRESH</code>. For more information about this package, see <a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a>.
                     </p>
                  </div>
               </div><a id="DWHSG9085"></a><div class="props_rev_3"><a id="GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA" name="GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA"></a><h4 id="DWHSG-GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA" class="sect4"><span class="enumeration_section">8.1.2 </span>Why Use Synchronous Refresh?
                  </h4>
                  <div>
                     <p>Synchronous refresh offers the following advantages over traditional types of methods used to refresh materialized views in a data warehouse:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It coordinates the loading of the changes into the base tables with the extremely efficient refresh of the dependent materialized views themselves.</p>
                        </li>
                        <li>
                           <p>It decreases the time materialized views are not available to be used by the Optimizer to rewrite queries.</p>
                        </li>
                        <li>
                           <p>It is well-suited for a wide class of materialized views (materialized aggregate views and materialized join views) commonly used in data warehouses. It does require the materialized views be partitioned as well as the fact tables, and if materialized views are not currently partitioned, they can be efficiently partitioned to take advantage of synchronous refresh.</p>
                        </li>
                        <li>
                           <p>It fully exploits partitioning and the nature of the data warehouse load cycle to guarantee synchronization between the materialized view and the base table throughout the refresh procedure.</p>
                        </li>
                        <li>
                           <p>In a typical data warehouse, data preparation consists of extracting the data from one or more sources, cleansing, and formatting it for consistency, and transforming into the data warehouse schema. The data preparation area is called the staging area and the base tables in a data warehouse are loaded from the tables in the staging area. The synchronous refresh method fits into this model because it allows you to load change data into the staging logs.</p>
                        </li>
                        <li>
                           <p>The staging logs play the same role as materialized view logs in the conventional fast refresh method. There is, however, an important difference. In the conventional fast refresh method, the base table is first updated and the changes are then applied from the materialized view log to the materialized views. But in the synchronous refresh method, the changes from the staging log are applied to refresh the materialized views while also being applied to the base tables.</p>
                        </li>
                        <li>
                           <p>Most materialized views in a data warehouse typically employ a star or snowflake schema with fact and dimension tables joined in a foreign key to primary key relationship. The synchronous refresh method can handle both schemas in all possible change data load scenarios, ranging from rows being added to only the fact table, to arbitrary changes to the fact and dimension tables.</p>
                        </li>
                        <li>
                           <p>Instead of providing the change load data in the staging logs, you have a choice of directly providing the change data in the form of outside tables containing the data to be exchanged with the affected partition in the base table. This capability is provided by the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure in the <code class="codeph">DBMS_SYNC_REFRESH</code> package.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9086"></a><div class="props_rev_3"><a id="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B" name="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B"></a><h4 id="DWHSG-GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B" class="sect4"><span class="enumeration_section">8.1.3 </span>Registering Tables and Materialized Views for Synchronous Refresh
                  </h4>
                  <div>
                     <div class="section">
                        <p>Before actually performing synchronous refresh, you must register the appropriate tables and materialized views. Synchronous refresh provides these methods to register tables and materialized views:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Tables are registered with synchronous refresh by creating a <span class="bold">staging</span> <span class="bold">log</span> on them. A staging log is created with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statement whose syntax has been extended in this release to create staging logs as well as the familiar materialized view logs used for the traditional incremental refresh. After you create a staging log on a table, it is deemed to be registered with synchronous refresh and can be modified only by using the synchronous refresh procedures. In other words, a table with a staging log defined on it is registered with synchronous refresh and cannot be modified directly by the user.
                              </p>
                           </li>
                           <li>
                              <p>Materialized views are registered with synchronous refresh using the <code class="codeph">REGISTER_MVIEWS</code> procedure in the <code class="codeph">DBMS_SYNC_REFRESH</code> package. The <code class="codeph">REGISTER_MVIEWS</code> procedure implicitly creates groups of related objects called sync refresh groups. A <span class="bold">sync</span> <span class="bold">refresh</span> <span class="bold">group</span> consists of all related materialized views and tables that must be refreshed together as a single entity because they are dependent on one another.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B__GUID-03226C2E-7F1E-403B-BA42-EC1328B1EB5C">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW-LOG.html#SQLRF01303" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information about the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statement
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_SYNC_REFRESH</code> package
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9087"></a><div class="props_rev_3"><a id="GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF" name="GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF"></a><h4 id="DWHSG-GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF" class="sect4"><span class="enumeration_section">8.1.4 </span>Specifying Change Data for Refresh
                  </h4>
                  <div>
                     <div class="section">
                        <p>In the other refresh methods, you can directly modify the base tables of the materialized view, and the issue of specifying change data does not arise. But with synchronous refresh, you are required to specify and prepare the change data according to certain formally specified rules and using APIs provided by the <code class="codeph">DBMS_SYNC_REFRESH</code> package.
                        </p>
                        <p>There are two ways to specify the change data:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Provide the change data in an outside table and register it with the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure.
                              </p>
                              <p>See <span class="q">"<a href="synchronous-refresh.html#GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1">Working with Partition Operations While Capturing Change Data for Synchronous Refresh</a>"</span> for more details.
                              </p>
                           </li>
                           <li>
                              <p>Provide the change data by in staging logs and process them with the <code class="codeph">PREPARE_STAGING_LOG</code> procedure. The format of the staging logs and rules for populating are described in <span class="q">"<a href="synchronous-refresh.html#GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6">Working with Staging Logs While Capturing Change Data for Synchronous Refresh</a>"</span>. You are required to run the <code class="codeph">PREPARE_STAGING_LOG</code> procedure for every table before performing the refresh operation on that table.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9088"></a><div class="props_rev_3"><a id="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF" name="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF"></a><h4 id="DWHSG-GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF" class="sect4"><span class="enumeration_section">8.1.5 </span>Synchronous Refresh Preparation and Execution
                  </h4>
                  <div>
                     <div class="section">
                        <p>After preparing the change data, you can perform the actual refresh operation. Synchronous refresh takes a new approach to refresh execution. It works by dividing the refresh operation into two steps: preparation and execution. This is one of the main differences between it and the other refresh methods and provides some important benefits.</p>
                        <p>The preparation step determines the mapping between the fact table partitions and the materialized view partitions. This step computes the new tables corresponding only to the partitions of the fact table that have been changed by the incremental change data load. After these tables, called <span class="bold">outside</span> <span class="bold">tables</span>, have been computed, the actual execution of the refresh operation takes place in the execution step, which consists of just exchanging the outside tables with the corresponding partitions in the fact table or materialized view.
                        </p>
                        <p>By dividing the refresh execution step into two phases and providing separate procedures for them, synchronous refresh not only provides you control over the refresh execution process, but also improves overall system performance. It does this by minimizing the time the materialized views are not available for use by direct access or the Optimizer because they are modified by the refresh process. During the preparation phase, the materialized view and its tables are not modified because at this time all the refresh changes are recorded in the outside table. Consequently, the materialized view is available to any query that needs to read them. It is only during execution that the tables and materialized views are modified. Execution performance is mainly affected by the number of changes to the dimension tables; if this number is small, then the performance should be very good because the exchange partition operations are themselves very fast.</p>
                        <p>The <code class="codeph">DBMS_SYNC_REFRESH</code> package provides the <code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code> procedures to perform these two steps.
                        </p>
                        <div class="infoboxnotealso" id="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF__GUID-8DEC7708-4D30-43D2-B120-D4009470C9AE">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9090"></a><div class="props_rev_3"><a id="GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F" name="GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F"></a><h4 id="DWHSG-GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F" class="sect4"><span class="enumeration_section">8.1.6 </span>Materialized View Eligibility Rules and Restrictions for Synchronous Refresh
                  </h4>
                  <div>
                     <p>The primary requirement for a materialized view to be eligible for synchronous refresh is that the materialized view must be partitioned with a key that can be derived from the partition key of its fact table. The following sections describe the other requirements for eligibility for synchronous refresh.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-2A769373-2083-470A-A479-57A349731F74">Synchronous Refresh Restrictions: Partitioning</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6">Synchronous Refresh Restrictions: Refresh Options</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304">Synchronous Refresh Restrictions: Constraints</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566">Synchronous Refresh Restrictions: Tables</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2">Synchronous Refresh Restrictions: Materialized Views</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8">Synchronous Refresh Restrictions: Materialized Views with Aggregates</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9091"></a><div class="props_rev_3"><a id="GUID-2A769373-2083-470A-A479-57A349731F74" name="GUID-2A769373-2083-470A-A479-57A349731F74"></a><h5 id="DWHSG-GUID-2A769373-2083-470A-A479-57A349731F74" class="sect5"><span class="enumeration_section">8.1.6.1 </span>Synchronous Refresh Restrictions: Partitioning
                     </h5>
                     <div>
                        <div class="section">
                           <p>There are two key requirements to use synchronous refresh:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The materialized view must be partitioned along the same dimension as the fact table.</p>
                              </li>
                              <li>
                                 <p>The partition key of the fact table should functionally determine the partition key of the materialized view.</p>
                              </li>
                           </ul>
                           <p>The term <span class="italic">functionally</span> <span class="italic">determine</span> means the partition key of the materialized view can be derived from the partition key of the fact table based on a foreign key constraint relationship. This condition is satisfied if the partition key of the materialized view is the same as that for the fact table or related by joins from the fact table to the dimension table as in a star or snowflake schema. For example, if the fact table is partitioned by a date column, such as <code class="codeph">TIME_KEY</code>, the materialized view can be partitioned by <code class="codeph">TIME_KEY</code>, <code class="codeph">MONTH</code>, or <code class="codeph">YEAR</code>.
                           </p>
                           <p>Synchronous refresh supports two types of partitioning on fact tables and materialized views: range partitioning and composite partitioning, when the top-level partitioning type is range.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9092"></a><div class="props_rev_3"><a id="GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6" name="GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6"></a><h5 id="DWHSG-GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6" class="sect5"><span class="enumeration_section">8.1.6.2 </span>Synchronous Refresh Restrictions: Refresh Options
                     </h5>
                     <div>
                        <div class="section">
                           <p>When you define a materialized view, you can specify three refresh options: how to refresh; whether trusted constraints can be used; and what type of refresh is to be performed. If unspecified, the defaults are assumed to be <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, <code class="codeph">ENFORCED</code> constraints, and <code class="codeph">FORCE</code> respectively. Synchronous refresh requires that the first two of these options must have the values <code class="codeph">ON</code> <code class="codeph">DEMAND</code> and <code class="codeph">TRUSTED</code> constraints respectively. Synchronous refresh does not require the type of refresh to have any specific value, so it can be <code class="codeph">FAST</code>, <code class="codeph">FORCE</code>, or <code class="codeph">COMPLETE</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9093"></a><div class="props_rev_3"><a id="GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304" name="GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304"></a><h5 id="DWHSG-GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304" class="sect5"><span class="enumeration_section">8.1.6.3 </span>Synchronous Refresh Restrictions: Constraints
                     </h5>
                     <div>
                        <div class="section">
                           <p>The relationships between the fact and dimension tables are declared by foreign and primary key constraints on the tables. Synchronous refresh trusts these constraints to perform the refresh, and requires that <code class="codeph">USING</code> <code class="codeph">TRUSTED</code> <code class="codeph">CONSTRAINTS</code> must be specified in the materialized view definition. This allows using nonvalidated <code class="codeph">RELY</code> constraints and rewriting against materialized views in an <code class="codeph">UNKNOWN</code> or <code class="codeph">FRESH</code> state during refresh.
                           </p>
                           <p>When a table is registered for synchronous refresh, its constraints might be in a <code class="codeph">VALIDATE</code> or <code class="codeph">NOVALIDATE</code> state. If the table is a dimension table, synchronous refresh will retain this state during the refresh execution process.
                           </p>
                           <p>However, if the table is a fact table, synchronous refresh marks the constraints <code class="codeph">NOVALIDATE</code> state during refresh execution. This avoids the need for validating the constraint on existing data during a partition exchange that is the basis of the synchronous refresh method, and improves the performance of refresh execution.
                           </p>
                           <p>Because the constraints on the fact table are not enforced by synchronous refresh, it is you who must verify the integrity and consistently of the data provided.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9094"></a><div class="props_rev_3"><a id="GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566" name="GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566"></a><h5 id="DWHSG-GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566" class="sect5"><span class="enumeration_section">8.1.6.4 </span>Synchronous Refresh Restrictions: Tables
                     </h5>
                     <div>
                        <div class="section">
                           <p>To be eligible for synchronous refresh, a table must satisfy the following conditions:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The table cannot have VPD or triggers defined on it.</p>
                              </li>
                              <li>
                                 <p>The table cannot have any <code class="codeph">RAW</code> type.
                                 </p>
                              </li>
                              <li>
                                 <p>The table cannot be remote.</p>
                              </li>
                              <li>
                                 <p>The staging log key of each table registered for synchronous refresh should satisfy the requirements described in <span class="q">"<a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">About the Staging Log Key</a>"</span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9095"></a><div class="props_rev_2"><a id="GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2" name="GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2"></a><h5 id="DWHSG-GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2" class="sect5"><span class="enumeration_section">8.1.6.5 </span>Synchronous Refresh Restrictions: Materialized Views
                     </h5>
                     <div>
                        <div class="section">
                           <p>There are some other restrictions that are specific to materialized views registered for synchronous refresh:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">ROWID</code> column cannot be used to define the query. It is not relevant because it uses partition exchange, which replaces the original partition with the outside table. Hence, the defining query should not include any <code class="codeph">ROWID</code> columns.
                                 </p>
                              </li>
                              <li>
                                 <p>Synchronous refresh does not support nested materialized views, <code class="codeph">UNION</code> <code class="codeph">ALL</code> materialized views, subqueries, or complex queries in the materialized view definition. The defining query must conform to the star or snowflake schema.
                                 </p>
                              </li>
                              <li>
                                 <p>These SQL constructs are also not supported: analytic window functions (such as <code class="codeph">RANK</code>), the <code class="codeph">MODEL</code> clause, and the <code class="codeph">CONNECT</code> <code class="codeph">BY</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>Synchronous refresh is not supported for a materialized view that refers to views, remote tables, or outer joins.</p>
                              </li>
                              <li>
                                 <p>The materialized view must not contain references to nonrepeating expressions like <code class="codeph">SYSDATE</code> and <code class="codeph">ROWNUM</code>.
                                 </p>
                              </li>
                           </ul>
                           <p>In general, most restrictions that apply to PCT-refresh, fast refresh, and general query rewrite also apply to synchronous refresh. Those restrictions are available at:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="basic-materialized-views.html#GUID-6A80266B-444E-4BB6-8A48-911E4619338B">About Materialized View Restrictions for Query Rewrite</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="basic-materialized-views.html#GUID-A5409962-E85D-46DD-B34A-820074CA579C">General Query Rewrite Restrictions</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>"</span></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9096"></a><div class="props_rev_3"><a id="GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8" name="GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8"></a><h5 id="DWHSG-GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8" class="sect5"><span class="enumeration_section">8.1.6.6 </span>Synchronous Refresh Restrictions: Materialized Views with Aggregates
                     </h5>
                     <div>
                        <div class="section">
                           <p>For materialized views with aggregates, synchronous refresh shares these restrictions with fast refresh:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Only <code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">AVG</code>, <code class="codeph">STDDEV</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">MIN</code>, and <code class="codeph">MAX</code> are supported.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">COUNT(*)</code> must be specified.
                                 </p>
                              </li>
                              <li>
                                 <p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code class="codeph">AVG(AVG(x))</code> or <code class="codeph">AVG(x)+ AVG(x)</code> are not allowed.
                                 </p>
                              </li>
                              <li>
                                 <p>For each aggregate, such as <code class="codeph">AVG(expr)</code>, the corresponding <code class="codeph">COUNT(expr)</code> must be present. Oracle recommends that <code class="codeph">SUM(expr)</code> be specified.
                                 </p>
                              </li>
                              <li>
                                 <p>If <code class="codeph">VARIANCE(expr)</code> or <code class="codeph">STDDEV(expr)</code> is specified, <code class="codeph">COUNT(expr)</code> and <code class="codeph">SUM(expr)</code> must be specified. Oracle recommends that <code class="codeph">SUM(expr *expr)</code> be specified.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9097"></a><div class="props_rev_3"><a id="GUID-8C78842C-8A78-4206-A303-7B74B8803A1C" name="GUID-8C78842C-8A78-4206-A303-7B74B8803A1C"></a><h3 id="DWHSG-GUID-8C78842C-8A78-4206-A303-7B74B8803A1C" class="sect3"><span class="enumeration_section">8.2 </span>Using Synchronous Refresh for Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p>Synchronous refresh differs from the other refresh methods in a number of ways. One is that the API for synchronous refresh is contained in a new package called <code class="codeph">DBMS_SYNC_REFRESH</code>, whereas other refresh methods are declared in the <code class="codeph">DBMS_MVIEW</code> package. Another difference is that after objects are registered with synchronous refresh, and, once registered, the other refresh methods cannot be used with them.
                     </p>
                     <p>The operations associated with synchronous refresh can be divided into the following three broad phases:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445">Synchronous Refresh Step 1: Registration Phase</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988">Synchronous Refresh Step 2: Synchronous Refresh Phase</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162">Synchronous Refresh Step 3: The Unregistration Phase</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9099"></a><a id="DWHSG9100"></a><a id="DWHSG9101"></a><a id="DWHSG9098"></a><div class="props_rev_3"><a id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445" name="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445"></a><h4 id="DWHSG-GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445" class="sect4"><span class="enumeration_section">8.2.1 </span>Synchronous Refresh Step 1: Registration Phase
                  </h4>
                  <div>
                     <div class="section">
                        <p>In this phase (<a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGGGBID">Figure 8-1</a>), you register the objects for use with synchronous refresh. The two steps in this phase are registration of tables first and then materialized views. You register the tables (by creating staging logs) and materialized views (with the <code class="codeph">REGISTER_MVIEWS</code> procedure). The staging logs are created with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">SYNCHRONOUS</code> <code class="codeph">REFRESH</code> statement. If a table already has a regular materialized view log, the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">SYNCHRONOUS</code> <code class="codeph">REFRESH</code> statement can be used to convert it to a staging log.
                        </p>
                        <div class="figure" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGGGBID">
                           <p class="titleinfigure">Figure 8-1 Registration Phase</p><img src="img/dwhsg_vm_157.png" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/dwhsg_vm_157.html"><br><a href="img_text/dwhsg_vm_157.html">Description of "Figure 8-1 Registration Phase"</a></div>
                        <!-- class="figure" -->
                        <p>You can create a staging log with a statement, as show in <a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGJJBFD">Example 8-1</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGJJBFD">
                        <p class="titleinexample">Example 8-1 Registering Tables</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON fact
FOR SYNCHRONOUS REFRESH USING st_fact;
</pre><p>If a table has a materialized view log, you can alter it to a staging log with a statement, such as the following:</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW LOG ON fact
FOR SYNCHRONOUS REFRESH USING st_fact;
</pre><p>You can register a materialized view with a statement, as shown in <a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGCBBIE">Example 8-2</a>.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGCBBIE">
                        <p class="titleinexample">Example 8-2 Registering Materialized Views</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS('MV1');
</pre><p>You can register multiple materialized views at one time:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS('mv2, mv2_year, mv1_halfmonth');</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9103"></a><a id="DWHSG9102"></a><div class="props_rev_3"><a id="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988" name="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988"></a><h4 id="DWHSG-GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988" class="sect4"><span class="enumeration_section">8.2.2 </span>Synchronous Refresh Step 2: Synchronous Refresh Phase
                  </h4>
                  <div>
                     <div class="section">
                        <p><a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">Figure 8-2</a> shows the synchronous refresh phase. This phase can be used repeatedly to perform synchronous refresh. The three main steps in this phase are:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Prepare the change data for the refresh operation. You can provide the change data in a table and register it with the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure or provide the data by populating the staging logs. The staging logs must be processed with the <code class="codeph">PREPARE_STAGING_LOG</code> procedure before proceeding to the next step.</span><div>
                              <p>An example is <a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFBBHD">Example 8-12</a>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Perform the first step of the refresh operation (<code class="codeph">PREPARE_REFRESH</code>). This can potentially be a long-running operation because it prepares and loads the outside tables.</span><div>
                              <p>An example is <a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCCJFA">Example 8-16</a>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Perform the second and last step of the refresh operation (<code class="codeph">EXECUTE_REFRESH</code>). This usually runs very fast because it usually consists of a series of partition-exchange operations.</span><div>
                              <p>An example is <a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">Example 8-20</a>.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>In <a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">Figure 8-2</a>, solid arrows show the standard control flow and dashed arrows are used for error-handling cases. If either of the refresh operations (<code class="codeph">PREPARE_REFRESH</code> or <code class="codeph">EXECUTE_REFRESH</code>) raises user errors, you use an <code class="codeph">ABORT_REFRESH</code> procedure to restore tables and materialized views to the state that existed before the refresh operation, fix the problem, and retry the refresh operation starting from the beginning.
                        </p>
                        <div class="figure" id="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">
                           <p class="titleinfigure">Figure 8-2 Refresh Phase</p><img src="img/dwhsg_vm_156.png" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" longdesc="img_text/dwhsg_vm_156.html"><br><a href="img_text/dwhsg_vm_156.html">Description of "Figure 8-2 Refresh Phase"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9105"></a><a id="DWHSG9106"></a><a id="DWHSG9107"></a><a id="DWHSG9104"></a><div class="props_rev_3"><a id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162" name="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162"></a><h4 id="DWHSG-GUID-03C3D5B9-C16E-4989-BA2C-279D59183162" class="sect4"><span class="enumeration_section">8.2.3 </span>Synchronous Refresh Step 3: The Unregistration Phase
                  </h4>
                  <div>
                     <div class="section">
                        <p>If you choose to stop using synchronous refresh, then you must unregister the materialized views as shown in <a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGFDBDI">Figure 8-3</a>. The materialized views are first unregistered with the <code class="codeph">UNREGISTER_MVIEWS</code> procedure. The tables are then unregistered by either dropping their staging logs or altering the staging logs to ordinary logs. Note that if the staging logs are converted to be ordinary materialized view logs with an <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">FAST</code> <code class="codeph">REFRESH</code> statement, then the materialized views can be maintained with standard fast-refresh methods.
                        </p>
                        <div class="figure" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGFDBDI">
                           <p class="titleinfigure">Figure 8-3 Unregistration Phase</p><img src="img/dwhsg_vm_155.png" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" longdesc="img_text/dwhsg_vm_155.html"><br><a href="img_text/dwhsg_vm_155.html">Description of "Figure 8-3 Unregistration Phase"</a></div>
                        <!-- class="figure" -->
                        <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGBCCBC">Example 8-3</a> illustrates how to unregister the single materialized view <code class="codeph">MV1</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGBCCBC">
                        <p class="titleinexample">Example 8-3 Unregister Materialized Views</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.UNREGISTER_MVIEWS('MV1');
</pre><p>You can unregister multiple materialized views at one time:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.UNREGISTER_MVIEWS('mv2, mv2_year, mv1_halfmonth');
</pre><p>You can verify to see that a materialized view has been unregistered by querying the <code class="codeph">DBA_SR_OBJ_ALL</code> view.
                        </p>
                        <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGJCAHB">Example 8-4</a> illustrates how to drop the staging log.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGJCAHB">
                        <p class="titleinexample">Example 8-4 Unregister Tables</p><pre class="oac_no_warn" dir="ltr">DROP MATERIALIZED VIEW LOG ON fact;
</pre><p>Or you can alter the table to a materialized view log:</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW LOG ON fact
FOR FAST REFRESH;
</pre><p>You can verify to see that a table has been unregistered by querying the <code class="codeph">DBA_SR_OBJ_ALL</code> view.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9108"></a><div class="props_rev_3"><a id="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0" name="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0"></a><h3 id="DWHSG-GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0" class="sect3"><span class="enumeration_section">8.3 </span>Using Synchronous Refresh Groups
               </h3>
               <div>
                  <p>The distinguishing feature of synchronous refresh is that changes to a table and its materialized views are loaded and refreshed together, hence the name synchronous refresh. For tables and materialized views to be maintained by synchronous refresh, the objects must be registered. Tables are registered for synchronous refresh when staging logs are created on them, and materialized views are registered using the <code class="codeph">REGISTER_MVIEWS</code> procedure.
                  </p>
                  <p>Synchronous refresh supports the refresh of materialized views built on multiple tables, with changes in one or more of them. Tables that are related by constraints must all necessarily be refreshed together to ensure data integrity. Furthermore, it is possible that some of the tables registered for synchronous refresh have several materialized views built on top of them, in which case, all those materialized views must also be refreshed together.</p>
                  <p>Instead of having you keep track of these dependencies, and issue the refresh commands on the right set of tables, Oracle Database automatically generates the minimal sets of tables and materialized views that must necessarily be refreshed together. These sets are termed synchronous refresh groups or just sync refresh groups. Each sync refresh group is identified by a <code class="codeph">GROUP_ID</code>.value.
                  </p>
                  <p>The three procedures related to performing synchronous refresh (<code class="codeph">PREPARE_REFRESH</code>, <code class="codeph">EXECUTE_REFRESH</code> and <code class="codeph">ABORT_REFRESH</code>) take as input either a single group ID or a list of group IDs identifying the sync refresh groups.
                  </p>
                  <p>Each table or materialized view registered for synchronous refresh is assigned a <code class="codeph">GROUP_ID</code> value, which may change over time, if the dependencies among them change. This happens when you issue the <code class="codeph">REGISTER_MVIEWS</code> and <code class="codeph">UNREGISTER_MVIEWS</code> procedures. The examples that follow show the sync refresh groups in a number of scenarios.
                  </p>
                  <p>Because the <code class="codeph">GROUP_ID</code> value can change with time, Oracle recommends the actual <code class="codeph">GROUP_ID</code> value not be used when invoking the synchronous refresh procedures, but that the function <code class="codeph">DBMS_SYNC_REFRESH.GET_GROUP_ID</code> be used instead. This function takes a materialized view name as input and returns the materialized view's <code class="codeph">GROUP_ID</code> value.
                  </p>
                  <div class="infoboxnotealso" id="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0__GUID-348325CA-4877-45AB-9189-73DC1C7D09AA">
                     <p class="notep1">See Also:</p>
                     <p><a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information about how to use the <code class="codeph">DBMS_SYNC_REFRESH.REGISTER_MVIEWS</code> procedure
                     </p>
                  </div>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717">Examples of Common Actions with Synchronous Refresh Groups</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE">Examples of Working with Multiple Synchronous Refresh Groups</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9110"></a><a id="DWHSG9111"></a><a id="DWHSG9112"></a><a id="DWHSG9109"></a><div class="props_rev_3"><a id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717" name="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717"></a><h4 id="DWHSG-GUID-FAC6FB90-55F8-486D-B3C8-C19389199717" class="sect4"><span class="enumeration_section">8.3.1 </span>Examples of Common Actions with Synchronous Refresh Groups
                  </h4>
                  <div>
                     <div class="section">
                        <p>The synchronous refresh demo scripts in the <code class="codeph">rdbms/demo</code> directory enable you to view typical operations that you are likely to perform. The main script is <code class="codeph">syncref_run.sql</code>, and its log is <code class="codeph">syncref_run.log</code>. <a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGIJAJC">Example 8-5</a>, <a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGJCFAC">Example 8-6</a>, and <a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGFACBG">Example 8-7</a> below illustrate the different contexts in which the <code class="codeph">GET_GROUP_ID</code> function can be used.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGIJAJC">
                        <p class="titleinexample">Example 8-5 Display the Objects Registered in a Group</p>
                        <p>This example illustrates how to display the objects registered in a group after registering them.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS('MV1');
SELECT NAME, TYPE, STAGING_LOG_NAME FROM USER_SR_OBJ
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;

NAME       TYPE       STAGING_LOG_NAME
---------- ---------- ----------------
MV1        MVIEW
FACT       TABLE      ST_FACT
STORE      TABLE      ST_STORE
TIME       TABLE      ST_TIME
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGJCFAC">
                        <p class="titleinexample">Example 8-6 Invoke Refresh Operations</p>
                        <p>This example illustrates how to invoke refresh operations.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH( -
        DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH( -
        DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
SELECT NAME, TYPE, STATUS FROM USER_SR_OBJ_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGFACBG">
                        <p class="titleinexample">Example 8-7 Verify the Status of Objects Registered in a Group</p>
                        <p>This example illustrates how to verify the status of objects registered in a group after an <code class="codeph">EXECUTE_REFRESH</code> operation.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, TYPE, STATUS FROM USER_SR_OBJ_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;

NAME             TYPE       STATUS
---------------- ---------- ----------------
MV1              MVIEW      COMPLETE
FACT             TABLE      COMPLETE
STORE            TABLE      COMPLETE
TIME             TABLE      COMPLETE</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9114"></a><a id="DWHSG9115"></a><a id="DWHSG9113"></a><div class="props_rev_3"><a id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE" name="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE"></a><h4 id="DWHSG-GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE" class="sect4"><span class="enumeration_section">8.3.2 </span>Examples of Working with Multiple Synchronous Refresh Groups
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can work with multiple refresh groups at one time with the following APIs:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">GET_GROUP_ID_LIST</code> 
                              </p>
                              <p>Takes a list of materialized views as input and returns their group IDs in a list.</p>
                           </li>
                           <li>
                              <p><code class="codeph">GET_ALL_GROUP_IDS</code></p>
                              <p>Returns the group IDs of all groups in the system in a list.</p>
                           </li>
                           <li>
                              <p>The prepare refresh procedures (<code class="codeph">PREPARE_REFRESH</code>, <code class="codeph">EXECUTE_REFRESH</code>, and <code class="codeph">ABORT_REFRESH</code>) can work multiple groups. Their overloaded versions accept lists of group IDs at a time.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE__BCGJBHIJ">
                        <p class="titleinexample">Example 8-8 Prepare Sync Refresh Groups</p>
                        <p>This example illustrates how to prepare the sync refresh groups of <code class="codeph">MV1</code>, <code class="codeph">MV2</code>, and <code class="codeph">MV3</code>.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH(
        DBMS_SYNC_REFRESH.GET_GROUP_ID_LIST('MV1, MV2, MV3'));
</pre><p>Note that it is not necessary that these three materialized views be all in different groups. It is possible that two of the materialized views are in one group, and third in another; or even that all three materialized views are in the same group. Because <code class="codeph">PREPARE_REFRESH</code> is overloaded to accept either a group ID or a list of group IDs, the above call will work in all cases.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE__BCGCIDAF">
                        <p class="titleinexample">Example 8-9 Execute Sync Refresh Groups </p>
                        <p>This example illustrates how to prepare and execute the refresh of all sync refresh groups in the system.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH(
        DBMS_SYNC_REFRESH.GET_ALL_GROUP_IDS);

EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH(
        DBMS_SYNC_REFRESH.GET_ALL_GROUP_IDS);</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9116"></a><div class="props_rev_3"><a id="GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65" name="GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65"></a><h3 id="DWHSG-GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65" class="sect3"><span class="enumeration_section">8.4 </span>Specifying and Preparing Change Data for Synchronous Refresh
               </h3>
               <div>
                  <div class="section">
                     <p>Synchronous refresh requires you to specify and prepare the change data that serves as the input to the <code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code> procedures. There are two methods for specifying the change data:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Provide the change data in an outside table and register it with the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure as described in <a href="synchronous-refresh.html#GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1">Working with Partition Operations While Capturing Change Data for Synchronous Refresh</a>.
                           </p>
                        </li>
                        <li>
                           <p>Provide the change data by in staging logs and process them with the <code class="codeph">PREPARE_STAGING_LOG</code> procedure as described in <a href="synchronous-refresh.html#GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6">Working with Staging Logs While Capturing Change Data for Synchronous Refresh</a>.
                           </p>
                        </li>
                     </ul>
                     <p>Some important points about change data are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The two methods are not mutually exclusive and can be employed at the same time, even on the same table, but there cannot be any conflicts in the changes specified. For instance, you can use the staging log to specify the change in a partition with a small number of changes, but if another partition has extensive changes, you can provide the changes for that partition in an outside table.</p>
                        </li>
                        <li>
                           <p>For dimension tables, you can use only the staging logs to provide changes.</p>
                        </li>
                        <li>
                           <p>Synchronous refresh can handle arbitrary combinations of changes in fact and dimension tables, but it is optimized for the most common data warehouse usage scenarios, where the bulk of the changes are made to only a few partitions of the fact table.</p>
                        </li>
                        <li>
                           <p>Synchronous refresh places no restrictions on the use of nondestructive partition maintenance operations (PMOPS), such as add partition, used commonly in data warehouses. The use of such PMOPS is not directly related to the method used to specify change data.</p>
                        </li>
                        <li>
                           <p>Synchronous refresh requires that all staging logs in the group must be prepared, even if the staging log has no changes registered in it.</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9118"></a><a id="DWHSG9117"></a><div class="props_rev_3"><a id="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1" name="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1"></a><h4 id="DWHSG-GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1" class="sect4"><span class="enumeration_section">8.4.1 </span>Working with Partition Operations While Capturing Change Data for Synchronous Refresh
                  </h4>
                  <div>
                     <div class="section">
                        <p>Using the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure, you can provide the change data directly. This method is applicable only to fact tables. For each fact table partition that is changed, you must provide an outside table containing the data for that partition. The synchronous refresh demo (<code class="codeph">syncref_run.sql</code> and <code class="codeph">syncref_run.log</code>) contains an example. The steps are:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Create an outside table for the partition that it is intended to replace. It must have the same constraints as the fact table, and can be created in any desired tablespace.</span><div><pre class="oac_no_warn" dir="ltr">CREATE TABLE      fact_ot_fp3(
   time_key       DATE NOT NULL REFERENCES time(time_key),
   store_key      INTEGER NOT NULL REFERENCES store(store_key),
   dollar_sales   NUMBER (6,2),
   unit_sales     INTEGER)
   tablespace     syncref_fp3_tbs;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Insert the data for this partition into the outside table.</span></li>
                        <li class="stepexpand"><span>Register this table for partition exchange.</span><div><pre class="oac_no_warn" dir="ltr">begin
   DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION(
       partition_op                 =&gt; 'EXCHANGE',
       schema_name                  =&gt; 'SYNCREF_USER',
       base_table_name              =&gt; 'FACT',
       partition_name               =&gt; 'FP3',
       outside_partn_table_schema   =&gt; 'SYNCREF_USER',
       outside_partn_table_name     =&gt; 'FACT_OT_FP3');
   end;
  /
/
</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>When you register the outside table and execute the refresh, Oracle Database performs the following operation at <code class="codeph">EXECUTE_REFRESH</code> time:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE FACT EXCHANGE PARTITION fp3 WITH TABLE fact_ot_fp3
INCLUDING INDEXES WITHOUT VALIDATION;
</pre><p>However, you are not allowed to issue the above statement directly on your own. If you do, Oracle Database will give this error:</p><pre class="oac_no_warn" dir="ltr">ORA-31908: Cannot modify the contents of a table with a staging log.
</pre><p>Besides the <code class="codeph">EXCHANGE</code> operation, the two other partition operations that can be registered with the <code class="codeph">REGISTER_PARTITION_OPERATION</code> procedure are <code class="codeph">DROP</code> and <code class="codeph">TRUNCATE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1__BCGDJGBD">
                        <p class="titleinexample">Example 8-10 Registering a DROP Operation</p>
                        <p>This example illustrates how to specify the drop of the first partition (<code class="codeph">FP1</code>), by using the following statement.
                        </p><pre class="oac_no_warn" dir="ltr">begin
 DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION(
              partition_op                 =&gt; 'DROP',
              schema_name                  =&gt; 'SYNCREF_USER',
              base_table_name              =&gt; 'FACT',
              partition_name               =&gt; 'FP1');
end;
/
</pre><p>If you wanted to truncate the partition instead, you could specify <code class="codeph">TRUNCATE</code> instead of <code class="codeph">DROP</code> for the <code class="codeph">partition_op</code> parameter.
                        </p>
                        <p>The three partition operations (<code class="codeph">EXCHANGE</code>, <code class="codeph">DROP</code>, and <code class="codeph">TRUNCATE</code>) are called destructive PMOPS because they modify the contents of the table. The following partition operations are not destructive, and can be performed directly on a table registered with synchronous refresh:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ADD</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MOVE</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">RENAME</code> <code class="codeph">PARTITION</code></p>
                           </li>
                        </ul>
                        <p>In data warehouses, these partition operations are commonly used to manage the large volumes of data, and synchronous refresh places no restrictions on their usage. Oracle Database requires only that these operations be performed before the <code class="codeph">PREPARE_REFRESH</code> command is issued. This is because the <code class="codeph">PREPARE_REFRESH</code> procedure computes the mapping between the fact table partitions and the materialized view partitions, and if any partition-maintenance is done between the <code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code> procedures, Oracle Database will detect this at <code class="codeph">EXECUTE_REFRESH</code> and show an error.
                        </p>
                        <p>You can use the <code class="codeph">USER_SR_PARTN_OPS</code> catalog view to display the registered partition operations.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT   TABLE_NAME, PARTITION_OP, PARTITION_NAME,
         OUTSIDE_TABLE_SCHEMA ot_schema, OUTSIDE_TABLE_NAME ot_name
FROM     USER_SR_PARTN_OPS
ORDER BY TABLE_NAME;
 
TABLE_NAME PARTITION_ PARTITION_NAME  OT_SCHEMA       OT_NAME
---------- ---------- --------------- --------------- --------------------
FACT       EXCHANGE   FP3             SYNCREF_USER    FACT_OT_FP3
 
1 row selected.
</pre><p>These partition operations are consumed by the synchronous refresh operation and are automatically unregistered by the <code class="codeph">EXECUTE_REFRESH</code> procedure. So if you query <code class="codeph">USER_SR_PARTN_OPS</code> after <code class="codeph">EXECUTE_REFRESH</code>, it will show no rows.
                        </p>
                        <p>After registering a partition, if you find you made a mistake or change your mind, you can undo it with the <code class="codeph">UNREGISTER_PARTITION_OPERATION</code> command:
                        </p><pre class="oac_no_warn" dir="ltr">begin
 DBMS_SYNC_REFRESH.UNREGISTER_PARTITION_OPERATION(
              partition_op                  =&gt; 'EXCHANGE',
              schema_name                   =&gt; 'SYNCREF_USER',
              base_table_name               =&gt; 'FACT',
              partition_name                =&gt; 'FP3');
end;
/
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9119"></a><div class="props_rev_3"><a id="GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6" name="GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6"></a><h4 id="DWHSG-GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6" class="sect4"><span class="enumeration_section">8.4.2 </span>Working with Staging Logs While Capturing Change Data for Synchronous Refresh
                  </h4>
                  <div>
                     <p>In synchronous refresh, staging logs play a role similar to materialized view logs in incremental refresh. They are created with a DDL statement and can be altered to a materialized view log. Unlike materialized view logs, however, you are responsible for loading changes into the staging logs in a specified format. Each row in the staging log must have a key to identify it uniquely; this key is called the <span class="bold">staging</span> <span class="bold">log</span> <span class="bold">key</span>, and is defined in <span class="q">"<a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">About the Staging Log Key</a>"</span>.
                     </p>
                     <p>You are responsible for populating the staging log, which will consist of all the columns in the base table and an additional control column <code class="codeph">DMLTYPE$$</code> of type <code class="codeph">CHAR(2)</code>. This must have the value <code class="codeph">'I'</code> to denote the row is being inserted, <code class="codeph">'D'</code> for delete, and <code class="codeph">'UN'</code> and <code class="codeph">'UO'</code> for the new and old values of the row being updated, respectively. The last two must occur in pairs.
                     </p>
                     <p>The staging log is validated by the <code class="codeph">PREPARE_STAGING_LOG</code> procedure and consumed by the synchronous refresh operations (<code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code>). During validation by <code class="codeph">PREPARE_STAGING_LOG</code>, if errors are detected, they will be captured in an exceptions table. You can query the view <code class="codeph">USER_SR_STLOG_EXCEPTIONS</code> to get details on the exceptions.
                     </p>
                     <p>Synchronous refresh requires that, before calling <code class="codeph">PREPARE_REFRESH</code> for sync refresh groups, the staging logs of all tables in the group must be processed with <code class="codeph">PREPARE_STAGING_LOG</code>. This is necessary even if a table has no change data and its staging log is empty.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">About the Staging Log Key</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB">About Staging Log Rules</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0">About Columns Being Updated to NULL</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE">Examples of Working with Staging Logs</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F">Error Handling in Preparing Staging Logs</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9120"></a><div class="props_rev_3"><a id="GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A" name="GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A"></a><h5 id="DWHSG-GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A" class="sect5"><span class="enumeration_section">8.4.2.1 </span>About the Staging Log Key
                     </h5>
                     <div>
                        <p>In order to create a staging log on a base table, the base table must have a key. If the table has a primary key, the primary key is deemed to be staging log key on the table's staging log. Note that every dimension table has a primary key.</p>
                        <p>With fact tables, it is less common for them to have a primary key. If a table does not have a primary key, the columns that are the foreign keys of its dimension tables constitute its staging log key.</p>
                        <p>The key of a staging log can be described as:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The primary key of the base table. If a fact table has a primary key, it is sometimes called a surrogate key.</p>
                           </li>
                           <li>
                              <p>The set of foreign keys for a fact table. This applies if the fact table does not have a primary key. This assumption is common in data warehouses, though it is not enforced.</p>
                           </li>
                        </ul>
                        <p>The rules for loading staging logs are described in <span class="q">"<a href="synchronous-refresh.html#GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB">About Staging Log Rules</a>"</span>.
                        </p>
                        <p>The <code class="codeph">PREPARE_STAGING_LOG</code> procedure verifies that each key value is specified at most once. When populating the staging log, it is your responsibility to consolidate the changes if a row with the same key value is changed more than once. This process is known as <span class="bold">change</span> <span class="bold">consolidation</span>. When doing the change consolidation, you must:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Consolidate a delete-insert of the same row into an update operation with rows <code class="codeph">'UO'</code> and <code class="codeph">'UN'</code>.
                              </p>
                           </li>
                           <li>
                              <p>Consolidate multiple updates into a single update.</p>
                           </li>
                           <li>
                              <p>Prevent null changes such as an insert-update-delete of the same row from appearing in the staging log.</p>
                           </li>
                           <li>
                              <p>Consolidate an insert followed by multiple updates into a single insert.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9121"></a><div class="props_rev_3"><a id="GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB" name="GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB"></a><h5 id="DWHSG-GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB" class="sect5"><span class="enumeration_section">8.4.2.2 </span>About Staging Log Rules
                     </h5>
                     <div>
                        <p>Every row should contain non-null values for all the columns comprising the primary key. You are required to consolidate all the changes so that each key in the staging log can be specified only for one type of operation.</p>
                        <p>For the rows being inserted (<code class="codeph">DMLTYPE$$</code> is <code class="codeph">'I'</code>), all columns in the staging log must be supplied with valid values, conforming to any constraint on the corresponding columns in the base table. Keys of rows being inserted must not exist in the base table.
                        </p>
                        <p>For the rows being deleted (<code class="codeph">DMLTYPE$$</code> is <code class="codeph">'D</code>'), the non-key column values are optional. Similarly, for the rows specifying the old values of the columns being updated (<code class="codeph">DMLTYPE$$</code> is <code class="codeph">'UO'</code>), the non-key column values are optional; an important exception is the column whose values are being updated to <code class="codeph">NULL</code>, as explained subsequently.
                        </p>
                        <p>For the rows specifying the new values of the columns being updated (<code class="codeph">DMLTYPE$$</code> is <code class="codeph">'UN'</code>), the non-key column values are optional except for the values of the columns that were changed.
                        </p>
                     </div>
                  </div><a id="DWHSG9122"></a><div class="props_rev_3"><a id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0" name="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0"></a><h5 id="DWHSG-GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0" class="sect5"><span class="enumeration_section">8.4.2.3 </span>About Columns Being Updated to NULL
                     </h5>
                     <div>
                        <p>If a column is being updated to <code class="codeph">NULL</code>, its old value must be specified. Otherwise, Oracle Database may not be able to distinguish this from a column whose value is being left unchanged in the update.
                        </p>
                        <p>For example, let table <code class="codeph">T1</code> have three columns <code class="codeph">c1</code>, <code class="codeph">c2</code>, and <code class="codeph">c3</code>. Let there be a row with (<code class="codeph">c1, c2, c3) = (1, 5, 10)</code>, and you supply the following information in the staging log:
                        </p>
                        <div class="tblformal" id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0__GUID-D59D54B1-6235-45BA-8583-944614B1F3D3">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="This table contains the old and new values for one row data in the staging log of table T1." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="23%" id="d34570e2024">DMLTYPE$$</th>
                                    <th align="left" valign="bottom" width="18%" id="d34570e2027">C1</th>
                                    <th align="left" valign="bottom" width="29%" id="d34570e2030">C2</th>
                                    <th align="left" valign="bottom" width="29%" id="d34570e2033">C3</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d34570e2038" headers="d34570e2024 ">
                                       <p>UO</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d34570e2038 d34570e2027 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2038 d34570e2030 ">
                                       <p>NULL</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2038 d34570e2033 ">
                                       <p>NULL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d34570e2051" headers="d34570e2024 ">
                                       <p>UN</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d34570e2051 d34570e2027 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2051 d34570e2030 ">
                                       <p>NULL</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2051 d34570e2033 ">
                                       <p>11</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The result would be that the new row could be <code class="codeph">(1, 5, 11)</code> or <code class="codeph">(1, NULL, 11)</code> without having specified the old value. However, with that specification, it is clear the new row is (<code class="codeph">1, 5, 11)</code>. If you want to specify <code class="codeph">NULL</code> for <code class="codeph">c2</code>, you should specify the old value in the <code class="codeph">UO</code> row as follows:
                        </p>
                        <div class="tblformal" id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0__GUID-B57F64A3-C933-4D64-8C45-F2A9E8C0ED03">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="This table contains the old and new values for one row data in the staging log of table T1." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d34570e2094">DMLTYPE$$</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2097">C1</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2100">C2</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2103">C3</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d34570e2108" headers="d34570e2094 ">
                                       <p>UO</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2097 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2100 ">
                                       <p>5</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2103 ">
                                       <p>NULL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d34570e2121" headers="d34570e2094 ">
                                       <p>UN</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2097 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2100 ">
                                       <p>NULL</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2103 ">
                                       <p>11</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Because the old value of <code class="codeph">c2</code> is <code class="codeph">5</code>, (the correct previously updated value for the column), its new value, will be <code class="codeph">NULL</code> and the new row is <code class="codeph">(1, NULL, 11)</code>.
                        </p>
                     </div>
                  </div><a id="DWHSG9124"></a><a id="DWHSG9125"></a><a id="DWHSG9126"></a><a id="DWHSG9127"></a><a id="DWHSG9128"></a><a id="DWHSG9123"></a><div class="props_rev_3"><a id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE" name="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE"></a><h5 id="DWHSG-GUID-82DB4858-381A-4F37-8A82-58463B6C57BE" class="sect5"><span class="enumeration_section">8.4.2.4 </span>Examples of Working with Staging Logs
                     </h5>
                     <div>
                        <p>This section illustrates examples of working with staging logs.</p>
                        <p>The <code class="codeph">PREPARE_STAGING_LOG</code> procedure has an optional third parameter called <code class="codeph">PSL_MODE</code>. This allows you to specify whether any or all of the three types of DML statements specified in the staging log can be treated as trusted, and not be subject to verification by the <code class="codeph">PREPARE_STAGING_LOG</code> procedure, as shown in <a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFFJHI">Example 8-11</a>.
                        </p>
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFFJHI">
                           <p class="titleinexample">Example 8-11 Specifying Trusted DML Statements</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'store',
                                 DBMS_SYNC_REFRESH.INSERT_TRUSTED +
                                 DBMS_SYNC_REFRESH.DELETE_TRUSTED);
</pre><p>This call will skip verification of <code class="codeph">INSERT</code> and <code class="codeph">DELETE</code> DML statements in the staging log of <code class="codeph">STORE</code> but will verify <code class="codeph">UPDATE</code> DML statements.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFBBHD">
                           <p class="titleinexample">Example 8-12 Preparing Staging Logs</p>
                           <p>This example is taken from the demo <code class="codeph">syncref_run.sql</code>. It shows that the user has provided values for all columns for the delete and update operations. This is recommended if these values are available.
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('I',   5, 5, 'Store 5', '03060');

INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('I',   6, 6, 'Store 6', '03062');
 
INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UO',  4, 4, 'Store 4', '03062');
 
INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UN',  4, 4, 'Stor4NewNam', '03062');
 
INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('D',   3, 3, 'Store 3', '03060');

EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'store');

-- display initial contents of st_store

SELECT dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE
FROM st_store
ORDER BY STORE_KEY ASC, dmltype$$ DESC;

DM  STORE_KEY  STORE_NUMBER  STORE_NAME    ZIPCODE
--  ---------  ------------  ----------    -------
D            3            3  Store 3         03060
UO           4            4  Store 4         03062
UN           4            4  Stor4NewNam     03062
I            5            5  Store 5         03060
I            5            5  Store 6         03062

5 rows selected.
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGEEGJD">
                           <p class="titleinexample">Example 8-13 Filling in Missing Values for Deleting and Updating Records</p>
                           <p>This example shows that if you do not supply all the values for the delete and update operations, then when you run the <code class="codeph">PREPARE_STAGING_LOG</code> procedure, Oracle Database will fill in missing values.
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('D',  3, NULL, NULL, NULL);

INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UO',  4, NULL, NULL, NULL);
 
INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UN',  4, NULL, NULL, '03063');
 
EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'store');
 
SELECT dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE
FROM ST_STORE ORDER BY STORE_KEY ASC, dmltype$$ DESC;
 
DM STORE_KEY STORE_NUMBER STORE_NAME  ZIPCODE
-- --------- ------------ ----------- ---------
D          3            3 Store 3     03060
UO         4            4 Store 4     03062
UN         4            4 Store 4     03063
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGGACCB">
                           <p class="titleinexample">Example 8-14 Updating a Column to NULL</p>
                           <p>This example illustrates how to update a column to <code class="codeph">NULL</code>. If you want to update a column value to <code class="codeph">NULL</code>, then you must provide its old value in the <code class="codeph">UO</code> record.
                           </p>
                           <p>In this example, your goal is to change the zipcode of store 4 to 03063 and its name to <code class="codeph">NULL</code>. You can supply the old zipcode value, but you must supply the old value of <code class="codeph">store_name</code> in the <code class="codeph">'UO'</code> row, or else <code class="codeph">store_name</code> will be unchanged.
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UO',  4, NULL, 'Store 4', NULL);
 
INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('UN',  4, NULL, NULL, '03063');
 
EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'store');
 
SELECT dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE
FROM st_store ORDER BY STORE_KEY ASC, dmltype$$ DESC;
 
DM STORE_KEY STORE_NUMBER STORE_NAME  ZIPCODE
-- --------- ------------ ----------- --------
UO         4            4 Store 4     03062
UN         4            4             03063
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGBGHFG">
                           <p class="titleinexample">Example 8-15 Displaying Staging Log Statistics</p>
                           <p>This example illustrates how to use the <code class="codeph">USER_SR_STLOG_STATS</code> catalog view to display the staging log statistics.
                           </p><pre class="oac_no_warn" dir="ltr">SELECT   TABLE_NAME, STAGING_LOG_NAME, NUM_INSERTS, NUM_DELETE, NUM_UPDATES
FROM     USER_SR_STLOG_STATS
ORDER BY TABLE_NAME;
 
TABLE_NAME STAGING_LOG_NAME NUM_INSERTS NUM_DELETES NUM_UPDATES
---------- ---------------- ----------- ----------- -----------
FACT       ST_FACT                    4           1           1
STORE      ST_STORE                   2           1           1
TIME       ST_TIME                    1           0           0
 
3 rows selected.
</pre><p>If you use the same query at the end of the <code class="codeph">EXECUTE_REFRESH</code> procedure, then you will get no rows, indicating the change data has all been consumed by synchronous refresh.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG9129"></a><div class="props_rev_3"><a id="GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F" name="GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F"></a><h5 id="DWHSG-GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F" class="sect5"><span class="enumeration_section">8.4.2.5 </span>Error Handling in Preparing Staging Logs
                     </h5>
                     <div>
                        <p>When a table is processed by the <code class="codeph">PREPARE_STAGING_LOG</code> procedure, it will detect and report errors in the specification of change data that relates only to that table. For example, it will verify that keys of rows being inserted do not already exist in the base table and that keys of rows being deleted or updated do exist. However, the <code class="codeph">PREPARE_STAGING_LOG</code> procedure cannot detect errors related to the referential integrity constraints on the table; that is, it cannot detect errors if there are inconsistencies in the specification of change data that involves more than one table. Such errors will be detected at the time of the <code class="codeph">EXECUTE_REFRESH</code> procedure.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9130"></a><div class="props_rev_3"><a id="GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6" name="GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6"></a><h3 id="DWHSG-GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6" class="sect3"><span class="enumeration_section">8.5 </span>Troubleshooting Synchronous Refresh Operations
               </h3>
               <div>
                  <p>This section describes how to monitor the status of the two synchronous refresh procedures, <code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code> and how to troubleshoot errors that may occur. To be successful in using synchronous refresh, you should be aware of the different types of errors that can arise and how to deal with them.
                  </p>
                  <p>One of the most likely sources of errors is from incorrect preparation of the change data. These errors will present themselves as referential constraint violations when the <code class="codeph">EXECUTE_REFRESH</code> procedure is run. In such cases, the status of the group is set to <code class="codeph">ABORT</code>. It is important to learn to recognize these errors and address them.
                  </p>
                  <p>The topics covered in this section are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC">Overview of the Status of Refresh Operations</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-D2DE66DA-9D73-4789-A39B-040090819CCB">How PREPARE_REFRESH Sets the STATUS Fields</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725">Examples of Preparing for Synchronous Refresh Using PREPARE_REFRESH</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E">How EXECUTE_REFRESH Sets the Status Fields During Synchronous Refresh</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654">Examples of Executing Synchronous Refresh Using EXECUTE_REFRESH</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8">Example of EXECUTE_REFRESH with Constraint Violations</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9131"></a><div class="props_rev_3"><a id="GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC" name="GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC"></a><h4 id="DWHSG-GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC" class="sect4"><span class="enumeration_section">8.5.1 </span>Overview of the Status of Refresh Operations
                  </h4>
                  <div>
                     <p>The <code class="codeph">DBMS_SYNC_REFRESH</code> package provides three procedures to control the refresh execution process. You initiate synchronous refresh with the <code class="codeph">PREPARE_REFRESH</code> procedure, which plans the entire refresh operation and does the bulk of the computational work for refresh, followed by the <code class="codeph">EXECUTE_REFRESH</code> procedure, which carries out the refresh. The third procedure provided is <code class="codeph">ABORT_REFRESH</code>, which is used to recover from errors if either of these procedures fails.
                     </p>
                     <p>The <code class="codeph">USER_SR_GRP_STATUS</code> and <code class="codeph">USER_SR_OBJ_STATUS</code> catalog views contain all the information on the status of these refresh operations for current groups:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">USER_SR_GRP_STATUS</code> view shows the status of the group as a whole.
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">OPERATION</code> field indicates the current refresh procedure run on the group: <code class="codeph">PREPARE</code> or <code class="codeph">EXECUTE</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">STATUS</code> field indicates the status of the operation - <code class="codeph">RUNNING</code>, <code class="codeph">COMPLETE</code>, <code class="codeph">ERROR</code>-<code class="codeph">SOFT</code>, <code class="codeph">ERROR</code>-<code class="codeph">HARD</code>, <code class="codeph">ABORT</code>, <code class="codeph">PARTIAL</code>. These are explained in detail later.
                                 </p>
                              </li>
                              <li>
                                 <p>The group is identified by its group ID.</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>The <code class="codeph">USER_SR_OBJ_STATUS</code> view shows the status of each individual object.
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The object is identified by its owner, name, and type (<code class="codeph">TABLE</code> or <code class="codeph">MVIEW</code>) and group ID.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">STATUS</code> field, which may be <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>, <code class="codeph">ABORT</code>, or <code class="codeph">COMPLETE</code>. These are explained in detail later.
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9132"></a><div class="props_rev_3"><a id="GUID-D2DE66DA-9D73-4789-A39B-040090819CCB" name="GUID-D2DE66DA-9D73-4789-A39B-040090819CCB"></a><h4 id="DWHSG-GUID-D2DE66DA-9D73-4789-A39B-040090819CCB" class="sect4"><span class="enumeration_section">8.5.2 </span>How PREPARE_REFRESH Sets the STATUS Fields
                  </h4>
                  <div>
                     <p>When you launch a new <code class="codeph">PREPARE_REFRESH</code> job, the group's <code class="codeph">STATUS</code> is set to <code class="codeph">RUNNING</code> and the <code class="codeph">STATUS</code> of the objects in the group is set to <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>. When the <code class="codeph">PREPARE_REFRESH</code> job finishes, the status of the objects remains unchanged, but the group's status is changed to one of following three values:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">COMPLETE</code> if the job completed successfully.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR_SOFT</code> if the job encountered the ORA-01536: space quota exceeded for tablespace '%s' error.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR_HARD</code> otherwise (that is, if the job encountered any error other than ORA-01536).
                           </p>
                        </li>
                     </ul>
                     <p>Some points to keep in mind when using the <code class="codeph">PREPARE_REFRESH</code> procedure:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> status of the objects in the group signifies that the data of the objects has not been modified by the <code class="codeph">PREPARE_REFRESH</code> job. The data modification will occur only in the <code class="codeph">EXECUTE_REFRESH</code> step, at which time the status will be changed as appropriate. This is described later.
                           </p>
                        </li>
                        <li>
                           <p>If the <code class="codeph">STATUS</code> is <code class="codeph">ERROR_SOFT</code>, you can fix the ORA-01536 error by increasing the space quota for the specified tablespace, and resume <code class="codeph">PREPARE_REFRESH</code>. Alternatively, you can choose to abort the refresh with <code class="codeph">ABORT_REFRESH</code>.
                           </p>
                        </li>
                        <li>
                           <p>If the <code class="codeph">STATUS</code> value is <code class="codeph">ERROR_HARD</code>, then your only option is to abort the refresh with <code class="codeph">ABORT_REFRESH</code>.
                           </p>
                        </li>
                        <li>
                           <p>If the <code class="codeph">STATUS</code> value after the <code class="codeph">PREPARE_REFRESH</code> procedure finishes is <code class="codeph">RUNNING</code>, then an error has occurred. Contact Oracle Support Services for assistance.
                           </p>
                        </li>
                        <li>
                           <p>A <code class="codeph">STATUS</code> value of <code class="codeph">ERROR_HARD</code> might be related to running out of resources because the <code class="codeph">PREPARE_REFRESH</code> procedure can be resource-intensive. If you are not able to identify the problem, then contact Oracle Support Services for assistance. But if you can identify the problem and fix it, then you might be able to continue using synchronous refresh, by first running <code class="codeph">ABORT_REFRESH</code> and then the <code class="codeph">PREPARE_REFRESH</code> procedure.
                           </p>
                        </li>
                        <li>
                           <p>Remember that you can launch a new <code class="codeph">PREPARE_REFRESH</code> job only when the previous refresh operation on the group (if any) has either completed execution successfully or has aborted.
                           </p>
                        </li>
                        <li>
                           <p>If the <code class="codeph">STATUS</code> value of the <code class="codeph">PREPARE_REFRESH</code> procedure at the end is not <code class="codeph">COMPLETE</code>, you cannot proceed to the <code class="codeph">EXECUTE_REFRESH</code> step. If you are unable to get <code class="codeph">PREPARE_REFRESH</code> to work correctly, then you can proceed to the unregistration phase, and maintain the objects in the groups with other refresh methods.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9134"></a><a id="DWHSG9135"></a><a id="DWHSG9136"></a><a id="DWHSG9137"></a><a id="DWHSG9133"></a><div class="props_rev_3"><a id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725" name="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725"></a><h4 id="DWHSG-GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725" class="sect4"><span class="enumeration_section">8.5.3 </span>Examples of Preparing for Synchronous Refresh Using PREPARE_REFRESH
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section offers examples of common cases when preparing a refresh.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCCJFA">
                        <p class="titleinexample">Example 8-16 PREPARE_REFRESH Succeeds with Status COMPLETE</p>
                        <p>This example shows a <code class="codeph">PREPARE_REFRESH</code> procedure completing successfully.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH( DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
PL/SQL procedure successfully completed.
 
SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');

OPERATION  STATUS
---------  ------
PREPARE    COMPLETE
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGJJHBI">
                        <p class="titleinexample">Example 8-17 PREPARE_REFRESH Fails with Status ERROR_SOFT</p>
                        <p>This example shows a <code class="codeph">PREPARE_REFRESH</code> procedure encountering ORA-01536.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH( DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
BEGIN DBMS_SYNC_REFRESH.PREPARE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')); END;
 
*
ERROR at line 1:
ORA-01536: space quota exceeded for tablespace 'DUMMY_TS'
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 63
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 411
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 429
ORA-06512: at line 1PL/SQL procedure successfully completed.
 
SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ------
PREPARE    ERROR_SOFT
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGGCBCA">
                        <p class="titleinexample">Example 8-18 Resume of PREPARE_REFRESH Succeeds</p>
                        <p>This example is a continuation of <a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGJJHBI">Example 8-17</a>. After the ORA-01536 error is raised, increase the tablespace for <code class="codeph">DUMMY_TS</code> and rerun the <code class="codeph">PREPARE_REFRESH</code> procedure, which now completes successfully. Note that the <code class="codeph">PREPARE_REFRESH</code> procedure will resume processing from the place where it stopped. Also note the usage of the <code class="codeph">PREPARE_REFRESH</code> procedure is no different from normal, and does not require any parameters or settings to indicate the procedure is being resumed.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
PL/SQL procedure successfully completed.
 
SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ------
PREPARE    COMPLETE
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCBFJF">
                        <p class="titleinexample">Example 8-19 Abort of PREPARE_REFRESH</p>
                        <p>This example assumes the <code class="codeph">PREPARE_REFRESH</code> procedure has failed and the <code class="codeph">STATUS</code> value is <code class="codeph">ERROR_HARD</code>. You then run the <code class="codeph">ABORT_REFRESH</code> procedure to abort the prepare job. Note that the <code class="codeph">STATUS</code> value has changed from <code class="codeph">ERROR_HARD</code> to <code class="codeph">ABORT</code> at the end.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ------
PREPARE    ERROR_HARD
 
EXECUTE DBMS_SYNC_REFRESH.ABORT_REFRESH( DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
PL/SQL procedure successfully completed.
 
SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ------
PREPARE    ABORT</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9138"></a><div class="props_rev_3"><a id="GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E" name="GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E"></a><h4 id="DWHSG-GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E" class="sect4"><span class="enumeration_section">8.5.4 </span>How EXECUTE_REFRESH Sets the Status Fields During Synchronous Refresh
                  </h4>
                  <div>
                     <p>The <code class="codeph">EXECUTE_REFRESH</code> procedure divides the group of objects in the sync refresh group into subgroups, each of which is refreshed atomically. The first subgroup consists of the base tables. Each materialized view in the sync refresh group is placed in a separate subgroup and refreshed atomically.
                     </p>
                     <p>In the case of the <code class="codeph">EXECUTE_REFRESH</code> procedure, the possible end states of the <code class="codeph">STATUS</code> field are: <code class="codeph">COMPLETE</code>, <code class="codeph">PARTIAL</code>, and <code class="codeph">ABORT</code>:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">COMPLETE</code></p>
                           <p>This state is reached if the base tables and all the materialized views refresh successfully.</p>
                        </li>
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">ABORT</code></p>
                           <p>This state indicates the refresh of the base tables subgroup has failed; the data in the tables and materialized views is consistent but unchanged. If this happens, then there should be an error associated with the failure. If it is a user error, such as a constraint violation, then you can fix the problem and retry the synchronous refresh operation from the beginning (that is, <code class="codeph">PREPARE_STAGING_LOG</code> for each table in the group <code class="codeph">PREPARE_REFRESH</code> and <code class="codeph">EXECUTE_REFRESH</code>.). If it is not a user error, then you should contact Oracle Support Services.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">PARTIAL</code></p>
                           <p>If all the base tables refresh successfully and some, but not all, materialized views refresh successfully, then this state is reached. The data in the tables and materialized views that have refreshed successfully are consistent with one another; the other materialized views are stale and need complete refresh. If this happens, there should be an error associated with the failure. Most likely this is not a user error, but an Oracle error that you should report to Oracle Support Services. You have two choices in this state:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Retry execution of the <code class="codeph">EXECUTE_REFRESH</code> procedure. In such a case, <code class="codeph">EXECUTE_REFRESH</code> will retry the refresh of the failed materialized views with another refresh method like PCT-refresh or <code class="codeph">COMPLETE</code> refresh. If all materialized views succeed, then the status will be set to <code class="codeph">COMPLETE</code>. Otherwise, the status will remain at <code class="codeph">PARTIAL</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Invoke the <code class="codeph">ABORT_REFRESH</code> procedure to abort the materialized views. This will roll back changes to all materialized views and base tables. They will all have the same data as in the original state before any of the changes in the staging logs or registered partition operations has been applied to them.
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>In the case of errors in the <code class="codeph">EXECUTE_REFRESH</code> procedure, the following fields in the <code class="codeph">USER_SR_GRP_STATUS</code> view are also useful:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">NUM_MVS_COMPLETED</code>, which contains the number of materialized views that completed the refresh operation successfully.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">NUM_MVS_ABORTED</code>, which contains the number of materialized views that aborted.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR</code> and <code class="codeph">ERROR_MESSAGE</code>, which records the error encountered in the operation.
                           </p>
                        </li>
                     </ul>
                     <p>At the end of the <code class="codeph">EXECUTE_REFRESH</code>, procedure, the statuses of the objects in the group are marked as follows in the <code class="codeph">USER_SR_OBJ_STATUS</code> view:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The status of an object is set to <code class="codeph">COMPLETE</code> if the changes were applied to it successfully.
                           </p>
                        </li>
                        <li>
                           <p>The status of an object is set to <code class="codeph">ABORT</code> if the changes were not applied successfully. In this case, the object will be in the same state as it was before the refresh operation. The <code class="codeph">ERROR</code> and <code class="codeph">ERROR_MESSAGE</code> fields record the error encountered in the operation.
                           </p>
                        </li>
                        <li>
                           <p>The status of an object remains <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> if no changes were applied to it.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9140"></a><a id="DWHSG9141"></a><a id="DWHSG9142"></a><a id="DWHSG9143"></a><a id="DWHSG9139"></a><div class="props_rev_3"><a id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654" name="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654"></a><h4 id="DWHSG-GUID-12BD73E0-A438-4F41-89D5-D48B2704C654" class="sect4"><span class="enumeration_section">8.5.5 </span>Examples of Executing Synchronous Refresh Using EXECUTE_REFRESH
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section provides examples of common cases when executing a refresh.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">
                        <p class="titleinexample">Example 8-20 EXECUTE_REFRESH Completes Successfully</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">Example 8-20</a> shows an <code class="codeph">EXECUTE_REFRESH</code> procedure completing successfully.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH( DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));

PL/SQL procedure successfully completed.
 
SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ------
EXECUTE    COMPLETE
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">
                        <p class="titleinexample">Example 8-21 EXECUTE_REFRESH Succeeds Partially</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">Example 8-21</a> shows an <code class="codeph">EXECUTE_REFRESH</code> procedure succeeding partially. In this example, the <code class="codeph">EXECUTE_REFRESH</code> procedure fails after refreshing the base tables but before completing the refresh of all the materialized views. The resulting status of the group is <code class="codeph">PARTIAL</code> and the QSM-03280 error message is thrown.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
BEGIN DBMS_SYNC_REFRESH.EXECUTE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')); END;
 
*
ERROR at line 1:
ORA-31928: Synchronous refresh error
QSM-03280: One or more materialized views failed to refresh successfully.
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 63
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 411
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 446
ORA-06512: at line 1
</pre><p>Check the status of the group itself after the <code class="codeph">EXECUTE_REFRESH</code>.procedure. Note that the operation field is set to <code class="codeph">EXECUTE</code> and the status is <code class="codeph">PARTIAL</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, STATUS FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  -------------
EXECUTE    PARTIAL
</pre><p>By querying the <code class="codeph">USER_SR_GRP_STATUS</code> view, you find the number of materialized views that have aborted is 1 and the failed materialized view is <code class="codeph">MV1</code>.
                        </p>
                        <p>If you examine the status of objects in the group, because <code class="codeph">STORE</code> and <code class="codeph">TIME</code> are unchanged, then their status is <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, TYPE, STATUS FROM USER_SR_OBJ_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;
 
NAME             TYPE       STATUS
---------------- ---------- ----------------
MV1              MVIEW      ABORT
MV1_HALFMONTH    MVIEW      COMPLETE
MV2              MVIEW      COMPLETE
MV2_YEAR         MVIEW      COMPLETE
FACT             TABLE      COMPLETE
STORE            TABLE      NOT PROCESSED
TIME             TABLE      NOT PROCESSED
 
7 rows selected.
 
SELECT NUM_TBLS, NUM_MVS, NUM_MVS_COMPLETED, NUM_MVS_ABORTED
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED
-------- ------- ----------------- ---------------
       3       4                 3               1
</pre><p>At this point, you can attempt to run the <code class="codeph">EXECUTE_REFRESH</code> procedure once more. If the retry succeeds and the failed materialized views succeed, then the group status will be set to <code class="codeph">COMPLETE</code>. Otherwise, the status will remain at <code class="codeph">PARTIAL</code>. This is shown in <a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">Example 8-22</a>. You can also abort the refresh procedure and return to the original state. This is shown in <a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">Example 8-23</a>.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">
                        <p class="titleinexample">Example 8-22 Retrying a Refresh After a PARTIAL Status</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">Example 8-22</a> illustrates a continuation of <a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">Example 8-21</a>. You retry the <code class="codeph">EXECUTE_REFRESH</code> procedure and it succeeds:
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
PL/SQL procedure successfully completed.
 
--Check the status of the group itself after the EXECUTE_REFRESH operation;
--note that the operation field is set to EXECUTE and status is COMPLETE.

SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------  ---------
EXECUTE    COMPLETE
</pre><p>By querying the <code class="codeph">USER_SR_GRP_STATUS</code> view, you find the number of materialized views that have aborted is 0 and the status of <code class="codeph">MV1</code> is <code class="codeph">COMPLETE</code>. If you examine the status of objects in the group, because <code class="codeph">STORE</code> and <code class="codeph">TIME</code> are unchanged, then their status is <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, TYPE, STATUS FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;
 
NAME             TYPE       STATUS
---------------- ---------- ----------------
MV1              MVIEW      COMPLETE
MV1_HALFMONTH    MVIEW      COMPLETE
MV2              MVIEW      COMPLETE
MV2_YEAR         MVIEW      COMPLETE
FACT             TABLE      COMPLETE
STORE            TABLE      NOT PROCESSED
TIME             TABLE      NOT PROCESSED
 
7 rows selected.
 
SELECT NUM_TBLS, NUM_MVS, NUM_MVS_COMPLETED, NUM_MVS_ABORTED
FROM  USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED
-------- ------- ----------------- ---------------
       3       4                 4               0
</pre><p>You can examine the tables and materialized views to verify that the changes in the change data have been applied to them correctly, and the materialized views and tables are consistent with one another.</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">
                        <p class="titleinexample">Example 8-23 Aborting a Refresh with a PARTIAL Status</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">Example 8-23</a> illustrates aborting a refresh procedure that is in a <code class="codeph">PARTIAL</code> state.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.ABORT_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
PL/SQL procedure successfully completed.
</pre><p>Check the status of the group itself after the <code class="codeph">ABORT_REFRESH</code> procedure; note that the operation field is set to <code class="codeph">EXECUTE</code> and status is <code class="codeph">ABORT</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, STATUS FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------- -------
EXECUTE    ABORT
</pre><p>By querying the <code class="codeph">USER_SR_GRP_STATUS</code> view, you see that all the materialized views have aborted, and the fact table as well. Check the status of objects in the group; because <code class="codeph">STORE</code> and <code class="codeph">TIME</code> are unchanged, their status is <code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, TYPE, STATUS FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')
ORDER BY TYPE, NAME;
 
NAME             TYPE       STATUS
---------------- ---------- ----------------
MV1              MVIEW      ABORT
MV1_HALFMONTH    MVIEW      ABORT
MV2              MVIEW      ABORT
MV2_YEAR         MVIEW      ABORT
FACT             TABLE      ABORT
STORE            TABLE      NOT PROCESSED
TIME             TABLE      NOT PROCESSED
 
7 rows selected.
 
SELECT NUM_TBLS, NUM_MVS, NUM_MVS_COMPLETED, NUM_MVS_ABORTED
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED
-------- ------- ----------------- ---------------
       3       4                 0               4
</pre><p>You can examine the tables and materialized views to verify that they are all in the original state and no changes from the change data have been applied to them.</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9145"></a><a id="DWHSG9144"></a><div class="props_rev_3"><a id="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8" name="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8"></a><h4 id="DWHSG-GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8" class="sect4"><span class="enumeration_section">8.5.6 </span>Example of EXECUTE_REFRESH with Constraint Violations
                  </h4>
                  <div>
                     <div class="section">
                        <p>In the synchronous refresh method, change data is loaded into the tables and materialized views at the same time to keep them synchronized. In the other refresh methods, change data is loaded into tables first, and any constraints that are enabled are checked at that time. In the synchronous refresh method, the outside table is prepared using trusted data from the user, and constraint validation is turned off to save execution time. The following example shows a constraint violation that is caught by the <code class="codeph">EXECUTE_REFRESH</code> procedure. In such cases, the final status of the <code class="codeph">EXECUTE_REFRESH</code> procedure will be <code class="codeph">ABORT</code>. You will have to identify and fix the problem in the change data and begin the synchronous refresh phase all over.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8__BCGJJDEH">
                        <p class="titleinexample">Example 8-24 Child Key Constraint Violation</p>
                        <p>In <a href="synchronous-refresh.html#GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8__BCGJJDEH">Example 8-24</a>, assume the same tables as in the file <code class="codeph">syncref_run.sql</code> in the <code class="codeph">rdbms/demo</code> directory are used and populated with the same data. In particular, the table <code class="codeph">STORE</code> has four rows with the primary key <code class="codeph">STORE_KEY</code> having the values 1 through 4, and the <code class="codeph">FACT</code> table has rows referencing all four stores, including store 3.
                        </p>
                        <p>To demonstrate a parent-key constraint violation, populate the staging log of <code class="codeph">STORE</code> with the delete of the row having the <code class="codeph">STORE_KEY</code> of 3. There are no other changes to the other tables. When the <code class="codeph">EXECUTE_REFRESH</code> procedure runs, it fails with the ORA-02292 error as shown.
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store (dmltype$$, STORE_KEY, STORE_NUMBER, STORE_NAME, ZIPCODE)
VALUES ('D',   3, 3, 'Store 3', '03060');
 
-- Prepare the staging logs
EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'fact');
EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'time');
EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG('syncref_user', 'store');
 
-- Prepare the refresh
EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
 
-- Execute the refresh
EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH( -
           DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1'));
BEGIN DBMS_SYNC_REFRESH.EXECUTE_REFRESH(DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1')); END;
 
*
ERROR at line 1:
ORA-02292: integrity constraint (SYNCREF_USER.SYS_C0031765) violated - child record found
ORA-06512: at line 1
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 63
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 411
ORA-06512: at "SYS.DBMS_SYNC_REFRESH", line 446
ORA-06512: at line 1
</pre><p>Examine the status of the group itself after the <code class="codeph">EXECUTE_REFRESH</code> procedure. Note that the operation field is set to <code class="codeph">EXECUTE</code> and the status is <code class="codeph">ABORT</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, STATUS
FROM USER_SR_GRP_STATUS
WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID('MV1');
 
OPERATION  STATUS
---------- --------------
EXECUTE    ABORT
</pre><p>If you check the contents of the base tables and of <code class="codeph">MV1</code>, then you will find there is no change, and they all have the original values.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9147"></a><a id="DWHSG9146"></a><div class="props_rev_3"><a id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3" name="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3"></a><h3 id="DWHSG-GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3" class="sect3"><span class="enumeration_section">8.6 </span>Performing Synchronous Refresh Eligibility Analysis
               </h3>
               <div>
                  <div class="section">
                     <p>The <code class="codeph">CAN_SYNCREF_TABLE</code> function tells you whether a table and its dependent materialized views are eligible for synchronous refresh. It provides an explanation of its analysis. If the table and views are not eligible, you can examine the reasons and take appropriate action if possible. To be eligible for synchronous refresh, a table must satisfy the various criteria described earlier.
                     </p>
                     <p>You can invoke <code class="codeph">CAN_SYNCREF_TABLE</code> function in two ways:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p> Use a table to store the output of the <code class="codeph">CAN_SYNCREF_TABLE</code> function
                           </p>
                           <p>The following shows the basic syntax for using an output table: </p><pre class="oac_no_warn" dir="ltr">can_syncref_table(schema_name   IN VARCHAR2,
                  table_name    IN VARCHAR2,
                  statement_id  IN VARCHAR2)
</pre></li>
                        <li>
                           <p> Use a VARRAY to store the output of the CAN_SYNCREF_TABLE function</p>
                           <p>To direct the output of the <code class="codeph">CAN_SYNCREF_TABLE</code> function to a <code class="codeph">VARRAY</code> instead of a table, call the procedure as follows:
                           </p><pre class="oac_no_warn" dir="ltr">can_syncref_table(schema_name   IN VARCHAR2,
                  table_name    IN VARCHAR2,
                  output_array  IN OUT Sys.CanSyncRefTypeArray)
</pre></li>
                     </ul>
                     <p>You can create an output table called <code class="codeph">SYNCREF_TABLE</code> by executing the <code class="codeph">utlcsrt.sql</code> script. 
                     </p>
                     <div class="tblformal" id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3__GUID-16DECA53-81BE-4D70-ACF1-8D97E2BA9067">
                        <p class="titleintable">Table 8-1 CAN_SYNCREF_TABLE</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="CAN_SYNCREF_TABLE" summary="This table describes the parameters of the CAN_SYNCREF_TABLE function." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d34570e3294">Parameter</th>
                                 <th align="left" valign="bottom" width="77%" id="d34570e3297">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3302" headers="d34570e3294 ">
                                    <p><code class="codeph">schema_name</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3302 d34570e3297 ">
                                    <p>Name of the schema of the base table.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3310" headers="d34570e3294 ">
                                    <p><code class="codeph">base_table_name</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3310 d34570e3297 ">
                                    <p>Name of the base table.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3318" headers="d34570e3294 ">
                                    <p><code class="codeph">statement_id</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3318 d34570e3297 ">
                                    <p>A string (<code class="codeph">VARCHAR2(30)</code> to identify the rows pertaining to a call of the <code class="codeph">CAN_SYNCREF_TABLE</code> function when the output is directed to a table named <code class="codeph">SYNCREF_TABLE</code> in the user's schema.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3335" headers="d34570e3294 ">
                                    <p><code class="codeph">output_array</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3335 d34570e3297 ">
                                    <p>The output array into which <code class="codeph">CAN_SYNCREF_TABLE</code> records the information on the eligibility of the base table and its dependent materialized views for synchronous refresh.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3__GUID-59A88AF1-D638-40E7-A996-D00AFF3CF935">
                        <p class="notep1">Note:</p>
                        <p>Only one <code class="codeph">statement_id</code> or <code class="codeph">output_array</code> parameter need be provided to the <code class="codeph">CAN_SYNCREF_TABLE</code> function.
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9148"></a><div class="props_rev_3"><a id="GUID-525992D6-4104-44BA-84D6-7B7CE50B8951" name="GUID-525992D6-4104-44BA-84D6-7B7CE50B8951"></a><h4 id="DWHSG-GUID-525992D6-4104-44BA-84D6-7B7CE50B8951" class="sect4"><span class="enumeration_section">8.6.1 </span>Using SYNCREF_TABLE to Store the Results of Synchronous Refresh Eligibility Analysis
                  </h4>
                  <div>
                     <div class="section">
                        <p>The output of the <code class="codeph">CAN_SYNCREF_TABLE</code> function can be directed to a table named <code class="codeph">SYNCREF_TABLE</code>. You are responsible for creating <code class="codeph">SYNCREF_TABLE</code>; it can be dropped when it is no longer needed. The format of <code class="codeph">SYNCREF_TABLE</code> is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE SYNCREF_TABLE(
          statement_id             VARCHAR2(30),
          schema_name              VARCHAR2(30),
          table_name               VARCHAR2(30),
          mv_schema_name           VARCHAR2(30),
          mv_name                  VARCHAR2(30),
          eligible                 VARCHAR2(1),   -- 'Y' , 'N'
          seq_num                  NUMBER,
          msg_number               NUMBER,
          message                  VARCHAR2(4000)
);
</pre><p>You must provide a different <code class="codeph">statement_id</code> parameter for each invocation of this procedure on the same table. If not, an error will be thrown. The <code class="codeph">statement_id</code>, <code class="codeph">schema_name</code>, and <code class="codeph">table_name</code> fields identify the results for a given table and <code class="codeph">statement_id</code>.
                        </p>
                        <p>Each row contains information on the eligibility of either the table or its dependent materialized view. The <code class="codeph">CAN_SYNCREF_TABLE</code> function guarantees that each row has values for both <code class="codeph">mv_schema_name</code> and <code class="codeph">mv_name</code> that are either <code class="codeph">NULL</code> or non-<code class="codeph">NULL</code>. These rows have the following semantics:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the <code class="codeph">mv_schema_name</code> value is <code class="codeph">NULL</code> and <code class="codeph">mv_name</code> is <code class="codeph">NULL</code>, then the <code class="codeph">ELIGIBLE</code> field describes whether the table is eligible for synchronous refresh; if the table is not eligible, the <code class="codeph">MSG_NUMBER</code> and <code class="codeph">MESSAGE</code> fields provide the reason for this.
                              </p>
                           </li>
                           <li>
                              <p>If the <code class="codeph">mv_schema_name</code> value is <code class="codeph">NOT</code> <code class="codeph">NULL</code> and <code class="codeph">mv_name</code> is <code class="codeph">NOT</code> <code class="codeph">NULL</code>, then the <code class="codeph">ELIGIBLE</code> field describes whether the materialized view is eligible for synchronous refresh; if the materialized view is not eligible, the <code class="codeph">MSG_NUMBER</code> and <code class="codeph">MESSAGE</code> fields provide the reason for this.
                              </p>
                           </li>
                        </ul>
                        <p>You must provide a different <code class="codeph">statement_id</code> parameter for each invocation of this procedure on the same table, or else an error will be thrown. The <code class="codeph">statement_id</code>, <code class="codeph">schema_name</code>, and <code class="codeph">table_name</code> fields identify the results for a given table and <code class="codeph">statement_id</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9149"></a><div class="props_rev_3"><a id="GUID-07ED0045-231C-477A-91F8-109BF4A92553" name="GUID-07ED0045-231C-477A-91F8-109BF4A92553"></a><h4 id="DWHSG-GUID-07ED0045-231C-477A-91F8-109BF4A92553" class="sect4"><span class="enumeration_section">8.6.2 </span>Using a VARRAY to Store the Results of Synchronous Refresh Eligibility Analysis
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can save the output of the <code class="codeph">CAN_SYNCREF_TABLE</code> function in a PL/SQL <code class="codeph">VARRAY</code>. The elements of this array are of type <code class="codeph">CanSyncRefMessage</code>, which is predefined in the <code class="codeph">SYS</code> schema as shown in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">TYPE CanSyncRefMessage IS OBJECT (
          schema_name         VARCHAR2(30),
          table_name          VARCHAR2(30),
          mv_schema_name      VARCHAR2(30),
          mv_name             VARCHAR2(30),
          eligible            VARCHAR2(1),    -- 'Y' , 'N'
          seq_num             NUMBER,
          msg_number          NUMBER,
          message             VARCHAR2(4000)
);
</pre><p>The array type, <code class="codeph">CanSyncRefArrayType</code>, which is a <code class="codeph">VARRAY</code> of <code class="codeph">CanSyncRefMessage</code> objects, is predefined in the <code class="codeph">SYS</code> schema as follows:
                        </p><pre class="oac_no_warn" dir="ltr">TYPE  CanSyncRefArrayType AS VARRAY(256) OF CanSyncRefMessage;
</pre><p>Each <code class="codeph">CanSyncRefMessage</code> record provides a message concerning the eligibility of the base table or a dependent materialized view for synchronous refresh. The semantics of the fields is the same as that of the corresponding fields in <code class="codeph">SYNCREF_TABLE</code>. However, <code class="codeph">SYNCREF_TABLE</code> has a <code class="codeph">statement_id</code> field that is absent in <code class="codeph">CanSyncRefMessage</code> because no <code class="codeph">statement_id</code> is supplied (because it is not required) when the <code class="codeph">CAN_SYNCREF_TABLE</code> procedure is called with a <code class="codeph">VARRAY</code> parameter.
                        </p>
                        <p>The default size limit for <code class="codeph">CanSyncRefArrayType</code> is 256 elements. If you need more than 256 elements, then connect as <code class="codeph">SYS</code> and redefine <code class="codeph">CanSyncRefArray</code>. The following commands, when connected as the <code class="codeph">SYS</code> user, redefine <code class="codeph">CanSyncRefArray</code> and set the limit to 2048 elements:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE CanSyncRefArrayType AS VARRAY(2048) OF SYS.CanSyncRefMessage;
/
GRANT EXECUTE ON SYS.CanSyncRefMessage TO PUBLIC;

CREATE OR REPLACE PUBLIC SYNONYM CanSyncRefMessage FOR SYS.CanSyncRefMessage;
/
GRANT EXECUTE ON SYS.CanSyncRefArrayType TO PUBLIC;

CREATE OR REPLACE PUBLIC SYNONYM CanSyncRefArrayType FOR SYS.CanSyncRefArrayType;
/
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9150"></a><div class="props_rev_3"><a id="GUID-3EA67828-9F6F-491A-8249-55564D88F284" name="GUID-3EA67828-9F6F-491A-8249-55564D88F284"></a><h4 id="DWHSG-GUID-3EA67828-9F6F-491A-8249-55564D88F284" class="sect4"><span class="enumeration_section">8.6.3 </span>Demo Scripts
                  </h4>
                  <div>
                     <p>The synchronous refresh demo scripts in the <code class="codeph">rdbms/demo</code> directory contain examples of the most common scenarios of the various synchronous refresh operations, including <code class="codeph">CAN_SYNCREF_API</code>. The main script is <code class="codeph">syncref_run.sql</code> and its log is <code class="codeph">syncref_run.log</code>. The file <code class="codeph">syncref_cst.sql</code> defines two procedures <code class="codeph">DO_CST</code> and <code class="codeph">DO_CST_ARR</code>, which simplify the usage of the <code class="codeph">CAN_SYNCREF_TABLE</code> function and display the information on the screen in a convenient format. This format is documented in the <code class="codeph">syncref_cst.sql</code> file.
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG9151"></a><div class="props_rev_3"><a id="GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB" name="GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB"></a><h3 id="DWHSG-GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB" class="sect3"><span class="enumeration_section">8.7 </span>Overview of Synchronous Refresh Security Considerations
               </h3>
               <div>
                  <p>The execute privilege on the <code class="codeph">DBMS_SYNC_REFRESH</code> package is granted to <code class="codeph">PUBLIC</code>, so all users can execute the procedures in that package to perform synchronous refresh on objects owned by them. The database administrator can perform synchronous refresh operation on all tables and materialized views in the database.
                  </p>
                  <p>In general, if a user without the <code class="codeph">DBA</code> privilege wants to use synchronous refresh on another user's table, he must have complete privileges to read from and write to that table; that is, the user must have the <code class="codeph">SELECT</code>, <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> privileges on that table or materialized view. The user can have the <code class="codeph">READ</code> privilege instead of the <code class="codeph">SELECT</code> privilege. A couple of exceptions occur in the following:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">PURGE_REFRESH_STATS</code> and <code class="codeph">ALTER_REFRESH_STATS_RETENTION</code> functions
                        </p>
                        <p>These two functions implement the purge policy and can be used to change the default retention period. These functions can be executed only by the database administrator.</p>
                     </li>
                     <li>
                        <p>The <code class="codeph">CAN_SYNCREF_TABLE</code> function
                        </p>
                        <p>This is an advisory function that examines the eligibility for synchronous refresh of all the materialized views associated with a specified table. Hence, this function requires the <code class="codeph">READ</code> or <code class="codeph">SELECT</code> privilege on all materialized views associated with the specified table.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>