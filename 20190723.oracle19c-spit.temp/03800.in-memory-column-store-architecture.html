<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">
      <meta name="description" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">
      <title>In-Memory Column Store Architecture</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database In-Memory Guide">
      <meta property="og:description" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database In-Memory Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00">
      <meta name="dcterms.title" content="Database In-Memory Guide">
      <meta name="dcterms.dateCopyrighted" content="2016, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96137-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="intro-to-in-memory-column-store.html" title="Previous" type="text/html">
      <link rel="next" href="configuring-the-im-column-store.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="intro-to-in-memory-column-store.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="configuring-the-im-column-store.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database In-Memory Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="concepts-for-the-im-column-store.html" property="item" typeof="WebPage"><span property="name">Oracle Database In-Memory Concepts</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">In-Memory Column Store Architecture</li>
            </ol>
            <a id="GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" name="GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224"></a>
            
            <h2 id="INMEM-GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" class="sect2"><span class="enumeration_chapter">2 </span>In-Memory Column Store Architecture
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>The <span class="bold">In-Memory Column Store</span> (IM column store) stores tables and partitions in memory using a <span class="bold">columnar format</span> optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.
               </p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E">Dual-Format: Column and Row</a><br>When you enable an IM column store, the SGA manages data in separate locations: the In-Memory Area and the database buffer cache. 
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1">In-Memory Storage Units</a><br>The IM column store manages both data and metadata in optimized storage units, not in traditional Oracle data blocks. 
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757">Expression Statistics Store (ESS)</a><br>The <strong class="term">Expression Statistics Store (ESS)</strong> is a repository maintained by the optimizer to store statistics about expression evaluation. The ESS resides in the SGA and persists on disk.
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2">In-Memory Process Architecture</a><br>In response to queries and DML, server processes scan columnar data and update SMU metadata. Background processes populate row data from disk into the IM column store.
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310">CPU Architecture: SIMD Vector Processing</a><br>For data that is populated in the IM column store, the database uses SIMD (single instruction, multiple data) vector processing.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="concepts-for-the-im-column-store.html#GUID-5A72B48A-8427-41AE-9220-E46042BC90C4" title="This part introduces the Oracle Database In-Memory (Database In-Memory) feature set, and explains the basic architecture of the In-Memory Column Store (IM column store).">Oracle Database In-Memory Concepts</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-FF2499C5-C582-496A-B547-CFE49C84185E" name="GUID-FF2499C5-C582-496A-B547-CFE49C84185E"></a><h3 id="INMEM-GUID-FF2499C5-C582-496A-B547-CFE49C84185E" class="sect3"><span class="enumeration_section">2.1 </span>Dual-Format: Column and Row
               </h3>
               <div>
                  <p>When you enable an IM column store, the SGA manages data in separate locations: the In-Memory Area and the database buffer cache. </p>
                  <p>The IM column store encodes data in a columnar format: each column is a separate structure. The columns are stored contiguously, which optimizes them for analytic queries. The database buffer cache can modify objects that are also populated in the IM column store. However, the buffer cache stores data in the traditional row format. Data blocks store the rows contiguously, optimizing them for transactions.</p>
                  <p>The following figure illustrates the difference between row-based storage and columnar storage.</p>
                  <div class="figure" id="GUID-FF2499C5-C582-496A-B547-CFE49C84185E__GUID-D12E234B-F0E5-49BD-B891-ED7A9F4643B2">
                     <p class="titleinfigure">Figure 2-1 Columnar and Row-Based Storage</p><img src="img/inmem_3v_012.png" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" longdesc="img_text/inmem_3v_012.html"><br><a href="img_text/inmem_3v_012.html">Description of "Figure 2-1 Columnar and Row-Based Storage"</a></div>
                  <!-- class="figure" -->
                  <p>This section creates the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E">Columnar Data in the In-Memory Area</a><br>The <strong class="term">In-Memory Area</strong> is an optional SGA component that contains the IM column store.
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6">Row Data in the Database Buffer Cache</a><br>The database buffer cache stores and processes data blocks in the same way whether the IM column store is enabled or disabled. Buffer I/O and buffer pools function the same.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">In-Memory Column Store Architecture</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-2D072622-139C-4617-88ED-F07D530B8E1E" name="GUID-2D072622-139C-4617-88ED-F07D530B8E1E"></a><h4 id="INMEM-GUID-2D072622-139C-4617-88ED-F07D530B8E1E" class="sect4"><span class="enumeration_section">2.1.1 </span>Columnar Data in the In-Memory Area
                  </h4>
                  <div>
                     <p>The <strong class="term">In-Memory Area</strong> is an optional SGA component that contains the IM column store.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09">Size of the In-Memory Area</a><br>The In-Memory Area is controlled by the <code class="codeph">INMEMORY_SIZE</code> initialization parameter. By default, the size of the In-Memory Area is 0, which means the IM column store is disabled.
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8">Memory Pools in the In-Memory Area</a><br>The In-Memory Area is divided into subpools for columnar data and metadata.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E" title="When you enable an IM column store, the SGA manages data in separate locations: the In-Memory Area and the database buffer cache.">Dual-Format: Column and Row</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09" name="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09"></a><h5 id="INMEM-GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09" class="sect5"><span class="enumeration_section">2.1.1.1 </span>Size of the In-Memory Area
                     </h5>
                     <div>
                        <p>The In-Memory Area is controlled by the <code class="codeph">INMEMORY_SIZE</code> initialization parameter. By default, the size of the In-Memory Area is 0, which means the IM column store is disabled.
                        </p>
                        <p>To enable the IM column store, set the In-Memory Area to at least 100 MB. The size is shown in <code class="codeph">V$SGA</code>.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-4C7789E3-082A-4CC4-8C94-D930183EC920">The In-Memory Area and SGA_TARGET</p>
                           <p>The In-Memory Area is subtracted from the <code class="codeph">SGA_TARGET</code> initialization parameter setting. For example, if you set <code class="codeph">SGA_TARGET</code> to 10 GB, and if you set the <code class="codeph">INMEMORY_SIZE</code> to 4 GB, then 40% of the <code class="codeph">SGA_TARGET</code> setting is allocated to the In-Memory Area. The following graphic illustrates the relationship.
                           </p>
                           <div class="figure" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-E78F7C9F-2719-49C1-BC10-B8C2BF0C58ED">
                              <p class="titleinfigure">Figure 2-2 INMEMORY_SIZE and SGA_TARGET</p><img id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__IMAGE_OPT_ZLQ_JHB" src="img/inmem_3v_017.png" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" longdesc="img_text/inmem_3v_017.html"><br><a href="img_text/inmem_3v_017.html">Description of "Figure 2-2 INMEMORY_SIZE and SGA_TARGET"</a></div>
                           <!-- class="figure" -->
                           <p>Unlike the other components of the SGA, including the buffer cache and the shared pool, the In-Memory Area size is not controlled by automatic memory management. The database does not automatically shrink the In-Memory Area when the buffer cache or shared pool requires more memory, or increase the In-Memory Area when it runs out of space.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-2CB4368C-52C6-4DD3-9836-E08424919F3C">Dynamic Resizing of the In-Memory Area</p>
                           <p>Starting in <span>Oracle Database 12c</span> Release 2 (12.2), you can dynamically increase <code class="codeph">INMEMORY_SIZE</code> by using the <code class="codeph">ALTER SYSTEM</code> statement. The database allocates increased memory when the following conditions are met:
                           </p>
                           <ul style="list-style-type: disc;" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_CKG_FMQ_JHB">
                              <li>
                                 <p>Free memory is available in the SGA.</p>
                              </li>
                              <li>
                                 <p>The new size for <code class="codeph">INMEMORY_SIZE</code> is at least 128 MB greater than the current setting.
                                 </p>
                                 <div class="infoboxnote" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-A27A9DCE-E50E-454B-A0A7-3D9D016A6BEE">
                                    <p class="notep1">Note:</p>
                                    <p> You cannot use <code class="codeph">ALTER SYSTEM</code> to reduce <code class="codeph">INMEMORY_SIZE</code>. 
                                    </p>
                                 </div>
                              </li>
                           </ul>
                           <p>The <code class="codeph">V$INMEMORY_AREA</code> and <code class="codeph">V$SGA</code> views immediately reflect the change. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-D2F123B0-1704-4709-877A-BB17A38711D1">The In-Memory Area in a Multitenant Environment</p>
                           <p>In a CDB, the size of the IM column store is set by the <code class="codeph">INMEMORY_SIZE</code> parameter in the CDB root. By default, the IM column store is shared among the PDBs. Consequently, a PDB can "starve" other PDBs by consuming the available memory.
                           </p>
                           <p>Within a PDB, you can limit memory consumption by using <code class="codeph">ALTER SYSTEM SET INMEMORY_SIZE</code>. For example, at the CDB level, you might set <code class="codeph">INMEMORY_SIZE</code> to <code class="codeph">20G</code>, and then configure the PDBs as follows:
                           </p>
                           <ul style="list-style-type: disc;" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_VYM_TNQ_JHB">
                              <li>
                                 <p>In <code class="codeph">hrpdb</code>, set <code class="codeph">INMEMORY_SIZE</code> to <code class="codeph">0</code></p>
                              </li>
                              <li>
                                 <p>In <code class="codeph">salespdb</code>, set <code class="codeph">INMEMORY_SIZE</code> to <code class="codeph">10G</code></p>
                              </li>
                              <li>
                                 <p>In <code class="codeph">oepdb</code>, set <code class="codeph">INMEMORY_SIZE</code> to <code class="codeph">11G</code></p>
                              </li>
                           </ul>
                           <p>In the preceding example, the <code class="codeph">INMEMORY_SIZE</code> settings at the PDB level add up to <code class="codeph">21G</code>, even though <code class="codeph">INMEMORY_SIZE</code> at the CDB level is only <code class="codeph">20G</code>. Oversubscription ensures that valuable space in the IM column store is not wasted if a PDB is shut down or unplugged.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_AKZ_GMQ_JHB">
                              <li>
                                 <p><span class="q">"<a href="enabling-the-im-column-store.html#GUID-48581A2D-1650-410D-8E02-1D8250CCDBED" title="When more memory is required for the IM column store, you can increase its size dynamically.">Increasing the Size of the IM Column Store Dynamically</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-memory.html#GUID-8F54391B-D42A-4FDA-9D12-E1F81FD113EA" target="_blank"><span><cite>Oracle Database Administratorâ€™s Guide</cite></span></a> to learn more about automatic memory management
                                 </p>
                              </li>
                              <li>
                                 <p><span><cite>Oracle Database Reference</cite></span> to learn about <a href="../refrn/INMEMORY_SIZE.html#GUID-B5BEB6BF-5308-485F-920D-CBB584DDDE8F" target="_blank"><code class="codeph">INMEMORY_SIZE</code></a>, <a href="../refrn/V-INMEMORY_AREA.html#GUID-EDC517A6-FF55-4294-B348-032A3FC498EB" target="_blank"><code class="codeph">V$INMEMORY_AREA</code></a>, and <a href="../refrn/V-SGA.html#GUID-4E216A4C-5C7E-43F6-8E2C-CDE442A1CEEC" target="_blank"><code class="codeph">V$SGA</code></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E" title="The In-Memory Area is an optional SGA component that contains the IM column store.">Columnar Data in the In-Memory Area</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8" name="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8"></a><h5 id="INMEM-GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8" class="sect5"><span class="enumeration_section">2.1.1.2 </span>Memory Pools in the In-Memory Area
                     </h5>
                     <div>
                        <p>The In-Memory Area is divided into subpools for columnar data and metadata.</p>
                        <p>The In-Memory area is subdivided into the following subpools:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <a href="glossary.html#GUID-3259010C-D7F2-4AA8-95CB-ED1E3908EA0D"><span class="xrefglossterm">columnar data pool</span></a></p>
                              <p>This subpool stores the IMCUs, which contain the columnar data. The <code class="codeph">V$INMEMORY_AREA.POOL</code> column identifies this subpool as <code class="codeph">1MB POOL</code>, as shown in <a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">Example 2-1</a>.
                              </p>
                           </li>
                           <li>
                              <p>The <a href="glossary.html#GUID-464A0659-4527-4730-A1A8-9D94B0A3B1DE"><span class="xrefglossterm">metadata pool</span></a></p>
                              <p>This subpool stores metadata about the objects that reside in the IM column store. The <code class="codeph">V$INMEMORY_AREA.POOL</code> column identifies this subpool as <code class="codeph">64KB POOL</code>, as shown in <a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">Example 2-1</a>.
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-713DCAE4-82DD-4C0D-901F-52F9985B2257">
                           <p class="titleinfigure">Figure 2-3 Subpools in the In-Memory Area</p><img src="img/cncpt_vm_380.png" alt="Description of Figure 2-3 follows" title="Description of Figure 2-3 follows" longdesc="img_text/cncpt_vm_380.html"><br><a href="img_text/cncpt_vm_380.html">Description of "Figure 2-3 Subpools in the In-Memory Area"</a></div>
                        <!-- class="figure" -->
                        <p>The database determines the relative size of the two subpools using internal heuristics. The database allocates the majority of space in the In-Memory Area to the columnar data pool (1 MB pool).</p>
                        <div class="infoboxnote" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-E350FF1C-FFB6-4C12-80C0-15BDF108517C">
                           <p class="notep1">Note:</p>
                           <p>Oracle Database automatically determines the subpool sizes. You cannot change the space allocations.</p>
                        </div>
                        <div class="example" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">
                           <p class="titleinexample">Example 2-1 V$INMEMORY_AREA View</p>
                           <p>This example queries the <code class="codeph">V$INMEMORY_AREA</code> view to determine the amount of available memory in each subpool (sample output included):
                           </p><pre class="pre codeblock"><code>COL POOL FORMAT a9
COL POPULATE_STATUS FORMAT a15
SSELECT POOL, TRUNC(ALLOC_BYTES/(1024*1024*1024),2) "ALLOC_GB",
        TRUNC(USED_BYTES/(1024*1024*1024),2) "USED_GB",
        POPULATE_STATUS
FROM    V$INMEMORY_AREA;

POOL      ALLOC_GB   USED_GB    POPULATE_STATUS
--------- ---------- ---------- ---------------
1MB POOL  7.99       0          DONE
64KB POOL 1.98       0          DONE</code></pre><p>The current size of the In-Memory area is visible in <code class="codeph">V$SGA</code>:
                           </p><pre class="pre codeblock"><code>SELECT NAME, VALUE/(1024*1024*1024) "SIZE_IN_GB"
FROM   V$SGA 
WHERE  NAME LIKE '%Mem%';

NAME                 SIZE_IN_GB
-------------------- ----------
In-Memory Area       10</code></pre><p>In this example, the memory allocated to the subpools is 9.97 GB, whereas the size of the In-Memory Area is 10 GB. The database uses a small percentage of memory for internal management structures.</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">See Also:</p><a href="../refrn/V-INMEMORY_AREA.html#GUID-EDC517A6-FF55-4294-B348-032A3FC498EB" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about <code class="codeph">V$INMEMORY_AREA</code></div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E" title="The In-Memory Area is an optional SGA component that contains the IM column store.">Columnar Data in the In-Memory Area</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6" name="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6"></a><h4 id="INMEM-GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6" class="sect4"><span class="enumeration_section">2.1.2 </span>Row Data in the Database Buffer Cache
                  </h4>
                  <div>
                     <p>The database buffer cache stores and processes data blocks in the same way whether the IM column store is enabled or disabled. Buffer I/O and buffer pools function the same.</p>
                     <p>The IM column store enables data to be simultaneously populated in the SGA in both the traditional row format (the buffer cache) and the columnar format. The database transparently sends OLTP queries (such as primary key lookups) to the buffer cache, and analytic and reporting queries to the IM column store. When fetching data, Oracle Database can also read data from both memory areas within the same query. </p>
                     <div class="infoboxnote" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__GUID-8B772890-5222-4FCC-848B-C376707C3906">
                        <p class="notep1">Note:</p>
                        <p>In the execution plan, the operation <code class="codeph">TABLE ACCESS IN MEMORY FULL</code> indicates that some or all data is accessed in the IM column store.
                        </p>
                     </div>
                     <p>The dual-format architecture does not double memory requirements. The buffer cache is optimized to run with a much smaller size than the size of the database.</p>
                     <p>The following figure shows a sample IM column store. The database stores the <code class="codeph">sh.sales</code> table on disk in traditional row format. The SGA stores the data in columnar format in the IM column store, and in row format in the database buffer cache.
                     </p>
                     <div class="figure" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__BGBEFJBH">
                        <p class="titleinfigure">Figure 2-4 IM Column Store</p><img src="img/cncpt_vm_379.png" width="540" alt="Description of Figure 2-4 follows" title="Description of Figure 2-4 follows" longdesc="img_text/cncpt_vm_379.html"><br><a href="img_text/cncpt_vm_379.html">Description of "Figure 2-4 IM Column Store"</a></div>
                     <!-- class="figure" -->
                     <p>Every on-disk data format for permanent, heap-organized tables is supported by the IM column store. The columnar format does not affect the format of data stored in data files or in the buffer cache, nor does it affect undo data and online redo logging.</p>
                     <p>The database processes DML modifications in the same way, regardless of whether the IM column store is enabled, by updating the buffer cache, online redo log, and undo tablespace. However, the database uses an internal mechanism to track changes and ensure that the IM column store is consistent with the rest of the database. For example, if the <code class="codeph">sales</code> table is populated in the IM column store, and if an application updates a row in <code class="codeph">sales</code>, then the database automatically keeps the copy of the <code class="codeph">sales</code> table in the IM column store transactionally consistent. A query that accesses the IM column store always returns the same results for a query that accesses the buffer cache.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__GUID-39A46614-F669-4EF9-B92D-82CC4B56AC94">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-4FF66585-E469-4631-9225-29D75594CD14" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn more about the database buffer cache
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E" title="When you enable an IM column store, the SGA manages data in separate locations: the In-Memory Area and the database buffer cache.">Dual-Format: Column and Row</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" name="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1"></a><h3 id="INMEM-GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" class="sect3"><span class="enumeration_section">2.2 </span>In-Memory Storage Units
               </h3>
               <div>
                  <p>The IM column store manages both data and metadata in optimized storage units, not in traditional Oracle data blocks. </p>
                  <p>Oracle Database maintains the storage units in the In-Memory Area. The following graphic gives an overview of the In-Memory Area and the database processes that interact with it. The remaining chapter describes the various memory components.</p>
                  <div class="figure" id="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1__GUID-FDB37040-B670-4D1E-96D0-9357E9117F95">
                     <p class="titleinfigure">Figure 2-5 IM Column Store: Memory and Process Architecture</p><img src="img/inmem_3v_013.png" alt="Description of Figure 2-5 follows" title="Description of Figure 2-5 follows" longdesc="img_text/inmem_3v_013.html"><br><a href="img_text/inmem_3v_013.html">Description of "Figure 2-5 IM Column Store: Memory and Process Architecture"</a></div>
                  <!-- class="figure" -->
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE">In-Memory Compression Units (IMCUs)</a><br>An <strong class="term">In-Memory Compression Unit (IMCU)</strong> is a compressed, read-only storage unit that contains data for one or more columns. 
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2">Snapshot Metadata Units (SMUs)</a><br>A Snapshot Metadata Unit (SMU) contains metadata and transactional information for an associated IMCU. 
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-E1A74436-E719-4FC3-A141-41B160792E51">In-Memory Expression Units (IMEUs)</a><br>An <span class="bold">In-Memory Expression Unit</span> (IMEU) is a storage container for materialized <span class="bold">In-Memory Expressions</span> (IM expressions) and user-defined virtual columns.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">In-Memory Column Store Architecture</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" name="GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE"></a><h4 id="INMEM-GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" class="sect4"><span class="enumeration_section">2.2.1 </span>In-Memory Compression Units (IMCUs)
                  </h4>
                  <div>
                     <p>An <strong class="term">In-Memory Compression Unit (IMCU)</strong> is a compressed, read-only storage unit that contains data for one or more columns. 
                     </p>
                     <p>An IMCU is analogous to a tablespace extent. An IMCU has two parts: a set of Column Compression Units (CUs), and a header that contains metadata such as the <a href="glossary.html#GUID-B9859425-36BD-40B7-9F9D-FA52CD215B69"><span class="xrefglossterm">IM storage index</span></a>.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8">IMCUs and Schema Objects</a><br>The IM column store stores data for a single object (table, partition, materialized view) in a set of IMCUs. An IMCU stores columnar data for one and only one object.
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7">Column Compression Units (CUs)</a><br>A <span class="bold">Column Compression Unit (CU)</span> is contiguous storage for a single column in an IMCU. Every IMCU has one or more CUs. 
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-A38FF2B6-506E-412A-9FE5-1CE709556379">In-Memory Storage Indexes</a><br>Every IMCU header automatically creates and manages <span class="bold">In-Memory Storage Indexes</span> (IM storage indexes) for its CUs. An IM storage index stores the minimum and maximum for all columns within the IMCU.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="The IM column store manages both data and metadata in optimized storage units, not in traditional Oracle data blocks.">In-Memory Storage Units</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" name="GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8"></a><h5 id="INMEM-GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" class="sect5"><span class="enumeration_section">2.2.1.1 </span>IMCUs and Schema Objects
                     </h5>
                     <div>
                        <p>The IM column store stores data for a single object (table, partition, materialized view) in a set of IMCUs. An IMCU stores columnar data for one and only one object.</p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41">IMCUs and INMEMORY Columns</a><br>For an object specified as <code class="codeph">INMEMORY</code>, every column listed in the <code class="codeph">INMEMORY</code> clause is included in every IMCU.
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED">In-Memory Compression</a><br>The IM column store uses special compression formats optimized for access speed rather than storage reduction. The columnar format enables queries to execute directly against the compressed columns.
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F">IMCUs and Rows</a><br>Each IMCU contains all column values (including nulls) for a subset of rows in a table segment. A subset of rows is called a <span class="italic">granule</span>. 
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="An In-Memory Compression Unit (IMCU) is a compressed, read-only storage unit that contains data for one or more columns.">In-Memory Compression Units (IMCUs)</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41" name="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41"></a><h6 id="INMEM-GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41" class="sect6"><span class="enumeration_section">2.2.1.1.1 </span>IMCUs and INMEMORY Columns
                        </h6>
                        <div>
                           <p>For an object specified as <code class="codeph">INMEMORY</code>, every column listed in the <code class="codeph">INMEMORY</code> clause is included in every IMCU.
                           </p>
                           <p>For example, the <code class="codeph">sh.sales</code> table has 7 columns. The following DDL statement specifies the table as <code class="codeph">INMEMORY</code>, which means that every IMCU for <code class="codeph">sales</code> includes columnar data for these 7 columns:
                           </p><pre class="pre codeblock"><code>ALTER TABLE sh.sales INMEMORY MEMCOMPRESS FOR QUERY LOW;</code></pre><div class="section">
                              <p class="subhead3" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-6A346F9B-6E35-4064-8211-D0E68DFF685D">NO INMEMORY Columns in INMEMORY Objects</p>
                              <p>You can specify that some but not all columns in an <code class="codeph">INMEMORY</code> table have the <code class="codeph">INMEMORY</code> attribute. For example, the <code class="codeph">sh.customers</code> table has 23 columns. The following DDL statement specifies that 15 columns in <code class="codeph">sh.customers</code> have the <code class="codeph">NO INMEMORY</code> attribute, which means that the other 8 columns in the table have the <code class="codeph">INMEMORY</code> attribute:
                              </p><pre class="pre codeblock"><code>ALTER TABLE sh.customers INMEMORY 
  MEMCOMPRESS FOR QUERY LOW
  NO INMEMORY ( cust_gender, cust_year_of_birth, cust_marital_status,
                cust_postal_code, cust_city, cust_state_province,
                cust_main_phone_number, cust_income_level, cust_credit_limit,
                cust_email, cust_total, cust_total_id, cust_eff_from,
                cust_eff_to, cust_valid );</code></pre><p>The following query shows the compression levels of the columns in <code class="codeph">sh.customers</code>, indicating which columns are <code class="codeph">NO INMEMORY</code>:
                              </p><pre class="pre codeblock"><code>SET LINESIZE 200
COL TABLE_NAME FORMAT a25
COL SEG_COL_ID FORMAT 999
COL COLUMN_NAME FORMAT a25
COL INMEMORY_COMPRESSION FORMAT a11
SELECT SEGMENT_COLUMN_ID AS "SEG_COL_ID", COLUMN_NAME, INMEMORY_COMPRESSION 
FROM   V$IM_COLUMN_LEVEL WHERE TABLE_NAME = 'CUSTOMERS'
ORDER BY SEG_COL_ID;

SEG_COL_ID COLUMN_NAME               INMEMORY_CO
---------- ------------------------- -----------
         1 CUST_ID                   DEFAULT
         2 CUST_FIRST_NAME           DEFAULT
         3 CUST_LAST_NAME            DEFAULT
         4 CUST_GENDER               NO INMEMORY
         5 CUST_YEAR_OF_BIRTH        NO INMEMORY
         6 CUST_MARITAL_STATUS       NO INMEMORY
         7 CUST_STREET_ADDRESS       DEFAULT
         8 CUST_POSTAL_CODE          NO INMEMORY
         9 CUST_CITY                 NO INMEMORY
        10 CUST_CITY_ID              DEFAULT
        11 CUST_STATE_PROVINCE       NO INMEMORY
        12 CUST_STATE_PROVINCE_ID    DEFAULT
        13 COUNTRY_ID                DEFAULT
        14 CUST_MAIN_PHONE_NUMBER    NO INMEMORY
        15 CUST_INCOME_LEVEL         NO INMEMORY
        16 CUST_CREDIT_LIMIT         NO INMEMORY
        17 CUST_EMAIL                NO INMEMORY
        18 CUST_TOTAL                NO INMEMORY
        19 CUST_TOTAL_ID             NO INMEMORY
        20 CUST_SRC_ID               DEFAULT
        21 CUST_EFF_FROM             NO INMEMORY
        22 CUST_EFF_TO               NO INMEMORY
        23 CUST_VALID                NO INMEMORY</code></pre><p>The following graphic represents three tables from the <code class="codeph">sh</code> schema populated in the IM column store: <code class="codeph">customers</code>, <code class="codeph">products</code>, and <code class="codeph">sales</code>. In this example, each table has a different number of columns specified <code class="codeph">INMEMORY</code>. The IMCUs for each table include only data for the <code class="codeph">INMEMORY</code> columns.
                              </p>
                              <div class="figure" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__BGBJCAIB">
                                 <p class="titleinfigure">Figure 2-6 Columns and IMCUs</p><img id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__IMAGE_W4T_MS4_LHB" src="img/cncpt_vm_378.png" alt="Description of Figure 2-6 follows" title="Description of Figure 2-6 follows" longdesc="img_text/cncpt_vm_378.html"><br><a href="img_text/cncpt_vm_378.html">Description of "Figure 2-6 Columns and IMCUs"</a></div>
                              <!-- class="figure" -->
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-1B5444AC-CD3B-4782-A673-BD5564033FC8">Queries That Reference NO INMEMORY Columns</p>
                              <p>When a query references a <code class="codeph">NO INMEMORY</code> column, the table scan retrieves data from the row store rather than the IMCUs in the IM column store. Row store access occurs even if all other columns referenced in the query are populated <code class="codeph">INMEMORY</code> columns.
                              </p>
                              <p>For example, assume that the <code class="codeph">customers</code> table is populated into the IM column store. The <code class="codeph">cust_id</code> and <code class="codeph">cust_last_name</code> columns are specified <code class="codeph">INMEMORY</code>, but the <code class="codeph">cust_postal_code</code> column is specified as <code class="codeph">NO INMEMORY</code>. You issue the following query:
                              </p><pre class="pre codeblock"><code>SELECT cust_id, cust_last_name, cust_postal_code 
FROM   customers 
WHERE  cust_id &lt; 5001
ORDER BY cust_id;</code></pre><p>In this case, the database accesses the row store, not the IM column store, even though <code class="codeph">cust_postal_code</code> is the only <code class="codeph">NO INMEMORY</code> column referenced in the query. The following query, which has <code class="codeph">cust_postal_code</code> in the predicate but not the <code class="codeph">SELECT</code> list, must also access the row store: 
                              </p><pre class="pre codeblock"><code>SELECT cust_id, cust_last_name 
FROM   customers 
WHERE  cust_postal_code = 77501
ORDER BY cust_id;</code></pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-78C230E9-D084-4D55-81E8-BF318D242D71">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__UL_ACJ_2V4_LHB">
                                 <li>
                                    <p><span class="q">"<a href="populating-objects-in-memory.html#GUID-C0BC34D3-2BD8-41A5-B2F0-9AB109C1B617" title="For internal tables, both In-Memory virtual columns (IM virtual columns) and nonvirtual columns are eligible for IM population. For external tables, only nonvirtual columns are eligible.">About Enabling INMEMORY Columns</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="https://blogs.oracle.com/in-memory/what-happens-if-a-column-is-not-populated" target="_blank">https://blogs.oracle.com/in-memory/what-happens-if-a-column-is-not-populated</a> for a blog entry on accessing columns that are not populated in the IM column store
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/ALTER-TABLE.html#GUID-552E7373-BF93-477D-9DA3-B2C9386F2877" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">ALTER TABLE</code> statement
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="The IM column store stores data for a single object (table, partition, materialized view) in a set of IMCUs. An IMCU stores columnar data for one and only one object.">IMCUs and Schema Objects</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED" name="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED"></a><h6 id="INMEM-GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED" class="sect6"><span class="enumeration_section">2.2.1.1.2 </span>In-Memory Compression
                        </h6>
                        <div>
                           <p>The IM column store uses special compression formats optimized for access speed rather than storage reduction. The columnar format enables queries to execute directly against the compressed columns.</p>
                           <p>Compression enables scanning and filtering operations to process a much smaller amount of data, which optimizes query performance. Oracle Database only decompresses data when it is required for the result set.</p>
                           <p>The compression applied in the IM column store is closely related to Hybrid Columnar Compression. Both technologies process column vectors. The primary difference is that the column vectors for the IM column store are optimized for SIMD vector processing, whereas the column vectors for Hybrid Columnar Compression are optimized for disk storage.</p>
                           <p>When you enable an object for population into the IM column store, you specify the type of compression in the <code class="codeph">INMEMORY</code> clause: <code class="codeph">FOR DML</code>, <code class="codeph">FOR QUERY</code> (<code class="codeph">LOW</code> or <code class="codeph">HIGH</code>), <code class="codeph">FOR CAPACITY</code> (<code class="codeph">LOW</code> or <code class="codeph">HIGH</code>), or <code class="codeph">NONE</code>.
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED__GUID-78432B01-CDB7-4B10-BE07-E5090D01273C">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="populating-objects-in-memory.html#GUID-B50145A4-3A97-48DD-8AA3-7E239E926261" title="Use the INMEMORY clause in DDL statements to specify which objects are eligible for population into the IM column store. You can enable tablespaces, tables (internal and external), partitions, and materialized views.">Controls for In-Memory Population</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../cncpt/tables-and-table-clusters.html#GUID-901A054B-B47F-4ADF-A57B-2074EBB85341" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn more about Hybrid Columnar Compression
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="The IM column store stores data for a single object (table, partition, materialized view) in a set of IMCUs. An IMCU stores columnar data for one and only one object.">IMCUs and Schema Objects</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F" name="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F"></a><h6 id="INMEM-GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F" class="sect6"><span class="enumeration_section">2.2.1.1.3 </span>IMCUs and Rows
                        </h6>
                        <div>
                           <p>Each IMCU contains all column values (including nulls) for a subset of rows in a table segment. A subset of rows is called a <span class="italic">granule</span>. 
                           </p>
                           <p>All IMCUs for a given segment contain approximately the same number of rows. Oracle Database determines the size of a granule automatically depending on data type, data format, and compression type. A higher compression level results in more rows in the IMCU.</p>
                           <p>A one-to-many mapping exists between an IMCU and a set of database blocks. As illustrated in <a href="in-memory-column-store-architecture.html#GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F__GUID-C6CBB52C-9E9C-42BB-9C91-1BD37B73254D">Example 2-2</a>, each IMCU stores the values for columns for a different set of blocks.
                           </p>
                           <p>The columns in an IMCU are not sorted. Oracle Database populates them in the order that they are read from disk.</p>
                           <p>The number of rows in an IMCU dictates the amount of space an IMCU consumes. If the target number of rows causes an IMCU to grow beyond the amount of contiguous 1 MB extents available in the 1 MB pool, then the IMCU creates additional extents (pieces) to hold the remaining column CUs. An IMCU always allocates space in 1 MB increments.</p>
                           <div class="example" id="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F__GUID-C6CBB52C-9E9C-42BB-9C91-1BD37B73254D">
                              <p class="titleinexample">Example 2-2 IMCUs and Row Subsets</p>
                              <p>In this simplified example, only the following 4 columns of the <code class="codeph">customers</code> table have the <code class="codeph">INMEMORY</code> attribute: <code class="codeph">cust_id</code>, <code class="codeph">cust_first_name</code>, <code class="codeph">cust_last_name</code>, and <code class="codeph">cust_gender</code>. Only 5 rows exist in the table, stored in 2 data blocks. Conceptually, the first data block stores its rows as follows:
                              </p><pre class="pre codeblock"><code>82,Madeline,Li,F;37004,Abel,Embrey,M;1714,Hardy,Gentle,M</code></pre><p>The second data block stores rows as follows:</p><pre class="pre codeblock"><code>100439,Uma,Campbell,F;3047,Lucia,Downey,F</code></pre><p>Assume IMCU 1 stores the data for the first data block. In this case, the <code class="codeph">cust_id</code> column values for the 3 rows in this data block stores are stored â€œverticallyâ€ within a CU as follows:
                              </p><pre class="pre codeblock"><code>82
37004
1714</code></pre><p>IMCU 2 stores the data from the second data block. The <code class="codeph">cust_id</code> column values for these 2 rows are stored within a CU as follows:
                              </p><pre class="pre codeblock"><code>100439
3047</code></pre><p>Because the <code class="codeph">cust_id</code> value is the first value for each row in the data block, the <code class="codeph">cust_id</code> column is in the first position within the IMCU. Columns always occupy the same position, so Oracle Database can reconstruct the rows by reading the IMCUs for a segment.
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>Related Topics</strong></p>
                              <ul>
                                 <li><a href="populating-objects-in-memory.html#GUID-B50145A4-3A97-48DD-8AA3-7E239E926261" title="Use the INMEMORY clause in DDL statements to specify which objects are eligible for population into the IM column store. You can enable tablespaces, tables (internal and external), partitions, and materialized views.">Controls for In-Memory Population</a></li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="The IM column store stores data for a single object (table, partition, materialized view) in a set of IMCUs. An IMCU stores columnar data for one and only one object.">IMCUs and Schema Objects</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" name="GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7"></a><h5 id="INMEM-GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" class="sect5"><span class="enumeration_section">2.2.1.2 </span>Column Compression Units (CUs)
                     </h5>
                     <div>
                        <p>A <span class="bold">Column Compression Unit (CU)</span> is contiguous storage for a single column in an IMCU. Every IMCU has one or more CUs. 
                        </p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E">Structure of a CU</a><br>A CU is divided into a body and a header.
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB">Local Dictionary</a><br>In a CU, the local dictionary has a list of distinct values and their corresponding dictionary codes.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="An In-Memory Compression Unit (IMCU) is a compressed, read-only storage unit that contains data for one or more columns.">In-Memory Compression Units (IMCUs)</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E" name="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E"></a><h6 id="INMEM-GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E" class="sect6"><span class="enumeration_section">2.2.1.2.1 </span>Structure of a CU
                        </h6>
                        <div>
                           <p>A CU is divided into a body and a header.</p>
                           <p>The body of every CU stores the column values for the range of rows included in the IMCU. The header contains metadata about the values stored in the CU body, for example, the minimum and maximum value within the CU. It may also contain a <a href="glossary.html#GUID-10ECFDBB-1835-4634-B1E6-5E156614B6DE"><span class="xrefglossterm">local dictionary</span></a>, which is a sorted list of the distinct values in that column and their corresponding dictionary codes.
                           </p>
                           <p>The following figure shows an IMCU with 4 CUs for the <code class="codeph">sales</code> table: <code class="codeph">prod_id</code>, <code class="codeph">cust_id</code>, <code class="codeph">time_id</code>, and <code class="codeph">channel_id</code>. Each CU stores the column values for the range of rows included in the IMCU.
                           </p>
                           <div class="figure" id="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E__GUID-ACC3BC93-A2D6-44CF-BCF7-F5996EED03A8">
                              <p class="titleinfigure">Figure 2-7 CUs in an IMCU</p><img src="img/inmem_3v_007.png" alt="Description of Figure 2-7 follows" title="Description of Figure 2-7 follows" longdesc="img_text/inmem_3v_007.html"><br><a href="img_text/inmem_3v_007.html">Description of "Figure 2-7 CUs in an IMCU"</a></div>
                           <!-- class="figure" -->
                           <p>The CUs store values in rowid order. For this reason, the database can answer queries by â€œstitchingâ€ the rows back together. For example, an application issues the following query:</p><pre class="pre codeblock"><code>SELECT cust_id, time_id, channel_id
FROM   sales
WHERE  prod_id =5;</code></pre><p>The database begins by scanning the <code class="codeph">prod_id</code> column for entries with the value <code class="codeph">5</code>. Assume that the database finds <code class="codeph">5</code> in position two in the <code class="codeph">prod_id</code> column. The database now must find the corresponding <code class="codeph">cust_id</code>, <code class="codeph">time_id</code>, and <code class="codeph">channel_id</code> for this row. Because the CUs store data in rowid order, the database can find the corresponding <code class="codeph">cust_id</code>, <code class="codeph">time_id</code>, and <code class="codeph">channel_id</code> values in position 2 in those columns. Thus, to answer the query, the database must extract the values from position 2 in the <code class="codeph">cust_id</code>, <code class="codeph">time_id</code>, and <code class="codeph">channel_id</code> columns, and then stitch the row back together to return it to the end user.
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" title="A Column Compression Unit (CU) is contiguous storage for a single column in an IMCU. Every IMCU has one or more CUs.">Column Compression Units (CUs)</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB" name="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB"></a><h6 id="INMEM-GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB" class="sect6"><span class="enumeration_section">2.2.1.2.2 </span>Local Dictionary
                        </h6>
                        <div>
                           <p>In a CU, the local dictionary has a list of distinct values and their corresponding dictionary codes.</p>
                           <p>The local dictionary stores the symbol contained in the column. The following figure illustrates how a CU stores a <code class="codeph">name</code> column in a <code class="codeph">vehicles</code> table.
                           </p>
                           <div class="figure" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-D5FF2EE9-ED35-4F2C-858F-356CDBD2429D">
                              <p class="titleinfigure">Figure 2-8 Local Dictionary</p><img src="img/inmem_3v_006.png" alt="Description of Figure 2-8 follows" title="Description of Figure 2-8 follows" longdesc="img_text/inmem_3v_006.html"><br><a href="img_text/inmem_3v_006.html">Description of "Figure 2-8 Local Dictionary"</a></div>
                           <!-- class="figure" -->
                           <p>In the preceding figure, the CU contains only 7 rows. Every distinct value in this CU, such as <code class="codeph">Cadillac</code> or <code class="codeph">Audi</code>, is assigned a different dictionary code, such as <code class="codeph">2</code>  for <code class="codeph">Cadillac</code> and <code class="codeph">0</code> for <code class="codeph">Audi</code>. The CU stores the dictionary code rather than the original value.
                           </p>
                           <div class="infoboxnote" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-BA81A5E1-BFA7-4247-891F-E3DD21F980C3">
                              <p class="notep1">Note:</p>
                              <p>When the database uses a <a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">common dictionary</span></a> for a <a href="glossary.html#GUID-0DCA9B69-43D8-4940-9CC0-8753061F27CA"><span class="xrefglossterm">join group</span></a>, the local dictionary contains <span class="italic">references</span> to the common dictionary rather than the <span class="italic">symbols</span>. For example, rather than storing the values <code class="codeph">Audi</code>, <code class="codeph">BWM</code>, and <code class="codeph">Cadillac</code> for the <code class="codeph">vehicles.name</code> column, the local dictionary stores dictionary codes such as <code class="codeph">101</code>, <code class="codeph">220</code>, and <code class="codeph">66</code>.
                              </p>
                           </div>
                           <p>The CU header contains the minimum and maximum values for the column. In this example, the minimum value is <code class="codeph">Audi</code> and the maximum value is <code class="codeph">Cadillac</code>. The local dictionary stores the list of distinct values: <code class="codeph">Audi</code>, <code class="codeph">BMW</code>, and <code class="codeph">Cadillac</code>. Their corresponding dictionary codes (<code class="codeph">0</code>, <code class="codeph">1</code>, and <code class="codeph">2</code>) are implicit. The local dictionary for a CU in each IMCU is independent of the local dictionaries in other IMCUs.
                           </p>
                           <p>If a query filters on Audi automobiles, then the database scans this IMCU for only <code class="codeph">0</code> codes.
                           </p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>Related Topics</strong></p>
                              <ul>
                                 <li><a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793" title="A common dictionary is a table-level, instance-specific set of dictionary codes.">How a Join Group Uses a Common Dictionary</a></li>
                              </ul>
                           </div>
                           <div class="infoboxnotealso" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-8A82B6DF-69A5-47DF-AA1A-3825D2F78035">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793" title="A common dictionary is a table-level, instance-specific set of dictionary codes.">How a Join Group Uses a Common Dictionary</a>"</span></p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" title="A Column Compression Unit (CU) is contiguous storage for a single column in an IMCU. Every IMCU has one or more CUs.">Column Compression Units (CUs)</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379" name="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379"></a><h5 id="INMEM-GUID-A38FF2B6-506E-412A-9FE5-1CE709556379" class="sect5"><span class="enumeration_section">2.2.1.3 </span>In-Memory Storage Indexes
                     </h5>
                     <div>
                        <p>Every IMCU header automatically creates and manages <span class="bold">In-Memory Storage Indexes</span> (IM storage indexes) for its CUs. An IM storage index stores the minimum and maximum for all columns within the IMCU.
                        </p>
                        <p>For example, <code class="codeph">sales</code> is populated in the IM column store. Every IMCU for this table has all columns. The <code class="codeph">sales.prod_id</code> column is stored in a separate CU within every IMCU. The IMCU header has the minimum and maximum values of each <code class="codeph">prod_id</code> CU (and every other CU).
                        </p>
                        <p>To eliminate unnecessary scans, the database can perform <a href="glossary.html#GUID-824EDD0E-2FF3-411E-A2B2-C7B542EADFDC"><span class="xrefglossterm">IMCU pruning</span></a> based on SQL filter predicates. The database scans only the IMCUs that satisfy the query predicate, as shown in the <code class="codeph">WHERE prod_id &gt; 14 AND prod_id &lt; 29</code> example in the following graphic.
                        </p>
                        <div class="figure" id="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379__BGBGBJJB">
                           <p class="titleinfigure">Figure 2-9 Storage Index for Columnar Data</p><img src="img/inmem_3v_016.png" alt="Description of Figure 2-9 follows" title="Description of Figure 2-9 follows" longdesc="img_text/inmem_3v_016.html"><br><a href="img_text/inmem_3v_016.html">Description of "Figure 2-9 Storage Index for Columnar Data"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="An In-Memory Compression Unit (IMCU) is a compressed, read-only storage unit that contains data for one or more columns.">In-Memory Compression Units (IMCUs)</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" name="GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2"></a><h4 id="INMEM-GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" class="sect4"><span class="enumeration_section">2.2.2 </span>Snapshot Metadata Units (SMUs)
                  </h4>
                  <div>
                     <p>A Snapshot Metadata Unit (SMU) contains metadata and transactional information for an associated IMCU. </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF">IMCUs and SMUs</a><br>The columnar pool of the In-Memory Area stores the actual data: IMCUs and IMEUs. The metadata pool in the In-Memory Area stores the SMUs.
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1">Transaction Journal</a><br>Every SMU contains a <span class="bold">transaction journal</span>. The database uses the transaction journal to keep the IMCU transactionally consistent.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="The IM column store manages both data and metadata in optimized storage units, not in traditional Oracle data blocks.">In-Memory Storage Units</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF" name="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF"></a><h5 id="INMEM-GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF" class="sect5"><span class="enumeration_section">2.2.2.1 </span>IMCUs and SMUs
                     </h5>
                     <div>
                        <p>The columnar pool of the In-Memory Area stores the actual data: IMCUs and IMEUs. The metadata pool in the In-Memory Area stores the SMUs.</p>
                        <div class="figure" id="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF__GUID-AC063DFD-ADC3-42BF-A971-A86F7C4812DF">
                           <p class="titleinfigure">Figure 2-10 IMCUs and SMUs</p>
                           <p>This figure shows IMCUs in the data pool, and SMUs in the metadata pool.</p><img src="img/inmem_3v_014.png" alt="Description of Figure 2-10 follows" title="Description of Figure 2-10 follows" longdesc="img_text/inmem_3v_014.html"><br><a href="img_text/inmem_3v_014.html">Description of "Figure 2-10 IMCUs and SMUs"</a></div>
                        <!-- class="figure" -->
                        <p>Every IMCU maps to a separate SMU. Thus, if the columnar data pool contains 100 IMCUs, then the metadata pool contains 100 SMUs. The SMUs store several types of metadata for their associated IMCUs, including the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Object numbers</p>
                           </li>
                           <li>
                              <p>Column numbers</p>
                           </li>
                           <li>
                              <p>Mapping information for rows</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" title="A Snapshot Metadata Unit (SMU) contains metadata and transactional information for an associated IMCU.">Snapshot Metadata Units (SMUs)</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" name="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1"></a><h5 id="INMEM-GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" class="sect5"><span class="enumeration_section">2.2.2.2 </span>Transaction Journal
                     </h5>
                     <div>
                        <p>Every SMU contains a <span class="bold">transaction journal</span>. The database uses the transaction journal to keep the IMCU transactionally consistent.
                        </p>
                        <p>The database uses the buffer cache to process DML, just as when the IM column store is not enabled. For example, an <code class="codeph">UPDATE</code> statement might modify a row in an IMCU. In this case, the database adds the rowid for the modified row to the transaction journal and marks it stale as of the SCN of the DML statement. If a query needs to access the new version of the row, then the database obtains the row from the database buffer cache.
                        </p>
                        <div class="figure" id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1__GUID-FA73343D-ED4F-4C7A-80B2-57DC5D14651C">
                           <p class="titleinfigure">Figure 2-11 Transaction Journal</p><img src="img/inmem_3v_020.png" alt="Description of Figure 2-11 follows" title="Description of Figure 2-11 follows" longdesc="img_text/inmem_3v_020.html"><br><a href="img_text/inmem_3v_020.html">Description of "Figure 2-11 Transaction Journal"</a></div>
                        <!-- class="figure" -->
                        <p>The database achieves read consistency by merging the contents of the column, transaction journal, and buffer cache. When the IMCU is refreshed during <a href="glossary.html#GUID-9168517C-C8A2-4433-946A-037631B840E2"><span class="xrefglossterm">repopulation</span></a>, queries can access the up-to-date row directly from the IMCU.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1__GUID-78FCBDF5-0498-4504-A82C-1ED36BAA1A05">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="The IM column store periodically refreshes objects that have been modified. You can control this behavior using initialization parameters and the DBMS_INMEMORY package.">Optimizing Repopulation of the IM Column Store</a>"</span> for an in-depth discussion of how the IM column store maintains transactional consistency
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" title="A Snapshot Metadata Unit (SMU) contains metadata and transactional information for an associated IMCU.">Snapshot Metadata Units (SMUs)</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E1A74436-E719-4FC3-A141-41B160792E51" name="GUID-E1A74436-E719-4FC3-A141-41B160792E51"></a><h4 id="INMEM-GUID-E1A74436-E719-4FC3-A141-41B160792E51" class="sect4"><span class="enumeration_section">2.2.3 </span>In-Memory Expression Units (IMEUs)
                  </h4>
                  <div>
                     <p>An <span class="bold">In-Memory Expression Unit</span> (IMEU) is a storage container for materialized <span class="bold">In-Memory Expressions</span> (IM expressions) and user-defined virtual columns.
                     </p>
                     <p>The database treats materialized expressions just like other columns in the IMCU. Conceptually, an IMEU is a logical extension of its parent IMCU. Just as an IMCU can contain multiple columns, an IMEU can contain multiple virtual columns.</p>
                     <p>Every IMEU maps to exactly one IMCU, mapping to the same row set. The IMEU contains expression results for the data contained in its associated IMCU. When the IMCU is populated, the associated IMEU is also populated.</p>
                     <p>A typical IM expression involves one or more columns, possibly with constants, and has a one-to-one mapping with the rows in the table. For example, an IMCU for an <code class="codeph">employees</code> table contains rows 1&#x2013;1000 for the column <code class="codeph">weekly_salary</code>. For the rows stored in this IMCU, the IMEU calculates the automatically detected IM expression <code class="codeph">weekly_salary*52</code>, and the user-defined virtual column <code class="codeph">quarterly_salary</code> defined as <code class="codeph">weekly_salary*12</code>. The 3rd row down in the IMCU maps to the 3rd row down in the IMEU.
                     </p>
                     <p>The IMEU is a logical extension of the IMCUs of a particular segment. By default, the IMEU inherits the <code class="codeph">INMEMORY</code> clause properties, including Oracle Real Application Clusters (Oracle RAC) properties such as <code class="codeph">DISTRIBUTE</code> and <code class="codeph">DUPLICATE</code>, from the base segment. You can selectively enable or disable virtual columns for storage in IMEUs. You can also specify compression levels for different columns.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="populating-objects-in-memory.html#GUID-C0BC34D3-2BD8-41A5-B2F0-9AB109C1B617" title="For internal tables, both In-Memory virtual columns (IM virtual columns) and nonvirtual columns are eligible for IM population. For external tables, only nonvirtual columns are eligible.">About Enabling INMEMORY Columns</a></li>
                           <li><a href="views-related-to-im-column-store.html#GUID-2EBF8D9B-FA9E-4D67-8934-5908E6018D4E" title="This topic describes data dictionary and dynamic performance views related to the In-Memory Column Store (IM column store).">In-Memory Views</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="The IM column store manages both data and metadata in optimized storage units, not in traditional Oracle data blocks.">In-Memory Storage Units</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757" name="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757"></a><h3 id="INMEM-GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757" class="sect3"><span class="enumeration_section">2.3 </span>Expression Statistics Store (ESS)
               </h3>
               <div>
                  <p>The <strong class="term">Expression Statistics Store (ESS)</strong> is a repository maintained by the optimizer to store statistics about expression evaluation. The ESS resides in the SGA and persists on disk.
                  </p>
                  <p>When an IM column store is enabled, the database leverages the ESS for its In-Memory Expressions (IM expressions) feature. However, the ESS is independent of the IM column store. The ESS is a permanent component of the database and cannot be disabled.</p>
                  <p>The database uses the ESS to determine whether an expression is â€œhotâ€ (frequently accessed), and thus a candidate for an IM expression. During a hard parse of a query, the ESS looks for active expressions in the <code class="codeph">SELECT</code> list, <code class="codeph">WHERE</code> clause, <code class="codeph">GROUP BY</code> clause, and so on.
                  </p>
                  <p>For each segment, the ESS maintains expression statistics such as the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Frequency of execution</p>
                     </li>
                     <li>
                        <p>Cost of evaluation</p>
                     </li>
                     <li>
                        <p>Timestamp evaluation</p>
                     </li>
                  </ul>
                  <p>The optimizer assigns each expression a weighted score based on cost and the number of times it was evaluated. The values are approximate rather than exact. More active expressions have higher scores. The ESS maintains an internal list of the most frequently accessed expressions.</p>
                  <p>Control the behavior of IM expressions using the <code class="codeph">DBMS_INMEMORY_ADMIN</code> package. For example, the <code class="codeph">IME_CAPTURE_EXPRESSIONS</code> procedure prompts the database to identify and gradually populate the hottest expressions in the database. The <code class="codeph">IME_POPULATE_EXPRESSIONS</code> procedure forces the database to populate the expressions immediately.
                  </p>
                  <p>ESS information is stored in the data dictionary and exposed in the <code class="codeph">DBA_EXPRESSION_STATISTICS</code> view. This view shows the metadata that the optimizer has collected in the ESS. IM expressions are exposed as system-generated virtual columns, prefixed by the string <code class="codeph">SYS_IME</code>, in the <code class="codeph">DBA_IM_EXPRESSIONS</code> view.
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757__GUID-32526C6F-6AA1-4856-A80B-A2B1ED9DB9CA">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="optimizing-in-memory-expressions.html#GUID-1B849DAF-277E-4B09-8275-367592115B06" title="By default, the DBMS_INMEMORY_ADMIN.IME_CAPTURE_EXPRESSIONS procedure identifies and populates â€œhotâ€ expressions, called In-Memory Expressions (IM expressions).">About IM Expressions</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="../tgsql/query-optimizer-concepts.html#GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> to learn more about ESS
                           </p>
                        </li>
                        <li>
                           <p><a href="../refrn/DBA_EXPRESSION_STATISTICS.html#GUID-9617514D-FFED-4B5D-B8C7-FB08FCB9CC91" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about the <code class="codeph">DBA_EXPRESSION_STATISTICS</code> view
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-398720DF-7D8D-4418-B395-5F7C5FC85BC5" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn more about the <code class="codeph">DBMS_INMEMORY_ADMIN</code> package
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">In-Memory Column Store Architecture</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" name="GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2"></a><h3 id="INMEM-GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" class="sect3"><span class="enumeration_section">2.4 </span>In-Memory Process Architecture
               </h3>
               <div>
                  <p>In response to queries and DML, server processes scan columnar data and update SMU metadata. Background processes populate row data from disk into the IM column store.</p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E">In-Memory Coordinator Process (IMCO)</a><br>The In-Memory Coordinator Process (IMCO) manages many tasks for the IM column store. Its primary task is to initiate background population and repopulation of columnar data.
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3">Space Management Worker Processes (Wnnn)</a><br>Space Management Worker Processes (W<span class="italic">nnn</span>) populate or repopulate data on behalf of IMCO.
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70">In-Memory Dynamic Scans</a><br><strong class="term">In-Memory Dynamic Scans (IM dynamic scans)</strong> use lightweight threads to parallelize In-Memory table scans.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">In-Memory Column Store Architecture</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E" name="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E"></a><h4 id="INMEM-GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E" class="sect4"><span class="enumeration_section">2.4.1 </span>In-Memory Coordinator Process (IMCO)
                  </h4>
                  <div>
                     <p>The In-Memory Coordinator Process (IMCO) manages many tasks for the IM column store. Its primary task is to initiate background population and repopulation of columnar data.</p>
                     <p>Population is a streaming mechanism, converting row data into columnar format, and then compressing it. IMCO automatically initiates population of <code class="codeph">INMEMORY</code> objects with any priority other than <code class="codeph">NONE</code>. When objects with priority <code class="codeph">NONE</code> are accessed, IMCO populates them using Space Management Worker Process (W<span class="italic">nnn</span>) processes.
                     </p>
                     <p>The IMCO background process also initiates <a href="glossary.html#GUID-6F8CD872-FBA2-4519-8204-66D3E45FA1C9"><span class="xrefglossterm">threshold-based repopulation</span></a> of IM column store objects when they meet a staleness threshold. IMCO may instigate <a href="glossary.html#GUID-34CC73ED-D322-4628-AC54-3F51065E8BCE"><span class="xrefglossterm">trickle repopulation</span></a> for any IMCU in the IM column store that has stale entries but does not meet the <a href="glossary.html#GUID-78ED27B2-6946-4302-BDD2-3F8A4F0DA42C"><span class="xrefglossterm">staleness threshold</span></a>. 
                     </p>
                     <p>Trickle repopulation occurs automatically in the background. The steps are as follows:</p>
                     <ol>
                        <li>
                           <p>IMCO wakes up.</p>
                        </li>
                        <li>
                           <p>IMCO determines whether population tasks need to be performed, including whether any stale entries exist in an IMCU.</p>
                        </li>
                        <li>
                           <p>If IMCO finds stale entries, then it triggers a Space Management Worker Process to repopulate these entries in the IMCU.</p>
                        </li>
                        <li>
                           <p>IMCO sleeps for two minutes, and then returns to Step 1.</p>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E__GUID-8B8A0400-F744-4034-99A4-6EAACB984D69">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="The IM column store periodically refreshes objects that have been modified. You can control this behavior using initialization parameters and the DBMS_INMEMORY package.">Optimizing Repopulation of the IM Column Store</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-86184690-5531-405F-AA05-BB935F57B76D" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about background processes
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="In response to queries and DML, server processes scan columnar data and update SMU metadata. Background processes populate row data from disk into the IM column store.">In-Memory Process Architecture</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3" name="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3"></a><h4 id="INMEM-GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3" class="sect4"><span class="enumeration_section">2.4.2 </span>Space Management Worker Processes (Wnnn)
                  </h4>
                  <div>
                     <p>Space Management Worker Processes (W<span class="italic">nnn</span>) populate or repopulate data on behalf of IMCO.
                     </p>
                     <p>During population, W<span class="italic">nnn</span> processes are responsible for creating IMCUs, SMUs, and IMEUs. When creating IMEUs, the worker processes perform the following tasks:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Identify virtual columns for population</p>
                        </li>
                        <li>
                           <p>Create virtual column values</p>
                        </li>
                        <li>
                           <p>Compute values for each row, transform the data into columnar format, and compress it</p>
                        </li>
                        <li>
                           <p>Register the objects with the space layer</p>
                        </li>
                        <li>
                           <p>Associate the IMEUs with their corresponding IMCUs</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3__GUID-683499D3-4356-4C9E-AC8E-CA92059FB61A">
                        <p class="notep1">Note:</p>
                        <p>During IMEU creation, parent IMCUs remain available for queries.</p>
                     </div>
                     <p>During repopulation, the W<span class="italic">nnn</span> processes create new versions of the IMCUs based on the existing IMCUs and transactions journals, while temporarily retaining the old versions. This mechanism is called <a href="glossary.html#GUID-D54C930C-1B27-40FC-9B15-25670A707365"><span class="xrefglossterm">double buffering</span></a>.
                     </p>
                     <p>The database can quickly move IM expressions in and out of the IM column store. For example, if an IMCU was created without an IMEU, then the database can add an IMEU later without forcing the IMCU to undergo the full repopulation mechanism.</p>
                     <p>The <code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code> initialization parameter controls the maximum number of worker processes that can be started for population. The <code class="codeph">INMEMORY_TRICKLE_REPOPULATE_PERCENT</code> initialization parameter controls the maximum percentage of time that worker processes can perform trickle repopulation.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3__GUID-7CC05002-BC25-4942-8AEC-B6319D935B81">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="populating-objects-in-memory.html#GUID-BFD476E7-C70D-4906-8B10-D33BC1E768C0" title="In-Memory population (population) occurs when the database reads existing row-format data from disk, transforms it into columnar format, and then stores it in the IM column store.">About In-Memory Population</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" title="The automatic refresh of columnar data after significant modifications is called repopulation.">About Repopulation of the IM Column Store</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="init-parameters-for-im-column-store.html#GUID-A67ABCAC-C6B9-499E-8AE0-BD7922B239BE" title="Several initialization parameters control the behavior of the IM column store.">In-Memory Initialization Parameters</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-86184690-5531-405F-AA05-BB935F57B76D" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about background processes
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="In response to queries and DML, server processes scan columnar data and update SMU metadata. Background processes populate row data from disk into the IM column store.">In-Memory Process Architecture</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" name="GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70"></a><h4 id="INMEM-GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" class="sect4"><span class="enumeration_section">2.4.3 </span>In-Memory Dynamic Scans
                  </h4>
                  <div>
                     <p><strong class="term">In-Memory Dynamic Scans (IM dynamic scans)</strong> use lightweight threads to parallelize In-Memory table scans.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59">Purpose of IM Dynamic Scans</a><br>When additional CPU is available, IM dynamic scans accelerate In-Memory table scans that are CPU bound.
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9">How IM Dynamic Scans Work</a><br>IM Dynamic Scans attain optimal performance by reading IMCUs in parallel.
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5">Interface for IM Dynamic Scans</a><br>IM dynamic scans are transparent, which means that they require no application changes and are automatically controlled by the Resource Manager.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="In response to queries and DML, server processes scan columnar data and update SMU metadata. Background processes populate row data from disk into the IM column store.">In-Memory Process Architecture</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59" name="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59"></a><h5 id="INMEM-GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59" class="sect5"><span class="enumeration_section">2.4.3.1 </span>Purpose of IM Dynamic Scans
                     </h5>
                     <div>
                        <p>When additional CPU is available, IM dynamic scans accelerate In-Memory table scans that are CPU bound.</p>
                        <p>IM dynamic scans automatically use idle CPU resources to scan IMCUs in parallel and maximize CPU usage. When CPU resources are available, applications can get even faster analytic query results automatically. Because the scans are dynamic, they enable the use of excess CPU bandwidth without affecting existing workload.</p>
                        <p>IM dynamic scans are more flexible than traditional Oracle parallel execution, although the two are not mutually exclusive. Dynamic scans use multiple lightweight threads of execution within a process. Typically, the performance overhead for dynamic scans is low.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59__GUID-0A9319C3-8D43-45CD-AB5D-9913517D9337">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=ADMIN-GUID-2BEF5482-CF97-4A85-BD90-9195E41E74EF" target="_blank"><span><cite>Oracle Database Administratorâ€™s Guide</cite></span></a> to learn more about Resource Manager
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="In-Memory Dynamic Scans (IM dynamic scans) use lightweight threads to parallelize In-Memory table scans.">In-Memory Dynamic Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" name="GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9"></a><h5 id="INMEM-GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" class="sect5"><span class="enumeration_section">2.4.3.2 </span>How IM Dynamic Scans Work
                     </h5>
                     <div>
                        <p>IM Dynamic Scans attain optimal performance by reading IMCUs in parallel.</p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-4DDD1A53-D634-4201-B46F-626DAE16A447">About Lightweight Threads</a><br>A <strong class="term">lightweight thread</strong> is an execution entity that helps to parallelize full table scans. It is â€œlightweightâ€ because it does not incur the higher memory overhead of Oracle processes.
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A">When the Database Considers IM Dynamic Scans</a><br>Lightweight threads are enabled when a CPU resource plan is enabled (for example, <code class="codeph">RESOURCE_MANAGER_PLAN=DEFAULT_PLAN</code>) and CPU utilization of the database is low.
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-0D557669-B378-4514-A0D3-FBE054AA9F57">How IM Dynamic Scans Work</a><br>Resource Manager allocates lightweight threads to parallelize the scan of IMCUs.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="In-Memory Dynamic Scans (IM dynamic scans) use lightweight threads to parallelize In-Memory table scans.">In-Memory Dynamic Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447" name="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447"></a><h6 id="INMEM-GUID-4DDD1A53-D634-4201-B46F-626DAE16A447" class="sect6"><span class="enumeration_section">2.4.3.2.1 </span>About Lightweight Threads
                        </h6>
                        <div>
                           <p>A <strong class="term">lightweight thread</strong> is an execution entity that helps to parallelize full table scans. It is â€œlightweightâ€ because it does not incur the higher memory overhead of Oracle processes.
                           </p>
                           <div class="infoboxnote" id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447__GUID-0FBCF10B-88C4-4A6F-9A7D-935799771F09">
                              <p class="notep1">Note:</p>
                              <p>A lightweight thread used by IM dynamic scans is not the same as a regular thread in the multithreaded Oracle Database model.</p>
                           </div>
                           <p>Lightweight threads share the resources of the parent foreground or PQ process, called the <a href="glossary.html#GUID-9938DE9E-21B0-4A21-B69B-A80CA6295B44"><span class="xrefglossterm">table scan process</span></a>, that coordinates the scan of a set of IMCUs. Threads maintain their own independent flow of execution. The database can parallelize scans by prioritizing threads and executing them asynchronously.
                           </p>
                           <p>For eligible queries, the process allocates a pool of threads. Resource Manager automatically determines the number of threads in the pool based on the CPU count in the database host and the current load on the system. The pool of threads remains available to the session for subsequent queries unless the idle time reaches an internal threshold, at which point the database terminates the threads.</p>
                           <p>Communication between threads occurs exclusively within a process. For this reason, contention does not occur at the database instance level.</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447__GUID-1F61E3C4-2B57-49E0-BCBD-98D05866076A">
                              <p class="notep1">See Also:</p>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=CNCPT-GUID-4B460E97-18A0-4F5A-A62F-9608FFD43664" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about the multithreaded Oracle Database model
                              </p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans attain optimal performance by reading IMCUs in parallel.">How IM Dynamic Scans Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A" name="GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A"></a><h6 id="INMEM-GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A" class="sect6"><span class="enumeration_section">2.4.3.2.2 </span>When the Database Considers IM Dynamic Scans
                        </h6>
                        <div>
                           <p>Lightweight threads are enabled when a CPU resource plan is enabled (for example, <code class="codeph">RESOURCE_MANAGER_PLAN=DEFAULT_PLAN</code>) and CPU utilization of the database is low.
                           </p>
                           <p>If lightweight threads are enabled, then the database considers an IM dynamic scan when an application queries an object that is currently populated in the IM column store. Typically, a serial or parallel query is a candidate for IM dynamic scans when it has the following characteristics:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Accesses a high number of IMCUs or columns</p>
                              </li>
                              <li>
                                 <p>Consumes all rows in the table</p>
                              </li>
                              <li>
                                 <p>Is CPU-intensive</p>
                              </li>
                           </ul>
                           <p>Oracle Database Resource Manager (the Resource Manager), which is automatically enabled when <code class="codeph">INMEMORY_SIZE</code> is greater than <code class="codeph">0</code>, is required for IM dynamic scans. The Resource Manager decides when and how to use the lightweight threads. Lightweight threads are the lowest priority operation in the database because they are capitalizing on unused resources.
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans attain optimal performance by reading IMCUs in parallel.">How IM Dynamic Scans Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57" name="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57"></a><h6 id="INMEM-GUID-0D557669-B378-4514-A0D3-FBE054AA9F57" class="sect6"><span class="enumeration_section">2.4.3.2.3 </span>How IM Dynamic Scans Work
                        </h6>
                        <div>
                           <p>Resource Manager allocates lightweight threads to parallelize the scan of IMCUs.</p>
                           <p>When the database determines that a query can benefit from an IM dynamic scan, it typically proceeds as follows:</p>
                           <ol>
                              <li>
                                 <p>A table scan process spawns a pool of lightweight threads.</p>
                              </li>
                              <li>
                                 <p>The table scan process creates a separate task for every IMCU that must be scanned, and then adds each task to a task queue.</p>
                              </li>
                              <li>
                                 <p>Resource Manager determines how many threads can participate in the table scan.</p>
                              </li>
                              <li>
                                 <p>Active threads pick up tasks from the task queue, with the table scan process consuming results from completed tasks.</p>
                              </li>
                           </ol>
                           <p>Depending on the database load, Resource Manager continuously adjusts the number of active lightweight threads while the query is running.&nbsp;If CPU resources are not available, then the table scan process performs the scan <span class="italic">without</span> using lightweight threads.
                           </p>
                           <p>The following graphic illustrates an IM dynamic scan of 12 IMCUs in the <code class="codeph">sales</code> table.
                           </p>
                           <div class="figure" id="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57__GUID-398D201A-1CD8-4400-B08E-C200FDDD7B85">
                              <p class="titleinfigure">Figure 2-12 IM Dynamic Scan</p><img src="img/inmem_pb_001b.png" alt="Description of Figure 2-12 follows" title="Description of Figure 2-12 follows" longdesc="img_text/inmem_pb_001b.html"><br><a href="img_text/inmem_pb_001b.html">Description of "Figure 2-12 IM Dynamic Scan"</a></div>
                           <!-- class="figure" -->
                           <p>In the preceding graphic, the database host has 8 CPU cores. Based on an internal algorithm, Resource Manager assigns 4 threads to assist the table scan process. In this scenario, 4 CPU cores remain idle for other concurrent database operations to use.</p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans attain optimal performance by reading IMCUs in parallel.">How IM Dynamic Scans Work</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5" name="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5"></a><h5 id="INMEM-GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5" class="sect5"><span class="enumeration_section">2.4.3.3 </span>Interface for IM Dynamic Scans
                     </h5>
                     <div>
                        <p>IM dynamic scans are transparent, which means that they require no application changes and are automatically controlled by the Resource Manager.</p>
                        <div class="section">
                           <p>IM dynamic scans require the Resource Manager, which is automatically enabled when <code class="codeph">INMEMORY_SIZE</code> is greater than <code class="codeph">0</code>. No specific resource plan is required.
                           </p>
                           <p>Several new session statistics track the usage of IM dynamic scans. Each thread writes trace data to a separate trace file. </p>
                           <p>Execution plans are unchanged. The following figure shows a sample execution plan.</p><pre class="pre codeblock"><code>SQL&gt; SELECT MAX(l_quantity) largest_order FROM lineitem;

LARGEST_ORDER
-------------
           50

Elapsed: 00:00:03.41

Execution Plan
----------------------------------------------------------
Plan hash value: 1885658499

------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name     | Rows | Bytes |Cost(%CPU)| Time     | Pstart| Pstop |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |          |    1 |     3 | 116K  (4)| 00:00:05 |       |       |
|   1 |  SORT AGGREGATE              |          |    1 |     3 |          |          |       |       |
|   2 |   PARTITION RANGE ALL        |          | 600M | 1716M | 116K  (4)| 00:00:05 |     1 |    84 |
|   3 |    TABLE ACCESS INMEMORY FULL| LINEITEM | 600M | 1716M | 116K  (4)| 00:00:05 |     1 |    84 |
------------------------------------------------------------------------------------------------------

NAME                                              VALUE
-------------------------------------------------------
IM scan CUs memcompress for query low              1147
IM scan bytes in-memory                      5.1790E+10
IM scan bytes uncompressed                   7.6722E+10
IM scan CUs columns accessed                       1147
IM scan rows                                  600037902
IM scan rows projected                               29
IM scan (dynamic) rows                        600037902
IM scan (dynamic) multi-threaded scans                1
IM scan (dynamic) tasks processed by thread        1146</code></pre><p>Consider the characteristics of the plan:</p>
                           <ol>
                              <li>
                                 <p>The execution plan is unchanged. </p>
                                 <p>Note that the plan does not mention IM dynamic scans in Step 3. However, clicking the binocular icon in a SQL Monitor report would show â€œDynamic Scan Tasks on Thread.â€</p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) multi-threaded scans</code> is nonzero, which means that the database used an IM dynamic scan.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan CUs memcompress for query low</code> indicates that 1147 IMCUs exist in the <code class="codeph">lineitem</code> table.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) tasks processed by thread</code> indicates how many IMCUs were processed in parallel. 
                                 </p>
                                 <p>The number is 1146, which is less than the total number of 1147 shown in <code class="codeph">IM scan CUs memcompress for query low</code>. The database analyzed the first IMCU without parallelization to determine whether parallelization was worthwhile. Because the answer was yes, the database proceeded to scan the remaining 1146 IMCUs in parallel.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) rows</code> and <code class="codeph">IM scan rows are equal</code>, which means that the threads retrieved all rows for the query.
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5__GUID-CDAA9B98-FEB7-406D-BDD7-F1F76628FB03">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=ADMIN-GUID-E8FABE8D-A781-49BB-B623-98F096DED239" target="_blank"><span><cite>Oracle Database Administratorâ€™s Guide</cite></span></a> to learn more about the Resource Manager
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/statistics-descriptions-2.html#REFRN-GUID-2FBC1B7E-9123-41DD-8178-96176260A639" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for descriptions of In-Memory statistics
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="In-Memory Dynamic Scans (IM dynamic scans) use lightweight threads to parallelize In-Memory table scans.">In-Memory Dynamic Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" name="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310"></a><h3 id="INMEM-GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" class="sect3"><span class="enumeration_section">2.5 </span>CPU Architecture: SIMD Vector Processing
               </h3>
               <div>
                  <p>For data that is populated in the IM column store, the database uses SIMD (single instruction, multiple data) vector processing.</p>
                  <p>The IM column store maximizes the number of column entries that the CPU can load into the vector registers and evaluate. Instead of evaluating each entry in the column one at a time, the database evaluates a set of column values in a single CPU instruction. SIMD vector processing enables the database to scan billions of rows per second.</p>
                  <p>For example, an application issues a query to find the total number of orders in the <code class="codeph">sales</code> table that use the <code class="codeph">promo_id</code> value of <code class="codeph">9999</code>. The <code class="codeph">sales</code> table resides in the IM column store. The query begins by scanning only the <code class="codeph">sales.promo_id</code> column, as shown in the following diagram:
                  </p>
                  <div class="figure" id="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310__GUID-20F920D6-E978-476E-A578-32B4C05F50B0">
                     <p class="titleinfigure">Figure 2-13 SIMD Vector Processing</p><img src="img/cncpt_vm_382.png" alt="Description of Figure 2-13 follows" title="Description of Figure 2-13 follows" longdesc="img_text/cncpt_vm_382.html"><br><a href="img_text/cncpt_vm_382.html">Description of "Figure 2-13 SIMD Vector Processing"</a></div>
                  <!-- class="figure" -->
                  <p>The CPU evaluates the data as follows:</p>
                  <ol>
                     <li>
                        <p>Loads the first 8 values (the number varies depending on data type and compression mode) from the <code class="codeph">promo_id</code> column into the SIMD register, and then compares them with the value <code class="codeph">9999</code> in a single instruction
                        </p>
                     </li>
                     <li>
                        <p>Discards the entries.</p>
                     </li>
                     <li>
                        <p>Loads another 8 values into the SIMD register, and then continues in this way until it has evaluated all entries.</p>
                     </li>
                  </ol>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA">SIMD and Oracle LOBs</a><br><span>Oracle Database 18c</span> provides SIMD vector support for queries involving SQL operators on specific LOB columns.
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534">SIMD and Oracle Numbers</a><br><span>For tables compressed with <code class="codeph">QUERY LOW</code>, <code class="codeph">NUMBER</code> columns are encoded using an optimized format that enables native calculations in hardware.</span></li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4">SIMD and Exadata Smart Flash Cache</a><br>Besides storing data in Hybrid Columnar Compression format, Exadata Smart Flash Cache can store data in pure columnar format.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously.">In-Memory Column Store Architecture</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA" name="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA"></a><h4 id="INMEM-GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA" class="sect4"><span class="enumeration_section">2.5.1 </span>SIMD and Oracle LOBs
                  </h4>
                  <div>
                     <p><span>Oracle Database 18c</span> provides SIMD vector support for queries involving SQL operators on specific LOB columns.
                     </p>
                     <p>The nature of the support depends on the type of LOB:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Inline LOBs</p>
                           <p>The IM column store provides contiguous storage for inline LOBs, which are LOBs less than 4 KB, within the IMCUs. Columnar storage enables faster query processing by removing the overhead of assembling LOB data from the database buffer cache.</p>
                        </li>
                        <li>
                           <p>Out-of-line LOBs</p>
                           <p>In this case, the IM column store only stores the LOB locator, which is 40 byes. Out-of-line columns do not benefit from columnar optimization.</p>
                        </li>
                     </ul>
                     <p>There is one exception to the preceding rule. An IMEU can allocate up to 32 KB of contiguous storage for JSON columns defined as a LOB data type. The IMEU stores these columns in the <a href="glossary.html#GUID-96C1EFE2-69DD-4E78-97DA-25253A51E3A5"><span class="xrefglossterm">OSON</span></a> format, which can provide faster query performance using SIMD processing.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA__GUID-30A42379-36EF-42C3-95D6-B12116C71695">
                        <p class="notep1">See Also:</p>
                        <p><a href="../adlob/introduction-to-large-objects.html#ADLOB-GUID-1A2B0023-9EE8-48AF-AA76-171D1FC5C241" target="_blank"><span><cite>Oracle Database SecureFiles and Large Objects Developer's Guide</cite></span></a> to learn more about LOBs
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="For data that is populated in the IM column store, the database uses SIMD (single instruction, multiple data) vector processing.">CPU Architecture: SIMD Vector Processing</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534" name="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534"></a><h4 id="INMEM-GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534" class="sect4"><span class="enumeration_section">2.5.2 </span>SIMD and Oracle Numbers
                  </h4>
                  <div>
                     <p><span>For tables compressed with <code class="codeph">QUERY LOW</code>, <code class="codeph">NUMBER</code> columns are encoded using an optimized format that enables native calculations in hardware.</span></p>
                     <p><span>SIMD vector processing enables simple aggregations, <code class="codeph">GROUP BY</code> aggregations, and arithmetic operations to benefit significantly. The performance improvement depends on the amount of time the aggregation spends on arithmetic computation. Some aggregations may benefit by up to a factor of 9.</span></p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534__GUID-09CA3951-DE7D-427A-9CE2-8D357B64F8E5">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="optimizing-in-memory-aggregation.html#GUID-4321558D-853B-41A0-9098-4A45204F21BD" title="In-Memory Optimized Arithmetic&nbsp;uses an optimized NUMBER format for fast calculations using SIMD hardware.">Optimizing In-Memory Arithmetic</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Data-Types.html#SQLRF-GUID-9401BC04-81C4-4CD5-99E7-C5E25C83F608" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="For data that is populated in the IM column store, the database uses SIMD (single instruction, multiple data) vector processing.">CPU Architecture: SIMD Vector Processing</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4" name="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4"></a><h4 id="INMEM-GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4" class="sect4"><span class="enumeration_section">2.5.3 </span>SIMD and Exadata Smart Flash Cache
                  </h4>
                  <div>
                     <p>Besides storing data in Hybrid Columnar Compression format, Exadata Smart Flash Cache can store data in pure columnar format.</p>
                     <p>Exadata Smart Scan supports SIMD predicates. The advantage is that In-Memory performance extends from DRAM storage to secondary storage.</p>
                     <p>By default, Exadata Smart Flash Cache compresses data using the level <code class="codeph">MEMCOMPRESS FOR CAPACITY LOW</code>. To change the compression level or disable the columnar format altogether, use the <code class="codeph">ALTER TABLE ... NO CELLMEMORY</code> statement.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4__GUID-ECB949A8-37D3-4DF0-923D-C433D823C8FC">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="intro-to-in-memory-column-store.html#GUID-3C7A9421-141C-43F8-9CFC-D0D516E19D3B" title="Not all objects marked INMEMORY may fit in DRAM memory at the same time. If you use Oracle Exadata Storage Server Software, then Exadata Smart Flash Cache can serve as supplemental memory.">In-Memory Support for Exadata Flash Cache</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=DBMSO-GUID-D3F05A21-F1A8-48D0-AC3C-88AF3D725DCD" target="_blank"><span id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4__DBMSO"><cite>Oracle Exadata Database Machine System Overview</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="For data that is populated in the IM column store, the database uses SIMD (single instruction, multiple data) vector processing.">CPU Architecture: SIMD Vector Processing</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>