<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Performance Improvement Methods</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Performance Tuning Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Performance Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-performance-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-12T22:26:14-07:00">
      <meta name="dcterms.title" content="Database Performance Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2007, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96347-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="designing-and-developing-for-performance.html" title="Previous" type="text/html">
      <link rel="next" href="configuring-database-for-performance.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGDBA">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="designing-and-developing-for-performance.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="configuring-database-for-performance.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Performance Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-I-database-performance-fundamentals.html" property="item" typeof="WebPage"><span property="name">Database Performance Fundamentals </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Performance Improvement Methods</li>
            </ol>
            <a id="GUID-11C3D845-70B3-46F2-B529-623050A8B933" name="GUID-11C3D845-70B3-46F2-B529-623050A8B933"></a><a id="TGDBA032"></a>
            
            <h2 id="TGDBA-GUID-11C3D845-70B3-46F2-B529-623050A8B933" class="sect2"><span class="enumeration_chapter">3 </span> Performance Improvement Methods
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses Oracle Database improvement methods and contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="performance-improvement-methods.html#GUID-3BB46F28-73FF-486E-ADB7-C4A42BAF33EF">The Oracle Performance Improvement Method</a></p>
                  </li>
                  <li>
                     <p><a href="performance-improvement-methods.html#GUID-E33E68C9-F4A5-4953-8F80-33810EADD560">Emergency Performance Methods</a></p>
                  </li>
               </ul>
            </div><a id="TGDBA94135"></a><div class="props_rev_3"><a id="GUID-3BB46F28-73FF-486E-ADB7-C4A42BAF33EF" name="GUID-3BB46F28-73FF-486E-ADB7-C4A42BAF33EF"></a><h3 id="TGDBA-GUID-3BB46F28-73FF-486E-ADB7-C4A42BAF33EF" class="sect3"><span class="enumeration_section">3.1 </span>The Oracle Performance Improvement Method
               </h3>
               <div>
                  <p>Oracle performance methodology helps you to identify performance problems in an Oracle database. This involves identifying bo<a id="d7771e119" class="indexterm-anchor"></a><a id="d7771e123" class="indexterm-anchor"></a>ttlenecks and fixing them. It is recommended that changes be made to a system only after you have confirmed that there is a bottleneck. 
                  </p>
                  <p>Performance improvement, by its nature, is iterative. For this reason, removing the first bottleneck might not lead to performance improvement immediately, because another bottleneck might be revealed. Also, in some cases, if serialization points move to a more inefficient sharing mechanism, then performance could degrade. With experience, and by following a rigorous method of bottleneck elimination, applications can be debugged and made scalable.</p>
                  <p>Performance problems generally result from either a lack of throughput, unacceptable user/job response time, or both. The problem might be localized between application modules, or it might be for the entire system.</p>
                  <p>Before looking at any database or operating system statistics, it is crucial to get feedback from the most important components of the system: the users of the system and the people ultimately paying for the application. Typical user feedback includes statements like the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>"The online performance is so bad that it prevents my staff from doing their jobs."</p>
                     </li>
                     <li>
                        <p>"The billing run takes too long."</p>
                     </li>
                     <li>
                        <p>"When I experience high amounts of Web traffic, the response time becomes unacceptable, and I am losing customers."</p>
                     </li>
                     <li>
                        <p>"I am currently performing 5000 trades a day, and the system is maxed out. Next month, we roll out to all our users, and the number of trades is expected to quadruple."</p>
                     </li>
                  </ul>
                  <p>From candid feedback, it is easy to set critical success factors for any performance work. Determining the performance targets and the performance engineer's exit criteria make managing the performance process much simpler and more successful at all levels. These critical success factors are better defined in terms of real business goals rather than system statistics. </p>
                  <p>Some real business goals for these typical user statements might be:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>"The billing run must process 1,000,000 accounts in a three-hour window."</p>
                     </li>
                     <li>
                        <p>"At a peak period on a Web site, the response time must not exceed five seconds for a page refresh."</p>
                     </li>
                     <li>
                        <p>"The system must be able to process 25,000 trades in an eight-hour window."</p>
                     </li>
                  </ul>
                  <p>The ultimate measure of success is the user's perception of system performance. The performance engineer's role is to eliminate any bottlenecks that degrade performance. These bottlenecks could be caused by inefficient use of limited shared resources or by abuse of shared resources, causing serialization. Because all shared resources are limited, the goal of a performance engineer is to maximize the number of business operations with efficient use of shared resources. At a very high level, the entire database server can be seen as a shared resource. Conversely, at a low level, a single CPU or disk can be seen as shared resources.</p>
                  <p>You can apply the Oracle performance improvement method until performance goals are met or deemed impossible. This process is highly iterative. Inevitably, some investigations may have little or no impact on database performance. Time and experience are necessary to develop the skills to accurately and quickly pinpoint critical bottlenecks. However, prior experience can sometimes work against the experienced engineer who neglects to use the data and statistics available. This type of behavior encourages database tuning by myth and folklore. This is a very risky, expensive, and unlikely to succeed method of database tuning. </p>
                  <p>The Automatic Database Diagnostic Monitor (ADDM) implements parts of the performance improvement method and analyzes statistics to provide automatic diagnosis of major performance issues. Using ADDM can significantly shorten the time required to improve the performance of a system.</p>
                  <p>Systems are so different and complex that hard and fast rules for performance analysis are impossible. In essence, the Oracle performance improvement method defines a way of working, but not a definitive set of rules. With bottleneck detection, the only rule is that there are no rules! The best performance engineers use the data provided and think laterally to determine performance problems.</p>
               </div><a id="TGDBA94136"></a><div class="props_rev_3"><a id="GUID-89C0441A-0744-4E84-AB23-BD7DF72F8554" name="GUID-89C0441A-0744-4E84-AB23-BD7DF72F8554"></a><h4 id="TGDBA-GUID-89C0441A-0744-4E84-AB23-BD7DF72F8554" class="sect4"><span class="enumeration_section">3.1.1 </span>Steps in the Oracle Performance Improvement Method
                  </h4>
                  <div>
                     <div class="section">
                        <ol>
                           <li>
                              <p>Perform the following initial standard checks:</p>
                              <ol type="a">
                                 <li>
                                    <p>Get candid feedback from users. Determine the performance project's scope and subsequent performance goals, and performance goals for the future. This process is key in future capacity planning.</p>
                                 </li>
                                 <li>
                                    <p>Get a full set of operating system, database, and application statistics from the system when the performance is both good and bad. If these are not available, then get whatever is available. Missing statistics are analogous to missing evidence at a crime scene: They make detectives work harder and it is more time-consuming.</p>
                                 </li>
                                 <li>
                                    <p>Sanity-check the operating systems of all computers involved with user performance. By sanity-checking the operating system, you look for hardware or operating system resources that are fully utilized. List any over-used resources as symptoms for analysis later. In addition, check that all hardware shows no errors or diagnostics.</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>Check for the top ten most common mistakes with Oracle Database, and determine if any of these are likely to be the problem. List these as symptoms for later analysis. These are included because they represent the most likely problems. ADDM automatically detects and reports nine of these top ten issues.</p>
                           </li>
                           <li>
                              <p>Build a conceptual model of what is happening on the system using the symptoms as clues to understand what caused the performance problems. See <span class="q">"<a href="performance-improvement-methods.html#GUID-3D34BBA9-B1D2-4EA1-BAB2-2749B3F68C8D">A Sample Decision Process for Performance Conceptual Modeling</a>"</span>.
                              </p>
                           </li>
                           <li>
                              <p>Propose a series of remedy actions and the anticipated behavior to the system, then apply them in the order that can benefit the application the most. ADDM produces recommendations each with an expected benefit. A golden rule in performance work is that you only change one thing at a time and then measure the differences. Unfortunately, system downtime requirements might prohibit such a rigorous investigation method. If multiple changes are applied at the same time, then try to ensure that they are isolated so that the effects of each change can be independently validated.</p>
                           </li>
                           <li>
                              <p>Validate that the changes made have had the desired effect, and see if the user's perception of performance has improved. Otherwise, look for more bottlenecks, and continue refining the conceptual model until your understanding of the application becomes more accurate.</p>
                           </li>
                           <li>
                              <p>Repeat the last three steps until performance goals are met or become impossible due to other constraints.</p>
                           </li>
                        </ol>
                        <p>This method identifies the biggest bottleneck and uses an objective approach to performance improvement. The focus is on making large performance improvements by increasing application efficiency and eliminating resource shortages and bottlenecks. In this process, it is anticipated that minimal (less than 10%) performance gains are made from instance tuning, and large gains (100% +) are made from isolating application inefficiencies.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94137"></a><div class="props_rev_3"><a id="GUID-3D34BBA9-B1D2-4EA1-BAB2-2749B3F68C8D" name="GUID-3D34BBA9-B1D2-4EA1-BAB2-2749B3F68C8D"></a><h4 id="TGDBA-GUID-3D34BBA9-B1D2-4EA1-BAB2-2749B3F68C8D" class="sect4"><span class="enumeration_section">3.1.2 </span>A Sample Decision Process for Performance Conceptual Modeling
                  </h4>
                  <div>
                     <p><a id="d7771e316" class="indexterm-anchor"></a><a id="d7771e318" class="indexterm-anchor"></a>Conceptual modeling is almost deterministic. However, as you gain experience in performance tuning, you begin to appreciate that no real rules exist. A flexible heads-up approach is required to interpret statistics and make good decisions. 
                     </p>
                     <p>For a quick and easy approach to performance tuning, use ADDM. ADDM automatically monitors your Oracle system and provides recommendations for solving performance problems should problems occur. For example, suppose a DBA receives a call from a user complaining that the system is slow. The DBA simply examines the latest ADDM report to see which of the recommendations should be implemented to solve the problem.</p>
                     <p>The following steps illustrate how a performance engineer might look for bottlenecks without using automatic diagnostic features. These steps are only intended as a guideline for the manual process. With experience, performance engineers add to the steps involved. This analysis assumes that statistics for both the operating system and the database have been gathered.</p>
                     <ol>
                        <li>
                           <p>Is the response time/batch run time acceptable for a single user on an empty or lightly loaded computer?</p>
                           <p>If it is not acceptable, then the application is probably not coded or designed optimally, and it will never be acceptable in a multiple user situation when system resources are shared. In this case, get application internal statistics, and get SQL Trace and SQL plan information. Work with developers to investigate problems in data, index, transaction SQL design, and potential deferral of work to batch and background processing.</p>
                        </li>
                        <li>
                           <p>Is all the CPU being utilized?</p>
                           <p>If the kernel utilization is over 40%, then investigate the operating system for network transfers, paging, swapping, or process thrashing. Continue to check CPU utilization in user space to verify if there are any non-database jobs consuming CPU on the system limiting the amount of shared CPU resources, such as backups, file transforms, print queues, and so on. After determining that the database is using most of the CPU, investigate the top SQL by CPU utilization. These statements form the basis of all future analysis. Check the SQL and the transactions submitting the SQL for optimal execution. Oracle Database provides CPU statistics in <code class="codeph">V$SQL</code> and <code class="codeph">V$SQLSTATS</code>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-3D34BBA9-B1D2-4EA1-BAB2-2749B3F68C8D__GUID-16D46D60-5DA8-41AF-8B31-94B4B40DC155">
                              <p class="notep1">See Also:</p>
                              <p><span class="italic">Oracle Database Reference</span> for more information about <a href="../refrn/V-SQL.html#REFRN-GUID-2B9340D7-4AA8-4894-94C0-D5990F67BE75" target="_blank"><code class="codeph">V$SQL</code></a> and <a href="../refrn/V-SQLSTATS.html#REFRN-GUID-495DD17D-6741-433F-871D-C965EB221DA9" target="_blank"><code class="codeph">V$SQLSTATS</code></a></p>
                           </div>
                           <p>If the application is optimal and no inefficiencies exist in the SQL execution, then consider rescheduling some work to off-peak hours or using a bigger computer.</p>
                        </li>
                        <li>
                           <p>At this point, the system performance is unsatisfactory, yet the CPU resources are not fully utilized.</p>
                           <p>In this case, you have serialization and unscalable behavior within the server. Get the <code class="codeph">WAIT_EVENTS</code> statistics from the server, and determine the biggest serialization point. If there are no serialization points, then the problem is most likely outside the database, and this should be the focus of investigation. Elimination of <code class="codeph">WAIT_EVENTS</code> involves modifying application SQL and tuning database parameters. This process is very iterative and requires the ability to drill down on the <code class="codeph">WAIT_EVENTS</code> systematically to eliminate serialization points.
                           </p>
                        </li>
                     </ol>
                  </div>
               </div><a id="TGDBA94138"></a><div class="props_rev_3"><a id="GUID-2740C1B3-DB87-4DD4-9CD7-DB11D03F845F" name="GUID-2740C1B3-DB87-4DD4-9CD7-DB11D03F845F"></a><h4 id="TGDBA-GUID-2740C1B3-DB87-4DD4-9CD7-DB11D03F845F" class="sect4"><span class="enumeration_section">3.1.3 </span>Top Ten Mistakes Found in Oracle Systems
                  </h4>
                  <div>
                     <p>This section lists the most common mistakes found in Oracle databases. By following the Oracle performance improvement methodology, you should be able to avoid these mistakes altogether. If you find these mistakes in your system, then re-engineer the application where the performance effort is worthwhile.</p>
                     <ol>
                        <li>
                           <p>Bad connection management</p>
                           <p>The application connects and disconnects for each database interaction. This problem is common with stateless middleware in application servers. It has over two orders of magnitude impact on performance, and is totally unscalable.</p>
                        </li>
                        <li>
                           <p>Bad use of cursors and the shared pool</p>
                           <p>Not using cursors results in repeated parses. If bind variables are not used, then there is hard parsing of all SQL statements. This has an order of magnitude impact in performance, and it is totally unscalable. Use cursors with bind variables that open the cursor and execute it many times. Be suspicious of applications generating dynamic SQL.</p>
                        </li>
                        <li>
                           <p>Bad SQL</p>
                           <p>Bad SQL is SQL that uses more resources than appropriate for the application requirement. This can be a decision support systems (DSS) query that runs for more than 24 hours, or a query from an online application that takes more than a minute. You should investigate SQL that consumes significant system resources for potential improvement. ADDM identifies high load SQL. SQL Tuning Advisor can provide recommendations for improvement.</p>
                        </li>
                        <li>
                           <p>Use of nonstandard initialization parameters</p>
                           <p>These might have been implemented based on poor advice or incorrect assumptions. Most databases provide acceptable performance using only the set of basic parameters. In particular, parameters associated with <code class="codeph">SPIN_COUNT</code> on latches and undocumented optimizer features can cause a great deal of problems that can require considerable investigation.
                           </p>
                           <p>Likewise, optimizer parameters set in the initialization parameter file can override proven optimal execution plans. For these reasons, schemas, schema statistics, and optimizer settings should be managed as a group to ensure consistency of performance.</p>
                           <div class="infoboxnotealso" id="GUID-2740C1B3-DB87-4DD4-9CD7-DB11D03F845F__GUID-9ABADA85-2803-4D83-8FD5-C4BDF24F01A3">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN002" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about initialization parameters and database creation
                                    </p>
                                 </li>
                                 <li>
                                    <p> <a href="../refrn/initialization-parameters-2.html#REFRN-GUID-FD266F6F-D047-4EBB-8D96-B51B1DCA2D61" target="_blank"><span class="italic">Oracle Database Reference</span></a> for details on initialization parameters
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>Getting database I/O wrong</p>
                           <p>Many sites lay out their databases poorly over the available disks. Other sites specify the number of disks incorrectly, because they configure disks by disk space and not I/O bandwidth.</p>
                        </li>
                        <li>
                           <p>Online redo log setup problems</p>
                           <p>Many sites run with too few online redo log files and files that are too small. Small redo log files cause system checkpoints to continuously put a high load on the buffer cache and I/O system. If too few redo log files exist, then the archive cannot keep up, and the database must wait for the archiver to catch up.</p>
                        </li>
                        <li>
                           <p>Serialization of data blocks in the buffer cache due to lack of free lists, free list groups, transaction slots (<code class="codeph">INITRANS</code>), or shortage of rollback segments. 
                           </p>
                           <p>This is particularly common on <code class="codeph">INSERT</code>-heavy applications, in applications that have raised the block size above 8K, or in applications with large numbers of active users and few rollback segments. Use automatic segment-space management (ASSM) and automatic undo management to solve this problem.
                           </p>
                        </li>
                        <li>
                           <p>Long full table scans</p>
                           <p>Long full table scans for high-volume or interactive online operations could indicate poor transaction design, missing indexes, or poor SQL optimization. Long table scans, by nature, are I/O intensive and unscalable.</p>
                        </li>
                        <li>
                           <p>High amounts of recursive (<code class="codeph">SYS</code>) SQL
                           </p>
                           <p>Large amounts of recursive SQL executed by <code class="codeph">SYS</code> could indicate space management activities, such as extent allocations, taking place. This is unscalable and impacts user response time. Use locally managed tablespaces to reduce recursive SQL due to extent allocation. Recursive SQL executed under another user ID is probably SQL and PL/SQL, and this is not a problem. 
                           </p>
                        </li>
                        <li>
                           <p>Deployment and migration errors</p>
                           <p>In many cases, an application uses too many resources because the schema owning the tables has not been successfully migrated from the development environment or from an older implementation. Examples of this are missing indexes or incorrect statistics. These errors can lead to sub-optimal execution plans and poor interactive user performance. When migrating applications of known performance, export the schema statistics to maintain plan stability using the <code class="codeph">DBMS_STATS</code> package.
                           </p>
                           <p>Although these errors are not directly detected by ADDM, ADDM highlights the resulting high load SQL.</p>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="TGDBA94139"></a><div class="props_rev_3"><a id="GUID-E33E68C9-F4A5-4953-8F80-33810EADD560" name="GUID-E33E68C9-F4A5-4953-8F80-33810EADD560"></a><h3 id="TGDBA-GUID-E33E68C9-F4A5-4953-8F80-33810EADD560" class="sect3"><span class="enumeration_section">3.2 </span>Emergency Performance Methods
               </h3>
               <div>
                  <p>This section provides techniques for dealing with <a id="d7771e567" class="indexterm-anchor"></a><a id="d7771e571" class="indexterm-anchor"></a>performance emergencies. You presumably have a methodology for establishing and improving application performance. However, in an emergency situation, a component of the system has changed to transform it from a reliable, predictable system to one that is unpredictable and not satisfying user requests.
                  </p>
                  <p>In this case, the performance engineer must rapidly determine what has changed and take appropriate actions to resume normal service as quickly as possible. In many cases, it is necessary to take immediate action, and a rigorous performance improvement project is unrealistic. </p>
                  <p>After addressing the immediate performance problem, the performance engineer must collect sufficient debugging information either to get better clarity on the performance problem or to at least ensure that it does not happen again.</p>
                  <p>The method for debugging emergency performance problems is the same as the method described in the performance improvement method earlier in this book. However, shortcuts are taken in various stages because of the timely nature of the problem. Keeping detailed notes and records of facts found as the debugging process progresses is essential for later analysis and justification of any remedial actions. This is analogous to a doctor keeping good patient notes for future reference.</p>
               </div><a id="TGDBA94140"></a><div class="props_rev_3"><a id="GUID-5AD3CA40-4C1E-47DB-B9FB-8A64823BD2E9" name="GUID-5AD3CA40-4C1E-47DB-B9FB-8A64823BD2E9"></a><h4 id="TGDBA-GUID-5AD3CA40-4C1E-47DB-B9FB-8A64823BD2E9" class="sect4"><span class="enumeration_section">3.2.1 </span>Steps in the Emergency Performance Method
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <a id="d7771e634" class="indexterm-anchor"></a>Emergency Performance Method is as follows:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Survey the performance problem and collect the symptoms of the performance problem. This process should include the following:</span><div>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>User feedback on how the system is underperforming. Is the problem throughput or response time?</p>
                                 </li>
                                 <li>
                                    <p>Ask the question, "What has changed since we last had good performance?" This answer can give clues to the problem. However, getting unbiased answers in an escalated situation can be difficult. Try to locate some reference points, such as collected statistics or log files, that were taken before and after the problem.</p>
                                 </li>
                                 <li>
                                    <p>Use automatic tuning features to diagnose and monitor the problem. In addition, you can use Oracle Enterprise Manager Cloud Control (Cloud Control) performance features to identify top SQL and sessions.</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Sanity-check the hardware utilization of all components of the application system. Check where the highest CPU utilization is, and check the disk, memory usage, and network performance on all the system components. This quick process identifies which tier is causing the problem. If the problem is in the application, then shift analysis to application debugging. Otherwise, move on to database server analysis.</span></li>
                        <li class="stepexpand"><span>Determine if the database server is constrained on CPU or if it is spending time waiting on wait events. If the database server is CPU-constrained, then investigate the following:</span><div>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Sessions that are consuming large amounts of CPU at the operating system level and database; check <code class="codeph">V$SESS_TIME_MODEL</code> for database CPU usage
                                    </p>
                                 </li>
                                 <li>
                                    <p>Sessions or statements that perform many buffer gets at the database level; check <code class="codeph">V$SESSTAT</code> and <code class="codeph">V$SQLSTATS</code></p>
                                 </li>
                                 <li>
                                    <p>Execution plan changes causing sub-optimal SQL execution; these can be difficult to locate</p>
                                 </li>
                                 <li>
                                    <p>Incorrect setting of initialization parameters</p>
                                 </li>
                                 <li>
                                    <p>Algorithmic issues caused by code changes or upgrades of all components</p>
                                 </li>
                              </ul>
                              <p>If the database sessions are waiting on events, then follow the wait events listed in <code class="codeph">V$SESSION_WAIT</code> to determine what is causing serialization. The <code class="codeph">V$ACTIVE_SESSION_HISTORY</code> view contains a sampled history of session activity which you can use to perform diagnosis even after an incident has ended and the system has returned to normal operation. In cases of massive contention for the library cache, it might not be possible to logon or submit SQL to the database. In this case, use historical data to determine why there is suddenly contention on this latch. If most waits are for I/O, then examine <code class="codeph">V$ACTIVE_SESSION_HISTORY</code> to determine the SQL being run by the sessions that are performing all of the inputs and outputs.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Apply emergency action to stabilize the system. This could involve actions that take parts of the application off-line or restrict the workload that can be applied to the system. It could also involve a system restart or the termination of job in process. These naturally have service level implications. </span></li>
                        <li class="stepexpand"><span>Validate that the system is stable. Having made changes and restrictions to the system, validate that the system is now stable, and collect a reference set of statistics for the database. Now follow the rigorous performance method described earlier in this book to bring back all functionality and users to the system. This process may require significant application re-engineering before it is complete.</span></li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>