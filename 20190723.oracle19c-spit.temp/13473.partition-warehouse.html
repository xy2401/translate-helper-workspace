<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Partitioning features can improve performance in a data warehouse environment.">
      <meta name="description" content="Partitioning features can improve performance in a data warehouse environment.">
      <title>Using Partitioning in a Data Warehouse Environment</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="VLDB and Partitioning Guide">
      <meta property="og:description" content="Partitioning features can improve performance in a data warehouse environment.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="VLDB and Partitioning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00">
      <meta name="dcterms.title" content="VLDB and Partitioning Guide">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96199-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="heatmap-ado-em.html" title="Previous" type="text/html">
      <link rel="next" href="partition-oltp.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="heatmap-ado-em.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="partition-oltp.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB and Partitioning Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Using Partitioning in a Data Warehouse Environment</li>
            </ol>
            <a id="GUID-31EBAE14-966E-438F-8141-51C06AFA0C10" name="GUID-31EBAE14-966E-438F-8141-51C06AFA0C10"></a><a id="VLDBG005"></a>
            
            <h2 id="VLDBG-GUID-31EBAE14-966E-438F-8141-51C06AFA0C10" class="sect2"><span class="enumeration_chapter">6 </span>Using Partitioning in a Data Warehouse Environment
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Partitioning features can improve performance in a data warehouse environment.</p>
               <p>This chapter describes the partitioning features that significantly enhance data access and improve overall application performance. Improvements with partitioning are especially true for applications that access tables and indexes with millions of rows and many gigabytes of data, as found in a data warehouse environment. Data warehouses often contain large tables and require techniques for managing these large tables and for providing good query performance across these large tables.</p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="partition-warehouse.html#GUID-CD9A8484-D111-461B-8883-04F520A30CE4" title="A data warehouse is a relational database that is designed for query and analysis rather than for transaction processing.">What Is a Data Warehouse?</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" title="Partitioning helps to scale a data warehouse by dividing database objects into smaller pieces, enabling access to smaller, more manageable objects. Having direct access to smaller objects addresses the scalability requirements of data warehouses.">Scalability in a Data Warehouse</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" title="Good performance is a requirement for a successful data warehouse.">Partitioning for Performance in a Data Warehouse</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" title="Data warehouses store historical data. Important parts of a data warehouse are the data loading and purging. Partitioning is powerful technology that can help data management for data warehouses.">Manageability in a Data Warehouse</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG00501"></a><div class="props_rev_3"><a id="GUID-CD9A8484-D111-461B-8883-04F520A30CE4" name="GUID-CD9A8484-D111-461B-8883-04F520A30CE4"></a><h3 id="VLDBG-GUID-CD9A8484-D111-461B-8883-04F520A30CE4" class="sect3">What Is a Data Warehouse?</h3>
               <div>
                  <p>A data warehouse is a relational database that is designed for query and analysis rather than for transaction processing.</p>
                  <p>A data warehouse usually contains historical data derived from transaction data, but can include data from other sources. Data warehouses separate analysis workload from transaction workload and enable an organization to consolidate data from several sources.</p>
                  <p>In addition to a relational database, a data warehouse environment can include an extraction, transformation, and loading (ETL) solution, analytical processing and data mining capabilities, client analysis tools, and other applications that manage the process of gathering data and delivering it to business users.</p>
                  <div class="infoboxnotealso" id="GUID-CD9A8484-D111-461B-8883-04F520A30CE4__GUID-F40498A7-E6AC-41DB-9E18-78410B0C5DD5">
                     <p class="notep1">See Also:</p>
                     <p><a href="../dwhsg/introduction-data-warehouse-concepts.html#DWHSG-GUID-452FBA23-6976-4590-AA41-1369647AD14D" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a></p>
                  </div>
               </div>
            </div><a id="VLDBG00502"></a><div class="props_rev_3"><a id="GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" name="GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED"></a><h3 id="VLDBG-GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" class="sect3">Scalability in a Data Warehouse</h3>
               <div>
                  <p>Partitioning helps to scale a data warehouse by dividing database objects into smaller pieces, enabling access to smaller, more manageable objects. Having direct access to smaller objects addresses the scalability requirements of data warehouses.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" title="The ability to split a large database object into smaller pieces transparently simplifies efficient management of very large databases.">Bigger Databases</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" title="It takes longer to scan a big table than it takes to scan a small table. Queries against partitioned tables may access one or more partitions that are small in contrast to the total size of the table.">Bigger Individual Tables: More Rows in Tables</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" title="With partitioning, users are more likely to query on isolated and smaller data sets.">More Users Querying the System</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" title="You can perform complex queries faster using smaller data sets.">More Complex Queries</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1339"></a><div class="props_rev_3"><a id="GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" name="GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB"></a><h4 id="VLDBG-GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" class="sect4">Bigger Databases</h4>
                  <div>
                     <p>The ability to split a large database object into smaller pieces transparently simplifies efficient management of very large databases.</p>
                     <p>You can identify and manipulate individual partitions and subpartitions to manage large database objects. Consider the following advantages of partitioned objects:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Backup and recovery can be performed on a low level of granularity to manage the size of the database.</p>
                        </li>
                        <li>
                           <p>Part of a database object can be placed in compressed storage while other parts can remain uncompressed.</p>
                        </li>
                        <li>
                           <p>Partitioning can store data transparently on different storage tiers to lower the cost of retaining vast amounts of data. For more information, refer to <a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle Database provides strategies to manage and maintain data based on time.">Managing and Maintaining Time-Based Information</a>.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1340"></a><div class="props_rev_3"><a id="GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" name="GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918"></a><h4 id="VLDBG-GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" class="sect4">Bigger Individual Tables: More Rows in Tables</h4>
                  <div>
                     <p>It takes longer to scan a big table than it takes to scan a small table. Queries against partitioned tables may access one or more partitions that are small in contrast to the total size of the table.</p>
                     <p>Similarly, queries may take advantage of partition elimination on indexes. It takes less time to read a smaller portion of an index from disk than to read the entire index. Index structures that share the partitioning strategy with the table, such as local partitioned indexes, can be accessed and maintained on a partition-by-partition basis.</p>
                     <p>The database can take advantage of the distinct data sets in separate partitions if you use parallel execution to speed up queries, DML, and DDL statements. Individual parallel execution servers can work on their own data sets, identified by the partition boundaries.</p>
                  </div>
               </div><a id="VLDBG1341"></a><div class="props_rev_3"><a id="GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" name="GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643"></a><h4 id="VLDBG-GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" class="sect4">More Users Querying the System</h4>
                  <div>
                     <p>With partitioning, users are more likely to query on isolated and smaller data sets.</p>
                     <p>Consequently, the database can return results faster than if all users queried the same and much larger data sets. Data contention is less likely.</p>
                  </div>
               </div><a id="VLDBG1342"></a><div class="props_rev_3"><a id="GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" name="GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221"></a><h4 id="VLDBG-GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" class="sect4">More Complex Queries</h4>
                  <div>
                     <p>You can perform complex queries faster using smaller data sets.</p>
                     <p>If smaller data sets are being accessed, then complex calculations are more likely to be processed in memory, which is beneficial from a performance perspective and reduces the application's I/O requirements. A larger data set may have to be written to the temporary tablespace to complete a query, in which case additional I/O operations against the database storage occurs.</p>
                  </div>
               </div>
            </div><a id="VLDBG1343"></a><div class="props_rev_3"><a id="GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" name="GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1"></a><h3 id="VLDBG-GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" class="sect3">Partitioning for Performance in a Data Warehouse</h3>
               <div>
                  <p>Good performance is a requirement for a successful data warehouse. </p>
                  <p>Analyses run against the database should return within a reasonable amount of time, even if the queries access large amounts of data in tables that are terabytes in size. Partitioning increases the speed of data access and application processing, which results in successful data warehouses that are not prohibitively expensive.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" title="Partition pruning is an essential performance feature for data warehouses.">Partition Pruning in a Data Warehouse</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" title="Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel.">Partition-Wise Joins in a Data Warehouse</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" title="Indexes are optional structures associated with tables that allow SQL statements to execute more quickly against a table.">Indexes and Partitioned Indexes in a Data Warehouse</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" title="One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations before execution and storing the results in a table in the database.">Materialized Views and Partitioning in a Data Warehouse</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1344"></a><div class="props_rev_3"><a id="GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" name="GUID-A3C2D796-C396-4FDB-88EB-5C5455033394"></a><h4 id="VLDBG-GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" class="sect4">Partition Pruning in a Data Warehouse</h4>
                  <div>
                     <p>Partition pruning is an essential performance feature for data warehouses.</p>
                     <p>In partition pruning, the optimizer analyzes <code class="codeph">FROM</code> and <code class="codeph">WHERE</code> clauses in SQL statements to eliminate unneeded partitions when building the partition access list. As a result, Oracle Database performs operations only on those partitions that are relevant to the SQL statement.
                     </p>
                     <p>Partition pruning dramatically reduces the amount of data retrieved from disk and shortens processing time, thus improving query performance and optimizing resource utilization.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" title="The optimizer uses a wide variety of predicates for pruning.">Basic Partition Pruning Techniques</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" title="Oracle Database pruning feature effectively handles more complex predicates or SQL statements that involve partitioned tables.">Advanced Partition Pruning Techniques</a></p>
                        </li>
                     </ul>
                     <p>For more information about partition pruning and the difference between static and dynamic partition pruning, refer to <a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="Partitioning enables availability, manageability, and performance.">Partitioning for Availability, Manageability, and Performance</a>.
                     </p>
                  </div><a id="VLDBG1345"></a><div class="props_rev_3"><a id="GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" name="GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A"></a><h5 id="VLDBG-GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" class="sect5">Basic Partition Pruning Techniques</h5>
                     <div>
                        <p>The optimizer uses a wide variety of predicates for pruning.</p>
                        <p>The three predicate types, equality, range, and <code class="codeph">IN</code>-list, are the predicates most commonly used for partition pruning. As an example, consider the following query:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT SUM(amount_sold) day_sales
FROM sales
WHERE time_id = TO_DATE('02-JAN-1998', 'DD-MON-YYYY');
</pre><p>Because there is an equality predicate on the partitioning column of <code class="codeph">sales</code>, the query is pruned down to a single predicate and this is reflected in the following execution plan:
                        </p><pre class="oac_no_warn" dir="ltr">-----------------------------------------------------------------------------------------------
|  Id | Operation                | Name  | Rows| Bytes | Cost (%CPU)| Time     |Pstart| Pstop |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |       |     |       | 21 (100)   |          |      |       |
|   1 |  SORT AGGREGATE          |       | 1   | 13    |            |          |      |       |
|   2 |   PARTITION RANGE SINGLE |       | 485 | 6305  | 21 (10)    | 00:00:01 | 5    | 5     |
| * 3 |    TABLE ACCESS FULL     | SALES | 485 | 6305  | 21 (10)    | 00:00:01 | 5    | 5     |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
  3 - filter("TIME_ID"=TO_DATE('1998-01-02 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
</pre><p>Similarly, a range or an <code class="codeph">IN</code>-list predicate on the <code class="codeph">time_id</code> column and the optimizer would be used to prune to a set of partitions. The partitioning type plays a role in which predicates can be used. Range predicates cannot be used for pruning on hash partitioned tables, but they can be used for all other partitioning strategies. However, on list-partitioned tables, range predicates may not map to a contiguous set of partitions. Equality and <code class="codeph">IN</code>-list predicates can prune with all the partitioning methods.
                        </p>
                     </div>
                  </div><a id="VLDBG1346"></a><div class="props_rev_3"><a id="GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" name="GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C"></a><h5 id="VLDBG-GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" class="sect5">Advanced Partition Pruning Techniques</h5>
                     <div>
                        <p>Oracle Database pruning feature effectively handles more complex predicates or SQL statements that involve partitioned tables.</p>
                        <p>A common situation is when a partitioned table is joined to the subset of another table, limited by a <code class="codeph">WHERE</code> condition. For example, consider the following query:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT t.day_number_in_month, SUM(s.amount_sold)
  FROM sales s, times t
  WHERE s.time_id = t.time_id
    AND t.calendar_month_desc='2000-12'
  GROUP BY t.day_number_in_month;
</pre><p>If the database performed a nested loop join with <code class="codeph">times</code> table on the right-hand side, then the query would access only the partition corresponding to this row from the <code class="codeph">times</code> table, so pruning would implicitly take place. But, if the database performed a hash or sort merge join, this would not be possible. If the table with the <code class="codeph">WHERE</code> predicate is relatively small compared to the partitioned table, and the expected reduction of records or partitions for the partitioned table is significant, then the database performs dynamic partition pruning using a recursive subquery. The decision whether to invoke subquery pruning is an internal cost-based decision of the optimizer.
                        </p>
                        <p>A sample execution plan using a hash join operation would look like the following:</p><pre class="oac_no_warn" dir="ltr">--------------------------------------------------------------------------------------------------
| Id| Operation                    |  Name |  Rows | Bytes| Cost (%CPU)|  Time  | Pstart | Pstop |
--------------------------------------------------------------------------------------------------
|  0| SELECT STATEMENT             |       |       |      | 761 (100)  |        |        |       |
|  1|  HASH GROUP BY               |       |    20 | 640  | 761 (41)   |00:00:10|        |       |
|* 2|   HASH JOIN                  |       | 19153 | 598K | 749 (40)   |00:00:09|        |       |
|* 3|    TABLE ACCESS FULL         | TIMES |    30 |  570 |  17 (6)    |00:00:01|        |       |
|  4|     PARTITION RANGE SUBQUERY |       |  918K | 11M  |   655 (33) |00:00:08| KEY(SQ)|KEY(SQ)|
|  5|      TABLE ACCESS FULL       | SALES |   918 | 11M  |   655 (33) |00:00:08| KEY(SQ)|KEY(SQ)|
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------
  2 - access("S"."TIME_ID"="T"."TIME_ID") 
  3 - filter("T"."CALENDAR_MONTH_DESC"='2000-12')
</pre><p>This execution plan shows that dynamic partition pruning occurred on the <code class="codeph">sales</code> table using a subquery, as shown by the <code class="codeph">KEY(SQ)</code> value in the <code class="codeph">PSTART</code> and <code class="codeph">PSTOP</code> columns.
                        </p>
                        <p>The following is an example of advanced pruning using an <code class="codeph">OR</code> predicate.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.promo_name promo_name, (s.profit - p.promo_cost) profit
FROM
   promotions p,
   ( SELECT
      sales.promo_id,
      SUM(sales.QUANTITY_SOLD * (costs.UNIT_PRICE - costs.UNIT_COST)) profit
   FROM
      sales, costs
   WHERE
      ((sales.time_id BETWEEN TO_DATE('01-JAN-1998','DD-MON-YYYY',
                  'NLS_DATE_LANGUAGE = American') AND
      TO_DATE('01-JAN-1999','DD-MON-YYYY', 'NLS_DATE_LANGUAGE = American')
   OR
      (sales.time_id BETWEEN TO_DATE('01-JAN-2001','DD-MON-YYYY',
                  'NLS_DATE_LANGUAGE = American') AND
      TO_DATE('01-JAN-2002','DD-MON-YYYY', 'NLS_DATE_LANGUAGE = American')))
      AND sales.time_id = costs.time_id
      AND sales.prod_id = costs.prod_id)
   GROUP BY
      sales.promo_id) s
WHERE s.promo_id = p.promo_id
ORDER BY profit
DESC;
</pre><p>This query joins the <code class="codeph">sales</code> and <code class="codeph">costs</code> tables. The <code class="codeph">sales</code> table is partitioned by range on the column <code class="codeph">time_id</code>. One condition in the query is two predicates on <code class="codeph">time_id</code>, which are combined with an <code class="codeph">OR</code> operator. This <code class="codeph">OR</code> predicate is used to prune the partitions in the <code class="codeph">sales</code> table and a single join between the <code class="codeph">sales</code> and <code class="codeph">costs</code> table is performed. The execution plan is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">--------------------------------------------------------------------------------------------------
| Id| Operation               |  Name    |Rows |Bytes |TmpSp|Cost(%CPU)| Time    | Pstart| Pstop |
--------------------------------------------------------------------------------------------------
|  0| SELECT STATEMENT        |          | 4   |  200 |     | 3556 (14)| 00:00:43|       |       |
|  1|  SORT ORDER BY          |          | 4   |  200 |     | 3556 (14)| 00:00:43|       |       |
|* 2|   HASH JOIN             |          | 4   |  200 |     | 3555 (14)| 00:00:43|       |       |
|  3|    TABLE ACCESS FULL    |PROMOTIONS| 503 | 16599|     |    16 (0)| 00:00:01|       |       |
|  4|    VIEW                 |          |   4 |   68 |     | 3538 (14)| 00:00:43|       |       |
|  5|     HASH GROUP BY       |          |   4 |  164 |     | 3538 (14)| 00:00:43|       |       |
|  6|      PARTITION RANGE OR |          | 314K|   12M|     |  3321 (9)| 00:00:40|KEY(OR)|KEY(OR)|
|* 7|       HASH JOIN         |          | 314K|   12M| 440K|  3321 (9)| 00:00:40|       |       |
|* 8|        TABLE ACCESS FULL| SALES    | 402K| 7467K|     |  400 (39)| 00:00:05|KEY(OR)|KEY(OR)|
|  9| TABLE ACCESS FULL       | COSTS    |82112| 1764K|     |   77 (24)| 00:00:01|KEY(OR)|KEY(OR)|
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
  2 - access("S"."PROMO_ID"="P"."PROMO_ID") 
  7 - access("SALES"."TIME_ID"="COSTS"."TIME_ID" AND "SALES"."PROD_ID"="COSTS"."PROD_ID") 
  8 - filter("SALES"."TIME_ID"&lt;=TO_DATE('1999-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') AND 
      "SALES"."TIME_ID"&gt;=TO_DATE('1998-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') OR 
      "SALES"."TIME_ID"&gt;=TO_DATE('2001-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') AND 
      "SALES"."TIME_ID"&lt;=TO_DATE('2002-01-01 00:00:00', 'yyyy-mm-dd hh24:mi:ss'))
</pre><p>The database also does additional pruning when a column is range-partitioned on multiple columns. As long as the database can guarantee that a particular predicate cannot be satisfied in a particular partition, the partition is skipped. This allows the database to optimize cases where there are range predicates on multiple columns or in the case where there are no predicates on a prefix of the partitioning columns.</p>
                        <p>For tips on partition pruning, refer to <a href="partition-pruning.html#GUID-6C660105-8ECE-4426-A795-5884E84B0A48" title="Tips for partition pruning are introduced in this topic.">Partition Pruning Tips</a>.
                        </p>
                     </div>
                  </div>
               </div><a id="VLDBG1347"></a><div class="props_rev_3"><a id="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" name="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB"></a><h4 id="VLDBG-GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" class="sect4">Partition-Wise Joins in a Data Warehouse</h4>
                  <div>
                     <p>Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. </p>
                     <p>Using partition-wise joins significantly reduces response time and improves the use of both CPU and memory resources. Parallel partition-wise joins are used commonly for processing large joins efficiently and fast. Partition-wise joins can be full or partial. Oracle Database decides which type of join to use.</p>
                     <p>In addition to parallel partition-wise joins, queries using the <code class="codeph">SELECT</code> <code class="codeph">DISTINCT</code> clause and SQL window functions can perform parallel partition-wise operations.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" title="Full partition-wise joins can occur if two tables that are co-partitioned on the same key are joined in a query.">Full Partition-Wise Joins</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-956E0532-BD25-44C6-B986-9D345BBAF663" title="Oracle Database can perform partial partition-wise joins only in parallel.">Partial Partition-Wise Joins</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" title="Partition-wise joins offers several benefits.">Benefits of Partition-Wise Joins</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" title="The optimizer weighs the advantages and disadvantages when deciding whether to use partition-wise joins.">Performance Considerations for Parallel Partition-Wise Joins</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB__FORADDITIONALINFORMATIONABOUTPARTIT-FB67663B">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="partition-wise-joins.html#GUID-7C28CD29-5189-4A53-9691-380E13515015" title="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">Partition-Wise Operations</a> for additional information about partition-wise operations
                              </p>
                           </li>
                           <li>
                              <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG-GUID-79C29A60-3477-448D-835D-2940D060D050" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for information about data warehousing and optimization techniques
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="VLDBG1348"></a><div class="props_rev_3"><a id="GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" name="GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61"></a><h5 id="VLDBG-GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" class="sect5">Full Partition-Wise Joins</h5>
                     <div>
                        <p>Full partition-wise joins can occur if two tables that are co-partitioned on the same key are joined in a query.</p>
                        <p>The tables can be co-partitioned at the partition level, or at the subpartition level, or at a combination of partition and subpartition levels. Reference partitioning is an easy way to guarantee co-partitioning. Full partition-wise joins can be executed serially and in parallel.</p>
                        <p>For more information about partition-wise joins, refer to <a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="Partitioning enables availability, manageability, and performance.">Partitioning for Availability, Manageability, and Performance</a>.
                        </p>
                        <p>The following example shows a full partition-wise join on the <code class="codeph">orders</code> and <code class="codeph">order_items</code> tables, in which the <code class="codeph">order_items</code> table is reference-partitioned.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders
( order_id     NUMBER(12) NOT NULL
, order_date   DATE NOT NULL
, order_mode   VARCHAR2(8)
, order_status VARCHAR2(1)
, CONSTRAINT orders_pk PRIMARY KEY (order_id)
)
PARTITION BY RANGE (order_date)
( PARTITION p_before_jan_2006 VALUES LESS THAN (TO_DATE('01-JAN-2006','dd-MON-yyyy'))
, PARTITION p_2006_jan VALUES LESS THAN (TO_DATE('01-FEB-2006','dd-MON-yyyy'))
, PARTITION p_2006_feb VALUES LESS THAN (TO_DATE('01-MAR-2006','dd-MON-yyyy'))
, PARTITION p_2006_mar VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
, PARTITION p_2006_apr VALUES LESS THAN (TO_DATE('01-MAY-2006','dd-MON-yyyy'))
, PARTITION p_2006_may VALUES LESS THAN (TO_DATE('01-JUN-2006','dd-MON-yyyy'))
, PARTITION p_2006_jun VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
, PARTITION p_2006_jul VALUES LESS THAN (TO_DATE('01-AUG-2006','dd-MON-yyyy'))
, PARTITION p_2006_aug VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
, PARTITION p_2006_sep VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
, PARTITION p_2006_oct VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
, PARTITION p_2006_nov VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
, PARTITION p_2006_dec VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
)
PARALLEL;

CREATE TABLE order_items
( order_id NUMBER(12) NOT NULL
, product_id NUMBER NOT NULL
, quantity NUMBER NOT NULL
, sales_amount NUMBER NOT NULL
, CONSTRAINT order_items_orders_fk FOREIGN KEY (order_id) REFERENCES 
orders(order_id)
)
PARTITION BY REFERENCE (order_items_orders_fk)
PARALLEL;
</pre><p>A typical data warehouse query would scan a large amount of data. In the underlying execution plan, the columns <code class="codeph">Rows</code>, <code class="codeph">Bytes</code>, <code class="codeph">Cost (%CPU)</code>, <code class="codeph">Time</code>, and <code class="codeph">TQ</code> have been removed.
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT o.order_date
, sum(oi.sales_amount) sum_sales
FROM orders o
, order_items oi
WHERE o.order_id = oi.order_id
AND o.order_date BETWEEN TO_DATE('01-FEB-2006','DD-MON-YYYY')
                     AND TO_DATE('31-MAY-2006','DD-MON-YYYY')
GROUP BY o.order_id
, o.order_date
ORDER BY o.order_date;

---------------------------------------------------------------------------------------------
| Id  | Operation                         | Name        | Pstart| Pstop |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |             |       |       |      |            |
|   1 |  PX COORDINATOR                   |             |       |       |      |            |
|   2 |   PX SEND QC (ORDER)              | :TQ10001    |       |       | P-&gt;S | QC (ORDER) |
|   3 |    SORT GROUP BY                  |             |       |       | PCWP |            |
|   4 |     PX RECEIVE                    |             |       |       | PCWP |            |
|   5 |      PX SEND RANGE                | :TQ10000    |       |       | P-&gt;P | RANGE      |
|   6 |       SORT GROUP BY               |             |       |       | PCWP |            |
|   7 |        PX PARTITION RANGE ITERATOR|             |     3 |     6 | PCWC |            |
|*  8 |         HASH JOIN                 |             |       |       | PCWP |            |
|*  9 |          TABLE ACCESS FULL        | ORDERS      |     3 |     6 | PCWP |            |
|  10 |          TABLE ACCESS FULL        | ORDER_ITEMS |     3 |     6 | PCWP |            |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("O"."ORDER_ID"="OI"."ORDER_ID")
   9 - filter("O"."ORDER_DATE"&lt;=TO_DATE(' 2006-05-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre></div>
                  </div><a id="VLDBG1349"></a><div class="props_rev_3"><a id="GUID-956E0532-BD25-44C6-B986-9D345BBAF663" name="GUID-956E0532-BD25-44C6-B986-9D345BBAF663"></a><h5 id="VLDBG-GUID-956E0532-BD25-44C6-B986-9D345BBAF663" class="sect5">Partial Partition-Wise Joins</h5>
                     <div>
                        <p>Oracle Database can perform partial partition-wise joins only in parallel.</p>
                        <p>Unlike full partition-wise joins, partial partition-wise joins require you to partition only one table on the join key, not both tables. The partitioned table is referred to as the reference table. The other table may or may not be partitioned. Partial partition-wise joins are more common than full partition-wise joins.</p>
                        <p>To execute a partial partition-wise join, the database dynamically partitions or repartitions the other table based on the partitioning of the reference table. After the other table is repartitioned, the execution is similar to a full partition-wise join.</p>
                        <p>The following example shows a call detail records table, <code class="codeph">cdrs</code>, in a typical data warehouse scenario. The table is interval-hash partitioned.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE cdrs
( id                 NUMBER
, cust_id            NUMBER
, from_number        VARCHAR2(20)
, to_number          VARCHAR2(20)
, date_of_call       DATE
, distance           VARCHAR2(1)
, call_duration_in_s NUMBER(4)
) PARTITION BY RANGE(date_of_call)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY HASH(cust_id)
SUBPARTITIONS 16
(PARTITION p0 VALUES LESS THAN (TO_DATE('01-JAN-2005','dd-MON-yyyy')))
PARALLEL;
</pre><p>The <code class="codeph">cdrs</code> table is joined with the nonpartitioned <code class="codeph">callers</code> table on the <code class="codeph">cust_id</code> column to rank the customers who spent the most time making calls.
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT c.cust_id
,      c.cust_last_name
,      c.cust_first_name
,      AVG(call_duration_in_s)
,      COUNT(1)
,      DENSE_RANK() OVER
       (ORDER BY (AVG(call_duration_in_s) * COUNT(1)) DESC) ranking
FROM   callers c
,      cdrs    cdr
WHERE cdr.cust_id = c.cust_id
AND cdr.date_of_call BETWEEN TO_DATE('01-JAN-2006','dd-MON-yyyy')
                         AND TO_DATE('31-DEC-2006','dd-MON-yyyy')  
GROUP BY c.cust_id
, c.cust_last_name
, c.cust_first_name
ORDER BY ranking;
</pre><p>The execution plans shows a partial partition-wise join. In the plan, the columns <code class="codeph">Rows</code>, <code class="codeph">Bytes</code>, <code class="codeph">Cost (%CPU)</code>, <code class="codeph">Time</code>, and <code class="codeph">TQ</code> have been removed.
                        </p><pre class="oac_no_warn" dir="ltr">--------------------------------------------------------------------------------------------
| Id  | Operation                           | Name     | Pstart| Pstop |IN-OUT| PQ Distrib |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |          |       |       |      |            |
|   1 |  WINDOW NOSORT                      |          |       |       |      |            |
|   2 |   PX COORDINATOR                    |          |       |       |      |            |
|   3 |    PX SEND QC (ORDER)               | :TQ10002 |       |       | P-&gt;S | QC (ORDER) |
|   4 |     SORT ORDER BY                   |          |       |       | PCWP |            |
|   5 |      PX RECEIVE                     |          |       |       | PCWP |            |
|   6 |       PX SEND RANGE                 | :TQ10001 |       |       | P-&gt;P | RANGE      |
|   7 |        HASH GROUP BY                |          |       |       | PCWP |            |
|*  8 |         HASH JOIN                   |          |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE    | :BF0000  |       |       | PCWP |            |
|  10 |           BUFFER SORT               |          |       |       | PCWC |            |
|  11 |            PX RECEIVE               |          |       |       | PCWP |            |
|  12 |             PX SEND PARTITION (KEY) | :TQ10000 |       |       | S-&gt;P | PART (KEY) |
|  13 |              TABLE ACCESS FULL      | CALLERS  |       |       |      |            |
|  14 |          PX PARTITION RANGE ITERATOR|          |   367 |   731 | PCWC |            |
|  15 |           PX PARTITION HASH ALL     |          |     1 |    16 | PCWC |            |
|* 16 |            TABLE ACCESS FULL        | CDRS     |  5857 | 11696 | PCWP |            |
--------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("CDR"."CUST_ID"="C"."CUST_ID")
  16 - filter("CDR"."DATE_OF_CALL"&gt;=TO_DATE(' 2006-01-01 00:00:00', 'syyyy-mm-dd 
hh24:mi:ss') AND "CDR"."DATE_OF_CALL"&lt;=TO_DATE('
              2006-12-31 00:00:00', 'syyyy-mm-dd hh24:mi:ss'))</pre></div>
                  </div><a id="VLDBG1350"></a><div class="props_rev_3"><a id="GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" name="GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE"></a><h5 id="VLDBG-GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" class="sect5">Benefits of Partition-Wise Joins</h5>
                     <div>
                        <p>Partition-wise joins offers several benefits.</p>
                        <p>These benefits are described in the following topics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="partition-warehouse.html#GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" title="When executed in parallel, partition-wise joins reduce communications overhead.">Reduction of Communications Overhead</a></p>
                           </li>
                           <li>
                              <p><a href="partition-warehouse.html#GUID-CAB00836-9030-4C55-AC55-F64345C57826" title="Partition-wise joins require less memory than the equivalent join operation of the complete data set of the tables being joined.">Reduction of Memory Requirements</a></p>
                           </li>
                        </ul>
                     </div><a id="VLDBG1351"></a><div class="props_rev_3"><a id="GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" name="GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1"></a><h6 id="VLDBG-GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" class="sect6">Reduction of Communications Overhead</h6>
                        <div>
                           <p>When executed in parallel, partition-wise joins reduce communications overhead.</p>
                           <p>This reduction, in the default case, occurs because parallel execution of a join operation by a set of parallel execution servers requires the redistribution of each table on the join column into disjoint subsets of rows. These disjoint subsets of rows are then joined pair-wise by a single parallel execution server.</p>
                           <p>The database can avoid redistributing the partitions because the two tables are partitioned on the join column. This functionality enables each parallel execution server to join a pair of matching partitions. This improved performance from using parallel execution is even more noticeable in Oracle Real Application Clusters configurations with internode parallel execution.</p>
                           <p>Partition-wise joins dramatically reduce interconnect traffic. Using this feature is key for large decision support systems (DSS) configurations that use Oracle Real Application Clusters. Currently, most Oracle Real Application Clusters platforms, such as massively parallel processing (MPP) and symmetric multiprocessing (SMP) clusters, provide limited interconnect bandwidths compared to their processing powers. Ideally, interconnect bandwidth should be comparable to disk bandwidth, but this is seldom the case. Consequently, most join operations in Oracle Real Application Clusters experience high interconnect latencies without parallel execution of partition-wise joins.</p>
                        </div>
                     </div><a id="VLDBG1352"></a><div class="props_rev_3"><a id="GUID-CAB00836-9030-4C55-AC55-F64345C57826" name="GUID-CAB00836-9030-4C55-AC55-F64345C57826"></a><h6 id="VLDBG-GUID-CAB00836-9030-4C55-AC55-F64345C57826" class="sect6">Reduction of Memory Requirements</h6>
                        <div>
                           <p>Partition-wise joins require less memory than the equivalent join operation of the complete data set of the tables being joined.</p>
                           <p>For serial joins, the join is performed at the same time on a pair of matching partitions. If data is evenly distributed across partitions, then the memory requirement is divided by the number of partitions and there is no skew to the data distribution among the parallel servers.</p>
                           <p>For parallel joins, memory requirements depend on the number of partition pairs that are joined in parallel. For example, if the degree of parallelism is 20 and the number of partitions is 100, then 5 times less memory is required because only 20 joins of two partitions each are performed at the same time. The fact that partition-wise joins require less memory has a direct beneficial effect on performance. For example, the join probably does not need to write blocks to disk during the build phase of a hash join.</p>
                        </div>
                     </div>
                  </div><a id="VLDBG1353"></a><div class="props_rev_3"><a id="GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" name="GUID-236EECB8-50DB-4CE3-A755-45080AFF4428"></a><h5 id="VLDBG-GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" class="sect5">Performance Considerations for Parallel Partition-Wise Joins</h5>
                     <div>
                        <p>The optimizer weighs the advantages and disadvantages when deciding whether to use partition-wise joins.</p>
                        <p>The optimizer chooses whether to use partition-wise joins based on the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>In range partitioning where partition sizes differ, data skew increases response time; some parallel execution servers take longer than others to finish their joins. Oracle recommends the use of hash partitioning and subpartitioning to enable partition-wise joins because hash partitioning, if the number of partitions is a power of two, limits the risk of skew. Ideally, the hash partitioning key is unique to minimize the risk of skew.</p>
                           </li>
                           <li>
                              <p>The number of partitions used for partition-wise joins should, if possible, be a multiple of the number of query servers. With a degree of parallelism of 16, for example, you can have 16, 32, or even 64 partitions. If there is an odd number of partitions, then some parallel execution servers are used less than others. For example, if there are 17 evenly distributed partition pairs, only one pair works on the last join, while the other pair has to wait. This is because, in the beginning of the execution, each parallel execution server works on a different partition pair. After this first phase, only one pair remains. Thus, a single parallel execution server joins this remaining pair while all other parallel execution servers are idle.</p>
                           </li>
                        </ul>
                        <p>In some situations, parallel joins can cause remote I/O operations. For example, on Oracle Real Application Clusters environments running on MPP configurations, if a pair of matching partitions is not collocated on the same node, a partition-wise join requires extra internode communication due to remote I/O. This is because Oracle Database must transfer at least one partition to the node where the join is performed. In this case, it is better to explicitly redistribute the data than to use a partition-wise join.</p>
                     </div>
                  </div>
               </div><a id="VLDBG1354"></a><div class="props_rev_3"><a id="GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" name="GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B"></a><h4 id="VLDBG-GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" class="sect4">Indexes and Partitioned Indexes in a Data Warehouse</h4>
                  <div>
                     <p>Indexes are optional structures associated with tables that allow SQL statements to execute more quickly against a table. </p>
                     <p>Even though table scans are very common in many data warehouses, indexes can often speed up queries.</p>
                     <p>Both B-tree and bitmap indexes can be created as local indexes on a partitioned table, in which case they inherit the table's partitioning strategy. B-tree indexes can be created as global partitioned indexes on partitioned and nonpartitioned tables.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" title="In a local index, all keys in a particular index partition refer only to rows stored in a single underlying table partition.">Local Partitioned Indexes</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" title="You can create nonpartitioned indexes on nonpartitioned and partitioned tables.">Nonpartitioned Indexes</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" title="You can create global partitioned indexes on nonpartitioned and partitioned tables.">Global Partitioned Indexes</a></p>
                        </li>
                     </ul>
                     <p>For more information about partitioned indexes, refer to <a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="Partitioning enables availability, manageability, and performance.">Partitioning for Availability, Manageability, and Performance</a>.
                     </p>
                  </div><a id="VLDBG1355"></a><div class="props_rev_3"><a id="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" name="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99"></a><h5 id="VLDBG-GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" class="sect5">Local Partitioned Indexes</h5>
                     <div>
                        <p>In a local index, all keys in a particular index partition refer only to rows stored in a single underlying table partition. </p>
                        <p>A local index is equipartitioned with the underlying table. Oracle Database partitions the index on the same columns as the underlying table, creates the same number of partitions or subpartitions, and gives them the same partition boundaries as corresponding partitions of the underlying table.</p>
                        <p>Oracle Database also maintains the index partitioning automatically when partitions in the underlying table are added, dropped, merged, or split, or when hash partitions or subpartitions are added or coalesced. This ensures that the index remains equipartitioned with the table.</p>
                        <p>For data warehouse applications, local nonprefixed indexes can improve performance because many index partitions can be scanned in parallel by range queries on the index key. The following example creates a local B-tree index on a partitioned <code class="codeph">customers_dw</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX cust_last_name_ix
 ON customers_dw(last_name) LOCAL
 PARALLEL NOLOGGING ;
</pre><p>Bitmap indexes use a very efficient storage mechanism for low cardinality columns. Bitmap indexes are used in data warehouses, and especially common in data warehouses that implement <span class="italic">star</span> <span class="italic">schemas</span>. A single star schema consists of a central large fact table and multiple smaller dimension tables that describe the data in the fact table.
                        </p>
                        <p>For example, consider a <code class="codeph">sales</code> table that is a fact table, described by dimension tables <code class="codeph">customers</code>, <code class="codeph">products</code>, <code class="codeph">promotions</code>, <code class="codeph">times</code>, and <code class="codeph">channels</code>. Bitmap indexes enable the star transformation, an optimization for fast query retrieval against star or star look-a-like schemas.
                        </p>
                        <p>Fact table foreign key columns are ideal candidates for bitmap indexes, because generally there are few distinct values relative to the total number of rows. Fact tables are often range or range-* partitioned, in which case you must create local bitmap indexes. Global bitmap indexes on partitioned tables are not supported.</p>
                        <p>The following example creates a local partitioned bitmap index on the <code class="codeph">sales</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX prod_id_ix
ON sales(prod_id) LOCAL
PARALLEL NOLOGGING;
</pre><div class="infoboxnotealso" id="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99__GUID-8E633CB8-D003-446C-9FE3-051D8C718449">
                           <p class="notep1">See Also:</p>
                           <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG8593" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for more information about the star transformation
                           </p>
                        </div>
                     </div>
                  </div><a id="VLDBG1356"></a><div class="props_rev_3"><a id="GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" name="GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9"></a><h5 id="VLDBG-GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" class="sect5">Nonpartitioned Indexes</h5>
                     <div>
                        <p>You can create nonpartitioned indexes on nonpartitioned and partitioned tables.</p>
                        <p>Nonpartitioned indexes are primarily used on nonpartitioned tables in data warehouse environments and in general to enforce uniqueness if the status of a unique constraint is required to be enforced in a data warehousing environment. You can use a nonpartitioned global index on a partitioned table to enforce a primary or unique key. A nonpartitioned (global) index can be useful for queries that commonly retrieve very few rows based on equality predicates or <code class="codeph">IN</code>-list on a column or set of columns that is not included in the partitioning key. In those cases, it can be faster to scan a single index than to scan many index partitions to find all matching rows.
                        </p>
                        <p>Unique indexes on columns other than the partitioning columns must be global because unique local nonprefixed indexes whose keys do not contain the partitioning keys are not supported. Unique keys are not always enforced in data warehouses due to the controlled data load processes and the performance cost of enforcing the unique constraint. Global indexes can grow very large on tables with billions of rows.</p>
                        <p>The following example creates a global unique index on the <code class="codeph">sales</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE UNIQUE INDEX sales_unique_ix
  ON sales(cust_id, prod_id, promo_id, channel_id, time_id)
  PARALLEL NOLOGGING;
</pre><p>Very few queries benefit from this index. In systems with a very limited data load window, consider not creating and maintaining it.</p>
                     </div>
                  </div><a id="VLDBG1357"></a><div class="props_rev_3"><a id="GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" name="GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25"></a><h5 id="VLDBG-GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" class="sect5">Global Partitioned Indexes</h5>
                     <div>
                        <p>You can create global partitioned indexes on nonpartitioned and partitioned tables. </p>
                        <p>In a global partitioned index, the keys in a particular index partition may refer to rows stored in multiple underlying table partitions or subpartitions. A global index can be range or hash partitioned, though it can be defined on any type of partitioned table.</p>
                        <p>A global index is created by specifying the <code class="codeph">GLOBAL</code> attribute. The database administrator is responsible for defining the initial partitioning of a global index at creation and for maintaining the partitioning over time. Index partitions can be merged or split as necessary.
                        </p>
                        <p>Global indexes can be useful if there is a class of queries that uses an access path to the table to retrieve a few rows through an index, and by partitioning the index you can eliminate large portions of the index for the majority of its queries. On a partitioned table, you would consider a global partitioned index if the column or columns included to achieve partition pruning do not include the table partitioning key.</p>
                        <p>The following example creates a global hash partitioned index on the <code class="codeph">sales</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX cust_id_prod_id_global_ix
ON sales(cust_id,prod_id)
GLOBAL PARTITION BY HASH (cust_id)
( PARTITION p1 TABLESPACE tbs1
, PARTITION p2 TABLESPACE tbs2
, PARTITION p3 TABLESPACE tbs3
, PARTITION p4 TABLESPACE tbs4
)
PARALLEL NOLOGGING;</pre></div>
                  </div>
               </div><a id="VLDBG1359"></a><div class="sect3"><a id="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" name="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88"></a><h4 id="VLDBG-GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" class="sect4">Materialized Views and Partitioning in a Data Warehouse</h4>
                  <div>
                     <p>One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations before execution and storing the results in a table in the database. </p>
                     <p>For example, you can create a summary table to contain the sums of sales by region and by product.</p>
                     <p>The summaries or aggregates that are referred to in this guide and in literature on data warehousing are created in Oracle Database using a schema object called a materialized view. Materialized views in a data warehouse speed up query performance.</p>
                     <p>The database supports transparent rewrites against materialized views, so that you do not need to modify the original queries to take advantage of precalculated results in materialized views. Instead of executing the query, the database retrieves precalculated results from one or more materialized views, performs any necessary additional operations on the data, and returns the query results.</p>
                     <div class="infoboxnotealso" id="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88__GUID-28535BE6-628D-4082-9A4A-C2FFC090CE4D">
                        <p class="notep1">See Also:</p>
                        <p><a href="../dwhsg/basic-materialized-views.html#DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for information about data warehousing and materialized views
                        </p>
                     </div>
                  </div><a id="VLDBG14081"></a><a id="VLDBG1360"></a><div class="props_rev_3"><a id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1" name="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1"></a><h5 id="VLDBG-GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1" class="sect5">Partitioned Materialized Views</h5>
                     <div>
                        <p>The underlying storage for a materialized view is a table structure. You can partition materialized views like you can partition tables. </p>
                        <p>When the database rewrites a query to run against materialized views, the query can take advantage of the same performance features from which queries running against tables directly benefit. The rewritten query may eliminate materialized view partitions. If joins back to tables or with other materialized views are necessary to retrieve the query result, then the rewritten query can take advantage of partition-wise joins.</p>
                        <p><a href="partition-warehouse.html#GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__CHDHDFFE">Example 6-1</a> shows how to create a compressed partitioned materialized view that aggregates sales results to country level. This materialized view benefits from queries that summarize sales numbers by country level or higher to subregion or region level.
                        </p>
                        <div class="example" id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__CHDHDFFE">
                           <p class="titleinexample">Example 6-1 Creating a compressed partitioned materialized view</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW country_sales
PARTITION BY HASH (country_id)
PARTITIONS 16
COMPRESS FOR OLTP
PARALLEL NOLOGGING
ENABLE QUERY REWRITE
AS SELECT co.country_id
, co.country_name
, co.country_subregion
, co.country_region
, sum(sa.quantity_sold) country_quantity_sold
, sum(sa.amount_sold) country_amount_sold
FROM sales sa
, customers cu
, countries co
WHERE sa.cust_id = cu.cust_id
AND cu.country_id = co.country_id
GROUP BY co.country_id
, co.country_name
, co.country_subregion
, co.country_region;
</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__GUID-0D90B21B-BA18-4C0B-B115-975BFFAC8071">
                              <p class="notep1">See Also:</p>
                              <p><a href="../dwhsg/basic-materialized-views.html#DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for information about data warehousing and materialized views
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG00504"></a><div class="props_rev_3"><a id="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" name="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF"></a><h3 id="VLDBG-GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" class="sect3">Manageability in a Data Warehouse</h3>
               <div>
                  <p>Data warehouses store historical data. Important parts of a data warehouse are the data loading and purging. Partitioning is powerful technology that can help data management for data warehouses.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" title="Partitions can be added using partition exchange load (PEL).">Partition Exchange Load</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" title="Partition maintenance operations are most easily performed on local indexes.">Partitioning and Indexes</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" title="Data warehouses commonly keep a time window of data. For example, three years of historical data is stored.">Removing Data from Tables</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" title="Data in a partitioned table can be compressed on a partition-by-partition basis.">Partitioning and Data Compression</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF__GUID-B1730163-A77B-4B31-A6F5-187024303F4A">
                     <p class="notep1">See Also:</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/vldbg&amp;id=TGSQL335" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> for information about collecting and managing statistics on partitioned indexes, exchanges, and tables
                     </p>
                  </div>
               </div><a id="VLDBG1361"></a><div class="props_rev_3"><a id="GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" name="GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8"></a><h4 id="VLDBG-GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" class="sect4">Partition Exchange Load</h4>
                  <div>
                     <p>Partitions can be added using partition exchange load (PEL).</p>
                     <p>When you use PEL, you create a separate table that looks exactly like a single partition, including the same indexes and constraints, if any. If you use a composite partitioned table, then your separate table must use a partitioning strategy that matches the subpartitioning strategy of your composite partitioned table. You can then exchange an existing table partition with this separate table. In a data load scenario, data can be loaded into the separate table. Build indexes and implement constraints on the separate table, without impacting the table users query. Then perform the PEL, which is a very low-impact transaction compared to the data load. Daily loads, with a range partition strategy by day, are common in data warehouse environments.</p>
                     <p>The following example shows a partition exchange load for the <code class="codeph">sales</code> table:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD PARTITION p_sales_jun_2007
VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy'));

CREATE TABLE sales_jun_2007 COMPRESS FOR OLTP
AS SELECT * FROM sales WHERE 1=0;
</pre><p>Next, populate table <code class="codeph">sales_jun_2007</code> with sales numbers for June 2007, and create the equivalent bitmap indexes and constraints that have been implemented on the <code class="codeph">sales</code> table:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX time_id_jun_2007_bix ON sales_jun_2007(time_id) NOLOGGING;
CREATE BITMAP INDEX cust_id_jun_2007_bix ON sales_jun_2007(cust_id) NOLOGGING;
CREATE BITMAP INDEX prod_id_jun_2007_bix ON sales_jun_2007(prod_id) NOLOGGING;
CREATE BITMAP INDEX promo_id_jun_2007_bix ON sales_jun_2007(promo_id) NOLOGGING;
CREATE BITMAP INDEX channel_id_jun_2007_bix ON sales_jun_2007(channel_id) NOLOGGING;

ALTER TABLE sales_jun_2007 ADD CONSTRAINT prod_id_fk FOREIGN KEY (prod_id) REFERENCES products(prod_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT cust_id_fk FOREIGN KEY (cust_id) REFERENCES customers(cust_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT promo_id_fk FOREIGN KEY (promo_id) REFERENCES promotions(promo_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT time_id_fk FOREIGN KEY (time_id) REFERENCES times(time_id);
ALTER TABLE sales_jun_2007 ADD CONSTRAINT channel_id_fk FOREIGN KEY (channel_id) REFERENCES channels(channel_id);
</pre><p>Next, exchange the partition:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
EXCHANGE PARTITION p_sales_jun_2007
WITH TABLE sales_jun_2007
INCLUDING INDEXES;
</pre><p>For more information about partition exchange load, refer to <a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="Partition administration is an important task when working with partitioned tables and indexes.">Partition Administration</a>.
                     </p>
                  </div>
               </div><a id="VLDBG1362"></a><div class="props_rev_3"><a id="GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" name="GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280"></a><h4 id="VLDBG-GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" class="sect4">Partitioning and Indexes</h4>
                  <div>
                     <p>Partition maintenance operations are most easily performed on local indexes. </p>
                     <p>Local indexes do not invalidate a global index when partition management takes place. Use <code class="codeph">INCLUDING INDEXES</code> in the PEL statement to exchange the local indexes with the equivalent indexes on the separate table so that no index partitions get invalidated. For PEL, you can update global indexes as part of the load. Use the <code class="codeph">UPDATE GLOBAL INDEXES</code> extension to the PEL statement. If an index requires updating, then the PEL takes much longer.
                     </p>
                  </div>
               </div><a id="VLDBG1364"></a><div class="props_rev_3"><a id="GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" name="GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89"></a><h4 id="VLDBG-GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" class="sect4">Removing Data from Tables</h4>
                  <div>
                     <p>Data warehouses commonly keep a time window of data. For example, three years of historical data is stored.</p>
                     <p>Partitioning makes it very easy to purge data from a table. You can use the <code class="codeph">DROP PARTITION</code> or <code class="codeph">TRUNCATE PARTITION</code> statements to purge data. Common strategies also include using a partition exchange load to unload the data from the table and replacing the partition with an empty table before dropping the partition. Archive the separate table you exchanged before emptying or dropping it.
                     </p>
                     <p>A drop or truncate operation would invalidate a global index or a global partitioned index. Local indexes remain valid. The local index partition is dropped when you drop the table partition.</p>
                     <p>The following example shows how to drop partition <code class="codeph">sales_1995</code> from the <code class="codeph">sales</code> table:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
 DROP PARTITION sales_1995
 UPDATE GLOBAL INDEXES PARALLEL;</pre></div>
               </div><a id="VLDBG1365"></a><div class="props_rev_3"><a id="GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" name="GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214"></a><h4 id="VLDBG-GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" class="sect4">Partitioning and Data Compression</h4>
                  <div>
                     <p>Data in a partitioned table can be compressed on a partition-by-partition basis.</p>
                     <p>Using compressed data is most efficient for data that does not change frequently. Common data warehouse scenarios often see few data changes as data ages and other scenarios only insert data. Using the partition management features, you can compress data on a partition-by-partition basis. Although Oracle Database supports compression for all DML operations, it is still more efficient to modify data in a noncompressed table.</p>
                     <p>Altering a partition to enable compression applies only to future data to be inserted into the partition. To compress the existing data in the partition, you must move the partition. Enabling compression and moving a partition can be done in a single operation.</p>
                     <p>To use table compression on partitioned tables with bitmap indexes, you must do the following before you introduce the compression attribute for the first time:</p>
                     <ol>
                        <li>
                           <p>Mark bitmap indexes <code class="codeph">UNUSABLE</code>.
                           </p>
                        </li>
                        <li>
                           <p>Set the compression attribute.</p>
                        </li>
                        <li>
                           <p>Rebuild the indexes.</p>
                        </li>
                     </ol>
                     <p>The first time you make a compressed partition part of an existing, fully uncompressed partitioned table, you must either drop all existing bitmap indexes or mark them <code class="codeph">UNUSABLE</code> before adding a compressed partition. This must be done regardless of whether any partition contains data. It is also independent of the operation that causes one or more compressed partitions to become part of the table. This does not apply to a partitioned table having only B-tree indexes.
                     </p>
                     <p>The following example shows how to compress the <code class="codeph">SALES_1995</code> partition in the <code class="codeph">sales</code> table:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
 MOVE PARTITION sales_1995
 COMPRESS FOR OLTP
 PARALLEL NOLOGGING;
</pre><p>If a table or a partition takes less space on disk, then the performance of large table scans in an I/O-constraint environment may improve.</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>