<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Using Dynamic SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide to the Oracle Precompilers">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00">
      <meta name="dcterms.title" content="Programmer's Guide to the Oracle Precompilers">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96474-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="using-host-arrays.html" title="Previous" type="text/html">
      <link rel="next" href="writing-user-exits.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-host-arrays.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="writing-user-exits.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide to the Oracle Precompilers</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Using Dynamic SQL</li>
            </ol>
            <a id="GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE" name="GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE"></a><a id="ZZPRE869"></a>
            
            <h2 id="ZZPRE-GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE" class="sect2"><span class="enumeration_chapter">10 </span> Using Dynamic SQL
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-09DE3FA0-C622-466A-9A2E-A7735A970271">What Is Dynamic SQL?</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD">Advantages and Disadvantages of Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803">When to Use Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-6E1145C9-54DD-4861-85B1-8F406701F65F">Requirements for Dynamic SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-30F8C760-69E7-4524-BF21-92C063CF513B">How Dynamic SQL Statements Are Processed</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85">Methods for Using Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-16F4F40D-E2C0-455C-9088-9173F96218A0">About Using Method 1</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7">About Using Method 2</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-0234861C-39A8-4AE3-980E-31CA185076F1">About Using Method 3</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-C4762850-789A-463B-B573-7A7630EC1931">Using Method 4</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8">About Using the DECLARE STATEMENT Statement</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B">About Using PL/SQL</a></p>
                  </li>
               </ul>
               <p>This chapter shows you how to use dynamic SQL, an advanced programming technique that adds flexibility and functionality to your applications. After weighing the advantages and disadvantages of dynamic SQL, you learn four methods from simple to complex for writing programs that accept and process SQL statements "on the fly" at run time. You learn the requirements and limitations of each method and how to choose the right method for a given job.</p>
            </div><a id="ZZPRE870"></a><div class="props_rev_3"><a id="GUID-09DE3FA0-C622-466A-9A2E-A7735A970271" name="GUID-09DE3FA0-C622-466A-9A2E-A7735A970271"></a><h3 id="ZZPRE-GUID-09DE3FA0-C622-466A-9A2E-A7735A970271" class="sect3"><span class="enumeration_section">10.1 </span>What Is Dynamic SQL?
               </h3>
               <div>
                  <p><a id="d71876e106" class="indexterm-anchor"></a><a id="d71876e108" class="indexterm-anchor"></a>Most database applications do a specific job. For example, a simple program might prompt the user for an employee number, then update rows in the EMP and DEPT tables. In this case, you know the makeup of the <code class="codeph">UPDATE</code> statement at precompile time. That is, you know which tables might be changed, the constraints defined for each table and column, which columns might be updated, and the datatype of each column.
                  </p>
                  <p>However, some applications must accept (or build) and process a variety of SQL statements at run time. For example, a general-purpose report writer must build different <code class="codeph">SELECT</code> statements for the various reports it generates. In this case, the statement's makeup is unknown until run time. Such statements can, and probably will, change from execution to execution. They are aptly called <span class="italic">dynamic</span> SQL statements.
                  </p>
                  <p>Unlike static SQL statements, dynamic SQL statements are not embedded in your source program. Instead, they are stored in character strings input to or built by the program at run time. They can be entered interactively or read from a file.</p>
                  <p></p>
               </div>
            </div><a id="ZZPRE871"></a><div class="props_rev_3"><a id="GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD" name="GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD"></a><h3 id="ZZPRE-GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD" class="sect3"><span class="enumeration_section">10.2 </span>Advantages and Disadvantages of Dynamic SQL
               </h3>
               <div>
                  <p><a id="d71876e148" class="indexterm-anchor"></a>Host programs that accept and process dynamically defined SQL statements are more versatile than plain embedded SQL programs. Dynamic SQL statements can be built interactively with input from users having little or no knowledge of SQL.
                  </p>
                  <p>For example, your program might simply prompt users for a search condition to be used in the <code class="codeph">WHERE</code> clause of a <code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statement. A more complex program might allow users to choose from menus listing SQL operations, table and view names, column names, and so on. Thus, dynamic SQL lets you write highly flexible applications.
                  </p>
                  <p>However, some dynamic queries require complex coding, the use of special data structures, and more run-time processing. While you might not notice the added processing time, you might find the coding difficult unless you fully understand dynamic SQL concepts and methods.</p>
                  <p></p>
               </div>
            </div><a id="ZZPRE872"></a><div class="props_rev_3"><a id="GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803" name="GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803"></a><h3 id="ZZPRE-GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803" class="sect3"><span class="enumeration_section">10.3 </span>When to Use Dynamic SQL
               </h3>
               <div>
                  <p>In practice, static SQL will meet nearly all your programming needs. Use dynamic SQL only if you need its open-ended flexibility. Its use is suggested when one or more of the following items is unknown at precompile time:<a id="d71876e193" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Text Of The Sql Statement (Commands, Clauses, And So On)</p>
                     </li>
                     <li>
                        <p>The Number Of Host Variables</p>
                     </li>
                     <li>
                        <p>The Datatypes Of Host Variables</p>
                     </li>
                     <li>
                        <p>References To Database Objects Such As Columns, Indexes, Sequences, Tables, Usernames, And Views</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE873"></a><div class="props_rev_3"><a id="GUID-6E1145C9-54DD-4861-85B1-8F406701F65F" name="GUID-6E1145C9-54DD-4861-85B1-8F406701F65F"></a><h3 id="ZZPRE-GUID-6E1145C9-54DD-4861-85B1-8F406701F65F" class="sect3"><span class="enumeration_section">10.4 </span>Requirements for Dynamic SQL Statements
               </h3>
               <div>
                  <p><a id="d71876e237" class="indexterm-anchor"></a>To represent a dynamic SQL statement, a character string must contain the text of a valid SQL statement, but <span class="italic">not</span> contain the EXEC SQL clause, host-language delimiters or statement terminator, or any of the following embedded SQL commands:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">CLOSE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DECLARE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DESCRIBE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">EXECUTE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">FETCH</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">INCLUDE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OPEN</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">PREPARE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">WHENEVER</code></p>
                     </li>
                  </ul>
                  <p><a id="d71876e283" class="indexterm-anchor"></a>In most cases, the character string can contain <span class="italic">dummy</span> host variables. They hold places in the SQL statement for actual host variables. Because dummy host variables are just <a id="d71876e289" class="indexterm-anchor"></a><a id="d71876e293" class="indexterm-anchor"></a>placeholders, you do not declare them and can name them anything you like. For example, Oracle makes no distinction between the following two strings:
                  </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM EMP WHERE MGR = :mgr_number AND JOB = :job_title'
'DELETE FROM EMP WHERE MGR = :m AND JOB = :j'</pre></div>
            </div><a id="ZZPRE874"></a><div class="props_rev_3"><a id="GUID-30F8C760-69E7-4524-BF21-92C063CF513B" name="GUID-30F8C760-69E7-4524-BF21-92C063CF513B"></a><h3 id="ZZPRE-GUID-30F8C760-69E7-4524-BF21-92C063CF513B" class="sect3"><span class="enumeration_section">10.5 </span>How Dynamic SQL Statements Are Processed
               </h3>
               <div>
                  <p><a id="d71876e321" class="indexterm-anchor"></a><a id="d71876e325" class="indexterm-anchor"></a>Typically, an application program prompts the user for the text of a SQL statement and the values of host variables used in the statement. Then Oracle <span class="italic">parses</span> the SQL statement. That is, Oracle examines the SQL statement to make sure it follows syntax rules and refers to valid database objects. Parsing also involves checking database access rights, reserving needed resources, and finding the optimal access path.
                  </p>
                  <p><a id="d71876e332" class="indexterm-anchor"></a><a id="d71876e334" class="indexterm-anchor"></a>Next, Oracle <span class="italic">binds</span> the host variables to the SQL statement. That is, Oracle gets the addresses of the host variables so that it can read or write their values.
                  </p>
                  <p>Then Oracle <span class="italic">executes</span> the SQL statement. That is, Oracle does what the SQL statement requested, such as deleting rows from a table.
                  </p>
                  <p>The SQL statement can be executed repeatedly using new values for the host variables.</p>
               </div>
            </div><a id="ZZPRE876"></a><a id="ZZPRE875"></a><div class="props_rev_3"><a id="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85" name="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85"></a><h3 id="ZZPRE-GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85" class="sect3"><span class="enumeration_section">10.6 </span>Methods for Using Dynamic SQL
               </h3>
               <div>
                  <p>This section introduces four methods you can use to define dynamic SQL statements. It briefly describes the capabilities and limitations of each method, then offers guidelines for choosing the right method. Later sections describe how to use the methods. In addition, you can find sample host-language programs in your supplement to this Guide.</p>
                  <p>The four methods are increasingly general. That is, Method 2 encompasses Method 1, Method 3 encompasses Methods 1 and 2, and so on. However, each method is most useful for handling a certain kind of SQL statement, as <a href="using-dynamic-SQL.html#GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85__BCEGIJJC" title="methods for using dynamic sql">Table 10-1</a> shows.
                  </p>
                  <div class="tblformal" id="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85__BCEGIJJC">
                     <p class="titleintable">Table 10-1 Dynamic SQL Method Applicability</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Dynamic SQL Method Applicability" summary="methods for using dynamic sql" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="13%" id="d71876e390">Method</th>
                              <th align="left" valign="bottom" width="87%" id="d71876e393">Kind of SQL Statement</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e398" headers="d71876e390 ">
                                 <p>1</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e398 d71876e393 ">
                                 <p>nonquery without input host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e405" headers="d71876e390 ">
                                 <p>2</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e405 d71876e393 ">
                                 <p>nonquery with known number of input host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e412" headers="d71876e390 ">
                                 <p>3</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e412 d71876e393 ">
                                 <p>query with known number of select-list items and input host variables</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e419" headers="d71876e390 ">
                                 <p>4</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e419 d71876e393 ">
                                 <p>query with unknown number of select-list items or input host variables</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>The term <span class="italic">select-list item</span> includes column names and expressions.
                  </p>
               </div><a id="ZZPRE877"></a><div class="props_rev_3"><a id="GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3" name="GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3"></a><h4 id="ZZPRE-GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3" class="sect4"><span class="enumeration_section">10.6.1 </span>Method 1
                  </h4>
                  <div>
                     <div class="section">
                        <p>This method lets your program accept or build a dynamic SQL statement, then immediately execute it using the<code class="codeph"> EXECUTE</code> <code class="codeph">IMMEDIATE</code> command. The SQL statement must not be a query (<code class="codeph">SELECT</code> statement) and must not contain any placeholders for input host variables. For example, the following host strings qualify:
                        </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM EMP WHERE DEPTNO = 20'
'GRANT SELECT ON EMP TO scott'
</pre><p>With Method 1, the SQL statement is parsed every time it is executed (unless you specify <code class="codeph">HOLD_CURSOR</code>=<code class="codeph">YES</code>).
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE878"></a><div class="props_rev_3"><a id="GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8" name="GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8"></a><h4 id="ZZPRE-GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8" class="sect4"><span class="enumeration_section">10.6.2 </span>Method 2
                  </h4>
                  <div>
                     <div class="section">
                        <p>This method lets your program accept or build a dynamic SQL statement, then process it using the <code class="codeph">PREPARE</code> and <code class="codeph">EXECUTE </code>commands<a id="d71876e501" class="indexterm-anchor"></a> .The SQL statement must not be a query. The number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time. For example, the following host strings fall into this category:
                        </p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP (ENAME, JOB) VALUES (:emp_name, :job_title)'
'DELETE FROM EMP WHERE EMPNO = :emp_number'
</pre><p>With Method 2, the SQL statement is parsed just once (unless you specify <code class="codeph">RELEASE_CURSOR</code>=<code class="codeph">YES</code>), but it can be executed many times with different values for the host variables. SQL data definition statements such as <code class="codeph">CREATE</code> are executed when they are <code class="codeph">PREPARE</code>d.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE879"></a><div class="props_rev_3"><a id="GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8" name="GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8"></a><h4 id="ZZPRE-GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8" class="sect4"><span class="enumeration_section">10.6.3 </span>Method 3
                  </h4>
                  <div>
                     <div class="section">
                        <p>This method lets your program accept or build a dynamic query, then process it using the PREPARE command with the <code class="codeph">DECLARE</code>,<code class="codeph"> OPEN</code>, <code class="codeph">FETCH</code>, and <code class="codeph">CLOSE </code>cursor commands. The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables must be known at precompile time. For example, the following host strings qualify:
                        </p><pre class="oac_no_warn" dir="ltr">'SELECT DEPTNO, MIN(SAL), MAX(SAL) FROM EMP GROUP BY DEPTNO'
'SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :dept_number'
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE880"></a><div class="props_rev_3"><a id="GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B" name="GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B"></a><h4 id="ZZPRE-GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B" class="sect4"><span class="enumeration_section">10.6.4 </span>Method 4
                  </h4>
                  <div>
                     <div class="section">
                        <p>This method lets your program accept or build a dynamic SQL statement, then process it using descriptors (discussed in "Using Method 4"). The number of select-list items, the number of placeholders for input host variables, and the datatypes of the input host variables can be unknown until run time. For example, the following host strings fall into this category:</p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP (&lt;unknown&gt;) VALUES (&lt;unknown&gt;)'
'SELECT &lt;unknown&gt; FROM EMP WHERE DEPTNO = 20'
</pre><p>Method 4 is required for dynamic SQL statements that contain an unknown number of select-list items or input host variables.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE881"></a><div class="props_rev_3"><a id="GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD" name="GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD"></a><h4 id="ZZPRE-GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD" class="sect4"><span class="enumeration_section">10.6.5 </span>Guidelines
                  </h4>
                  <div>
                     <p><a id="d71876e608" class="indexterm-anchor"></a><a id="d71876e612" class="indexterm-anchor"></a>With all four methods, you must store the dynamic SQL statement in a character string, which must be a host variable or quoted literal. When you store the SQL statement in the string, omit the keywords EXEC SQL and the statement terminator.
                     </p>
                     <p><a id="d71876e618" class="indexterm-anchor"></a>With Methods 2 and 3, the number of placeholders for input host variables and the datatypes of the input host variables must be known at precompile time.
                     </p>
                     <p>Each succeeding method imposes fewer constraints on your application, but is more difficult to code. As a rule, use the simplest method you can. However, if a dynamic SQL statement is to be executed repeatedly by Method 1, use Method 2 instead to avoid reparsing for each execution.</p>
                     <p>Method 4 provides maximum flexibility, but requires complex coding and a full understanding of dynamic SQL concepts. In general, use Method 4 only if you cannot use Methods 1, 2, or 3. The decision logic in <a href="using-dynamic-SQL.html#GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F__CHDJHDJA">Figure 10-1</a> will help you choose the correct method.
                     </p>
                  </div>
               </div><a id="ZZPRE883"></a><a id="ZZPRE882"></a><div class="props_rev_3"><a id="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F" name="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F"></a><h4 id="ZZPRE-GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F" class="sect4"><span class="enumeration_section">10.6.6 </span>Avoiding Common Errors
                  </h4>
                  <div>
                     <div class="section">
                        <p>If you use a character array to store the dynamic SQL statement, blank-pad the array before storing the SQL statement. That way, you clear extraneous characters. This is especially important when you reuse the array for different SQL statements. As a rule, always initialize (or reinitialize) the host string before storing the SQL statement.</p>
                        <p>Do not null-terminate the host string. Oracle does not recognize the null terminator as an end-of-string sentinel. Instead, Oracle treats it as part of the SQL statement.</p>
                        <p>If you use a <code class="codeph">VARCHAR</code> variable to store the dynamic SQL statement, make sure the length of the <code class="codeph">VARCHAR</code> is set (or reset) correctly before you execute the PREPARE or <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement.
                        </p>
                        <p><code class="codeph">EXECUTE</code> resets the SQLWARN warning flags in the SQLCA. So, to catch mistakes such as an unconditional update (caused by omitting a <code class="codeph">WHERE</code> clause), check the SQLWARN flags after executing the <code class="codeph">PREPARE</code> statement but before executing the <code class="codeph">EXECUTE</code> statement.
                        </p>
                        <div class="figure" id="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F__CHDJHDJA">
                           <p class="titleinfigure">Figure 10-1 Choosing the Right Method</p><img src="img/image013.gif" alt="Description of Figure 10-1 follows" title="Description of Figure 10-1 follows" longdesc="img_text/image013.html"><br><a href="img_text/image013.html">Description of "Figure 10-1 Choosing the Right Method"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE884"></a><div class="props_rev_3"><a id="GUID-16F4F40D-E2C0-455C-9088-9173F96218A0" name="GUID-16F4F40D-E2C0-455C-9088-9173F96218A0"></a><h3 id="ZZPRE-GUID-16F4F40D-E2C0-455C-9088-9173F96218A0" class="sect3"><span class="enumeration_section">10.7 </span>About Using Method 1
               </h3>
               <div>
                  <p><a id="d71876e709" class="indexterm-anchor"></a>The simplest kind of dynamic SQL statement results only in "success" or "failure" and uses no host variables. Some examples follow:
                  </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM table_name WHERE column_name = constant'
'CREATE TABLE table_name ...'
'DROP INDEX index_name'
'UPDATE table_name SET column_name = constant'
'GRANT SELECT ON table_name TO username'
'REVOKE RESOURCE FROM username'
</pre></div><a id="ZZPRE885"></a><div class="props_rev_3"><a id="GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B" name="GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B"></a><h4 id="ZZPRE-GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B" class="sect4"><span class="enumeration_section">10.7.1 </span>The EXECUTE IMMEDIATE Statement
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e738" class="indexterm-anchor"></a> Method 1 parses, then immediately executes the SQL statement using the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> command. The command is followed by a character string (host variable or literal) containing the SQL statement to be executed, which cannot be a query.
                        </p>
                        <p><a id="d71876e750" class="indexterm-anchor"></a>The syntax of the <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE { :host_string | string_literal };
</pre><p><a id="d71876e764" class="indexterm-anchor"></a>In the following example, you use the host variable <span class="italic">sql_stmt</span> to store SQL statements input by the user:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 sql_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
...
LOOP
 display 'Enter SQL statement: ';
 read sql_stmt;
 IF sql_stmt is empty THEN
 exit loop;
 ENDIF;
 -- sql_stmt now contains the text of a SQL statement
 EXEC SQL EXECUTE IMMEDIATE :sql_stmt;
ENDLOOP;
</pre><p>You can also use string literals, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE 'REVOKE RESOURCE FROM MILLER';
</pre><p>Because EXECUTE IMMEDIATE parses the input SQL statement before every execution, Method 1 is best for statements that are executed only once. Data definition statements usually fall into this category.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE886"></a><div class="props_rev_3"><a id="GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C" name="GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C"></a><h4 id="ZZPRE-GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C" class="sect4"><span class="enumeration_section">10.7.2 </span>An Example
                  </h4>
                  <div>
                     <p><a id="d71876e801" class="indexterm-anchor"></a>The following program prompts the user for a search condition to be used in the <code class="codeph">WHERE</code> clause of an <code class="codeph">UPDATE</code> statement, then executes the statement using Method 1:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 update_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
EXEC SQL INCLUDE SQLCA;
display 'Username? ';
read username;
display 'Password? ';
read password;
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display 'Connected to Oracle';
set update_stmt = 'UPDATE EMP SET COMM = 500 WHERE ';
display 'Enter a search condition for the following statement:';
display update_stmt;
read search_cond;
concatenate update_stmt, search_cond;
EXEC SQL EXECUTE IMMEDIATE :update_stmt;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 display 'Processing error';
 exit program with an error;
</pre></div>
               </div>
            </div><a id="ZZPRE887"></a><div class="props_rev_3"><a id="GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7" name="GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7"></a><h3 id="ZZPRE-GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7" class="sect3"><span class="enumeration_section">10.8 </span>About Using Method 2
               </h3>
               <div>
                  <p><a id="d71876e839" class="indexterm-anchor"></a>What Method 1 does in one step, Method 2 does in two. The dynamic SQL statement, <a id="d71876e844" class="indexterm-anchor"></a>which cannot be a query, is first <code class="codeph">PREPARE</code>d (named and parsed), then executed.
                  </p>
                  <p> <a id="d71876e854" class="indexterm-anchor"></a>With Method 2, the SQL statement can contain <a id="d71876e859" class="indexterm-anchor"></a>placeholders for input host variables and indicator variables. You can <code class="codeph">PREPARE</code> the SQL statement once, then <code class="codeph">EXECUTE</code> it repeatedly using different values of the host variables. Also, you need <span class="italic">not</span> rePREPARE the SQL statement after a <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> (unless you log off and reconnect).
                  </p>
                  <p>Note that you can use <code class="codeph">EXECUTE</code> for nonqueries with Method 4.
                  </p>
                  <p>The syntax of the <code class="codeph">PREPARE</code> statement follows:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name
 FROM { :host_string | string_literal };
</pre><p><code class="codeph">PREPARE</code> parses the SQL statement and gives it a name.
                  </p>
                  <p>The <span class="italic">statement_name</span> is an identifier used by the precompiler, <span class="italic">not</span> a host or program variable, and should not be declared in the Declare Section. It simply designates the <code class="codeph">PREPAREd</code> statement you want to <code class="codeph">EXECUTE</code>.
                  </p>
                  <p>The syntax of the <code class="codeph">EXECUTE</code> statement is
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name [USING host_variable_list];
</pre><p>where <span class="italic">host_variable_list</span> stands for the following syntax:
                  </p><pre class="oac_no_warn" dir="ltr">:host_variable1[:indicator1] [, host_variable2[:indicator2], ...]
</pre><p><code class="codeph">EXECUTE</code> executes the parsed SQL statement, using the values supplied for each input host variable. In the following example, the input SQL statement contains the placeholder <span class="italic">n</span>:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 ...
 emp_number INTEGER;
 delete_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
...
set delete_stmt = 'DELETE FROM EMP WHERE EMPNO = :n AND ';
display 'Complete the following statement's search condition:';
display delete_stmt;
read search_cond;
concatenate delete_stmt, search_cond;
EXEC SQL PREPARE sql_stmt FROM :delete_stmt;
LOOP
 display 'Enter employee number: ';
 read emp_number;
 IF emp_number = 0 THEN
 exit loop;
 EXEC SQL EXECUTE sql_stmt USING :emp_number;
ENDLOOP;
</pre><p>With Method 2, you must know the datatypes of input host variables at precompile time. In the last example, <span class="italic">emp_number</span> was declared as type <code class="codeph">INTEGER</code>. It could also have been declared as type <code class="codeph">CHARACTER</code> or <code class="codeph">REAL</code>, because Oracle supports all these datatype conversions to the <code class="codeph">NUMBER</code> datatype.
                  </p>
               </div><a id="ZZPRE888"></a><div class="props_rev_3"><a id="GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F" name="GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F"></a><h4 id="ZZPRE-GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F" class="sect4"><span class="enumeration_section">10.8.1 </span>The USING Clause
                  </h4>
                  <div>
                     <p>When the SQL statement is <code class="codeph">EXECUTEd</code>, input host variables in the <code class="codeph">USING</code> clause replace corresponding placeholders in the <code class="codeph">PREPAREd</code> dynamic SQL statement.
                     </p>
                     <p>Every placeholder in the PREPAREd dynamic SQL statement must correspond to a host variable in the <code class="codeph">USING</code> clause. So, if the same placeholder appears two or more times in the <code class="codeph">PREPAREd</code> statement, each appearance must correspond to a host variable in the <code class="codeph">USING</code> clause. If one of the host variables in the <code class="codeph">USING</code> clause is an array, all must be arrays.
                     </p>
                     <p><a id="d71876e1001" class="indexterm-anchor"></a>The names of the placeholders need not match the names of the host variables. However, the order of the placeholders in the <code class="codeph">PREPAREd</code> dynamic SQL statement must match the order of corresponding host variables in the <code class="codeph">USING</code> clause.
                     </p>
                     <p><a id="d71876e1013" class="indexterm-anchor"></a>To specify nulls, you can associate indicator variables with host variables in the <code class="codeph">USING</code> clause. For more information, refer to <span class="q">"<a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">About Using Indicator Variables</a>"</span>.
                     </p>
                  </div>
               </div><a id="ZZPRE889"></a><div class="props_rev_3"><a id="GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB" name="GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB"></a><h4 id="ZZPRE-GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB" class="sect4"><span class="enumeration_section">10.8.2 </span>An Example
                  </h4>
                  <div>
                     <p> <a id="d71876e1048" class="indexterm-anchor"></a>The following program prompts the user for a search condition to be used in the <code class="codeph">WHERE</code> clause of an <code class="codeph">UPDATE</code> statement, then prepares and executes the statement using Method 2. Notice that the <code class="codeph">SET</code> clause of the <code class="codeph">UPDATE</code> statement contains a placeholder (<span class="italic">c</span>).
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 sql_stmt CHARACTER(80);
 empno INTEGER VALUE 1234;
 deptno1 INTEGER VALUE 97;
 deptno2 INTEGER VALUE 99;
EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;
EXEC ORACLE OPTION (ORACA=YES);
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
display 'Username? ';
read username;
display 'Password? ';
read password;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display 'Connected to Oracle';
set sql_stmt = 
 'INSERT INTO EMP (EMPNO, DEPTNO) VALUES (:v1, :v2)';
display "V1 = ", empno, "V2 = ", deptno1;
EXEC SQL PREPARE S FROM :sql_stmt;
EXEC SQL EXECUTE S USING :empno, :deptno1;
set empno = empno + 1;
display "V1 = ", empno, "V2 = ", deptno2;
EXEC SQL EXECUTE S USING :empno, :deptno2;
set sql_stmt = 
 'DELETE FROM EMP WHERE DEPTNO = :v1 OR DEPTNO = :v2")';
display "V1 = ", deptno1, "V2 = ", deptno2;
EXEC SQL PREPARE S FROM :sql_stmt;
EXEC SQL EXECUTE S USING :deptno1, :deptno2;
EXEC SQL COMMIT WORK RELEASE;
exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 display 'Processing error';
 EXEC SQL ROLLBACK WORK RELEASE;
 exit program with an error;
</pre></div>
               </div>
            </div><a id="ZZPRE890"></a><div class="props_rev_3"><a id="GUID-0234861C-39A8-4AE3-980E-31CA185076F1" name="GUID-0234861C-39A8-4AE3-980E-31CA185076F1"></a><h3 id="ZZPRE-GUID-0234861C-39A8-4AE3-980E-31CA185076F1" class="sect3"><span class="enumeration_section">10.9 </span>About Using Method 3
               </h3>
               <div>
                  <p><a id="d71876e1093" class="indexterm-anchor"></a>Method 3 is similar to Method 2<a id="d71876e1098" class="indexterm-anchor"></a> but combines the <code class="codeph">PREPARE</code> statement with the statements needed to define and manipulate a cursor. This allows your program to accept and process queries. In fact, if the dynamic SQL statement is a query, you <span class="italic">must</span> use Method 3 or 4.
                  </p>
                  <p><a id="d71876e1110" class="indexterm-anchor"></a>For Method 3, the number of columns in the query select list and the number of placeholders for input host variables must be known at precompile time. However, the names of database objects such as tables and columns need not be specified until run time (they cannot duplicate the names of host variables). Clauses that limit, group, and sort query results (such as <code class="codeph">WHERE</code>, <code class="codeph">GROUP</code> <code class="codeph">BY</code>, and <code class="codeph">ORDER</code> <code class="codeph">BY</code>) can also be specified at run time.
                  </p>
                  <p>With Method 3, you use the following sequence of embedded SQL statements:</p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM { :host_string | string_literal };
DECLARE cursor_name CURSOR FOR statement_name;
OPEN cursor_name [USING host_variable_list];
FETCH cursor_name INTO host_variable_list;
CLOSE cursor_name;
</pre><p>Now let us look at what each statement does.</p>
               </div><a id="ZZPRE891"></a><div class="props_rev_3"><a id="GUID-47931071-4091-4D65-9AD4-21D4BEC2804A" name="GUID-47931071-4091-4D65-9AD4-21D4BEC2804A"></a><h4 id="ZZPRE-GUID-47931071-4091-4D65-9AD4-21D4BEC2804A" class="sect4"><span class="enumeration_section">10.9.1 </span>PREPARE
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1164" class="indexterm-anchor"></a><code class="codeph">PREPARE</code> parses the dynamic SQL statement and gives it a name. In the following example, <code class="codeph">PREPARE</code> parses the query stored in the character string <span class="italic">select_stmt</span> and gives it the name <span class="italic">sql_stmt</span>:
                        </p><pre class="oac_no_warn" dir="ltr">set select_stmt = 'SELECT MGR, JOB FROM EMP WHERE SAL &lt; :salary';
EXEC SQL PREPARE sql_stmt FROM :select_stmt;
</pre><p>Commonly, the query <code class="codeph">WHERE</code> clause is input from a terminal at run time or is generated by the application.
                        </p>
                        <p>The identifier <span class="italic">sql_stmt</span> is <span class="italic">not</span> a host or program variable, but must be unique. It designates a particular dynamic SQL statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE892"></a><div class="props_rev_3"><a id="GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370" name="GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370"></a><h4 id="ZZPRE-GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370" class="sect4"><span class="enumeration_section">10.9.2 </span>DECLARE
                  </h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">DECLARE</code> defines a cursor by giving it a name and associating it with a specific query. The cursor declaration is local to its precompilation unit. Continuing our example, <code class="codeph">DECLARE</code> defines a cursor named <span class="italic">emp_cursor</span> and associates it with <span class="italic">sql_stmt</span>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr"><a id="d71876e1230" class="indexterm-anchor"></a>EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
</pre><p>The identifiers <span class="italic">sql_stmt</span> and <span class="italic">emp_cursor</span> are <span class="italic">not</span> host or program variables, but must be unique. If you declare two cursors using the same statement name, the precompiler considers the two cursor names synonymous. For example, if you execute the statements
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM :select_stmt;
EXEC SQL DECLARE emp_cursor FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :delete_stmt;
EXEC SQL DECLARE dept_cursor FOR sql_stmt;
</pre><p>when you OPEN <span class="italic">emp_cursor</span>, you will process the dynamic SQL statement stored in <span class="italic">delete_stmt</span>, not the one stored in <span class="italic">select_stmt.</span></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE893"></a><div class="props_rev_3"><a id="GUID-D6313AED-13FD-42B7-B229-5694EE080400" name="GUID-D6313AED-13FD-42B7-B229-5694EE080400"></a><h4 id="ZZPRE-GUID-D6313AED-13FD-42B7-B229-5694EE080400" class="sect4"><span class="enumeration_section">10.9.3 </span>OPEN
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1287" class="indexterm-anchor"></a><code class="codeph">OPEN</code> allocates an Oracle cursor, binds input host variables, and executes the query, identifying its active set. OPEN also positions the cursor on the first row in the active set and zeroes the rows-processed count kept by the third element of SQLERRD in the SQLCA. Input host variables in the USING clause replace corresponding placeholders in the <code class="codeph">PREPAREd</code> dynamic SQL statement.
                        </p>
                        <p>In our example, <code class="codeph">OPEN</code> allocates <span class="italic">emp_cursor</span> and assigns the host variable <span class="italic">salary</span> to the <code class="codeph">WHERE</code> clause, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor USING :salary;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE894"></a><div class="props_rev_3"><a id="GUID-A2105218-5AF9-481E-B7D9-8607062E76B7" name="GUID-A2105218-5AF9-481E-B7D9-8607062E76B7"></a><h4 id="ZZPRE-GUID-A2105218-5AF9-481E-B7D9-8607062E76B7" class="sect4"><span class="enumeration_section">10.9.4 </span>FETCH
                  </h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">FETCH</code> returns a row from the active set, assigns column values in the select list to corresponding host variables in the <code class="codeph">INTO</code> clause, and advances the cursor to the next row. When no more rows are found, <code class="codeph">FETCH</code> returns the "no data found" Oracle error code to SQLCODE in the SQLCA.
                        </p>
                        <p><a id="d71876e1345" class="indexterm-anchor"></a> In our example, FETCH returns a row from the active set and assigns the values of columns MGR and JOB to host variables <span class="italic">mgr_number</span> and <span class="italic">job_title</span>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO :mgr_number, :job_title;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE895"></a><div class="props_rev_3"><a id="GUID-1D1151ED-608B-4B8C-AA38-6B6449340665" name="GUID-1D1151ED-608B-4B8C-AA38-6B6449340665"></a><h4 id="ZZPRE-GUID-1D1151ED-608B-4B8C-AA38-6B6449340665" class="sect4"><span class="enumeration_section">10.9.5 </span>CLOSE
                  </h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">CLOSE</code> disables the cursor. After you <code class="codeph">CLOSE</code> a cursor, you can no longer <code class="codeph">FETCH</code> from it. In our example, the <code class="codeph">CLOSE</code> statement disables <span class="italic">emp_cursor</span>, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE896"></a><div class="props_rev_3"><a id="GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766" name="GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766"></a><h4 id="ZZPRE-GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766" class="sect4"><span class="enumeration_section">10.9.6 </span>An Example
                  </h4>
                  <div>
                     <p> <a id="d71876e1420" class="indexterm-anchor"></a>The following program prompts the user for a search condition to be used in the <code class="codeph">WHERE</code> clause of a query, then prepares and executes the query using Method 3.
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;
 username CHARACTER(20);
 password CHARACTER(20);
 dept_number INTEGER;
 emp_name CHARACTER(10);
 salary REAL;
 select_stmt CHARACTER(120);
EXEC SQL END DECLARE SECTION;
 search_cond CHARACTER(40);
EXEC SQL INCLUDE SQLCA;
display 'Username? ';
read username;
display 'Password? ';
read password;
EXEC SQL WHENEVER SQLERROR GOTO sql_error;
EXEC SQL CONNECT :username IDENTIFIED BY :password;
display 'Connected to Oracle';
set select_stmt = 'SELECT ENAME,SAL FROM EMP WHERE ';
display 'Enter a search condition for the following statement:';
display select_stmt;
read search_cond;
concatenate select_stmt, search_cond;
EXEC SQL PREPARE sql_stmt FROM :select_stmt;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
EXEC SQL OPEN emp_cursor;
EXEC SQL WHENEVER NOT FOUND GOTO no_more;
display 'Employee Salary';
display '-------- ------';
LOOP
 EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
 display emp_name, salary;
ENDLOOP;
no_more:
 EXEC SQL CLOSE emp_cursor;
 EXEC SQL COMMIT WORK RELEASE;
 exit program;
sql_error:
 EXEC SQL WHENEVER SQLERROR CONTINUE;
 EXEC SQL ROLLBACK WORK RELEASE;
 exit program with an error;
</pre></div>
               </div>
            </div><a id="ZZPRE897"></a><div class="props_rev_3"><a id="GUID-C4762850-789A-463B-B573-7A7630EC1931" name="GUID-C4762850-789A-463B-B573-7A7630EC1931"></a><h3 id="ZZPRE-GUID-C4762850-789A-463B-B573-7A7630EC1931" class="sect3"><span class="enumeration_section">10.10 </span>Using Method 4
               </h3>
               <div>
                  <p><a id="d71876e1455" class="indexterm-anchor"></a>The implementation of Method 4 is very language-dependent. Therefore, this section only gives an overview. For details, see your host-language supplement.
                  </p>
                  <p>There is a kind of dynamic SQL statement that your program cannot process using Method 3. When the number of select-list items or placeholders for input host variables is unknown until run time, your program must use a descriptor. A <a id="d71876e1462" class="indexterm-anchor"></a><span class="italic">descriptor</span> is an area of memory used by your program and Oracle to hold a complete description of the variables in a dynamic SQL statement.
                  </p>
                  <p><a id="d71876e1470" class="indexterm-anchor"></a>Recall that for a multirow query, you <code class="codeph">FETCH</code> selected column values <code class="codeph">INTO</code> a list of declared output host variables. If the select list is unknown, the host-variable list cannot be established at precompile time by the <code class="codeph">INTO</code> clause. For example, you know the following query returns two column values:
                  </p><pre class="oac_no_warn" dir="ltr">SELECT ENAME, EMPNO FROM EMP WHERE DEPTNO = :dept_number;
</pre><p>However, if you let the user define the select list, you might not know how many column values the query will return.</p>
               </div><a id="ZZPRE898"></a><div class="props_rev_3"><a id="GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7" name="GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7"></a><h4 id="ZZPRE-GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7" class="sect4"><span class="enumeration_section">10.10.1 </span>Need for the SQLDA
                  </h4>
                  <div>
                     <p><a id="d71876e1513" class="indexterm-anchor"></a>To process this kind of dynamic query, your program must issue the <code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code> command and declare a data structure called the SQL Descriptor Area <a id="d71876e1525" class="indexterm-anchor"></a>(SQLDA). Because it holds descriptions of columns in the query select list, this structure is also called a <span class="italic">select descriptor</span>.
                     </p>
                     <p>Likewise, if a dynamic SQL statement contains an unknown number of placeholders for input host variables, the host-variable list cannot be established at precompile time by the <code class="codeph">USING</code> clause.
                     </p>
                     <p><a id="d71876e1539" class="indexterm-anchor"></a>To process the dynamic SQL statement, your program must issue the <code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code> command and declare another kind of SQLDA called a <span class="italic">bind descriptor</span> to hold descriptions of the placeholders for the input host variables. (Input host variables are also called <span class="italic">bind variables</span>.)
                     </p>
                     <p>If your program has more than one active SQL statement (it might have OPENed two or more cursors, for example), each statement must have its own SQLDA(s). However, non-concurrent cursors can reuse SQLDAs. There is no set limit on the number of SQLDAs in a program.</p>
                  </div>
               </div><a id="ZZPRE899"></a><div class="props_rev_3"><a id="GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630" name="GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630"></a><h4 id="ZZPRE-GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630" class="sect4"><span class="enumeration_section">10.10.2 </span>The DESCRIBE Statement
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1581" class="indexterm-anchor"></a>DESCRIBE initializes a descriptor to hold descriptions of select-list items or input host variables.<a id="d71876e1584" class="indexterm-anchor"></a></p>
                        <p>If you supply a select descriptor, the <code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code> statement examines each select-list item in a <code class="codeph">PREPAREd</code> dynamic query to determine its name, datatype, constraints, length, scale, and precision. It then stores this information in the select descriptor.
                        </p>
                        <p>If you supply a bind descriptor, the <code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code> statement examines each placeholder in a <code class="codeph">PREPAREd</code> dynamic SQL statement to determine its name, length, and the datatype of its associated input host variable. It then stores this information in the bind descriptor for your use. For example, you might use placeholder names to prompt the user for the values of input host variables.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE900"></a><div class="props_rev_3"><a id="GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0" name="GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0"></a><h4 id="ZZPRE-GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0" class="sect4"><span class="enumeration_section">10.10.3 </span>What Is a SQLDA?
                  </h4>
                  <div>
                     <p>A SQLDA is a host-program data structure that holds descriptions of select-list items or input host variables.</p>
                     <p>SQLDA variables are <span class="italic">not</span> defined in the Declare Section.
                     </p>
                     <p>Though SQLDAs differ among host languages, a generic select SQLDA contains the following information about a query select list:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Maximum number of columns that can be described</p>
                        </li>
                        <li>
                           <p>Actual number of columns found by describe</p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store column values</p>
                        </li>
                        <li>
                           <p>Lengths of column values</p>
                        </li>
                        <li>
                           <p>Datatypes of column values</p>
                        </li>
                        <li>
                           <p>addresses of indicator-variable values</p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store column names</p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store column names</p>
                        </li>
                        <li>
                           <p>Current lengths of column names</p>
                        </li>
                     </ul>
                     <p>A generic bind SQLDA contains the following information about the input host variables in a SQL statement:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Maximum number of placeholders that can be described</p>
                        </li>
                        <li>
                           <p>Actual number of placeholders found by describe</p>
                        </li>
                        <li>
                           <p>Addresses of input host variables</p>
                        </li>
                        <li>
                           <p>Lengths of input host variables</p>
                        </li>
                        <li>
                           <p>Datatypes of input host variables</p>
                        </li>
                        <li>
                           <p>Addresses of indicator variables</p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store placeholder names</p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store placeholder names</p>
                        </li>
                        <li>
                           <p>Current lengths of placeholder names</p>
                        </li>
                        <li>
                           <p>Addresses of buffers to store indicator-variable names</p>
                        </li>
                        <li>
                           <p>Sizes of buffers to store indicator-variable names</p>
                        </li>
                        <li>
                           <p>Current lengths of indicator-variable names</p>
                        </li>
                     </ul>
                     <p>To see the SQLDA structure and variable names in a particular host language, refer to your host-language supplement.</p>
                  </div>
               </div><a id="ZZPRE901"></a><div class="props_rev_3"><a id="GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3" name="GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3"></a><h4 id="ZZPRE-GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3" class="sect4"><span class="enumeration_section">10.10.4 </span>Implementing Method 4
                  </h4>
                  <div>
                     <p>With Method 4, you generally use the following sequence of embedded SQL statements:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name
 FROM { :host_string | string_literal };
EXEC SQL DECLARE cursor_name CURSOR FOR statement_name;
EXEC SQL DESCRIBE BIND VARIABLES FOR statement_name
 INTO bind_descriptor_name;
EXEC SQL OPEN cursor_name
 [USING DESCRIPTOR bind_descriptor_name];
EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name
 INTO select_descriptor_name;
EXEC SQL FETCH cursor_name
 USING DESCRIPTOR select_descriptor_name;
EXEC SQL CLOSE cursor_name;
</pre><p>Select and bind descriptors need not work in tandem. If the number of columns in a query select list is known, but the number of placeholders for input host variables is unknown, you can use the Method 4 <code class="codeph">OPEN</code> statement with the following Method 3 <code class="codeph">FETCH</code> statement:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO host_variable_list;
</pre><p>Conversely, if the number of placeholders for input host variables is known, but the number of columns in the select list is unknown, you can use the following Method 3 <code class="codeph">OPEN</code> statement with the Method 4 <code class="codeph">FETCH</code> statement:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor_name [USING host_variable_list];
</pre><p>Note that <code class="codeph">EXECUTE</code> can be used for nonqueries with Method 4.
                     </p>
                     <p>To learn how these statements allow your program to process dynamic SQL statements using descriptors, see your host-language supplement.</p>
                  </div>
               </div>
            </div><a id="ZZPRE902"></a><div class="props_rev_3"><a id="GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8" name="GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8"></a><h3 id="ZZPRE-GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8" class="sect3"><span class="enumeration_section">10.11 </span>About Using the DECLARE STATEMENT Statement
               </h3>
               <div>
                  <p><a id="d71876e1788" class="indexterm-anchor"></a>With Methods 2, 3, and 4, you might need to use the statement
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT db_name] DECLARE statement_name STATEMENT;
</pre><p>where <span class="italic">db_name</span> and <span class="italic">statement_name</span> are identifiers used by the precompiler, <span class="italic">not</span> host or program variables.
                  </p>
                  <p><code class="codeph">DECLARE</code> <code class="codeph">STATEMENT</code> declares the name of a dynamic SQL statement so that the statement can be referenced by <code class="codeph">PREPARE</code>, <code class="codeph">EXECUTE</code>, <code class="codeph">DECLARE</code> <code class="codeph">CURSOR</code>, and <code class="codeph">DESCRIBE</code>. It is <a id="d71876e1829" class="indexterm-anchor"></a>required if you want to execute the dynamic SQL statement at a nondefault database. An example using Method 2 follows:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT remote_db DECLARE sql_stmt STATEMENT;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL EXECUTE sql_stmt;
</pre><p>In the example, <span class="italic">remote_db</span> tells Oracle where to <code class="codeph">EXECUTE</code> the SQL statement.
                  </p>
                  <p><a id="d71876e1845" class="indexterm-anchor"></a>With Methods <a id="d71876e1850" class="indexterm-anchor"></a>3 and <a id="d71876e1855" class="indexterm-anchor"></a>4, <code class="codeph">DECLARE</code> <code class="codeph">STATEMENT</code> is also required if the DECLARE <code class="codeph">CURSOR</code> statement precedes the PREPARE statement, as shown in the following example:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE sql_stmt STATEMENT;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :sql_string;
</pre><p>The usual sequence of statements is</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM :sql_string;
EXEC SQL DECLARE emp_cursor CURSOR FOR sql_stmt;
</pre></div><a id="ZZPRE903"></a><div class="props_rev_3"><a id="GUID-406CB08D-F866-43B6-9420-27AF3EFA288E" name="GUID-406CB08D-F866-43B6-9420-27AF3EFA288E"></a><h4 id="ZZPRE-GUID-406CB08D-F866-43B6-9420-27AF3EFA288E" class="sect4"><span class="enumeration_section">10.11.1 </span>Usage of Host Arrays
                  </h4>
                  <div>
                     <p><a id="d71876e1896" class="indexterm-anchor"></a><a id="d71876e1900" class="indexterm-anchor"></a>Usage of host arrays in static and dynamic SQL is similar. For example, to use input host arrays with dynamic SQL Method 2, use the syntax
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name USING host_array_list;
</pre><p>where <span class="italic">host_array_list</span> contains one or more host arrays. With Method 3, use the following syntax:
                     </p><pre class="oac_no_warn" dir="ltr">OPEN cursor_name USING host_array_list;
</pre><p>To use output host arrays with Method 3, use the following syntax:</p><pre class="oac_no_warn" dir="ltr">FETCH cursor_name INTO host_array_list;
</pre><p>With Method 4, you must use the optional FOR clause to tell Oracle the size of your input or output host array. To learn how this is done, see your host-language supplement.</p>
                     <p></p>
                  </div>
               </div>
            </div><a id="ZZPRE904"></a><div class="props_rev_3"><a id="GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B" name="GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B"></a><h3 id="ZZPRE-GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B" class="sect3"><span class="enumeration_section">10.12 </span>About Using PL/SQL
               </h3>
               <div>
                  <p><a id="d71876e1943" class="indexterm-anchor"></a>The Oracle Precompilers treat a PL/SQL block like a single SQL statement. So, like a <a id="d71876e1946" class="indexterm-anchor"></a>SQL statement, a PL/SQL block can be stored in a string host variable or literal. When you store the PL/SQL block in the string, omit the keywords EXEC SQL <code class="codeph">EXECUTE</code>, the keyword END-EXEC, and the statement terminator.
                  </p>
                  <p>However, there are two differences in the way the precompiler handles SQL and PL/SQL:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The precompiler treats all PL/SQL host variables as <span class="italic">input</span> host variables whether they serve as input or output host variables (or both) inside the PL/SQL block.
                        </p>
                     </li>
                     <li>
                        <p>You cannot FETCH from a PL/SQL block because it might contain any number of SQL statements.</p>
                     </li>
                  </ul>
               </div><a id="ZZPRE905"></a><div class="props_rev_3"><a id="GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7" name="GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7"></a><h4 id="ZZPRE-GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7" class="sect4"><span class="enumeration_section">10.12.1 </span>With Method 1
                  </h4>
                  <div>
                     <p><a id="d71876e1987" class="indexterm-anchor"></a>If the PL/SQL block contains no host variables, you can use Method 1 to <code class="codeph">EXECUTE</code> the PL/SQL string in the usual way.
                     </p>
                  </div>
               </div><a id="ZZPRE906"></a><div class="props_rev_3"><a id="GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9" name="GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9"></a><h4 id="ZZPRE-GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9" class="sect4"><span class="enumeration_section">10.12.2 </span>With Method 2
                  </h4>
                  <div>
                     <p><a id="d71876e2016" class="indexterm-anchor"></a>If the PL/SQL block contains a known number of input and output host variables, you can use Method 2 to <code class="codeph">PREPARE</code> and <code class="codeph">EXECUTE</code> the PL/SQL string in the usual way.
                     </p>
                     <p>You must put <span class="italic">all</span> host variables in the USING clause. When the PL/SQL string is <code class="codeph">EXECUTEd</code>, host variables in the USING clause replace corresponding placeholders in the <code class="codeph">PREPAREd</code> string. Though the precompiler treats all PL/SQL host variables as input host variables, values are assigned correctly. Input (program) values are assigned to input host variables, and output (column) values are assigned to output host variables.
                     </p>
                     <p>Every placeholder in the <code class="codeph">PREPAREd</code> PL/SQL string must correspond to a host variable in the <code class="codeph">USING</code> clause. So, if the same placeholder appears two or more times in the <code class="codeph">PREPAREd</code> string, each appearance must correspond to a host variable in the USING clause.
                     </p>
                  </div>
               </div><a id="ZZPRE907"></a><div class="props_rev_3"><a id="GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04" name="GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04"></a><h4 id="ZZPRE-GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04" class="sect4"><span class="enumeration_section">10.12.3 </span>With Method 3
                  </h4>
                  <div>
                     <p><a id="d71876e2071" class="indexterm-anchor"></a>Methods 2 and 3 are the same except that Method 3 allows <code class="codeph">FETCHing</code>. Since you cannot <code class="codeph">FETCH</code> from a PL/SQL block, use Method 2 instead.
                     </p>
                  </div>
               </div><a id="ZZPRE908"></a><div class="props_rev_3"><a id="GUID-8A644727-9074-424E-AF79-AA6603091DA3" name="GUID-8A644727-9074-424E-AF79-AA6603091DA3"></a><h4 id="ZZPRE-GUID-8A644727-9074-424E-AF79-AA6603091DA3" class="sect4"><span class="enumeration_section">10.12.4 </span>With Method 4
                  </h4>
                  <div>
                     <p><a id="d71876e2103" class="indexterm-anchor"></a>If the PL/SQL block contains an unknown number of input or output host variables, you must use Method 4.
                     </p>
                     <p>To use Method 4, you set up one bind descriptor for all the input and output host variables. Executing <code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code> stores information about input <span class="italic">and</span> output host variables in the bind descriptor. Because the precompiler treats all PL/SQL host variables as input host variables, executing <code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code> has no effect.
                     </p>
                     <p>The use of bind descriptors with Method 4 is detailed in your host-language supplement.</p>
                     <div class="infoboxnote" id="GUID-8A644727-9074-424E-AF79-AA6603091DA3__GUID-7EAD97A0-939E-447A-B096-27A0121065AB">
                        <p class="notep1">Note:</p>
                        <p> In dynamic SQL Method 4, a host array cannot be bound to a PL/SQL procedure with a parameter of type "table."</p>
                     </div>
                  </div>
               </div><a id="ZZPRE909"></a><div class="props_rev_3"><a id="GUID-F12F7699-0216-407A-8DED-A3F068C839A6" name="GUID-F12F7699-0216-407A-8DED-A3F068C839A6"></a><h4 id="ZZPRE-GUID-F12F7699-0216-407A-8DED-A3F068C839A6" class="sect4"><span class="enumeration_section">10.12.5 </span>Caution
                  </h4>
                  <div>
                     <p><a id="d71876e2158" class="indexterm-anchor"></a>Do not use ANSI-style comments (- - ...) in a PL/SQL block that will be processed dynamically because end-of-line characters are ignored. As a result, ANSI-style comments extend to the end of the block, not just to the end of a line. Instead, use C-style comments (/* ... */).
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>