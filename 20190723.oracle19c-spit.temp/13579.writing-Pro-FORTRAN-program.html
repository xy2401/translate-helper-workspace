<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Writing a Pro*FORTRAN Program</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Supplement to the Oracle Precompilers Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Supplement to the Oracle Precompilers Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="fortran-supplement-oracle-precompilers.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T01:30:46-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1994, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96472-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="preface.html" title="Previous" type="text/html">
      <link rel="next" href="error-handling-and-diagnostics.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*FORTRAN Supplement to the Oracle Precompilers">
    <meta name="dcterms.isVersionOf" content="ZZFOR">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="preface.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="error-handling-and-diagnostics.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Supplement to the Oracle Precompilers Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Writing a Pro*FORTRAN Program</li>
            </ol>
            <a id="GUID-6CA45FB3-3F07-47F9-BDF5-602BDE0578BE" name="GUID-6CA45FB3-3F07-47F9-BDF5-602BDE0578BE"></a><a id="ZZFOR107"></a>
            
            <h2 id="ZZFOR-GUID-6CA45FB3-3F07-47F9-BDF5-602BDE0578BE" class="sect2"><span class="enumeration_chapter">1 </span> Writing a Pro*FORTRAN Program
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter provides basic information  for writing a Pro*FORTRAN program:</p>
               <div class="infoboxnote" id="GUID-6CA45FB3-3F07-47F9-BDF5-602BDE0578BE__GUID-3079AA62-879C-4F9D-B369-5B5465F63B48">
                  <p class="notep1">Note:</p>
                  <p>The Pro*Fortran Precompiler is NOT supported in 64 bit Oracle Database installations. </p>
                  <p>The Pro*Fortran Precompiler is only supported and available in Oracle Database 32 bit Client installations.</p>
               </div>
               <p>This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-39755AD8-642E-4522-87CC-007EF146D2DF">Programming Guidelines</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-7761FB2D-04E6-4ECF-B9D5-2C4DAFFE43B3">Required Declarations and SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-21F9AD0C-D7BF-49E9-B66B-ACBA613F5DFF">Host Variable Names</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-379B5871-299B-4D07-9C25-C86FF1986FF8">Scope of Host Variables</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-D7950FBD-CF21-432A-9734-FFCAD77D9004">Host Variables</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-C1EE0D71-FA0F-40AB-A5E6-AD088E8D59CD">About Referencing Host Variables</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-6DF12FC0-20F3-4492-9DF9-A1D9B4C06B4B">Indicator Variables</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-E5D4F976-D222-49D9-864B-ABB758BFF1BE">Host Arrays</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-FA24E636-1372-40B5-A6CC-2AC54B5BFD60">VARCHAR Host Variables</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-93D22B55-7110-484C-A48C-1633CF8EBFB8">About Handling Character Data</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-B567760E-18C0-4C00-A520-68F64507591A">The Oracle Datatypes</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-B1D58589-9169-4A8B-9B0F-4D4233517784">Datatype Conversion</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-CD1D2DEB-07EE-4DA3-9D27-04FBE0A1F51A">Datatype Equivalencing</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-39098A75-F8FC-4CAB-91EB-8133B9C4A382">Embedding PL/SQL</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-7A1CE308-3AAB-46BD-B626-F2998DCF457C">About Declaring a Cursor Variable</a></p>
                  </li>
                  <li>
                     <p><a href="writing-Pro-FORTRAN-program.html#GUID-A0304B39-A1A3-4608-B2F4-A30CB42AFDA3">Connecting to Oracle</a></p>
                  </li>
               </ul>
            </div><a id="ZZFOR108"></a><div class="props_rev_3"><a id="GUID-39755AD8-642E-4522-87CC-007EF146D2DF" name="GUID-39755AD8-642E-4522-87CC-007EF146D2DF"></a><h3 id="ZZFOR-GUID-39755AD8-642E-4522-87CC-007EF146D2DF" class="sect3"><span class="enumeration_section">1.1 </span>Programming Guidelines
               </h3>
               <div>
                  <p>This section deals with embedded SQL syntax, coding conventions, and FORTRAN-specific features and restrictions. Topics are arranged alphabetically.</p>
               </div>
               <div class="props_rev_3"><a id="GUID-39663C50-B662-43B2-98E6-517B88576F64" name="GUID-39663C50-B662-43B2-98E6-517B88576F64"></a><h4 id="ZZFOR-GUID-39663C50-B662-43B2-98E6-517B88576F64" class="sect4"><span class="enumeration_section">1.1.1 </span>32 bit vs 64 bit
                  </h4>
                  <div>
                     <div class="section">
                        <p>The Pro*Fortran Precompiler is NOT supported in 64 bit Oracle environments. </p>
                        <p>The Pro*Fortran Precompiler is only supported and available in Oracle Database 32 bit Client installations.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR109"></a><div class="props_rev_3"><a id="GUID-5EB82D2B-16A0-4821-AFEA-DC1F7AF2586B" name="GUID-5EB82D2B-16A0-4821-AFEA-DC1F7AF2586B"></a><h4 id="ZZFOR-GUID-5EB82D2B-16A0-4821-AFEA-DC1F7AF2586B" class="sect4"><span class="enumeration_section">1.1.2 </span>Case-sensitivity
                  </h4>
                  <div>
                     <div class="section">
                        <p>Though the standard FORTRAN character set excludes lowercase alpha characters, many compilers allow them in identifiers, comments, and quoted literals.</p>
                        <p>The Pro*FORTRAN Precompiler is not case-sensitive; however, some compilers are. If your compiler is case-sensitive, you must declare and reference variables in the same uppercase/lowercase format. Check your FORTRAN compiler user's guide.</p>
                        <p>You must code EXEC SQL and EXEC ORACLE statements in columns 7 through 72 (columns 73 through 80 are ignored). The other columns are used for the following purposes:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Column 1 can indicate a comment line or can be part of an optional statement label.</p>
                           </li>
                           <li>
                              <p>Columns 2 through 5 can contain an optional statement label.</p>
                           </li>
                           <li>
                              <p>Column 6 indicates continuation lines.</p>
                           </li>
                        </ul>
                        <p>On some systems, <span class="italic">terminal format</span> is supported; that is, entry is not restricted to certain columns. In this manual, the program fragments and sample programs are in ANSI format (FORMAT=ANSI).
                        </p>
                        <p>No more than one statement can appear on a single line.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR110"></a><div class="props_rev_3"><a id="GUID-6C64564B-B985-4A18-99CE-E22B0FF757D0" name="GUID-6C64564B-B985-4A18-99CE-E22B0FF757D0"></a><h4 id="ZZFOR-GUID-6C64564B-B985-4A18-99CE-E22B0FF757D0" class="sect4"><span class="enumeration_section">1.1.3 </span>Comments
                  </h4>
                  <div>
                     <p>You can place FORTRAN comment lines within SQL statements. FORTRAN comment lines start with the letter C or an asterisk (*) in column 1. You can place ANSI SQL-style comments (- - ...) in SQL statements at the end of a line, and you can also place C-style comments (/* ... */) in SQL statements.</p>
                     <p>The following example shows all three styles of comments:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME, SAL
C Assign column values to host variables.
 1 INTO :ENAM, :ESAL -- output host variables
 2 FROM EMP
 3 /* Use input host variable in
 4 search condition */
 5 WHERE DEPTNO = :DNUM
</pre><div class="infoboxnote" id="GUID-6C64564B-B985-4A18-99CE-E22B0FF757D0__GUID-99FBF62B-A1BE-4C22-A6E0-563CE17E5763">
                        <p class="notep1">Note:</p>
                        <p>You cannot nest comments. Blank lines are treated as comments, but are <span class="italic">not</span> allowed within a continued statement.
                        </p>
                     </div>
                  </div>
               </div><a id="ZZFOR111"></a><div class="props_rev_3"><a id="GUID-861175B4-1014-4EB2-8006-CC71D50D3DFC" name="GUID-861175B4-1014-4EB2-8006-CC71D50D3DFC"></a><h4 id="ZZFOR-GUID-861175B4-1014-4EB2-8006-CC71D50D3DFC" class="sect4"><span class="enumeration_section">1.1.4 </span>Continuation Lines
                  </h4>
                  <div>
                     <p>You can continue SQL statements from one line to the next, according to the rules of FORTRAN. To code a continuation line, place a nonzero, non-blank character in column 6. In this manual, digits are used as continuation characters, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">* Retrieve employee data.
 EXEC SQL SELECT EMPNO, ENAME, JOB, SAL
 1 INTO :ENUM, :ENAM, :EJOB, :ESAL
 2 FROM EMP
 3 WHERE DEPTNO = :DNUM
</pre><p>To continue a string literal from one line to the next, code the literal through column 72. On the next line, code a continuation character and the rest of the literal. An example follows:</p><pre class="oac_no_warn" dir="ltr">* Execute dynamic SQL statement.
 EXEC SQL EXECUTE IMMEDIATE 'UPDATE EMP SET COMM = 500 WHERE
 1 DEPTNO=20'
</pre><p>Most FORTRAN implementations allow up to 19 continuation lines. Check your FORTRAN compiler user's guide.</p>
                  </div>
               </div><a id="ZZFOR112"></a><div class="props_rev_3"><a id="GUID-A7B38BA8-3654-489F-8FB7-A59ADE8885D9" name="GUID-A7B38BA8-3654-489F-8FB7-A59ADE8885D9"></a><h4 id="ZZFOR-GUID-A7B38BA8-3654-489F-8FB7-A59ADE8885D9" class="sect4"><span class="enumeration_section">1.1.5 </span>Delimiters
                  </h4>
                  <div>
                     <p>Though FORTRAN does not require blanks to delimit keywords, you must use blanks to delimit keywords in SQL statements. FORTRAN uses apostrophes to delimit string literals, as in</p><pre class="oac_no_warn" dir="ltr">* Display employee name.
 IF (ENAM .LT. 'ZZZZZ') THEN
 PRINT *, ' Employee Name: ', ENAM
 END IF
</pre><p>SQL also uses apostrophes to delimit string literals, as in</p><pre class="oac_no_warn" dir="ltr">* Retrieve employee data.
 EXEC SQL SELECT ENAME, SAL
 1 INTO :ENAM, :ESAL
 2 FROM EMP
 3 WHERE JOB = 'CLERK'
</pre><p>SQL also uses quotation marks to delimit identifiers containing special or lowercase characters. </p>
                  </div>
               </div><a id="ZZFOR113"></a><div class="props_rev_3"><a id="GUID-6E4F8E05-58DD-41C6-AB8D-6A5E45CB0D9C" name="GUID-6E4F8E05-58DD-41C6-AB8D-6A5E45CB0D9C"></a><h4 id="ZZFOR-GUID-6E4F8E05-58DD-41C6-AB8D-6A5E45CB0D9C" class="sect4"><span class="enumeration_section">1.1.6 </span>Embedded SQL Syntax
                  </h4>
                  <div>
                     <p>To use a SQL statement in your host program, precede the SQL statement with the EXEC SQL clause. Embedded SQL syntax is described in the <a href="../lnpcc/introduction.html#LNPCC-GUID-20CBCC27-EC6B-4651-92CC-7E008BD73611" target="_blank"><span class="italic">Pro*C/C++ Programmer's Guide</span></a>. The precompiler translates all EXEC SQL statements into calls to the runtime library SQLLIB.
                     </p>
                  </div>
               </div><a id="ZZFOR114"></a><div class="props_rev_3"><a id="GUID-FC75FF3D-BA99-4D2B-A90E-EF5E9274501B" name="GUID-FC75FF3D-BA99-4D2B-A90E-EF5E9274501B"></a><h4 id="ZZFOR-GUID-FC75FF3D-BA99-4D2B-A90E-EF5E9274501B" class="sect4"><span class="enumeration_section">1.1.7 </span>File Length
                  </h4>
                  <div>
                     <p>The Pro*FORTRAN Precompiler cannot process arbitrarily long source files. Some of the variables used internally limit the size of the generated file. There is no absolute limit to the number of lines allowed, but the following aspects of the source files are contributing factors to the file-size constraint:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>complexity of the embedded SQL statements (for example, the number of bind and define variables)</p>
                        </li>
                        <li>
                           <p>whether a database name is used (for example, connecting to a database with an AT clause)</p>
                        </li>
                        <li>
                           <p>number of embedded SQL statements</p>
                        </li>
                     </ul>
                     <p>To prevent problems related to this limitation, use multiple program units to reduce the size of the source files as required.</p>
                  </div>
               </div><a id="ZZFOR115"></a><div class="props_rev_3"><a id="GUID-9A7D1E69-07F3-4866-B21F-69877272BEB3" name="GUID-9A7D1E69-07F3-4866-B21F-69877272BEB3"></a><h4 id="ZZFOR-GUID-9A7D1E69-07F3-4866-B21F-69877272BEB3" class="sect4"><span class="enumeration_section">1.1.8 </span>File Naming Restrictions
                  </h4>
                  <div>
                     <p>Avoid using filenames starting with "sql," because errors might occur. For example, if you name a file SQLERROR.PFO, some linkers return name conflicts because there will be an array named SQLERD and a common block named SQLERD.</p>
                  </div>
               </div><a id="ZZFOR116"></a><div class="props_rev_3"><a id="GUID-9B544D4A-4B21-4BD9-950B-42588A39ABEA" name="GUID-9B544D4A-4B21-4BD9-950B-42588A39ABEA"></a><h4 id="ZZFOR-GUID-9B544D4A-4B21-4BD9-950B-42588A39ABEA" class="sect4"><span class="enumeration_section">1.1.9 </span>FORTRAN Versions
                  </h4>
                  <div>
                     <p>The Pro*FORTRAN Precompiler supports the standard implementation of FORTRAN for your operating system (usually FORTRAN 77). For more information, see your Oracle system-specific documentation.</p>
                  </div>
               </div>
            </div><a id="ZZFOR117"></a><div class="props_rev_3"><a id="GUID-7761FB2D-04E6-4ECF-B9D5-2C4DAFFE43B3" name="GUID-7761FB2D-04E6-4ECF-B9D5-2C4DAFFE43B3"></a><h3 id="ZZFOR-GUID-7761FB2D-04E6-4ECF-B9D5-2C4DAFFE43B3" class="sect3"><span class="enumeration_section">1.2 </span>Required Declarations and SQL Statements
               </h3>
               <div>
                  <p>Passing data between Oracle and your application program requires host variables and event handling. This section shows you how to meet these requirements.</p>
               </div><a id="ZZFOR118"></a><div class="props_rev_3"><a id="GUID-03BDF71B-FBBD-4FEE-B5CF-4EE88B243272" name="GUID-03BDF71B-FBBD-4FEE-B5CF-4EE88B243272"></a><h4 id="ZZFOR-GUID-03BDF71B-FBBD-4FEE-B5CF-4EE88B243272" class="sect4"><span class="enumeration_section">1.2.1 </span>The Declare Section
                  </h4>
                  <div>
                     <p>You must declare all program variables to be used in SQL statements in the <span class="italic">Declare Section</span>, which begins with the statement
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION
</pre><p>and ends with the statement</p><pre class="oac_no_warn" dir="ltr">EXEC SQL END DECLARE SECTION
</pre><p>Between these two statements only the following are allowed:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>host variable and indicator variable declarations</p>
                        </li>
                        <li>
                           <p>EXEC SQL DECLARE statements</p>
                        </li>
                        <li>
                           <p>EXEC SQL INCLUDE statements</p>
                        </li>
                        <li>
                           <p>EXEC SQL VAR statements</p>
                        </li>
                        <li>
                           <p>EXEC ORACLE statements</p>
                        </li>
                        <li>
                           <p>FORTRAN comments</p>
                        </li>
                     </ul>
                     <p>In a Pro*FORTRAN source file, multiple program units can contain SQL statements. So, multiple Declare Sections are allowed for each precompiled unit. Furthermore, a Pro*FORTRAN program can contain multiple files.</p>
                  </div>
               </div><a id="ZZFOR119"></a><div class="props_rev_3"><a id="GUID-651BC723-1B41-4847-97F4-BC1CCAF1445E" name="GUID-651BC723-1B41-4847-97F4-BC1CCAF1445E"></a><h4 id="ZZFOR-GUID-651BC723-1B41-4847-97F4-BC1CCAF1445E" class="sect4"><span class="enumeration_section">1.2.2 </span>Using the INCLUDE Statement
                  </h4>
                  <div>
                     <div class="section">
                        <p>FORTRAN INCLUDEs are processed by the FORTRAN compiler, while EXEC SQL INCLUDE statements are processed by Pro*FORTRAN to copy files into your host program, as illustrated in the following example:</p><pre class="oac_no_warn" dir="ltr">* Copy in the SQL Communications Area (SQLCA)
* and the Oracle Communications Area (ORACA).
 EXEC SQL INCLUDE SQLCA
 EXEC SQL INCLUDE ORACA
</pre><p>You can INCLUDE any file. When you precompile a Pro*FORTRAN program, each EXEC SQL INCLUDE statement is replaced by a copy of the file named in the statement.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR120"></a><div class="props_rev_3"><a id="GUID-19AD5252-7B92-4ADB-98AD-0CA4AF06B13B" name="GUID-19AD5252-7B92-4ADB-98AD-0CA4AF06B13B"></a><h4 id="ZZFOR-GUID-19AD5252-7B92-4ADB-98AD-0CA4AF06B13B" class="sect4"><span class="enumeration_section">1.2.3 </span>Filename Extensions
                  </h4>
                  <div>
                     <p>If your system uses file extensions but you do not specify one, the Pro*FORTRAN Precompiler assumes the default extension for source files (usually FOR or F). The default extension is system dependent. For more information, see your Oracle system-specific documentation.</p>
                  </div>
               </div><a id="ZZFOR121"></a><div class="props_rev_3"><a id="GUID-9CB9322E-6B0A-43C6-ACF2-CB55A3602A83" name="GUID-9CB9322E-6B0A-43C6-ACF2-CB55A3602A83"></a><h4 id="ZZFOR-GUID-9CB9322E-6B0A-43C6-ACF2-CB55A3602A83" class="sect4"><span class="enumeration_section">1.2.4 </span>Search Paths
                  </h4>
                  <div>
                     <p>If your system uses directories, you can set a search path for INCLUDE files using the INCLUDE precompiler option, as follows:</p><pre class="oac_no_warn" dir="ltr">INCLUDE=<span class="italic">path</span> 
</pre><p>where <span class="italic">path</span> defaults to the current directory.
                     </p>
                     <p>The precompiler first searches the current directory, then the directory specified by the INCLUDE option, and finally the directory for standard INCLUDE files. You need not specify a path for standard files such as the SQLCA and ORACA. However, a path is required for nonstandard files unless they are stored in the current directory.</p>
                     <p>You can also specify multiple paths on the command line, as follows:</p><pre class="oac_no_warn" dir="ltr">... INCLUDE=&lt;path1&gt; INCLUDE=&lt;path2&gt; ...
</pre><p>When multiple paths are specified, the precompiler searches the current directory first, then the <span class="italic">path1</span> directory, then the <span class="italic">path2</span> directory, and so on. The directory containing standard INCLUDE files is searched last. The path syntax is system specific. Check the Oracle installation or user's guide for your system.
                     </p>
                  </div>
               </div><a id="ZZFOR122"></a><div class="props_rev_3"><a id="GUID-98AD7182-2202-43C8-AF1E-65C5B065EA0C" name="GUID-98AD7182-2202-43C8-AF1E-65C5B065EA0C"></a><h4 id="ZZFOR-GUID-98AD7182-2202-43C8-AF1E-65C5B065EA0C" class="sect4"><span class="enumeration_section">1.2.5 </span>Caution
                  </h4>
                  <div>
                     <p>Remember, the precompiler searches for a file in the current directory first even if you specify a search path. If the file you want to INCLUDE is in another directory, make sure no file with the same name is in the current directory or any other directory that precedes it in the search path. Also, if your operating system is case-sensitive, you must specify the same upper or lower case filename under which the file is stored.</p>
                  </div>
               </div><a id="ZZFOR123"></a><div class="props_rev_3"><a id="GUID-5C9DE4AE-EB45-4726-8135-313F97441A18" name="GUID-5C9DE4AE-EB45-4726-8135-313F97441A18"></a><h4 id="ZZFOR-GUID-5C9DE4AE-EB45-4726-8135-313F97441A18" class="sect4"><span class="enumeration_section">1.2.6 </span>Event and Error Handling
                  </h4>
                  <div>
                     <p>Pro*FORTRAN provides forward and backward compatibility when checking the outcome of executing SQL statements. However, there are restrictions on using SQLCA, SQLCODE, and SQLSTATE depending on the MODE and DBMS option settings. For more information, see <a href="../zzpre/error-handling-diagnostics.html#ZZPRE-GUID-75EB7FA6-5080-44B1-B96D-C542EBB16088" target="_blank">Error Handling and Diagnostics</a>.
                     </p>
                  </div>
               </div>
            </div><a id="ZZFOR124"></a><div class="props_rev_3"><a id="GUID-21F9AD0C-D7BF-49E9-B66B-ACBA613F5DFF" name="GUID-21F9AD0C-D7BF-49E9-B66B-ACBA613F5DFF"></a><h3 id="ZZFOR-GUID-21F9AD0C-D7BF-49E9-B66B-ACBA613F5DFF" class="sect3"><span class="enumeration_section">1.3 </span>Host Variable Names
               </h3>
               <div>
                  <p>Host variable names must consist only of letters and digits, and must begin with a letter. They can be of any length, but only the first 31 characters are significant. Some compilers prohibit variable names longer than six characters, or ignore characters after the sixth. Check your FORTRAN compiler user's guide.</p>
               </div><a id="ZZFOR126"></a><a id="ZZFOR127"></a><a id="ZZFOR125"></a><div class="props_rev_3"><a id="GUID-356222B9-304C-4759-A316-C8F75F1DE744" name="GUID-356222B9-304C-4759-A316-C8F75F1DE744"></a><h4 id="ZZFOR-GUID-356222B9-304C-4759-A316-C8F75F1DE744" class="sect4"><span class="enumeration_section">1.3.1 </span>Logical and Relational Operators
                  </h4>
                  <div>
                     <div class="section">
                        <p>Logical and relational operators are different for FORTRAN and SQL, as shown in the following tables, respectively. For example, the SQL operators do not have leading and trailing periods, as shown in table 1-1 and table 1-2.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-356222B9-304C-4759-A316-C8F75F1DE744__GUID-1946588A-631C-4DF4-A5E6-4F16394BFE6B">
                        <p class="titleintable">Table 1-1 Logical Operators</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Logical Operators" summary="Logical Operators" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="51%" id="d1790e686">SQL Operators</th>
                                 <th align="left" valign="bottom" width="49%" id="d1790e689">FORTRAN Operators</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="51%" id="d1790e694" headers="d1790e686 ">
                                    <p>NOT</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d1790e694 d1790e689 ">
                                    <p>.NOT.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="51%" id="d1790e701" headers="d1790e686 ">
                                    <p>AND</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d1790e701 d1790e689 ">
                                    <p>.AND.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="51%" id="d1790e708" headers="d1790e686 ">
                                    <p>OR</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d1790e708 d1790e689 ">
                                    <p>.OR.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="51%" id="d1790e715" headers="d1790e686 ">
                                    <p>--</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d1790e715 d1790e689 ">
                                    <p>.EQV.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="51%" id="d1790e722" headers="d1790e686 ">
                                    <p>--</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d1790e722 d1790e689 ">
                                    <p>.NEQV.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-356222B9-304C-4759-A316-C8F75F1DE744__GUID-C0DB8BAC-99AC-4527-AC69-E67514915CDA">
                        <p class="titleintable">Table 1-2 Relational Operator</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Relational Operator" summary="Relational Operator" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="54%" id="d1790e738">SQL Operators</th>
                                 <th align="left" valign="bottom" width="46%" id="d1790e741">FORTRAN operators</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e746" headers="d1790e738 ">
                                    <p>=</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e746 d1790e741 ">
                                    <p>.EQ.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e753" headers="d1790e738 ">
                                    <p>&lt;&gt;, !=, ^=</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e753 d1790e741 ">
                                    <p>.NE.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e760" headers="d1790e738 ">
                                    <p>&gt;</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e760 d1790e741 ">
                                    <p>.GT.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e767" headers="d1790e738 ">
                                    <p>&lt;</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e767 d1790e741 ">
                                    <p>.LT.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e774" headers="d1790e738 ">
                                    <p>&gt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e774 d1790e741 ">
                                    <p>.GE.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="54%" id="d1790e781" headers="d1790e738 ">
                                    <p>&lt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d1790e781 d1790e741 ">
                                    <p>.LE.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>Logical and relational FORTRAN operators are <span class="italic">not</span> allowed in SQL statements.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR128"></a><div class="props_rev_3"><a id="GUID-6627D368-0853-469D-9022-ED8C2EC82BF0" name="GUID-6627D368-0853-469D-9022-ED8C2EC82BF0"></a><h4 id="ZZFOR-GUID-6627D368-0853-469D-9022-ED8C2EC82BF0" class="sect4"><span class="enumeration_section">1.3.2 </span>MAXLITERAL Default
                  </h4>
                  <div>
                     <div class="section">
                        <p>With the MAXLITERAL precompiler option, you can specify the maximum length of string literals generated by the precompiler, so that compiler limits are not exceeded. For Pro*FORTRAN, the default value is 1000, but you might need to specify a lower value.</p>
                        <p>For example, if your FORTRAN compiler cannot handle string literals longer than 512 characters, specify MAXLITERAL=512. Check your FORTRAN compiler user's guide.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR129"></a><div class="props_rev_3"><a id="GUID-59B35440-F071-4A43-BD90-C5130BBFF880" name="GUID-59B35440-F071-4A43-BD90-C5130BBFF880"></a><h4 id="ZZFOR-GUID-59B35440-F071-4A43-BD90-C5130BBFF880" class="sect4"><span class="enumeration_section">1.3.3 </span>Nulls
                  </h4>
                  <div>
                     <p>In SQL, a null represents a missing, unknown, or inapplicable column value; it equates neither to zero nor to a blank. Use the NVL function to convert nulls to non-null values, use the IS [NOT] NULL comparison operator to search for nulls, and use indicator variables to insert and test for nulls.</p>
                  </div>
               </div><a id="ZZFOR130"></a><div class="props_rev_3"><a id="GUID-8BBA55DE-CB29-48A5-B4F6-510982570AE4" name="GUID-8BBA55DE-CB29-48A5-B4F6-510982570AE4"></a><h4 id="ZZFOR-GUID-8BBA55DE-CB29-48A5-B4F6-510982570AE4" class="sect4"><span class="enumeration_section">1.3.4 </span>Program Units
                  </h4>
                  <div>
                     <p>In FORTRAN, a <span class="italic">program unit</span> is a function, subroutine, or main program. In Pro*FORTRAN, an input file contains one or more program units.
                     </p>
                     <p>If a program unit contains SQL statements, it must</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>define all local host variables in its Declare Section</p>
                        </li>
                        <li>
                           <p>INCLUDE the SQLCA when MODE={ORACLE|ANSI13}</p>
                        </li>
                        <li>
                           <p>declare a variable named SQLATA or SQLCOD inside or outside the Declare Section when MODE={ANSI|ANSI14}</p>
                        </li>
                        <li>
                           <p>INCLUDE the ORACA if you specify ORACA=YES</p>
                        </li>
                     </ul>
                     <p>Multiple program units can contain SQL statements. For example, you can DECLARE a cursor in one program unit, OPEN it in another, FETCH from it in yet another, and CLOSE it in still another as long as they are in the same file.</p>
                  </div>
               </div>
            </div><a id="ZZFOR131"></a><div class="props_rev_3"><a id="GUID-379B5871-299B-4D07-9C25-C86FF1986FF8" name="GUID-379B5871-299B-4D07-9C25-C86FF1986FF8"></a><h3 id="ZZFOR-GUID-379B5871-299B-4D07-9C25-C86FF1986FF8" class="sect3"><span class="enumeration_section">1.4 </span>Scope of Host Variables
               </h3>
               <div>
                  <p>The scoping rules for FORTRAN identifiers apply to host variables. Host variables declared in a program unit are local to that unit, and host variables declared in the main program are <span class="italic">not</span> global. So, all host variables used in a program unit must be declared in that unit in the Declare Section.
                  </p>
               </div><a id="ZZFOR132"></a><div class="props_rev_3"><a id="GUID-CB98185C-BA60-4D07-BC93-13787B72F22C" name="GUID-CB98185C-BA60-4D07-BC93-13787B72F22C"></a><h4 id="ZZFOR-GUID-CB98185C-BA60-4D07-BC93-13787B72F22C" class="sect4"><span class="enumeration_section">1.4.1 </span>Statement Labels
                  </h4>
                  <div>
                     <p>You can associate FORTRAN numeric statement labels (1 - 99999) with SQL statements, as shown in the following example:</p><pre class="oac_no_warn" dir="ltr">* Insert row into employee table.
 500 EXEC SQL INSERT INTO EMP (EMPNO, ENAME, JOB, DEPTNO)
 1 VALUES (:ENUM, :ENAM, :EJOB, :DNUM)
</pre><p>And, you can reference statement labels in a WHENEVER DO or WHENEVER GOTO statement, as this example shows:</p><pre class="oac_no_warn" dir="ltr">* Handle SQL execution errors.
 EXEC SQL WHENEVER SQLERROR GOTO 900
 ...
* SQLEMC stores the Oracle error code and message.
 900 WRITE (*, 8500) SQLEMC
 8500 FORMAT (1X, 70A1)
 ...
</pre><p>Statement labels must be coded in columns 1 through 5, and must <span class="italic">not</span> appear in continuation lines. Statement labels may consist of alphanumeric characters, only; the special characters, underscore ( _ ), hyphen (-), and dollar sign ($) are not allowed.
                     </p>
                     <p>The Pro*FORTRAN Precompiler does not use statement labels in generated code. Therefore, the BEGLABEL and ENDLABEL options that were available in earlier Pro*FORTRAN versions are not supported in this version and will return an informational message if found.</p>
                  </div>
               </div><a id="ZZFOR133"></a><div class="props_rev_3"><a id="GUID-6C6EB142-2B75-4D22-A0B8-6DB7ABCD824F" name="GUID-6C6EB142-2B75-4D22-A0B8-6DB7ABCD824F"></a><h4 id="ZZFOR-GUID-6C6EB142-2B75-4D22-A0B8-6DB7ABCD824F" class="sect4"><span class="enumeration_section">1.4.2 </span>Statement Terminator
                  </h4>
                  <div>
                     <p>Embedded SQL statements are terminated by an end-of-line, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">* Delete employee.
 EXEC SQL DELETE FROM EMP WHERE EMPNO = :ENUM
</pre><p>However, a continuation character on the next line overrides an end-of-line.</p>
                  </div>
               </div>
            </div><a id="ZZFOR134"></a><div class="props_rev_3"><a id="GUID-D7950FBD-CF21-432A-9734-FFCAD77D9004" name="GUID-D7950FBD-CF21-432A-9734-FFCAD77D9004"></a><h3 id="ZZFOR-GUID-D7950FBD-CF21-432A-9734-FFCAD77D9004" class="sect3"><span class="enumeration_section">1.5 </span>Host Variables
               </h3>
               <div>
                  <p>Host variables are the key to communication between your host program and Oracle. Typically, a host program inputs data to Oracle, and Oracle outputs data to the program. Oracle stores input data in database columns and stores output data in program host variables.</p>
               </div><a id="ZZFOR135"></a><div class="props_rev_3"><a id="GUID-12420FAA-2E0F-4894-8B9B-760CE8631898" name="GUID-12420FAA-2E0F-4894-8B9B-760CE8631898"></a><h4 id="ZZFOR-GUID-12420FAA-2E0F-4894-8B9B-760CE8631898" class="sect4"><span class="enumeration_section">1.5.1 </span>Declaring Host Variables
                  </h4>
                  <div>
                     <p>Host variables are declared according to FORTRAN rules, using the FORTRAN datatypes that are supported by Oracle. FORTRAN datatypes must be compatible with the source/target database column. The supported FORTRAN datatypes are shown in the following table. One-dimensional arrays of FORTRAN types are also supported.</p>
                     <div class="tblformal" id="GUID-12420FAA-2E0F-4894-8B9B-760CE8631898__GUID-83E792D2-0EEE-46F4-8727-7BCADEAA9372">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="variable declaration" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="50%" id="d1790e1021">Variable Declaration</th>
                                 <th align="left" valign="bottom" width="50%" id="d1790e1024">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1029" headers="d1790e1021 ">
                                    <p>BYTE <span class="italic">var</span> CHARACTER <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1029 d1790e1024 ">
                                    <p>single character</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1041" headers="d1790e1021 ">
                                    <p>CHARACTER <span class="italic">var</span>*<span class="italic">n</span> CHARACTER*<span class="italic">n var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1041 d1790e1024 ">
                                    <p><span class="italic">n</span>-byte character string
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1058" headers="d1790e1021 ">
                                    <p>CHARACTER(*) <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1058 d1790e1024 ">
                                    <p>character string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1067" headers="d1790e1021 ">
                                    <p>INTEGER <span class="italic">var</span> INTEGER*2 <span class="italic">var</span> INTEGER*4 <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1067 d1790e1024 ">
                                    <p>default-length integer 2-byte integer 4-byte integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1082" headers="d1790e1021 ">
                                    <p>LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1082 d1790e1024 ">
                                    <p>single character 2-byte character string 4-byte character string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1100" headers="d1790e1021 ">
                                    <p>REAL <span class="italic">var</span> REAL*4 <span class="italic">var</span> REAL*8 <span class="italic">var</span> DOUBLE PRECISION <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1100 d1790e1024 ">
                                    <p>4-byte real number 8-byte real number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1118" headers="d1790e1021 ">
                                    <p>VARCHAR*<span class="italic">n</span></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1118 d1790e1024 ">
                                    <p>&lt;= 32765-byte, variable length character string (3)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d1790e1127" headers="d1790e1021 ">
                                    <p>SQLCURSOR</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d1790e1127 d1790e1024 ">
                                    <p>cursor variable</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">Notes</span>:
                     </p>
                     <ol>
                        <li>
                           <p>The size of FORTRAN numeric types is implementation-dependent. The sizes given in the table are typical but not universal. Check your FORTRAN compiler user's guide.</p>
                        </li>
                        <li>
                           <p>CHARACTER(*) variables have no predetermined length. They are used to specify dummy arguments in a subroutine declaration. The maximum length of an actual argument is returned by the LEN intrinsic function.</p>
                        </li>
                        <li>
                           <p>Variables declared with VARCHAR*<span class="italic">n</span> (not native to FORTRAN) are assigned the VARCHAR external datatype. See "Declaring VARCHAR Variables" for more information.
                           </p>
                        </li>
                     </ol>
                     <p>The following table lists the compatible Oracle internal datatypes.</p>
                     <div class="tblformal" id="GUID-12420FAA-2E0F-4894-8B9B-760CE8631898__GUID-E24A59E2-B7ED-4043-8F4B-BA696B7BB7FD">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="internal type" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d1790e1161">Internal Type</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e1164">FORTRAN Type</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e1167">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e1172" headers="d1790e1161 ">
                                    <p>CHAR(<span class="italic">x</span>) (1)VARCHAR2(<span class="italic">y</span>) (1)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1172 d1790e1164 ">
                                    <p>BYTE CHARACTER CHARACTER*<span class="italic">n</span> VARCHAR*<span class="italic">n var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1172 d1790e1167 ">
                                    <p>single character variable-length string variable-length string variable-length string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e1199" headers="d1790e1161 ">
                                    <p>NUMBER NUMBER (<span class="italic">p</span>,<span class="italic">s</span>) (2)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1199 d1790e1164 ">
                                    <p>CHARACTER*<span class="italic">n</span><span class="italic">var</span> CHARACTER <span class="italic">var</span> *<span class="italic">n</span> CHARACTER(*) DOUBLE PRECISION INTEGER INTEGER*2 INTEGER*4 LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span>REAL REAL*4 REAL*8 VARCHAR*<span class="italic">n</span><span class="italic">var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1199 d1790e1167 ">
                                    <p><span class="italic">n</span>-byte character string (3) character string (as parameter) 8-byte float number integer (default size) 2-byte integer 4-byte integer single character 2-byte character string 4-byte character string float number 4-byte float number 8-byte float number variable-length string
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e1251" headers="d1790e1161 ">
                                    <p>DATE (4)LONG RAW (1)LONG RAW ROWID (5)MLSLABEL (6)</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1251 d1790e1164 ">
                                    <p>CHARACTER*<span class="italic">n var</span> CHARACTER*<span class="italic">n var</span> VARCHAR*<span class="italic">n var1</span>, <span class="italic">var2</span>, <span class="italic">var3</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1251 d1790e1167 ">
                                    <p><span class="italic">n</span>-byte character string <span class="italic">n</span>-byte variable-length string variable-length string
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e1280" headers="d1790e1161 ">
                                    <p>CURSOR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1280 d1790e1164 ">
                                    <p>SQLCURSOR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e1280 d1790e1167 ">
                                    <p>cursor variable</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">Notes</span>:
                     </p>
                     <ol>
                        <li>
                           <p><span class="italic">x</span> ranges from 1 to 255, and 1 is the default. <span class="italic">y</span> ranges from 1 to 2000.
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">p</span> ranges from 2 to 38. <span class="italic">s</span> ranges from -84 to 127.
                           </p>
                        </li>
                        <li>
                           <p>Strings can be converted to NUMBERs only if they consist of convertible characters -- 0 to 9, period (.), +, -, E, e. The NLS settings for your system might change the decimal point from a period (.) to a comma (,).</p>
                        </li>
                        <li>
                           <p>When converted to a string type, the default size of a DATE depends on the NLS settings in effect on your system. When converted to a binary value, the length is 7 bytes.</p>
                        </li>
                        <li>
                           <p>When converted to a string type, a ROWID requires from 18 to 256 bytes.</p>
                        </li>
                     </ol>
                  </div>
               </div><a id="ZZFOR136"></a><div class="props_rev_3"><a id="GUID-94018E56-E07B-4033-BEB2-8D9F4CF1B444" name="GUID-94018E56-E07B-4033-BEB2-8D9F4CF1B444"></a><h4 id="ZZFOR-GUID-94018E56-E07B-4033-BEB2-8D9F4CF1B444" class="sect4"><span class="enumeration_section">1.5.2 </span>Example Declarations
                  </h4>
                  <div>
                     <p>In the following example, several host variables are declared to be used later in a Pro*FORTRAN program:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 INTEGER*2 DNUM
 CHARACTER*15 DNAM
 EXEC SQL END DECLARE SECTION
</pre><p>You can also declare one-dimensional arrays of FORTRAN types, as the next example shows:</p><pre class="oac_no_warn" dir="ltr">* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(100)
 CHARACTER*10 ENAM(100)
 REAL*4 ESAL(100)
 EXEC SQL END DECLARE SECTION
</pre></div>
               </div><a id="ZZFOR137"></a><div class="props_rev_3"><a id="GUID-2B9B1C1D-3616-4E09-B4B0-1C051761FD12" name="GUID-2B9B1C1D-3616-4E09-B4B0-1C051761FD12"></a><h4 id="ZZFOR-GUID-2B9B1C1D-3616-4E09-B4B0-1C051761FD12" class="sect4"><span class="enumeration_section">1.5.3 </span>Repeating Definitions
                  </h4>
                  <div>
                     <p>You can use repeating definitions for datatypes, as in the following example:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 ESAL, ECOM, EBON
 EXEC SQL END DECLARE SECTION
</pre><p>which is equivalent to</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 ESAL
 REAL*4 ECOM
 REAL*4 EBON
 EXEC SQL END DECLARE SECTION 
</pre></div>
               </div><a id="ZZFOR138"></a><div class="props_rev_3"><a id="GUID-7F352525-56DB-4E24-AF59-39AEEBAADE6A" name="GUID-7F352525-56DB-4E24-AF59-39AEEBAADE6A"></a><h4 id="ZZFOR-GUID-7F352525-56DB-4E24-AF59-39AEEBAADE6A" class="sect4"><span class="enumeration_section">1.5.4 </span>Initialization
                  </h4>
                  <div>
                     <p>While it is not necessary to initialize host variables inside the Declare Section, you can use the FORTRAN DATA statement to initialize host variables, as shown in the following example:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 MINSAL
 REAL*4 MAXSAL
 DATA MINSAL, MAXSAL /1000.00, 5000.00/
 EXEC SQL END DECLARE SECTION
</pre><p>DATA statements must come before the first executable FORTRAN statement but after any variable and PARAMETER declarations. Later in your program, you can change the values of variables initialized by a DATA statement. You cannot, however, reuse a DATA statement to reset the changed values.</p>
                  </div>
               </div><a id="ZZFOR139"></a><div class="props_rev_3"><a id="GUID-1F086982-7926-4141-B1E9-D213805A107C" name="GUID-1F086982-7926-4141-B1E9-D213805A107C"></a><h4 id="ZZFOR-GUID-1F086982-7926-4141-B1E9-D213805A107C" class="sect4"><span class="enumeration_section">1.5.5 </span>Constants
                  </h4>
                  <div>
                     <p>You can use the FORTRAN PARAMETER statement inside or outside the Declare Section to assign constant values to host variables, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 PARAMETER (UID = 'AAAAA', PWD = 'BBBBB')
 EXEC SQL END DECLARE SECTION 
</pre></div>
               </div><a id="ZZFOR140"></a><div class="props_rev_3"><a id="GUID-E74F0F62-9EF4-4553-87D8-1B6495ABE818" name="GUID-E74F0F62-9EF4-4553-87D8-1B6495ABE818"></a><h4 id="ZZFOR-GUID-E74F0F62-9EF4-4553-87D8-1B6495ABE818" class="sect4"><span class="enumeration_section">1.5.6 </span>COMMON Blocks
                  </h4>
                  <div>
                     <p>Using the FORTRAN COMMON statement, you can keep host variables and arrays in a common storage area as if they were globally defined, so that you can use their values in different program units. The COMMON statement must appear <span class="italic">outside</span> the Declare Section, and before the first executable FORTRAN statement but after variable declarations. An example follows:
                     </p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 REAL*4 ECOM
 EXEC SQL END DECLARE SECTION
* Define COMMON block.
 COMMON /EMPBLK/ ENUM, ESAL, ECOM
</pre><p>In this example, EMPBLK is the COMMON block name. The names of COMMON blocks, subroutines, and functions are the only globally defined identifiers in a FORTRAN program. You should avoid using blank COMMON blocks.</p>
                     <p>You can make a COMMON block available to other program units by redefining it in those units. You must repeat the type declarations for variables in a COMMON block in all units where the block is used.</p>
                     <p>Only the order and datatypes of variables in the COMMON block matter, not their names. Therefore, the variable names can differ from unit to unit. However, it is good programming practice to use the same names for corresponding variables in each occurrence of a COMMON block.</p>
                     <p>The following restrictions apply to COMMON blocks:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You cannot put VARCHAR variables in a COMMON block.</p>
                        </li>
                        <li>
                           <p>Host arrays cannot be dimensioned in a COMMON statement.</p>
                        </li>
                        <li>
                           <p>You cannot use a DATA statement to initialize variables in a blank COMMON block.</p>
                        </li>
                        <li>
                           <p>With most compilers, CHARACTER variables must appear in their own COMMON blocks; that is, they cannot be mixed with other variables in a COMMON block.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ZZFOR141"></a><div class="props_rev_3"><a id="GUID-7B8A9520-DC11-4CCF-BC0E-EF368B93EED3" name="GUID-7B8A9520-DC11-4CCF-BC0E-EF368B93EED3"></a><h4 id="ZZFOR-GUID-7B8A9520-DC11-4CCF-BC0E-EF368B93EED3" class="sect4"><span class="enumeration_section">1.5.7 </span>EQUIVALENCE Statement
                  </h4>
                  <div>
                     <p>With the FORTRAN EQUIVALENCE statement, you can use two or more host variable names for the same storage location. The EQUIVALENCE statement must appear before the first executable FORTRAN statement.</p>
                     <p>You can equivalence CHARACTER variables only to other CHARACTER variables. You <span class="italic">cannot</span> equivalence VARCHAR variables.
                     </p>
                  </div>
               </div><a id="ZZFOR142"></a><div class="props_rev_3"><a id="GUID-A5722BE8-5B3D-40ED-88DF-0CE15080E97E" name="GUID-A5722BE8-5B3D-40ED-88DF-0CE15080E97E"></a><h4 id="ZZFOR-GUID-A5722BE8-5B3D-40ED-88DF-0CE15080E97E" class="sect4"><span class="enumeration_section">1.5.8 </span>Special Requirements for Subroutines
                  </h4>
                  <div>
                     <p>You must explicitly declare host variables in the Declare Section of the program unit that uses them in SQL statements. Thus, variables passed to a subroutine and used in SQL statements within the subroutine must be declared in the subroutine Declare Section, as illustrated in the following example:</p><pre class="oac_no_warn" dir="ltr">...
 CALL LOGON (UID, PWD)
 ...
 SUBROUTINE LOGON (UID, PWD) 
* Declare host variables in subroutine.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD 
 WRITE(*, 1000) UID
 1000 FORMAT(/,' Connected to Oracle as user: ', A10, /)
 RETURN
 END
</pre></div>
               </div><a id="ZZFOR144"></a><a id="ZZFOR145"></a><a id="ZZFOR143"></a><div class="props_rev_3"><a id="GUID-6A20994E-84BA-4C9E-87AE-830F96DBF196" name="GUID-6A20994E-84BA-4C9E-87AE-830F96DBF196"></a><h4 id="ZZFOR-GUID-6A20994E-84BA-4C9E-87AE-830F96DBF196" class="sect4"><span class="enumeration_section">1.5.9 </span>Restrictions
                  </h4>
                  <div>
                     <p>The following restrictions apply with respect to Declarations:</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6A20994E-84BA-4C9E-87AE-830F96DBF196__GUID-EB1946A7-15A2-4A1D-8F4C-2DCF3F262D71">Implicit Declarations</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>FORTRAN allows implicit declaration of INTEGER and REAL variables. Unless explicitly declared otherwise, identifiers starting with I, J, K, L, M, or N are assumed to be of type INTEGER, and other identifiers are assumed to be of type REAL.</p>
                        <p>However, implicit declaration of host variables is <span class="italic">not</span> allowed; it triggers an "undeclared host variable" error message at precompile time. Every variable referenced in a SQL statement must be defined in the Declare Section.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6A20994E-84BA-4C9E-87AE-830F96DBF196__GUID-EFD5BE86-4636-4716-ADCD-60A3C7A90043">Complex Numbers</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>These are numbers including a real and an imaginary part. In FORTRAN, complex numbers are represented using the datatype COMPLEX. Pro*FORTRAN, however, does <span class="italic">not</span> support the use of COMPLEX host variables in SQL statements.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZFOR146"></a><div class="props_rev_3"><a id="GUID-C1EE0D71-FA0F-40AB-A5E6-AD088E8D59CD" name="GUID-C1EE0D71-FA0F-40AB-A5E6-AD088E8D59CD"></a><h3 id="ZZFOR-GUID-C1EE0D71-FA0F-40AB-A5E6-AD088E8D59CD" class="sect3"><span class="enumeration_section">1.6 </span>About Referencing Host Variables
               </h3>
               <div>
                  <p>You use host variables in SQL data manipulation statements. A host variable must be prefixed with a colon (:) in SQL statements but must not be prefixed with a colon in FORTRAN statements, as shown in the following example:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 CHARACTER*10 EJOB
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 3100)
 3100 FORMAT (' Enter employee number: ')
 READ (*, 3200) ENUM
 3200 FORMAT (I4) 
 EXEC SQL SELECT ENAME, SAL, JOB
 1 INTO :ENAM, :ESAL, :EJOB
 2 FROM EMP
 3 WHERE EMPNO = :ENUM 
 BONUS = ESAL / 10
 ...
</pre><p>Though it might be confusing, you can provide the same name to a host variable as that of an Oracle table or column, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT ENAME, SAL
 1 INTO :ENAM, :ESAL
 2 FROM EMP
 3 WHERE EMPNO = :ENUM
</pre></div><a id="ZZFOR147"></a><div class="props_rev_3"><a id="GUID-7F658F31-F2A3-4BE9-880F-4EF6F7F7C682" name="GUID-7F658F31-F2A3-4BE9-880F-4EF6F7F7C682"></a><h4 id="ZZFOR-GUID-7F658F31-F2A3-4BE9-880F-4EF6F7F7C682" class="sect4"><span class="enumeration_section">1.6.1 </span>Restrictions
                  </h4>
                  <div>
                     <p>A host variable cannot substitute for a column, table, or other Oracle objects in a SQL statement and must not be an Oracle reserved word. See <a href="../zzpre/Oracle-reserved-words-keywords-namespaces.html#ZZPRE-GUID-7ECD5BA3-BDE2-4729-9430-CD41F06745F5" target="_blank">Oracle Reserved Words, Keywords, and Namespaces</a> for a list of Oracle reserved words and keywords.
                     </p>
                  </div>
               </div>
            </div><a id="ZZFOR148"></a><div class="props_rev_3"><a id="GUID-6DF12FC0-20F3-4492-9DF9-A1D9B4C06B4B" name="GUID-6DF12FC0-20F3-4492-9DF9-A1D9B4C06B4B"></a><h3 id="ZZFOR-GUID-6DF12FC0-20F3-4492-9DF9-A1D9B4C06B4B" class="sect3"><span class="enumeration_section">1.7 </span>Indicator Variables
               </h3>
               <div>
                  <p>You use indicator variables to provide information to Oracle about the status of a host variable, or to monitor the status of data returned from Oracle. An indicator variable is always associated with a host variable.</p>
                  <p>You use indicator variables in the VALUES or SET clauses to assign nulls to input host variables and in the INTO clause to detect nulls or truncated values in output host variables.</p>
               </div><a id="ZZFOR149"></a><div class="props_rev_3"><a id="GUID-57BE50F7-47D4-4385-875A-05E3BF9592D5" name="GUID-57BE50F7-47D4-4385-875A-05E3BF9592D5"></a><h4 id="ZZFOR-GUID-57BE50F7-47D4-4385-875A-05E3BF9592D5" class="sect4"><span class="enumeration_section">1.7.1 </span>Declaring Indicator Variables
                  </h4>
                  <div>
                     <p>An indicator variable must be explicitly declared in the Declare Section as a 2-byte integer (INTEGER*2) and must not be an Oracle reserved word. In the following example, you declare two indicator variables (the names IESAL and IECOM are arbitrary):</p><pre class="oac_no_warn" dir="ltr">* Declare host and indicator variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 CHARACTER*10 ENAM
 REAL*4 ESAL
 REAL*4 ECOM
 INTEGER*2 IESAL
 INTEGER*2 IECOM
 EXEC SQL END DECLARE SECTION
</pre><p>You can define an indicator variable anywhere in the Declare Section. It need not follow its associated host variable.</p>
                  </div>
               </div><a id="ZZFOR150"></a><div class="props_rev_3"><a id="GUID-48C9F138-3D24-4D72-A695-3FC924D05998" name="GUID-48C9F138-3D24-4D72-A695-3FC924D05998"></a><h4 id="ZZFOR-GUID-48C9F138-3D24-4D72-A695-3FC924D05998" class="sect4"><span class="enumeration_section">1.7.2 </span>About Referencing Indicator Variables
                  </h4>
                  <div>
                     <p>In SQL statements, an indicator variable must be prefixed with a colon and appended to its associated host variable. In FORTRAN statements, an indicator variable must <span class="italic">not</span> be prefixed with a colon or appended to its associated host variable. An example follows:
                     </p><pre class="oac_no_warn" dir="ltr">* Retrieve employee data.
 EXEC SQL SELECT SAL, COMM
 1 INTO :ESAL, :ECOM:IECOM
 2 FROM EMP
 3 WHERE EMPNO = :ENUM 
* When an indicator variable equals -1, its associated
* host variable is null.
 IF (IECOM .EQ. -1) THEN
 PAY = ESAL
 ELSE
 PAY = ESAL + ECOM
 END IF
</pre><p>To improve readability, you can precede any indicator variable with the optional keyword INDICATOR. You must still prefix the indicator variable with a colon. The correct syntax is</p><pre class="oac_no_warn" dir="ltr">:&lt;host_variable&gt; INDICATOR :&lt;indicator_variable&gt;
</pre><p>, which is equivalent to</p><pre class="oac_no_warn" dir="ltr">:&lt;host_variable&gt;:&lt;indicator_variable&gt;
</pre><p>You can use both forms of the expression in your host program.</p>
                  </div>
               </div><a id="ZZFOR151"></a><div class="props_rev_3"><a id="GUID-54237EE0-DE7B-4B35-9DAC-1DEAE457157F" name="GUID-54237EE0-DE7B-4B35-9DAC-1DEAE457157F"></a><h4 id="ZZFOR-GUID-54237EE0-DE7B-4B35-9DAC-1DEAE457157F" class="sect4"><span class="enumeration_section">1.7.3 </span>Restrictions
                  </h4>
                  <div>
                     <p>Indicator variables cannot be used in the WHERE clause to search for nulls. For example, the following DELETE statement triggers an Oracle error at run time:</p><pre class="oac_no_warn" dir="ltr">* Set indicator variable.
 IECOM = -1
 EXEC SQL DELETE FROM EMP WHERE COMM = :ECOM:IECOM
</pre><p>The correct syntax follows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE COMM IS NULL
</pre></div>
               </div><a id="ZZFOR152"></a><div class="props_rev_3"><a id="GUID-2F85B6FD-B4D1-4CF0-86C0-15042DD8CA58" name="GUID-2F85B6FD-B4D1-4CF0-86C0-15042DD8CA58"></a><h4 id="ZZFOR-GUID-2F85B6FD-B4D1-4CF0-86C0-15042DD8CA58" class="sect4"><span class="enumeration_section">1.7.4 </span>Oracle Restrictions
                  </h4>
                  <div>
                     <p>When DBMS=V6, Oracle does not issue an error if you SELECT or FETCH a null into a host variable not associated with an indicator variable. However, when DBMS=V7, if you SELECT or FETCH a null into a host variable that has no indicator, Oracle issues the following error message:</p><pre class="oac_no_warn" dir="ltr">ORA-01405: fetched column value is NULL
</pre><p>When precompiling with MODE=ORACLE and DBMS=V7, you can disable the ORA-01405 message by also specifying UNSAFE_NULL=YES on the command line. For more information, see <a href="../zzpre/running-Oracle-precompilers.html#ZZPRE-GUID-9BD762BA-BFF8-4B91-8188-8D5E64ADF6A7" target="_blank">UNSAFE_NULL</a>.
                     </p>
                  </div>
               </div><a id="ZZFOR153"></a><div class="props_rev_3"><a id="GUID-C428E4F4-655C-4518-B905-A2167197472C" name="GUID-C428E4F4-655C-4518-B905-A2167197472C"></a><h4 id="ZZFOR-GUID-C428E4F4-655C-4518-B905-A2167197472C" class="sect4"><span class="enumeration_section">1.7.5 </span>ANSI Requirements
                  </h4>
                  <div>
                     <p>When MODE=ORACLE, if you SELECT or FETCH a truncated column value into a host variable not associated with an indicator variable, Oracle issues the following error message:</p><pre class="oac_no_warn" dir="ltr">ORA-01406: fetched column value was truncated
</pre><p>However, when MODE={ANSI|ANSI14|ANSI13}, no error is generated. Values for indicator variables are discussed in <a href="../zzpre/meeting-program-requirements.html#ZZPRE-GUID-ED71BADE-AF94-4074-B4B1-140E03903E88" target="_blank">Meeting Program Requirements</a>.
                     </p>
                  </div>
               </div>
            </div><a id="ZZFOR154"></a><div class="props_rev_3"><a id="GUID-E5D4F976-D222-49D9-864B-ABB758BFF1BE" name="GUID-E5D4F976-D222-49D9-864B-ABB758BFF1BE"></a><h3 id="ZZFOR-GUID-E5D4F976-D222-49D9-864B-ABB758BFF1BE" class="sect3"><span class="enumeration_section">1.8 </span>Host Arrays
               </h3>
               <div>
                  <p>Host arrays can boost performance by letting you manipulate an entire collection of data items with a single SQL statement. With few exceptions, you can use host arrays wherever scalar host variables are allowed. And, you can associate an indicator array with any host array.</p>
               </div><a id="ZZFOR155"></a><div class="props_rev_3"><a id="GUID-01F124DA-E77E-4789-B8AE-350C4F04280E" name="GUID-01F124DA-E77E-4789-B8AE-350C4F04280E"></a><h4 id="ZZFOR-GUID-01F124DA-E77E-4789-B8AE-350C4F04280E" class="sect4"><span class="enumeration_section">1.8.1 </span>About Declaring Host Arrays
                  </h4>
                  <div>
                     <p>You declare and dimension host arrays in the Declare Section. In the following example, three host arrays are declared, each with an upper dimension bound of 50 (the lower bound defaults to 1):</p><pre class="oac_no_warn" dir="ltr">* Declare and dimension host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 CHARACTER*10 ENAM(50)
 REAL*4 ESAL(50)
 EXEC SQL END DECLARE SECTION 
</pre></div>
               </div><a id="ZZFOR156"></a><div class="props_rev_3"><a id="GUID-C45BEB04-AD38-48E0-9455-3E1A9BC110DA" name="GUID-C45BEB04-AD38-48E0-9455-3E1A9BC110DA"></a><h4 id="ZZFOR-GUID-C45BEB04-AD38-48E0-9455-3E1A9BC110DA" class="sect4"><span class="enumeration_section">1.8.2 </span>Restrictions
                  </h4>
                  <div>
                     <p>You cannot specify a lower dimension bound for host arrays. For example, the following declaration is <span class="italic">invalid</span>:
                     </p><pre class="oac_no_warn" dir="ltr">* Invalid dimensioning of host array
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 VECTOR(0:10)
 EXEC SQL END DECLARE SECTION
</pre><p>Multi-dimensional host arrays are <span class="italic">not</span> allowed. Therefore, the two-dimensional host array declared in the following example is <span class="italic">invalid</span>:
                     </p><pre class="oac_no_warn" dir="ltr">* Invalid declaration of host array
 EXEC SQL BEGIN DECLARE SECTION
 ...
 REAL*4 MATRIX(50, 100)
 EXEC SQL END DECLARE SECTION
</pre><p>You cannot dimension host arrays using the FORTRAN DIMENSION statement. For example, the following usage is <span class="italic">invalid</span>:
                     </p><pre class="oac_no_warn" dir="ltr">* Invalid use of DIMENSION statement
 EXEC SQL BEGIN DECLARE SECTION
 REAL*4 ESAL
 REAL*4 ECOM
 DIMENSION ESAL(50), ECOM(50)
 EXEC SQL END DECLARE SECTION 
</pre><p>Also, you cannot dimension a host array in a COMMON statement.</p>
                  </div>
               </div><a id="ZZFOR157"></a><div class="props_rev_3"><a id="GUID-B6308AE3-4B43-4942-8F77-B8E1F6D91177" name="GUID-B6308AE3-4B43-4942-8F77-B8E1F6D91177"></a><h4 id="ZZFOR-GUID-B6308AE3-4B43-4942-8F77-B8E1F6D91177" class="sect4"><span class="enumeration_section">1.8.3 </span>About Referencing Host Arrays
                  </h4>
                  <div>
                     <p>If you use multiple host arrays in a single SQL statement, their dimensions should be the same. However, this is not a requirement because the Pro*FORTRAN Precompiler always uses the <span class="italic">smallest</span> dimension for the SQL operation. In the following example, only 50 rows are INSERTed:
                     </p><pre class="oac_no_warn" dir="ltr">* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(100)
 CHARACTER*10 ENAM(100)
 INTEGER*4 DNUM(100)
 REAL*4 ECOM(50)
 EXEC SQL END DECLARE SECTION
 ...
* Populate host arrays here.
 ...
 EXEC SQL INSERT INTO EMP (EMPNO, ENAME, COMM, DEPTNO)
 1 VALUES (:ENUM, :ENAM, :ECOM, :DNUM)
</pre><p>Host arrays must <span class="italic">not</span> be subscripted in SQL statements. For example, the following INSERT statement is invalid:
                     </p><pre class="oac_no_warn" dir="ltr">* Declare host arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 REAL*4 ESAL(50)
 INTEGER*4 DNUM(50)
 EXEC SQL END DECLARE SECTION
 ...
 DO 200 J = 1, 50
* Invalid use of host arrays
 EXEC SQL INSERT INTO EMP (EMPNO, SAL, DEPTNO)
 1 VALUES (:ENUM(J), :ESAL(J), :DNUM(J))
 200 CONTINUE
</pre><p>You need not process host arrays in a loop. Instead, use unsubscripted array names in your SQL statement. Oracle treats a SQL statement containing host arrays of dimension <span class="italic">n</span> like the same statement executed <span class="italic">n</span> times with <span class="italic">n</span> different scalar variables. For more information, see <a href="../zzpre/using-host-arrays.html#ZZPRE-GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F" target="_blank">Using Host Arrays</a>.
                     </p>
                  </div>
               </div><a id="ZZFOR158"></a><div class="props_rev_3"><a id="GUID-21540F86-9FE5-424C-AC0F-CFDB27BD1CCC" name="GUID-21540F86-9FE5-424C-AC0F-CFDB27BD1CCC"></a><h4 id="ZZFOR-GUID-21540F86-9FE5-424C-AC0F-CFDB27BD1CCC" class="sect4"><span class="enumeration_section">1.8.4 </span>About Using Indicator Arrays
                  </h4>
                  <div>
                     <p>You can use indicator arrays to assign nulls to input host arrays and to detect nulls or truncated values in output host arrays. The following example shows how to INSERT with indicator arrays:</p><pre class="oac_no_warn" dir="ltr">* Declare host and indicator arrays.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 INTEGER*4 DNUM(50)
 REAL*4 ECOM(50)
 INTEGER*2 IECOM(50) -- indicator array
 EXEC SQL END DECLARE SECTION
 ...
* Populate the host and indicator arrays. To insert
* a null into the COMM column, assign -1 to the
* appropriate element in the indicator array.
 ...
 EXEC SQL INSERT INTO EMP (EMPNO, DEPTNO, COMM)
 1 VALUES (:ENUM, :DNUM, :ECOM:IECOM)
</pre><p>The dimension of the indicator array must be greater than, or equal to, the dimension of the host array.</p>
                  </div>
               </div>
            </div><a id="ZZFOR159"></a><div class="props_rev_3"><a id="GUID-FA24E636-1372-40B5-A6CC-2AC54B5BFD60" name="GUID-FA24E636-1372-40B5-A6CC-2AC54B5BFD60"></a><h3 id="ZZFOR-GUID-FA24E636-1372-40B5-A6CC-2AC54B5BFD60" class="sect3"><span class="enumeration_section">1.9 </span>VARCHAR Host Variables
               </h3>
               <div>
                  <p>FORTRAN string datatypes are of fixed length. However, Pro*FORTRAN lets you declare a variable-length string pseudotype called VARCHAR.</p>
               </div><a id="ZZFOR160"></a><div class="props_rev_3"><a id="GUID-EA310150-6B02-438A-82FA-BB42C10CF644" name="GUID-EA310150-6B02-438A-82FA-BB42C10CF644"></a><h4 id="ZZFOR-GUID-EA310150-6B02-438A-82FA-BB42C10CF644" class="sect4"><span class="enumeration_section">1.9.1 </span>About Declaring VARCHAR Variables
                  </h4>
                  <div>
                     <p>A VARCHAR is a set of three variables declared using the syntax</p><pre class="oac_no_warn" dir="ltr">* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 VARCHAR*&lt;n&gt; &lt;VARNAM&gt;, &lt;VARLEN&gt;, &lt;VARARR&gt;
 EXEC SQL END DECLARE SECTION
</pre><p>where:</p><pre class="oac_no_warn" dir="ltr">n</pre><p>Is the maximum length of the VARCHAR; <span class="italic">n</span> must be in the range 1 through 32765.
                     </p><pre class="oac_no_warn" dir="ltr">VARNAM</pre><p>Is the name used to reference the VARCHAR in SQL statements; it is called an <span class="italic">aggregate name</span> because it identifies a set of variables.
                     </p><pre class="oac_no_warn" dir="ltr">VARLEN</pre><p>Is a 2-byte signed integer variable that stores the actual length of the string variable.</p><pre class="oac_no_warn" dir="ltr">VARARR</pre><p>Is the string variable used in FORTRAN statements.</p>
                     <p>The advantage of using VARCHAR variables is that you can explicitly set and reference VARLEN. With input host variables, Oracle reads the value of VARLEN and uses the same number of characters of VARARR. With output host variables, Oracle sets VARLEN to the length of the character string stored in VARARR.</p>
                     <p>You can declare a VARCHAR only in the Declare Section. In the following example, you declare a VARCHAR named EJOB with a maximum length of 15 characters:</p><pre class="oac_no_warn" dir="ltr">* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 VARCHAR*15 EJOB, EJOBL, EJOBA
 EXEC SQL END DECLARE SECTION
</pre><p>The precompiler expands this declaration to</p><pre class="oac_no_warn" dir="ltr">* Expanded VARCHAR declaration
 INTEGER*2 EJOBL
 LOGICAL*1 EJOBA(15)
 INTEGER*2 SQXXX(2)
 EQUIVALENCE (SQXXX(1), EJOBL), (SQXXX(2), EJOBA(1))
</pre><p>where SQXXX is an array generated by the precompiler and XXX denotes three arbitrary characters. Notice that the aggregate name EJOB is not declared. The EQUIVALENCE statement forces the compiler to store EJOBL and EJOBA contiguously.</p>
                  </div>
               </div><a id="ZZFOR161"></a><div class="props_rev_3"><a id="GUID-4FFC5D67-8620-4AE3-BFF4-61695E0DFC4A" name="GUID-4FFC5D67-8620-4AE3-BFF4-61695E0DFC4A"></a><h4 id="ZZFOR-GUID-4FFC5D67-8620-4AE3-BFF4-61695E0DFC4A" class="sect4"><span class="enumeration_section">1.9.2 </span>About Referencing VARCHAR Variables
                  </h4>
                  <div>
                     <p>In SQL statements, you can reference a VARCHAR variable by using the aggregate name prefixed with a colon, as the following example shows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT JOB
 1 INTO :EJOB
 2 FROM EMP
 3 WHERE EMPNO = :ENUM
</pre><p>After the query executes, EJOBL holds the actual length of the character string retrieved from the database and stored in EJOBA. In FORTRAN statements, you reference VARCHAR variables using the length variable and string variable names, as this example shows:</p><pre class="oac_no_warn" dir="ltr">* Display job title.
 WRITE (*, 5200) (EJOBA(J), J = 1, EJOBL)
 5200 FORMAT (15A1)
 ...
</pre></div>
               </div><a id="ZZFOR162"></a><div class="props_rev_3"><a id="GUID-5F4DF79A-F550-4B86-8DDF-2F26895FE9E3" name="GUID-5F4DF79A-F550-4B86-8DDF-2F26895FE9E3"></a><h4 id="ZZFOR-GUID-5F4DF79A-F550-4B86-8DDF-2F26895FE9E3" class="sect4"><span class="enumeration_section">1.9.3 </span>About Overcoming the Length Limit
                  </h4>
                  <div>
                     <p>Recall that the length variable of a VARCHAR must be a 2-byte integer. FORTRAN provides a 2-byte signed integer datatype, which can represent numbers in the range -32768 through 32767. However, FORTRAN lacks a 2-byte <span class="italic">unsigned</span> integer datatype, which can represent numbers in the range 0 through 65535. Therefore, the maximum length of a VARCHAR character string is 32765 bytes (32767 minus 2 for the length variable).
                     </p>
                     <p>With other host languages, the maximum length of a VARCHAR character string is 65533 bytes. If you want to use 65533-byte VARCHAR variables, try the technique shown in the following example:</p><pre class="oac_no_warn" dir="ltr">* Declare a VARCHAR.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 VARCHAR*65533 BUF, BUFL, BUFA
 EXEC SQL END DECLARE SECTION
 ...
* Equivalence two 2-byte integers to one 4-byte integer.
 INTEGER*2 INT2(2)
 INTEGER*4 INT4
 EQUIVALENCE (INT2(1), INT4)
 INTEGER*4 I
 ...
 INT4 = 65533
* Set the VARCHAR length variable equal to the
* equivalenced value of INT4.
 BUFL = INT2(1)
 DO 100 I = 1, 65533
 BUFA(I) = 32
 100 CONTINUE
 EXEC SQL INSERT INTO LONG_TABLE VALUES (:BUF)
 ...
 BUFL = 0
 EXEC SQL SELECT COL1 INTO :BUF FROM LONG_TABLE
 INT2(1) = BUFL
 ...
</pre><div class="infoboxnote" id="GUID-5F4DF79A-F550-4B86-8DDF-2F26895FE9E3__GUID-660628BF-AB67-47A1-89AC-AE49BECCB4E8">
                        <p class="notep1">Note:</p>
                        <p>The way integers are stored varies from system to system. On some systems, the least significant digits are stored at the low address; on other systems they are stored at the high address. In the last example, this determines whether the length is stored in INT2(1) or INT2(2).</p>
                     </div>
                  </div>
               </div>
            </div><a id="ZZFOR163"></a><div class="props_rev_3"><a id="GUID-93D22B55-7110-484C-A48C-1633CF8EBFB8" name="GUID-93D22B55-7110-484C-A48C-1633CF8EBFB8"></a><h3 id="ZZFOR-GUID-93D22B55-7110-484C-A48C-1633CF8EBFB8" class="sect3"><span class="enumeration_section">1.10 </span>About Handling Character Data
               </h3>
               <div>
                  <p>This section explains how the Pro*FORTRAN Precompiler handles character host variables. There are two types of character host variables:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>CHARACTER*<span class="italic">n</span></p>
                     </li>
                     <li>
                        <p>VARCHAR</p>
                     </li>
                  </ul>
                  <p>Do not confuse VARCHAR, which is a host variable data structure supplied by the precompiler, with VARCHAR2, which is an Oracle column datatype for variable-length character strings.</p>
               </div><a id="ZZFOR164"></a><div class="props_rev_3"><a id="GUID-8467FC0E-292A-4739-AD7A-F79E79D0A026" name="GUID-8467FC0E-292A-4739-AD7A-F79E79D0A026"></a><h4 id="ZZFOR-GUID-8467FC0E-292A-4739-AD7A-F79E79D0A026" class="sect4"><span class="enumeration_section">1.10.1 </span>Effects of the MODE Option
                  </h4>
                  <div>
                     <p>The MODE option has the following effects:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It determines how the Pro*FORTRAN Precompiler treats data in character arrays and strings. The MODE option allows the program to use ANSI fixed-length strings or to maintain compatibility with previous versions of the Oracle Server and the Pro*FORTRAN Precompiler.</p>
                        </li>
                        <li>
                           <p>With respect to character handling, MODE={ANSI14|ANSI13} is equivalent to MODE=ORACLE. The MODE option affects character data on input (from host variables to Oracle) and on output (from Oracle to host variables).</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-8467FC0E-292A-4739-AD7A-F79E79D0A026__GUID-3F53C240-2D4F-4624-A2B8-1D43FE0A1058">
                        <p class="notep1">Note:</p>
                        <p>The MODE option does not affect the way Pro*FORTRAN handles VARCHAR host variables.</p>
                     </div>
                  </div>
               </div><a id="ZZFOR165"></a><div class="props_rev_3"><a id="GUID-BA4B1207-C096-4CBA-872B-20BDC4BEE52A" name="GUID-BA4B1207-C096-4CBA-872B-20BDC4BEE52A"></a><h4 id="ZZFOR-GUID-BA4B1207-C096-4CBA-872B-20BDC4BEE52A" class="sect4"><span class="enumeration_section">1.10.2 </span>CHARACTER*<span class="italic">n</span></h4>
                  <div>
                     <p>Character variables are declared using the CHARACTER*<span class="italic">n</span> datatype. These types of variables handle character data based on their roles as input or output variables.
                     </p>
                  </div>
               </div><a id="ZZFOR166"></a><div class="props_rev_3"><a id="GUID-86E4769D-A646-46D5-A966-7E7AC504D0ED" name="GUID-86E4769D-A646-46D5-A966-7E7AC504D0ED"></a><h4 id="ZZFOR-GUID-86E4769D-A646-46D5-A966-7E7AC504D0ED" class="sect4"><span class="enumeration_section">1.10.3 </span>On Input
                  </h4>
                  <div>
                     <p>When MODE=ORACLE, the program interface strips trailing blanks before sending the value to the database. If you insert into a fixed-length CHAR column, Oracle re-appends trailing blanks up to the length of the database column. However, if you insert into a variable-length VARCHAR2 column, Oracle never appends blanks.</p>
                     <p>When MODE=ANSI, trailing blanks are never stripped.</p>
                     <p>Make sure that the input value is not trailed by extraneous characters. For example, nulls are not stripped and are inserted into the database. Normally, this is not a problem because when a value is READ into or assigned to a CHARACTER*<span class="italic">n</span> variable, FORTRAN appends blanks up to the length of the variable.
                     </p>
                     <p>The following example illustrates the point:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER ENAM *10, EJOB *8
 ...
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 300)
 300 FORMAT (/, '$Employee name? ')
* Assume the name 'MILLER' is entered
 READ (*, 400)
 400 FORMAT (A10)
 EJOB = 'SALES'
 EXEC SQL INSERT INTO emp (empno, ename, deptno, job)
 VALUES (1234, :ENAM, 20, :EJOB)
</pre><p>If you precompile the last example with MODE=ORACLE and the target database columns are VARCHAR2, the program interface strips the trailing blanks on input and inserts just the 6-character string "MILLER" and the 5-character string "SALES" into the database. However, if the target database columns are CHAR, the strings are blank-padded to the width of the columns.</p>
                     <p>If you precompile the last example with MODE=ANSI and the JOB column is defined as CHAR(10), the value inserted into that column is "SALES#####" (five trailing blanks). However, if the JOB column is defined as VARCHAR2(10), the value inserted is "SALES###" (three trailing blanks) because the host variable is a CHARACTER*8. This might not be what you want, so be careful.</p>
                  </div>
               </div><a id="ZZFOR167"></a><div class="props_rev_3"><a id="GUID-D1E33DE1-E249-4DC2-9F13-9304ACD5F215" name="GUID-D1E33DE1-E249-4DC2-9F13-9304ACD5F215"></a><h4 id="ZZFOR-GUID-D1E33DE1-E249-4DC2-9F13-9304ACD5F215" class="sect4"><span class="enumeration_section">1.10.4 </span>On Output
                  </h4>
                  <div>
                     <p>The MODE option has no effect on output to character variables. When you use a CHARACTER*<span class="italic">n</span> variable as an output host variable, Oracle blank-pads it. In our example, when your program fetches the string "MILLER" from the database, ENAM contains the value "MILLER####" (with four trailing blanks). This character string can be used without change as input to another SQL statement.
                     </p>
                  </div>
               </div><a id="ZZFOR168"></a><div class="props_rev_3"><a id="GUID-19733687-EAFA-44B8-B16B-37C21BF276C2" name="GUID-19733687-EAFA-44B8-B16B-37C21BF276C2"></a><h4 id="ZZFOR-GUID-19733687-EAFA-44B8-B16B-37C21BF276C2" class="sect4"><span class="enumeration_section">1.10.5 </span>VARCHAR Variables
                  </h4>
                  <div>
                     <p>VARCHAR variables handle character data based on their roles as input or output variables</p>
                  </div>
               </div><a id="ZZFOR169"></a><div class="props_rev_3"><a id="GUID-E5B92083-0F7A-4236-B845-750872EE670C" name="GUID-E5B92083-0F7A-4236-B845-750872EE670C"></a><h4 id="ZZFOR-GUID-E5B92083-0F7A-4236-B845-750872EE670C" class="sect4"><span class="enumeration_section">1.10.6 </span>On Input
                  </h4>
                  <div>
                     <p>When you use a VARCHAR variable as an input host variable, your program must assign values to the length and string variables, as shown in the following example:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 INTEGER*2 IEJOB
 INTEGER*4 DNUM
 EXEC SQL END DECLARE SECTION
 ...
 WRITE (*, 4300)
 4300 FORMAT (/, ' Enter job title: ')
 READ (*, 4400) EJOBA
 4400 FORMAT (15A1) 
* Scan backward for last non-blank character, then
* set length to that position. If input is all blank,
* set indicator variable to -1 to indicate a null.
 DO 5000 J = 15, 1, -1
 IF (EJOBA(J) .NE. ' ') GOTO 5100
 5000 CONTINUE
 J = 0
 5100 IF (J .EQ. 0) THEN
 IEJOB = -1
 ELSE
 IEJOB = 0
 END IF 
 EJOBL = J 
 EXEC SQL INSERT INTO EMP (EMPNO, JOB, DEPTNO)
 1 VALUES (:ENUM, :EJOB:IEJOB, :DNUM)
</pre></div>
               </div><a id="ZZFOR170"></a><div class="props_rev_3"><a id="GUID-8CD3414C-6945-419E-A6C8-4165065AA7BA" name="GUID-8CD3414C-6945-419E-A6C8-4165065AA7BA"></a><h4 id="ZZFOR-GUID-8CD3414C-6945-419E-A6C8-4165065AA7BA" class="sect4"><span class="enumeration_section">1.10.7 </span>On Output
                  </h4>
                  <div>
                     <p>When you use a VARCHAR variable as an output host variable, Oracle sets the length variable. An example follows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM
 VARCHAR*15 EJOB, EJOBL, EJOBA
 INTEGER*4 ESAL
 EXEC SQL END DECLARE SECTION
 ...
 EXEC SQL SELECT JOB, SAL INTO :EJOB, :ESAL FROM EMP
 1 WHERE EMPNO = :ENUM
 ...
 IF (EJOBL .EQ. 0) GOTO ...
 ...
</pre><p>An advantage of VARCHAR variables over fixed-length strings is that the length of the value returned by Oracle is available immediately. With fixed-length strings, to get the length of the value, your program must count the number of characters. (The intrinsic function LEN returns the length of a string including blanks, not its current length.)</p>
                  </div>
               </div>
            </div><a id="ZZFOR171"></a><div class="props_rev_3"><a id="GUID-B567760E-18C0-4C00-A520-68F64507591A" name="GUID-B567760E-18C0-4C00-A520-68F64507591A"></a><h3 id="ZZFOR-GUID-B567760E-18C0-4C00-A520-68F64507591A" class="sect3"><span class="enumeration_section">1.11 </span>The Oracle Datatypes
               </h3>
               <div>
                  <div class="section">
                     <p>Oracle recognizes two kinds of datatypes: <span class="italic">internal</span> and <span class="italic">external</span>. Internal datatypes specify how Oracle stores data in database columns. Oracle also uses internal datatypes to represent database pseudocolumns. An external datatype specifies how data is stored in a host variable. For descriptions of the Oracle datatypes, see <a href="../zzpre/meeting-program-requirements.html#ZZPRE-GUID-9F34D892-C67C-4567-94C6-E402BB079FA8" target="_blank">Oracle Datatypes</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZFOR172"></a><div class="props_rev_3"><a id="GUID-5F562403-E83D-4736-AFE2-B5E1898535AC" name="GUID-5F562403-E83D-4736-AFE2-B5E1898535AC"></a><h4 id="ZZFOR-GUID-5F562403-E83D-4736-AFE2-B5E1898535AC" class="sect4"><span class="enumeration_section">1.11.1 </span>Internal Datatypes
                  </h4>
                  <div>
                     <div class="section">
                        <p>For values stored in database columns, Oracle uses the following internal datatypes:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-5F562403-E83D-4736-AFE2-B5E1898535AC__GUID-8BB7A82E-87E9-4EDA-9EAC-A270ADE08CB5">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="name" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d1790e2408">Name</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2411">Code</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2414">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2419" headers="d1790e2408 ">
                                    <p>CHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2419 d1790e2411 ">
                                    <p>96</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2419 d1790e2414 ">
                                    <p>&lt;= 255-byte, fixed-length string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2429" headers="d1790e2408 ">
                                    <p>DATE</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2429 d1790e2411 ">
                                    <p>12</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2429 d1790e2414 ">
                                    <p>7-byte, fixed-length date/time value</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2439" headers="d1790e2408 ">
                                    <p>LONG</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2439 d1790e2411 ">
                                    <p>8</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2439 d1790e2414 ">
                                    <p>&lt;= 2147483647-byte, variable-length string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2449" headers="d1790e2408 ">
                                    <p>LONG RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2449 d1790e2411 ">
                                    <p>24</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2449 d1790e2414 ">
                                    <p>&lt;= 2147483647-byte, variable-length binary data</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2459" headers="d1790e2408 ">
                                    <p>MLSLABEL</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2459 d1790e2411 ">
                                    <p>105</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2459 d1790e2414 ">
                                    <p>&lt;= 5-byte, variable-length binary label</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2469" headers="d1790e2408 ">
                                    <p>NUMBER</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2469 d1790e2411 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2469 d1790e2414 ">
                                    <p>fixed or floating point number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2479" headers="d1790e2408 ">
                                    <p>RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2479 d1790e2411 ">
                                    <p>23</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2479 d1790e2414 ">
                                    <p>&lt;= 255-byte, variable-length binary data</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2489" headers="d1790e2408 ">
                                    <p>ROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2489 d1790e2411 ">
                                    <p>11</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2489 d1790e2414 ">
                                    <p>fixed-length binary value</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2499" headers="d1790e2408 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2499 d1790e2411 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2499 d1790e2414 ">
                                    <p>&lt;= 2000-byte, variable-length string</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>Table 1 - 5. Internal Datatypes</p>
                        <p>These internal datatypes can be quite different from FORTRAN datatypes. For example, FORTRAN has no equivalent to the NUMBER datatype, which was specially designed for portability and high precision.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZFOR173"></a><div class="props_rev_3"><a id="GUID-78F35FF5-A485-4861-AE4D-0C2E24915214" name="GUID-78F35FF5-A485-4861-AE4D-0C2E24915214"></a><h4 id="ZZFOR-GUID-78F35FF5-A485-4861-AE4D-0C2E24915214" class="sect4"><span class="enumeration_section">1.11.2 </span>External Datatypes
                  </h4>
                  <div>
                     <div class="section">
                        <p>As the following table shows, the external datatypes include all the internal datatypes plus several datatypes found in other supported host languages. For example, the STRING external datatype refers to a C null-terminated string. You use the datatype names in datatype equivalencing, and you use the datatype codes in dynamic SQL Method 4.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-78F35FF5-A485-4861-AE4D-0C2E24915214__GUID-ED404512-C40F-4E71-8A8F-F35F61ABC088">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="name" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d1790e2545">Name</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2548">Code</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2551">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2556" headers="d1790e2545 ">
                                    <p>CHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2556 d1790e2548 ">
                                    <p>1 96</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2556 d1790e2551 ">
                                    <p>&lt;= 65535-byte, variable-length character string (1)&lt;= 65535-byte, fixed-length character string (1)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2566" headers="d1790e2545 ">
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2566 d1790e2548 ">
                                    <p>96</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2566 d1790e2551 ">
                                    <p>&lt;= 65535-byte, fixed-length character string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2576" headers="d1790e2545 ">
                                    <p>CHARZ</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2576 d1790e2548 ">
                                    <p>97</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2576 d1790e2551 ">
                                    <p>&lt;= 65535-byte, fixed-length, null-terminated string (2)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2586" headers="d1790e2545 ">
                                    <p>DATE</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2586 d1790e2548 ">
                                    <p>12</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2586 d1790e2551 ">
                                    <p>7-byte, fixed-length date/time value</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2596" headers="d1790e2545 ">
                                    <p>DECIMAL</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2596 d1790e2548 ">
                                    <p>7</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2596 d1790e2551 ">
                                    <p>COBOL packed decimal</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2606" headers="d1790e2545 ">
                                    <p>DISPLAY</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2606 d1790e2548 ">
                                    <p>91</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2606 d1790e2551 ">
                                    <p>COBOL numeric character string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2616" headers="d1790e2545 ">
                                    <p>FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2616 d1790e2548 ">
                                    <p>4</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2616 d1790e2551 ">
                                    <p>4-byte or 8-byte floating-point number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2626" headers="d1790e2545 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2626 d1790e2548 ">
                                    <p>3</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2626 d1790e2551 ">
                                    <p>2-byte or 4-byte signed integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2636" headers="d1790e2545 ">
                                    <p>LONG</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2636 d1790e2548 ">
                                    <p>8</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2636 d1790e2551 ">
                                    <p>&lt;= 2147483647-byte, fixed-length string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2646" headers="d1790e2545 ">
                                    <p>LONG RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2646 d1790e2548 ">
                                    <p>24</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2646 d1790e2551 ">
                                    <p>&lt;= 217483647-byte, fixed-length binary data</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2656" headers="d1790e2545 ">
                                    <p>LONG VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2656 d1790e2548 ">
                                    <p>94</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2656 d1790e2551 ">
                                    <p>&lt;= 217483643-byte, variable-length string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2667" headers="d1790e2545 ">
                                    <p>LONG VARRAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2667 d1790e2548 ">
                                    <p>95</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2667 d1790e2551 ">
                                    <p>&lt;= 217483643-byte, variable-length binary data</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2677" headers="d1790e2545 ">
                                    <p>MLSLABEL</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2677 d1790e2548 ">
                                    <p>106</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2677 d1790e2551 ">
                                    <p>2..5-byte, variable-length binary data</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2687" headers="d1790e2545 ">
                                    <p>NUMBER</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2687 d1790e2548 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2687 d1790e2551 ">
                                    <p>integer or floating-point number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2697" headers="d1790e2545 ">
                                    <p>RAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2697 d1790e2548 ">
                                    <p>23</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2697 d1790e2551 ">
                                    <p>&lt;= 65535-byte, fixed-length binary data (2)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2707" headers="d1790e2545 ">
                                    <p>ROWID</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2707 d1790e2548 ">
                                    <p>11</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2707 d1790e2551 ">
                                    <p>(typically) 13-byte, fixed-length binary value</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2717" headers="d1790e2545 ">
                                    <p>STRING</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2717 d1790e2548 ">
                                    <p>5</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2717 d1790e2551 ">
                                    <p>&lt;= 65535-byte, null-terminated character string (2)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2727" headers="d1790e2545 ">
                                    <p>UNSIGNED</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2727 d1790e2548 ">
                                    <p>68</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2727 d1790e2551 ">
                                    <p>2-byte or 4-byte unsigned integer</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2737" headers="d1790e2545 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2737 d1790e2548 ">
                                    <p>9</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2737 d1790e2551 ">
                                    <p>&lt;= 65533-byte, variable-length character string</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2747" headers="d1790e2545 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2747 d1790e2548 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2747 d1790e2551 ">
                                    <p>&lt;= 65535-byte, variable-length character string (2)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2757" headers="d1790e2545 ">
                                    <p>VARNUM</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2757 d1790e2548 ">
                                    <p>6</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2757 d1790e2551 ">
                                    <p>variable-length binary number</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2767" headers="d1790e2545 ">
                                    <p>VARRAW</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2767 d1790e2548 ">
                                    <p>15</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2767 d1790e2551 ">
                                    <p>&lt;= 65533-byte, variable-length binary data</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p><span class="bold">Notes</span>:
                        </p>
                        <ol>
                           <li>
                              <p>CHAR is datatype 1 when MODE={ORACLE|ANSI13|ANSI14} and datatype 96 when MODE=ANSI.</p>
                           </li>
                           <li>
                              <p>Maximum size is 32767 (32K) on some platforms.</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZFOR174"></a><div class="props_rev_3"><a id="GUID-B1D58589-9169-4A8B-9B0F-4D4233517784" name="GUID-B1D58589-9169-4A8B-9B0F-4D4233517784"></a><h3 id="ZZFOR-GUID-B1D58589-9169-4A8B-9B0F-4D4233517784" class="sect3"><span class="enumeration_section">1.12 </span>Datatype Conversion
               </h3>
               <div>
                  <p>At precompile time, an external datatype is assigned to each host variable in the Declare Section. For example, the precompiler assigns the FLOAT external datatype to host variables of type REAL. At run time, the datatype code of every host variable used in a SQL statement is passed to Oracle. Oracle uses the codes to convert between internal and external datatypes.</p>
                  <p>Before assigning a SELECTed column value to an output host variable, Oracle must convert the internal datatype of the source column to the datatype of the host variable. Likewise, before assigning or comparing the value of an input host variable to a column, Oracle must convert the external datatype of the host variable to the internal datatype of the target column.</p>
                  <p>Conversions between internal and external datatypes follow the usual data conversion rules. For example, you can convert a CHAR value of "1234" to a INTEGER*2 value. You cannot, however, convert a CHAR value of "65543" (number too large) or "10F" (number not decimal) to a INTEGER*2 value. Likewise, you cannot convert a CHARACTER*<span class="italic">n</span> value that contains alphabetic characters to a NUMBER value.
                  </p>
                  <p>For more information about datatype conversion, see <a href="../zzpre/meeting-program-requirements.html#ZZPRE-GUID-ED71BADE-AF94-4074-B4B1-140E03903E88" target="_blank">Meeting Program Requirements</a>.
                  </p>
               </div>
            </div><a id="ZZFOR175"></a><div class="props_rev_3"><a id="GUID-CD1D2DEB-07EE-4DA3-9D27-04FBE0A1F51A" name="GUID-CD1D2DEB-07EE-4DA3-9D27-04FBE0A1F51A"></a><h3 id="ZZFOR-GUID-CD1D2DEB-07EE-4DA3-9D27-04FBE0A1F51A" class="sect3"><span class="enumeration_section">1.13 </span>Datatype Equivalencing
               </h3>
               <div>
                  <p>Datatype equivalencing lets you control the way Oracle interprets input data and the way Oracle formats output data. You can equivalence supported FORTRAN datatypes to Oracle external datatypes on a variable-by-variable basis.</p>
               </div><a id="ZZFOR176"></a><div class="props_rev_3"><a id="GUID-AC062C9C-1D5F-4E45-93E8-855FA4B4C79F" name="GUID-AC062C9C-1D5F-4E45-93E8-855FA4B4C79F"></a><h4 id="ZZFOR-GUID-AC062C9C-1D5F-4E45-93E8-855FA4B4C79F" class="sect4"><span class="enumeration_section">1.13.1 </span>Host Variable Equivalencing
                  </h4>
                  <div>
                     <p>By default, the Pro*FORTRAN Precompiler assigns a specific external datatype to every host variable. The default assignments are shown in the following table. For more information about datatype equivalencing, see <a href="../zzpre/learning-basics.html#ZZPRE-GUID-FDFE502B-9288-4133-9CE5-7BAEC62C8AB4" target="_blank">Datatype Equivalencing</a>.
                     </p>
                     <div class="tblformal" id="GUID-AC062C9C-1D5F-4E45-93E8-855FA4B4C79F__GUID-5AA3BA8B-53C8-4A69-8E6C-B489D6490950">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="host type" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d1790e2881">Host Type</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2884">External Type</th>
                                 <th align="left" valign="bottom" width="33%" id="d1790e2887">Code</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2892" headers="d1790e2881 ">
                                    <p>BYTE <span class="italic">var</span> LOGICAL <span class="italic">var</span> LOGICAL*1 <span class="italic">var</span> LOGICAL*2 <span class="italic">var</span> LOGICAL*4 <span class="italic">var</span> CHARACTER <span class="italic">var</span> CHARACTER <span class="italic">var</span>*<span class="italic">n</span> CHARACTER*<span class="italic">n var</span> CHARACTER(*) <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2892 d1790e2884 ">
                                    <p>VARCHAR2 CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2892 d1790e2887 ">
                                    <p>1 (when MODE != ANSI) 96 (when MODE=ANSI)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2932" headers="d1790e2881 ">
                                    <p>VARCHAR*<span class="italic">n</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2932 d1790e2884 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2932 d1790e2887 ">
                                    <p>9</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2944" headers="d1790e2881 ">
                                    <p>INTEGER <span class="italic">var</span> INTEGER*2 <span class="italic">var</span> INTEGER*4 <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2944 d1790e2884 ">
                                    <p>INTEGER</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2944 d1790e2887 ">
                                    <p>3</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d1790e2962" headers="d1790e2881 ">
                                    <p>REAL <span class="italic">var</span> REAL*4 <span class="italic">var</span> REAL*8 <span class="italic">var</span> DOUBLE PRECISION <span class="italic">var</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2962 d1790e2884 ">
                                    <p>FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d1790e2962 d1790e2887 ">
                                    <p>4</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>With the VAR statement, you can override the default assignments by equivalencing host variables to Oracle external datatypes in the Declare Section. The syntax you use is</p><pre class="oac_no_warn" dir="ltr">EXEC SQL
 VAR &lt;host_variable&gt;
 IS &lt;ext_type_name&gt; [({&lt;length&gt; | &lt;precision&gt;,&lt;scale&gt;})]
</pre><p>where <span class="italic">host_variable</span> is an input or output host variable (or host array) declared earlier in the Declare Section, <span class="italic">ext_type_name</span> is the name of a valid external datatype, and <span class="italic">length</span> is an integer literal specifying a valid length in bytes.
                     </p>
                     <p>When <span class="italic">ext_type_name</span> is FLOAT, use <span class="italic">length</span>; when <span class="italic">ext_type_name</span> is DECIMAL, you must specify <span class="italic">precision</span> and <span class="italic">scale</span> instead of <span class="italic">length</span>.
                     </p>
                     <p>Host variable equivalencing is useful in several ways. For example, you can use it when you want Oracle to store but not interpret data. Suppose you want to store a host array of 4-byte integers in a RAW database column. Simply equivalence the host array to the RAW external datatype, as follows:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION
 INTEGER*4 ENUM(50)
 ...
* Reset default datatype (INTEGER) to RAW.
 EXEC SQL VAR ENUM IS RAW (200);
 EXEC SQL END DECLARE SECTION
 ...
</pre><p>With host arrays, the length you specify must match the buffer size required to hold the array. In the last example, you specified a length of 200, which is the buffer size required to hold 50 4-byte integers.</p>
                     <p>For more information about datatype equivalencing, see <a href="../zzpre/learning-basics.html#ZZPRE-GUID-FDFE502B-9288-4133-9CE5-7BAEC62C8AB4" target="_blank">Datatype Equivalencing</a>.
                     </p>
                  </div>
               </div>
            </div><a id="ZZFOR177"></a><div class="props_rev_3"><a id="GUID-39098A75-F8FC-4CAB-91EB-8133B9C4A382" name="GUID-39098A75-F8FC-4CAB-91EB-8133B9C4A382"></a><h3 id="ZZFOR-GUID-39098A75-F8FC-4CAB-91EB-8133B9C4A382" class="sect3"><span class="enumeration_section">1.14 </span>Embedding PL/SQL
               </h3>
               <div>
                  <p>The Pro*FORTRAN Precompiler treats a PL/SQL block like a single embedded SQL statement. As a result, you can place a PL/SQL block anywhere in a host program that you can place a SQL statement.</p>
                  <p>To embed a PL/SQL block in your host program, declare the variables to be shared with PL/SQL and bracket the PL/SQL block with the EXEC SQL EXECUTE and END-EXEC keywords.</p>
               </div><a id="ZZFOR178"></a><div class="props_rev_3"><a id="GUID-F0CB742F-8C78-444C-ACCC-1E0423631B52" name="GUID-F0CB742F-8C78-444C-ACCC-1E0423631B52"></a><h4 id="ZZFOR-GUID-F0CB742F-8C78-444C-ACCC-1E0423631B52" class="sect4"><span class="enumeration_section">1.14.1 </span>Host Variables
                  </h4>
                  <div>
                     <p>Inside a PL/SQL block, host variables are global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.</p>
                  </div>
               </div><a id="ZZFOR179"></a><div class="props_rev_3"><a id="GUID-0032A34A-06AB-4170-B7D3-7E473D2E0AFE" name="GUID-0032A34A-06AB-4170-B7D3-7E473D2E0AFE"></a><h4 id="ZZFOR-GUID-0032A34A-06AB-4170-B7D3-7E473D2E0AFE" class="sect4"><span class="enumeration_section">1.14.2 </span>VARCHAR Variables
                  </h4>
                  <div>
                     <p>When entering a PL/SQL block, Oracle automatically checks the length fields of VARCHAR host variables. So, you must set the length fields <span class="italic">before</span> the block is entered. For input variables, set the length field to the length of the value stored in the string field. For output variables, set the length field to the maximum length allowed by the string field.
                     </p>
                  </div>
               </div><a id="ZZFOR180"></a><div class="props_rev_3"><a id="GUID-4F62525E-BA7E-4247-9BDB-4688A9C48466" name="GUID-4F62525E-BA7E-4247-9BDB-4688A9C48466"></a><h4 id="ZZFOR-GUID-4F62525E-BA7E-4247-9BDB-4688A9C48466" class="sect4"><span class="enumeration_section">1.14.3 </span>Indicator Variables
                  </h4>
                  <div>
                     <p>In a PL/SQL block, you cannot refer to an indicator variable by itself; it must be appended to its associated host variable. In addition, if you refer to a host variable with its indicator variable, you must always refer to it the same way within the same block.</p>
                  </div>
               </div><a id="ZZFOR181"></a><div class="props_rev_3"><a id="GUID-8CE20AFC-A544-4457-BBBE-46399DCB4E20" name="GUID-8CE20AFC-A544-4457-BBBE-46399DCB4E20"></a><h4 id="ZZFOR-GUID-8CE20AFC-A544-4457-BBBE-46399DCB4E20" class="sect4"><span class="enumeration_section">1.14.4 </span>About Handling Nulls
                  </h4>
                  <div>
                     <p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a null to the host variable. When exiting the block, if a host variable is null, PL/SQL automatically assigns a value of -1 to the indicator variable.</p>
                  </div>
               </div><a id="ZZFOR182"></a><div class="props_rev_3"><a id="GUID-B49A2FDF-9AF4-4D36-A429-EA7BB639CC7C" name="GUID-B49A2FDF-9AF4-4D36-A429-EA7BB639CC7C"></a><h4 id="ZZFOR-GUID-B49A2FDF-9AF4-4D36-A429-EA7BB639CC7C" class="sect4"><span class="enumeration_section">1.14.5 </span>About Handling Truncated Values
                  </h4>
                  <div>
                     <p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string.</p>
                  </div>
               </div><a id="ZZFOR183"></a><div class="props_rev_3"><a id="GUID-B9C8E60B-B5DB-4F6C-BC18-F215738A05A6" name="GUID-B9C8E60B-B5DB-4F6C-BC18-F215738A05A6"></a><h4 id="ZZFOR-GUID-B9C8E60B-B5DB-4F6C-BC18-F215738A05A6" class="sect4"><span class="enumeration_section">1.14.6 </span>SQLCHECK
                  </h4>
                  <div>
                     <p>You must specify SQLCHECK=SEMANTICS when precompiling a program with an embedded PL/SQL block. You must also use the USERID option. For more information, see <a href="../zzpre/running-Oracle-precompilers.html#ZZPRE-GUID-C6823AE2-9898-43B4-B400-BEF616AF6D13" target="_blank">SQLCHECK</a>.
                     </p>
                  </div>
               </div><a id="ZZFOR184"></a><div class="props_rev_3"><a id="GUID-A0F3C14D-1500-4CCC-BD12-784A4A6C47D2" name="GUID-A0F3C14D-1500-4CCC-BD12-784A4A6C47D2"></a><h4 id="ZZFOR-GUID-A0F3C14D-1500-4CCC-BD12-784A4A6C47D2" class="sect4"><span class="enumeration_section">1.14.7 </span>Cursor Variables
                  </h4>
                  <div>
                     <p>Starting with Release 1.7 of the Pro*FORTRAN Precompiler, you can use <span class="italic">cursor variables</span> in your Pro*FORTRAN programs to process multi-row queries using static embedded SQL. A cursor variable identifies a <span class="italic">cursor reference</span> that is defined and opened on the Oracle Database Server, using PL/SQL. See the<span class="italic"> Oracle Database PL/SQL Language Reference</span> for complete information about cursor variables.
                     </p>
                     <p>The advantages of cursor variables are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="italic">Encapsulation</span>: queries are centralized in the stored procedure that opens the cursor variable.
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">Ease of maintenance</span>: only the stored procedure needs to be changed if the table changes.
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">Security</span>: the user of the application (the username when the Pro*FORTRAN application connected to the database) must have execute permission on the stored procedure that opens the cursor. This user, however, does not need to have read permission on the tables used in the query. This capability can be used to limit access to the columns in the table.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ZZFOR185"></a><div class="props_rev_3"><a id="GUID-7A1CE308-3AAB-46BD-B626-F2998DCF457C" name="GUID-7A1CE308-3AAB-46BD-B626-F2998DCF457C"></a><h3 id="ZZFOR-GUID-7A1CE308-3AAB-46BD-B626-F2998DCF457C" class="sect3"><span class="enumeration_section">1.15 </span>About Declaring a Cursor Variable
               </h3>
               <div>
                  <p>You declare a Pro*FORTRAN cursor variable using the SQLCURSOR pseudotype. For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION
 ...
 SQLCURSOR CURVAR
 ...
 EXEC SQL END DECLARE SECTION
</pre><p>A SQLCURSOR variable is implemented using a FORTRAN INTEGER*4 array in the code that Pro*FORTRAN generates. A cursor variable is just like any other Pro*FORTRAN host variable.</p>
               </div><a id="ZZFOR186"></a><div class="props_rev_3"><a id="GUID-09F3D3B8-08F3-445C-A262-921627D80B0A" name="GUID-09F3D3B8-08F3-445C-A262-921627D80B0A"></a><h4 id="ZZFOR-GUID-09F3D3B8-08F3-445C-A262-921627D80B0A" class="sect4"><span class="enumeration_section">1.15.1 </span>About Allocating a Cursor Variable
                  </h4>
                  <div>
                     <p>Before you can OPEN or FETCH a cursor variable, you must allocate it by using the Pro*FORTRAN ALLOCATE command. For example, to allocate the cursor variable CURVAR that was declared in the previous section, write the following statement:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE :CURVAR
</pre><p>Allocating a cursor variable does <span class="italic">not</span> require a call to the server, either at precompile time or at run time.
                     </p>
                     <div class="infoboxnote" id="GUID-09F3D3B8-08F3-445C-A262-921627D80B0A__GUID-81CE8CCD-CBB1-4D6D-BAC6-0C17801E14E7">
                        <p class="notep1">Caution:</p>
                        <p>Allocating a cursor variable <span class="italic">does</span> cause heap memory to be used. For this reason, avoid allocating a cursor variable in a program loop.
                        </p>
                     </div>
                  </div>
               </div><a id="ZZFOR187"></a><div class="props_rev_3"><a id="GUID-03CC37B0-786C-4927-8A40-B3EC9A8624A6" name="GUID-03CC37B0-786C-4927-8A40-B3EC9A8624A6"></a><h4 id="ZZFOR-GUID-03CC37B0-786C-4927-8A40-B3EC9A8624A6" class="sect4"><span class="enumeration_section">1.15.2 </span>About Opening a Cursor Variable
                  </h4>
                  <div>
                     <p>You must use an embedded anonymous PL/SQL block to open a cursor variable on the Oracle Server. The anonymous PL/SQL block may open the cursor either indirectly by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement) or directly from the Pro*FORTRAN program.</p>
                  </div>
               </div><a id="ZZFOR188"></a><div class="props_rev_3"><a id="GUID-8A3EFB84-04EC-4A82-8873-C31DF4680C71" name="GUID-8A3EFB84-04EC-4A82-8873-C31DF4680C71"></a><h4 id="ZZFOR-GUID-8A3EFB84-04EC-4A82-8873-C31DF4680C71" class="sect4"><span class="enumeration_section">1.15.3 </span>About Opening Indirectly through a Stored PL/SQL Procedure
                  </h4>
                  <div>
                     <p>Consider the following PL/SQL package stored in the database:</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE demo_cur_pkg AS
 TYPE EmpName IS RECORD (name VARCHAR2(10));
 TYPE cur_type IS REF CURSOR RETURN EmpName;
 PROCEDURE open_emp_cur (
 curs IN OUT curtype,
 dept_num IN NUMBER);
END;
CREATE PACKAGE BODY demo_cur_pkg AS
 CREATE PROCEDURE open_emp_cur (
 curs IN OUT curtype,
 dept_num IN NUMBER) IS
 BEGIN
 OPEN curs FOR
 SELECT ename FROM emp
 WHERE deptno = dept_num
 ORDER BY ename ASC;
 END;
END;
</pre><p>After this package has been stored, you can open the variable <span class="italic">curs</span> by calling the <span class="italic">open_emp_cur</span> stored procedure from your Pro*FORTRAN program, and FETCH from the cursor variable ECUR in the program. For example:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION
 SQLCURSOR ECUR
 INTEGER*4 DNUM
 VARCHAR*10 ENAM, ENAML, ENAMA
 EXEC SQL END DECLARE SECTION
 ...
* Allocate the cursor variable.
 EXEC SQL ALLOCATE :ECUR
 ...
 DNUM=30
* Open the cursor on the Oracle Database Server.
 EXEC SQL EXECUTE
 1 BEGIN
 2 demo_cur_pkg.open_emp_cur(:ECUR, :DNUM);
 3 END;
 4 END-EXEC
 EXEC SQL WHENEVER NOTFOUND DO CALL SIGNOFF
*
 1000 EXEC SQL FETCH :ECUR INTO :ENAM
 PRINT *, "Employee Name: ", ENAM
 GOTO 1000
 ...
</pre></div>
               </div><a id="ZZFOR189"></a><div class="props_rev_3"><a id="GUID-D0011A0C-E897-4F55-ADC6-6D9BBBC3358E" name="GUID-D0011A0C-E897-4F55-ADC6-6D9BBBC3358E"></a><h4 id="ZZFOR-GUID-D0011A0C-E897-4F55-ADC6-6D9BBBC3358E" class="sect4"><span class="enumeration_section">1.15.4 </span>About Opening Directly from Your Pro*FORTRAN Application
                  </h4>
                  <div>
                     <p>To open a cursor by using a PL/SQL anonymous block in a Pro*FORTRAN program, define the cursor in the anonymous block. Consider the following example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE
 1 BEGIN
 2 OPEN :ECUR FOR SELECT ENAME FROM EMP
 3 WHERE DEPTNO = :DNUM;
 4 END;
 5 END-EXEC
 ...
</pre></div>
               </div><a id="ZZFOR190"></a><div class="props_rev_3"><a id="GUID-7F95D4B5-FBD4-4267-A10B-9CCA18DC4EC0" name="GUID-7F95D4B5-FBD4-4267-A10B-9CCA18DC4EC0"></a><h4 id="ZZFOR-GUID-7F95D4B5-FBD4-4267-A10B-9CCA18DC4EC0" class="sect4"><span class="enumeration_section">1.15.5 </span>Return Types
                  </h4>
                  <div>
                     <p>When you define a reference cursor (REF CURSOR) in a PL/SQL stored procedure, you must declare the type that the cursor returns. The return types allowed for reference cursors are described in the <a href="../lnpls/overview.html#LNPLS-GUID-2FBCFBBE-6B42-4DB8-83F3-55B63B75B1EB" target="_blank"><span class="italic">PL/SQL User's Guide and Reference</span></a>.
                     </p>
                  </div>
               </div><a id="ZZFOR191"></a><div class="props_rev_3"><a id="GUID-01024084-0CB0-467B-AE87-D558ED3319CD" name="GUID-01024084-0CB0-467B-AE87-D558ED3319CD"></a><h4 id="ZZFOR-GUID-01024084-0CB0-467B-AE87-D558ED3319CD" class="sect4"><span class="enumeration_section">1.15.6 </span>About Fetching from a Cursor Variable
                  </h4>
                  <div>
                     <p>Use the embedded SQL FETCH .... INTO command to retrieve the rows SELECTed when you opened the cursor variable. For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH :ECUR INTO :EINFO:IEINFO
</pre><p>Before you can FETCH from a cursor variable, the variable must be initialized and opened. You cannot FETCH from an unopened cursor variable.</p>
                  </div>
               </div><a id="ZZFOR192"></a><div class="props_rev_3"><a id="GUID-BDE5738A-F891-4AF8-8C30-8108D1F3DED7" name="GUID-BDE5738A-F891-4AF8-8C30-8108D1F3DED7"></a><h4 id="ZZFOR-GUID-BDE5738A-F891-4AF8-8C30-8108D1F3DED7" class="sect4"><span class="enumeration_section">1.15.7 </span>About Closing a Cursor Variable
                  </h4>
                  <div>
                     <p>Use the embedded SQL CLOSE command to close a cursor variable. For example:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION
* Declare the cursor variable.
 SQLCURSOR ECUR
 ...
 EXEC SQL END DECLARE SECTION
* Allocate and open the cursor variable, then
* fetch one or more rows.
 ...
* Close the cursor variable.
 EXEC SQL CLOSE :ECUR
</pre></div>
               </div><a id="ZZFOR193"></a><div class="props_rev_3"><a id="GUID-C8DE3905-A36B-4D3C-A9DB-61486D9FB010" name="GUID-C8DE3905-A36B-4D3C-A9DB-61486D9FB010"></a><h4 id="ZZFOR-GUID-C8DE3905-A36B-4D3C-A9DB-61486D9FB010" class="sect4"><span class="enumeration_section">1.15.8 </span>Restrictions
                  </h4>
                  <div>
                     <p>The following restrictions apply to the use of cursor variables:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You can only use cursor variables with the ALLOCATE, FETCH, and CLOSE commands. The DECLARE CURSOR command does <span class="italic">not</span> apply to cursor variables.
                           </p>
                        </li>
                        <li>
                           <p>You cannot FETCH from a CLOSEd or unALLOCATEd cursor variable.</p>
                        </li>
                        <li>
                           <p>If you precompile with MODE=ANSI, it is an error to close a cursor variable that is already closed.</p>
                        </li>
                        <li>
                           <p>You cannot use the AT clause with the ALLOCATE command.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ZZFOR194"></a><div class="props_rev_3"><a id="GUID-9E0F0A8F-A027-410C-81C2-D49611CB3445" name="GUID-9E0F0A8F-A027-410C-81C2-D49611CB3445"></a><h4 id="ZZFOR-GUID-9E0F0A8F-A027-410C-81C2-D49611CB3445" class="sect4"><span class="enumeration_section">1.15.9 </span>Error Conditions
                  </h4>
                  <div>
                     <p>Do <span class="italic">not</span> perform any of the following operations:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>FETCH from a closed cursor variable</p>
                        </li>
                        <li>
                           <p>use a cursor variable that is not ALLOCATEd</p>
                        </li>
                        <li>
                           <p>CLOSE a cursor variable that is not open</p>
                        </li>
                     </ul>
                     <p>These operations on cursor variables result in errors.</p>
                  </div>
               </div><a id="ZZFOR234"></a><a id="ZZFOR235"></a><a id="ZZFOR195"></a><div class="props_rev_3"><a id="GUID-282F1A95-EF05-4C7A-ACB7-AFA631C500FC" name="GUID-282F1A95-EF05-4C7A-ACB7-AFA631C500FC"></a><h4 id="ZZFOR-GUID-282F1A95-EF05-4C7A-ACB7-AFA631C500FC" class="sect4"><span class="enumeration_section">1.15.10 </span>Sample Programs
                  </h4>
                  <div>
                     <p>The following sample programs -- a SQL script (SAMPLE11.SQL) and a Pro*FORTRAN program (SAMPLE11.PFO) -- demonstrate how you can use cursor variables in Pro*FORTRAN.</p>
                     <div class="infoboxnote" id="GUID-282F1A95-EF05-4C7A-ACB7-AFA631C500FC__GUID-7746E98B-2338-4AEC-8C23-381C0A1CEFA2">
                        <p class="notep1">Note:</p>
                        <p>For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.
                        </p>
                     </div>
                  </div>
               </div><a id="ZZFOR196"></a><div class="props_rev_3"><a id="GUID-11B17A1B-D46B-4AE2-A4D4-1EF21677D8D5" name="GUID-11B17A1B-D46B-4AE2-A4D4-1EF21677D8D5"></a><h4 id="ZZFOR-GUID-11B17A1B-D46B-4AE2-A4D4-1EF21677D8D5" class="sect4"><span class="enumeration_section">1.15.11 </span>SAMPLE11.SQL
                  </h4>
                  <div>
                     <p>Following is the PL/SQL source code for a creating a package that declares and opens a cursor variable:</p><pre class="oac_no_warn" dir="ltr">CONNECT AAAAA/BBBBB
CREATE OR REPLACE PACKAGE emp_demo_pkg AS
 TYPE emp_cur_type IS REF CURSOR RETURN emp%ROWTYPE;
 PROCEDURE open_cur (
 cursor IN OUT emp_cur_type,
 dept_num IN number);
END emp_demo_pkg;
/ 
CREATE OR REPLACE PACKAGE BODY emp_demo_pkg AS
 PROCEDURE open_cur (
 cursor IN OUT emp_cur_type, 
 dept_num IN number) IS
 BEGIN 
 OPEN cursor FOR SELECT * FROM emp
 WHERE deptno = dept_num
 ORDER BY ename ASC;
 END;
END emp_demo_pkg;
/
</pre></div>
               </div><a id="ZZFOR197"></a><div class="props_rev_3"><a id="GUID-CBBD2BD1-5D7E-44CF-BC99-9CA1D95FABE0" name="GUID-CBBD2BD1-5D7E-44CF-BC99-9CA1D95FABE0"></a><h4 id="ZZFOR-GUID-CBBD2BD1-5D7E-44CF-BC99-9CA1D95FABE0" class="sect4"><span class="enumeration_section">1.15.12 </span>SAMPLE11.PFO
                  </h4>
                  <div>
                     <p>Following is a Pro*FORTRAN sample program that uses the cursor declared in the SAMPLE11.SQL example to fetch employee names, salaries, and commissions from the EMP table.</p><pre class="oac_no_warn" dir="ltr">PROGRAM SAMPLE11
 EXEC SQL BEGIN DECLARE SECTION
* Declare the cursor variable.
 SQLCURSOR ECUR
* EMPINFO
 INTEGER ENUM
 CHARACTER*10 ENAM
 VARCHAR*9 EJOB, EJOBL, EJOBA
 INTEGER EMGR
 VARCHAR*10 EDAT, EDATL, EDATA
 REAL ESAL
 REAL ECOM
 INTEGER EDEP
* EMPINFO INDICATORS
 INTEGER*2 IENUM
 INTEGER*2 IENAM
 INTEGER*2 IEJOB
 INTEGER*2 IEMGR
 INTEGER*2 IEDAT
 INTEGER*2 IESAL
 INTEGER*2 IECOM
 INTEGER*2 IEDEP
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 COMMON /CURSOR/ ECUR
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 CALL LOGON

* Initialize the cursor variable.
 EXEC SQL ALLOCATE :ECUR
 TYPE 1000
 1000 FORMAT (/, 'Enter department number (0 to exit): ', $)
 ACCEPT 1100, EDEP
 1100 FORMAT (I10)
 IF (EDEP .LE. 0) THEN
 CALL SIGNOFF
 ENDIF

* Open the cursor by calling a PL/SQL stored procedure.
 EXEC SQL EXECUTE
 1 BEGIN
 2 emp_demo_pkg.open_cur (:ECUR, :EDEP);
 3 END;
 4 END-EXEC
 PRINT 1200, EDEP
 1200 FORMAT (/, 'For department ', I, ':',/)
 PRINT 1300
 1300 FORMAT (/, 'EMPLOYEE SALARY COMMISSION',
 + /, '---------- ---------- ----------')

* Fetch data from the cursor into the host variables.
 2000 EXEC SQL WHENEVER NOT FOUND DO CALL SIGNOFF
 EXEC SQL FETCH :ECUR
 1 INTO :ENUM:IENUM,
 2 :ENAM:IENAM,
 3 :EJOB:IEJOB,
 4 :EMGR:IEMGR,
 5 :EDAT:IEDAT,
 6 :ESAL:IESAL,
 7 :ECOM:IECOM,
 8 :EDEP:IEDEP

* Check for commission and print results.
 IF (IECOM .EQ. 0) THEN
 PRINT 2100, ENAM, ESAL, ECOM
 2100 FORMAT (A10, 2X, F10.2, 2X, F10.2)
 ELSE
 PRINT 2200, ENAM, ESAL
 2200 FORMAT (A10, 2X, F10.2, 2X, ' N/A')
 ENDIF
 GOTO 2000
 END

* LOG ON TO ORACLE.
 SUBROUTINE LOGON
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 UID = 'AAAAA'
 PWD = 'BBBBB'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT 3000, UID
 3000 FORMAT (/, 'CONNECTED TO ORACLE AS USER: ', A)
 END
* Close the cursor variable.
 SUBROUTINE SIGNOFF
 EXEC SQL BEGIN DECLARE SECTION
 SQLCURSOR ECUR
 EXEC SQL END DECLARE SECTION
 EXEC SQL INCLUDE SQLCA
 COMMON /CURSOR/ ECUR
 EXEC SQL CLOSE :ECUR
 PRINT 4100
 4100 FORMAT (/, 'HAVE A GOOD DAY.', /)
 EXEC SQL COMMIT WORK RELEASE
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT*, ' '
 PRINT *, 'ORACLE ERROR DETECTED: '
 PRINT '(70A1)', SQLEMC
 PRINT*, ' '
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
               </div>
            </div><a id="ZZFOR198"></a><div class="props_rev_3"><a id="GUID-A0304B39-A1A3-4608-B2F4-A30CB42AFDA3" name="GUID-A0304B39-A1A3-4608-B2F4-A30CB42AFDA3"></a><h3 id="ZZFOR-GUID-A0304B39-A1A3-4608-B2F4-A30CB42AFDA3" class="sect3"><span class="enumeration_section">1.16 </span>Connecting to Oracle
               </h3>
               <div>
                  <div class="section">
                     <p>Your Pro*FORTRAN program must log on to Oracle before querying or manipulating data. To log on, you use the CONNECT statement, as in</p><pre class="oac_no_warn" dir="ltr">* Log on to Oracle.
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
</pre><p>where UID and PWD are CHARACTER or VARCHAR host variables. Alternatively, you can use the statement</p><pre class="oac_no_warn" dir="ltr">* Log on to Oracle.
 EXEC SQL CONNECT :UIDPWD
</pre><p>where the host variable UIDPWD contains your username and password separated by a slash (/).</p>
                     <p>The CONNECT statement must be the first SQL statement executed by the program. That is, other executable SQL statements can positionally, but not logically, precede the CONNECT statement.</p>
                     <p>To supply the Oracle username and password separately, you define two host variables in the Declare Section as character strings or VARCHAR variables. If you supply a userid containing both username and password, only one host variable is needed.</p>
                     <p>Make sure to set the username and password variables before the CONNECT is executed or it will fail. Your program can prompt for the values or you can hard code them as follows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 ...
 EXEC SQL END DECLARE SECTION
 UID = 'AAAAA'
 PWD = 'BBBBB'
* Handle logon errors.
 EXEC SQL WHENEVER SQLERROR GOTO ...
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
</pre><p>However, you cannot hard code a username and password into the CONNECT statement or use quoted literals. For example, both of the following statements are <span class="italic">invalid</span>:
                     </p><pre class="oac_no_warn" dir="ltr">* Invalid CONNECT statements
 EXEC SQL CONNECT AAAAA IDENTIFIED BY BBBBB
 EXEC SQL CONNECT 'AAAAA' IDENTIFIED BY 'BBBBB'
</pre></div>
                  <!-- class="section" -->
               </div><a id="ZZFOR199"></a><div class="props_rev_3"><a id="GUID-C78E6925-DFE4-4602-AD6D-2D394DAB53FF" name="GUID-C78E6925-DFE4-4602-AD6D-2D394DAB53FF"></a><h4 id="ZZFOR-GUID-C78E6925-DFE4-4602-AD6D-2D394DAB53FF" class="sect4"><span class="enumeration_section">1.16.1 </span>Automatic Logons
                  </h4>
                  <div>
                     <p>You can automatically log on to the Oracle using the following userid:</p><pre class="oac_no_warn" dir="ltr">&lt;prefix&gt;&lt;username&gt;
</pre><p>where <span class="italic">prefix</span> is the value of the Oracle initialization parameter OS_AUTHENT_PREFIX (the default value is OPS$) and <span class="italic">username</span> is your operating system user or task name. For example, if the prefix is OPS$, your user name is TBARNES, and OPS$TBARNES is a valid Oracle userid, you log on to Oracle as user OPS$TBARNES.
                     </p>
                     <p>To take advantage of the automatic logon feature, you simply pass a slash (/) character to the precompiler, as follows:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 CHARACTER*1 ORAID
 EXEC SQL END DECLARE SECTION 
 ORAID = '/' 
 EXEC SQL CONNECT :ORAID
</pre><p>This automatically connects you as user OPS$<span class="italic">username</span>. For example, if your operating system username is RHILL, and OPS$RHILL is a valid Oracle username, connecting with a slash (/) automatically logs you on to Oracle as user OPS$RHILL.
                     </p>
                     <p>You can also pass a character string to the precompiler. However, the string cannot contain trailing blanks. For example, the following CONNECT statement will fail:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 ...
 CHARACTER*5 ORAID
 EXEC SQL END DECLARE SECTION 
 ORAID = '/ ' 
 EXEC SQL CONNECT :ORAID 
</pre><p>For more information about operating system authentication, see the <span class="italic">Oracle Database Administrator's Guide</span>.
                     </p>
                  </div>
               </div><a id="ZZFOR200"></a><div class="props_rev_3"><a id="GUID-E9734943-82A1-4DC9-A3F9-6D2BC7215320" name="GUID-E9734943-82A1-4DC9-A3F9-6D2BC7215320"></a><h4 id="ZZFOR-GUID-E9734943-82A1-4DC9-A3F9-6D2BC7215320" class="sect4"><span class="enumeration_section">1.16.2 </span>Concurrent Logons
                  </h4>
                  <div>
                     <p>Your application can use Oracle Net Services to access any combination of remote and local databases concurrently or make multiple connections to the same database. In the following example, you connect to two nondefault databases concurrently:</p><pre class="oac_no_warn" dir="ltr">* Declare host variables.
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*5 UID
 CHARACTER*5 PWD
 CHARACTER*12 DBSTR1
 CHARACTER*12 DBSTR2
 EXEC SQL END DECLARE SECTION
 UID = 'AAAAA'
 PWD = 'BBBBB'
 DBSTR1 = 'NEWYORK'
 DBSTR2 = 'BOSTON'
* Give each database connection a unique name.
 EXEC SQL DECLARE DBNAM1 DATABASE
 EXEC SQL DECLARE DBNAM2 DATABASE
* Connect to the two non-default databases.
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 1 AT DBNAM1 USING :DBSTR1
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 1 AT DBNAM2 USING :DBSTR2
</pre><p>The string syntax in DBSTR1 and DBSTR2 depends on your network driver and how it is configured. DBNAM1 and DBNAM2 name the nondefault connections; they can be undeclared identifiers or host variables.</p>
                     <p>For step-by-step instructions on connecting to Oracle through Oracle Net Services, see <a href="../zzpre/meeting-program-requirements.html#ZZPRE-GUID-ED71BADE-AF94-4074-B4B1-140E03903E88" target="_blank">Meeting Program Requirements</a>.
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>