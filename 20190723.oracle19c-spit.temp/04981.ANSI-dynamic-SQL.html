<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>ANSI Dynamic SQL</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96467-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="Oracle-dynamic-SQL.html" title="Previous" type="text/html">
      <link rel="next" href="Oracle-dynamic-SQL-method-4.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNPCC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-dynamic-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="Oracle-dynamic-SQL-method-4.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name"> Applications </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> 	ANSI Dynamic SQL</li>
            </ol>
            <a id="GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF" name="GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF"></a><a id="LNPCC014"></a>
            
            <h2 id="LNPCC-GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF" class="sect2"><span class="enumeration_chapter">14 </span> 	ANSI Dynamic SQL
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes Oracle's implementation of <a id="d75516e22" class="indexterm-anchor"></a>ANSI dynamic SQL (also known as SQL standard dynamic SQL) which should be used for new Method 4 applications. It has enhancements over the older Oracle dynamic SQL Method 4, described in the previous chapter. 
               </p>
               <p>The ANSI Method 4 supports all Oracle types, while the older Oracle Method 4 does <span class="italic">not</span> support object types, cursor variables, arrays of structs, DML returning clauses, Unicode variables, and LOBs.
               </p>
               <p>In ANSI dynamic SQL, descriptors are internally maintained by Oracle, while in the older Oracle dynamic SQL Method 4, descriptors are defined in the user's Pro*C/C++ program. In both cases, Method 4 means that your Pro*C/C++ program accepts or builds SQL statements that contain a varying number of host variables.</p>
               <p>This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-89EBF009-D3AE-4410-9BB6-A55DBE07BC41">Basics of ANSI Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5">Overview of ANSI SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-D40DCC4E-4B07-4C21-92CA-D060FF716700">Oracle Extensions</a></p>
                  </li>
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8">ANSI Dynamic SQL Precompiler Options</a></p>
                  </li>
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-C0D00130-3193-4038-A730-98471BF8E259">Full Syntax of the Dynamic SQL Statements</a></p>
                  </li>
                  <li>
                     <p><a href="ANSI-dynamic-SQL.html#GUID-F216E6D1-16BA-400A-8C26-75AC9398264A">Example Programs</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4033"></a><div class="props_rev_3"><a id="GUID-89EBF009-D3AE-4410-9BB6-A55DBE07BC41" name="GUID-89EBF009-D3AE-4410-9BB6-A55DBE07BC41"></a><h3 id="LNPCC-GUID-89EBF009-D3AE-4410-9BB6-A55DBE07BC41" class="sect3"><span class="enumeration_section">14.1 </span>Basics of ANSI Dynamic SQL
               </h3>
               <div>
                  <p>Consider the SQL statement:</p><pre class="oac_no_warn" dir="ltr">SELECT ename, empno FROM emp WHERE deptno = :deptno_data 
</pre><p>The steps you follow to use ANSI dynamic SQL are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Declare variables, including a string to hold the statement to be executed.</p>
                     </li>
                     <li>
                        <p>Allocate descriptors for input and output variables.</p>
                     </li>
                     <li>
                        <p>Prepare the statement.</p>
                     </li>
                     <li>
                        <p>Describe input for the input descriptor.</p>
                     </li>
                     <li>
                        <p>Set the input descriptor (in our example the one input host bind variable, <code class="codeph">deptno_data)</code>.
                        </p>
                     </li>
                     <li>
                        <p>Declare and open a dynamic cursor.</p>
                     </li>
                     <li>
                        <p>Set the output descriptors (in our example, the output host variables <code class="codeph">ename </code>and <code class="codeph">empno)</code>.
                        </p>
                     </li>
                     <li>
                        <p>Repeatedly fetch data, using GET DESCRIPTOR to retrieve the <code class="codeph">ename</code> and <code class="codeph">empno</code> data fields from each row.
                        </p>
                     </li>
                     <li>
                        <p>Do something with the data retrieved (output it, for instance).</p>
                     </li>
                     <li>
                        <p>Close the dynamic cursor and deallocate the input and output descriptors.</p>
                     </li>
                  </ul>
               </div><a id="LNPCC4034"></a><a id="LNPCC3574"></a><div class="props_rev_3"><a id="GUID-4C3798E6-854E-438B-85A9-BC34CE2B314E" name="GUID-4C3798E6-854E-438B-85A9-BC34CE2B314E"></a><h4 id="LNPCC-GUID-4C3798E6-854E-438B-85A9-BC34CE2B314E" class="sect4"><span class="enumeration_section">14.1.1 </span>Precompiler Options
                  </h4>
                  <div>
                     <p>Set the micro precompiler option DYNAMIC to ANSI, or set the macro option MODE to ANSI, which causes the default value of DYNAMIC to be ANSI. The other setting of DYNAMIC is ORACLE.</p>
                     <p>In order to use ANSI type codes, set the precompiler micro option TYPE_CODE to ANSI, or set the macro option MODE to ANSI which makes the default setting of TYPE_CODE to ANSI. To set TYPE_CODE to ANSI, DYNAMIC must also be ANSI.</p>
                     <p>Oracle's implementation of the ANSI SQL types in <a href="ANSI-dynamic-SQL.html#GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5">Overview of ANSI SQL Statements</a> does not exactly match the ANSI standard. For example, a describe of a column declared as INTEGER will return the code for NUMERIC. As Oracle moves closer to the ANSI standard, small changes in behavior may be required. Use the ANSI types with precompiler option TYPE_CODE set to ANSI if you want your application to be portable across database platforms and as ANSI compliant as possible. Do not use TYPE_CODE set to ANSI if such changes are not acceptable.
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC4036"></a><a id="LNPCC4035"></a><div class="props_rev_3"><a id="GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5" name="GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5"></a><h3 id="LNPCC-GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5" class="sect3"><span class="enumeration_section">14.2 </span>Overview of ANSI SQL Statements
               </h3>
               <div>
                  <p>Allocate a descriptor area first before using it in a dynamic SQL statement. </p>
                  <p>The ALLOCATE DESCRIPTOR statement syntax is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>} 
  [WITH MAX {<span class="italic">:occurrences</span> | <span class="italic">numeric_literal</span>}];
</pre><p>A global descriptor can be used in any module in the program. A local descriptor can be accessed only in the file in which it is allocated. Local is the default. </p>
                  <p>The descriptor name, <code class="codeph">desc_nam,</code> can be a literal in single quotes or a character value stored in a host variable.
                  </p>
                  <p><code class="codeph">occurrences</code> is the maximum number of bind variables or columns that the descriptor can hold. This must be a numeric literal. The default is 100. 
                  </p>
                  <p>When a descriptor is no longer needed, deallocate it to conserve memory. Otherwise, deallocation is done automatically when there are no more active database connections.</p>
                  <p>The deallocate statement is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>};
</pre><p>Use the DESCRIBE statement to obtain information on a prepared SQL statement. DESCRIBE INPUT describes bind variables for the dynamic statement that has been prepared. DESCRIBE OUTPUT (the default) can give the number, type, and length of the output columns. The simplified syntax is:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DESCRIBE [INPUT | OUTPUT] <span class="italic">sql_statement</span> 
    USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam</span> | <span class="italic">string_literal</span>};

</pre><p>If your SQL statement has input and output values, you must allocate two descriptors: one for input and one for output values. If there are no input values, for example:</p><pre class="oac_no_warn" dir="ltr">SELECT ename, empno FROM emp ;
</pre><p>then the input descriptor is not needed.</p>
                  <p>Use the SET DESCRIPTOR statement to specify input values for INSERTS, UPDATES, DELETES and the WHERE clauses of SELECT statements. Use SET DESCRIPTOR to set the number of input bind variables (stored in <code class="codeph">COUNT</code>) when you have not done a DESCRIBE into your input descriptor: 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
   COUNT = {:<span class="italic">kount </span>|<span class="italic"> numeric_literal</span>};
</pre><p><code class="codeph">kount</code> can be a host variable or a numeric literal, such as 5. Use a SET DESCRIPTOR statement for each host variable, giving at least the data source of the variable:
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   VALUE <span class="italic">item_number</span> DATA = :<span class="italic">hv3</span>;
</pre><p>You can also set the type and length of the input host variable:</p>
                  <div class="infoboxnote" id="GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__GUID-267F11F1-44A3-4474-87A1-D46DEFE4FA56">
                     <p class="notep1">Note:</p>
                     <p>When TYPE_CODE=ORACLE, if you do not set TYPE and LENGTH, either explicitly using the SET statement or implicitly by doing a DESCRIBE OUTPUT, the precompiler will use values for them derived from the host variable itself. When TYPE_CODE=ANSI, you must set TYPE using the values in <a href="ANSI-dynamic-SQL.html#GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__G1022936" title="ANSI SQL Datatypes">Table 14-1</a>. You should also set LENGTH because the ANSI default lengths may not match those of your host variables.
                     </p>
                  </div><pre class="oac_no_warn" dir="ltr">EXEC SQL SET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   VALUE <span class="italic">item_number</span> TYPE = :<span class="italic">hv1</span>, LENGTH = :<span class="italic">hv2</span>, DATA = :<span class="italic">hv3</span>;
</pre><p>We use the identifiers<code class="codeph"> hv1</code>, <code class="codeph">hv2</code>, and <code class="codeph">hv3 </code>to remind us that the values must be supplied by host variables. <span class="italic">item_number</span> is the position of the input variable in the SQL statement.
                  </p>
                  <p>TYPE is the Type Code selected from the following table, if TYPE_CODE is set to ANSI:</p>
                  <div class="tblformal" id="GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__G1022936">
                     <p class="titleintable">Table 14-1 ANSI SQL Datatypes</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="ANSI SQL Datatypes" summary="ANSI SQL Datatypes" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="71%" id="d75516e370">Datatype</th>
                              <th align="left" valign="bottom" width="29%" id="d75516e373">Type Code</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e378" headers="d75516e370 ">
                                 <p>CHARACTER</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e378 d75516e373 ">
                                 <p>1</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e385" headers="d75516e370 ">
                                 <p>CHARACTER VARYING</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e385 d75516e373 ">
                                 <p>12</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e392" headers="d75516e370 ">
                                 <p>DATE</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e392 d75516e373 ">
                                 <p>9</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e399" headers="d75516e370 ">
                                 <p>DECIMAL</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e399 d75516e373 ">
                                 <p>3</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e406" headers="d75516e370 ">
                                 <p>DOUBLE PRECISION</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e406 d75516e373 ">
                                 <p>8</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e413" headers="d75516e370 ">
                                 <p>FLOAT</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e413 d75516e373 ">
                                 <p>6</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e420" headers="d75516e370 ">
                                 <p>INTEGER</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e420 d75516e373 ">
                                 <p>4</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e427" headers="d75516e370 ">
                                 <p>NUMERIC</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e427 d75516e373 ">
                                 <p>2</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e434" headers="d75516e370 ">
                                 <p>REAL</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e434 d75516e373 ">
                                 <p>7</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="71%" id="d75516e441" headers="d75516e370 ">
                                 <p>SMALLINT</p>
                              </td>
                              <td align="left" valign="top" width="29%" headers="d75516e441 d75516e373 ">
                                 <p>5</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>DATA is the value of the host variable that is to be input</p>
                  <p>You can also set other input values such as indicator, precision and scale. </p>
                  <p>The numeric values in the SET DESCRIPTOR statement must be declared as either <code class="codeph">int</code> or <code class="codeph">short int</code>, except for indicator and returned length values which you must declare as <code class="codeph">short int</code>. 
                  </p>
                  <p>For example, in the following example, when you want to retrieve an <code class="codeph">empno</code>, set these values: VALUE = 2, because <code class="codeph">empno</code> is the second output host variable in the dynamic SQL statement. The host variable <code class="codeph">empno_typ</code> is set to 3 (Oracle Type for integer). The length of a host integer, <code class="codeph">empno_len</code>, is set to 4, which is the size of the host variable. The DATA is equated to the host variable <code class="codeph">empno_data</code> which will receive the value from the database table. The code fragment is as follows:
                  </p><pre class="oac_no_warn" dir="ltr">...
char *dyn_statement = "SELECT ename, empno FROM emp 
   WHERE deptno = :deptno_number" ;
int empno_data ;
int empno_typ = 3 ;
int empno_len = 4 ;
...
EXEC SQL SET DESCRIPTOR 'out' VALUE 2  TYPE = :empno_typ, LENGTH = :empno_len,
   DATA = :empno_data ;
</pre><p>After setting the input values, execute or open your statement using the input descriptor. If there are output values in your statement, set them before doing a FETCH. If you have performed a DESCRIBE OUTPUT, you may have to test the actual type and length of your host variables. The DESCRIBE execution produces internal types and lengths that differ from your host variable external types and length.</p>
                  <p>After the FETCH of the output descriptor, use GET DESCRIPTOR to access the returned data. Again we show a simplified syntax with details later in this chapter:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL GET DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}
   VALUE <span class="italic">item_number </span>:<span class="italic">hv1</span> = DATA, :<span class="italic">hv2</span> = INDICATOR, :<span class="italic">hv3</span> = RETURNED_LENGTH ;
</pre><p><code class="codeph">desc_nam</code> and <code class="codeph">item_number</code> can be literals or host variables. A descriptor name can be a literal such as 'out'. An item number can be a numeric literal such as 2.
                  </p>
                  <p><code class="codeph">hv1, hv2, and hv3</code> are host variables. They must be host variables, not literals. Only three are shown in the example. 
                  </p>
                  <p>Use either <span class="bold">long</span><span class="bold">, </span><span class="bold">int</span> or <span class="bold">short</span> for all numeric values, except for indicator and returned length variables, which must be <code class="codeph">short</code>.
                  </p>
                  <div class="infoboxnotealso" id="GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__GUID-825F7CC6-EEFA-41F4-8BB1-F4AD19E3ADBB">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-dynamic-SQL-method-4.html#GUID-72068D5F-21E9-4C42-92FC-536437D246FB__G34096" title="Oracle External Datatypes and Datatype Codes">Table 15-2</a> for the Oracle type codes
                           </p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="ANSI-dynamic-SQL.html#GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D">SET DESCRIPTOR</a>"</span> for a complete discussion of all the possible descriptor item names
                           </p>
                        </li>
                        <li>
                           <p><a href="ANSI-dynamic-SQL.html#GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__G1022893" title="Definitions of Descriptor Item Names for GET DESC">Table 14-4</a> for a list of all possible items of returned data that you can get.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4037"></a><div class="props_rev_3"><a id="GUID-AA394CB8-AED3-4941-9E13-1B94C0128724" name="GUID-AA394CB8-AED3-4941-9E13-1B94C0128724"></a><h4 id="LNPCC-GUID-AA394CB8-AED3-4941-9E13-1B94C0128724" class="sect4"><span class="enumeration_section">14.2.1 </span>Example Code
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following example demonstrates the use of ANSI Dynamic SQL. It allocates an input descriptor ('in') and an output descriptor ('out') to execute a SELECT statement. Input values are set using the SET DESCRIPTOR statement. The cursor is opened and fetched from and the resulting output values are retrieved using a GET DESCRIPTOR statement.</p><pre class="oac_no_warn" dir="ltr">...
char* dyn_statement = "SELECT ename, empno FROM emp WHERE deptno = :deptno_data" ;
int deptno_type = 3, deptno_len = 2, deptno_data = 10 ;
int ename_type = 97, ename_len = 30 ;
char ename_data[31] ;
int empno_type = 3, empno_len = 4 ;
int empno_data ;
long SQLCODE = 0 ;
...
main ()
{
/* Place preliminary code, including connection, here. */
...
EXEC SQL ALLOCATE DESCRIPTOR 'in' ;
EXEC SQL ALLOCATE DESCRIPTOR 'out' ;
EXEC SQL PREPARE s FROM :dyn_statement ;
EXEC SQL DESCRIBE INPUT s USING DESCRIPTOR 'in' ;
EXEC SQL SET DESCRIPTOR 'in' VALUE 1 TYPE = :deptno_type,
   LENGTH = :deptno_len, DATA = :deptno_data ;
EXEC SQL DECLARE c CURSOR FOR s ;
EXEC SQL OPEN c USING DESCRIPTOR 'in' ;
EXEC SQL DESCRIBE OUTPUT s USING DESCRIPTOR 'out' ;
EXEC SQL SET DESCRIPTOR 'out' VALUE 1 TYPE = :ename_type, 
    LENGTH = :ename_len, DATA = :ename_data ;
EXEC SQL SET DESCRIPTOR 'out' VALUE 2 TYPE = :empno_type, 
    LENGTH = :empno_len, DATA = :empno_data ;

EXEC SQL WHENEVER NOT FOUND DO BREAK ;
while (SQLCODE == 0) 
{
   EXEC SQL FETCH c INTO DESCRIPTOR 'out' ;
   EXEC SQL GET DESCRIPTOR 'out' VALUE 1 :ename_data = DATA ;
   EXEC SQL GET DESCRIPTOR 'out' VALUE 2 :empno_data = DATA ;
   printf("\nEname = %s Empno = %s", ename_data, empno_data) ;
}
EXEC SQL CLOSE c ;
EXEC SQL DEALLOCATE DESCRIPTOR 'in' ;
EXEC SQL DEALLOCATE DESCRIPTOR 'out' ;
...
}
</pre><p>Scrollable cursors can also be used with ANSI Dynamic SQL. In order to use ANSI dynamic SQL with scrollable cursors, we DECLARE the cursor in SCROLL mode. Use the various fetch orientation modes with the FETCH statement to access the result set.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4038"></a><div class="props_rev_3"><a id="GUID-D40DCC4E-4B07-4C21-92CA-D060FF716700" name="GUID-D40DCC4E-4B07-4C21-92CA-D060FF716700"></a><h3 id="LNPCC-GUID-D40DCC4E-4B07-4C21-92CA-D060FF716700" class="sect3"><span class="enumeration_section">14.3 </span>Oracle Extensions
               </h3>
               <div>
                  <p>These extensions are described next:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Reference semantics for data items in SET statements.</p>
                     </li>
                     <li>
                        <p>Arrays for bulk operations.</p>
                     </li>
                     <li>
                        <p>Support for object types, NCHAR columns, and LOBs.</p>
                     </li>
                  </ul>
               </div><a id="LNPCC4039"></a><div class="props_rev_3"><a id="GUID-1F46FC36-3190-4613-A4BF-6B31B2F276F4" name="GUID-1F46FC36-3190-4613-A4BF-6B31B2F276F4"></a><h4 id="LNPCC-GUID-1F46FC36-3190-4613-A4BF-6B31B2F276F4" class="sect4"><span class="enumeration_section">14.3.1 </span>Reference Semantics
                  </h4>
                  <div>
                     <p>The ANSI standard specifies <span class="italic">value</span> semantics. To improve performance, Oracle has extended this standard to include <span class="italic">reference</span> semantics. 
                     </p>
                     <p>Value semantics makes a copy of your host variables data. Reference semantics uses the addresses of your host variables, avoiding a copy. Thus, reference semantics can provide performance improvements for large amounts of data.</p>
                     <p>To help speed up fetches, use the REF keyword before the data clauses:</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET DESCRIPTOR 'out' VALUE 1 TYPE = :ename_type,
   LENGTH = :ename_len, REF DATA = :ename_data ;
EXEC SQL DESCRIPTOR 'out' VALUE 2 TYPE = :empno_type,
   LENGTH = :empno_len, REF DATA = :empno_data ;
</pre><p>Then the host variables receive the results of the retrieves. The GET statement is not needed. The retrieved data is written directly into <code class="codeph">ename_data</code> and <code class="codeph">empno_data</code> after each FETCH.
                     </p>
                     <p>Use of the REF keyword is allowed <span class="italic">only</span> before DATA, INDICATOR and RETURNED_LENGTH items (which can vary with each row fetched) as in this fragment of code:
                     </p><pre class="oac_no_warn" dir="ltr">int indi, returnLen ;
...
EXEC SQL SET DESCRIPTOR 'out' VALUE 1 TYPE = :ename_type,
   LENGTH = :ename_len, REF DATA = :ename_data,
      REF INDICATOR = :indi, REF RETURNED_LENGTH = :returnLen ;
</pre><p>After each fetch, <code class="codeph">returnLen </code>holds the actual retrieved length of the <code class="codeph">ename</code> field, which is useful for <code class="codeph">CHAR</code> or <code class="codeph">VARCHAR2 </code>data.
                     </p>
                     <p><code class="codeph">ename_len</code> will not receive the returned length. It will not be changed by the FETCH statement. Use a DESCRIBE statement, followed by a GET statement to find out the maximum column width before fetching rows of data.
                     </p>
                     <p>REF keyword is also used for other types of SQL statements than SELECT, to speed them up. With reference semantics, the host variable is used rather than a value copied into the descriptor area. The host variable data at the time of execution of the SQL statement is used, not its data at the time of the SET. Here is an example:</p><pre class="oac_no_warn" dir="ltr">int x = 1 ;
EXEC SQL SET DESCRIPTOR 'value' VALUE 1 DATA = :x ;
EXEC SQL SET DESCRIPTOR 'reference' VALUE 1 REF DATA = :x ;
x = 2 ;
EXEC SQL EXECUTE s USING  DESCRIPTOR 'value' ;    /* Will use  x = 1 */
EXEC SQL EXECUTE s USING DESCRIPTOR 'reference' ; /* Will use x = 2 */
</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D">SET DESCRIPTOR</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4040"></a><div class="props_rev_3"><a id="GUID-E56A766C-79F9-4AA7-8DF1-833DF8191296" name="GUID-E56A766C-79F9-4AA7-8DF1-833DF8191296"></a><h4 id="LNPCC-GUID-E56A766C-79F9-4AA7-8DF1-833DF8191296" class="sect4"><span class="enumeration_section">14.3.2 </span>About Using Arrays for Bulk Operations
                  </h4>
                  <div>
                     <p>Oracle extends ANSI dynamic SQL by providing bulk operations. To use bulk operations, use the <code class="codeph">FOR</code> clause with an array size to specify the amount of input data or the number of rows you want to process.
                     </p>
                     <p>The <code class="codeph">FOR</code> clause is used in the ALLOCATE statement to give the maximum amount of data or number of rows. For example, to use a maximum array size of 100:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR 100 ALLOCATE DESCRIPTOR 'out' ;
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">int array_size = 100 ;
...
EXEC SQL FOR :array_size ALLOCATE DESCRIPTOR 'out' ;
</pre><p>The <code class="codeph">FOR </code>clause is then used in subsequent statements that access the descriptor. In an output descriptor the FETCH statement must have an array size equal to or less than the array size already used in the ALLOCATE statement:
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR 20 FETCH c1 USING DESCRIPTOR 'out' ;
</pre><p>Subsequent GET statements for the same descriptor, that get DATA, INDICATOR, or RETURNED_LENGTH values, must use the same array size as the FETCH statement.</p><pre class="oac_no_warn" dir="ltr">int val_data[20] ;
short val_indi[20] ;
...
EXEC SQL FOR 20 GET DESCRIPTOR 'out' VALUE 1 :val_data = DATA,
  :val_indi = INDICATOR ;
</pre><p>However, GET statements that reference other items which do not vary from row to row, such as LENGTH, TYPE and COUNT, must <span class="italic">not</span> use the <code class="codeph">FOR</code> clause:
                     </p><pre class="oac_no_warn" dir="ltr">int cnt, len ;
...
EXEC SQL GET DESCRIPTOR 'out' :cnt = COUNT ;
EXEC SQL GET DESCRIPTOR 'out' VALUE 1 :len = LENGTH ;
</pre><p>The same holds true for SET statements with reference semantics. SET statements which precede the FETCH and employ reference semantics for DATA, INDICATOR, or RETURNED_LENGTH must have the same array size as the FETCH:</p><pre class="oac_no_warn" dir="ltr">int ref_data[20] ;
short ref_indi[20] ;
...
EXEC SQL FOR 20 SET DESCRIPTOR 'out' VALUE 1 REF DATA = :ref_data,
   REF INDICATOR = :ref_indi ;
</pre><p>Similarly, for a descriptor that is used for input, to insert a batch of rows, for instance, the EXECUTE or OPEN statement must use an array size equal to or less than the size used in the ALLOCATE statement. The SET statement, for both value and reference semantics, that accesses DATA, INDICATOR, or RETURNED_LENGTH must use the same array size as in the EXECUTE statement.</p>
                     <p>The FOR clause is never used on the DEALLOCATE or PREPARE statements.</p>
                     <p>The following code example illustrates a bulk operation with no output descriptor (there is no output, only input to be inserted into the table <code class="codeph">emp</code>). The value of <code class="codeph">COUNT</code> is 2 (there are two host variables, <code class="codeph">ename_arr</code> and <code class="codeph">empno_arr</code>, in the INSERT statement). The data array <code class="codeph">ename_arr</code> holds three character strings: "Tom", "Dick" and "Harry", in that order. The indicator array <code class="codeph">ename_ind</code> has a value of -1 for the second element; so a NULL will be inserted instead of "Dick". The data array <code class="codeph">empno_arr</code> contains three employee numbers. A DML returning clause could be used to confirm the actual names inserted.
                     </p><pre class="oac_no_warn" dir="ltr">...
char* dyn_statement = "INSERT INTO emp (ename) VALUES (:ename_arr)" ;
char ename_arr[3][6] = {Tom","Dick","Harry"} ;
short ename_ind[3] = {0,-1,0} ;
int ename_len = 6, ename_type = 97, cnt = 2 ;
int empno_arr[3] = {8001, 8002, 8003} ;
int empno_len = 4 ;
int empno_type = 3 ;
int array_size = 3 ;
EXEC SQL FOR :array_size ALLOCATE DESCRIPTOR 'in' ;
EXEC SQL SET DESCRIPTOR 'in' COUNT = :cnt ;
EXEC SQL SET DESCRIPTOR 'in' VALUE 1 TYPE = :ename_type, LENGTH = :ename_len ;
EXEC SQL SET DESCRIPTOR 'in' VALUE 2 TYPE = :empno_type, LENGTH = :empno_len ;
EXEC SQL FOR :array_size SET DESCRIPTOR 'in' VALUE 1
   DATA = :ename_arr, INDICATOR = :ename_ind ;
EXEC SQL FOR :array_size SET DESCRIPTOR 'in' VALUE 2
   DATA = :empno_arr ;
EXEC SQL PREPARE s FROM :dyn_statement ;
EXEC SQL FOR :array_size EXECUTE s USING DESCRIPTOR 'in' ;
...
</pre><p>The preceding code will insert these values:</p><pre class="oac_no_warn" dir="ltr">EMPNO   ENAME
 8001   Tom
 8002   
 8003   Harry</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D">The DML Returning Clause</a></li>
                           <li><a href="host-arrays.html#GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0">About Using the FOR Clause</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4041"></a><div class="props_rev_3"><a id="GUID-E2986ED3-1776-4DE7-AD3A-DED02C10CC90" name="GUID-E2986ED3-1776-4DE7-AD3A-DED02C10CC90"></a><h4 id="LNPCC-GUID-E2986ED3-1776-4DE7-AD3A-DED02C10CC90" class="sect4"><span class="enumeration_section">14.3.3 </span>Support for Arrays of Structs
                  </h4>
                  <div>
                     <p>You must set the HOST_STRIDE_LENGTH to the size of the struct, and the INDICATOR_STRIDE_LENGTH to the size of the indicator struct, and the RETURNED_LENGTH_STRIDE to the size of your returned length struct.</p>
                     <p>Arrays of structs are supported by ANSI dynamic SQL, but are <span class="italic">not</span> supported by the older Oracle dynamic SQL. 
                     </p>
                  </div>
               </div><a id="LNPCC4042"></a><div class="props_rev_3"><a id="GUID-F7D9D346-586F-4743-A4A7-F69F2366D5BB" name="GUID-F7D9D346-586F-4743-A4A7-F69F2366D5BB"></a><h4 id="LNPCC-GUID-F7D9D346-586F-4743-A4A7-F69F2366D5BB" class="sect4"><span class="enumeration_section">14.3.4 </span>Support for Object Types
                  </h4>
                  <div>
                     <p>For the object types that you have defined yourself, use Oracle TYPE equal to 108. For an object type column, use a DESCRIBE statement to obtain USER_DEFINED_TYPE_VERSION, USER_DEFINED_TYPE_NAME, USER_DEFINED_TYPE_NAME_LENGTH, USER_DEFINED_TYPE_SCHEMA, and USER_DEFINED_TYPE_SCHEMA_LENGTH.</p>
                     <p>If you do not employ the DESCRIBE statement to retrieve these values, you have to set them yourself through the SET DESCRIPTOR statement.</p>
                  </div>
               </div>
            </div><a id="LNPCC4044"></a><a id="LNPCC4045"></a><a id="LNPCC4043"></a><div class="props_rev_3"><a id="GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8" name="GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8"></a><h3 id="LNPCC-GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8" class="sect3"><span class="enumeration_section">14.4 </span>ANSI Dynamic SQL Precompiler Options
               </h3>
               <div>
                  <div class="section">
                     <p>The macro option <a id="d75516e932" class="indexterm-anchor"></a>MODE sets ANSI compatibility characteristics and controls a number of functions. It can have the values ANSI or ORACLE. For individual functions there are micro options that override the MODE setting. 
                     </p>
                     <p>The precompiler micro option <a id="d75516e939" class="indexterm-anchor"></a><span class="italic">DYNAMIC</span> specifies the descriptor behavior in dynamic SQL. The precompiler micro option <a id="d75516e946" class="indexterm-anchor"></a><span class="italic">TYPE_CODE</span> specifies whether ANSI or Oracle datatype codes are to be used. 
                     </p>
                     <p>When the macro option MODE is set to ANSI, the micro option DYNAMIC becomes ANSI automatically. When MODE is set to ORACLE, DYNAMIC becomes ORACLE. </p>
                     <p>DYNAMIC and TYPE_CODE cannot be used inline.</p>
                     <p>This table describes functionality and how the DYNAMIC setting affects them.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8__G1022849">
                     <p class="titleintable">Table 14-2 DYNAMIC Option Settings</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DYNAMIC Option Settings" summary="DYNAMIC Option Settings" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="27%" id="d75516e970">Function</th>
                              <th align="left" valign="bottom" width="37%" id="d75516e973">DYNAMIC = ANSI</th>
                              <th align="left" valign="bottom" width="37%" id="d75516e976">DYNAMIC = ORACLE</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e981" headers="d75516e970 ">
                                 <p>Descriptor creation.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e981 d75516e973 ">
                                 <p>Must use ALLOCATE statement.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e981 d75516e976 ">
                                 <p>Must use function SQLSQLDAAlloc().</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e991" headers="d75516e970 ">
                                 <p>Descriptor destruction.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e991 d75516e973 ">
                                 <p>May use DEALLOCATE statement.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e991 d75516e976 ">
                                 <p>May use function SQLLDAFree(). </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e1001" headers="d75516e970 ">
                                 <p>Retrieving data.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1001 d75516e973 ">
                                 <p>May use both FETCH and GET statements.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1001 d75516e976 ">
                                 <p>Must use only FETCH statement.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e1011" headers="d75516e970 ">
                                 <p>Setting input data.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1011 d75516e973 ">
                                 <p>May use DESCRIBE INPUT statement. Must use SET statement.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1011 d75516e976 ">
                                 <p>Must set descriptor values in code. Must use DESCRIBE BIND VARIABLES statement.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e1021" headers="d75516e970 ">
                                 <p>Descriptor representation.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1021 d75516e973 ">
                                 <p>Single quoted literal or host identifier which contains the descriptor name. </p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1021 d75516e976 ">
                                 <p>Host variable, a pointer to SQLDA.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e1031" headers="d75516e970 ">
                                 <p>Data types available.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1031 d75516e973 ">
                                 <p>All ANSI types except BIT and all Oracle types.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1031 d75516e976 ">
                                 <p>Oracle types except objects, LOBs, arrays of structs and cursor variables.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>The micro option TYPE_CODE is set by the precompiler to the same setting as the macro option MODE. TYPE_CODE can only equal ANSI if DYNAMIC equals ANSI.</p>
                     <p>Here is the functionality corresponding to the TYPE_CODE settings:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-5473577F-3537-4DD6-B879-7DB1411EB7E8__G1022881">
                     <p class="titleintable">Table 14-3 TYPE_CODE Option Settings</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="TYPE_CODE Option Settings" summary="TYPE_CODE Option Settings" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="27%" id="d75516e1056">Function</th>
                              <th align="left" valign="bottom" width="37%" id="d75516e1059">TYPE_CODE = ANSI</th>
                              <th align="left" valign="bottom" width="37%" id="d75516e1062">TYPE_CODE = ORACLE</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d75516e1067" headers="d75516e1056 ">
                                 <p>Data type code numbers input and returned in dynamic SQL. </p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1067 d75516e1059 ">
                                 <p>Use ANSI code numbers when ANSI type exists. Otherwise, use the negative of the Oracle code number.</p>
                                 <p>Only valid when DYNAMIC = ANSI.</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d75516e1067 d75516e1062 ">
                                 <p>Use Oracle code numbers.</p>
                                 <p>May be used regardless of the setting of DYNAMIC.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-639D5AF6-3CC0-4F9A-A501-DF9C791388B5">MODE</a></li>
                        <li><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">New Names for SQLLIB Public Functions</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4046"></a><div class="props_rev_3"><a id="GUID-C0D00130-3193-4038-A730-98471BF8E259" name="GUID-C0D00130-3193-4038-A730-98471BF8E259"></a><h3 id="LNPCC-GUID-C0D00130-3193-4038-A730-98471BF8E259" class="sect3"><span class="enumeration_section">14.5 </span>Full Syntax of the Dynamic SQL Statements
               </h3>
               <div>
                  <p>See <a href="embedded-SQL-statements-and-directives.html#GUID-0ABBFB3E-F2BA-4906-8DEF-53EA78D758B5">Embedded SQL Statements and Directives </a> for more details on all these statements. 
                  </p>
               </div><a id="LNPCC4048"></a><a id="LNPCC4049"></a><a id="LNPCC4050"></a><a id="LNPCC4051"></a><a id="LNPCC4047"></a><div class="props_rev_3"><a id="GUID-1D870984-33FA-4F37-B8B6-DB8026205334" name="GUID-1D870984-33FA-4F37-B8B6-DB8026205334"></a><h4 id="LNPCC-GUID-1D870984-33FA-4F37-B8B6-DB8026205334" class="sect4"><span class="enumeration_section">14.5.1 </span>ALLOCATE DESCRIPTOR
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-1D870984-33FA-4F37-B8B6-DB8026205334__GUID-B39644BB-378D-461A-A16A-40C60A601A4A">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use this statement to allocate a SQL descriptor area. Supply a descriptor and the maximum number of occurrences of host bind items, and an array size. This statement is only for the ANSI dynamic SQL.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1D870984-33FA-4F37-B8B6-DB8026205334__GUID-CE1793C0-45CF-4103-98EB-AAE8D0400792">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR [:]<span class="italic">array_size</span>] ALLOCATE DESCRIPTOR [GLOBAL | LOCAL]
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} [WITH MAX <span class="italic">occurrences</span>] ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1D870984-33FA-4F37-B8B6-DB8026205334__GUID-EA40B444-4862-468A-8764-99E132096121">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>This is in an optional clause (it is an Oracle extension) that supports array processing. It tells the precompiler that the descriptor is usable for array processing.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>Descriptor name. Local descriptors must be unique in the module. A runtime error is generated if the descriptor has been allocated, but not deallocated, previously. A global descriptor must be unique for the application, or a runtime error results.</p>
                        <p>occurrences</p>
                        <p>The maximum number of host variables possible in the descriptor. It must be an integer constant between 0 and 64K, or an error is returned. Default is 100. The clause is optional. A precompiler error results if it does not conform to these rules.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1D870984-33FA-4F37-B8B6-DB8026205334__GUID-A39245B0-8031-436A-BA14-3EA4F264D6B6"> Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE DESCRIPTOR 'SELDES' WITH MAX 50 ;

EXEC SQL FOR :batch ALLOCATE DESCRIPTOR GLOBAL :binddes WITH MAX 25 ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4053"></a><a id="LNPCC4054"></a><a id="LNPCC4055"></a><a id="LNPCC4056"></a><a id="LNPCC4052"></a><div class="props_rev_3"><a id="GUID-39530428-24E2-4576-941B-C9859616DEBB" name="GUID-39530428-24E2-4576-941B-C9859616DEBB"></a><h4 id="LNPCC-GUID-39530428-24E2-4576-941B-C9859616DEBB" class="sect4"><span class="enumeration_section">14.5.2 </span>DEALLOCATE DESCRIPTOR
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-39530428-24E2-4576-941B-C9859616DEBB__GUID-D43D4476-2898-4601-A9B9-EBA1998827BF">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use this statement to deallocate a SQL descriptor area that has been previously allocated, to free memory. This statement is only used for the ANSI dynamic SQL.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-39530428-24E2-4576-941B-C9859616DEBB__GUID-9721A988-93B6-4889-801C-6D357A64B96E">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DEALLOCATE DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-39530428-24E2-4576-941B-C9859616DEBB__GUID-D195059A-B377-498C-9503-77E3E748EC48">Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>A runtime error results when a descriptor with the same name and scope has not been allocated, or has been allocated and deallocated already. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-39530428-24E2-4576-941B-C9859616DEBB__GUID-E26FEDE9-1710-4D36-8CD6-99DF36F7F64B">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL 'SELDES' ;

EXEC SQL DEALLOCATE DESCRIPTOR :binddes ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4058"></a><a id="LNPCC4059"></a><a id="LNPCC4060"></a><a id="LNPCC4061"></a><a id="LNPCC4062"></a><a id="LNPCC4063"></a><a id="LNPCC4064"></a><a id="LNPCC4065"></a><a id="LNPCC4057"></a><div class="props_rev_3"><a id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D" name="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D"></a><h4 id="LNPCC-GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D" class="sect4"><span class="enumeration_section">14.5.3 </span>GET DESCRIPTOR
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-7E30C062-D5B8-4B4F-91A7-31E224BCE03D">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use to obtain information from a SQL descriptor area.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-9E765B7D-8CDA-4895-BD87-EEB9EFBB074C">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR [:]<span class="italic">array_size</span>] GET DESCRIPTOR [GLOBAL | LOCAL] 
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} 
   { :<span class="italic">hv0</span>  = COUNT | VALUE <span class="italic">item_number </span>
      :<span class="italic">hv1</span> = <span class="italic">item_name1</span> [ {, :<span class="italic">hvN</span> = <span class="italic">item_nameN</span>}] } ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-6F1F078A-94A5-49E5-9925-F2172DA3181F">Variables </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>The <code class="codeph">FOR array_size</code> is an optional Oracle extension. <code class="codeph">array_size</code> has to be equal to the field <code class="codeph">array_size</code> in the FETCH statement.
                        </p>
                        <p>COUNT </p>
                        <p>The total number of bind variables. </p>
                        <p>desc_nam</p>
                        <p>Descriptor name.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>VALUE item_number</p>
                        <p>The position of the item in the SQL statement. <code class="codeph">item_number</code> can be a variable or a constant. If<code class="codeph"> item_number</code> is greater than <code class="codeph">COUNT</code>, the "no data found" condition is returned. <code class="codeph">item_number</code> must be greater than 0.
                        </p>
                        <p>hv1 .. hvN</p>
                        <p>These are host variables to which values are transferred.</p>
                        <p>item_name1 .. item_nameN</p>
                        <p>The descriptor item names corresponding to the host variables. The possible ANSI descriptor item names are:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__G1022893">
                        <p class="titleintable">Table 14-4 Definitions of Descriptor Item Names for GET DESCRIPTOR</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Definitions of Descriptor Item Names for GET DESCRIPTOR" summary="Definitions of Descriptor Item Names for GET DESC" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d75516e1409">Descriptor Item Name</th>
                                 <th align="left" valign="bottom" width="69%" id="d75516e1413">Meaning</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1419" headers="d75516e1409 ">
                                    <p><code class="codeph">TYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1419 d75516e1413 ">
                                    <p>Use the negative value of Oracle type code if the ANSI datatype is not in the table and TYPE_CODE=ANSI.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1427" headers="d75516e1409 ">
                                    <p><code class="codeph">LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1427 d75516e1413 ">
                                    <p>Length of data in the column:  in characters for NCHAR;  in bytes otherwise. Set by the DESCRIBE OUTPUT.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1435" headers="d75516e1409 ">
                                    <p><code class="codeph">OCTET_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1435 d75516e1413 ">
                                    <p>Length of data in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1443" headers="d75516e1409 ">
                                    <p><code class="codeph">RETURNED_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1443 d75516e1413 ">
                                    <p>The actual data length after a FETCH.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1451" headers="d75516e1409 ">
                                    <p><code class="codeph">RETURNED_OCTET_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1451 d75516e1413 ">
                                    <p>Length of the returned data in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1459" headers="d75516e1409 ">
                                    <p><code class="codeph">PRECISION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1459 d75516e1413 ">
                                    <p>The number of digits.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1467" headers="d75516e1409 ">
                                    <p><code class="codeph">SCALE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1467 d75516e1413 ">
                                    <p>For exact numeric types, the number of digits to the right of the decimal point.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1475" headers="d75516e1409 ">
                                    <p><code class="codeph">NULLABLE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1475 d75516e1413 ">
                                    <p>If 1, the column can have NULL values. If 0,the column cannot have NULL values.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1483" headers="d75516e1409 ">
                                    <p><code class="codeph">INDICATOR</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1483 d75516e1413 ">
                                    <p>The associated indicator value.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1491" headers="d75516e1409 ">
                                    <p><code class="codeph">DATA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1491 d75516e1413 ">
                                    <p>The data value.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1499" headers="d75516e1409 ">
                                    <p><code class="codeph">NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1499 d75516e1413 ">
                                    <p>Column name.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1508" headers="d75516e1409 ">
                                    <p><code class="codeph">CHARACTER_SET_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1508 d75516e1413 ">
                                    <p>Column's character set.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>The Oracle additional descriptor item names are:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__G1022973">
                        <p class="titleintable">Table 14-5 Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR" summary="Oracle Extensions to Definitions of Descriptor Item Names for GET DESCRIPTOR" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d75516e1528">Descriptor Item Name</th>
                                 <th align="left" valign="bottom" width="69%" id="d75516e1532">Meaning</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1538" headers="d75516e1528 ">
                                    <p><code class="codeph">NATIONAL_CHARACTER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1538 d75516e1532 ">
                                    <p>If 2, NCHAR or NVARCHAR2. If 1, character. If 0, non-character.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1546" headers="d75516e1528 ">
                                    <p><code class="codeph">INTERNAL_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1546 d75516e1532 ">
                                    <p>The internal length, in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1554" headers="d75516e1528 ">
                                    <p><code class="codeph">HOST_STRIDE_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1554 d75516e1532 ">
                                    <p>The size of the host struct in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1562" headers="d75516e1528 ">
                                    <p><code class="codeph">INDICATOR_STRIDE_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1562 d75516e1532 ">
                                    <p>The size of the indicator struct in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1570" headers="d75516e1528 ">
                                    <p><code class="codeph">RETURNED_LENGTH_STRIDE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1570 d75516e1532 ">
                                    <p>The size of the returned-length struct in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1578" headers="d75516e1528 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_VERSION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1578 d75516e1532 ">
                                    <p>Used for character representation of object type version.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1586" headers="d75516e1528 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1586 d75516e1532 ">
                                    <p>Name of object type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1594" headers="d75516e1528 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_NAME_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1594 d75516e1532 ">
                                    <p>Length of name of object type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1602" headers="d75516e1528 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_SCHEMA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1602 d75516e1532 ">
                                    <p>Used for character representation of the object's schema.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1610" headers="d75516e1528 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_SCHEMA_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1610 d75516e1532 ">
                                    <p>Length of <code class="codeph">USER_DEFINED_TYPE_SCHEMA</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1621" headers="d75516e1528 ">
                                    <p><code class="codeph">NATIONAL_CHARACTER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1621 d75516e1532 ">
                                    <p>If 2, NCHAR or NVARCHAR2. If 1, character. If 0, non-character.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-3BF2EC36-3B25-4100-B4B9-FEA837ECF312">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use the FOR clause in GET DESCRIPTOR statements which contain DATA, INDICATOR, and RETURNED_LENGTH items only. </p>
                        <p>The internal type is provided by the DESCRIBE OUTPUT statement. For both input and output, you must set the type to be the external type of your host variable. </p>
                        <p>TYPE is the ANSI SQL Datatype code. Use the negative value of the Oracle type code if the ANSI type is not in the table. </p>
                        <p>LENGTH contains the column length in characters for fields that have fixed-width National Character Sets. It is in bytes for other character columns. It is set in DESCRIBE OUTPUT.</p>
                        <p>RETURNED_LENGTH is the actual data length set by the FETCH statement. It is in bytes or characters as described for LENGTH. The fields OCTET_LENGTH and RETURNED_OCTET_LENGTH are the lengths in bytes.</p>
                        <p>NULLABLE = 1 means that the column can have NULLS; NULLABLE = 0 means it cannot.</p>
                        <p>CHARACTER_SET_NAME only has meaning for character columns. For other types, it is undefined. The DESCRIBE OUTPUT statement obtains the value.</p>
                        <p>DATA and INDICATOR are the data value and the indicator status for that column. If data = NULL, but the indicator was not requested, an error is generated at runtime ("DATA EXCEPTION, NULL VALUE, NO INDICATOR PARAMETER").</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-2776F1B0-362A-4DF0-BE2E-3C8EE26934C0">Oracle-Specific Descriptor Item Names</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p></p>
                        <p>NATIONAL_CHARACTER = 2 if the column is an NCHAR or NVARCHAR2 column. If the column is a character (but not National Character) column, this item is set to 1. If a non-character column, this item becomes 0 after DESCRIBE OUTPUT is executed.</p>
                        <p>INTERNAL_LENGTH is for compatibility with Oracle dynamic Method 4. It has the same value as the length member of the Oracle SQL descriptor area.</p>
                        <p>The following three items are not returned by a DESCRIBE OUTPUT statement.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>HOST_STRIDE_LENGTH is the size of the struct of host variables.</p>
                           </li>
                           <li>
                              <p>INDICATOR_STRIDE_LENGTH is the size of the struct of indicator variables.</p>
                           </li>
                           <li>
                              <p>RETURNED_LENGTH_STRIDE is the size of the struct of returned-length variables </p>
                           </li>
                        </ul>
                        <p>The following items apply only to object types when the precompiler option OBJECTS has been set to YES.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>USER_DEFINED_TYPE_VERSION contains the character representation of the type version.</p>
                           </li>
                           <li>
                              <p>USER_DEFINED_TYPE_NAME is the character representation of the name of the type.</p>
                           </li>
                           <li>
                              <p>USER_DEFINED_TYPE_NAME_LENGTH is the length of the type name in bytes.</p>
                           </li>
                           <li>
                              <p>USER_DEFINED_TYPE_SCHEMA is the character representation of the schema name of the type.</p>
                           </li>
                           <li>
                              <p>USER_DEFINED_TYPE_SCHEMA_LENGTH is the length in characters of the type's schema name.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-C6C2F695-D65E-4D85-8A6F-878BAD701C19">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL GET DESCRIPTOR :binddes :n = COUNT ;

EXEC SQL GET DESCRIPTOR 'SELDES' VALUE 1 :t = TYPE, :l = LENGTH ;

EXEC SQL FOR :batch GET DESCRIPTOR LOCAL 'SELDES'
   VALUE :sel_item_no :i = INDICATOR, :v = DATA ; </pre><div class="infoboxnotealso" id="GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D__GUID-7FE90F60-8143-4C88-B60E-1839CFF0B11A">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="ANSI-dynamic-SQL.html#GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__G1022936" title="ANSI SQL Datatypes">Table 14-1</a> for the ANSI type codes
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-72068D5F-21E9-4C42-92FC-536437D246FB__G34096" title="Oracle External Datatypes and Datatype Codes">Table 15-2</a>"</span> for the Oracle type codes
                                 </p>
                              </li>
                              <li>
                                 <p><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">  Oracle Dynamic SQL:  Method 4</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4067"></a><a id="LNPCC4068"></a><a id="LNPCC4069"></a><a id="LNPCC4070"></a><a id="LNPCC4071"></a><a id="LNPCC4072"></a><a id="LNPCC4073"></a><a id="LNPCC4066"></a><div class="props_rev_3"><a id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D" name="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D"></a><h4 id="LNPCC-GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D" class="sect4"><span class="enumeration_section">14.5.4 </span>SET DESCRIPTOR
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-3A20788F-A0E6-4ABA-A736-F69E0817406E">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use this statement to set information in the descriptor area from host variables. The SET DESCRIPTOR statement supports <span class="italic">only</span> host variables for the item names.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-17F40BD0-7176-4052-8818-557598EECEB3">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR <span class="italic">array_size</span>] SET DESCRIPTOR [GLOBAL | LOCAL] 
   {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} {COUNT = :<span class="italic">hv0</span> | 
   VALUE <span class="italic">item_number</span>
   [REF] <span class="italic">item_name1</span> = :<span class="italic">hv1</span> 
   [{, [REF] <span class="italic">item_nameN</span> = :<span class="italic">hvN</span>}]} ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-891F8D42-FDE1-4165-B14A-9912FC7CFDE7">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>This optional Oracle clause permits using arrays when setting the descriptor items DATA, INDICATOR, and RETURNED_LENGTH only. You cannot use other items in a SET DESCRIPTOR that contains the FOR clause. All host variable array sizes must match. Use the same array size for the SET statement that you use for the FETCH statement. </p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>The descriptor name. It follows the rules in ALLOCATE DESCRIPTOR.</p>
                        <p>COUNT </p>
                        <p>The number of bind (input) or define (output) variables.</p>
                        <p>VALUE item_number</p>
                        <p>Position in the dynamic SQL statement of a host variable.</p>
                        <p>hv1 .. hvN</p>
                        <p>The host variables (not constants) that you set.</p>
                        <p>item_nameI</p>
                        <p>In a similar way to the GET DESCRIPTOR syntax <code class="codeph">desc_item_name</code> can take on these values.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__G1045758">
                        <p class="titleintable">Table 14-6 Descriptor Item Names for SET DESCRIPTOR</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Descriptor Item Names for SET DESCRIPTOR" summary="Descriptor Item Names for SET DESCRIPTOR" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d75516e1839">Descriptor Item Name</th>
                                 <th align="left" valign="bottom" width="69%" id="d75516e1843">Meaning</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1849" headers="d75516e1839 ">
                                    <p><code class="codeph">TYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1849 d75516e1843 ">
                                    <p>Use negative value of the Oracle type if there is no corresponding ANSI type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1857" headers="d75516e1839 ">
                                    <p><code class="codeph">LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1857 d75516e1843 ">
                                    <p>Maximum length of data in the column.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1865" headers="d75516e1839 ">
                                    <p><code class="codeph">INDICATOR</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1865 d75516e1843 ">
                                    <p>The associated indicator value. Set for reference semantics.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1873" headers="d75516e1839 ">
                                    <p><code class="codeph">DATA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1873 d75516e1843 ">
                                    <p>Value of the data to be set. Set for reference semantics.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1881" headers="d75516e1839 ">
                                    <p><code class="codeph">CHARACTER_SET_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1881 d75516e1843 ">
                                    <p>Column's character set.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1889" headers="d75516e1839 ">
                                    <p><code class="codeph">TYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1889 d75516e1843 ">
                                    <p>Use negative value of the Oracle type if there is no corresponding ANSI type.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>See <a href="ANSI-dynamic-SQL.html#GUID-B4F31F00-0589-4E65-B245-6CA28F6A85D5__G1022936" title="ANSI SQL Datatypes">Table 14-1</a> for the ANSI type codes and see <span class="q">"<a href="Oracle-dynamic-SQL-method-4.html#GUID-72068D5F-21E9-4C42-92FC-536437D246FB__G34096" title="Oracle External Datatypes and Datatype Codes">Table 15-2</a>"</span> for the Oracle type codes.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The Oracle extensions to the descriptor item names are:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__G1045970">
                        <p class="titleintable">Table 14-7 Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR" summary="Oracle Extensions to Descriptor Item Names for SET DESCRIPTOR" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d75516e1923">Descriptor Item Name</th>
                                 <th align="left" valign="bottom" width="69%" id="d75516e1927">Meaning</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1933" headers="d75516e1923 ">
                                    <p><code class="codeph">RETURNED_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1933 d75516e1927 ">
                                    <p>Length returned after a FETCH. Set if reference semantics is being used.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1941" headers="d75516e1923 ">
                                    <p><code class="codeph">NATIONAL_CHARACTER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1941 d75516e1927 ">
                                    <p>Set to 2 when the input host variable is an NCHAR or NVARCHAR2 type.</p>
                                    <p>Set to 0 when the National Character setting is clear.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1951" headers="d75516e1923 ">
                                    <p><code class="codeph">HOST_STRIDE_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1951 d75516e1927 ">
                                    <p>Size of the host variable struct in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1959" headers="d75516e1923 ">
                                    <p><code class="codeph">INDICATOR_STRIDE_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1959 d75516e1927 ">
                                    <p>Size of the indicator variable in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1967" headers="d75516e1923 ">
                                    <p><code class="codeph">RETURNED_LENGTH_STRIDE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1967 d75516e1927 ">
                                    <p>Size of the returned-length struct in bytes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1975" headers="d75516e1923 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1975 d75516e1927 ">
                                    <p>Name of object type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1983" headers="d75516e1923 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_NAME_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1983 d75516e1927 ">
                                    <p>Length of name of object type.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1991" headers="d75516e1923 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_SCHEMA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1991 d75516e1927 ">
                                    <p>Used for character representation of the object's schema.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d75516e1999" headers="d75516e1923 ">
                                    <p><code class="codeph">USER_DEFINED_TYPE_SCHEMA_LENGTH</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d75516e1999 d75516e1927 ">
                                    <p>Length of <code class="codeph">USER_DEFINED_TYPE_SCHEMA</code>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-12D30B30-7BDE-4334-A58D-4E1433C0545E">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Reference semantics is another optional Oracle extension that speeds performance. Use the keyword REF before these descriptor items names only: DATA, INDICATOR, RETURNED_LENGTH. When you use the REF keyword you do not need to use a GET statement. Complex data types (object and collection types, arrays of structs, and the DML returning clause) all require the REF form of SET DESCRIPTOR. </p>
                        <p>If the program reuses DESCRIPTOR for another SQL, the old values of DESCRIPTOR remain.</p>
                        <p>When REF is used the associated host variable itself is used in the SET. The GET is not needed in this case. The RETURNED_LENGTH can only be set when you use the REF semantics, not the value semantics.</p>
                        <p>Use the same array size for the SET or GET statements that you use in the FETCH.</p>
                        <p>Set the NATIONAL_CHAR field to 2 for NCHAR host input values.</p>
                        <p>Set the NATIONAL_CHARACTER field to 0 when DESCRIPTOR is used for NCHAR host input values in the old SQL.</p>
                        <p>When setting an object type's characteristics, you must set USER_DEFINED_TYPE_NAME and USER_DEFINED_TYPE_NAME_LENGTH.</p>
                        <p>If omitted, USER_DEFINED_TYPE_SCHEMA and USER_DEFINED_TYPE_SCHEMA_LENGTH default to the current connection.</p>
                        <p>Set CHARACTER_SET_NAME to UTF16 for client-side Unicode support. The data will be in UCS2 encoding and the RETURNED_LENGTH is in CHARS.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-BF426287-1491-4159-8072-A5BBAA6B74A7">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">int bindno = 2 ;
short indi = -1 ;
char data = "ignore" ;
int batch = 1 ;

EXEC SQL FOR :batch ALLOCATE DESCRIPTOR 'binddes' ;
EXEC SQL SET DESCRIPTOR GLOBAL :binddes COUNT = 3 ;
EXEC SQL FOR :batch SET DESCRIPTOR :bindes
   VALUE :bindno INDICATOR = :indi, DATA = :data ;
...</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-78FA7AFE-CB9B-487E-9A91-06003FDC219D">GET DESCRIPTOR</a></li>
                           <li><a href="embedded-SQL.html#GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D">The DML Returning Clause</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-E56A766C-79F9-4AA7-8DF1-833DF8191296">About Using Arrays for Bulk Operations</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C1251DD8-6299-4A82-BE01-4D7235E76E9D__GUID-C2F86E0D-82B0-47A9-BCA8-F2B66285D615">
                        <p class="notep1">See Also:</p>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4075"></a><a id="LNPCC4076"></a><a id="LNPCC4077"></a><a id="LNPCC4078"></a><a id="LNPCC4074"></a><div class="props_rev_3"><a id="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01" name="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01"></a><h4 id="LNPCC-GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01" class="sect4"><span class="enumeration_section">14.5.5 </span>Use of PREPARE
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01__GUID-20B0CEC0-82A1-44B3-8A7C-E54716C8B4F8">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The PREPARE statement used in this method is the same as the PREPARE statement used in the other dynamic SQL methods. An Oracle extension allows a quoted string for the SQL statement, as well as a variable. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01__GUID-5AB525B0-98F4-44C6-9A0A-FFC69EBBF92E">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE <span class="italic">statement_id</span> FROM :<span class="italic">sql_statement </span>;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01__GUID-918F1F74-EEE2-4D45-9E42-52393B76D2EC">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>statement_id</p>
                        <p>This must not be declared; it is a undeclared SQL identifier.</p>
                        <p>sql_statement</p>
                        <p>A character string (a constant or a variable) holding the embedded SQL statement.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AC47FC84-157A-4E2A-AD7C-E1DA65958E01__GUID-F1DC47CE-DEFE-420D-AE40-7F23A6EEEA52">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">char* statement = "SELECT ENAME FROM emp WHERE deptno = :d" ;
EXEC SQL PREPARE S1 FROM :statement ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4080"></a><a id="LNPCC4081"></a><a id="LNPCC4082"></a><a id="LNPCC4083"></a><a id="LNPCC4084"></a><a id="LNPCC4079"></a><div class="props_rev_3"><a id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A" name="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A"></a><h4 id="LNPCC-GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A" class="sect4"><span class="enumeration_section">14.5.6 </span>DESCRIBE INPUT
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A__GUID-1FC9AFB4-F943-4B23-B924-9422B76158D1">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This statement returns information about the bind variables.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A__GUID-14F4FB96-B076-45BD-B723-C847132A7DA8">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DESCRIBE INPUT <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR 
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>} ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A__GUID-F42E02DB-E4D9-43F6-B7B9-2159A4576815">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>statement_id</p>
                        <p>The same as used in PREPARE and DESCRIBE OUTPUT. This must not be declared; it is an undeclared SQL identifier.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p></p>
                        <p>desc_nam</p>
                        <p>The descriptor name.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A__GUID-BE30D3B9-5144-4D56-BE1F-9C1F89995512">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>DESCRIBE INPUT only sets COUNT and NAME items. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-82AB7A8F-4CD5-4A2A-BE12-91CCEB4F3A4A__GUID-7E6A8EB8-C0FC-4746-A4D3-21CB50741A18">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DESCRIBE INPUT S1 USING SQL DESCRIPTOR GLOBAL :binddes ;
EXEC SQL DESCRIBE INPUT S2 USING DESCRIPTOR 'input' ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4086"></a><a id="LNPCC4087"></a><a id="LNPCC4088"></a><a id="LNPCC4089"></a><a id="LNPCC4085"></a><div class="props_rev_3"><a id="GUID-92918804-0091-413F-BD86-5F5274891445" name="GUID-92918804-0091-413F-BD86-5F5274891445"></a><h4 id="LNPCC-GUID-92918804-0091-413F-BD86-5F5274891445" class="sect4"><span class="enumeration_section">14.5.7 </span>DESCRIBE OUTPUT
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-92918804-0091-413F-BD86-5F5274891445__GUID-58074930-3FAA-4D51-97E7-DD8A55FF5017">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use this statement to obtain information about the output columns in a PREPAREd statement. The ANSI syntax differs from the older Oracle syntax. The information which is stored in the SQL descriptor area is the number of values returned and associated information such as type, length, and name.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-92918804-0091-413F-BD86-5F5274891445__GUID-7B8F560E-55DA-4E10-B02C-260B5E89C3BD">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DESCRIBE [OUTPUT] <span class="italic">statement_id</span> USING [SQL] DESCRIPTOR
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}<span class="italic"> ;</span></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-92918804-0091-413F-BD86-5F5274891445__GUID-F3F8D6C8-ABE0-4E4E-A51B-26FE87966BEB">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>statement_id</p>
                        <p>The same as used in PREPARE. This must not be declared; it is an undeclared SQL identifier.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>The descriptor name. </p>
                        <p>OUTPUT is the default and can be omitted.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-92918804-0091-413F-BD86-5F5274891445__GUID-B610E242-E325-461E-9EEB-EA70F2449C1E">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">char* desname = "SELDES" ;
EXEC SQL DESCRIBE S1 USING SQL DESCRIPTOR 'SELDES' ; /* Or, */
EXEC SQL DESCRIBE OUTPUT S1 USING DESCRIPTOR :desname ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4091"></a><a id="LNPCC4092"></a><a id="LNPCC4093"></a><a id="LNPCC4094"></a><a id="LNPCC4095"></a><a id="LNPCC4090"></a><div class="props_rev_3"><a id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28" name="GUID-00B73490-5667-4D86-A0D8-1792BF794A28"></a><h4 id="LNPCC-GUID-00B73490-5667-4D86-A0D8-1792BF794A28" class="sect4"><span class="enumeration_section">14.5.8 </span>EXECUTE
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28__GUID-7161DF1F-E247-433A-9E18-3C2CB3AA3D29">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>EXECUTE matches input and output variables in a prepared SQL statement and then executes the statement. This ANSI version of EXECUTE differs from the older EXECUTE statement by allowing two descriptors in one statement to support DML returning clause.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28__GUID-8A3A32F3-9E8D-4E25-B16B-5BEA077DF2E2">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR :<span class="italic">array_size</span>] EXECUTE <span class="italic">statement_id</span> 
    [USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}] 
        [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam </span>|<span class="italic"> string_literal</span>}] ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28__GUID-CFB5BD5D-3ED1-4D39-AA11-4A3873DFD705">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>The number of rows the statement will process.</p>
                        <p>statement_id</p>
                        <p>The same as used in PREPARE. This must not be declared; it is an undeclared SQL identifier. It can be a literal.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>The descriptor name.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28__GUID-8E6162A4-5D34-4A4B-AEB2-46FDAC7B64CC">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The INTO clause implements the DML returning clause for INSERT, UPDATE and DELETE. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-00B73490-5667-4D86-A0D8-1792BF794A28__GUID-7CB58661-D7B6-40DA-9AF4-824A81C4BBED">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE S1 USING SQL DESCRIPTOR GLOBAL :binddes ;

EXEC SQL EXECUTE S2 USING DESCRIPTOR :bv1 INTO DESCRIPTOR 'SELDES' ;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D">The DML Returning Clause</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4097"></a><a id="LNPCC4098"></a><a id="LNPCC4099"></a><a id="LNPCC4100"></a><a id="LNPCC4096"></a><div class="props_rev_3"><a id="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D" name="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D"></a><h4 id="LNPCC-GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D" class="sect4"><span class="enumeration_section">14.5.9 </span>Use of EXECUTE IMMEDIATE
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D__GUID-2310C1A0-ADF0-4917-9DA6-330E230D41C8">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Executes a literal or host variable character string containing the SQL statement.The ANSI SQL form of this statement is the same as in the older Oracle dynamic SQL:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D__GUID-91DCB6F5-5CC3-46EF-AF6E-96017E842390">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE {:<span class="italic">sql_statement </span>| <span class="italic">string_literal</span>}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D__GUID-E22DE205-28F3-49D2-929D-F45CEB33E44B">Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>sql_statement</p>
                        <p>The SQL statement or PL/SQL block in a character string.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CC11EA53-B423-478F-A62F-F5639AC8F17D__GUID-77B2A51B-0579-4826-97F0-6E4D950414F0">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE :statement ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4102"></a><a id="LNPCC4103"></a><a id="LNPCC4104"></a><a id="LNPCC4105"></a><a id="LNPCC4101"></a><div class="props_rev_3"><a id="GUID-6B921727-7A70-4280-892B-64444691D28A" name="GUID-6B921727-7A70-4280-892B-64444691D28A"></a><h4 id="LNPCC-GUID-6B921727-7A70-4280-892B-64444691D28A" class="sect4"><span class="enumeration_section">14.5.10 </span>Use of DYNAMIC DECLARE CURSOR
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-6B921727-7A70-4280-892B-64444691D28A__GUID-88BDCAF9-45B6-486A-BC0E-5C01053D0527">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Declares a cursor that is associated with a statement which is a query. This is a form of the generic Declare Cursor statement.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6B921727-7A70-4280-892B-64444691D28A__GUID-9A55CED1-8E8F-4580-B4E4-16CBF36C79EF">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE <span class="italic">cursor_name</span> CURSOR FOR <span class="italic">statement_id;</span></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6B921727-7A70-4280-892B-64444691D28A__GUID-30F69975-AF0F-4EE5-9138-0BF551F8EEF2">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>cursor_name</p>
                        <p>A cursor variable (a SQL identifier, not a host variable).</p>
                        <p>statement_id</p>
                        <p>An undeclared SQL identifier.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6B921727-7A70-4280-892B-64444691D28A__GUID-749F6525-580A-4DC8-A576-93E61E8A7768">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE C1 CURSOR FOR S1 ; </pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4107"></a><a id="LNPCC4108"></a><a id="LNPCC4109"></a><a id="LNPCC4110"></a><a id="LNPCC4111"></a><a id="LNPCC4106"></a><div class="props_rev_3"><a id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1" name="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1"></a><h4 id="LNPCC-GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1" class="sect4"><span class="enumeration_section">14.5.11 </span>OPEN Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1__GUID-000A43F0-8148-427F-BF73-A4088D293BA3">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The OPEN statement associates input parameters with a cursor and then opens the cursor. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1__GUID-20176522-F128-4564-AFDE-AF430CE9F3EA">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR :<span class="italic">array_size</span>] OPEN <span class="italic">dyn_cursor</span> 
    [[USING [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam1 </span>|<span class="italic"> string_literal</span>}]
    [INTO [SQL] DESCRIPTOR [GLOBAL | LOCAL] {<span class="italic">:desc_nam2 </span>|<span class="italic"> string_literal</span>}]] ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1__GUID-FDD9127E-A2A8-430E-9E81-52B1B01ED3BF">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>This limit is less than or equal to number specified when the descriptor was allocated.</p>
                        <p>dyn_cursor</p>
                        <p>The cursor variable.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>The descriptor name.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1__GUID-FA348FC3-04B0-4254-B510-D0B2C65D78E8">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If the prepared statement associated with the cursor contains colons or question marks, a USING clause must be specified, or an error results at runtime. The DML returning clause is supported. </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B721BCBF-F624-419D-B9F6-84B9244A39A1__GUID-C1379A4F-BEF3-4CA3-BCE0-F7DB7E06DF29">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN C1 USING SQL DESCRIPTOR :binddes ;

EXEC SQL FOR :limit OPEN C2 USING DESCRIPTOR :b1, :b2 
   INTO SQL DESCRIPTOR :seldes ;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D">The DML Returning Clause</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4113"></a><a id="LNPCC4114"></a><a id="LNPCC4115"></a><a id="LNPCC4116"></a><a id="LNPCC4117"></a><a id="LNPCC4112"></a><div class="props_rev_3"><a id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC" name="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC"></a><h4 id="LNPCC-GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC" class="sect4"><span class="enumeration_section">14.5.12 </span>FETCH
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC__GUID-3AC46534-0911-44D4-8C3D-F0A0B8871C49">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Fetches a row for a cursor declared with a dynamic DECLARE statement.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC__GUID-7F4864AE-A907-47A7-BEAC-7DE0EA58F21D">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [FOR :<span class="italic">array_size</span>] FETCH <span class="italic">cursor</span> INTO [SQL] DESCRIPTOR 
   [GLOBAL | LOCAL] {<span class="italic">:desc_nam | string_literal</span>} ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC__GUID-F38CCA1C-C0DB-4F76-B8F8-4BA516AAEE8F">Variables</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>array_size</p>
                        <p>The number of rows the statement will process.</p>
                        <p>cursor</p>
                        <p>The dynamic cursor that was previously declared.</p>
                        <p>GLOBAL | LOCAL</p>
                        <p>The optional scope clause defaults to LOCAL if not entered. A local descriptor can be accessed only in the file in which it is allocated. A global descriptor can be used in any module in the compilation unit.</p>
                        <p>desc_nam</p>
                        <p>Descriptor name.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC__GUID-64E74F7A-43F6-4847-8547-FD313C44C1A9">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The optional <code class="codeph">array_size </code>in the FOR clause must be less than or equal to the number specified in the ALLOCATE DESCRIPTOR statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2B6A37AD-8114-4D1A-BF82-83A3D43EB3FC__GUID-83BB09CC-564B-4522-AE33-E1D8A983F07D">Examples</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH FROM C1 INTO DESCRIPTOR 'SELDES' ;

EXEC SQL FOR :arsz FETCH C2 INTO DESCRIPTOR :desc ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4119"></a><a id="LNPCC4120"></a><a id="LNPCC4121"></a><a id="LNPCC4122"></a><a id="LNPCC4118"></a><div class="props_rev_3"><a id="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F" name="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F"></a><h4 id="LNPCC-GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F" class="sect4"><span class="enumeration_section">14.5.13 </span>CLOSE a Dynamic Cursor
                  </h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F__GUID-22F5F2FD-0821-449B-B614-1463E7E0CCE8">Purpose</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Closes a dynamic cursor. Syntax has not changed from the older Oracle Method 4:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F__GUID-3F20F508-E5BA-4787-AFBB-0BBE1767985E">Syntax</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE <span class="italic">cursor</span> ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F__GUID-DC8AAF89-F203-4992-AC0E-66292A4A27C7">Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>cursor</p>
                        <p>The dynamic cursor that was previously declared.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-09ABA189-63C4-4A7C-8179-8B4A5698BC5F__GUID-1F1916A2-709F-4AD4-8DC7-DF164296BE8B">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE C1 ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4123"></a><div class="props_rev_3"><a id="GUID-71C2F06E-CAFD-4E7B-AFF3-CBC6451D882A" name="GUID-71C2F06E-CAFD-4E7B-AFF3-CBC6451D882A"></a><h4 id="LNPCC-GUID-71C2F06E-CAFD-4E7B-AFF3-CBC6451D882A" class="sect4"><span class="enumeration_section">14.5.14 </span>Differences From Oracle Dynamic Method 4
                  </h4>
                  <div>
                     <p>The ANSI dynamic SQL interface supports all the datatypes supported by the Oracle dynamic Method 4, with these additions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>All datatypes, including object types, result sets, and LOB types are supported by ANSI Dynamic SQL.</p>
                        </li>
                        <li>
                           <p>The ANSI mode uses an internal <span class="italic">SQL descriptor area</span> which is an expansion of the external SQLDA used in Oracle older dynamic Method 4 to store its input and output information.
                           </p>
                        </li>
                        <li>
                           <p>New embedded SQL statements are introduced: ALLOCATE DESCRIPTOR, DEALLOCATE DESCRIPTOR, DESCRIBE, GET DESCRIPTOR, and SET DESCRIPTOR.</p>
                        </li>
                        <li>
                           <p>The DESCRIBE statement does not return the names of indicator variables in ANSI Dynamic SQL.</p>
                        </li>
                        <li>
                           <p>ANSI Dynamic SQL does not allow you to specify the maximum size of the returned column name or expression. The default size is set at 128.</p>
                        </li>
                        <li>
                           <p>The descriptor name must be either an identifier in single-quotes or a host variable preceded by a colon.</p>
                        </li>
                        <li>
                           <p>For output, the optional SELECT LIST FOR clause in the DESCRIBE is replaced by the optional keyword OUTPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
                        </li>
                        <li>
                           <p>For input, the optional BIND VARIABLES FOR clause of the DESCRIBE can be replaced by the keyword INPUT. The INTO clause is replaced by the USING DESCRIPTOR clause, which can contain the optional keyword SQL.</p>
                        </li>
                        <li>
                           <p>The optional keyword SQL can come before the keyword DESCRIPTOR in the USING clause of the EXECUTE, FETCH and OPEN statements.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4124"></a><div class="props_rev_3"><a id="GUID-2B1BBBD2-4E13-422C-ACF1-625727D1E747" name="GUID-2B1BBBD2-4E13-422C-ACF1-625727D1E747"></a><h4 id="LNPCC-GUID-2B1BBBD2-4E13-422C-ACF1-625727D1E747" class="sect4"><span class="enumeration_section">14.5.15 </span>Restrictions (ANSI Dynamic SQL)
                  </h4>
                  <div>
                     <p>Restrictions in effect on ANSI dynamic SQL are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You cannot mix ANSI and Oracle dynamic SQL methods in the same module.</p>
                        </li>
                        <li>
                           <p>The precompiler option DYNAMIC must be set to ANSI. The precompiler option TYPE_CODE can be set to ANSI only if DYNAMIC is set to ANSI.</p>
                        </li>
                        <li>
                           <p>The SET statement supports only host variables as item names.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC4125"></a><div class="props_rev_3"><a id="GUID-F216E6D1-16BA-400A-8C26-75AC9398264A" name="GUID-F216E6D1-16BA-400A-8C26-75AC9398264A"></a><h3 id="LNPCC-GUID-F216E6D1-16BA-400A-8C26-75AC9398264A" class="sect3"><span class="enumeration_section">14.6 </span>Example Programs
               </h3>
               <div>
                  <p>The following two programs are in the demo directory.</p>
               </div><a id="LNPCC4126"></a><div class="props_rev_3"><a id="GUID-9E71C9FC-CBE5-4D50-8977-4B73C12521FF" name="GUID-9E71C9FC-CBE5-4D50-8977-4B73C12521FF"></a><h4 id="LNPCC-GUID-9E71C9FC-CBE5-4D50-8977-4B73C12521FF" class="sect4"><span class="enumeration_section">14.6.1 </span>ansidyn1.pc
                  </h4>
                  <div>
                     <div class="section">
                        <p>This program demonstrates using ANSI Dynamic SQL to process SQL statements which are not known until runtime. It is intended to demonstrate the simplest (though not the most efficient) approach to using ANSI Dynamic SQL. It uses ANSI compatible value semantics and ANSI type codes. ANSI SQLSTATE is used for error numbers. Descriptor names are literals. All input and output is through ANSI varying character type.</p>
                        <p>The program connects you to ORACLE using your username and password, then prompts you for a SQL statement. Enter legal SQL or PL/SQL statements using regular, not embedded, SQL syntax and terminate each statement with a semicolon. Your statement will be processed. If it is a query, the fetched rows are displayed.   </p>
                        <p>You can enter multiline statements. The limit is 1023 characters. There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255. This program processes up to 40 bind variables and 40 select-list items. DML returning clauses and user defined types are not supported with value semantics.</p>
                        <p>Precompile the program with mode = ansi, for example:</p><pre class="oac_no_warn" dir="ltr">proc mode=ansi ansidyn1
</pre><p>Using <code class="codeph">mode=ansi</code> will set dynamic and <code class="codeph">type_code</code> to ansi.
                        </p><pre class="oac_no_warn" dir="ltr">/*******************************************************************
ANSI Dynamic Demo 1:  ANSI Dynamic SQL with value semantics,
                                   literal descriptor names
                                   and ANSI type codes

This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It is intended to
demonstrate the simplest (though not the most efficient) approach
to using ANSI Dynamic SQL.  It uses ANSI compatible value semantics
and ANSI type codes. ANSI Sqlstate is used for error numbers. 
Descriptor names are literals. All input and output is through ANSI the
varying character type.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statements using regular, not embedded, SQL syntax and terminate each 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed.  

You can enter multiline statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.
DML returning statments and user defined types are not supported with 
value semantics.

Precompile the program with mode=ansi, for example:
 
proc mode=ansi ansidyn1

Using mode=ansi will set dynamic and type_code to ansi.

*******************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;

#define MAX_OCCURENCES 40
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN   31

#ifndef NULL
#define NULL  0
#endif


/* Prototypes */
#if defined(__STDC__)
  void sql_error(void);
  int oracle_connect(void);
  int get_dyn_statement(void);
  int process_input(void);
  int process_output(void);
  void help(void);
#else
  void sql_error(/*_ void _*/);
  int oracle_connect(/*_ void _*/);
  int get_dyn_statement(/* void _*/);
  int process_input(/*_ void _*/);
  int process_output(/*_ void _*/);
  void help(/*_ void _*/);
#endif

EXEC SQL INCLUDE sqlca;

char SQLSTATE[6];

/* global variables */
EXEC SQL BEGIN DECLARE SECTION;
 char    dyn_statement[1024];
 char SQLSTATE[6];
EXEC SQL END DECLARE SECTION;




/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

/* A global flag for the error routine. */
int parse_flag = 0;
/* A global flag to indicate statement is a select */
int select_found;   

void main()
{

    /* Connect to the database. */
    if (oracle_connect() != 0)
        exit(1);

    EXEC SQL WHENEVER SQLERROR DO sql_error();

    /* Allocate the input and output descriptors. */
    EXEC SQL ALLOCATE DESCRIPTOR 'input_descriptor';
    EXEC SQL ALLOCATE DESCRIPTOR 'output_descriptor';

    /* Process SQL statements. */
    for (;;) 
    {
        (void) setjmp(jmp_continue);

        /* Get the statement.  Break on "exit". */
        if (get_dyn_statement() != 0)
            break;

        /* Prepare the statement and declare a cursor. */
        parse_flag = 1;     /* Set a flag for sql_error(). */
        EXEC SQL PREPARE S FROM :dyn_statement;
        parse_flag = 0;     /* Unset the flag. */

        EXEC SQL DECLARE C CURSOR FOR S;

        /* Call the function that processes the input. */
        if (process_input())
            exit(1);
 
        /* Open the cursor and execute the statement. */
        EXEC SQL OPEN C USING DESCRIPTOR 'input_descriptor';

        /* Call the function that processes the output. */
        if (process_output())
            exit(1);

        /* Close the cursor. */
        EXEC SQL CLOSE C;

    }   /* end of for(;;) statement-processing loop */


    /* Deallocate the descriptors */
    EXEC SQL DEALLOCATE DESCRIPTOR 'input_descriptor';
    EXEC SQL DEALLOCATE DESCRIPTOR 'output_descriptor';

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL COMMIT WORK;
    puts("\nHave a good day!\n");

    EXEC SQL WHENEVER SQLERROR DO sql_error();
    return;
}



int get_dyn_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;

    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf("\nSQL&gt; ");
            dyn_statement[0] = '\0';
            select_found = 0;
        }
        
        fgets(linebuf, sizeof linebuf, stdin);

        cp = strrchr(linebuf, '\n');
        if (cp &amp;&amp; cp != linebuf)
            *cp = ' ';
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, "SELECT", 6) == 0) ||
            (strncmp(linebuf, "select", 6) == 0))
        {
            select_found=1;;
        }

        if ((strncmp(linebuf, "EXIT", 4) == 0) ||
            (strncmp(linebuf, "exit", 4) == 0))
        {
            return -1;
        }

        else if (linebuf[0] == '?' ||
            (strncmp(linebuf, "HELP", 4) == 0) ||
            (strncmp(linebuf, "help", 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, "BEGIN") ||
            (strstr(linebuf, "begin")))
        {
            plsql = 1;
        }

        strcat(dyn_statement, linebuf);

        if ((plsql &amp;&amp; (cp = strrchr(dyn_statement, '/'))) ||
            (!plsql &amp;&amp; (cp = strrchr(dyn_statement, ';'))))
        {
            *cp = '\0';
            break;
        }
        else
        {
            iter++;
            printf("%3d  ", iter);
        }
    }
    return 0;
}


int process_input()
{
    int i;
    EXEC SQL BEGIN DECLARE SECTION;
      char name[31];
      int  input_count, input_len, occurs, ANSI_varchar_type;
      char input_buf[MAX_VAR_LEN];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR 'input_descriptor';
    EXEC SQL GET DESCRIPTOR 'input_descriptor' :input_count = COUNT; 
       
    ANSI_varchar_type=12;
    for (i=0; i &lt; input_count; i++)
    {
        occurs = i +1;                       /* occurence is 1 based */
        EXEC SQL GET DESCRIPTOR 'input_descriptor' 
                 VALUE :occurs :name = NAME;
        printf ("\nEnter value for input variable %*.*s:  ", 10,31, name);
        fgets(input_buf, sizeof(input_buf), stdin);
        input_len = strlen(input_buf) - 1;  /* get rid of new line */
        input_buf[input_len] = '\0';        /* null terminate */
        EXEC SQL SET DESCRIPTOR 'input_descriptor'
                 VALUE :occurs TYPE = :ANSI_varchar_type, 
                               LENGTH = :input_len,
                               DATA = :input_buf;
    }
    return(sqlca.sqlcode);
}


int process_output()
{
   int i, j;
   EXEC SQL BEGIN DECLARE SECTION;
     int output_count, occurs, type, len, col_len;
     short indi;
     char data[MAX_VAR_LEN], name[MAX_NAME_LEN];
   EXEC SQL END DECLARE SECTION;
   if (!select_found)
       return(0);   

   EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR 'output_descriptor';
   
   EXEC SQL GET DESCRIPTOR 'output_descriptor' :output_count = COUNT;


   printf ("\n");
   type = 12;            /* ANSI VARYING character type */
   len = MAX_VAR_LEN;    /* use the max allocated length */
   for (i = 0; i &lt; output_count; i++)
    {
        occurs = i + 1;
        EXEC SQL GET DESCRIPTOR 'output_descriptor' VALUE :occurs
                 :name = NAME;
        printf("%-*.*s ", 9,9, name);
        EXEC SQL SET DESCRIPTOR 'output_descriptor' VALUE :occurs 
                 TYPE = :type, LENGTH = :len;
    }   
    printf("\n");

    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;

    for (;;)
    {
        EXEC SQL FETCH C INTO DESCRIPTOR 'output_descriptor';
        for (i=0; i &lt; output_count; i++)
          {
            occurs = i + 1;
            EXEC SQL GET DESCRIPTOR 'output_descriptor' VALUE :occurs
                 :data = DATA, :indi = INDICATOR;
            if (indi == -1)       
              printf("%-*.*s ", 9,9, "NULL");
            else
              printf("%-*.*s ", 9,9, data);  /* simplified output formatting */ 
                          /* truncation will occur, but columns will line up */
          }                             
         printf ("\n");
    }
end_select_loop:
    return(0);
}



void help()
{
    puts("\n\nEnter a SQL statement or a PL/SQL block at the SQL&gt; prompt.");
    puts("Statements can be continued over several lines, except");
    puts("within string literals.");
    puts("Terminate a SQL statement with a semicolon.");
    puts("Terminate a PL/SQL block (which can contain embedded semicolons)");
    puts("with a slash (/).");
    puts("Typing \"exit\" (no semicolon needed) exits the program.");
    puts("You typed \"?\" or \"help\" to get this message.\n\n");
}


void sql_error()
{
    /* ORACLE error handler */
    printf("\n\nANSI sqlstate: %s: ", SQLSTATE);
    printf ("\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
    if (parse_flag)
        printf
        ("Parse error at character offset %d in SQL statement.\n",
           sqlca.sqlerrd[4]);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    longjmp(jmp_continue, 1);
}


int oracle_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  username[128];
        VARCHAR  password[32];
    EXEC SQL END DECLARE SECTION;

    printf("\nusername: ");
    fgets((char *) username.arr, sizeof username.arr, stdin);
    username.arr[strlen((char *) username.arr)-1] = '\0';
    username.len = (unsigned short)strlen((char *) username.arr);

    printf("password: ");
    fgets((char *) password.arr, sizeof password.arr, stdin);
    password.arr[strlen((char *) password.arr) - 1] = '\0';
    password.len = (unsigned short)strlen((char *) password.arr);


    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    printf("\nConnected to ORACLE as user %s.\n", username.arr);

    return 0;

connect_error:
    fprintf(stderr, "Cannot connect to ORACLE as user %s\n", username.arr);
    return -1;
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4127"></a><div class="props_rev_3"><a id="GUID-60184CBB-D503-4E9C-8ECF-A5FBEE320D40" name="GUID-60184CBB-D503-4E9C-8ECF-A5FBEE320D40"></a><h4 id="LNPCC-GUID-60184CBB-D503-4E9C-8ECF-A5FBEE320D40" class="sect4"><span class="enumeration_section">14.6.2 </span>ansidyn2.pc
                  </h4>
                  <div>
                     <div class="section">
                        <p>This program demonstrates using ANSI Dynamic SQL to process SQL statements which are not known until runtime. It uses the Oracle extensions for batch processing and reference semantics.</p>
                        <p>The program connects you to ORACLE using your username and password, then prompts you for a SQL statement. Enter legal SQL or PL/SQL statement using interactive, not embedded, SQL syntax, terminating the statement with a semicolon. Your statement will be processed. If it is a query, the fetched rows are displayed. </p>
                        <p>You can enter multiline statements. The limit is 1023 characters. There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255. This program processes up to 40 bind variables and 40 select-list items.</p>
                        <p>Precompile the program with <code class="codeph">dynamic = ansi</code>, for example:
                        </p><pre class="oac_no_warn" dir="ltr">proc dynamic=ansi ansidyn2

/*******************************************************************
ANSI Dynamic Demo 2:  ANSI Dynamic SQL with reference semantics,
                           batch processing and global descriptor
                           names in host variables
                           
This program demonstates using ANSI Dynamic SQL to process SQL
statements which are not known until runtime.  It uses the Oracle
extensions for batch processing and reference semantics.

The program connects you to ORACLE using your username and password,
then prompts you for a SQL statement.  Enter legal SQL or PL/SQL 
statement using interactive, not embedded, SQL syntax, terminating the 
statement with a seimcolon.  Your statement will be processed.  If it
is a query, the fetched rows are displayed. 

If your statement has input bind variables (other than in a where clause),
the program will ask for an input array size and then allow you to enter 
that number of input values. If your statment has output, the program will
ask you for an output array size and will do array fetchng using that value.
It will also output the rows fetched in one batch together, so using a small
value for the output array size will improve the look of the output.  
For example, connected as scott/tiger, try select empno, ename from emp
with an output array size of 4;

You can enter multiline statements.  The limit is 1023 characters.
There is a limit on the size of the variables, MAX_VAR_LEN, defined as 255.
This program processes up to 40 bind variables and 40 select-list items.

Precompile with program with dynamic=ansi, for example:
 
proc dynamic=ansi ansidyn2

*******************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlcpr.h&gt;


#define MAX_OCCURENCES  40
#define MAX_ARRSZ      100
#define MAX_VAR_LEN    255
#define MAX_NAME_LEN    31

#ifndef NULL
#define NULL  0
#endif


/* Prototypes */
#if defined(__STDC__)
  void sql_error(void);
  int oracle_connect(void);
  int get_dyn_statement(void);
  int process_input(void);
  int process_output(void);
  void rows_processed(void);
  void help(void);
#else
  void sql_error(/*_ void _*/);
  int oracle_connect(/*_ void _*/);
  int get_dyn_statement(/* void _*/);
  int process_input(/*_ void _*/);
  int process_output(/*_ void _*/);
  void rows_processed(/*_ void _*/);
  void help(/*_ void _*/);
#endif

EXEC SQL INCLUDE sqlca;

/* global variables */
char    dyn_statement[1024];                      /* statement variable     */
EXEC SQL VAR dyn_statement IS STRING(1024);

char  indesc[]="input_descriptor";                /* descriptor names       */
char outdesc[]="output_descriptor";
char   input[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN +1 ],    /* data areas */
      output[MAX_OCCURENCES][MAX_ARRSZ][MAX_VAR_LEN + 1];

short outindi[MAX_OCCURENCES][MAX_ARRSZ];        /* output indicators      */
short *iptr;

int   in_array_size;     /* size of input batch, that is, number of rows */
int   out_array_size;    /* size of input batch, that is, number of rows */
int   max_array_size=MAX_ARRSZ;   /* maximum arrays size used for allocates */

char *dml_commands[] = {"SELECT", "select", "INSERT", "insert",
                        "UPDATE", "update", "DELETE", "delete"};

int select_found, cursor_open = 0;

/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

/* A global flag for the error routine. */
int parse_flag = 0;

void main()
{

    /* Connect to the database. */
    if (oracle_connect() != 0)
        exit(1);

    EXEC SQL WHENEVER SQLERROR DO sql_error();

    /* Allocate the input and output descriptors. */
    EXEC SQL FOR :max_array_size
             ALLOCATE DESCRIPTOR GLOBAL :indesc;
    EXEC SQL FOR :max_array_size
             ALLOCATE DESCRIPTOR GLOBAL :outdesc;

    /* Process SQL statements. */
    for (;;) 
    {
        (void) setjmp(jmp_continue);

        /* Get the statement.  Break on "exit". */
        if (get_dyn_statement() != 0)
            break;

        /* Prepare the statement and declare a cursor. */
        parse_flag = 1;     /* Set a flag for sql_error(). */
        EXEC SQL PREPARE S FROM :dyn_statement;
        parse_flag = 0;     /* Unset the flag. */

        EXEC SQL DECLARE C CURSOR FOR S;

        /* Call the function that processes the input. */
        if (process_input())
            exit(1);

        /* Open the cursor and execute the statement. */
        EXEC SQL FOR :in_array_size
            OPEN C USING DESCRIPTOR GLOBAL :indesc;
        cursor_open = 1;
 
        /* Call the function that processes the output. */
        if (process_output())
            exit(1);

        /* Tell user how many rows were processed. */
        rows_processed();

    }   /* end of for(;;) statement-processing loop */

 
    /* Close the cursor. */
    if (cursor_open)
      EXEC SQL CLOSE C;

    /* Deallocate the descriptors */
    EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :indesc;
    EXEC SQL DEALLOCATE DESCRIPTOR GLOBAL :outdesc;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL COMMIT WORK RELEASE;
    puts("\nHave a good day!\n");

    EXEC SQL WHENEVER SQLERROR DO sql_error();
    return;
}



int get_dyn_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;

    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf("\nSQL&gt; ");
            dyn_statement[0] = '\0';
            select_found = 0;
        }
        
        fgets(linebuf, sizeof linebuf, stdin);

        cp = strrchr(linebuf, '\n');
        if (cp &amp;&amp; cp != linebuf)
            *cp = ' ';
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, "SELECT", 6) == 0) ||
            (strncmp(linebuf, "select", 6) == 0))
        {
            select_found=1;;
        }

        if ((strncmp(linebuf, "EXIT", 4) == 0) ||
            (strncmp(linebuf, "exit", 4) == 0))
        {
            return -1;
        }

        else if (linebuf[0] == '?' ||
            (strncmp(linebuf, "HELP", 4) == 0) ||
            (strncmp(linebuf, "help", 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, "BEGIN") ||
            (strstr(linebuf, "begin")))
        {
            plsql = 1;
        }

        strcat(dyn_statement, linebuf);

        if ((plsql &amp;&amp; (cp = strrchr(dyn_statement, '/'))) ||
            (!plsql &amp;&amp; (cp = strrchr(dyn_statement, ';'))))
        {
            *cp = '\0';
            break;
        }
        else
        {
            iter++;
            printf("%3d  ", iter);
        }
    }
    return 0;
}


int process_input()
{
    int i, j;
    char name[31];
    int  input_count, input_len= MAX_VAR_LEN;
    int  occurs, string_type = 5;
    int  string_len;
    char arr_size[3];

    EXEC SQL DESCRIBE INPUT S USING DESCRIPTOR GLOBAL :indesc;
    EXEC SQL GET DESCRIPTOR GLOBAL :indesc :input_count = COUNT; 

    if (input_count &gt; 0 &amp;&amp; !select_found )
       {     /* get input array size */
          printf ("\nEnter value for input array size (max is %d) :  ", 
                           max_array_size);
        fgets(arr_size, 4, stdin);
        in_array_size = atoi(arr_size); 
       }
    else
       { 
         in_array_size = 1;
       }
    for (i=0; i &lt; input_count; i++)
    {
        occurs = i +1;                       /* occurence is 1 based */
        EXEC SQL GET DESCRIPTOR GLOBAL :indesc 
                 VALUE :occurs :name = NAME;

        for (j=0; j &lt; in_array_size; j++)
        {
          if (in_array_size == 1)
            printf ("\nEnter value for input variable %*.*s:  ",10,31, name);
          else 
            printf ("\nEnter %d%s value for input variable %*.*s:  ",
               j +1, ((j==0) ?  "st" :  (j==1) ? "nd" : (j==2) ? "rd" :"th"),
                      10,31, name);
          fgets(input[i][j], sizeof(input[i][j]), stdin);
          string_len = strlen(input[i][j]);
          input[i][j][string_len - 1 ] = '\0';   /* change \n to \0 */
        }
        EXEC SQL SET DESCRIPTOR GLOBAL :indesc
                 VALUE :occurs TYPE = :string_type, LENGTH = :input_len;
        EXEC SQL FOR :in_array_size
                 SET DESCRIPTOR GLOBAL :indesc
                     VALUE :occurs  REF DATA = :input[i];
    }

    return(sqlca.sqlcode);
}


int process_output()
{
   int i, j;
   int output_count, occurs;
   int type, output_len= MAX_VAR_LEN;
   char name[MAX_OCCURENCES][MAX_NAME_LEN];
   int rows_this_fetch=0, cumulative_rows=0;
   char arr_size[3];
   if (!select_found)
      return(0);   
   EXEC SQL DESCRIBE OUTPUT S USING DESCRIPTOR GLOBAL :outdesc;
   
   EXEC SQL GET DESCRIPTOR GLOBAL :outdesc :output_count = COUNT;
  
   if (output_count &gt; 0 )
      {
        printf ("\nEnter value for output array size (max is %d) :  ", 
                       max_array_size);
        fgets(arr_size, 4, stdin);
        out_array_size = atoi(arr_size); 
      }
   if (out_array_size &lt; 1)    /* must have at least one */
       out_array_size = 1;

   printf ("\n");
   
   for (i = 0; i &lt; output_count; i++)
   {
      occurs = i + 1;
      EXEC SQL GET DESCRIPTOR GLOBAL :outdesc VALUE :occurs
               :type = TYPE, :name[i] = NAME;
      occurs = i + 1;                         /* occurence is one based */
      type = 5;  /* force all data to be null terminated character */
      EXEC SQL SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
               TYPE = :type, LENGTH = :output_len;
   
      iptr = (short *)&amp;outindi[i]; /* no mult-dimension non-char host vars */
      EXEC SQL FOR :out_array_size
               SET DESCRIPTOR GLOBAL :outdesc VALUE :occurs 
               REF DATA = :output[i], REF INDICATOR = :iptr;
   }   
   
   
   
   EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;
   
   /* print the column headings */
   for (j=0; j &lt; out_array_size; j++)
      for (i=0; i &lt; output_count; i++)
         printf("%-*.*s ", 9,9, name[i]);
   printf("\n");
   
   /* FETCH each row selected and print the column values. */
   for (;;)
   {
      EXEC SQL FOR :out_array_size 
              FETCH C INTO DESCRIPTOR GLOBAL :outdesc;
      rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
      cumulative_rows = sqlca.sqlerrd[2];
      if (rows_this_fetch)
      for (j=0; j &lt; out_array_size &amp;&amp; j &lt; rows_this_fetch; j++)
      {           /* output by columns using simplified formatting */
         for (i=0; i &lt; output_count; i++)
           {                              
                if (outindi[i][j] == -1)       
                   printf("%-*.*s ", 9, 9, "NULL");
               else
                  printf("%-*.*s ", 9, 9, output[i][j]);  /* simplified */
                              /* output formatting may cause truncation */
                              /* but columns will line up */
           } 
      }
       printf ("\n");
   }

end_select_loop:
   /* print any unprinted rows */
   rows_this_fetch = sqlca.sqlerrd[2] - cumulative_rows;
   cumulative_rows = sqlca.sqlerrd[2];
   if (rows_this_fetch)
     for (j=0; j &lt; out_array_size &amp;&amp; j &lt; rows_this_fetch; j++)
       {           /* output by columns using simplified formatting */
         for (i=0; i &lt; output_count; i++)
           {                              
              if (outindi[i][j] == -1)       
                   printf("%-*.*s ",9, 9, "NULL");
               else
                  printf("%-*.*s ", 9, 9, output[i][j]); 
            } 
        }
   return(0);
}

void rows_processed()
{  
   int i;
   for (i = 0; i &lt; 8; i++)
     {
       if (strncmp(dyn_statement, dml_commands[i], 6) == 0)
         {
            printf("\n\n%d row%c processed.\n", sqlca.sqlerrd[2],
                       sqlca.sqlerrd[2] == 1 ? ' ' : 's');
            break;
         }
     }
   return;
}


void help()
{
    puts("\n\nEnter a SQL statement or a PL/SQL block at the SQL&gt; prompt.");
    puts("Statements can be continued over several lines, except");
    puts("within string literals.");
    puts("Terminate a SQL statement with a semicolon.");
    puts("Terminate a PL/SQL block (which can contain embedded semicolons)");
    puts("with a slash (/).");
    puts("Typing \"exit\" (no semicolon needed) exits the program.");
    puts("You typed \"?\" or \"help\" to get this message.\n\n");
}


void sql_error()
{
    /* ORACLE error handler */
    printf ("\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);
    if (parse_flag)
        printf
        ("Parse error at character offset %d in SQL statement.\n",
           sqlca.sqlerrd[4]);

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    longjmp(jmp_continue, 1);
}


int oracle_connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  username[128];
        VARCHAR  password[32];
    EXEC SQL END DECLARE SECTION;

    printf("\nusername: ");
    fgets((char *) username.arr, sizeof username.arr, stdin);
    username.arr[strlen((char *) username.arr)-1] = '\0';
    username.len = (unsigned short)strlen((char *) username.arr);

    printf("password: ");
    fgets((char *) password.arr, sizeof password.arr, stdin);
    password.arr[strlen((char *) password.arr) - 1] = '\0';
    password.len = (unsigned short)strlen((char *) password.arr);


    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    printf("\nConnected to ORACLE as user %s.\n", username.arr);

    return 0;

connect_error:
    fprintf(stderr, "Cannot connect to ORACLE as user %s\n", username.arr);
    return -1;
}

</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>