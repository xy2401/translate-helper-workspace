<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">
      <meta name="description" content="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">
      <title>Partition-Wise Operations</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="VLDB and Partitioning Guide">
      <meta property="og:description" content="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="VLDB and Partitioning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00">
      <meta name="dcterms.title" content="VLDB and Partitioning Guide">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96199-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="partition-pruning.html" title="Previous" type="text/html">
      <link rel="next" href="index-partitioning.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-pruning.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="index-partitioning.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB and Partitioning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-availability.html" property="item" typeof="WebPage"><span property="name">Partitioning for Availability, Manageability, and Performance</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Partition-Wise Operations</li>
            </ol>
            <a id="GUID-7C28CD29-5189-4A53-9691-380E13515015" name="GUID-7C28CD29-5189-4A53-9691-380E13515015"></a><a id="VLDBG00402"></a>
            
            <h2 id="VLDBG-GUID-7C28CD29-5189-4A53-9691-380E13515015" class="sect2">Partition-Wise Operations</h2>
         </header>
         <div class="ind">
            <div>
               <p>Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources. </p>
               <p>Partition-wise joins can reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. In Oracle Real Application Clusters (Oracle RAC) environments, partition-wise joins also avoid or at least limit the data traffic over the interconnect, which is the key to achieving good scalability for massive join operations. Parallel partition-wise joins are used commonly for processing large joins efficiently and fast. Partition-wise joins can be full or partial. Oracle Database decides which type of join to use.</p>
               <p>In addition to parallel partition-wise joins, queries using the <code class="codeph">SELECT</code> <code class="codeph">DISTINCT</code> clause and SQL window functions can perform parallel partition-wise operations.
               </p>
               <p>The following topics are discussed:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="partition-wise-joins.html#GUID-673EFAFE-6D0C-4323-A086-67385B4DCA76" title="A full partition-wise join divides a large join into smaller joins between a pair of partitions from the two joined tables.">Full Partition-Wise Joins</a></p>
                  </li>
                  <li>
                     <p><a href="partition-wise-joins.html#GUID-34563811-55B5-4ABF-8960-F225AB3CC240" title="With partial partition-wise joins, only one table must be partitioned on the join key.">Partial Partition-Wise Joins</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-7C28CD29-5189-4A53-9691-380E13515015__ORACLEDATABASEDATAWAREHOUSINGGUIDEF-FB66E477">
                  <p class="notep1">See Also:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" title="Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel.">Partition-Wise Joins in a Data Warehouse</a> for information about parallel partition-wise operations in a data warehouse environment
                        </p>
                     </li>
                     <li>
                        <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG-GUID-79C29A60-3477-448D-835D-2940D060D050" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for information about data warehousing and optimization techniques
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1241"></a><div class="props_rev_3"><a id="GUID-673EFAFE-6D0C-4323-A086-67385B4DCA76" name="GUID-673EFAFE-6D0C-4323-A086-67385B4DCA76"></a><h3 id="VLDBG-GUID-673EFAFE-6D0C-4323-A086-67385B4DCA76" class="sect3">Full Partition-Wise Joins</h3>
               <div>
                  <p>A full partition-wise join divides a large join into smaller joins between a pair of partitions from the two joined tables.</p>
                  <p>To use full partition-wise joins, you must equipartition both tables on their join keys, or use reference partitioning. </p>
                  <p>You can use various partitioning methods to equipartition both tables. These methods are described at a high level in the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17" title="You can query using a full partition-wise join.">Querying a Full Partition-Wise Join</a></p>
                     </li>
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73" title="A single-level to single-level full partition-wise join is the simplest method: two tables are both partitioned by the join column.">Full Partition-Wise Joins: Single-Level - Single-Level</a></p>
                     </li>
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC" title="A composite to single-level full partition-wise join is a variation of the single-level - single-level method.">Full Partition-Wise Joins: Composite - Single-Level</a></p>
                     </li>
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-508516A8-F72F-4F92-A377-6902F0EBBFDC" title="You can use composite to composite full partition-wise joins for additional flexibility.">Full Partition-Wise Joins: Composite - Composite</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14028"></a><div class="props_rev_3"><a id="GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17" name="GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17"></a><h4 id="VLDBG-GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17" class="sect4">Querying a Full Partition-Wise Join</h4>
                  <div>
                     <p>You can query using a full partition-wise join.</p>
                     <p>Consider a large join between a sales table and a customer table on the column <code class="codeph">cust_id</code>, as shown in <a href="partition-wise-joins.html#GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17__BABGCCHD">Example 3-4</a>. The query "find the records of all customers who bought more than 100 articles in Quarter 3 of 1999" is a typical example of a SQL statement performing such a join.
                     </p>
                     <p>Such a large join is typical in data warehousing environments. In this case, the entire customer table is joined with one quarter of the sales data. In large data warehouse applications, this might mean joining millions of rows. The join method to use in that case is obviously a hash join. You can reduce the processing time for this hash join even more if both tables are equipartitioned on the <code class="codeph">cust_id</code> column. This functionality enables a full partition-wise join.
                     </p>
                     <p>When you execute a full partition-wise join in parallel, the granule of parallelism is a partition. Consequently, the degree of parallelism is limited to the number of partitions. For example, you require at least 16 partitions to set the degree of parallelism of the query to 16.</p>
                     <div class="example" id="GUID-9575CBEC-9BC5-45E0-8F18-DE403AE1AA17__BABGCCHD">
                        <p class="titleinexample">Example 3-4 Querying with a full partition-wise join</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_last_name, COUNT(*)
  FROM sales s, customers c
  WHERE s.cust_id = c.cust_id AND 
        s.time_id BETWEEN TO_DATE('01-JUL-1999', 'DD-MON-YYYY') AND 
        (TO_DATE('01-OCT-1999', 'DD-MON-YYYY'))
  GROUP BY c.cust_last_name HAVING COUNT(*) &gt; 100;
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1243"></a><a id="VLDBG1242"></a><div class="props_rev_3"><a id="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73" name="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73"></a><h4 id="VLDBG-GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73" class="sect4">Full Partition-Wise Joins: Single-Level - Single-Level</h4>
                  <div>
                     <p>A single-level to single-level full partition-wise join is the simplest method: two tables are both partitioned by the join column.</p>
                     <p>In the example, the <code class="codeph">customers</code> and <code class="codeph">sales</code> tables are both partitioned on the <code class="codeph">cust_id</code> columns. This partitioning method enables full partition-wise joins when the tables are joined on <code class="codeph">cust_id</code>, both representing the same customer identification number. This scenario is available for range-range, list-list, and hash-hash partitioning. Interval-range and interval-interval full partition-wise joins are also supported and can be compared to range-range.
                     </p>
                     <p>In serial, this join is performed between pairs of matching hash partitions, one at a time. When one partition pair has been joined, the join of another partition pair begins. The join completes when all partition pairs have been processed. To ensure a good workload distribution, you should either have many more partitions than the requested degree of parallelism or use equisize partitions with as many partitions as the requested degree of parallelism. Using hash partitioning on a unique or almost-unique column, with the number of partitions equal to a power of 2, is a good way to create equisized partitions.</p>
                     <div class="infoboxnote" id="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73__GUID-7284F070-1DEB-403C-8FBA-FE68EBDAA2D6">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A pair of matching hash partitions is defined as one partition with the same partition number from each table. For example, with full partition-wise joins based on hash partitioning, the database joins partition 0 of <code class="codeph">sales</code> with partition 0 of <code class="codeph">customers</code>, partition 1 of <code class="codeph">sales</code> with partition 1 of <code class="codeph">customers</code>, and so on.
                              </p>
                           </li>
                           <li>
                              <p>Reference partitioning is an easy way to co-partition two tables so that the optimizer can always consider a full partition-wise join if the tables are joined in a statement.</p>
                           </li>
                        </ul>
                     </div>
                     <p>Parallel execution of a full partition-wise join is a straightforward parallelization of the serial execution. Instead of joining one partition pair at a time, partition pairs are joined in parallel by the query servers. <a href="partition-wise-joins.html#GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73__I1006910">Figure 3-1</a> illustrates the parallel execution of a full partition-wise join.
                     </p>
                     <div class="figure" id="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73__I1006910">
                        <p class="titleinfigure">Figure 3-1 Parallel Execution of a Full Partition-wise Join</p><img src="img/vldbg017.gif" width="490" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" longdesc="img_text/vldbg017.html"><br><a href="img_text/vldbg017.html">Description of "Figure 3-1 Parallel Execution of a Full Partition-wise Join"</a></div>
                     <!-- class="figure" -->
                     <p>The following example shows the execution plan for <code class="codeph">sales</code> and <code class="codeph">customers</code> co-partitioned by hash with the same number of partitions. The plan shows a full partition-wise join.
                     </p><pre class="oac_no_warn" dir="ltr">explain plan for SELECT c.cust_last_name, COUNT(*)
FROM sales s, customers c
WHERE s.cust_id = c.cust_id AND 
s.time_id BETWEEN TO_DATE('01-JUL-1999', 'DD-MON-YYYY') AND 
     (TO_DATE('01-OCT-1999', 'DD-MON-YYYY'))
GROUP BY c.cust_last_name HAVING COUNT(*) &gt; 100;

-------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name      | Rows  | Bytes | Pstart| Pstop|    TQ  |IN-OUT| PQ Distrib|
-------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |           |    46 |  1196 |       |      |        |      |           |
|   1 |  PX COORDINATOR              |           |       |       |       |      |        |      |           |
|   2 |   PX SEND QC (RANDOM)        | :TQ10001  |    46 |  1196 |       |      |  Q1,01 | P-&gt;S | QC (RAND) |
|*  3 |    FILTER                    |           |       |       |       |      |  Q1,01 | PCWC |           |
|   4 |     HASH GROUP BY            |           |    46 |  1196 |       |      |  Q1,01 | PCWP |           |
|   5 |      PX RECEIVE              |           |    46 |  1196 |       |      |  Q1,01 | PCWP |           |
|   6 |       PX SEND HASH           | :TQ10000  |    46 |  1196 |       |      |  Q1,00 | P-&gt;P | HASH      |
|   7 |        HASH GROUP BY         |           |    46 |  1196 |       |      |  Q1,00 | PCWP |           |
|   8 |         PX PARTITION HASH ALL|           | 59158 |  1502K|     1 |   16 |  Q1,00 | PCWC |           |
|*  9 |          HASH JOIN           |           | 59158 |  1502K|       |      |  Q1,00 | PCWP |           |
|  10 |           TABLE ACCESS FULL  | CUSTOMERS | 55500 |   704K|     1 |   16 |  Q1,00 | PCWP |           |
|* 11 |           TABLE ACCESS FULL  | SALES     | 59158 |   751K|     1 |   16 |  Q1,00 | PCWP |           |
-------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   9 - access("S"."CUST_ID"="C"."CUST_ID")
  11 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre><div class="infoboxnote" id="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73__GUID-6130D6F1-F8DA-4DD7-9887-5BD409C849C3">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">Cost (%CPU)</code> and <code class="codeph">Time</code> columns were removed from the plan table output in this example.
                        </p>
                     </div>
                     <p>In Oracle RAC environments running on massive parallel processing (MPP) platforms, placing partitions on nodes is critical to achieving good scalability. To avoid remote I/O, both matching partitions should have affinity to the same node. Partition pairs should be spread over all of the nodes to avoid bottlenecks and to use all CPU resources available on the system.</p>
                     <p>Nodes can host multiple pairs when there are more pairs than nodes. For example, with an 8-node system and 16 partition pairs, each node receives two pairs.</p>
                     <div class="infoboxnotealso" id="GUID-36B5A01D-849E-44A3-B6D7-2B82DD23DB73__GUID-680B2693-0F37-43AF-8C28-02FFD4AC15AA">
                        <p class="notep1">See Also:</p>
                        <p><a href="../racad/introduction-to-oracle-rac.html#RACAD1111" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for more information about data affinity
                        </p>
                     </div>
                  </div>
               </div><a id="VLDBG1245"></a><a id="VLDBG1244"></a><div class="props_rev_3"><a id="GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC" name="GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC"></a><h4 id="VLDBG-GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC" class="sect4">Full Partition-Wise Joins: Composite - Single-Level</h4>
                  <div>
                     <p>A composite to single-level full partition-wise join is a variation of the single-level - single-level method.</p>
                     <p>In this scenario, one table (typically the larger table) is composite partitioned on two dimensions, using the join columns as the subpartition key. In the example, the <code class="codeph">sales</code> table is a typical example of a table storing historical data. Using range partitioning is a logical initial partitioning method for a table storing historical information.
                     </p>
                     <p>For example, assume you want to partition the <code class="codeph">sales</code> table into eight partitions by range on the column <code class="codeph">time_id</code>. Also assume you have two years and that each partition represents a quarter. Instead of using range partitioning, you can use composite partitioning to enable a full partition-wise join while preserving the partitioning on <code class="codeph">time_id</code>. For example, partition the <code class="codeph">sales</code> table by range on <code class="codeph">time_id</code> and then subpartition each partition by hash on <code class="codeph">cust_id</code> using 16 subpartitions for each partition, for a total of 128 subpartitions. The <code class="codeph">customers</code> table can use hash partitioning with 16 partitions.
                     </p>
                     <p>When you use the method just described, a full partition-wise join works similarly to the one created by a single-level - single-level hash-hash method. The join is still divided into 16 smaller joins between hash partition pairs from both tables. The difference is that now each hash partition in the <code class="codeph">sales</code> table is composed of a set of 8 subpartitions, one from each range partition.
                     </p>
                     <p><a href="partition-wise-joins.html#GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__I1006952">Figure 3-2</a> illustrates how the hash partitions are formed in the <code class="codeph">sales</code> table. Each cell represents a subpartition. Each row corresponds to one range partition, for a total of 8 range partitions. Each range partition has 16 subpartitions. Each column corresponds to one hash partition for a total of 16 hash partitions; each hash partition has 8 subpartitions. Hash partitions can be defined only if all partitions have the same number of subpartitions, in this case, 16.
                     </p>
                     <p>Hash partitions are implicit in a composite table. However, Oracle does not record them in the data dictionary, and you cannot manipulate them with DDL commands as you can range or list partitions.</p>
                     <div class="figure" id="GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__I1006952">
                        <p class="titleinfigure">Figure 3-2 Range and Hash Partitions of a Composite Table</p><img src="img/vldbg010.gif" width="496" alt="Description of Figure 3-2 follows" title="Description of Figure 3-2 follows" longdesc="img_text/vldbg010.html"><br><a href="img_text/vldbg010.html">Description of "Figure 3-2 Range and Hash Partitions of a Composite Table"</a></div>
                     <!-- class="figure" -->
                     <p>The following example shows the execution plan for the full partition-wise join with the <code class="codeph">sales</code> table range partitioned by <code class="codeph">time_id</code>, and subpartitioned by hash on <code class="codeph">cust_id</code>.
                     </p><pre class="oac_no_warn" dir="ltr">----------------------------------------------------------------------------------------------
| Id  | Operation                            | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |           |       |       |      |            |
|   1 |  PX COORDINATOR                      |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)                | :TQ10001  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                            |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                    |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                      |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                   | :TQ10000  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                 |           |       |       | PCWP |            |
|   8 |         PX PARTITION HASH ALL        |           |     1 |    16 | PCWC |            |
|*  9 |          HASH JOIN                   |           |       |       | PCWP |            |
|  10 |           TABLE ACCESS FULL          | CUSTOMERS |     1 |    16 | PCWP |            |
|  11 |           PX PARTITION RANGE ITERATOR|           |     8 |     9 | PCWC |            |
|* 12 |            TABLE ACCESS FULL         | SALES     |   113 |   144 | PCWP |            |
----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   9 - access("S"."CUST_ID"="C"."CUST_ID")
  12 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre><div class="infoboxnote" id="GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__GUID-B1BC6179-2EE1-4578-9383-9FB681564254">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">Rows</code>, <code class="codeph">Cost (%CPU)</code>, <code class="codeph">Time</code>, and <code class="codeph">TQ</code> columns were removed from the plan table output in this example.
                        </p>
                     </div>
                     <p>Composite - single-level partitioning is effective because it enables you to combine pruning on one dimension with a full partition-wise join on another dimension. In the previous example query, pruning is achieved by scanning only the subpartitions corresponding to Q3 of 1999, in other words, row number 3 in <a href="partition-wise-joins.html#GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__I1006952">Figure 3-2</a>. Oracle then joins these subpartitions with the customer table, using a full partition-wise join.
                     </p>
                     <p>All characteristics of the single-level - single-level partition-wise join apply to the composite - single-level partition-wise join. In particular, for this example, these two points are common to both methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The degree of parallelism for this full partition-wise join cannot exceed 16. Even though the <code class="codeph">sales</code> table has 128 subpartitions, it has only 16 <span class="italic">hash</span> <span class="italic">partitions</span>.
                           </p>
                        </li>
                        <li>
                           <p>A partition is now a collection of subpartitions. For example, in <a href="partition-wise-joins.html#GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__I1006952">Figure 3-2</a>, store hash partition 9 of the <code class="codeph">sales</code> table shown by the eight circled subpartitions, on the same node as hash partition 9 of the <code class="codeph">customers</code> table. 
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1246"></a><div class="props_rev_3"><a id="GUID-508516A8-F72F-4F92-A377-6902F0EBBFDC" name="GUID-508516A8-F72F-4F92-A377-6902F0EBBFDC"></a><h4 id="VLDBG-GUID-508516A8-F72F-4F92-A377-6902F0EBBFDC" class="sect4">Full Partition-Wise Joins: Composite - Composite</h4>
                  <div>
                     <p>You can use composite to composite full partition-wise joins for additional flexibility.</p>
                     <p>If needed, you can also partition the <code class="codeph">customers</code> table by the composite method. For example, you partition it by range on a postal code column to enable pruning based on postal codes. You then subpartition it by hash on <code class="codeph">cust_id</code> using the same number of partitions (16) to enable a partition-wise join on the hash dimension.
                     </p>
                     <p>You can get full partition-wise joins on all combinations of partition and subpartition partitions: partition - partition, partition - subpartition, subpartition - partition, and subpartition - subpartition.</p>
                  </div>
               </div>
            </div><a id="VLDBG1247"></a><div class="props_rev_3"><a id="GUID-34563811-55B5-4ABF-8960-F225AB3CC240" name="GUID-34563811-55B5-4ABF-8960-F225AB3CC240"></a><h3 id="VLDBG-GUID-34563811-55B5-4ABF-8960-F225AB3CC240" class="sect3">Partial Partition-Wise Joins</h3>
               <div>
                  <p>With partial partition-wise joins, only one table must be partitioned on the join key.</p>
                  <p>Oracle Database can perform partial partition-wise joins only in parallel. Unlike full partition-wise joins, partial partition-wise joins require you to partition only one table on the join key, not both tables. The partitioned table is referred to as the reference table. The other table may or may not be partitioned. Partial partition-wise joins are more common than full partition-wise joins.</p>
                  <p>To execute a partial partition-wise join, the database dynamically repartitions the other table based on the partitioning of the reference table. After the other table is repartitioned, the execution is similar to a full partition-wise join.</p>
                  <p>The performance advantage that partial partition-wise joins have over joins in nonpartitioned tables is that the reference table is not moved during the join operation. Parallel joins between nonpartitioned tables require both input tables to be redistributed on the join key. This redistribution operation involves exchanging rows between parallel execution servers. This is a CPU-intensive operation that can lead to excessive interconnect traffic in Oracle RAC environments. Partitioning large tables on a join key, either a foreign or primary key, prevents this redistribution every time the table is joined on that key. Of course, if you choose a foreign key to partition the table, which is the most common scenario, then select a foreign key that is involved in many queries.</p>
                  <p>To illustrate partial partition-wise joins, consider the previous <code class="codeph">sales/customers</code> example. Assume that <code class="codeph">customers</code> is not partitioned or is partitioned on a column other than <code class="codeph">cust_id</code>. Because <code class="codeph">sales</code> is often joined with <code class="codeph">customers</code> on <code class="codeph">cust_id</code>, and because this join dominates our application workload, partition <code class="codeph">sales</code> on <code class="codeph">cust_id</code> to enable partial partition-wise joins every time <code class="codeph">customers</code> and <code class="codeph">sales</code> are joined. As with full partition-wise joins, you have several alternatives:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-8D44D783-651D-41BA-87B4-2021676C7F3F" title="A single-level partial partition-wise join is the simplest method to enable a partial partition-wise join.">Partial Partition-Wise Joins: Single-Level Partitioning</a></p>
                     </li>
                     <li>
                        <p><a href="partition-wise-joins.html#GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA" title="You can use composite partial partition-wise joins.">Partial Partition-Wise Joins: Composite</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1249"></a><a id="VLDBG1248"></a><div class="props_rev_3"><a id="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F" name="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F"></a><h4 id="VLDBG-GUID-8D44D783-651D-41BA-87B4-2021676C7F3F" class="sect4">Partial Partition-Wise Joins: Single-Level Partitioning</h4>
                  <div>
                     <p>A single-level partial partition-wise join is the simplest method to enable a partial partition-wise join.</p>
                     <p>For example, you can enable a single-level partial partition-wise join to partition <code class="codeph">sales</code> by hash on <code class="codeph">cust_id</code>. The number of partitions determines the maximum degree of parallelism, because the partition is the smallest granule of parallelism for partial partition-wise join operations.
                     </p>
                     <p>The parallel execution of a partial partition-wise join is illustrated in <a href="partition-wise-joins.html#GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__I1006993">Figure 3-3</a>, which assumes that both the degree of parallelism and the number of partitions of <code class="codeph">sales</code> are 16. The execution involves two sets of query servers: one set, labeled <span class="italic">set 1</span> in <a href="partition-wise-joins.html#GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__I1006993">Figure 3-3</a>, scans the <code class="codeph">customers</code> table in parallel. The granule of parallelism for the scan operation is a range of blocks.
                     </p>
                     <p>Rows from <code class="codeph">customers</code> that are selected by the first set, in this case all rows, are redistributed to the second set of query servers by hashing <code class="codeph">cust_id</code>. For example, all rows in <code class="codeph">customers</code> that could have matching rows in partition <code class="codeph">P1</code> of <code class="codeph">sales</code> are sent to query server 1 in the second set. Rows received by the second set of query servers are joined with the rows from the corresponding partitions in <code class="codeph">sales</code>. Query server number 1 in the second set joins all <code class="codeph">customers</code> rows that it receives with partition <code class="codeph">P1</code> of <code class="codeph">sales</code>.
                     </p>
                     <div class="figure" id="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__I1006993">
                        <p class="titleinfigure">Figure 3-3 Partial Partition-Wise Join</p><img src="img/vldbg011.gif" width="490" alt="Description of Figure 3-3 follows" title="Description of Figure 3-3 follows" longdesc="img_text/vldbg011.html"><br><a href="img_text/vldbg011.html">Description of "Figure 3-3 Partial Partition-Wise Join"</a></div>
                     <!-- class="figure" -->
                     <p>The example below shows the execution plan for the partial partition-wise join between <code class="codeph">sales</code> and <code class="codeph">customers</code>.
                     </p><pre class="oac_no_warn" dir="ltr">-----------------------------------------------------------------------------------------------
| Id  | Operation                             | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                      |           |       |       |      |            |
|   1 |  PX COORDINATOR                       |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)                 | :TQ10002  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                             |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                     |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                       |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                    | :TQ10001  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                  |           |       |       | PCWP |            |
|*  8 |         HASH JOIN                     |           |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE      | :BF0000   |       |       | PCWP |            |
|  10 |           PX RECEIVE                  |           |       |       | PCWP |            |
|  11 |            PX SEND PARTITION (KEY)    | :TQ10000  |       |       | P-&gt;P | PART (KEY) |
|  12 |             PX BLOCK ITERATOR         |           |       |       | PCWC |            |
|  13 |              TABLE ACCESS FULL        | CUSTOMERS |       |       | PCWP |            |
|  14 |          PX PARTITION HASH JOIN-FILTER|           |:BF0000|:BF0000| PCWC |            |
|* 15 |           TABLE ACCESS FULL           | SALES     |:BF0000|:BF0000| PCWP |            |
-----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   8 - access("S"."CUST_ID"="C"."CUST_ID")
  15 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre><p>This query runs in parallel, as displayed in the plan, because there are <code class="codeph">PX</code> row sources. One table is partitioned, which is the <code class="codeph">SALES</code> table. You can determine this because the <code class="codeph">PX PARTITION HASH</code> row source contains a nonpartitioned table <code class="codeph">CUSTOMERS</code> that is distributed through <code class="codeph">PX SEND PARTITION</code> to a different slave set that performs the join.
                     </p>
                     <div class="infoboxnote" id="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__GUID-A52CD2C3-EF62-45C2-9A09-D4F3F5ED0CFB">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">Rows</code>, <code class="codeph">Cost (%CPU)</code>, <code class="codeph">Time</code>, and <code class="codeph">TQ</code> columns were removed from the plan table output in this example.
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__GUID-025AA221-0018-4857-8959-FA59D6181778">
                        <p class="notep1">Note:</p>
                        <p>This discussion is based on hash partitioning, but it also applies for range, list, and interval partial partition-wise joins.</p>
                     </div>
                     <p>Considerations for full partition-wise joins also apply to partial partition-wise joins:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The degree of parallelism does not need to equal the number of partitions. In <a href="partition-wise-joins.html#GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__I1006993">Figure 3-3</a>, the query executes with two sets of 16 query servers. In this case, Oracle assigns 1 partition to each query server of the second set. Again, the number of partitions should always be a multiple of the degree of parallelism.
                           </p>
                        </li>
                        <li>
                           <p>In Oracle RAC environments on MPPs, each hash partition of <code class="codeph">sales</code> should preferably have affinity to only one node to avoid remote I/Os. Also, spread partitions over all nodes to avoid bottlenecks and use all CPU resources available on the system. A node can host multiple partitions when there are more partitions than nodes.
                           </p>
                           <div class="infoboxnotealso" id="GUID-8D44D783-651D-41BA-87B4-2021676C7F3F__GUID-697A500C-D16D-4C74-96FC-2D89CFA6E634">
                              <p class="notep1">See Also:</p>
                              <p><a href="../racad/introduction-to-oracle-rac.html#RACAD1111" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for more information about data affinity
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1250"></a><div class="props_rev_3"><a id="GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA" name="GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA"></a><h4 id="VLDBG-GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA" class="sect4">Partial Partition-Wise Joins: Composite</h4>
                  <div>
                     <p>You can use composite partial partition-wise joins.</p>
                     <p>As with full partition-wise joins, the prime partitioning method for the <code class="codeph">sales</code> table is to use the range method on column <code class="codeph">time_id</code>. This is because <code class="codeph">sales</code> is a typical example of a table that stores historical data. To enable a partial partition-wise join while preserving this range partitioning, subpartition <code class="codeph">sales</code> by hash on column <code class="codeph">cust_id</code> using 16 subpartitions for each partition. Both pruning and partial partition-wise joins can be used if a query joins <code class="codeph">customers</code> and <code class="codeph">sales</code> and if the query has a selection predicate on <code class="codeph">time_id</code>.
                     </p>
                     <p>When the <code class="codeph">sales</code> table is composite partitioned, the granule of parallelism for a partial partition-wise join is a hash partition and not a subpartition. Refer to <a href="partition-wise-joins.html#GUID-704577A7-20B9-47F5-8BFB-A9CA3BA6D7DC__I1006952">Figure 3-2</a> for an illustration of a hash partition in a composite table. Again, the number of hash partitions should be a multiple of the degree of parallelism. Also, on an MPP system, ensure that each hash partition has affinity to a single node. In the previous example, the eight subpartitions composing a hash partition should have affinity to the same node.
                     </p>
                     <div class="infoboxnote" id="GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA__GUID-15D8F2BA-1B6F-49E1-8FE1-4A2ABA36B3AF">
                        <p class="notep1">Note:</p>
                        <p>This discussion is based on range-hash, but it also applies for all other combinations of composite partial partition-wise joins.</p>
                     </div>
                     <p>The following example shows the execution plan for the query between <code class="codeph">sales</code> and <code class="codeph">customers</code> with sales range partitioned by <code class="codeph">time_id</code> and subpartitioned by hash on <code class="codeph">cust_id</code>.
                     </p><pre class="oac_no_warn" dir="ltr">---------------------------------------------------------------------------------------------
| Id  | Operation                           | Name      | Pstart| Pstop |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |           |       |       |      |            |
|   1 |  PX COORDINATOR                     |           |       |       |      |            |
|   2 |   PX SEND QC (RANDOM)               | :TQ10002  |       |       | P-&gt;S | QC (RAND)  |
|*  3 |    FILTER                           |           |       |       | PCWC |            |
|   4 |     HASH GROUP BY                   |           |       |       | PCWP |            |
|   5 |      PX RECEIVE                     |           |       |       | PCWP |            |
|   6 |       PX SEND HASH                  | :TQ10001  |       |       | P-&gt;P | HASH       |
|   7 |        HASH GROUP BY                |           |       |       | PCWP |            |
|*  8 |         HASH JOIN                   |           |       |       | PCWP |            |
|   9 |          PART JOIN FILTER CREATE    | :BF0000   |       |       | PCWP |            |
|  10 |           PX RECEIVE                |           |       |       | PCWP |            |
|  11 |            PX SEND PARTITION (KEY)  | :TQ10000  |       |       | P-&gt;P | PART (KEY) |
|  12 |             PX BLOCK ITERATOR       |           |       |       | PCWC |            |
|  13 |              TABLE ACCESS FULL      | CUSTOMERS |       |       | PCWP |            |
|  14 |          PX PARTITION RANGE ITERATOR|           |     8 |     9 | PCWC |            |
|  15 |           PX PARTITION HASH ALL     |           |     1 |    16 | PCWC |            |
|* 16 |            TABLE ACCESS FULL        | SALES     |   113 |   144 | PCWP |            |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - filter(COUNT(SYS_OP_CSR(SYS_OP_MSR(COUNT(*)),0))&gt;100)
   8 - access("S"."CUST_ID"="C"."CUST_ID")
  16 - filter("S"."TIME_ID"&lt;=TO_DATE(' 1999-10-01 00:00:00', 'syyyy-mm-dd hh24:mi:ss') AND 
"S"."TIME_ID"&gt;=TO_DATE(' 1999-07-01
              00:00:00', 'syyyy-mm-dd hh24:mi:ss'))
</pre><div class="infoboxnote" id="GUID-5B63C8B9-2CF8-4411-AA07-5979AD7104BA__GUID-6FD7A0E9-45B0-411C-8F98-7126D11E36A5">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">Rows</code>, <code class="codeph">Cost (%CPU)</code>, <code class="codeph">Time</code>, and <code class="codeph">TQ</code> columns were removed from the plan table output in this example.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>