<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Set(T)</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library">
<link rel="prev" href="Sequence.html" title="Sequence(T)">
<link rel="next" href="State.html" title="State">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">
				
					Set(T)
				
			</h1>
<div class="section" title="Set(T)">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="Set"></a>
				<span class="bold"><strong>
					<code class="code">Set(T)</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>conformsTo 
				<a class="link" href="UniqueCollection.html" title="UniqueCollection(T)">
					<code class="code">UniqueCollection(T)</code>
				</a>
			
</p>
<p>
				
<span class="bold"><strong>Operations</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>
				precedence: 
				<code class="code">EQUALITY</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if 
				<code class="code">self</code> and s contain the same elements.
			</p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>
				precedence: 
				<code class="code">EQUALITY</code>
			
</p>
<p>
				
<code class="code">-(s : UniqueCollection(OclAny)) : Set(T)</code>
				precedence: 
				<code class="code">ADDITIVE</code>
			
</p>
<p>The elements of 
				<code class="code">self</code>, which are not in s.
			</p>
<p>
				
<code class="code">excluding(object : OclAny[?]) : Set(T)</code>
			
</p>
<p>The set containing all elements of 
				<code class="code">self</code> without object.
			</p>
<p>
				
<code class="code">excludingAll(objects : Collection(OclAny)) : Set(T)</code>
			
</p>
<p>The set containing all elements of 
				<code class="code">self</code> apart from all occurrences of all objects.
			</p>
<p>
				
<code class="code">flatten(T2)() : Set(T2)</code>
			
</p>
<p>Redefines the Collection operation. If the element type is not a collection type, this results in the same set as 
				<code class="code">self</code>.
				If the element type is a collection type, the result is the set containing all the elements of all the recursively flattened elements of 
				<code class="code">self</code>.
			</p>
<p>
				
<code class="code">including(object : T[?]) : Set(T)</code>
			
</p>
<p>The set containing all elements of 
				<code class="code">self</code> plus object.
			</p>
<p>
				
<code class="code">includingAll(objects : Collection(T)) : Set(T)</code>
			
</p>
<p>The set containing all elements of 
				<code class="code">self</code> and objects.
			</p>
<p>
				
<code class="code">selectByKind(TT)(type : TT[?]) : Set(TT)</code>
			
</p>
<p>
				
<code class="code">selectByType(TT)(type : TT[?]) : Set(TT)</code>
			
</p>
<p>
				
<span class="bold"><strong>Iterations</strong></span>
			
</p>
<p>
				
<code class="code">closure(i : T[1] | lambda : Lambda T() : Set(T)[?]) : Set(T)</code>
			
</p>
<p>The closure of applying body transitively to every distinct element of the source collection.</p>
<p>
				
<code class="code">collect(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)</code>
			
</p>
<p>
				
<code class="code">collectNested(V)(i : T[?] | lambda : Lambda T() : V[?]) : Bag(V)</code>
			
</p>
<p>The Bag of elements which results from applying body to every member of the source nonordered collection.</p>
<p>
				
<code class="code">reject(i : T[?] | lambda : Lambda T() : Boolean[1]) : Set(T)</code>
			
</p>
<p>The subset of the source set for which body is 
				<code class="code">false</code>.
			</p>
<p>
				
<code class="code">select(i : T[?] | lambda : Lambda T() : Boolean[1]) : Set(T)</code>
			
</p>
<p>The subset of set for which expr is 
				<code class="code">true</code>.
			</p>
<p>
				
<code class="code">sortedBy(i : T[?] | lambda : Lambda T() : OclAny[?]) : OrderedSet(T)</code>
			
</p>
<p>Results in the ordered set containing all elements of the source collection.
				The element for which body has the lowest value comes first, and so on.
				The type of the body expression must have the &lt; operation defined.
				The &lt; operation must return a Boolean value and must be transitive (i.e., if a &lt; b and b &lt; c, then a &lt; c).</p>
</div>
</body>
</html>
