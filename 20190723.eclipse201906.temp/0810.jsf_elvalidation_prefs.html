<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="stylesheet" href="../../book.css" type="text/css">
<title>Validating JSF Applications</title>
</head>
<body>
<h1>Changing EL Validation Preferences</h1>
<br>
<p>Most EL validation problems can have their severity customized to be one of <i>error</i>, <i>warning</i> or <i>none</i>.  A severity of <i>none</i> effectively ignores the error for reporting purposes.</p>
<h3>EL Problem Severity Preferences</h3>
To change the severity of a specific EL validation problem type, open the preferences dialog by clicking :  <div><b>Window -&gt; Preferences... -&gt; Web -&gt;JavaServer Faces Tools -&gt; Validation</b>:</div><br><br>
<img alt="EL Validator Preferences" src="./images/elvalidationprefs.png" ><br><br>
<h2>Problem Explanations</h2><br>
<p>The table below shows each of the problems that can have severity customization and explains their effects:
</p>
<table border="1">
<tr class="bgcolorAlternatingOne"><th>Description</th><th>Example</th><th>Explanation</th></tr>
<tr class="bgcolorAlternatingOne"><td>General Syntax Error</td><td nowrap="nowrap">#{* x}</td><td>Syntax errors are  a general violation of the EL language.  In the example, the multiplication operator '*' expects to have two operands, but only one (<i>x</i>) is provided.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Empty EL Expression</td><td nowrap="nowrap">#{}</td><td>Indicates that no expression has been provided.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Missing closing bracket on expression</td><td nowrap="nowrap">#{x + 5</td><td>Indicates that a closing '}' bracket needs to be added as in &quot;#{x + 5<b>}</b>&quot;</td></tr>
<tr class="bgcolorAlternatingOne"><td>Applying operator to method binding</td><td nowrap="nowrap">#{bean.action * 5}</td><td>If <i>bean.action</i> indicates a method &quot;action()&quot; on bean, then it is not legal EL to treat its result as a value.  In the example, multiplying action by 5 attempts treat it is as a value.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Dotted property names should use array  ([]) syntax.</td><td nowrap="nowrap">#{property.name.foo}</td><td>If <i>name.foo</i> is the key of a value in a property bundle index on <i>property, </i>then the EL specification recommends (although does not require) that you instead express it as <i>property['name.foo']</i> to emphasize the fact that <i>name.foo</i> is a key in a map as opposed to, say, a bean property.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Variable not found</td><td nowrap="nowrap">#{bean property}</td><td>If <i>bean</i>  cannot be resolved as a variable, this problem will be flagged.  Since the design time doesn't know about 100% of the variables that may be active at runtime, this may be useful to suppress occassionally to reduce false positives.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Member not found</td><td nowrap="nowrap">#{bean property}</td><td>If <i>property</i>  cannot be resolved as a property of <i>bean</i>, this problem will be flagged.  For example, if <i>bean</i> is a class with no methods <i>getProperty/setProperty</i>.  Although it is much less likely that this validation will  cause false positives, if you are using a lot of different possible sources of variables like tags, it may be useful to ignore.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Property is intermediate</td><td nowrap="nowrap">#{property.name}</td><td>The problem arises because EL allows the '.' character in key names  (as in <i>bean['x<b>.</b>y']</i>, but also allows it to be used as a member operator (as in <i>bean<b>.</b>property)</i>.  This can cause user confusion, especially in cases like the example where <i>property</i> represents a map backed by a resource bundle (i.e. property file).  In the case of the example, suppose there is a key for <i>name.foo</i>.  The statement <i>property.name</i> may then seem meaningful, even though it has no key in the bundle and will result in either a null value or a runtime exception.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Binary operation number coercion problems</td><td nowrap="nowrap">#{5 * true}</td><td>Some binary operators (like '+',  '-', '*', '/' and mod, that take two operands as  in <b>x</b> + <b>y</b>), expect that both operands can be coerced to numbers before applying the operation.  In the example, <i>true</i>  is a boolean literal that does not have a legal coercion to a numeric value (although some implemenations force a coercion in C-like fashion).  Such coercion errors usually cause runtime exceptions.  Note that variables (i.e. bean.booleanProperty) also have the same coercion problems; it is not resticted to literals.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Binary operation boolean coercion problems</td><td nowrap="nowrap">#{myBean.integerProperty && true}</td><td>Some binary operators (like &amp;&amp;, ||) expect that both operands can be coerced to boolean values before applying the operation.  In the case of the example, <i>myBean.integerProperty</i> is a bean property of type Integer.  EL does allow a coercion from numeric types to booleans (although some implementations may force a C-like coercion).</td></tr>
<tr class="bgcolorAlternatingOne"><td>Binary operation no available coercion</td><td>#{myBean.stringArrayProperty&nbsp;&gt;= myBean.booleanProperty}</td><td>When a binary operator like &gt;= is given operands, neither of which can be meaningfully coerced to derive the type of the operands, this problem is shown.  In the example, neither <i>stringArrayProperty</i> nor <i>booleanProperty</i> is a valid value comparable using the &quot;&gt;=&quot; operator.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Binary coercion of literal to number</td><td nowrap="nowrap">#{'a' + 'b'}</td><td>EL sometimes allows string values to be coerced to numbers.  For example #{'5' + '6'} is legal, because both '5' and '6' can be converted to numbers using Long.valueOf().  However,  similar coercions are illegal if such conversions can't be made.  At design time, we can only be certain of such invalid conversions if an offending value is a literal (if it is a variable, we generally won't know until runtime).  In the example, we can tell for sure that neither 'a' or 'b' is convertible to a numeric type expected by the + operator.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Unary operation number coercion problem</td><td nowrap="nowrap">#{-myBean.mapProperty}</td><td>The unary  minus operator expects its operand to be coerable to a numeric type before applying the operation.  In the example, <i>myBean.mapProperty</i> is of type java.util.Map, which has no valid coercion to a number. </td></tr>
<tr class="bgcolorAlternatingOne"><td>Unary operation boolean coercion problem</td><td nowrap="nowrap">#{!myBean.mapProperty}</td><td>The unary  not operator expects its operand to be coerable to a boolean type before applying the operation.  In the example, <i>myBean.mapProperty</i> is of type java.util.Map, which has no valid coercion to a boolean. </td></tr>
<tr class="bgcolorAlternatingOne"><td>Unary operation string coercion not guaranteed</td><td nowrap="nowrap">#{-myBean.stringProperty}</td><td> String coercions to number as expected by unary minus, are not guaranteed depending on the value of the string.  This problem flags such possible problems.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Both operands null</td><td nowrap="nowrap">#{null + null}</td><td> When both operands are null, the resulting value is constant and could be manually folded (replaced by the literal constant) to reduce code.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Binary expression always evaluates to same value</td><td nowrap="nowrap">#{x + 5 * 4}</td><td> When both arguments of a binary expression are literals, the operation can folded at design time.  For example, this expression can be simplified to #{x+20}.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Equality comparison with null always evaluates to same value</td><td nowrap="nowrap">#{myBean.integerProperty == null}</td><td> EL equality and relational comparisons ('==', '!=', '&gt;=' etc.) with null always result in the same value.  Generally, inequality results in true, equality and all relational operators result in false.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Enumeration comparison always evaluates to same value</td><td nowrap="nowrap">#{myBean.coins == 'notAValue'}</td><td> Since the possible values of an enumeration  (Java 5 and later) are known at compile time, we can rule out comparisons that we know will always result in the same value.  In the example, <i>notAValue</i> is not  a member of the Coins enumeration, so we know the equality can never be true.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Unary expression always evaluates to same value</td><td nowrap="nowrap">#{empty 'notEmpty'}</td><td> The unary operators have operands for which the design time can detect they will always evaluate to the same value.  In the example, the <i>empty</i> operator always results in false if applied to a non-null, non-empty string.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Empty operator always resolves to false on type</td><td nowrap="nowrap">#{empty myBean.integerProperty}</td><td> The <i>empty</i> operator always evaluates to false unless its operand is a null value, empty String,  or an array, Map or Collection type.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Minus applied to null always evaluates to zero</td><td nowrap="nowrap">#{-null}</td><td> Null is effectively coerced to 0 when the minus operator is applied.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>First argument short-circuits expression.</td><td nowrap="nowrap">#{false &amp;&amp; someFunc()}</td><td> EL conditional operators are &quot;short-circuiting&quot;, meaning that if the first operand provides enough information to be sure  of the result, then the second operand is not evaluated.  In the example, <i>someFunc() </i>will never be called since the logical-AND of 'false' with any value is false.  Since this can be detected at design time, this probably indicates a useless or manually foldable expression.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Second argument always evaluates the same</td><td nowrap="nowrap">#{myBean.booleanProperty &amp;&amp; false}</td><td> This is similar to the problem above, only the expression is not short-circuited.  In the example, the expression will always be false.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Applying the dot ('.') operator with null always returns null</td><td nowrap="nowrap">#{map[null]}</td><td> Using null as a member accessor will always result in null.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Possible division by zero</td><td nowrap="nowrap">#{x mod  0}</td><td> Division and modulo by 0 can result in a runtime exception.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Possible index out of bounds</td><td nowrap="nowrap">#{myBean.stringArrayProperty[-1]}</td><td> Array indices must be greater than or equal to 0 and less than the size of the array or collection (the same as Java).  When the design time can determine that these contraints may be broken, it flags a warning.</td></tr>
<tr class="bgcolorAlternatingOne"><td>Incompatible enumeration comparision</td><td nowrap="nowrap">#{myBean.coins &gt;= myBean.colors}</td><td> Comparing two enumeration values that are not of the same enumeration type (Java 5 and later)  may cause an exception at runtime.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Method expression expected</td><td nowrap="nowrap">&lt;h:commandButton action=&quot;#{bean.property}&quot;/&gt;</td><td> If the EL validator has information that a tag attribute expects a method expression (method binding before JSF 1.2), then it will flag an error if the EL expression evaluates to a value expression.  In the example, <i>bean.property</i> is a value expression resolving to a bean property on <i>bean</i>.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Value expression type incompatibility</td><td nowrap="nowrap">&lt;h:inputText rendered=&quot;#{bean.foo}/&gt;</td><td> If the EL validator has information that a tag attribute expects a certain value type, then it will flag a problem if the expression cannot be coerced to that type.  In the example, <i>bean.foo</i> is a bean property of type beans Foo.  Arbitrary class type generally cannot be coerced to booleans (rendered must be boolean).</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Value expression expected</td><td nowrap="nowrap">&lt;h:inputText value=&quot;#{bean.action}/&gt;</td><td> If a tag attribute is known to expect a value, then an problem will be flagged if a method expression is given instead.  In the example, the value attribute expects a value expression but a method expression is provided instead (note that there is not way just by looking at it that we can determine it is a method expression.  We must evaluate <i>action</i> on <i>bean</i> to be sure.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Method expression signature incompatibility</td><td nowrap="nowrap">&lt;h:commandButton action=&quot;#{bean.actionTakesArg}&quot;</td><td> If the expected signature of a method expression is known, then the validator will compare it to the provided expression and flag a problem if it doesn't match.  In this case, the <i>action</i> attribute expects a method that takes no arguments, but one with arguments is provided.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Property expected to be readable but has no getter</td><td nowrap="nowrap">&lt;h:outputText value=&quot;#{bean.writeOnlyProperty}/&gt;</td><td> If a tag attribute is known to require a readable property, but an unreadable one is provided, the validator will flag a problem.</td></tr>
<tr class="bgcolorAlternatingTwo"><td>Property expected to be writable but has no setter</td><td nowrap="nowrap">&lt;h:inputText value=&quot;#{bean.readOnlyProperty}/&gt;</td><td>If a tag attribute is known to require a writable property, but an read-only one is provided, the validator will flag a problem.</td></tr>

</table>
<br>
 
<p> <img src="../../images/ngrelt.png"  alt="Related tasks" border="0"> 
</p> 
<p>
<a href="../tasks/jsf_validation.html">Validating JSF Applications</a><br><br>
</p>
  
</body>
</html>