<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>OclAny</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="OCL Documentation">
<link rel="up" href="StandardLibrary.html" title="The OCL Standard Library">
<link rel="prev" href="Map.html" title="Map(K, V)">
<link rel="next" href="OclComparable.html" title="OclComparable">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">
				
					OclAny
				
			</h1>
<div class="section" title="OclAny">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="OclAny"></a>
				<span class="bold"><strong>
					<code class="code">OclAny</code>
				</strong></span>
			
</h2>
</div>
</div>
</div>
<p>The number of elements in the collection 
				<code class="code">self</code>.essions.
				OclAny is itself an instance of the metatype AnyType.
			</p>
<p>All classes in a UML model inherit all operations defined on OclAny.
				To avoid name conflicts between properties in the model and the properties inherited from OclAny,
				all names on the properties of OclAny start with &lsquo;ocl.&rsquo;
				Although theoretically there may still be name conflicts, they can be avoided.
				One can also use qualification by OclAny (name of the type) to explicitly refer to the OclAny properties.</p>
<p>Operations of OclAny, where the instance of OclAny is called object.</p>
<p>
				
<span class="bold"><strong>Attributes</strong></span>
			
</p>
<p>
				
<code class="code">OclInvalid : Bag(OclInvalid[*|?])</code>
			
</p>
<p>
				
<span class="bold"><strong>Operations</strong></span>
			
</p>
<p>
				
<code class="code">=(object2 : OclSelf[?]) : Boolean[1]</code>
				precedence: 
				<code class="code">EQUALITY</code>
			
</p>
<p>True if 
				<code class="code">self</code> is the same object as object2. Infix operator.
			</p>
<div class="literallayout">
<p>
<code class="code">post:&nbsp;result&nbsp;=&nbsp;self&nbsp;=&nbsp;object2<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">&lt;&gt;(object2 : OclSelf[?]) : Boolean[1]</code>
				precedence: 
				<code class="code">EQUALITY</code>
			
</p>
<p>True if 
				<code class="code">self</code> is a different object from object2. Infix operator.
			</p>
<div class="literallayout">
<p>
<code class="code">post:&nbsp;result&nbsp;=&nbsp;not&nbsp;(self&nbsp;=&nbsp;object2)<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">oclAsSet() : Set(OclSelf)</code>
			
</p>
<p>Returns a Set with 
				<code class="code">self</code> as the sole content, unless 
				<code class="code">self</code> is 
				<code class="code">null</code> in which case returns an empty set,
			</p>
<p>
				
<code class="code">oclAsType(TT)(type : TT[?]) : TT[1] invalidating</code>
			
</p>
<p>Evaluates to 
				<code class="code">self</code>, where 
				<code class="code">self</code> is of the type identified by 
				<code class="code">TT</code>.
				The type 
				<code class="code">TT</code> may be any classifier defined by OCL or a user metamodel;
				if the actual type of 
				<code class="code">self</code> at evaluation time does not conform to 
				<code class="code">TT</code>,
				then the oclAsType operation evaluates to 
				<code class="code">invalid</code>.
			</p>
<p>If 
				<code class="code">self</code> is a multiply classified instance, the current classification used for OCL navigation
				is changed to the classification to which 
				<code class="code">TT</code> conforms. The oclAsType call is not well-formed if
				the classification is ambiguous.
			</p>
<p>In the case of feature redefinition, casting an object to a supertype of its actual type
				does not access the supertype&rsquo;s definition of the feature;
				according to the semantics of redefinition, the redefined feature simply does not exist for the object.
				However, when casting to a supertype, any features additionally defined by the subtype are suppressed.</p>
<div class="literallayout">
<p>
<code class="code">post&nbsp;IsSelf:&nbsp;result&nbsp;=&nbsp;self<br>

</code>
</p>
</div>
<p></p>
<p>
				
<code class="code">oclIsInState(statespec : OclState[?]) : Boolean[1]</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if the 
				<code class="code">self</code> is in the state identified by statespec.
			</p>
<p>
				
<code class="code">oclIsInvalid() : Boolean[1] validating</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if the 
				<code class="code">self</code> is equal to OclInvalid.
			</p>
<p>
				
<code class="code">oclIsKindOf(type : OclType[?]) : Boolean[1]</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if the type of 
				<code class="code">self</code> conforms to 
				<code class="code">type</code>.
				That is, 
				<code class="code">self</code> is of type 
				<code class="code">type</code> or a subtype of 
				<code class="code">type</code>.
			</p>
<p>
				
<code class="code">oclIsNew() : Boolean[1]</code>
			
</p>
<p>Can only be used in a postcondition.
				Evaluates to 
				<code class="code">true</code> if the 
				<code class="code">self</code> is created during performing the operation (for instance, it didn&rsquo;t exist at precondition time).
			</p>
<p>
				
<code class="code">oclIsTypeOf(type : OclType[?]) : Boolean[1]</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if 
				<code class="code">self</code> is of the type 
				<code class="code">type</code> but not a subtype of 
				<code class="code">type</code>.
			</p>
<p>
				
<code class="code">oclIsUndefined() : Boolean[1] validating</code>
			
</p>
<p>Evaluates to 
				<code class="code">true</code> if the 
				<code class="code">self</code> is equal to 
				<code class="code">invalid</code> or equal to 
				<code class="code">null</code>.
			</p>
<p>
				
<code class="code">oclLog() : OclSelf[?]</code>
			
</p>
<p>Evaluates to the self, with the side effect of generating a log message comprising self.</p>
<p>
				
<code class="code">oclLog(message : String[?]) : OclSelf[?]</code>
			
</p>
<p>Evaluates to the self, with the side effect of generating a log message comprising message followed by self.</p>
<p>
				
<code class="code">oclType() : OclSelf[1]</code>
			
</p>
<p>Evaluates to the most derived type of which 
				<code class="code">self</code> is currently an instance. If 
				<code class="code">self</code> is an instance of a multiply
				classified type, the return is the most derived type of the current classification which is established when the instance is
				passed to OCL, or re-established by an 
				<code class="code">oclAsType()</code> call.
			</p>
<p>
				
<code class="code">oclTypes() : Set(OclSelf[*|?])</code>
			
</p>
<p>Evaluates to all of the most derived type of which 
				<code class="code">self</code> is an instance. The return from 
				<code class="code">oclTypes()</code>
				is normally equivalent to that from 
				<code class="code">oclType()</code> unless 
				<code class="code">self</code> is an instance of multiply classified type.
			</p>
<p>
				
<code class="code">toString() : String[1]</code>
			
</p>
<p>Returns a string representation of 
				<code class="code">self</code>.
			</p>
</div>
</body>
</html>
