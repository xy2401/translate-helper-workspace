<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "../xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <link rel="stylesheet" type="text/css" href="../css/ot.css" />
      <link rel="stylesheet" type="text/css" href="../css/otjld.css" />
      <title>OT/J Language Definition v1.3.1</title>
   </head>
   <body class="otdt">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a><a href="s3.html" rel="prev">&lt;&lt;&nbsp;&sect;3&nbsp;Callout Binding</a></td>
               <td class="top"><a href="index.html" rel="contents">&uarr;&nbsp;Table of Contents&nbsp;&uarr;</a></td>
               <td class="next"><a href="s5.html" rel="next">&sect;5&nbsp;Team Activation&nbsp;&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s4">
            <div class="headl">
               <div class="headr">
                  <h1>&sect;4&nbsp;Callin Binding</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s4.html">&sect;4&nbsp;Callin Binding</a></li>
                  <li><a href="#s4.1">&sect;4.1&nbsp;Callin method binding</a></li>
                  <li><a href="#s4.2">&sect;4.2&nbsp;Callin modifiers (before, after, replace)</a></li>
                  <li><a href="#s4.3">&sect;4.3&nbsp;Base calls</a></li>
                  <li><a href="#s4.4">&sect;4.4&nbsp;Callin parameter mapping</a></li>
                  <li><a href="#s4.5">&sect;4.5&nbsp;Lifting and lowering</a></li>
                  <li><a href="#s4.6">&sect;4.6&nbsp;Overriding access restrictions</a></li>
                  <li><a href="#s4.7">&sect;4.7&nbsp;Callin binding with static methods</a></li>
                  <li><a href="#s4.8">&sect;4.8&nbsp;Callin precedence</a></li>
                  <li><a href="#s4.9">&sect;4.9&nbsp;Callin inheritance</a></li>
                  <li><a href="#s4.10">&sect;4.10&nbsp;Generic callin bindings</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>Notion of callin binding</h3>
               <p>
                  			Callin bindings realize a forwarding in the direction opposite to callout bindings 
                  			(see <a href="s3.html" title="&sect;3&nbsp;Callout Binding" class="sect">&sect;3</a>).
                  			Both terms are chosen from the perspective of a role, which controls its communication with 
                  			an associated base object.
                  			Technically, callin bindings are equivalent to weaving additional code (triggers) 
                  			into existing base methods.
                  		
               </p>
               <div class="line"></div>
               <div class="term">Callin</div>
               <div class="termdesc">Methods of a base class may be <strong>intercepted</strong> by a callin binding
                  	    (<em>the base method "calls into" the role</em>).
               </div>
               <div class="line"></div>
               <div class="term">Before/after/replace</div>
               <div class="termdesc">The modifiers <strong>before, after, replace</strong> control the composition
                  	    of original method and callin method.
               </div>
               <div class="line"></div>
               <div class="term">Activation</div>
               <div class="termdesc">Callin bindings may be active or inactive according to
                  	    <a href="s5.html" title="&sect;5&nbsp;Team Activation" class="sect">&sect;5</a>.
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s4.1">
               <h2 class="sect">&sect;4.1&nbsp;Callin method binding<a class="img" href="s4.1.html"
                     title="PermaLink to &sect;4.1&nbsp;Callin method binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.3.3" title="&sect;A.3.3&nbsp;Callin binding"
                     class="syntax">&rarr;&nbsp;Syntax&nbsp;&sect;A.3.3</a></div>
               <div class="subsect depth3" id="s4.1.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Method call interception</span><a class="img" href="s4.1.a.html"
                        title="PermaLink to (a)&nbsp;Method call interception"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A role method may intercept calls to a base method by
                     	    a callin binding.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Prerequisite: Class binding</span><a class="img" href="s4.1.b.html"
                        title="PermaLink to (b)&nbsp;Prerequisite: Class binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A callin binding requires the enclosing class to be a role class
                     	    bound to a base class according to <a href="s2.1.html" title="&sect;2.1&nbsp;playedBy relation" class="sect">&sect;2.1</a>. 
                     	    An <em>unliftable</em> role (see <a href="s2.3.4.a.html" title="&sect;2.3.4.(a)&nbsp;Potential ambiguity"
                        class="sect">&sect;2.3.4.(a)</a>) should not define callin bindings.
                     	    In this case callin bindings can only safely be introduced in sub-roles 
                     	    which (by an appropriately refined <code>playedBy</code> clause) disambiguate the lifting translation.
                     			
                  </p>
                  <p>
                     		For corner cases the above rule can be overridden by suppressing the corresponding error
                     		using the <code>"hidden-lifting-problem"</code> token (see <a href="s2.3.5.html"
                        title="&sect;2.3.5&nbsp;Consequences of lifting problems"
                        class="sect">&sect;2.3.5</a>).  
                     		This will allow callin bindings to be defined even for unliftable roles expecting that lifting
                     		may still succeed by one of the patterns desribed in <a href="s2.3.4.b.html" title="&sect;2.3.4.(b)&nbsp;Definite ambiguity"
                        class="sect">&sect;2.3.4.(b)</a>.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Callin declaration</span><a class="img" href="s4.1.c.html"
                        title="PermaLink to (c)&nbsp;Callin declaration"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A callin binding composes an existing role method with a
                     	    given base method.
                     	    It may appear within the role class at any place where feature
                     	    declarations are allowed. It is denoted by
                     			
                  </p>
                  <div class="listing plain"><pre><i>role_method_designator</i> <b>&lt;-</b> <i>callin_modifier </i><i>base_method_designator;</i></pre></div>
                  <p>Just like with callout bindings, method designators may
                     	    or may not contain parameters lists and return type but no modifiers;
                     also, each method designator must exactly and uniquely select one method 
                     (cf. <a href="s3.1.c.html" title="&sect;3.1.(c)&nbsp;Kinds of method designators"
                        class="sect">&sect;3.1.(c)</a>).
                     <br />
                     	    For <em>callin modifiers</em> see <a href="#s4.2"
                        title="&sect;4.2&nbsp;Callin modifiers (before, after, replace)"
                        class="sect">below (&sect;4.2)</a>.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Multiple base methods</span><a class="img" href="s4.1.d.html"
                        title="PermaLink to (d)&nbsp;Multiple base methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Base method designators may furthermore enumerate a
                     	    list of methods. If multiple base methods are bound in one
                     	    callin declaration generally all signatures in this binding must be conform.
                     		<br />
                     	    However, <em>extraneous parameters</em> from base methods may be ignored
                     	    at the role.
                     	    <br />
                     	    For <em>result types</em> different rules exist, depending on the
                     	    applied callin modifier (see next).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">Named callin binding</span><a class="img" href="s4.1.e.html"
                        title="PermaLink to (e)&nbsp;Named callin binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Any callin binding may be labeled with a name. The name of a callin binding is used 
                     			for declaring <em>precedence</em> (<a href="#s4.8" title="&sect;4.8&nbsp;Callin precedence" class="sect">&sect;4.8</a>). 
                     			A named callin binding <em>overrides</em> any inherited callin binding 
                     			(explicit and implicit (<a href="s1.3.1.html"
                        title="&sect;1.3.1&nbsp;Acquisition and implicit inheritance of role classes"
                        class="sect">&sect;1.3.1</a>)) with the same name.
                     			<br />
                     It is an error to use the same callin name more than once within the same role class.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.f">
                  <h4 class="subsect">(f)&nbsp;<span class="title">Callin to final</span><a class="img" href="s4.1.f.html" title="PermaLink to (f)&nbsp;Callin to final"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>When binding to a final base method, the enclosing role must be played by the exact base class 
                     			declaring the final method. I.e., callin binding to a final method inherited from the 
                     			base class's super-class is not allowed. This is motivated by the fact that no sub-class may have 
                     			a version of a final method with different semantics.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.g">
                  <h4 class="subsect">(g)&nbsp;<span class="title">Declared exceptions</span><a class="img" href="s4.1.g.html"
                        title="PermaLink to (g)&nbsp;Declared exceptions"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>It is an error if a role method to be bound by callin declares in its <tt>throws</tt> clause 
                     		any exceptions that are not declared by the corresponding base method(s).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.h">
                  <h4 class="subsect">(h)&nbsp;<span class="title">Method of enclosing class</span><a class="img" href="s4.1.h.html"
                        title="PermaLink to (h)&nbsp;Method of enclosing class"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>In a <code>before</code> or <code>after</code> callin binding the left hand side may alternatively
                     			resolve to a method of an enclosing class rather than the current role.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.1.i">
                  <h4 class="subsect">(i)&nbsp;<span class="title">Callin to constructor</span><a class="img" href="s4.1.i.html"
                        title="PermaLink to (i)&nbsp;Callin to constructor"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A callin binding may refer to a constructor of the bound base class by using the
                     				constructor's source name (identical to the name of the base class). 
                     				In this case only an <strong>after</strong>	binding (<a href="#s4.2.a" title="&sect;4.2.(a)&nbsp;Method composition" class="sect">&sect;4.2.(a)</a>) is allowed.
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.2">
               <h2 class="sect">&sect;4.2&nbsp;Callin modifiers (before, after, replace)<a class="img" href="s4.2.html"
                     title="PermaLink to &sect;4.2&nbsp;Callin modifiers (before, after, replace)"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <div class="subsect depth3" id="s4.2.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Method composition</span><a class="img" href="s4.2.a.html"
                        title="PermaLink to (a)&nbsp;Method composition"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The kind of method composition is controlled by adding one
                     	    of the modifiers <strong>before, after</strong> or <strong>replace</strong> after the
                     	    "<code>&lt;-</code>" token of the binding declaration.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.2.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Additive composition</span><a class="img" href="s4.2.b.html"
                        title="PermaLink to (b)&nbsp;Additive composition"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The <code>before</code> and <code>after</code> modifiers have the
                     	    effect of adding a call to the role method at the beginning or end
                     	    of the base method, resp.<br />
                     	    In this case no data are transferred from the role to the base,
                     	    so if the role method has a result, this will always be ignored.
                     			
                  </p>
                  <h5 class="listing">Example code (Callin):</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>team</b> <b>class</b> Company {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>protected</b> <b>class</b> Employee <b>playedBy</b> Person {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>public</b> <b>void</b> recalculateIncome() { ... }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>    recalculateIncome <em><b>&lt;-</b> after</em> haveBirthday; <span class="comment">// callin binding</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">5</td>
                           <td><pre>  }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <p>Line 4 declares a callin binding for the role method <code>recalculateIncome()</code> 
                        			defined in line 3. In combination with the role binding in line 2 this has the following effect:
                        				
                     </p>
                     <ul>
                        <li><strong>After</strong> every call of the method <code>Person.haveBirthday</code> 
                           					the method <code>Company.recalculateIncome</code> is called.
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="subsect depth3" id="s4.2.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Replacing composition</span><a class="img" href="s4.2.c.html"
                        title="PermaLink to (c)&nbsp;Replacing composition"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The <code>replace</code> modifier causes <em>only</em> the role method to be
                     	    invoked, replacing the base method.
                     	    <br />
                     	    In this case, if the base method declares a result, this should be provided by the role method.
                     	    Special cases of return values in callin bindings are discussed in <a href="#s4.3.e" title="&sect;4.3.(e)&nbsp;Fragile callin binding"
                        class="sect">&sect;4.3.(e)</a></p>
               </div>
               <div class="subsect depth3" id="s4.2.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Callin methods</span><a class="img" href="s4.2.d.html" title="PermaLink to (d)&nbsp;Callin methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Role methods to be bound by a callin replacement binding must have
                     	    the modifier <code>callin</code>. This modifier is only allowed for methods
                     	    of a role class.<br />
                     		A method with the <code>callin</code> modifier can only be called
                     			
                  </p>
                  <ul>
                     <li>via a callin replace binding</li>
                     <li>by a <code>super</code> or <code>tsuper</code> call from an overriding callin method.
                     </li>
                  </ul>
                  <p>It is illegal for a <code>callin</code> method
                  </p>
                  <ul>
                     <li>to be called directly,</li>
                     <li>to be bound using a callout binding, and</li>
                     <li>to be bound to a base method using a <code>before</code> or <code>after</code> callin binding.
                     </li>
                  </ul>
                  <p>Despite these rules a second level role &mdash; which is played by the current role &mdash;
				can	intercept the execution of a callin method using any form of callin binding.</p>
                  <p>A callin method cannot override a regular method and vice versa, however,
                     	    overriding one callin method with another callin method is legal and
                     	    dynamic binding applies to callin method just like regular methods.
                     	    <br />
                     	    A callin method must not declare its visibility using any of the modifiers <code>public</code>, 
                     	    <code>protected</code> or <code>private</code>. Since callin methods can only be invoked via callin bindings 
                     	    such visibility control would not be useful.
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.3">
               <h2 class="sect">&sect;4.3&nbsp;Base calls<a class="img" href="s4.3.html" title="PermaLink to &sect;4.3&nbsp;Base calls"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.5.3" title="&sect;A.5.3&nbsp;BaseCall" class="syntax">&rarr;&nbsp;Syntax&nbsp;&sect;A.5.3</a></div>
               <p>Role methods with a <code>callin</code> modifier should contain
                  a <em>base call</em> which uses the special name <code>base</code>
                  in order to invoke the original base method (original means: before replacement).
                  		
               </p>
               <div class="subsect depth3" id="s4.3.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Syntax</span><a class="img" href="s4.3.a.html" title="PermaLink to (a)&nbsp;Syntax"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The syntax for base calls is <code>base.m()</code>,
                     		which is in analogy to super calls.
                     	    A <code>base.m()</code> call must use the same name and signature
                     	    as the enclosing method. This again follows the rule, that roles
                     	    should never explicitly use base names, except in binding declarations.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Missing base call</span><a class="img" href="s4.3.b.html"
                        title="PermaLink to (b)&nbsp;Missing base call"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>For each callin method, the compiler uses some flow analysis to check whether
                     		a base call will be invoked on each path of execution (analysis is very similar 
                     		to the analysis for definite assignment regarding final variables - 
                     		<a href="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html"
                        class="ext">JLS &sect;16</a>).
                     		The compiler will issue a warning if a base call is missing either
                     		on each path (definitely missing) or on some paths (potentially missing).
                     		Instead of directly invoking a base call, a callin method may also call
                     		its explicit or implicit super version using <code>super.m()</code> or <code>tsuper.m()</code> (see <a href="s1.3.1.f.html" title="&sect;1.3.1.(f)&nbsp;tsuper" class="sect">&sect;1.3.1.(f)</a>). 
                     		In this case the flow analysis will transitively include the called super/tsuper version.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Duplicate base call</span><a class="img" href="s4.3.c.html"
                        title="PermaLink to (c)&nbsp;Duplicate base call"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>If a callin method contains several base calls, the compiler gives
                     		a warning if this will result in duplicate base call invocations on all
                     		paths (definitely duplicate) or on some paths (potentially duplicate).
                     		Again super/tsuper calls are included in the flow analysis (see 4.3(b)).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Parameter tunneling</span><a class="img" href="s4.3.d.html"
                        title="PermaLink to (d)&nbsp;Parameter tunneling"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>If a base method has more parameters
                     	    than a callin method to which it is composed, additional
                     	    parameters are implicitly passed unchanged from the original
                     	    call to the base call (original means: before interception).
                     		I.e., a call <code>base.m()</code> may invisibly pass additional
                     		parameters that were provided by the caller, but are hidden from the
                     		role method.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">Fragile callin binding</span><a class="img" href="s4.3.e.html"
                        title="PermaLink to (e)&nbsp;Fragile callin binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>If a role method returns void, but the bound base method declares a
                     		non-void result, this is reported as a <em>fragile callin binding</em>:
                     The result can still be provided by the base call, but omitting the
                     		base call may cause problems depending on the return type:
                     			
                  </p>
                  <ul>
                     <li>For reference return types <code>null</code> will be returned
                        			            in this case.
                     </li>
                     <li>In the case of primitive return types this will cause a
                        						<code>ResultNotProvidedException</code> at run-time.
                     </li>
                  </ul>
                  <p>It is an error if a callin method involved in a fragile callin binding
                     		has definitely no base call.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.3.f">
                  <h4 class="subsect">(f)&nbsp;<span class="title">Base super calls</span><a class="img" href="s4.3.f.html" title="PermaLink to (f)&nbsp;Base super calls"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>If a callin method <code>rm</code> is bound to a base method <code>B1.m</code> 
                     			that in turn overrides an inherited method <code>B0.m</code> 
                     			(<code>B0</code> is a super class of <code>B1</code>),
                     			the callin method may use a special form of a base call denoted as 
                     			
                  </p>
                  <div class="listing plain"><pre><strong>base.super</strong>.rm();</pre></div>
                  <p>Such base super call invokes the super method of the bound base method,
                     			here <code>B0.m</code>. This invocation is not affected by any further callin binding.
                     			
                  </p>
                  <p>A base super call bypasses both the original method <code>B1.m</code> and
                     			also other callin bindings that would be triggered by a regular base call.
                     			For this reason any application of this construct is flagged by a decapsulation warning
                     			(see <a href="s3.4.html" title="&sect;3.4&nbsp;Overriding access restrictions"
                        class="sect">&sect;3.4</a>).
                     			
                  </p>
               </div>
               <div class="note">
                  <h5>Comment:</h5>
                  			Base calls can occur in callin methods that are not
                  			yet bound. These methods have no idea of the names of base methods that
                  			a sub-role will bind to them. Also multiple base methods may be bound
                  			to the same callin method.
                  			Hence the use of the role method's own name and signature.
                  			The language implementation translates the method name and signature
                  			back to the base method that has originally been invoked.
                  		
               </div>
               <h5 class="listing">Example code (Base Call):</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>class</b> ValidatorRole <b>playedBy</b> Po<b>int</b> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <em>callin</em> <b>void</b> checkCoordinate(<b>int</b> value) {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>if</b> (value &lt; 0)</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>      <em>base</em>.checkCoordinate(-value);</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">5</td>
                        <td><pre>    else</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>      <em>base</em>.checkCoordinate(value);</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>  checkCoordinate <b>&lt;-</b> <b>replace</b> setX, setY;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>Effects:</h5>
                  <ul>
                     <li>Line 2 defines a callin method which is bound to two methods 
                        						of the base class <code>Point</code> (see line 8).
                     </li>
                     <li>The value passed to either setX or setY is checked if it is
                        						positive (line 3).
                     </li>
                     <li>Lines 4 and 6 show calls of the original method (base calls). 
                        						While line 6 passes the original value, in the negative case (line 4) 
                        						the passed value is made positive.
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="s4.4">
               <h2 class="sect">&sect;4.4&nbsp;Callin parameter mapping<a class="img" href="s4.4.html"
                     title="PermaLink to &sect;4.4&nbsp;Callin parameter mapping"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <div class="subsect depth3" id="s4.4.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">General case parameter mapping</span><a class="img" href="s4.4.a.html"
                        title="PermaLink to (a)&nbsp;General case parameter mapping"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The rules for mapping callin parameters and result type
                     	    are mainly the same as for callout bindings (<a href="s3.2.html" title="&sect;3.2&nbsp;Callout parameter mapping"
                        class="sect">&sect;3.2</a>)
                     	    except for reversing the <code>-&gt;</code> and <code>&lt;-</code> tokens and
                     	    swapping left hand side and right hand side.
                     	    <br />
                     	    Callin bindings using <code>before</code> have no result mapping.
                     For <code>result</code> in <code>after</code> callin bindings
                     see <a href="#s4.4.c"
                        title="&sect;4.4.(c)&nbsp;Mapping the result of a base method"
                        class="sect">&sect;4.4.(c)</a> below.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.4.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Restrictions for callin replace bindings</span><a class="img" href="s4.4.b.html"
                        title="PermaLink to (b)&nbsp;Restrictions for callin replace bindings"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>The right-hand side of a parameter mapping may either be
                     		the simple name of a base method argument without further computation, 
                     		or an arbitrary expression <em>not</em> containing any base method argument.
                     		<br />
                     		Each base method argument must either appear as a simple name in exactly one parameter mapping
                     		or not be mapped at all. In the latter case, the original argument is "tunneled" to
                     		the base call, meaning, the callin method does not see the argument, but it is passed
                     		to the base method as expected.
                     <br />
                     If the base method declares a result, then
                     			
                  </p>
                  <ul>
                     <li>if the role method also declares a result, <code>result</code> must be mapped to itself:
                        					<br /><code>result -&gt; result</code></li>
                     <li>if the role method does not declare a result, an arbitrary expression may be mapped to result:
                        	<br /><code><em>expression</em> -&gt; result</code><br />
                        		If in this situation no result mapping exists, the result of the base call
                        					is "tunneled" and passed to the original caller (see <a href="#s4.3.e" title="&sect;4.3.(e)&nbsp;Fragile callin binding"
                           class="sect">
                           					fragile callin binding (&sect;4.3.(e))</a> above).
                        
                     </li>
                  </ul>
                  <p>These rules ensure that these bindings are reversible
                     		for the sake of base calls (<a href="#s4.3" title="&sect;4.3&nbsp;Base calls" class="sect">&sect;4.3</a>).
                     			
                  </p>
                  <p>As stated above a fragile callin binding (<a href="#s4.3.e" title="&sect;4.3.(e)&nbsp;Fragile callin binding"
                        class="sect">&sect;4.3.(e)</a>) 
                     		is not allowed with a callin method that definitely has no base call
                     		(<a href="#s4.3.b" title="&sect;4.3.(b)&nbsp;Missing base call" class="sect">&sect;4.3.(b)</a>). A callin replace binding is not fragile if it provides 
                     		the base result using a result mapping.
                     			
                  </p>
                  <p>A callin method bound with replace to a base method returning
                     		void must not declare a non-void result.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.4.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Mapping the result of a base method</span><a class="img" href="s4.4.c.html"
                        title="PermaLink to (c)&nbsp;Mapping the result of a base method"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>In an <code>after</code> callin binding, the right-hand side
                     		of a parameter mapping may use the identifier <code>result</code>
                     to refer to the result of the base method.
                     	
                  </p>
                  <p> 
                     An <code>after</code> callin binding
                     can, however, not <em>influence</em> the result of the base method,
                     thus mappings with the <code>-&gt;</code> token are not allowed for after callin bindings.
                     For <code>before</code> mappings using the <code>-&gt;</code> token is already ruled out by <a href="#s4.4.a" title="&sect;4.4.(a)&nbsp;General case parameter mapping"
                        class="sect">&sect;4.4.(a)</a></p>
               </div>
               <div class="subsect depth3" id="s4.4.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Multiple base methods</span><a class="img" href="s4.4.d.html"
                        title="PermaLink to (d)&nbsp;Multiple base methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A callin binding listing more than one base method may use parameter
                     		mappings with only the following restriction: if any base parameter should be mapped this parameter 
                     		must have the same name and type in all listed base method designators. 
                     		However, different parameter mappings for different base methods bound to the same role method 
                     		can be defined if separate callin bindings are used.
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.5">
               <h2 class="sect">&sect;4.5&nbsp;Lifting and lowering<a class="img" href="s4.5.html"
                     title="PermaLink to &sect;4.5&nbsp;Lifting and lowering"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <p>For basic definition see <a href="s2.2.html" title="&sect;2.2&nbsp;Lowering" class="sect">&sect;2.2</a>
                  and <a href="s2.3.html" title="&sect;2.3&nbsp;Lifting" class="sect">&sect;2.3</a>.
                  <br />
                  	(The following rules are reverse forms of those from <a href="s3.3.html" title="&sect;3.3&nbsp;Lifting and lowering" class="sect">&sect;3.3</a>)
                  		
               </p>
               <div class="subsect depth3" id="s4.5.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Call target translation</span><a class="img" href="s4.5.a.html"
                        title="PermaLink to (a)&nbsp;Call target translation"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Invoking a role method due to a callin binding first
                     	    <strong>lifts</strong> the base object to the role class of the
                     	    callin binding, in order to obtain the effective call target. 
                     	    This is why callin bindings cannot be defined in roles that are <em>unliftable</em> 
                     	    due to <em>potential binding ambiguity</em> (see <a href="#s4.1.b" title="&sect;4.1.(b)&nbsp;Prerequisite: Class binding"
                        class="sect">&sect;4.1.(b)</a> 
                     	    above and <a href="s2.3.4.a.html" title="&sect;2.3.4.(a)&nbsp;Potential ambiguity"
                        class="sect">&sect;2.3.4.(a)</a>).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Parameter translation</span><a class="img" href="s4.5.b.html"
                        title="PermaLink to (b)&nbsp;Parameter translation"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>During callin execution, each parameter for which the role method expects a role
                     	    object is implicitly <strong>lifted</strong> to the declared role class.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Result translation</span><a class="img" href="s4.5.c.html"
                        title="PermaLink to (c)&nbsp;Result translation"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Returning a role object from a callin method implicitly
                     	    <strong>lowers</strong> this object.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Typing rules</span><a class="img" href="s4.5.d.html" title="PermaLink to (d)&nbsp;Typing rules"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A parameter mapping (implicit by parameter position or explicit
                     	    by a <code>with</code> clause) is <strong>well typed</strong> if
                     	    the right hand side conforms to the left hand side, either by
                     			
                  </p>
                  <ul>
                     <li>type equality</li>
                     <li>implicit primitive type conversion</li>
                     <li>subtype polymorphism</li>
                     <li>translation polymorphism, here: <em>lifting</em>;<br />
                        however, within <code>replace</code> bindings step 1 of the smart lifting 
                        algorithm (<a href="s2.3.3.a.html" title="&sect;2.3.3.(a)&nbsp;Static adjustment"
                           class="sect">&sect;2.3.3.(a)</a>) is not applicable
                     </li>
                     <li><em>or</em> by a combination of the above.
                     </li>
                  </ul>
                  <p>A result mapping (implicit or explicit by a <code>with</code> clause)
                     	    is well typed, if the value at the left hand conforms to the
                     	    right hand side according to the rules given above, except that
                     	    translation polymorphism here applies <em>lowering</em> instead of
                     	    lifting.
                  </p>
                  <p>
                     	    These rules define <strong>translation polymorphism</strong> as introduced in
                     	    <a href="s2.3.html" title="&sect;2.3&nbsp;Lifting" class="sect">&sect;2.3</a>.
                     			
                  </p>
                  <p>Additionally, in a <code>replace</code> callin binding compatibility of parameters and return
                     			types must hold in both directions. 
                     			Thus, from the above list of conversions a replace binding cannot apply subtype polymorphism
                     			nor primitive type conversion.
                     			If more flexibility is desired, type parameters can be used as defined in <a href="#s4.10" title="&sect;4.10&nbsp;Generic callin bindings" class="sect">&sect;4.10</a>.
                     	    	
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">Role arrays</span><a class="img" href="s4.5.e.html" title="PermaLink to (e)&nbsp;Role arrays"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>For arrays of roles as parameters <a href="s2.3.d.html" title="&sect;2.3.(d)&nbsp;Lifting of arrays"
                        class="sect">&sect;2.3.(d)</a> applies 
                     		accordingly. For arrays as return value <a href="s2.2.e.html" title="&sect;2.2.(e)&nbsp;Lowering of arrays"
                        class="sect">&sect;2.2.(e)</a> applies.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.5.f">
                  <h4 class="subsect">(f)&nbsp;<span class="title">Base calls</span><a class="img" href="s4.5.f.html" title="PermaLink to (f)&nbsp;Base calls"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>For base calls these rules are reversed again, i.e., a
                     		base call behaves like a callout binding.
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.6">
               <h2 class="sect">&sect;4.6&nbsp;Overriding access restrictions<a class="img" href="s4.6.html"
                     title="PermaLink to &sect;4.6&nbsp;Overriding access restrictions"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <p>Callin bindings may also mention inaccessible methods
                  	(cf. decapsulation <a href="s3.4.html" title="&sect;3.4&nbsp;Overriding access restrictions"
                     class="sect">&sect;3.4</a>).
                  	Due to the reverse call direction this is relevant only for base calls within 
                  	<code>callin</code> methods. 
                  	Base calls have unrestricted access to protected base methods.
                  	Accessing a base method with private or default visibility is
                  	also allowed, but signaled by a compiler warning.
                  		
               </p>
               <div class="note">
                  <h5>Comment:</h5>
                  			A base call to an inaccessible base method is considered harmless, 
                  			since this is the originally intended method execution.
                  		
               </div>
               <div class="subsect depth3" id="s4.6.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Private methods from super classes</span><a class="img" href="s4.6.a.html"
                        title="PermaLink to (a)&nbsp;Private methods from super classes"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p><em>(Cf. <a href="s3.4.d.html"
                           title="&sect;3.4.(d)&nbsp;Private methods from super classes"
                           class="sect">&sect;3.4.(d)</a>)</em>
                     			If a callin binding shall bind to a private base method, that method
                     must be defined in the exact base class to which the current role
                     class is bound using <code>playedBy</code>.
                     <br />
                     If a private base feature must indeed be callin-bound, a role class
                     must be defined that is played by the exact base class defining the
                     private feature. Another role bound to a sub-base-class can then
                     be defined as a sub class of the first role. It will inherit the
                     callin binding and through this it can access the desired feature.
                     
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s4.7">
               <h2 class="sect">&sect;4.7&nbsp;Callin binding with static methods<a class="img" href="s4.7.html"
                     title="PermaLink to &sect;4.7&nbsp;Callin binding with static methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <p>The normal case of callin bindings refers to non-static methods on both
                  	sides (base and role). Furthermore, in Java inner classes can not define
                  	static methods. Both restrictions are relaxed by the following rules:
                  		
               </p>
               <div class="subsect depth3" id="s4.7.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Static role methods</span><a class="img" href="s4.7.a.html"
                        title="PermaLink to (a)&nbsp;Static role methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A role class may define static methods (see also <a href="s1.2.1.f.html" title="&sect;1.2.1.(f)&nbsp;Static role methods"
                        class="sect">&sect;1.2.1.(f)</a>).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Binding static to static</span><a class="img" href="s4.7.b.html"
                        title="PermaLink to (b)&nbsp;Binding static to static"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A callin binding may bind a static role method to one or more
                     		static base methods. It is, however, an error to bind a static base method to a non-static role method, 
                     		because such binding would require to lift a base object that is not provided.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">before/after</span><a class="img" href="s4.7.c.html" title="PermaLink to (c)&nbsp;before/after"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>In addition to the above, <code>before</code> and <code>after</code>
                     		callin bindings may also bind a static role method to non-static base methods.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.7.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">replace</span><a class="img" href="s4.7.d.html" title="PermaLink to (d)&nbsp;replace"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>In contrast to <a href="#s4.7.c" title="&sect;4.7.(c)&nbsp;before/after" class="sect">&sect;4.7.(c)</a> above, a <code>replace</code> callin binding
                     		cannot bind a static role method to a non-static base method.
                     			
                  </p>
               </div>
               <p>The following table summarizes the combinations defined above:
                  		
               </p>
               <table border="2" class="sep" cellpadding="5" width="80%">
                  <tr class="z1">
                     <td colspan="2" rowspan="2" align="right"><strong>&lt;-</strong>&nbsp;&nbsp;
                     </td>
                     <td colspan="2" align="center" rowspan="1"><strong>base method</strong></td>
                  </tr>
                  <tr class="z1">
                     <td align="center" rowspan="1" colspan="1">static</td>
                     <td align="center" rowspan="1" colspan="1">non-static</td>
                  </tr>
                  <tr class="z2">
                     <td rowspan="2" align="center" class="z1" colspan="1"><strong>role<br />method</strong></td>
                     <td align="center" class="z1" rowspan="1" colspan="1">static</td>
                     <td rowspan="1" colspan="1"><span class="green">OK</span></td>
                     <td rowspan="1" colspan="1"><code>before/after</code>: <span class="green">OK</span><br /><code>replace</code>: <span class="error">illegal</span></td>
                  </tr>
                  <tr class="z2">
                     <td align="center" class="z1" rowspan="1" colspan="1">non-static</td>
                     <td rowspan="1" colspan="1"><span class="error">illegal</span></td>
                     <td rowspan="1" colspan="1"><span class="green">OK</span></td>
                  </tr>
               </table>
               <div class="subsect depth3" id="s4.7.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">No overriding</span><a class="img" href="s4.7.e.html" title="PermaLink to (e)&nbsp;No overriding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Since static methods are not dynamically bound, <i>overriding</i> does not
                     				   apply in the normal semantics. Regarding callin bindings this has the
                     				   following consequences (assuming a role <code>RMid</code> played by
                     				   <code>BMid</code> plus its super-class <code>BSuper</code> and its sub-class
                     				   <code>BSub</code>.
                     			
                  </p>
                  <ol>
                     <li>If a static base method <code>BMid.m</code> is bound by a callin binding
                        				       this has no effect on any method <code>m</code> in <code>BSub</code>.
                     </li>
                     <li>If a callin binding mentions a method <code>m</code> which is not present 
                        in <code>BMid</code> but resolves to a static method in <code>BSuper</code> 
                        the binding only affects invocations as <code>BMid.m()</code> but not
                        <code>BSuper.m()</code>. If the latter call should be affected, too,
                        the callin binding must appear in a role class bound to <code>BSuper</code>, 
                        not <code>BMid</code>.
                     </li>
                     <li>In order to bind two static base methods with equal signatures, one being
                        				       defined in a sub-class of the other one, two roles have to be defined
                        				       where one role refines the <code>playedBy</code> clause of the other role
                        				       (say: <code>public class RSub extends RMid playedBy BSub</code>).
                        				       Now each role may bind to the static base method accessible in its direct
                        				       base-class.
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="s4.8">
               <h2 class="sect">&sect;4.8&nbsp;Callin precedence<a class="img" href="s4.8.html"
                     title="PermaLink to &sect;4.8&nbsp;Callin precedence"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <div class="syntaxlink"><a href="sA.8.html" title="&sect;A.8&nbsp;Precedence declaration"
                     class="syntax">&rarr;&nbsp;Syntax&nbsp;&sect;A.8</a></div>
               <p>If multiple callins from the same team refer to the same base method and also have the same 
                  	callin modifier (<code>before</code>, <code>after</code> or <code>replace</code>), the order in which 
                  	the callin bindings shall be triggered has to be declared using a precedence declaration.
                  		
               </p>
               <div class="subsect depth3" id="s4.8.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Precedence declaration</span><a class="img" href="s4.8.a.html"
                        title="PermaLink to (a)&nbsp;Precedence declaration"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>A precedence declaration consists of the keyword <code>precedence</code> followed by 
                     		a list of names referring to callin bindings (see <a href="#s4.1.e" title="&sect;4.1.(e)&nbsp;Named callin binding" class="sect">&sect;4.1.(e)</a> for named callin bindings).
                     		
                  </p>
                  <div class="listing plain"><pre><b>precedence</b> callinBinding1, callinBinding2;</pre></div>
                  <p>
                     	A precedence declaration is only legal within a role or team class.<br />
                     	The order of elements in a precedence declaration determines their <strong>priority</strong> during dispatch,
                     	similar to priorities based on activation of several team instances (<a href="s5.1.html" title="&sect;5.1&nbsp;Effect of team activation"
                        class="sect">&sect;5.1</a>).
                     	This means that <code>before</code> and <code>replace</code> binding with highest priority trigger first, 
                     	whereas <code>after</code> bindings with highest priority trigger last.
                     	For binding precedences (as opposed to class based precedence, see <a href="#s4.8.c" title="&sect;4.8.(c)&nbsp;Class based precedence"
                        class="sect">&sect;4.8.(c)</a> below)
                     	which refer to <code>after</code> bindings, the precedence declaration must also use the <code>after</code> keyword
                     	to remind the programmer that the execution order is inverse to the textual order.
                     			
                  </p>
                  <div class="listing plain"><pre><b>precedence</b> <b>after</b> importantExecuteLast, lessImportantExecuteEarlier;</pre></div>
               </div>
               <div class="subsect depth3" id="s4.8.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Qualified and unqualified names</span><a class="img" href="s4.8.b.html"
                        title="PermaLink to (b)&nbsp;Qualified and unqualified names"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Within a role class a callin binding may be referenced by its unqualified name. 
                     		A precedence declaration in a team class must qualify the callin name with the name of the declaring 
                     		role class. A team with nested teams may concat role class names. 
                     		Elements of a qualified callin name are separated by ".".
                     		<br />
                     The callin binding must be found in the role specified by the qualifying prefix or 
                     in the enclosing role for unqualified names, or any super class of this role 
                     (including implicit super classes <a href="s1.3.1.html"
                        title="&sect;1.3.1&nbsp;Acquisition and implicit inheritance of role classes"
                        class="sect">&sect;1.3.1</a>).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Class based precedence</span><a class="img" href="s4.8.c.html"
                        title="PermaLink to (c)&nbsp;Class based precedence"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>At the team level a precedence declaration may contain role class names without 
                     		explicitly mentioning callin bindings in order to refer to all callin bindings of the role.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Multiple precedence statements</span><a class="img" href="s4.8.d.html"
                        title="PermaLink to (d)&nbsp;Multiple precedence statements"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>All precedence statements are collected at the outer-most team. At that level all 
                     		precedence declarations involving the same base method are merged using the 
                     		C3 algorithm <a href="#fn3-c3-algorithm" class="int">[3]</a>.
                     		When merging precendence declarations more deeply nested declarations have higher priority
                     		than outer declarations. 
                     		For several declarations at the same nesting level the lexical ordering determines the priority. 
                     			
                  </p>
                  <p>
                     		At any point the C3 algorithm will ensure that the resulting order after merging is consistent
                     		with each individual precedence declaration.
                     		It is an error to declare 
                     		incompatible precedence lists that cannot be merged by the C3 algorithm.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.8.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">Binding overriding</span><a class="img" href="s4.8.e.html"
                        title="PermaLink to (e)&nbsp;Binding overriding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>Precedence declarations may conflict with overriding of callin bindings 
                     		(see <a href="#s4.1.e" title="&sect;4.1.(e)&nbsp;Named callin binding" class="sect">&sect;4.1.(e)</a>): For each pair of callin bindings of which one 
                     		callin binding overrides the other one, precedence declarations are not applicable, 
                     		since dynamic binding will already select exactly one callin binding.
                     		<br />
                     		It is an error to <i>explicitly mention</i> such a pair of overriding callin bindings in a precedence declaration.
                     		<br />
                     		When a class-based precedence declaration <i>implicitly refers to</i> a callin binding that is overridden by, 
                     		or overrides any other callin binding within the same precedence declaration, this does not affect the fact, 
                     		that the most specific callin binding overrides less specific ones.
                     			
                  </p>
               </div>
               <h5 class="listing">Callin binding example</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>class</b> LogLog<b>in</b> <b>playedBy</b> Data<b>base</b> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>callin</b> <b>void</b> log (String what) {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    System.out.println("enter " + what);</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>    base.log(what.toLowerCase());</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">5</td>
                        <td><pre>    System.out.println("leave " + what);</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>void</b> log(String what) <b>&lt;-</b> <b>replace</b> <b>void</b> login(String uid, String passwd) </pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    <b>with</b> { what <b>&lt;-</b> uid }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>(<b>new</b> Database()).login("Admin", "Passwd");</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>Effects:</h5>
                  <p>Provided the callin bindings are active (cf. <a href="s5.html" title="&sect;5&nbsp;Team Activation" class="sect">&sect;5</a>) then:
                     			
                  </p>
                  <ul>
                     <li>the call in line 10 is intercepted by method <code>log</code>
                        						of role <code>LogLogin</code>.
                     </li>
                     <li>the call target of <code>log</code> is a role of type
                        						<code>LogLogin</code> which is created by lifting the
                        						original call target (of type <code>Database</code>) to
                        						<code>LogLogin</code>.
                     </li>
                     <li>only parameter <code>uid</code> is passed to <code>log</code>
                        						(bound to formal parameter <code>what</code>).
                     </li>
                     <li>within method <code>log</code> the base call (line 4) invokes 
                        						the original method passing a modified uid (converted to lower case, cf. line 4) 
                        						and the unmodified password, which is hidden from the callin method due to the
                        						parameter mapping in line 8.
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="s4.9">
               <h2 class="sect">&sect;4.9&nbsp;Callin inheritance<a class="img" href="s4.9.html"
                     title="PermaLink to &sect;4.9&nbsp;Callin inheritance"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <p>
                  			This section defines how callin bindings and callin methods relate to inheritance.
                  		
               </p>
               <div class="sect depth3" id="s4.9.1">
                  <h3 class="sect">&sect;4.9.1&nbsp;Base side inheritance<a class="img" href="s4.9.1.html"
                        title="PermaLink to &sect;4.9.1&nbsp;Base side inheritance"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a><span class="toplink"><a href="#s4.9">&uarr;&nbsp;&sect;4.9</a></span></h3>
                  <p>
                     				Generally, a callin binding affects all sub-types of its bound base.
                     				Specifically, if a role type <code>R</code> bound to a base type <code>B</code> 
                     				defines a callin binding <code>rm &lt;- <i>callin_modifier</i> bm</code>,
                     				the following rules apply:
                     			
                  </p>
                  <div class="subsect depth4" id="s4.9.1.a">
                     <h4 class="subsect">(a)&nbsp;<span class="title">Effect on sub-classes</span><a class="img" href="s4.9.1.a.html"
                           title="PermaLink to (a)&nbsp;Effect on sub-classes"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                                alt="" /></a></h4>
                     <p>The callin binding also effects instances of any type <code>BSub</code> 
                        	that is a sub-type of <code>B</code>.
                        	If <code>BSub</code> overrides the bound base method <code>bm</code>,
                        	the overridden version is generally affected, too.
                        	However, if <code>bm</code> covariantly redefines the return type from its
                        	super version, the callin binding has to explicitly specify if the covariant
                        	sub-class version should be affected, too (see <a href="#s4.9.3.b"
                           title="&sect;4.9.3.(b)&nbsp;Capturing covariant base methods"
                           class="sect">&sect;4.9.3.(b)</a>).
                        
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.1.b">
                     <h4 class="subsect">(b)&nbsp;<span class="title">No effect on super-classes</span><a class="img" href="s4.9.1.b.html"
                           title="PermaLink to (b)&nbsp;No effect on super-classes"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                                alt="" /></a></h4>
                     <p>The binding never affects an instance of any super-type of <code>B</code> 
                        	                even if the method <code>bm</code> is inherited from a super-class 
                        	                or overrides an inherited method. 
                        	                This ensures that dispatching to a role method due to a callin binding 
                        	                always provides a base instance that has at least the type declared in the role's 
                        	                <code>playedBy</code> clause.
                        
                     </p>
                  </div>
                  <p>
                     For corresponding definitions regarding static methods see <a href="#s4.7.e" title="&sect;4.7.(e)&nbsp;No overriding" class="sect">&sect;4.7.(e)</a>.
                     			
                  </p>
               </div>
               <div class="sect depth3" id="s4.9.2">
                  <h3 class="sect">&sect;4.9.2&nbsp;Role side inheritance<a class="img" href="s4.9.2.html"
                        title="PermaLink to &sect;4.9.2&nbsp;Role side inheritance"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a><span class="toplink"><a href="#s4.9">&uarr;&nbsp;&sect;4.9</a></span></h3>
                  <p>
                     	Any sub-type of <code>R</code> inherits the given callin binding 
                     	(for overriding of bindings see <a href="#s4.8.e" title="&sect;4.8.(e)&nbsp;Binding overriding" class="sect">&sect;4.8.(e)</a>).
                     If the sub-role overrides the role method <code>rm</code> this will be considered 
                     for dynamic dispatch when the callin binding is triggered.
                     
                  </p>
               </div>
               <div class="sect depth3" id="s4.9.3">
                  <h3 class="sect">&sect;4.9.3&nbsp;Covariant return types<a class="img" href="s4.9.3.html"
                        title="PermaLink to &sect;4.9.3&nbsp;Covariant return types"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a><span class="toplink"><a href="#s4.9">&uarr;&nbsp;&sect;4.9</a></span></h3>
                  <p>
                     				Since version 5, Java supports the covariant redefinition of a method's return type 
                     				(see <a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.5"
                        class="ext">JLS 8.4.5</a>).
                     				This is <em>not</em> supported for <code>callin</code> methods (<a href="#s4.9.3.a" title="&sect;4.9.3.(a)&nbsp;No covariant callin methods"
                        class="sect">&sect;4.9.3.(a)</a>). 
                     				If base methods with covariant redefinition of the return type are to be bound by a callin binding
                     				the subsequent rules ensure that type safety is preserved.
                     				Two <em>constraints</em> have to be considered: 
                     			
                  </p>
                  <ol>
                     <li>
                        					When a callin method issues a base-call or calls its tsuper version, 
                        					this call must produce a value whose type is compatible to the 
                        					enclosing method's declared return type.
                        				
                     </li>
                     <li>
                        					If a replace-bound role method returns a value that is not the result of a base-call,
                        					it must be ensured that the return value actually satisfies the declared signature of 
                        					the bound base method.
                        				
                     </li>
                  </ol>
                  <div class="subsect depth4" id="s4.9.3.a">
                     <h4 class="subsect">(a)&nbsp;<span class="title">No covariant callin methods</span><a class="img" href="s4.9.3.a.html"
                           title="PermaLink to (a)&nbsp;No covariant callin methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                                alt="" /></a></h4>
                     <p>
                        					A method declared with the <code>callin</code> modifier that overrides an inherited method
                        					must not redefine the return type with respect to the inherited method.
                        					This reflects that fact that an inherited callin binding should remain type-safe
                        					while binding to the new, overriding role method.
                        					Binding a covariant role method to the original base method would break constraint (1) above.
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.3.b">
                     <h4 class="subsect">(b)&nbsp;<span class="title">Capturing covariant base methods</span><a class="img" href="s4.9.3.b.html"
                           title="PermaLink to (b)&nbsp;Capturing covariant base methods"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                                alt="" /></a></h4>
                     <p>
                        					If a callin binding should indeed affect not only the specified base method
                        					but also overriding versions which covariantly redefine the return type,
                        					the binding must specify the base method's return type with a "+" appended
                        					to the type name as in
                     </p>
                     <div class="listing plain"><pre><b>void</b> rm() <b>&lt;-</b> <b>before</b> <em>RT+</em> bm();</pre></div>
                     <p>Without the "+" sign the binding would only capture base methods whose
                        					return type is exactly <code>RT</code>;
                        					by appending "+" also sub-types of <code>RT</code>
                        					are accepted as the declared return type.
                        				
                     </p>
                  </div>
                  <div class="subsect depth4" id="s4.9.3.c">
                     <h4 class="subsect">(c)&nbsp;<span class="title">Covariant replace binding</span><a class="img" href="s4.9.3.c.html"
                           title="PermaLink to (c)&nbsp;Covariant replace binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                                alt="" /></a></h4>
                     <p>
                        					When using the syntax of <a href="#s4.9.3.b"
                           title="&sect;4.9.3.(b)&nbsp;Capturing covariant base methods"
                           class="sect">&sect;4.9.3.(b)</a> to capture base methods with
                        					covariant return types in a callin binding with the <code>replace</code> modifier,
                        					the role method must be specified using a free type parameter as follows:
                     </p>
                     <div class="listing plain"><pre><em>&lt;E <b>extends</b> RT&gt; E</em> rm() <b>&lt;-</b> <b>replace</b> RT+ bm();</pre></div>
                     <p>The role method <code>rm</code> referenced by this callin binding must use the same style 
                        	of return type using a type parameter.
                        	                The only possible non-null value of type <code>E</code> 
                        	                to be returned from such method is the value provided by a base-call or a tsuper-call.<br />
                        	                This rule enforces the constraint (2) above.<br />
                        	                Note that this rule is further generalized in <a href="#s4.10" title="&sect;4.10&nbsp;Generic callin bindings" class="sect">&sect;4.10</a>.
                        				
                     </p>
                     <h5 class="listing">Binding a parametric role method</h5>
                     <div class="listing example frame">
                        <table class="listing">
                           <tr class="line odd">
                              <td class="ln">1</td>
                              <td><pre><b>public</b> <b>class</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">2</td>
                              <td><pre>    SuperBase foo() { <b>return</b> this; }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">3</td>
                              <td><pre>    <b>void</b> check() { System.out.print("OK"); }</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">4</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">5</td>
                              <td><pre><b>public</b> <b>class</b> SubBase <b>extends</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">6</td>
                              <td><pre>    @Override</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">7</td>
                              <td><pre>    SubBase foo() { <b>return</b> this; }</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">8</td>
                              <td><pre>    <b>void</b> print() { System.out.print("SubBase"); }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">9</td>
                              <td><pre>    String test() { </pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">10</td>
                              <td><pre>        this.foo().print(); <span class="comment">// print() requires a SubBase</span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">11</td>
                              <td><pre>    }</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">12</td>
                              <td><pre>}</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">13</td>
                              <td><pre></pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">14</td>
                              <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeam {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">15</td>
                              <td><pre>    <b>protected</b> <b>class</b> R <b>playedBy</b> SuperBase {</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">16</td>
                              <td><pre>        <b>callin</b> &lt;E <b>extends</b> SuperBase&gt; E ci() {</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">17</td>
                              <td><pre>			E result= base.ci();</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">18</td>
                              <td><pre>			result.check(); <span class="comment">// check() is available on E via type bound SuperBase</span></pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">19</td>
                              <td><pre>			<b>return</b> result;</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">20</td>
                              <td><pre>        }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">21</td>
                              <td><pre>        &lt;E <b>extends</b> SuperBase&gt; E  ci() <b>&lt;-</b> <b>replace</b> SuperBase+ foo();</pre></td>
                           </tr>
                           <tr class="line even">
                              <td class="ln">22</td>
                              <td><pre>    }</pre></td>
                           </tr>
                           <tr class="line odd">
                              <td class="ln">23</td>
                              <td><pre>}</pre></td>
                           </tr>
                        </table>
                     </div>
                     <div class="codecomment">
                        <h5>Explanation:</h5>
                        <ul>
                           <li>
                              							Method <code>SubBase.foo</code> in line 7 redefines the return type
                              							from <code>SuperBase</code>	(inherited version) to <code>SubBase</code>,
                              							thus clients like the method call in line 10 must be safe to assume
                              							that the return value will always conform to <code>SubBase</code>.
                              						
                           </li>
                           <li>
                              							The callin binding in line 21 explicitly captures both versions of <code>foo</code>
                              							by specifying <code>SuperBase+</code> as the expected return type.
                              							Thus, if an instance of <code>MyTeam</code> is active at the method call
                              							in line 10, this call to <code>foo</code> will indeed be intercepted
                              							even though this call is statically known to return a value of type <code>SubBase</code>.
                              						
                           </li>
                           <li>
                              							The callin method in lines 16-20 has a return type which is not known statically,
                              							but the return type is represented by the type variable <code>E</code>.
                              							Since the base call is known to have the exact same signature as its enclosing
                              							method, the value provided by the base call is of the same type <code>E</code>
                              							and thus can be safely returned from <code>ci</code>.
                              							<em>Note,</em> that no other non-null value is known to have the type <code>E</code>.
                              						
                           </li>
                           <li>
                              							By specifying <code>SuperBase</code> as an upper bound for the type <code>E</code>
                              							the callin method <code>ci</code> may invoke 
                              							any method declared in type <code>SuperBase</code>
                              							on any value of type <code>E</code>. For an example see the call to <code>check</code>
                              							in line 18.
                              						
                           </li>
                        </ul>
                        <p><em>
                              							As an aside note that the above example uses type <code>SuperBase</code>
                              							in an undisciplined way: within role <code>R</code> this type is bound
                              							using <code>playedBy</code><strong> and</strong> the same type is also
                              							used directly (as the upper bound for <code>E</code>).
                              							This is considered bad style and it is prohibited if <code>SuperBase</code>
                              							is imported using an base import (<a href="s2.1.2.d.html" title="&sect;2.1.2.(d)&nbsp;Base imports" class="sect">&sect;2.1.2.(d)</a>).
                              							Here this rule is neglegted just for the purpose of keeping the example small.
                              						</em></p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s4.10">
               <h2 class="sect">&sect;4.10&nbsp;Generic callin bindings<a class="img" href="s4.10.html"
                     title="PermaLink to &sect;4.10&nbsp;Generic callin bindings"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                          alt="" /></a><span class="toplink"><a href="#top">&uarr;&nbsp;&sect;4</a></span></h2>
               <p>
                  			As mentioned in <a href="#s4.5.d" title="&sect;4.5.(d)&nbsp;Typing rules" class="sect">&sect;4.5.(d)</a> replace bindings do not support subtype polymorphism
                  			in either direction.
                  			On the other hand, binding several base methods to the same <code>callin</code> method
                  			may require some more flexibility if these base methods have different signatures.
                  			This is where type parameter come to the rescue to allow for generic <code>callin</code> methods
                  			and	their binding to base methods with different signatures.<br />
                  			Note that this rule is a generalization of rule <a href="#s4.9.3.c" title="&sect;4.9.3.(c)&nbsp;Covariant replace binding"
                     class="sect">&sect;4.9.3.(c)</a>.
                  		
               </p>
               <p>
                  			Additionally, any callin binding (before,replace,after) may declare one or more type parameters
                  			for propagating type parameters of the bound base method(s) (<a href="#s4.10.e" title="&sect;4.10.(e)&nbsp;Propagating type parameters"
                     class="sect">&sect;4.10.(e)</a>).
                  		
               </p>
               <div class="subsect depth3" id="s4.10.a">
                  <h4 class="subsect">(a)&nbsp;<span class="title">Fresh type parameter</span><a class="img" href="s4.10.a.html"
                        title="PermaLink to (a)&nbsp;Fresh type parameter"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>
                     			If a callin method declares a type parameter <code>&lt;T&gt;</code> for
                     			capturing a covariant return type
                     			this type <code>T</code>
                     			can be used for specifying the type of exactly one parameter or the return type.
                     			If a type parameter is used in more than one position of a <code>callin</code> method
                     			it is not considered a <em>fresh type parameter</em>
                     			and can thus not be bound to a covariant return type (see <a href="#s4.10.d" title="&sect;4.10.(d)&nbsp;Binding to a type parameter"
                        class="sect">&sect;4.10.(d)</a>).
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.10.b">
                  <h4 class="subsect">(b)&nbsp;<span class="title">Type bounds</span><a class="img" href="s4.10.b.html" title="PermaLink to (b)&nbsp;Type bounds"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>
                     			The type parameter of a callin binding may be bounded by an upper bound as in <code>&lt;T extends C&gt;</code>.
                     			In this case <code>T</code> can only be instantiated by types conforming to the upper bound <code>C</code>.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.10.c">
                  <h4 class="subsect">(c)&nbsp;<span class="title">Generic replace binding</span><a class="img" href="s4.10.c.html"
                        title="PermaLink to (c)&nbsp;Generic replace binding"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>
                     			A generic <code>callin</code> method according to the above rules is bound using a replace
                     			binding that declares the same number of type parameters,
                     			where type parameters of the binding and its callin method are identified.
                     			If the <code>callin</code> method declares bounds for its type parameters
                     			so should the replace binding.
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s4.10.d">
                  <h4 class="subsect">(d)&nbsp;<span class="title">Binding to a type parameter</span><a class="img" href="s4.10.d.html"
                        title="PermaLink to (d)&nbsp;Binding to a type parameter"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>
                     			A fresh type parameter can be used to capture arbitrary types in the base methods to be bound.
                     			The type parameter may be instantiated differently for each bound base method.
                     			By such type parameter instantiation the types in role and base signatures are actually identical,
                     			thus satisfying the requirement of two-way substitutability.
                     			
                  </p>
               </div>
               <p>
                  			Within the body of a generic <code>callin</code> method no further rules have to be followed,
                  			because the fresh type variable actually guarantees, that the role method cannot replace the
                  			original value (initial argument or base-call result) with a different object,
                  			because no type exists that is guaranteed to conform to the type parameters.
                  			Yet, the type bound allows the role method to invoke methods of the provided object.
                  		
               </p>
               <h5 class="listing">Generic replace binding</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>public</b> <b>team</b> <b>class</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>    <b>protected</b> <b>class</b> R <b>playedBy</b> Figures {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>        <b>callin</b> &lt;E <b>extends</b> Shape, F <b>extends</b> Shape&gt; E ci(F arg) {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>            E result= base.ci(arg);</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">5</td>
                        <td><pre>            <span class="error">result= arg; // illegal, types E and F are incommensurable</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>            <span class="error">arg= result; // illegal, types E and F are incommensurable</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>            <b>int</b> size= arg.getSize(); <span class="comment">// getSize() is availabel on F via type bound Shape</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>            result.resize(size); <span class="comment">    // resize() is available on E via type bound Shape</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>            <b>return</b> result; <span class="comment">// only two legal values exist: <code>result</code> and <code>null</code></span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>        }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>        &lt;E <b>extends</b> Shape, F <b>extends</b> Shape&gt; </pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>        E  ci(F arg) <b>&lt;-</b> <b>replace</b> Rectangle getBoundingBox(Shape original), </pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre>                                Rectangle stretch(Square original);</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>    }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>Explanation:</h5>
                  			These declaration generate two version of the <code>callin</code> method <code>ci</code>:
                  			
                  <ol>
                     <li><code>Rectangle ci (Shape arg)</code></li>
                     <li><code>Rectangle ci (Square arg)</code></li>
                  </ol>
                  			Within the <code>callin</code> method the following observations hold:
                  			
                  <ul>
                     <li>Line 5 is illegal for the first signature as <code>Shape</code> is not conform to <code>Rectangle</code></li>
                     <li>Line 6 is illegal for the second signature as <code>Rectangle</code> is not conform to <code>Square</code></li>
                     <li>Everything else is type-safe.</li>
                  </ul>
               </div>
               <div class="subsect depth3" id="s4.10.e">
                  <h4 class="subsect">(e)&nbsp;<span class="title">Propagating type parameters</span><a class="img" href="s4.10.e.html"
                        title="PermaLink to (e)&nbsp;Propagating type parameters"><img style="vertical-align:text-top;margin-left:5px;" src="../images/permalink.png"
                             alt="" /></a></h4>
                  <p>
                     				If a callin binding binds to a generic base method, 
                     				any type parameter(s) of the base method must be propagated into the role method 
                     				by declaring the callin binding with type parameters, too.
                     				By matching a type parameter of a base method with a type variable
                     				of the callin binding, this genericity is propagated through the callin binding.
                     			
                  </p>
                  <div class="listing  frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>class</b> MyBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>	&lt;T&gt; T getIt(T it) { <b>return</b> it; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre><b>team</b> <b>class</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">5</td>
                           <td><pre>	<b>protected</b> <b>class</b> MyRole <b>playedBy</b> MyBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>		<b>callin</b> &lt;U&gt; U rm(U a) { <b>return</b> base.rm(a); }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>		&lt;U&gt; U rm(U a) <b>&lt;-</b> <b>replace</b> U getIt(U it);</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>	}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>Explanation:</h5>
                     				The callin binding declares a type parameter <code>&lt;U&gt;</code>
                     				which is used to match all occurrences of <code>T</code> in the signature of <code>getIt</code>.
                     				Thus the implementation of <code>rm</code> uses the type <code>U</code>
                     				in exactly the same generic way as <code>getIt</code> uses <code>T</code>.
                     			
                  </div>
               </div>
            </div>
            <div class="aux" id="aux4.2">
               <h4 class="aux">Open issues:<span class="toplink"><a href="#s4">&uarr;&nbsp;&sect;4</a></span></h4>
               <p>The query language for specifying sets of base methods (<a href="#s4.1.d" title="&sect;4.1.(d)&nbsp;Multiple base methods"
                     class="sect">&sect;4.1.(d)</a>)
                  		has not been finalized yet. In this version of the OTJLD <a href="s8.html" title="&sect;8&nbsp;Join Point Queries" class="sect">&sect;8</a> 
                  		acts as a placeholder for the section that will define a join point query language in the future.
               </p>
            </div>
            <div class="aux" id="aux4.1">
               <h4 class="aux">References:<span class="toplink"><a href="#s4">&uarr;&nbsp;&sect;4</a></span></h4>
               <p id="fn3-c3-algorithm">
                  			[3] Kim Barrett, Bob Cassels, Paul Haahr, David A. Moon, Keith Playford, P. Tucker Withington. <em>A monotonic superclass linearization for Dylan</em>. OOPSLA '96: Proceedings of the 11th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications,
                  pages 69-82, 1996.
                  		
               </p>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s3.html" rel="prev">&lt;&lt;&nbsp;&sect;3&nbsp;Callout Binding</a></td>
               <td class="top"><a href="index.html" rel="contents">&uarr;&nbsp;Table of Contents&nbsp;&uarr;</a></td>
               <td class="next"><a href="s5.html" rel="next">&sect;5&nbsp;Team Activation&nbsp;&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr /><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer"
            shape="rect"><img src="../images/valid-css2-blue.png" alt="Valid CSS!" height="31" width="88" /></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="Valid XHTML 1.0 Strict" height="31"
                 width="88" /></a><address>&copy; Stephan Herrmann, Christine Hundt, Marco Mosconi</address>
         			OT/J version 1.3.1 &mdash; last modified: 2013-05-28
      </div>
   </body>
</html>