<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="There are various maintenance operations that can be performed on partitioned tables and indexes.">
      <meta name="description" content="There are various maintenance operations that can be performed on partitioned tables and indexes.">
      <title>Maintenance Operations for Partitioned Tables and Indexes</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="VLDB and Partitioning Guide">
      <meta property="og:description" content="There are various maintenance operations that can be performed on partitioned tables and indexes.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="VLDB and Partitioning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00">
      <meta name="dcterms.title" content="VLDB and Partitioning Guide">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96199-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="maintenance-partition-can-be-performed.html" title="Previous" type="text/html">
      <link rel="next" href="drop-partition-table.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="maintenance-partition-can-be-performed.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="drop-partition-table.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB and Partitioning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-admin.html" property="item" typeof="WebPage"><span property="name">Partition Administration</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Maintenance Operations for Partitioned Tables and Indexes</li>
            </ol>
            <a id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED" name="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED"></a><a id="VLDBG1118"></a>
            
            <h2 id="VLDBG-GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED" class="sect2">Maintenance Operations for Partitioned Tables and Indexes</h2>
         </header>
         <div class="ind">
            <div>
               <p>There are various maintenance operations that can be performed on partitioned tables and indexes.</p>
               <p>The operations to perform partition and subpartition maintenance for both tables and indexes are discussed in the following topics.</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" title="This section introduces how to manually add new partitions to a partitioned table and explains why partitions cannot be specifically added to most partitioned indexes.">About Adding Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" title="Coalescing partitions is a way of reducing the number of partitions in a hash partitioned table or index, or the number of subpartitions in a *-hash partitioned table.">About Coalescing Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" title="You can drop partitions from range, interval, list, or composite *-[range | list] partitioned tables.">About Dropping Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" title="You can convert a partition or subpartition into a nonpartitioned table, and a nonpartitioned table into a partition or subpartition of a partitioned table by exchanging their data segments.">About Exchanging Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" title="Use the ALTER TABLE MERGE PARTITION and SUBPARTITION SQL statements to merge the contents of two partitions or subpartitions.">About Merging Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" title="The modification of attributes of tables, partitions, and subpartitions is introduced in this topic.">About Modifying Attributes of Tables, Partitions, and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" title="The modification of values in list partitions and subpartitions is introduced in this topic.">About Modifying List Partitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-763391C6-44E8-401D-8119-DC12926F5877" title="You can change the partitioning strategy of a regular (heap-organized) table with the ALTER TABLE MODIFY PARTITION SQL statement.">About Modifying the Partitioning Strategy</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" title="Use the MOVE PARTITION clause of the ALTER TABLE statement to change the physical storage attributes of a partition.">About Moving Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" title="Rebuilding an index provides several advantages.">About Rebuilding Index Partitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" title="You can rename partitions and subpartitions of both tables and indexes.">About Renaming Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" title="You can split the contents of a partition into two new partitions.">About Splitting Partitions and Subpartitions</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" title="Truncating a partition is similar to dropping a partition, except that the partition is emptied of its data, but not physically dropped.">About Truncating Partitions and Subpartitions</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED__GUID-538B4FB5-ECC3-411B-9856-8AE374231641">
                  <p class="notep1">Note:</p>
                  <p>Where the usability of indexes or index partitions affected by the maintenance operation is discussed, consider the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Only indexes and index partitions that are <span class="italic">not</span> empty are candidates for being marked <code class="codeph">UNUSABLE</code>. If they are empty, the <code class="codeph">USABLE</code>/<code class="codeph">UNUSABLE</code> status is left unchanged.
                        </p>
                     </li>
                     <li>
                        <p>Only indexes or index partitions with <code class="codeph">USABLE</code> status are updated by subsequent DML.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="infoboxnotealso" id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED__GUID-848BF461-57B6-4FBC-BA7C-8A5D53C6BBD2">
                  <p class="notep1">See Also:</p>
                  <p></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="../admin/managing-tables.html#ADMIN015" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for information about managing tables
                        </p>
                     </li>
                     <li>
                        <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the exact syntax of the partitioning clauses for altering partitioned tables and indexes, any restrictions on their use, and specific privileges required for creating and altering tables
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1125"></a><div class="props_rev_3"><a id="GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" name="GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB"></a><h3 id="VLDBG-GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" class="sect3">About Adding Partitions and Subpartitions</h3>
               <div>
                  <p>This section introduces how to manually add new partitions to a partitioned table and explains why partitions cannot be specifically added to most partitioned indexes.</p>
                  <p></p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7205A9-5D01-4642-B7E9-02406200493E" title="You can add a partition after the last existing partition of a table or the beginning of a table or in the middle of a table.">Adding a Partition to a Range-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" title="When you add a partition to a hash partitioned table, the database populates the new partition with rows rehashed from an existing partition (selected by the database) as determined by the hash function.">Adding a Partition to a Hash-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" title="The example in this topic shows how to add a partition to a list-partitioned table.">Adding a Partition to a List-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-497B9404-C945-4665-B9B6-C67385785BD3" title="You cannot explicitly add a partition to an interval-partitioned table. The database automatically creates a partition for an interval when data for that interval is inserted.">Adding a Partition to an Interval-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" title="Partitions can be added at both the partition level and at the hash subpartition level.">About Adding Partitions to a Composite *-Hash Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" title="Partitions can be added at both the partition level and at the list subpartition level.">About Adding Partitions to a Composite *-List Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" title="Partitions can be added at both the partition level and at the range subpartition level.">About Adding Partitions to a Composite *-Range Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" title="A partition or subpartition can be added to a parent table in a reference partition definition just as partitions and subpartitions can be added to a range, hash, list, or composite partitioned table.">About Adding a Partition or Subpartition to a Reference-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" title="You cannot explicitly add a partition to a local index. Instead, a new partition is added to a local index only when you add a partition to the underlying table.">Adding Index Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" title="You can add multiple new partitions and subpartitions with the ADD PARTITION and ADD SUBPARTITION clauses of the ALTER TABLE statement.">Adding Multiple Partitions</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1126"></a><div class="props_rev_3"><a id="GUID-0E7205A9-5D01-4642-B7E9-02406200493E" name="GUID-0E7205A9-5D01-4642-B7E9-02406200493E"></a><h4 id="VLDBG-GUID-0E7205A9-5D01-4642-B7E9-02406200493E" class="sect4">Adding a Partition to a Range-Partitioned Table</h4>
                  <div>
                     <p>You can add a partition after the last existing partition of a table or the beginning of a table or in the middle of a table.</p>
                     <div class="section">
                        <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> statement to add a new partition to the "high" end (the point after the last existing partition). To add a partition at the beginning or in the middle of a table, use the <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> clause.
                        </p>
                        <p>For example, consider the table, <code class="codeph">sales</code>, which contains data for the current month in addition to the previous 12 months. On January 1, 1999, you add a partition for January, which is stored in tablespace <code class="codeph">tsx</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
      ADD PARTITION jan99 VALUES LESS THAN ( '01-FEB-1999' )
      TABLESPACE tsx;
</pre><p>Local and global indexes associated with the range-partitioned table remain usable.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1127"></a><div class="props_rev_3"><a id="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" name="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57"></a><h4 id="VLDBG-GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" class="sect4">Adding a Partition to a Hash-Partitioned Table</h4>
                  <div>
                     <p>When you add a partition to a hash partitioned table, the database populates the new partition with rows rehashed from an existing partition (selected by the database) as determined by the hash function.</p>
                     <div class="section">
                        <p>Consequently, if the table contains data, then it may take some time to add a hash partition. </p>
                        <p>The following statements show two ways of adding a hash partition to table <code class="codeph">scubagear</code>. Choosing the first statement adds a new hash partition whose partition name is system generated, and which is placed in the default tablespace. The second statement also adds a new hash partition, but that partition is explicitly named <code class="codeph">p_named</code> and is created in tablespace <code class="codeph">gear5</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear ADD PARTITION;

ALTER TABLE scubagear
      ADD PARTITION p_named TABLESPACE gear5;
</pre><p>Indexes may be marked <code class="codeph">UNUSABLE</code> as explained in the following table:
                        </p>
                        <div class="tblformal" id="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57__GUID-9E1855CE-813A-44F7-A491-5BAB8EEBEA66">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="23%" id="d29958e669">Table Type</th>
                                    <th align="left" valign="bottom" width="77%" id="d29958e672">Index Behavior</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d29958e677" headers="d29958e669 ">
                                       <p>Regular (Heap)</p>
                                    </td>
                                    <td align="left" valign="top" width="77%" headers="d29958e677 d29958e672 ">
                                       <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> as part of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement:
                                       </p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>The local indexes for the new partition, and for the existing partition from which rows were redistributed, are marked <code class="codeph">UNUSABLE</code> and must be rebuilt. 
                                             </p>
                                          </li>
                                          <li>
                                             <p>All global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code> and must be rebuilt.
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d29958e709" headers="d29958e669 ">
                                       <p>Index-organized</p>
                                    </td>
                                    <td align="left" valign="top" width="77%" headers="d29958e709 d29958e672 ">
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>For local indexes, the behavior is identical to heap tables.</p>
                                          </li>
                                          <li>
                                             <p>All global indexes remain usable.</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1128"></a><div class="props_rev_3"><a id="GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" name="GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D"></a><h4 id="VLDBG-GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" class="sect4">Adding a Partition to a List-Partitioned Table</h4>
                  <div>
                     <p>The example in this topic shows how to add a partition to a list-partitioned table.</p>
                     <div class="section">
                        <p>The following statement illustrates how to add a new partition to a list-partitioned table. In this example, physical attributes and <code class="codeph">NOLOGGING</code> are specified for the partition being added.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE q1_sales_by_region 
   ADD PARTITION q1_nonmainland VALUES ('HI', 'PR')
      STORAGE (INITIAL 20K NEXT 20K) TABLESPACE tbs_3
      NOLOGGING;
</pre><p>Any value in the set of literal values that describe the partition being added must not exist in any of the other partitions of the table. </p>
                        <p>You cannot add a partition to a list-partitioned table that has a default partition, but you can split the default partition. By doing so, you effectively create a new partition defined by the values that you specify, and a second partition that remains the default partition.</p>
                        <p>Local and global indexes associated with the list-partitioned table remain usable.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1129"></a><div class="props_rev_3"><a id="GUID-497B9404-C945-4665-B9B6-C67385785BD3" name="GUID-497B9404-C945-4665-B9B6-C67385785BD3"></a><h4 id="VLDBG-GUID-497B9404-C945-4665-B9B6-C67385785BD3" class="sect4">Adding a Partition to an Interval-Partitioned Table</h4>
                  <div>
                     <p>You cannot explicitly add a partition to an interval-partitioned table. The database automatically creates a partition for an interval when data for that interval is inserted. </p>
                     <div class="section">
                        <p>However, exchanging a partition of an interval-partitioned table that has not been materialized in the data dictionary, meaning to have an explicit entry in the data dictionary beyond the interval definition, you must manually materialize the partition using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">LOCK</code> <code class="codeph">PARTITION</code> command. 
                        </p>
                        <p>To change the interval for future partitions, use the <code class="codeph">SET INTERVAL</code> clause of the <code class="codeph">ALTER TABLE</code> statement. The <code class="codeph">SET INTERVAL</code> clause converts existing interval partitions to range partitions, determines the high value of the defined range partitions, and automatically creates partitions of the specified interval as needed for data that is beyond that high value. As a side effect, an interval-partitioned table does not have the notation of <code class="codeph">MAXVALUES</code>.
                        </p>
                        <p>You also use the <code class="codeph">SET INTERVAL</code> clause to migrate an existing range partitioned or range-* composite partitioned table into an interval or interval-* partitioned table. To disable the creation of future interval partitions, and effectively revert to a range-partitioned table, use an empty value in the <code class="codeph">SET INTERVAL</code> clause. Created interval partitions are transformed into range partitions with their current high values.
                        </p>
                        <p>To increase the interval for date ranges, you must ensure that you are at a relevant boundary for the new interval. For example, if the highest interval partition boundary in your daily interval partitioned table transactions is January 30, 2007 and you want to change to a monthly partition interval, then the following statement results in an error:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE transactions SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH');

ORA-14767: Cannot specify this interval with existing high bounds
</pre><p>You must create another daily partition with a high bound of February 1, 2007 to successfully change to a monthly interval:</p><pre class="oac_no_warn" dir="ltr">LOCK TABLE transactions PARTITION FOR(TO_DATE('31-JAN-2007','dd-MON-yyyy') 
   IN SHARE MODE;

ALTER TABLE transactions SET INTERVAL (NUMTOYMINTERVAL(1,'MONTH');
</pre><p>The lower partitions of an interval-partitioned table are range partitions. You can split range partitions to add more partitions in the range portion of the interval-partitioned table.</p>
                        <p>To disable interval partitioning on the <code class="codeph">transactions</code> table, use:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE transactions SET INTERVAL ();</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1130"></a><div class="props_rev_3"><a id="GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" name="GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8"></a><h4 id="VLDBG-GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" class="sect4">About Adding Partitions to a Composite *-Hash Partitioned Table</h4>
                  <div>
                     <p>Partitions can be added at both the partition level and at the hash subpartition level.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" title="The example in this topic shows how to add a new partition to a [range | list | interval]-hash partitioned table.">Adding a Partition to a *-Hash Partitioned Table</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" title="Use the MODIFY PARTITION ADD SUBPARTITION clause of the ALTER TABLE statement to add a hash subpartition to a [range | list | interval]-hash partitioned table.">Adding a Subpartition to a *-Hash Partitioned Table</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1131"></a><div class="props_rev_3"><a id="GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" name="GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17"></a><h5 id="VLDBG-GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" class="sect5">Adding a Partition to a *-Hash Partitioned Table</h5>
                     <div>
                        <p>The example in this topic shows how to add a new partition to a [range | list | interval]-hash partitioned table.</p>
                        <div class="section">
                           <p>For an interval-hash partitioned table, interval partitions are automatically created. You can specify a <code class="codeph">SUBPARTITIONS</code> clause that lets you add a specified number of subpartitions, or a <code class="codeph">SUBPARTITION</code> clause for naming specific subpartitions. If no <code class="codeph">SUBPARTITIONS</code> or <code class="codeph">SUBPARTITION</code> clause is specified, then the partition inherits table level defaults for subpartitions. For an interval-hash partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.
                           </p>
                           <p>This example adds a range partition <code class="codeph">q1_2000</code> to the range-hash partitioned table <code class="codeph">sales</code>, which is populated with data for the first quarter of the year 2000. There are eight subpartitions stored in tablespace <code class="codeph">tbs5</code>. The subpartitions cannot be set explicitly to use table compression. Subpartitions inherit the compression attribute from the partition level and are stored in a compressed form in this example:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD PARTITION q1_2000
      VALUES LESS THAN (2000, 04, 01) COMPRESS
      SUBPARTITIONS 8 STORE IN tbs5;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1132"></a><div class="props_rev_3"><a id="GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" name="GUID-FCD53D58-461E-4555-A8CC-77B2B181232D"></a><h5 id="VLDBG-GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" class="sect5">Adding a Subpartition to a *-Hash Partitioned Table</h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to add a hash subpartition to a [range | list | interval]-hash partitioned table. 
                        </p>
                        <div class="section">
                           <p>The newly added subpartition is populated with rows rehashed from other subpartitions of the same partition as determined by the hash function. For an interval-hash partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.</p>
                           <p>In the following example, a new hash subpartition <code class="codeph">us_loc5</code>, stored in tablespace <code class="codeph">us1</code>, is added to range partition <code class="codeph">locations_us</code> in table <code class="codeph">diving</code>. 
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE diving MODIFY PARTITION locations_us
      ADD SUBPARTITION us_locs5 TABLESPACE us1;
</pre><p>Index subpartitions corresponding to the added and rehashed subpartitions must be rebuilt unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>. 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1133"></a><div class="props_rev_3"><a id="GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" name="GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A"></a><h4 id="VLDBG-GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" class="sect4">About Adding Partitions to a Composite *-List Partitioned Table</h4>
                  <div>
                     <p>Partitions can be added at both the partition level and at the list subpartition level.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" title="The example in this topic shows how to add a new partition to a [range | list | interval]-list partitioned table.">Adding a Partition to a *-List Partitioned Table</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" title="Use the MODIFY PARTITION ADD SUBPARTITION clause of the ALTER TABLE statement to add a list subpartition to a [range | list | interval]-list partitioned table.">Adding a Subpartition to a *-List Partitioned Table</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG14071"></a><a id="VLDBG1134"></a><div class="props_rev_3"><a id="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" name="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23"></a><h5 id="VLDBG-GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" class="sect5">Adding a Partition to a *-List Partitioned Table</h5>
                     <div>
                        <p>The example in this topic shows how to add a new partition to a [range | list | interval]-list partitioned table.</p>
                        <div class="section">
                           <p>The database automatically creates interval partitions as data for a specific interval is inserted. You can specify <code class="codeph">SUBPARTITION</code> clauses for naming and providing value lists for the subpartitions. If no <code class="codeph">SUBPARTITION</code> clauses are specified, then the partition inherits the subpartition template. If there is no subpartition template, then a single default subpartition is created.
                           </p>
                           <p>The statement in <a href="maintenance-partition-tables-indexes.html#GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23__CHDJJFDF">Example 4-28</a> adds a new partition to the <code class="codeph">quarterly_regional_sales</code> table that is partitioned by the range-list method. Some new physical attributes are specified for this new partition while table-level defaults are inherited for those that are not specified.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23__CHDJJFDF">
                           <p class="titleinexample">Example 4-28 Adding partitions to a range-list partitioned table</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales 
   ADD PARTITION q1_2000 VALUES LESS THAN (TO_DATE('1-APR-2000','DD-MON-YYYY'))
      STORAGE (INITIAL 20K NEXT 20K) TABLESPACE ts3 NOLOGGING
         (
          SUBPARTITION q1_2000_northwest VALUES ('OR', 'WA'),
          SUBPARTITION q1_2000_southwest VALUES ('AZ', 'UT', 'NM'),
          SUBPARTITION q1_2000_northeast VALUES ('NY', 'VM', 'NJ'),
          SUBPARTITION q1_2000_southeast VALUES ('FL', 'GA'),
          SUBPARTITION q1_2000_northcentral VALUES ('SD', 'WI'),
          SUBPARTITION q1_2000_southcentral VALUES ('OK', 'TX')
         );</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="VLDBG1135"></a><div class="props_rev_3"><a id="GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" name="GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41"></a><h5 id="VLDBG-GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" class="sect5">Adding a Subpartition to a *-List Partitioned Table</h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to add a list subpartition to a [range | list | interval]-list partitioned table.
                        </p>
                        <div class="section">
                           <p>For an interval-list partitioned table, you can only add subpartitions to range or interval partitions that have been materialized.</p>
                           <p>The following statement adds a new subpartition to the existing set of subpartitions in the range-list partitioned table <code class="codeph">quarterly_regional_sales</code>. The new subpartition is created in tablespace <code class="codeph">ts2</code>.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales
   MODIFY PARTITION q1_1999 
      ADD SUBPARTITION q1_1999_south
         VALUES ('AR','MS','AL') tablespace ts2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1136"></a><div class="props_rev_3"><a id="GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" name="GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0"></a><h4 id="VLDBG-GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" class="sect4">About Adding Partitions to a Composite *-Range Partitioned Table</h4>
                  <div>
                     <p>Partitions can be added at both the partition level and at the range subpartition level.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" title="The example in this topic shows how to add a new partition to a [range | list | interval]-range partitioned table.">Adding a Partition to a *-Range Partitioned Table</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-57C6840F-E023-4035-B5B4-00B92168F63F" title="You use the MODIFY PARTITION ADD SUBPARTITION clause of the ALTER TABLE statement to add a range subpartition to a [range | list | interval]-range partitioned table.">Adding a Subpartition to a *-Range Partitioned Table</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG14072"></a><a id="VLDBG1137"></a><div class="props_rev_3"><a id="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" name="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78"></a><h5 id="VLDBG-GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" class="sect5">Adding a Partition to a *-Range Partitioned Table</h5>
                     <div>
                        <p>The example in this topic shows how to add a new partition to a [range | list | interval]-range partitioned table.</p>
                        <div class="section">
                           <p>The database automatically creates interval partitions for an interval-range partitioned table when data is inserted in a specific interval. You can specify a <code class="codeph">SUBPARTITION</code> clause for naming and providing ranges for specific subpartitions. If no <code class="codeph">SUBPARTITION</code> clause is specified, then the partition inherits the subpartition template specified at the table level. If there is no subpartition template, then a single subpartition with a maximum value of <code class="codeph">MAXVALUE</code> is created.
                           </p>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78__CHDHHJHA">Example 4-29</a> adds a range partition <code class="codeph">p_2007_jan</code> to the range-range partitioned table <code class="codeph">shipments</code>, which is populated with data for the shipments ordered in January 2007. There are three subpartitions. Subpartitions inherit the compression attribute from the partition level and are stored in a compressed form in this example:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78__CHDHHJHA">
                           <p class="titleinexample">Example 4-29 Adding partitions to a range-range partitioned table</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE shipments
   ADD PARTITION p_2007_jan
      VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy')) COMPRESS
      ( SUBPARTITION p07_jan_e VALUES LESS THAN (TO_DATE('15-FEB-2007','dd-MON-yyyy'))
      , SUBPARTITION p07_jan_a VALUES LESS THAN (TO_DATE('01-MAR-2007','dd-MON-yyyy'))
      , SUBPARTITION p07_jan_l VALUES LESS THAN (TO_DATE('01-APR-2007','dd-MON-yyyy'))
      ) ;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="VLDBG1138"></a><div class="props_rev_3"><a id="GUID-57C6840F-E023-4035-B5B4-00B92168F63F" name="GUID-57C6840F-E023-4035-B5B4-00B92168F63F"></a><h5 id="VLDBG-GUID-57C6840F-E023-4035-B5B4-00B92168F63F" class="sect5">Adding a Subpartition to a *-Range Partitioned Table</h5>
                     <div>
                        <p>You use the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to add a range subpartition to a [range | list | interval]-range partitioned table.
                        </p>
                        <div class="section">
                           <p> For an interval-range partitioned table, you can only add partitions to range or interval partitions that have been materialized.</p>
                           <p>The following example adds a range subpartition to the <code class="codeph">shipments</code> table that contains all values with an <code class="codeph">order_date</code> in January 2007 and a <code class="codeph">delivery_date</code> on or after April 1, 2007.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE shipments
   MODIFY PARTITION p_2007_jan
      ADD SUBPARTITION p07_jan_vl VALUES LESS THAN (MAXVALUE) ;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1139"></a><div class="props_rev_3"><a id="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" name="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F"></a><h4 id="VLDBG-GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" class="sect4">About Adding a Partition or Subpartition to a Reference-Partitioned Table</h4>
                  <div>
                     <p>A partition or subpartition can be added to a parent table in a reference partition definition just as partitions and subpartitions can be added to a range, hash, list, or composite partitioned table.</p>
                     <p>The add operation automatically cascades to any descendant reference partitioned tables. The <code class="codeph">DEPENDENT TABLES</code> clause can set specific properties for dependent tables when you add partitions or subpartitions to a master table.
                     </p>
                     <div class="infoboxnotealso" id="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F__GUID-B301BA95-7C63-4DC7-BBE8-F989463971E3">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="VLDBG1140"></a><div class="props_rev_3"><a id="GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" name="GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE"></a><h4 id="VLDBG-GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" class="sect4">Adding Index Partitions</h4>
                  <div>
                     <p>You cannot explicitly add a partition to a local index. Instead, a new partition is added to a local index only when you add a partition to the underlying table.</p>
                     <div class="section">
                        <p>Specifically, when there is a local index defined on a table and you issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to add a partition, a matching partition is also added to the local index. The database assigns names and default physical storage attributes to the new index partitions, but you can rename or alter them after the <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> operation is complete.
                        </p>
                        <p>You can effectively specify a new tablespace for an index partition in an <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> operation by first modifying the default attributes for the index. For example, assume that a local index, <code class="codeph">q1_sales_by_region_locix</code>, was created for list partitioned table <code class="codeph">q1_sales_by_region</code>. If before adding the new partition <code class="codeph">q1_nonmainland</code>, as shown in <a href="maintenance-partition-tables-indexes.html#GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" title="The example in this topic shows how to add a partition to a list-partitioned table.">Adding a Partition to a List-Partitioned Table</a>, you had issued the following statement, then the corresponding index partition would be created in tablespace <code class="codeph">tbs_4</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX q1_sales_by_region_locix
   MODIFY DEFAULT ATTRIBUTES TABLESPACE tbs_4;
</pre><p>Otherwise, it would be necessary for you to use the following statement to move the index partition to <code class="codeph">tbs_4</code> after adding it:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX q1_sales_by_region_locix 
   REBUILD PARTITION q1_nonmainland TABLESPACE tbs_4;
 </pre><p>You can add a partition to a hash partitioned global index using the <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> syntax of <code class="codeph">ALTER</code> <code class="codeph">INDEX</code>. The database adds hash partitions and populates them with index entries rehashed from an existing hash partition of the index, as determined by the hash function. The following statement adds a partition to the index <code class="codeph">hgidx</code> shown in <a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="Hash partitioned global indexes can improve the performance of indexes where a small number of leaf blocks in the index have high contention in multiuser OLTP environments.">Creating a Hash Partitioned Global Index</a>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX hgidx ADD PARTITION p5;
</pre><p>You cannot add a partition to a range-partitioned global index, because the highest partition always has a partition bound of <code class="codeph">MAXVALUE</code>. To add a new highest partition, use the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14108"></a><div class="props_rev_3"><a id="GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" name="GUID-676087FC-D6DC-4533-95FD-6DC941CE4753"></a><h4 id="VLDBG-GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" class="sect4">Adding Multiple Partitions</h4>
                  <div>
                     <p>You can add multiple new partitions and subpartitions with the <code class="codeph">ADD</code> <code class="codeph">PARTITION</code> and <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code> clauses of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement.
                     </p>
                     <div class="section">
                        <p> When adding multiple partitions, local and global index operations are the same as when adding a single partition. Adding multiple partitions and subpartitions is only supported for range, list, and system partitions and subpartitions.</p>
                        <p>You can add multiple range partitions that are listed in ascending order of their upper bound values to the high end (after the last existing partition) of a range-partitioned or composite range-partitioned table, provided the <code class="codeph">MAXVALUE</code> partition is not defined. Similarly, you can add multiple list partitions to a table using new sets of partition values if the <code class="codeph">DEFAULT</code> partition does not exist.
                        </p>
                        <p>Multiple system partitions can be added using a single SQL statement by specifying the individual partitions. For example, the following SQL statement adds multiple partitions to the range-partitioned <code class="codeph">sales</code> table created in <a href="partition-create-tables-indexes.html#GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C__CHDJDFAF">Example 4-1</a>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD 
  PARTITION sales_q1_2007 VALUES LESS THAN (TO_DATE('01-APR-2007','dd-MON-yyyy')),
  PARTITION sales_q2_2007 VALUES LESS THAN (TO_DATE('01-JUL-2007','dd-MON-yyyy')),
  PARTITION sales_q3_2007 VALUES LESS THAN (TO_DATE('01-OCT-2007','dd-MON-yyyy')),
  PARTITION sales_q4_2007 VALUES LESS THAN (TO_DATE('01-JAN-2008','dd-MON-yyyy'))
;
</pre><p>You can use the <code class="codeph">BEFORE</code> clause to add multiple new system partitions in relation to only one existing partition. The following SQL statements provide an example of adding multiple individual partitions using the <code class="codeph">BEFORE</code> clause: 
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE system_part_tab1 (number1 integer, number2 integer) 
PARTITION BY SYSTEM
( PARTITION p1,
  PARTITION p2,
  PARTITION p3,
  PARTITION p_last);

ALTER TABLE system_part_tab1 ADD 
  PARTITION p4,
  PARTITION p5,
  PARTITION p6
  BEFORE PARTITION p_last;

SELECT SUBSTR(TABLE_NAME,1,18) table_name, TABLESPACE_NAME, 
   SUBSTR(PARTITION_NAME,1,16) partition_name 
   FROM USER_TAB_PARTITIONS WHERE TABLE_NAME='SYSTEM_PART_TAB1';
TABLE_NAME         TABLESPACE_NAME                PARTITION_NAME
------------------ ------------------------------ ----------------
SYSTEM_PART_TAB1   USERS                          P_LAST
SYSTEM_PART_TAB1   USERS                          P6
SYSTEM_PART_TAB1   USERS                          P5
SYSTEM_PART_TAB1   USERS                          P4
SYSTEM_PART_TAB1   USERS                          P3
SYSTEM_PART_TAB1   USERS                          P2
SYSTEM_PART_TAB1   USERS                          P1</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1141"></a><div class="props_rev_3"><a id="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" name="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483"></a><h3 id="VLDBG-GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" class="sect3">About Coalescing Partitions and Subpartitions</h3>
               <div>
                  <p>Coalescing partitions is a way of reducing the number of partitions in a hash partitioned table or index, or the number of subpartitions in a *-hash partitioned table.</p>
                  <p>When a hash partition is coalesced, its contents are redistributed into one or more remaining partitions determined by the hash function. The specific partition that is coalesced is selected by the database, and is dropped after its contents have been redistributed. If you coalesce a hash partition or subpartition in the parent table of a reference-partitioned table definition, then the reference-partitioned table automatically inherits the new partitioning definition.</p>
                  <p>Index partitions may be marked <code class="codeph">UNUSABLE</code> as explained in the following table:
                  </p>
                  <div class="tblformal" id="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483__GUID-50E6E81C-521D-4F8F-AECA-48EF13EC9DB7">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e2462">Table Type</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e2465">Index Behavior</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e2470" headers="d29958e2462 ">
                                 <p>Regular (Heap)</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e2470 d29958e2465 ">
                                 <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> as part of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Any local index partition corresponding to the selected partition is also dropped. Local index partitions corresponding to the one or more absorbing partitions are marked <code class="codeph">UNUSABLE</code> and must be rebuilt. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>All global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code> and must be rebuilt.
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e2502" headers="d29958e2462 ">
                                 <p>Index-organized</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e2502 d29958e2465 ">
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Some local indexes are marked <code class="codeph">UNUSABLE</code> as noted for heap indexes.
                                       </p>
                                    </li>
                                    <li>
                                       <p>All global indexes remain usable.</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" title="The ALTER TABLE COALESCE PARTITION statement is used to coalesce a partition in a hash partitioned table.">Coalescing a Partition in a Hash Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" title="The ALTER TABLE COALESCE SUBPARTITION statement is used to coalesce a subpartition in a hash partitioned table.">Coalescing a Subpartition in a *-Hash Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" title="You can instruct the database to reduce by one the number of index partitions in a hash partitioned global index using the COALESCE PARTITION clause of ALTER INDEX.">Coalescing Hash Partitioned Global Indexes</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1142"></a><div class="props_rev_3"><a id="GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" name="GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF"></a><h4 id="VLDBG-GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" class="sect4">Coalescing a Partition in a Hash Partitioned Table</h4>
                  <div>
                     <p>The <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">COALESCE</code> <code class="codeph">PARTITION</code> statement is used to coalesce a partition in a hash partitioned table. 
                     </p>
                     <div class="section">
                        <p>The following statement reduces by one the number of partitions in a table by coalescing a partition.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE ouu1
     COALESCE PARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1143"></a><div class="props_rev_3"><a id="GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" name="GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED"></a><h4 id="VLDBG-GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" class="sect4">Coalescing a Subpartition in a *-Hash Partitioned Table</h4>
                  <div>
                     <p>The <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">COALESCE</code> <code class="codeph">SUBPARTITION</code> statement is used to coalesce a subpartition in a hash partitioned table.
                     </p>
                     <div class="section">
                        <p>The following statement distributes the contents of a subpartition of partition <code class="codeph">us_locations</code> into one or more remaining subpartitions (determined by the hash function) of the same partition. For an interval-partitioned table, you can only coalesce hash subpartitions of materialized range or interval partitions. Basically, this operation is the inverse of the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code> clause discussed in <a href="maintenance-partition-tables-indexes.html#GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" title="Use the MODIFY PARTITION ADD SUBPARTITION clause of the ALTER TABLE statement to add a hash subpartition to a [range | list | interval]-hash partitioned table.">Adding a Subpartition to a *-Hash Partitioned Table</a>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE diving MODIFY PARTITION us_locations
     COALESCE SUBPARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1144"></a><div class="props_rev_3"><a id="GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" name="GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A"></a><h4 id="VLDBG-GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" class="sect4">Coalescing Hash Partitioned Global Indexes</h4>
                  <div>
                     <p>You can instruct the database to reduce by one the number of index partitions in a hash partitioned global index using the <code class="codeph">COALESCE</code> <code class="codeph">PARTITION</code> clause of <code class="codeph">ALTER</code> <code class="codeph">INDEX</code>.
                     </p>
                     <div class="section">
                        <p> The database selects the partition to coalesce based on the requirements of the hash partition. The following statement reduces by one the number of partitions in the <code class="codeph">hgidx</code> index, created in <a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="Hash partitioned global indexes can improve the performance of indexes where a small number of leaf blocks in the index have high contention in multiuser OLTP environments.">Creating a Hash Partitioned Global Index</a>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX hgidx COALESCE PARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1145"></a><div class="props_rev_3"><a id="GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" name="GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D"></a><h3 id="VLDBG-GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" class="sect3">About Dropping Partitions and Subpartitions</h3>
               <div>
                  <p>You can drop partitions from range, interval, list, or composite *-[range | list] partitioned tables.</p>
                  <p>For interval partitioned tables, you can only drop range or interval partitions that have been materialized. For hash partitioned tables, or hash subpartitions of composite *-hash partitioned tables, you must perform a coalesce operation instead.</p>
                  <p>You cannot drop a partition from a reference-partitioned table. Instead, a drop operation on a parent table cascades to all descendant tables.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" title="To drop table partitions, use DROP PARTITION or DROP SUBPARTITION with the ALTER TABLE SQL statement.">Dropping Table Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" title="You can drop interval partitions in an interval-partitioned table.">Dropping Interval Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" title="You cannot explicitly drop a partition of a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.">Dropping Index Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" title="You can remove multiple partitions or subpartitions from a range or list partitioned table with the DROP PARTITION and DROP SUBPARTITION clauses of the SQL ALTER TABLE statement.">Dropping Multiple Partitions</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1146"></a><div class="props_rev_3"><a id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" name="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB"></a><h4 id="VLDBG-GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" class="sect4">Dropping Table Partitions</h4>
                  <div>
                     <p>To drop table partitions, use <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> or <code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code> with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL statement.
                     </p>
                     <p>The following statements drop a table partition or subpartition:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> to drop a table partition
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code> to drop a subpartition of a composite *-[range | list] partitioned table
                           </p>
                        </li>
                     </ul>
                     <p>To preserve the data in the partition, use the <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> statement instead of the <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement. 
                     </p>
                     <p>To remove data in the partition without dropping the partition, use the <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement. 
                     </p>
                     <p>If local indexes are defined for the table, then this statement also drops the matching partition or subpartitions from the local index. All global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code> unless either of the following is true:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> (Cannot be specified for index-organized tables. Use <code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> instead.)
                           </p>
                        </li>
                        <li>
                           <p>The partition being dropped or its subpartitions are empty</p>
                           <div class="infoboxnote" id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB__GUID-EF634043-5D37-4199-9371-AA8BCE9819D7">
                              <p class="notep1">Note:</p>
                              <p></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If a table contains only one partition, you cannot drop the partition. Instead, you must drop the table.</p>
                                 </li>
                                 <li>
                                    <p>You cannot drop the highest range partition in the range-partitioned section of an interval-partitioned or interval-* composite partitioned table.</p>
                                 </li>
                                 <li>
                                    <p>With asynchronous global index maintenance, a drop partition update indexes operation is on metadata only and all global indexes remain valid.</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                     <p>The following sections contain some scenarios for dropping table partitions.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" title="There are several methods you can use to drop a partition from a table that contains data and global indexes.">Dropping a Partition from a Table that Contains Data and Global Indexes</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" title="There are several methods you can use to drop a partition containing data and referential integrity constraints.">Dropping a Partition Containing Data and Referential Integrity Constraints</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB__GUID-34D94A0C-8DC5-4784-845B-DBFFE4F05F3E">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" title="Use the ALTER TABLE MERGE PARTITION and SUBPARTITION SQL statements to merge the contents of two partitions or subpartitions.">About Merging Partitions and Subpartitions</a> for information about merging a partition
                              </p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" title="Truncating a partition is similar to dropping a partition, except that the partition is emptied of its data, but not physically dropped.">About Truncating Partitions and Subpartitions</a> for information about truncating a partition
                              </p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-can-be-performed.html#GUID-087B87A6-959A-40C6-82AF-36E401FD089B" title="The partition maintenance operations DROP PARTITION and TRUNCATE PARTITION are optimized by making the index maintenance for metadata only.">Asynchronous Global Index Maintenance for Dropping and Truncating Partitions</a> for information about asynchronous index maintenance for dropping partitions
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="VLDBG1148"></a><a id="VLDBG1149"></a><a id="VLDBG1150"></a><a id="VLDBG1147"></a><div class="props_rev_3"><a id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" name="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0"></a><h5 id="VLDBG-GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" class="sect5">Dropping a Partition from a Table that Contains Data and Global Indexes</h5>
                     <div>
                        <p>There are several methods you can use to drop a partition from a table that contains data and global indexes.</p>
                        <div class="section">
                           <p>If the partition contains data and one or more global indexes are defined on the table, then use one of the following methods (method 1, 2 or 3) to drop the table partition.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-7B087ED8-EF71-48B2-B134-45070AB45A8E">Method 1 </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement without maintaining global indexes. Afterward, you must rebuild any global indexes (whether partitioned or not) because the index (or index partitions) has been marked <code class="codeph">UNUSABLE</code>. The following statements provide an example of dropping partition <code class="codeph">dec98</code> from the <code class="codeph">sales</code> table, then rebuilding its global nonpartitioned index.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION dec98;
ALTER INDEX sales_area_ix REBUILD;
</pre><p>If index <code class="codeph">sales_area_ix</code> were a range-partitioned global index, then all partitions of the index would require rebuilding. Further, it is not possible to rebuild all partitions of an index in one statement. You must issue a separate <code class="codeph">REBUILD</code> statement for each partition in the index. The following statements rebuild the index partitions <code class="codeph">jan99_ix</code> to <code class="codeph">dec99_ix</code>.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX sales_area_ix REBUILD PARTITION jan99_ix;
ALTER INDEX sales_area_ix REBUILD PARTITION feb99_ix;
ALTER INDEX sales_area_ix REBUILD PARTITION mar99_ix;
...
ALTER INDEX sales_area_ix REBUILD PARTITION dec99_ix;
</pre><p>This method is most appropriate for large tables where the partition being dropped contains a significant percentage of the total data in the table. While asynchronous global index maintenance keeps global indexes valid without the need of any index maintenance, you must use the <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause to enable this new functionality. This behavior ensures backward compatibility.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-B92F6A37-4E05-44DE-8A9C-7E03DEA53EFA">Method 2 </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Issue the <code class="codeph">DELETE</code> statement to delete all rows from the partition before you issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement. The <code class="codeph">DELETE</code> statement updates the global indexes.
                           </p>
                           <p>For example, to drop the first partition, issue the following statements:</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition (dec98);
ALTER TABLE sales DROP PARTITION dec98;
</pre><p>This method is most appropriate for small tables, or for large tables when the partition being dropped contains a small percentage of the total data in the table.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-38285045-3EFA-4CF9-A8C6-FB98A4884820">Method 3 </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> in the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement. Doing so leverages the new asynchronous global index maintenance. Indexes remain valid.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION dec98
     UPDATE INDEXES;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1152"></a><a id="VLDBG1153"></a><a id="VLDBG1151"></a><div class="props_rev_3"><a id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" name="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F"></a><h5 id="VLDBG-GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" class="sect5">Dropping a Partition Containing Data and Referential Integrity Constraints</h5>
                     <div>
                        <p>There are several methods you can use to drop a partition containing data and referential integrity constraints.</p>
                        <div class="section">
                           <p>If a partition contains data and the table has referential integrity constraints, choose either of the following methods (method 1 or 2) to drop the table partition. This table has a local index only, so it is not necessary to rebuild any indexes.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F__GUID-AF4B1B6D-EAEB-491F-8C38-02D1CB7897CC">Method 1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>If there is no data referencing the data in the partition to drop, then you can disable the integrity constraints on the referencing tables, issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement, then re-enable the integrity constraints.
                           </p>
                           <p>This method is most appropriate for large tables where the partition being dropped contains a significant percentage of the total data in the table. If there is still data referencing the data in the partition to be dropped, then ensure the removal of all the referencing data so that you can re-enable the referential integrity constraints.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F__GUID-E4878DAD-6CD9-4291-9A6B-D36EC3B91D60">Method 2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>If there is data in the referencing tables, then you can issue the <code class="codeph">DELETE</code> statement to delete all rows from the partition before you issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement. The <code class="codeph">DELETE</code> statement enforces referential integrity constraints, and also fires triggers and generates redo and undo logs. The delete can succeed if you created the constraints with the <code class="codeph">ON DELETE CASCADE</code> option, deleting all rows from referencing tables as well.
                           </p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition (dec94);
ALTER TABLE sales DROP PARTITION dec94;
</pre><p>This method is most appropriate for small tables or for large tables when the partition being dropped contains a small percentage of the total data in the table.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1154"></a><div class="props_rev_3"><a id="GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" name="GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2"></a><h4 id="VLDBG-GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" class="sect4">Dropping Interval Partitions</h4>
                  <div>
                     <p>You can drop interval partitions in an interval-partitioned table.</p>
                     <div class="section">
                        <p>This operation drops the data for the interval only and leaves the interval definition in tact. If data is inserted in the interval just dropped, then the database again creates an interval partition.</p>
                        <p>You can also drop range partitions in an interval-partitioned table. The rules for dropping a range partition in an interval-partitioned table follow the rules for dropping a range partition in a range-partitioned table. If you drop a range partition in the middle of a set of range partitions, then the lower boundary for the next range partition shifts to the lower boundary of the range partition you just dropped. You cannot drop the highest range partition in the range-partitioned section of an interval-partitioned table.</p>
                        <p>The following example drops the September 2007 interval partition from the <code class="codeph">sales</code> table. There are only local indexes so no indexes are invalidated.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION FOR(TO_DATE('01-SEP-2007','dd-MON-yyyy'));</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1155"></a><div class="props_rev_3"><a id="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" name="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE"></a><h4 id="VLDBG-GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" class="sect4">Dropping Index Partitions</h4>
                  <div>
                     <p>You cannot explicitly drop a partition of a local index. Instead, local index partitions are dropped only when you drop a partition from the underlying table.</p>
                     <div class="section">
                        <p>If a global index partition is empty, then you can explicitly drop it by issuing the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> statement. But, if a global index partition contains data, then dropping the partition causes the next highest partition to be marked <code class="codeph">UNUSABLE</code>. For example, you would like to drop the index partition P1, and P2 is the next highest partition. You must issue the following statements:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX npr DROP PARTITION P1;
ALTER INDEX npr REBUILD PARTITION P2;</pre><div class="infoboxnote" id="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE__GUID-FF702298-FE8E-469C-9723-58D9450F65D5">
                           <p class="notep1">Note:</p>
                           <p>You cannot drop the highest partition in a global index.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14110"></a><div class="props_rev_3"><a id="GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" name="GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947"></a><h4 id="VLDBG-GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" class="sect4">Dropping Multiple Partitions</h4>
                  <div>
                     <p>You can remove multiple partitions or subpartitions from a range or list partitioned table with the <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> and <code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code> clauses of the SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement. 
                     </p>
                     <div class="section">
                        <p>For example, the following SQL statement drops multiple partitions from the range-partitioned table <code class="codeph">sales</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION sales_q1_2008, sales_q2_2008,
     sales_q3_2008, sales_q4_2008;
</pre><p>You cannot drop all the partitions of a table. When dropping multiple partitions, local and global index operations are the same as when dropping a single partition. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1156"></a><div class="props_rev_3"><a id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" name="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848"></a><h3 id="VLDBG-GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" class="sect3">About Exchanging Partitions and Subpartitions</h3>
               <div>
                  <p>You can convert a partition or subpartition into a nonpartitioned table, and a nonpartitioned table into a partition or subpartition of a partitioned table by exchanging their data segments.</p>
                  <p>You can also convert a hash partitioned table into a partition of a composite *-hash partitioned table, or convert the partition of a composite *-hash partitioned table into a hash partitioned table. Similarly, you can convert a range- or list-partitioned table into a partition of a composite *-range or -list partitioned table, or convert a partition of the composite *-range or -list partitioned table into a range- or list-partitioned table.</p>
                  <p>Exchanging table partitions is useful to get data quickly in or out of a partitioned table. For example, in data warehousing environments, exchanging partitions facilitates high-speed data loading of new, incremental data into an existing partitioned table. </p>
                  <p>OLTP and data warehousing environments benefit from exchanging old data partitions out of a partitioned table. The data is purged from the partitioned table without actually being deleted and can be archived separately afterward.</p>
                  <p>When you exchange partitions, logging attributes are preserved. You can optionally specify if local indexes are also to be exchanged with the <code class="codeph">INCLUDING</code> <code class="codeph">INDEXES</code> clause, and if rows are to be validated for proper mapping with the <code class="codeph">WITH</code> <code class="codeph">VALIDATION</code> clause. 
                  </p>
                  <div class="infoboxnote" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-1C179196-F91F-4219-8927-9F21CA848076">
                     <p class="notep1">Note:</p>
                     <p>When you specify <code class="codeph">WITHOUT</code> <code class="codeph">VALIDATION</code> for the exchange partition operation, this is normally a fast operation because it involves only data dictionary updates. However, if the table or partitioned table involved in the exchange operation has a primary key or unique constraint enabled, then the exchange operation is performed as if <code class="codeph">WITH</code> <code class="codeph">VALIDATION</code> were specified to maintain the integrity of the constraints.
                     </p>
                     <p>To avoid the overhead of this validation activity, issue the following statement for each constraint before performing the exchange partition operation:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic">table_name</span>
     DISABLE CONSTRAINT <span class="italic">constraint_name</span> KEEP INDEX
</pre><p>Enable the constraints after the exchange.</p>
                     <p>If you specify <code class="codeph">WITHOUT</code> <code class="codeph">VALIDATION</code>, then you must ensure that the data to be exchanged belongs in the partition you exchange.
                     </p>
                  </div>
                  <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>, the Oracle Database marks the global indexes or all global index partitions on the table whose partition is being exchanged as <code class="codeph">UNUSABLE</code>. Global indexes or global index partitions on the table being exchanged remain invalidated. 
                  </p>
                  <p>You cannot use <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> for index-organized tables. Use <code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> instead.
                  </p>
                  <p>Incremental statistics on a partitioned table are maintained with a partition exchange operation if the statistics were gathered on the nonpartitioned table when <code class="codeph">DBMS_STATS</code> table preferences <code class="codeph">INCREMENTAL</code> is set to true and <code class="codeph">INCREMENTAL_LEVEL</code> is set to <code class="codeph">TABLE</code>. 
                  </p>
                  <div class="infoboxnote" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-9EED4704-31E4-495F-B8CB-3018B18026E3">
                     <p class="notep1">Note:</p>
                     <p>In situations where column statistics for virtual columns are out of order, the column statistics are deleted rather than retaining the stale statistics. Information about this deletion is written to the alert log file.</p>
                  </div>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" title="Tables can be created with the FOR EXCHANGE WITH clause to exactly match the shape of a partitioned table and be eligible for a partition exchange command. However, indexes are not created as an operation of this command.">Creating a Table for Exchange With a Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" title="To exchange a partition of a range, hash, or list partitioned table with a nonpartitioned table, or the reverse, use the ALTER TABLE EXCHANGE PARTITION statement.">Exchanging a Range, Hash, or List Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" title="You can exchange interval partitions in an interval-partitioned table. However, you must ensure that the interval partition has been created before you can exchange the partition.">Exchanging a Partition of an Interval Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" title="You can exchange partitions in a reference-partitioned table, but you must ensure that the data that you reference is available in the respective partition in the parent table.">Exchanging a Partition of a Reference-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" title="You can exchange partitions in the presence of virtual columns.">About Exchanging a Partition of a Table with Virtual Columns</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="You can exchange a whole hash partitioned table, with all of its partitions, with the partition of a *-hash partitioned table and all of its hash subpartitions.">Exchanging a Hash Partitioned Table with a *-Hash Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="You can use the ALTER TABLE EXCHANGE SUBPARTITION statement to convert a hash subpartition of a *-hash partitioned table into a nonpartitioned table, or the reverse.">Exchanging a Subpartition of a *-Hash Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" title="You can use the ALTER TABLE EXCHANGE PARTITION statement to exchange a list-partitioned table with a *-list partition.">Exchanging a List-Partitioned Table with a *-List Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" title="You can use the ALTER TABLE EXCHANGE SUBPARTITION statement to exchange a subpartition of a *-list partitioned table.">About Exchanging a Subpartition of a *-List Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" title="You can use the ALTER TABLE EXCHANGE PARTITION statement to exchange a range-partitioned table with a *-range partition.">Exchanging a Range-Partitioned Table with a *-Range Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" title="You can use the ALTER TABLE EXCHANGE SUBPARTITION statement to exchange a subpartition of a *-range partition.">About Exchanging a Subpartition of a *-Range Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" title="You can cascade exchange operations to reference partitioned child tables with the CASCADE option of the ALTER TABLE EXCHANGE PARTITION and ALTER TABLE EXCHANGE SUBPARTITION SQL statements.">About Exchanging a Partition with the Cascade Option</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-0D5C9A72-F780-47C5-9A66-B5FCF3330115">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="view-info-partition-tables-indexes.html#GUID-2D424638-511C-4CC3-9BDE-53FFB1686ECD" title="You can display information about partitioned tables and indexes with Oracle Database views.">Viewing Information About Partitioned Tables and Indexes</a> for information about using views to monitor details about partitioned tables and indexes
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/vldbg&amp;id=TGSQL413" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> for more information about incremental statistics
                              </p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_STATS.html#ARPLS-GUID-01FAB8ED-E4A3-4C3E-8FE2-88717DCDDA06" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information about the <code class="codeph">DBMS_STATS</code> package
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" name="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34"></a><h4 id="VLDBG-GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" class="sect4">Creating a Table for Exchange With a Partitioned Table</h4>
                  <div>
                     <p>Tables can be created with the <code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code> clause to exactly match the shape of a partitioned table and be eligible for a partition exchange command. However, indexes are not created as an operation of this command. 
                     </p>
                     <p>Because the <code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code> clause of <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> provides an exact match between a non-partitioned and partitioned table, this is an improvement over the <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> statement.
                     </p>
                     <p>The following list is a summary of the effects of the <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">FOR EXCHANGE WITH</code> DDL operation:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The use case of this DDL operation is to facilitate creation of a table to be used for exchange partition DDL. </p>
                        </li>
                        <li>
                           <p>The operation creates a clone of the for exchange table in terms of column ordering and column properties. </p>
                        </li>
                        <li>
                           <p>Columns cannot be renamed. The table being created inherits the names from the for exchange table. </p>
                        </li>
                        <li>
                           <p>The only logical property that can be specified during the DDL operation is the partitioning specification of the table. </p>
                           <p>The partitioning clause is only relevant for the exchange with a partition of a composite-partitioned table. In this case, a partition with <span class="italic">n</span> subpartitions is exchanged with a partitioned table with <span class="italic">n</span> partitions matching the subpartitions. You are responsible for the definition of the partitioning clause for this exchange in this scenario.
                           </p>
                           <p>The subpartitioning can be asymmetrical across partitions. The partitioning clause has to match exactly the subpartitioning of the partition to being exchanged.</p>
                        </li>
                        <li>
                           <p>The physical properties which can be specified are primarily table segment attributes. </p>
                        </li>
                        <li>
                           <p>Column properties copied with this DDL operation include, but are not limited to, the following: unusable columns, invisible columns, virtual expression columns, functional index expression columns, and other internal settings and attributes.</p>
                        </li>
                     </ul>
                     <p>The following is an example of the use of the <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> statement with the <code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code> clause to create a table that mimics the shape of an existing table in terms of column ordering and properties.
                     </p>
                     <div class="example" id="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34__GUID-5A628646-19E6-4DF6-9057-57327C62EDB7">
                        <p class="titleinexample">Example 4-30 Using the FOR EXCHANGE WITH clause of CREATE TABLE</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_year_table
  ( prod_id       NUMBER        NOT NULL,
    cust_id       NUMBER        NOT NULL,
    time_id       DATE          NOT NULL,
    channel_id    NUMBER        NOT NULL,
    promo_id      NUMBER        NOT NULL,
    quantity_sold NUMBER(10,2)  NOT NULL,
    amount_sold   NUMBER(10,2)  NOT NULL
  )
    PARTITION BY RANGE (time_id)
     (PARTITION sales_2016 VALUES LESS THAN (TO_DATE('01-01-2017','dd-mm-yyyy')),
      PARTITION sales_2017 VALUES LESS THAN (TO_DATE('01-01-2018','dd-mm-yyyy')),
      PARTITION sales_2018 VALUES LESS THAN (TO_DATE('01-01-2019','dd-mm-yyyy')),
      PARTITION sales_2019 VALUES LESS THAN (TO_DATE('01-01-2020','dd-mm-yyyy')),
      PARTITION sales_future VALUES LESS THAN (MAXVALUE)
 );

DESCRIBE sales_by_year_table
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 PROD_ID                                   NOT NULL NUMBER
 CUST_ID                                   NOT NULL NUMBER
 TIME_ID                                   NOT NULL DATE
 CHANNEL_ID                                NOT NULL NUMBER
 PROMO_ID                                  NOT NULL NUMBER
 QUANTITY_SOLD                             NOT NULL NUMBER(10,2)
 AMOUNT_SOLD                               NOT NULL NUMBER(10,2)

CREATE TABLE sales_later_year_table
  FOR EXCHANGE WITH TABLE sales_by_year_table;

DESCRIBE sales_later_year_table
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 PROD_ID                                   NOT NULL NUMBER
 CUST_ID                                   NOT NULL NUMBER
 TIME_ID                                   NOT NULL DATE
 CHANNEL_ID                                NOT NULL NUMBER
 PROMO_ID                                  NOT NULL NUMBER
 QUANTITY_SOLD                             NOT NULL NUMBER(10,2)
 AMOUNT_SOLD                               NOT NULL NUMBER(10,2)
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1157"></a><div class="props_rev_3"><a id="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" name="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF"></a><h4 id="VLDBG-GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" class="sect4">Exchanging a Range, Hash, or List Partition</h4>
                  <div>
                     <p>To exchange a partition of a range, hash, or list partitioned table with a nonpartitioned table, or the reverse, use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p>The following is an example of exchanging range partitions with a nonpartitioned table.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF__GUID-721F491B-E03F-4FCC-8DAD-3B049A26E5A0">
                        <p class="titleinexample">Example 4-31 Exchanging a Range Partition</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_future_table
  ( prod_id       NUMBER        NOT NULL,
    cust_id       NUMBER        NOT NULL,
    time_id       DATE          NOT NULL,
    channel_id    NUMBER        NOT NULL,
    promo_id      NUMBER        NOT NULL,
    quantity_sold NUMBER(10,2)  NOT NULL,
    amount_sold   NUMBER(10,2)  NOT NULL
  )
    PARTITION BY RANGE (time_id)
     (PARTITION s_2020 VALUES LESS THAN (TO_DATE('01-01-2021','dd-mm-yyyy')),
      PARTITION s_2021 VALUES LESS THAN (TO_DATE('01-01-2022','dd-mm-yyyy')),
      PARTITION s_2022 VALUES LESS THAN (TO_DATE('01-01-2023','dd-mm-yyyy'))
 );

CREATE TABLE sales_exchange_table
  FOR EXCHANGE WITH TABLE sales_future_table;

INSERT INTO sales_exchange_table VALUES (1002,110,TO_DATE('19-02-2020','dd-mm-yyyy'),12,18,150,4800);
INSERT INTO sales_exchange_table VALUES (1001,100,TO_DATE('12-03-2020','dd-mm-yyyy'),10,15,400,6500);
INSERT INTO sales_exchange_table VALUES (1001,100,TO_DATE('31-05-2020','dd-mm-yyyy'),10,15,600,8000);
INSERT INTO sales_exchange_table VALUES (2105,101,TO_DATE('25-06-2020','dd-mm-yyyy'),12,19,100,3000);
INSERT INTO sales_exchange_table VALUES (1002,120,TO_DATE('31-08-2020','dd-mm-yyyy'),10,15,400,6000);
INSERT INTO sales_exchange_table VALUES (2105,101,TO_DATE('25-10-2020','dd-mm-yyyy'),12,19,250,7500);

ALTER TABLE sales_future_table
    EXCHANGE PARTITION s_2020 WITH TABLE sales_exchange_table;

SELECT * FROM sales_future_table PARTITION(s_2020);
   PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      1002        110 19-FEB-20         12         18           150        4800
      1001        100 12-MAR-20         10         15           400        6500
      1001        100 31-MAY-20         10         15           600        8000
      2105        101 25-JUN-20         12         19           100        3000
      1002        120 31-AUG-20         10         15           400        6000
      2105        101 25-OCT-20         12         19           250        7500
6 rows selected.

REM Note that all records have been removed from the sales_exchange_table
SELECT * FROM sales_exchange_table;
no rows selected

INSERT INTO sales_exchange_table VALUES (1002,110,TO_DATE('15-02-2021','dd-mm-yyyy'),12,18,300,9500);
INSERT INTO sales_exchange_table VALUES (1002,120,TO_DATE('31-03-2021','dd-mm-yyyy'),10,15,200,3000);
INSERT INTO sales_exchange_table VALUES (2105,101,TO_DATE('25-04-2021','dd-mm-yyyy'),12,19,150,9000);

ALTER TABLE sales_future_table
    EXCHANGE PARTITION s_2021 WITH TABLE sales_exchange_table;

SELECT * FROM sales_future_table PARTITION(s_2021);
   PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      1002        110 15-FEB-21         12         18           300        9500
      1002        120 31-MAR-21         10         15           200        3000
      2105        101 25-APR-21         12         19           150        9000
3 rows selected.
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1158"></a><div class="props_rev_3"><a id="GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" name="GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0"></a><h4 id="VLDBG-GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" class="sect4">Exchanging a Partition of an Interval Partitioned Table</h4>
                  <div>
                     <p>You can exchange interval partitions in an interval-partitioned table. However, you must ensure that the interval partition has been created before you can exchange the partition.</p>
                     <div class="section">
                        <p>The following example shows a partition exchange for the <code class="codeph">interval_sales</code> table, interval-partitioned using monthly partitions as of January 1, 2007. This example shows how to add data for June 2007 to the table using partition exchange load. Assume there are only local indexes on the <code class="codeph">interval_sales</code> table, and equivalent indexes have been created on the <code class="codeph">interval_sales_june_2007</code> table.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE interval_sales
  EXCHANGE PARTITION FOR (TO_DATE('01-JUN-2007','dd-MON-yyyy'))
  WITH TABLE interval_sales_jun_2007
  INCLUDING INDEXES;
</pre><p>Note the use of the <code class="codeph">FOR</code> syntax to identify a partition that was system-generated. You can determine the partition name by querying the <code class="codeph">*_TAB_PARTITIONS</code> data dictionary view to display the system-generated partition name.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14073"></a><a id="VLDBG1159"></a><div class="props_rev_3"><a id="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" name="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF"></a><h4 id="VLDBG-GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" class="sect4">Exchanging a Partition of a Reference-Partitioned Table</h4>
                  <div>
                     <p>You can exchange partitions in a reference-partitioned table, but you must ensure that the data that you reference is available in the respective partition in the parent table.</p>
                     <div class="section">
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF__CHDEJFFI">Example 4-32</a> shows a partition exchange load scenario for the range-partitioned <code class="codeph">orders</code> table, and the reference partitioned <code class="codeph">order_items</code> table. The data in the <code class="codeph">order_items_dec_2006</code> table only contains order item data for orders with an <code class="codeph">order_date</code> in December 2006.
                        </p>
                        <p>You must use the <code class="codeph">UPDATE GLOBAL INDEXES</code> or <code class="codeph">UPDATE INDEXES</code> on the exchange partition of the parent table in order for the primary key index to remain usable. Note also that you must create or enable the foreign key constraint on the <code class="codeph">order_items_dec_2006</code> table in order for the partition exchange on the reference-partitioned table to succeed.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF__CHDEJFFI">
                        <p class="titleinexample">Example 4-32 Exchanging a partition for a reference-partitioned table</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders
  EXCHANGE PARTITION p_2006_dec
  WITH TABLE orders_dec_2006
  UPDATE GLOBAL INDEXES;

ALTER TABLE order_items_dec_2006
  ADD CONSTRAINT order_items_dec_2006_fk
  FOREIGN KEY (order_id)
  REFERENCES orders(order_id) ;

ALTER TABLE order_items
  EXCHANGE PARTITION p_2006_dec
  WITH TABLE order_items_dec_2006;
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1160"></a><div class="props_rev_3"><a id="GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" name="GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06"></a><h4 id="VLDBG-GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" class="sect4">About Exchanging a Partition of a Table with Virtual Columns</h4>
                  <div>
                     <p>You can exchange partitions in the presence of virtual columns.</p>
                     <p>In order for a partition exchange on a partitioned table with virtual columns to succeed, you must create a table that matches the definition of all non-virtual columns in a single partition of the partitioned table. You do not need to include the virtual column definitions, unless constraints or indexes have been defined on the virtual column.</p>
                     <p>In this case, you must include the virtual column definition to match the partitioned table's constraint and index definitions. This scenario also applies to virtual column-based partitioned tables.</p>
                  </div>
               </div><a id="VLDBG1161"></a><div class="props_rev_3"><a id="GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" name="GUID-8E3836CA-6C40-4058-88C1-9D14E410128F"></a><h4 id="VLDBG-GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" class="sect4">Exchanging a Hash Partitioned Table with a *-Hash Partition</h4>
                  <div>
                     <p>You can exchange a whole hash partitioned table, with all of its partitions, with the partition of a *-hash partitioned table and all of its hash subpartitions.</p>
                     <div class="section">
                        <p>The following example illustrates this concept for a range-hash partitioned table.</p>
                        <p>First, create a hash partitioned table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t1 (i NUMBER, j NUMBER)
     PARTITION BY HASH(i)
       (PARTITION p1, PARTITION p2);
</pre><p>Populate the table, then create a range-hash partitioned table as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t2 (i NUMBER, j NUMBER)
     PARTITION BY RANGE(j)
     SUBPARTITION BY HASH(i)
        (PARTITION p1 VALUES LESS THAN (10)
            (SUBPARTITION t2_pls1,
             SUBPARTITION t2_pls2),
         PARTITION p2 VALUES LESS THAN (20)
            (SUBPARTITION t2_p2s1,
             SUBPARTITION t2_p2s2)
         );
</pre><p>It is important that the partitioning key in table <code class="codeph">t1</code> equals the subpartitioning key in table <code class="codeph">t2</code>.
                        </p>
                        <p>To migrate the data in <code class="codeph">t1</code> to <code class="codeph">t2</code>, and validate the rows, use the following statement:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1
     WITH VALIDATION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1162"></a><div class="props_rev_3"><a id="GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" name="GUID-35E940E6-03F8-4205-B9E3-365F444DEF89"></a><h4 id="VLDBG-GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" class="sect4">Exchanging a Subpartition of a *-Hash Partitioned Table</h4>
                  <div>
                     <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> statement to convert a hash subpartition of a *-hash partitioned table into a nonpartitioned table, or the reverse.
                     </p>
                     <div class="section">
                        <p>The following example converts the subpartition <code class="codeph">q3_1999_s1</code> of table <code class="codeph">sales</code> into the nonpartitioned table <code class="codeph">q3_1999</code>. Local index partitions are exchanged with corresponding indexes on <code class="codeph">q3_1999</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE SUBPARTITION q3_1999_s1
      WITH TABLE q3_1999 INCLUDING INDEXES;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1163"></a><div class="props_rev_3"><a id="GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" name="GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1"></a><h4 id="VLDBG-GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" class="sect4">Exchanging a List-Partitioned Table with a *-List Partition</h4>
                  <div>
                     <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement to exchange a list-partitioned table with a *-list partition.
                     </p>
                     <div class="section">
                        <p>The semantics are the same as described previously in <a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="You can exchange a whole hash partitioned table, with all of its partitions, with the partition of a *-hash partitioned table and all of its hash subpartitions.">Exchanging a Hash Partitioned Table with a *-Hash Partition</a>. The following example shows an exchange partition scenario for a list-list partitioned table.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE customers_apac
( id            NUMBER
, name          VARCHAR2(50)
, email         VARCHAR2(100)
, region        VARCHAR2(4)
, credit_rating VARCHAR2(1)
)
PARTITION BY LIST (credit_rating)
( PARTITION poor VALUES ('P')
, PARTITION mediocre VALUES ('C')
, PARTITION good VALUES ('G')
, PARTITION excellent VALUES ('E')
);
</pre><p>Populate the table with APAC customers. Then create a list-list partitioned table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE customers
( id            NUMBER
, name          VARCHAR2(50)
, email         VARCHAR2(100)
, region        VARCHAR2(4)
, credit_rating VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY LIST (credit_rating)
SUBPARTITION TEMPLATE
( SUBPARTITION poor VALUES ('P')
, SUBPARTITION mediocre VALUES ('C')
, SUBPARTITION good VALUES ('G')
, SUBPARTITION excellent VALUES ('E')
)
(PARTITION americas VALUES ('AMER')
, PARTITION emea VALUES ('EMEA')
, PARTITION apac VALUES ('APAC')
);
</pre><p>It is important that the partitioning key in the <code class="codeph">customers_apac</code> table matches the subpartitioning key in the <code class="codeph">customers</code> table.
                        </p>
                        <p>Next, exchange the <code class="codeph">apac</code> partition.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE customers
EXCHANGE PARTITION apac
WITH TABLE customers_apac
WITH VALIDATION;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1164"></a><div class="props_rev_3"><a id="GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" name="GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158"></a><h4 id="VLDBG-GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" class="sect4">About Exchanging a Subpartition of a *-List Partitioned Table</h4>
                  <div>
                     <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> statement to exchange a subpartition of a *-list partitioned table.
                     </p>
                     <p> </p>
                     <p>The semantics of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code><code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> statement are the same as described previously in <a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="You can use the ALTER TABLE EXCHANGE SUBPARTITION statement to convert a hash subpartition of a *-hash partitioned table into a nonpartitioned table, or the reverse.">Exchanging a Subpartition of a *-Hash Partitioned Table</a>.
                     </p>
                  </div>
               </div><a id="VLDBG1165"></a><div class="props_rev_3"><a id="GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" name="GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6"></a><h4 id="VLDBG-GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" class="sect4">Exchanging a Range-Partitioned Table with a *-Range Partition</h4>
                  <div>
                     <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement to exchange a range-partitioned table with a *-range partition.
                     </p>
                     <div class="section">
                        <p>The semantics of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> statement are the same as described previously in <a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="You can exchange a whole hash partitioned table, with all of its partitions, with the partition of a *-hash partitioned table and all of its hash subpartitions.">Exchanging a Hash Partitioned Table with a *-Hash Partition</a>. The example below shows the <code class="codeph">orders</code> table, which is interval partitioned by <code class="codeph">order_date</code>, and subpartitioned by range on <code class="codeph">order_total</code>. The example shows how to exchange a single monthly interval with a range-partitioned table.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders_mar_2007
 ( id          NUMBER
  , cust_id     NUMBER
  , order_date  DATE
  , order_total NUMBER
 )
PARTITION BY RANGE (order_total)
 ( PARTITION p_small VALUES LESS THAN (1000)
  , PARTITION p_medium VALUES LESS THAN (10000)
  , PARTITION p_large VALUES LESS THAN (100000)
  , PARTITION p_extraordinary VALUES LESS THAN (MAXVALUE)
 );
</pre><p>Populate the table with orders for March 2007. Then create an interval-range partitioned table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders
 ( id          NUMBER
  , cust_id     NUMBER
  , order_date  DATE
  , order_total NUMBER
 )
PARTITION BY RANGE (order_date) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
  SUBPARTITION BY RANGE (order_total)
  SUBPARTITION TEMPLATE
  ( SUBPARTITION p_small VALUES LESS THAN (1000)
   , SUBPARTITION p_medium VALUES LESS THAN (10000)
   , SUBPARTITION p_large VALUES LESS THAN (100000)
   , SUBPARTITION p_extraordinary VALUES LESS THAN (MAXVALUE)
  )
 (PARTITION p_before_2007 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')));
</pre><p>It is important that the partitioning key in the <code class="codeph">orders_mar_2007</code> table matches the subpartitioning key in the <code class="codeph">orders</code> table.
                        </p>
                        <p>Next, exchange the partition.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders
  EXCHANGE PARTITION
   FOR (TO_DATE('01-MAR-2007','dd-MON-yyyy'))
   WITH TABLE orders_mar_2007
   WITH VALIDATION;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1166"></a><div class="props_rev_3"><a id="GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" name="GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109"></a><h4 id="VLDBG-GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" class="sect4">About Exchanging a Subpartition of a *-Range Partitioned Table</h4>
                  <div>
                     <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> statement to exchange a subpartition of a *-range partition.
                     </p>
                     <p>The semantics of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> are the same as described previously in <a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="You can use the ALTER TABLE EXCHANGE SUBPARTITION statement to convert a hash subpartition of a *-hash partitioned table into a nonpartitioned table, or the reverse.">Exchanging a Subpartition of a *-Hash Partitioned Table</a>.
                     </p>
                  </div>
               </div><a id="VLDBG14111"></a><div class="props_rev_3"><a id="GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" name="GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25"></a><h4 id="VLDBG-GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" class="sect4">About Exchanging a Partition with the Cascade Option</h4>
                  <div>
                     <p>You can cascade exchange operations to reference partitioned child tables with the <code class="codeph">CASCADE</code> option of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> and <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> SQL statements. 
                     </p>
                     <p>Cascading exchange operations require all foreign key constraints to being defined as <code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>.
                     </p>
                     <p>When the <code class="codeph">CASCADE</code> option for <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> and <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> is specified, the <code class="codeph">EXCHANGE</code> operation cascades to reference partitioned tables that are children of the targeted table. The exchange operation can be targeted at any level in a reference partitioned hierarchy and cascades to child tables starting from the targeted table. Privileges are not required on the child tables, but ordinary restrictions on the exchange operation apply for all tables affected by the operation. The <code class="codeph">CASCADE</code> option is ignored if it is specified for a table that does not have reference partitioned children.
                     </p>
                     <p>The reference partitioned hierarchy of the targeted table and the reference partitioned hierarchy of the exchange table must match. The <code class="codeph">CASCADE</code> option is not supported if the same parent key is referenced by multiple dependent tables. Having more than one dependent table relying on the same primary key makes it impossible for the kernel to unambiguously identify how to exchange the dependent partitions. Any other options specified for the operation, such as <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>, applies for all tables affected by the operation. 
                     </p>
                     <p>The cascade options are off by default so they do not affect Oracle Database compatibility.</p>
                  </div>
               </div>
            </div><a id="VLDBG1167"></a><div class="props_rev_3"><a id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" name="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523"></a><h3 id="VLDBG-GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" class="sect3">About Merging Partitions and Subpartitions</h3>
               <div>
                  <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> and <code class="codeph">SUBPARTITION</code> SQL statements to merge the contents of two partitions or subpartitions.
                  </p>
                  <p> The two original partitions or subpartitions are dropped, as are any corresponding local indexes. You cannot use this statement for a hash partitioned table or for hash subpartitions of a composite *-hash partitioned table. </p>
                  <p>You cannot merge partitions for a reference-partitioned table. Instead, a merge operation on a parent table cascades to all descendant tables. However, you can use the <code class="codeph">DEPENDENT TABLES</code> clause to set specific properties for dependent tables when you issue the merge operation on the master table to merge partitions or subpartitions.
                  </p>
                  <p>You can use the <code class="codeph">ONLINE</code> keyword with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> and <code class="codeph">SUBPARTITION</code> SQL statements to enable online merge operations for regular (heap-organized) tables. For an example of the use of the <code class="codeph">ONLINE</code> keyword, see <a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">Example 4-33</a>.
                  </p>
                  <p>If the involved partitions or subpartitions contain data, then indexes may be marked <code class="codeph">UNUSABLE</code> as described in the following table:
                  </p>
                  <div class="tblformal" id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523__GUID-62C55005-CD3C-43C1-97D4-EC99C243B314">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e5934">Table Type</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e5937">Index Behavior</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e5942" headers="d29958e5934 ">
                                 <p>Regular (Heap)</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e5942 d29958e5937 ">
                                 <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> as part of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The database marks <code class="codeph">UNUSABLE</code> all resulting corresponding local index partitions or subpartitions. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>Global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code> and must be rebuilt.
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e5974" headers="d29958e5934 ">
                                 <p>Index-organized</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e5974 d29958e5937 ">
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The database marks <code class="codeph">UNUSABLE</code> all resulting corresponding local index partitions. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>All global indexes remain usable.</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" title="You can merge the contents of two adjacent range partitions into one partition.">Merging Range Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="The contents of two adjacent interval partitions can be merged into one partition.">Merging Interval Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-49405446-99D3-42F1-A266-9E212F312D3C" title="When you merge list partitions, the partitions being merged can be any two partitions.">Merging List Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" title="When you merge *-hash partitions, the subpartitions are rehashed into the number of subpartitions specified by SUBPARTITIONS n or the SUBPARTITION clause. If neither is included, table-level defaults are used.">Merging *-Hash Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" title="Partitions can be merged at the partition level and subpartitions can be merged at the list subpartition level.">About Merging *-List Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" title="Partitions can be merged at the partition level and subpartitions can be merged at the range subpartition level.">About Merging *-Range Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-54080399-6E59-4706-80C8-690159B20790" title="You can merge the contents of two or more partitions or subpartitions into one new partition or subpartition and then drop the original partitions or subpartitions with the MERGE PARTITIONS and MERGE SUBPARTITIONS clauses of the ALTER TABLE SQL statement.">Merging Multiple Partitions</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523__GUID-57BFA06A-7B4E-434B-902A-5DE37ED7F389">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="VLDBG14074"></a><a id="VLDBG1168"></a><div class="props_rev_3"><a id="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" name="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797"></a><h4 id="VLDBG-GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" class="sect4">Merging Range Partitions</h4>
                  <div>
                     <p>You can merge the contents of two adjacent range partitions into one partition. </p>
                     <div class="section">
                        <p>Nonadjacent range partitions cannot be merged. The resulting partition inherits the higher upper bound of the two merged partitions. </p>
                        <p>One reason for merging range partitions is to keep historical data online in larger partitions. For example, you can have daily partitions, with the oldest partition rolled up into weekly partitions, which can then be rolled up into monthly partitions, and so on.</p>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">Example 4-33</a> shows an example of merging range partitions using the <code class="codeph">ONLINE</code> keyword.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">
                        <p class="titleinexample">Example 4-33 Merging range partitions</p><pre class="oac_no_warn" dir="ltr">-- First, create a partitioned table with four partitions, each on its own
-- tablespace, partitioned by range on the date column
--
CREATE TABLE four_seasons
(       one DATE,
        two VARCHAR2(60),
      three NUMBER
)
PARTITION BY RANGE (one) 
(
PARTITION quarter_one 
   VALUES LESS THAN ( TO_DATE('01-APR-2017','dd-mon-yyyy'))
   TABLESPACE quarter_one,
PARTITION quarter_two 
   VALUES LESS THAN ( TO_DATE('01-JUL-2017','dd-mon-yyyy'))
   TABLESPACE quarter_two,
PARTITION quarter_three
   VALUES LESS THAN ( TO_DATE('01-OCT-2017','dd-mon-yyyy'))
   TABLESPACE quarter_three,
PARTITION quarter_four
   VALUES LESS THAN ( TO_DATE('01-JAN-2018','dd-mon-yyyy'))
   TABLESPACE quarter_four
);
-- 
-- Create local PREFIXED indexes on four_seasons
-- Prefixed because the leftmost columns of the index match the
-- Partitioning key 
--
CREATE INDEX i_four_seasons_l ON four_seasons (one,two) 
  LOCAL ( 
  PARTITION i_quarter_one TABLESPACE i_quarter_one,
  PARTITION i_quarter_two TABLESPACE i_quarter_two,
  PARTITION i_quarter_three TABLESPACE i_quarter_three,
  PARTITION i_quarter_four TABLESPACE i_quarter_four
);


SELECT TABLE_NAME, PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='FOUR_SEASONS';
TABLE_NAME                          PARTITION_NAME
----------------------------------- -------------------------
FOUR_SEASONS                        QUARTER_FOUR
FOUR_SEASONS                        QUARTER_ONE
FOUR_SEASONS                        QUARTER_THREE
FOUR_SEASONS                        QUARTER_TWO

-- Next, merge the first two partitions
ALTER TABLE four_seasons 
  MERGE PARTITIONS quarter_one, quarter_two INTO PARTITION quarter_two
  UPDATE INDEXES 
  ONLINE;

SELECT TABLE_NAME, PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='FOUR_SEASONS';
TABLE_NAME                          PARTITION_NAME
----------------------------------- -------------------------
FOUR_SEASONS                        QUARTER_FOUR
FOUR_SEASONS                        QUARTER_THREE
FOUR_SEASONS                        QUARTER_TWO
</pre><p>If you omit the <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause from the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph"><span class="codeinlineitalic">four_season</span></code> statement, then you must rebuild the local index for the affected partition.
                        </p><pre class="oac_no_warn" dir="ltr">-- Rebuild the index for quarter_two, which has been marked unusable 
-- because it has not had all of the data from quarter_one added to it.
-- Rebuilding the index corrects this condition.
--
ALTER TABLE four_seasons MODIFY PARTITION quarter_two 
  REBUILD UNUSABLE LOCAL INDEXES;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1169"></a><div class="props_rev_3"><a id="GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" name="GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360"></a><h4 id="VLDBG-GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" class="sect4">Merging Interval Partitions</h4>
                  <div>
                     <p>The contents of two adjacent interval partitions can be merged into one partition.</p>
                     <div class="section">
                        <p>Nonadjacent interval partitions cannot be merged. The first interval partition can also be merged with the highest range partition. The resulting partition inherits the higher upper bound of the two merged partitions.</p>
                        <p>Merging interval partitions always results in the transition point being moved to the higher upper bound of the two merged partitions. This result is that the range section of the interval-partitioned table is extended to the upper bound of the two merged partitions. Any materialized interval partitions with boundaries lower than the newly merged partition are automatically converted into range partitions, with their upper boundaries defined by the upper boundaries of their intervals.</p>
                        <p>For example, consider the following interval-partitioned table transactions:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE transactions
( id               NUMBER
, transaction_date DATE
, value            NUMBER
)
PARTITION BY RANGE (transaction_date)
INTERVAL (NUMTODSINTERVAL(1,'DAY'))
( PARTITION p_before_2007 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')));
</pre><p>Inserting data into the interval section of the table creates the interval partitions for these days. The data for January 15, 2007 and January 16, 2007 are stored in adjacent interval partitions.</p><pre class="oac_no_warn" dir="ltr">INSERT INTO transactions VALUES (1,TO_DATE('15-JAN-2007','dd-MON-yyyy'),100);
INSERT INTO transactions VALUES (2,TO_DATE('16-JAN-2007','dd-MON-yyyy'),600); 
INSERT INTO transactions VALUES (3,TO_DATE('30-JAN-2007','dd-MON-yyyy'),200);
</pre><p>Next, merge the two adjacent interval partitions. The new partition again has a system-generated name.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE transactions
MERGE PARTITIONS FOR(TO_DATE('15-JAN-2007','dd-MON-yyyy'))
, FOR(TO_DATE('16-JAN-2007','dd-MON-yyyy'));
</pre><p>The transition point for the <code class="codeph">transactions</code> table has now moved to January 17, 2007. The range section of the interval-partitioned table contains two range partitions: values less than January 1, 2007 and values less than January 17, 2007. Values greater than January 17, 2007 fall in the interval portion of the interval-partitioned table.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1170"></a><div class="props_rev_3"><a id="GUID-49405446-99D3-42F1-A266-9E212F312D3C" name="GUID-49405446-99D3-42F1-A266-9E212F312D3C"></a><h4 id="VLDBG-GUID-49405446-99D3-42F1-A266-9E212F312D3C" class="sect4">Merging List Partitions</h4>
                  <div>
                     <p>When you merge list partitions, the partitions being merged can be any two partitions. </p>
                     <div class="section">
                        <p>They do not need to be adjacent, as for range partitions, because list partitioning does not assume any order for partitions. The resulting partition consists of all of the data from the original two partitions. If you merge a default list partition with any other partition, then the resulting partition is the default partition.</p>
                        <p>The following statement merges two partitions of a table partitioned using the list method into a partition that inherits all of its attributes from the table-level default attributes. <code class="codeph">MAXEXTENTS</code> is specified in the statement.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE q1_sales_by_region 
   MERGE PARTITIONS q1_northcentral, q1_southcentral 
   INTO PARTITION q1_central 
      STORAGE(MAXEXTENTS 20);
</pre><p>The value lists for the two original partitions were specified as:</p><pre class="oac_no_warn" dir="ltr">PARTITION q1_northcentral VALUES ('SD','WI')
PARTITION q1_southcentral VALUES ('OK','TX')
</pre><p>The resulting <code class="codeph">sales_west</code> partition value list comprises the set that represents the union of these two partition value lists, or specifically: 
                        </p><pre class="oac_no_warn" dir="ltr">('SD','WI','OK','TX')</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1171"></a><div class="props_rev_3"><a id="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" name="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6"></a><h4 id="VLDBG-GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" class="sect4">Merging *-Hash Partitions</h4>
                  <div>
                     <p>When you merge *-hash partitions, the subpartitions are rehashed into the number of subpartitions specified by <code class="codeph">SUBPARTITIONS</code> <span class="italic"><code class="codeph">n</code></span> or the <code class="codeph">SUBPARTITION</code> clause. If neither is included, table-level defaults are used.
                     </p>
                     <div class="section">
                        <p>The inheritance of properties is different when a *-hash partition is split, as opposed to when two *-hash partitions are merged. When a partition is split, the new partitions can inherit properties from the original partition because there is only one parent. However, when partitions are merged, properties must be inherited from the table level.</p>
                        <p>For interval-hash partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. The transition point moves when you merge intervals in an interval-hash partitioned table.</p>
                        <p>The following example merges two range-hash partitions:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE all_seasons
   MERGE PARTITIONS quarter_1, quarter_2 INTO PARTITION quarter_2
   SUBPARTITIONS 8;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6__GUID-74D4D16A-A01F-45A0-BA84-FDA81616B23A">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="maintenance-partition-tables-indexes.html#GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" title="You can split a hash partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a *-Hash Partition</a> for information about splitting a hash partition
                                 </p>
                              </li>
                              <li>
                                 <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="The contents of two adjacent interval partitions can be merged into one partition.">Merging Interval Partitions</a> for information about merging interval partitions
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1172"></a><div class="props_rev_3"><a id="GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" name="GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18"></a><h4 id="VLDBG-GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" class="sect4">About Merging *-List Partitions</h4>
                  <div>
                     <p>Partitions can be merged at the partition level and subpartitions can be merged at the list subpartition level.</p>
                     <p>This section contains the following topics.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" title="When you merge two *-list partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if a template exists. If no subpartition template exists, then a single default subpartition is created for the new partition.">Merging Partitions in a *-List Partitioned Table</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" title="You can merge the contents of any two arbitrary list subpartitions belonging to the same partition.">Merging Subpartitions in a *-List Partitioned Table</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1173"></a><div class="props_rev_3"><a id="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" name="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B"></a><h5 id="VLDBG-GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" class="sect5">Merging Partitions in a *-List Partitioned Table</h5>
                     <div>
                        <p> When you merge two *-list partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if a template exists. If no subpartition template exists, then a single default subpartition is created for the new partition.</p>
                        <div class="section">
                           <p>For interval-list partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. The transition point moves when you merge intervals in an interval-list partitioned table.</p>
                           <p>The following statement merges two partitions in the range-list partitioned <code class="codeph">stripe_regional_sales</code> table. A subpartition template exists for the table. 
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE stripe_regional_sales
   MERGE PARTITIONS q1_1999, q2_1999 INTO PARTITION q1_q2_1999
      STORAGE(MAXEXTENTS 20);
</pre><p>Some new physical attributes are specified for this new partition while table-level defaults are inherited for those that are not specified. The new resulting partition <code class="codeph">q1_q2_1999</code> inherits the high-value bound of the partition <code class="codeph">q2_1999</code> and the subpartition value-list descriptions from the subpartition template description of the table.
                           </p>
                           <p>The data in the resulting partitions consists of data from both the partitions. However, there may be cases where the database returns an error. This can occur because data may map out of the new partition when both of the following conditions exist:</p>
                           <p>This error condition can be eliminated by always specifying a default partition in the default subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Some literal values of the merged subpartitions were not included in the subpartition template.</p>
                              </li>
                              <li>
                                 <p>The subpartition template does not contain a default partition definition.</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B__GUID-527E339A-0F9F-4BFC-AF14-C36CA1CC781E">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-49405446-99D3-42F1-A266-9E212F312D3C" title="When you merge list partitions, the partitions being merged can be any two partitions.">Merging List Partitions</a> for information about merging partitions in a *-list partitioned table
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="The contents of two adjacent interval partitions can be merged into one partition.">Merging Interval Partitions</a> for information about merging interval partitions
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1174"></a><div class="props_rev_3"><a id="GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" name="GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E"></a><h5 id="VLDBG-GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" class="sect5">Merging Subpartitions in a *-List Partitioned Table</h5>
                     <div>
                        <p>You can merge the contents of any two arbitrary list subpartitions belonging to the <span class="italic">same</span> partition.
                        </p>
                        <p> The resulting subpartition value-list descriptor includes all of the literal values in the value lists for the partitions being merged.</p>
                        <p>The following statement merges two subpartitions of a table partitioned using range-list method into a new subpartition located in tablespace <code class="codeph">ts4</code>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales
   MERGE SUBPARTITIONS q1_1999_northwest, q1_1999_southwest
      INTO SUBPARTITION q1_1999_west
         TABLESPACE ts4;
</pre><p>The value lists for the original two partitions were:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Subpartition <code class="codeph">q1_1999_northwest</code> was described as <code class="codeph">('WA','OR')</code></p>
                           </li>
                           <li>
                              <p>Subpartition <code class="codeph">q1_1999_southwest</code> was described as <code class="codeph">('AZ','NM','UT')</code></p>
                           </li>
                        </ul>
                        <p>The resulting subpartition value list comprises the set that represents the union of these two subpartition value lists:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Subpartition <code class="codeph">q1_1999_west</code> has a value list described as <code class="codeph">('WA','OR','AZ','NM','UT')</code></p>
                           </li>
                        </ul>
                        <p>The tablespace in which the resulting subpartition is located and the subpartition attributes are determined by the partition-level default attributes, except for those specified explicitly. If any of the existing subpartition names are being reused, then the new subpartition inherits the subpartition attributes of the subpartition whose name is being reused.</p>
                     </div>
                  </div>
               </div><a id="VLDBG1175"></a><div class="props_rev_3"><a id="GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" name="GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0"></a><h4 id="VLDBG-GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" class="sect4">About Merging *-Range Partitions</h4>
                  <div>
                     <p>Partitions can be merged at the partition level and subpartitions can be merged at the range subpartition level.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" title="When you merge two *-range partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if one exists. If no subpartition template exists, then a single subpartition with an upper boundary MAXVALUE is created for the new partition.">Merging Partitions in a *-Range Partitioned Table</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1176"></a><div class="props_rev_3"><a id="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" name="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04"></a><h5 id="VLDBG-GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" class="sect5">Merging Partitions in a *-Range Partitioned Table</h5>
                     <div>
                        <p>When you merge two *-range partitions, the resulting new partition inherits the subpartition descriptions from the subpartition template, if one exists. If no subpartition template exists, then a single subpartition with an upper boundary <code class="codeph">MAXVALUE</code> is created for the new partition.
                        </p>
                        <div class="section">
                           <p>For interval-range partitioned tables, you can only merge two adjacent interval partitions, or the highest range partition with the first interval partition. The transition point moves when you merge intervals in an interval-range partitioned table.</p>
                           <p>The following statement merges two partitions in the monthly interval-range partitioned <code class="codeph">orders</code> table. A subpartition template exists for the table.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders
MERGE PARTITIONS FOR(TO_DATE('01-MAR-2007','dd-MON-yyyy')), 
FOR(TO_DATE('01-APR-2007','dd-MON-yyyy'))
INTO PARTITION p_pre_may_2007;
</pre><p>If the March 2007 and April 2007 partitions were still in the interval section of the interval-range partitioned table, then the merge operation would move the transition point to May 1, 2007.</p>
                           <p>The subpartitions for partition <code class="codeph">p_pre_may_2007</code> inherit their properties from the subpartition template. The data in the resulting partitions consists of data from both the partitions. However, there may be cases where the database returns an error. This can occur because data may map out of the new partition when both of the following conditions are met:
                           </p>
                           <p>The error condition can be eliminated by always specifying a subpartition with an upper boundary of <code class="codeph">MAXVALUE</code> in the subpartition template.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Some range values of the merged subpartitions were not included in the subpartition template.</p>
                              </li>
                              <li>
                                 <p>The subpartition template does not have a subpartition definition with a <code class="codeph">MAXVALUE</code> upper boundary.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04__GUID-AF8AAD2D-FFB1-4B6E-B1E9-FBFAAC281D96">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" title="You can merge the contents of two adjacent range partitions into one partition.">Merging Range Partitions</a> for information about merging partitions in a *-range partitioned table
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="The contents of two adjacent interval partitions can be merged into one partition.">Merging Interval Partitions</a> for information about merging interval partitions
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG14113"></a><div class="props_rev_3"><a id="GUID-54080399-6E59-4706-80C8-690159B20790" name="GUID-54080399-6E59-4706-80C8-690159B20790"></a><h4 id="VLDBG-GUID-54080399-6E59-4706-80C8-690159B20790" class="sect4">Merging Multiple Partitions</h4>
                  <div>
                     <p>You can merge the contents of two or more partitions or subpartitions into one new partition or subpartition and then drop the original partitions or subpartitions with the <code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code> and <code class="codeph">MERGE</code> <code class="codeph">SUBPARTITIONS</code> clauses of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL statement. 
                     </p>
                     <div class="section">
                        <p>The <code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code> and <code class="codeph">MERGE</code> <code class="codeph">SUBPARTITIONS</code> clauses are synonymous with the <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> and <code class="codeph">MERGE</code> <code class="codeph">SUBPARTITION</code> clauses.
                        </p>
                        <p>For example, the following SQL statement merges four partitions into one partition and drops the four partitions that were merged.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t1 MERGE PARTITIONS p01, p02, p03, p04 INTO p0;
</pre><p>When merging multiple range partitions, the partitions must be adjacent and specified in the ascending order of their partition bound values. The new partition inherits the partition upper bound of the highest of the original partitions.</p>
                        <p>You can specify the lowest and the highest partitions to be merged when merging multiple range partitions with the <code class="codeph">TO</code> syntax. All partitions between specified partitions, including those specified, are merged into the target partition. You cannot use this syntax for list and system partitions.
                        </p>
                        <p>For example, the following SQL statements merges partitions <code class="codeph">p01</code> through <code class="codeph">p04</code> into the partition <code class="codeph">p0</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t1 MERGE PARTITIONS p01 TO p04 INTO p0;
</pre><p>List partitions and system partitions that you want to merge do not need to be adjacent, because no ordering of the partitions is assumed. When merging multiple list partitions, the resulting partition value list are the union of the set of partition value list of all of the partitions to be merged. A <code class="codeph">DEFAULT</code> list partition merged with other list partitions results in a <code class="codeph">DEFAULT</code> partition.
                        </p>
                        <p>When merging multiple partitions of a composite partitioned table, the resulting new partition inherits the subpartition descriptions from the subpartition template, if one exists. If no subpartition template exists, then Oracle creates one <code class="codeph">MAXVALUE</code> subpartition from range subpartitions or one <code class="codeph">DEFAULT</code> subpartition from list subpartitions for the new partition. When merging multiple subpartitions of a composite partitioned table, the subpartitions to be merged must belong to the same partition. 
                        </p>
                        <p>When merging multiple partitions, local and global index operations and semantics for inheritance of unspecified physical attributes are the same for merging two partitions.</p>
                        <p>In the following SQL statement, four partitions of the partitioned by range table <code class="codeph">sales</code> are merged. These four partitions that correspond to the four quarters of the oldest year are merged into a single partition containing the entire sales data of the year.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
  MERGE PARTITIONS sales_q1_2009, sales_q2_2009, sales_q3_2009, sales_q4_2009
  INTO PARTITION sales_2009;
</pre><p>The previous SQL statement can be rewritten as the following SQL statement to obtain the same result.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales
  MERGE PARTITIONS sales_q1_2009 TO sales_q4_2009
  INTO PARTITION sales_2009;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" name="GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E"></a><h3 id="VLDBG-GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" class="sect3">About Modifying Attributes of Tables, Partitions, and Subpartitions</h3>
               <div>
                  <p>The modification of attributes of tables, partitions, and subpartitions is introduced in this topic.</p>
                  <p></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" title="You can modify the default attributes of a table, or for a partition of a composite partitioned table.">About Modifying Default Attributes</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" title="It is possible to modify attributes of an existing partition of a table or index.">About Modifying Real Attributes of Partitions</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1177"></a><div class="props_rev_3"><a id="GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" name="GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC"></a><h4 id="VLDBG-GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" class="sect4">About Modifying Default Attributes</h4>
                  <div>
                     <p>You can modify the default attributes of a table, or for a partition of a composite partitioned table.</p>
                     <p>When you modify default attributes, the new attributes affect only future partitions, or subpartitions, that are created. The default values can still be specifically overridden when creating a new partition or subpartition. You can modify the default attributes of a reference-partitioned table.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" title="You can modify the default attributes that are inherited for range, hash, list, interval, or reference partitions using the MODIFY DEFAULT ATTRIBUTES clause of ALTER TABLE.">Modifying Default Attributes of a Table</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" title="To modify the default attributes inherited when creating subpartitions, use the ALTER TABLE MODIFY DEFAULT ATTRIBUTES FOR PARTITION.">Modifying Default Attributes of a Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" title="In a similar fashion to table partitions, you can alter the default attributes that are inherited by partitions of a range-partitioned global index, or local index partitions of partitioned tables.">Modifying Default Attributes of Index Partitions</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1178"></a><div class="props_rev_3"><a id="GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" name="GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657"></a><h5 id="VLDBG-GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" class="sect5">Modifying Default Attributes of a Table</h5>
                     <div>
                        <p>You can modify the default attributes that are inherited for range, hash, list, interval, or reference partitions using the <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> clause of <code class="codeph">ALTER</code> <code class="codeph">TABLE</code>.
                        </p>
                        <div class="section">
                           <p>For hash partitioned tables, only the <code class="codeph">TABLESPACE</code> attribute can be modified.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1179"></a><div class="props_rev_3"><a id="GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" name="GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3"></a><h5 id="VLDBG-GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" class="sect5">Modifying Default Attributes of a Partition</h5>
                     <div>
                        <p>To modify the default attributes inherited when creating subpartitions, use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> <code class="codeph">FOR</code> <code class="codeph">PARTITION</code>.
                        </p>
                        <div class="section">
                           <p>The following statement modifies the <code class="codeph">TABLESPACE</code> in which future subpartitions of partition <code class="codeph">p1</code> in the range-hash partitioned table reside.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE employees_subpartitions
     MODIFY DEFAULT ATTRIBUTES FOR PARTITION p1 TABLESPACE ts1;
</pre><p>Because all subpartitions of a range-hash partitioned table must share the same attributes, except <code class="codeph">TABLESPACE</code>, it is the only attribute that can be changed.
                           </p>
                           <p>You cannot modify default attributes of interval partitions that have not yet been created. To change the way in which future subpartitions in an interval-partitioned table are created, you must modify the subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1180"></a><div class="props_rev_3"><a id="GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" name="GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63"></a><h5 id="VLDBG-GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" class="sect5">Modifying Default Attributes of Index Partitions</h5>
                     <div>
                        <p>In a similar fashion to table partitions, you can alter the default attributes that are inherited by partitions of a range-partitioned global index, or local index partitions of partitioned tables.</p>
                        <div class="section">
                           <p>For this you use the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> statement. Use the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> <code class="codeph">FOR</code> <code class="codeph">PARTITION</code> statement if you are altering default attributes to be inherited by subpartitions of a composite partitioned table.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1181"></a><div class="props_rev_3"><a id="GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" name="GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747"></a><h4 id="VLDBG-GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" class="sect4">About Modifying Real Attributes of Partitions</h4>
                  <div>
                     <p>It is possible to modify attributes of an existing partition of a table or index. </p>
                     <p></p>
                     <p>You cannot change the <code class="codeph">TABLESPACE</code> attribute. Use <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>/<code class="codeph">SUBPARTITION</code> to move a partition or subpartition to a new tablespace.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" title="Use the ALTER TABLE MODIFY PARTITION statement to modify existing attributes of a range partition or list partition.">Modifying Real Attributes for a Range or List Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" title="You can use the ALTER TABLE MODIFY PARTITION statement to modify attributes of a hash partition.">Modifying Real Attributes for a Hash Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" title="With the MODIFY SUBPARTITION clause of ALTER TABLE you can perform the same actions as listed previously for partitions, but at the specific composite partitioned table subpartition level.">Modifying Real Attributes of a Subpartition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" title="The MODIFY PARTITION clause of ALTER INDEX enables you to modify the real attributes of an index partition or its subpartitions.">Modifying Real Attributes of Index Partitions</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1182"></a><div class="props_rev_3"><a id="GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" name="GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33"></a><h5 id="VLDBG-GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" class="sect5">Modifying Real Attributes for a Range or List Partition</h5>
                     <div>
                        <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> statement to modify existing attributes of a range partition or list partition.
                        </p>
                        <p> You can modify segment attributes (except <code class="codeph">TABLESPACE</code>), or you can allocate and deallocate extents, mark local index partitions <code class="codeph">UNUSABLE</code>, or rebuild local indexes that have been marked <code class="codeph">UNUSABLE</code>.
                        </p>
                        <p>If this is a range partition of a *-hash partitioned table, then note the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If you allocate or deallocate an extent, this action is performed for every subpartition of the specified partition.</p>
                           </li>
                           <li>
                              <p>Likewise, changing any other attributes results in corresponding changes to those attributes of all the subpartitions for that partition. The partition level default attributes are changed as well. To avoid changing attributes of existing subpartitions, use the <code class="codeph">FOR</code> <code class="codeph">PARTITION</code> clause of the <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> statement.
                              </p>
                           </li>
                        </ul>
                        <p>The following are some examples of modifying the real attributes of a partition.</p>
                        <p>This example modifies the <code class="codeph">MAXEXTENTS</code> storage attribute for the range partition <code class="codeph">sales_q1</code> of table <code class="codeph">sales</code>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales MODIFY PARTITION sales_q1
     STORAGE (MAXEXTENTS 10); 
</pre><p>All of the local index subpartitions of partition <code class="codeph">ts1</code> in range-hash partitioned table <code class="codeph">scubagear</code> are marked <code class="codeph">UNUSABLE</code> in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear MODIFY PARTITION ts1 UNUSABLE LOCAL INDEXES;
</pre><p>For an interval-partitioned table you can only modify real attributes of range partitions or interval partitions that have been created.</p>
                     </div>
                  </div><a id="VLDBG1183"></a><div class="props_rev_3"><a id="GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" name="GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F"></a><h5 id="VLDBG-GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" class="sect5">Modifying Real Attributes for a Hash Partition</h5>
                     <div>
                        <p>You can use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> statement to modify attributes of a hash partition.
                        </p>
                        <p> However, because the physical attributes of individual hash partitions must all be the same (except for <code class="codeph">TABLESPACE</code>), you are restricted to:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Allocating a new extent</p>
                           </li>
                           <li>
                              <p>Deallocating an unused extent</p>
                           </li>
                           <li>
                              <p>Marking a local index subpartition <code class="codeph">UNUSABLE</code> 
                              </p>
                           </li>
                           <li>
                              <p>Rebuilding local index subpartitions that are marked <code class="codeph">UNUSABLE </code></p>
                           </li>
                        </ul>
                        <p>The following example rebuilds any unusable local index partitions associated with hash partition <code class="codeph">p1</code> of the table:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE departments_rebuild_index MODIFY PARTITION p1
     REBUILD UNUSABLE LOCAL INDEXES;</pre></div>
                  </div><a id="VLDBG1184"></a><div class="props_rev_3"><a id="GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" name="GUID-0B6418C4-C282-40D1-837A-6426F216BBA9"></a><h5 id="VLDBG-GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" class="sect5">Modifying Real Attributes of a Subpartition</h5>
                     <div>
                        <p>With the <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> clause of <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> you can perform the same actions as listed previously for partitions, but at the specific composite partitioned table subpartition level.
                        </p>
                        <p> For example:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE employees_rebuild_index MODIFY SUBPARTITION p3_s1
     REBUILD UNUSABLE LOCAL INDEXES;</pre></div>
                  </div><a id="VLDBG1185"></a><div class="props_rev_3"><a id="GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" name="GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7"></a><h5 id="VLDBG-GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" class="sect5">Modifying Real Attributes of Index Partitions</h5>
                     <div>
                        <p>The <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> clause of <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> enables you to modify the real attributes of an index partition or its subpartitions.
                        </p>
                        <p> The rules are very similar to those for table partitions, but unlike the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> clause for <code class="codeph">ALTER</code> <code class="codeph">INDEX</code>, there is no subclause to rebuild an unusable index partition, but there is a subclause to coalesce an index partition or its subpartitions. In this context, coalesce means to merge index blocks where possible to free them for reuse.
                        </p>
                        <p>You can also allocate or deallocate storage for a subpartition of a local index, or mark it <code class="codeph">UNUSABLE</code>, using the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> clause.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" name="GUID-AA8A163D-7812-41B3-9B97-73EFB4034607"></a><h3 id="VLDBG-GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" class="sect3">About Modifying List Partitions</h3>
               <div>
                  <p>The modification of values in list partitions and subpartitions is introduced in this topic.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" title="List partitioning enables you to optionally add literal values from the defining value list.">About Modifying List Partitions: Adding Values</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" title="List partitioning enables you to optionally drop literal values from the defining value list.">About Modifying List Partitions: Dropping Values</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1186"></a><div class="props_rev_3"><a id="GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" name="GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5"></a><h4 id="VLDBG-GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" class="sect4">About Modifying List Partitions: Adding Values</h4>
                  <div>
                     <p>List partitioning enables you to optionally add literal values from the defining value list.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" title="Use the MODIFY PARTITION ADD VALUES clause of the ALTER TABLE statement to extend the value list of an existing partition.">Adding Values for a List Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" title="Use the MODIFY SUBPARTITION ADD VALUES clause of the ALTER TABLE statement to extend the value list of an existing subpartition.">Adding Values for a List Subpartition</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1187"></a><div class="props_rev_3"><a id="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" name="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A"></a><h5 id="VLDBG-GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" class="sect5">Adding Values for a List Partition </h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">VALUES</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to extend the value list of an existing partition.
                        </p>
                        <div class="section">
                           <p> Literal values being added must not have been included in any other partition value list. The partition value list for any corresponding local index partition is correspondingly extended, and any global indexes, or global or local index partitions, remain usable.</p>
                           <p>The following statement adds a new set of state codes ('<code class="codeph">OK</code>', '<code class="codeph">KS</code>') to an existing partition list.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region
   MODIFY PARTITION region_south
      ADD VALUES ('OK', 'KS');
</pre><p>The existence of a default partition can have a performance impact when adding values to other partitions. This is because to add values to a list partition, the database must check that the values being added do not exist in the default partition. If any of the values do exist in the default partition, then an error is displayed.</p>
                           <div class="infoboxnote" id="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A__GUID-BE939F94-994D-4FA4-B552-64980EDD8E12">
                              <p class="notep1">Note:</p>
                              <p>The database runs a query to check for the existence of rows in the default partition that correspond to the literal values being added. Therefore, it is advisable to create a local prefixed index on the table. This speeds up the execution of the query and the overall operation.</p>
                           </div>
                           <p>You cannot add values to a default list partition. </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1188"></a><div class="props_rev_3"><a id="GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" name="GUID-1597E3D3-46F7-4615-B55B-A06B47B54279"></a><h5 id="VLDBG-GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" class="sect5">Adding Values for a List Subpartition</h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">ADD</code> <code class="codeph">VALUES</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to extend the value list of an existing subpartition.
                        </p>
                        <div class="section">
                           <p>This operation is essentially the same as described for <a href="maintenance-partition-tables-indexes.html#GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" title="List partitioning enables you to optionally add literal values from the defining value list.">About Modifying List Partitions: Adding Values</a>, however, you use a <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> clause instead of the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> clause. For example, to extend the range of literal values in the value list for subpartition <code class="codeph">q1_1999_southeast</code>, use the following statement:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales
   MODIFY SUBPARTITION q1_1999_southeast
      ADD VALUES ('KS');
</pre><p>Literal values being added must not have been included in any other subpartition value list within the owning partition. However, they can be duplicates of literal values in the subpartition value lists of other partitions within the table. </p>
                           <p>For an interval-list composite partitioned table, you can only add values to subpartitions of range partitions or interval partitions that have been created. To add values to subpartitions of interval partitions that have not yet been created, you must modify the subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1189"></a><div class="props_rev_3"><a id="GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" name="GUID-C5819AF5-C357-4553-80E2-3ACA271F532B"></a><h4 id="VLDBG-GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" class="sect4">About Modifying List Partitions: Dropping Values</h4>
                  <div>
                     <p>List partitioning enables you to optionally drop literal values from the defining value list.</p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" title="Use the MODIFY PARTITION DROP VALUES clause of the ALTER TABLE statement to remove literal values from the value list of an existing partition.">Dropping Values from a List Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-63402906-D104-481C-B530-7D1315A22913" title="Use the MODIFY SUBPARTITION DROP VALUES clause of the ALTER TABLE statement to remove literal values from the value list of an existing subpartition.">Dropping Values from a List Subpartition</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1190"></a><div class="props_rev_3"><a id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" name="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF"></a><h5 id="VLDBG-GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" class="sect5">Dropping Values from a List Partition</h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">DROP</code> <code class="codeph">VALUES</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to remove literal values from the value list of an existing partition.
                        </p>
                        <div class="section">
                           <p> The statement is always executed with validation, meaning that it checks to see if any rows exist in the partition that corresponds to the set of values being dropped. If any such rows are found then the database returns an error message and the operation fails. When necessary, use a <code class="codeph">DELETE</code> statement to delete corresponding rows from the table before attempting to drop values.
                           </p>
                           <div class="infoboxnote" id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF__GUID-DAE1E325-29B1-4538-BDF9-413371C65260">
                              <p class="notep1">Note:</p>
                              <p>You cannot drop all literal values from the value list describing the partition. You must use the <code class="codeph">ALTER TABLE DROP PARTITION</code> statement instead.
                              </p>
                           </div>
                           <p>The partition value list for any corresponding local index partition reflects the new value list, and any global index, or global or local index partitions, remain usable.</p>
                           <p>The following statement drops a set of state codes ('<code class="codeph">OK</code>' and '<code class="codeph">KS</code>') from an existing partition value list. 
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region
   MODIFY PARTITION region_south
      DROP VALUES ('OK', 'KS');</pre><div class="infoboxnote" id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF__GUID-AA6B9442-F71C-463F-8991-F39056D48B43">
                              <p class="notep1">Note:</p>
                              <p>The database runs a query to check for the existence of rows in the partition that correspond to the literal values being dropped. Therefore, it is advisable to create a local prefixed index on the table. This speeds up the query and the overall operation.</p>
                           </div>
                           <p>You cannot drop values from a default list partition.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1191"></a><div class="props_rev_3"><a id="GUID-63402906-D104-481C-B530-7D1315A22913" name="GUID-63402906-D104-481C-B530-7D1315A22913"></a><h5 id="VLDBG-GUID-63402906-D104-481C-B530-7D1315A22913" class="sect5">Dropping Values from a List Subpartition</h5>
                     <div>
                        <p>Use the <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">DROP</code> <code class="codeph">VALUES</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to remove literal values from the value list of an existing subpartition.
                        </p>
                        <div class="section">
                           <p>This operation is essentially the same as described for <a href="maintenance-partition-tables-indexes.html#GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" title="List partitioning enables you to optionally drop literal values from the defining value list.">About Modifying List Partitions: Dropping Values</a>, however, you use a <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> clause instead of the <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> clause. For example, to remove a set of literal values in the value list for subpartition <code class="codeph">q1_1999_southeast</code>, use the following statement:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales
   MODIFY SUBPARTITION q1_1999_southeast
      DROP VALUES ('KS');
</pre><p>For an interval-list composite partitioned table, you can only drop values from subpartitions of range partitions or interval partitions that have been created. To drop values from subpartitions of interval partitions that have not yet been created, you must modify the subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-763391C6-44E8-401D-8119-DC12926F5877" name="GUID-763391C6-44E8-401D-8119-DC12926F5877"></a><h3 id="VLDBG-GUID-763391C6-44E8-401D-8119-DC12926F5877" class="sect3">About Modifying the Partitioning Strategy</h3>
               <div>
                  <p>You can change the partitioning strategy of a regular (heap-organized) table with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> SQL statement.
                  </p>
                  <p>Modifying the partitioning strategy, such as hash  partitioning to composite range-hash partitioning, can be performed offline or online. When performed in online mode, the conversion does not impact ongoing DML operations. When performed in offline mode, the conversion does not allow concurrent DML operations during the modification.</p>
                  <p>Indexes are maintained as part of the table modification. When modifying the partitioning strategy, all unspecified indexes whose index columns are a prefix of the new partitioning key are automatically converted to a local partitioned index; otherwise, an index is converted to global index.</p>
                  <p>The modification operation is not supported with domain indexes. The <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause cannot change the columns on which the list of indexes was originally defined or the uniqueness property of the index or any other index property.
                  </p>
                  <p>For information about converting a non-partitioned table to a partitioned table, refer to <a href="evolve-nopartition-table.html#GUID-5FDB7D59-DD05-40E4-8AB4-AF82EA0D0FE5" title="A non-partitioned table can be converted to a partitioned table with a MODIFY clause added to the ALTER TABLE SQL statement.">Converting a Non-Partitioned Table to a Partitioned Table</a>.
                  </p>
                  <p><a href="maintenance-partition-tables-indexes.html#GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-48123038-29A5-4133-B64D-3D7C564B34FC">Example 4-34</a> shows the use of <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> to convert a range partitioned table to a composite range-hash partitioned table online. During the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> modification in the example, indexes are updated.
                  </p>
                  <div class="infoboxnote" id="GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-B1C8D002-005E-4FCC-920C-8496A776B681">
                     <p class="notep1">Live SQL:</p>
                     <p>View and run a related example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/modify-partitioning-strategy.html" target="_blank"><span class="italic">Modifying the Partitioning Strategy of a Table</span></a>.
                     </p>
                  </div>
                  <div class="example" id="GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-48123038-29A5-4133-B64D-3D7C564B34FC">
                     <p class="titleinexample">Example 4-34 Modifying the partitioning strategy</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mod_sales_partitioning
  ( prod_id       NUMBER        NOT NULL,
    cust_id       NUMBER        NOT NULL,
    time_id       DATE          NOT NULL,
    channel_id    NUMBER        NOT NULL,
    promo_id      NUMBER        NOT NULL,
    quantity_sold NUMBER(10,2)  NOT NULL,
    amount_sold   NUMBER(10,2)  NOT NULL
  )
  PARTITION BY RANGE (time_id)
  (PARTITION sales_q1_2017 VALUES LESS THAN (TO_DATE('01-APR-2017','dd-MON-yyyy')),
   PARTITION sales_q2_2017 VALUES LESS THAN (TO_DATE('01-JUL-2017','dd-MON-yyyy')),
   PARTITION sales_q3_2017 VALUES LESS THAN (TO_DATE('01-OCT-2017','dd-MON-yyyy')),
   PARTITION sales_q4_2017 VALUES LESS THAN (TO_DATE('01-JAN-2018','dd-MON-yyyy'))
 ); 

CREATE INDEX i1_cust_id_indx ON mod_sales_partitioning (cust_id) LOCAL;
CREATE INDEX i2_time_id_indx ON mod_sales_partitioning (time_id);
CREATE INDEX i3_prod_id_indx ON mod_sales_partitioning (prod_id);

SELECT TABLE_NAME, PARTITIONING_TYPE FROM USER_PART_TABLES WHERE TABLE_NAME ='MOD_SALES_PARTITIONING';
TABLE_NAME                PARTITION_NAME 
------------------------- --------------
MOD_SALES_PARTITIONING    RANGE

SELECT TABLE_NAME, PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='MOD_SALES_PARTITIONING';
TABLE_NAME                PARTITION_NAME 
------------------------- --------------
MOD_SALES_PARTITIONING    SALES_Q1_2017
MOD_SALES_PARTITIONING    SALES_Q2_2017
MOD_SALES_PARTITIONING    SALES_Q3_2017
MOD_SALES_PARTITIONING    SALES_Q4_2017
...

ALTER TABLE mod_sales_partitioning
 MODIFY 
 PARTITION BY RANGE (time_id) SUBPARTITION BY HASH (cust_id)
  SUBPARTITIONS 8
 ( PARTITION  sales_q1_2017 VALUES LESS THAN (TO_DATE('01-APR-2017','dd-MON-yyyy')),
    PARTITION sales_q2_2017 VALUES LESS THAN (TO_DATE('01-JUL-2017','dd-MON-yyyy')),
    PARTITION sales_q3_2017 VALUES LESS THAN (TO_DATE('01-OCT-2017','dd-MON-yyyy')),
    PARTITION sales_q4_2017 VALUES LESS THAN (TO_DATE('01-JAN-2018','dd-MON-yyyy')))
    ONLINE
  UPDATE INDEXES
   ( i1_cust_id_indx LOCAL, 
     i2_time_id_indx GLOBAL PARTITION BY RANGE (time_id) 
     (PARTITION ip1_indx VALUES LESS THAN (MAXVALUE) ) );

SELECT TABLE_NAME, PARTITIONING_TYPE, SUBPARTITIONING_TYPE FROM USER_PART_TABLES WHERE TABLE_NAME ='MOD_SALES_PARTITIONING';
TABLE_NAME                  PARTITION      SUBPARTIT
--------------------------- -------------- ----------
MOD_SALES_PARTITIONING      RANGE          HASH

SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='MOD_SALES_PARTITIONING';
TABLE_NAME                  PARTITION_NAME     SUBPARTITION_NAME 
--------------------------- ------------------ ------------------
MOD_SALES_PARTITIONING      SALES_Q1_2017      SYS_SUBP567       
MOD_SALES_PARTITIONING      SALES_Q1_2017      SYS_SUBP568
MOD_SALES_PARTITIONING      SALES_Q1_2017      SYS_SUBP569
MOD_SALES_PARTITIONING      SALES_Q1_2017      SYS_SUBP570
...
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1193"></a><div class="props_rev_3"><a id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" name="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0"></a><h3 id="VLDBG-GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" class="sect3">About Moving Partitions and Subpartitions</h3>
               <div>
                  <p>Use the <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement to change the physical storage attributes of a partition.
                  </p>
                  <p>With the <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement, you can: 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Re-cluster data and reduce fragmentation</p>
                     </li>
                     <li>
                        <p>Move a partition to another tablespace</p>
                     </li>
                     <li>
                        <p>Modify create-time attributes</p>
                     </li>
                     <li>
                        <p>Store the data in compressed format using table compression</p>
                     </li>
                  </ul>
                  <p>Typically, you can change the physical storage attributes of a partition in a single step using an <code class="codeph">ALTER</code> <code class="codeph">TABLE</code>/<code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> statement. However, there are some physical attributes, such as <code class="codeph">TABLESPACE</code>, that you cannot modify using <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>. In these cases, use the <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> clause. Modifying some other attributes, such as table compression, affects only future storage, but not existing data.
                  </p>
                  <p>If the partition being moved contains any data, then indexes may be marked <code class="codeph">UNUSABLE</code> according to the following table:
                  </p>
                  <div class="tblformal" id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0__GUID-85C83634-E4E4-434F-A378-1AE2DE747897">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e9641">Table Type</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e9644">Index Behavior</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e9649" headers="d29958e9641 ">
                                 <p>Regular (Heap)</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e9649 d29958e9644 ">
                                 <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> as part of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The matching partition in each local index is marked <code class="codeph">UNUSABLE</code>. You must rebuild these index partitions after issuing <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>Any global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code>.
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e9687" headers="d29958e9641 ">
                                 <p>Index-organized</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e9687 d29958e9644 ">
                                 <p>Any local or global indexes defined for the partition being moved remain usable because they are primary-key based logical rowids. However, the guess information for these rowids becomes incorrect.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" title="Use the MOVE PARTITION clause to move a partition.">Moving Table Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" title="Use the MOVE SUBPARTITION clause to move a subpartition.">Moving Subpartitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" title="The ALTER TABLE MOVE PARTITION statement for regular tables marks all partitions of a global index UNUSABLE.">Moving Index Partitions</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0__GUID-34FC37B3-3AC2-4FE4-9CEE-10B88B872D0B">
                     <p class="notep1">see Also:</p>
                     <p></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> statement
                           </p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-tables.html#ADMIN11659" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for information moving tables and partitions
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1194"></a><div class="props_rev_3"><a id="GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" name="GUID-793919DF-78AB-4B9D-874D-54C37D97F67F"></a><h4 id="VLDBG-GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" class="sect4">Moving Table Partitions</h4>
                  <div>
                     <p>Use the <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> clause to move a partition.
                     </p>
                     <div class="section">
                        <p> For example, to move the most active partition to a tablespace that resides on its own set of disks (to balance I/O), not log the action, and compress the data, issue the following statement:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE parts MOVE PARTITION depot2
     TABLESPACE ts094 NOLOGGING COMPRESS;
</pre><p>This statement always drops the old partition segment and creates a new segment, even if you do not specify a new tablespace. </p>
                        <p>If you are moving a partition of a partitioned index-organized table, then you can specify the <code class="codeph">MAPPING</code> <code class="codeph">TABLE</code> clause as part of the <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> clause, and the mapping table partition are moved to the new location along with the table partition.
                        </p>
                        <p>For an interval or interval-* partitioned table, you can only move range partitions or interval partitions that have been materialized. A partition move operation does not move the transition point in an interval or interval-* partitioned table.</p>
                        <p>You can move a partition in a reference-partitioned table independent of the partition in the master table.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1195"></a><div class="props_rev_3"><a id="GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" name="GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F"></a><h4 id="VLDBG-GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" class="sect4">Moving Subpartitions</h4>
                  <div>
                     <p>Use the <code class="codeph">MOVE</code> <code class="codeph">SUBPARTITION</code> clause to move a subpartition.
                     </p>
                     <div class="section">
                        <p>The following statement shows how to move data in a subpartition of a table. In this example, a <code class="codeph">PARALLEL</code> clause has also been specified.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scuba_gear MOVE SUBPARTITION bcd_types 
     TABLESPACE tbs23 PARALLEL (DEGREE 2);
</pre><p>You can move a subpartition in a reference-partitioned table independent of the subpartition in the master table.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1196"></a><div class="props_rev_3"><a id="GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" name="GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC"></a><h4 id="VLDBG-GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" class="sect4">Moving Index Partitions</h4>
                  <div>
                     <p>The <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> statement for regular tables marks all partitions of a global index <code class="codeph">UNUSABLE</code>.
                     </p>
                     <div class="section">
                        <p> You can rebuild the entire index by rebuilding each partition individually using the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code> statement. You can perform these rebuilds concurrently.
                        </p>
                        <p>You can also simply drop the index and re-create it. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1198"></a><div class="props_rev_3"><a id="GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" name="GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E"></a><h3 id="VLDBG-GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" class="sect3">About Rebuilding Index Partitions</h3>
               <div>
                  <p>Rebuilding an index provides several advantages.</p>
                  <p>Some reasons for rebuilding index partitions include:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>To recover space and improve performance</p>
                     </li>
                     <li>
                        <p>To repair a damaged index partition caused by media failure</p>
                     </li>
                     <li>
                        <p>To rebuild a local index partition after loading the underlying table partition with SQL*Loader or an import utility</p>
                     </li>
                     <li>
                        <p>To rebuild index partitions that have been marked <code class="codeph">UNUSABLE</code> 
                        </p>
                     </li>
                     <li>
                        <p>To enable key compression for B-tree indexes</p>
                     </li>
                  </ul>
                  <p>The following sections discuss options for rebuilding index partitions and subpartitions.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" title="You can rebuild global index partitions with several methods.">About Rebuilding Global Index Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" title="You can rebuild local index partitions with several methods.">About Rebuilding Local Index Partitions</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1199"></a><div class="props_rev_3"><a id="GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" name="GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20"></a><h4 id="VLDBG-GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" class="sect4">About Rebuilding Global Index Partitions</h4>
                  <div>
                     <p>You can rebuild global index partitions with several methods.</p>
                     <p></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Rebuild each partition by issuing the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code> statement (you can run the rebuilds concurrently).
                           </p>
                        </li>
                        <li>
                           <p>Drop the entire global index and re-create it. This method is more efficient because the table is scanned only one time.</p>
                        </li>
                     </ul>
                     <p>For most maintenance operations on partitioned tables with indexes, you can optionally avoid the need to rebuild the index by specifying <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> on your DDL statement.
                     </p>
                  </div>
               </div><a id="VLDBG1200"></a><div class="props_rev_3"><a id="GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" name="GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44"></a><h4 id="VLDBG-GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" class="sect4">About Rebuilding Local Index Partitions</h4>
                  <div>
                     <p>You can rebuild local index partitions with several methods.</p>
                     <p>Rebuild local indexes using either <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> or <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> as follows: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code>/<code class="codeph">SUBPARTITION</code> 
                           </p>
                           <p>This statement rebuilds an index partition or subpartition unconditionally.</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>/<code class="codeph">SUBPARTITION</code> <code class="codeph">REBUILD</code> <code class="codeph">UNUSABLE</code> <code class="codeph">LOCAL</code> <code class="codeph">INDEXES</code> 
                           </p>
                           <p>This statement finds all of the unusable indexes for the given table partition or subpartition and rebuilds them. It only rebuilds an index partition if it has been marked <code class="codeph">UNUSABLE</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The following sections contain examples about rebuilding indexes.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" title="The ALTER INDEX REBUILD PARTITION statement rebuilds one partition of an index.">Using ALTER INDEX to Rebuild a Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" title="The REBUILD UNUSABLE LOCAL INDEXES clause of ALTER TABLE MODIFY PARTITION enables you to rebuild an unusable index partition.">Using ALTER TABLE to Rebuild an Index Partition</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1201"></a><div class="props_rev_3"><a id="GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" name="GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D"></a><h5 id="VLDBG-GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" class="sect5">Using ALTER INDEX to Rebuild a Partition</h5>
                     <div>
                        <p>The <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code> statement rebuilds one partition of an index.
                        </p>
                        <div class="section">
                           <p> It cannot be used for composite-partitioned tables. Only real physical segments can be rebuilt with this command. When you re-create the index, you can also choose to move the partition to a new tablespace or change attributes.</p>
                           <p>For composite-partitioned tables, use <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">SUBPARTITION</code> to rebuild a subpartition of an index. You can move the subpartition to another tablespace or specify a parallel clause. The following statement rebuilds a subpartition of a local index on a table and moves the index subpartition to another tablespace.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX scuba
   REBUILD SUBPARTITION bcd_types
   TABLESPACE tbs23 PARALLEL (DEGREE 2);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1202"></a><div class="props_rev_3"><a id="GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" name="GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962"></a><h5 id="VLDBG-GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" class="sect5">Using ALTER TABLE to Rebuild an Index Partition</h5>
                     <div>
                        <p>The <code class="codeph">REBUILD</code> <code class="codeph">UNUSABLE</code> <code class="codeph">LOCAL</code> <code class="codeph">INDEXES</code> clause of <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> enables you to rebuild an unusable index partition.
                        </p>
                        <div class="section">
                           <p>However, the statement does not allow you to specify any new attributes for the rebuilt index partition. The following example finds and rebuilds any unusable local index partitions for table <code class="codeph">scubagear</code>, partition <code class="codeph">p1</code>.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear
   MODIFY PARTITION p1 REBUILD UNUSABLE LOCAL INDEXES;
</pre><p>The <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> is the clause for rebuilding unusable local index subpartitions. 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1203"></a><div class="props_rev_3"><a id="GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" name="GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E"></a><h3 id="VLDBG-GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" class="sect3">About Renaming Partitions and Subpartitions</h3>
               <div>
                  <p>You can rename partitions and subpartitions of both tables and indexes.</p>
                  <p>One reason for renaming a partition might be to assign a meaningful name, as opposed to a default system name that was assigned to the partition in another maintenance operation.</p>
                  <p>All partitioning methods support the <code class="codeph">FOR(</code><span class="italic"><code class="codeph">value</code></span><code class="codeph">)</code> method to identify a partition. You can use this method to rename a system-generated partition name into a more meaningful name. This is particularly useful in interval or interval-* partitioned tables.
                  </p>
                  <p>You can independently rename partitions and subpartitions for reference-partitioned master and child tables. The rename operation on the master table is not cascaded to descendant tables.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" title="You can rename a range, hash, or list partition, using the ALTER TABLE RENAME PARTITION statement.">Renaming a Table Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" title="You can assign new names to subpartitions of a table.">Renaming a Table Subpartition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" title="You can rename index partitions and subpartitions with the ALTER INDEX statement.">About Renaming Index Partitions</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1204"></a><div class="props_rev_3"><a id="GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" name="GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3"></a><h4 id="VLDBG-GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" class="sect4">Renaming a Table Partition</h4>
                  <div>
                     <p>You can rename a range, hash, or list partition, using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p> For example:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear RENAME PARTITION sys_p636 TO tanks;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1205"></a><div class="props_rev_3"><a id="GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" name="GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD"></a><h4 id="VLDBG-GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" class="sect4">Renaming a Table Subpartition</h4>
                  <div>
                     <p>You can assign new names to subpartitions of a table.</p>
                     <div class="section">
                        <p>In this case, you would use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> <code class="codeph">SUBPARTITION</code> syntax.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1206"></a><div class="props_rev_3"><a id="GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" name="GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520"></a><h4 id="VLDBG-GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" class="sect4">About Renaming Index Partitions</h4>
                  <div>
                     <p>You can rename index partitions and subpartitions with the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> statement.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" title="Use the ALTER INDEX RENAME PARTITION statement to rename an index partition.">Renaming an Index Partition</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" title="Use the ALTER INDEX RENAME SUBPARTITION statement to rename an index subpartition.">Renaming an Index Subpartition</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1207"></a><div class="props_rev_3"><a id="GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" name="GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E"></a><h5 id="VLDBG-GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" class="sect5">Renaming an Index Partition</h5>
                     <div>
                        <p>Use the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">RENAME</code> <code class="codeph">PARTITION</code> statement to rename an index partition.
                        </p>
                        <div class="section">
                           <p>The <code class="codeph">ALTER INDEX</code> statement does not support the use of <code class="codeph">FOR(</code><span class="italic"><code class="codeph">value</code></span><code class="codeph">)</code> to identify a partition. You must use the original partition name in the rename operation.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1208"></a><div class="props_rev_3"><a id="GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" name="GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104"></a><h5 id="VLDBG-GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" class="sect5">Renaming an Index Subpartition</h5>
                     <div>
                        <p>Use the <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">RENAME</code> <code class="codeph">SUBPARTITION</code> statement to rename an index subpartition.
                        </p>
                        <div class="section">
                           <p>The following statement simply shows how to rename a subpartition that has a system generated name that was a consequence of adding a partition to an underlying table:</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX scuba RENAME SUBPARTITION sys_subp3254 TO bcd_types;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG00303"></a><div class="props_rev_3"><a id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" name="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B"></a><h3 id="VLDBG-GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" class="sect3">About Splitting Partitions and Subpartitions</h3>
               <div>
                  <p>You can split the contents of a partition into two new partitions.</p>
                  <p>The <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> or <code class="codeph">ALTER</code> <code class="codeph">INDEX</code> statement is used to redistribute the contents of a partition into two new partitions. Consider doing this when a partition becomes too large and causes backup, recovery, or maintenance operations to take a long time to complete or it is felt that there is simply too much data in the partition. You can also use the <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> clause to redistribute the I/O load. This clause cannot be used for hash partitions or subpartitions. 
                  </p>
                  <p>If the partition you are splitting contains any data, then indexes may be marked <code class="codeph">UNUSABLE</code> as explained in the following table:
                  </p>
                  <div class="tblformal" id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B__GUID-F11F75FA-24A6-4561-87BF-8C527685C133">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e11505">Table Type</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e11508">Index Behavior</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e11513" headers="d29958e11505 ">
                                 <p>Regular (Heap)</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e11513 d29958e11508 ">
                                 <p>Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> as part of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The database marks <code class="codeph">UNUSABLE</code> the new partitions (there are two) in each local index. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>Any global indexes, or all partitions of partitioned global indexes, are marked <code class="codeph">UNUSABLE</code> and must be rebuilt.
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e11545" headers="d29958e11505 ">
                                 <p>Index-organized</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e11545 d29958e11508 ">
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The database marks <code class="codeph">UNUSABLE</code> the new partitions (there are two) in each local index. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>All global indexes remain usable.</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>You cannot split partitions or subpartitions in a reference-partitioned table except for the parent table. When you split partitions or subpartitions in the parent table then the split is cascaded to all descendant tables. However, you can use the <code class="codeph">DEPENDENT TABLES</code> clause to set specific properties for dependent tables when you issue the <code class="codeph">SPLIT</code> statement on the master table to split partitions or subpartitions.
                  </p>
                  <p>Partition maintenance with <code class="codeph">SPLIT</code> operations are supported as online operations with the keyword <code class="codeph">ONLINE</code> for heap organized tables, enabling concurrent DML operations while a partition maintenance operation is ongoing. 
                  </p>
                  <p>For <code class="codeph">ONLINE</code> operations, split indexes are always updated by default, regardless whether you specify the <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause.
                  </p>
                  <p>For an example of the use of the keyword <code class="codeph">ONLINE</code> with a <code class="codeph">SPLIT</code> operation, see <a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__SPLITTINGAPARTITIONOFARANGE-PARTITI-F7059E9E">Example 4-36</a>.
                  </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="You can split a range partition using the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a Range-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="You can split a list partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a List-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-D329CC2A-57CB-470D-8990-89C5240F029C" title="You can split a range or a materialized interval partition with the ALTER TABLE SPLIT PARTITION statement in an interval-partitioned table.">Splitting a Partition of an Interval-Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" title="You can split a hash partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a *-Hash Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" title="Partitions can be split at both the partition level and at the subpartition level in a list partitioned table..">Splitting Partitions in a *-List Partitioned Table</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" title="You can split a range partition using the ALTER TABLE SPLIT PARTITION statement.">Splitting a *-Range Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" title="You cannot explicitly split a partition in a local index. A local index partition is split only when you split a partition in the underlying table.">Splitting Index Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" title="You can redistribute the contents of one partition or subpartition into multiple partitions or subpartitions with the SPLIT PARTITION and SPLIT SUBPARTITION clauses of the ALTER TABLE statement.">Splitting into Multiple Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" title="Oracle Database implements a SPLIT PARTITION operation by creating two new partitions and redistributing the rows from the partition being split into the two new partitions.">Fast SPLIT PARTITION and SPLIT SUBPARTITION Operations</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B__GUID-AF409B04-E26B-4655-B6D7-72E901FD64B2">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                  </div>
               </div><a id="VLDBG1209"></a><div class="props_rev_3"><a id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" name="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8"></a><h4 id="VLDBG-GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" class="sect4">Splitting a Partition of a Range-Partitioned Table</h4>
                  <div>
                     <p>You can split a range partition using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p>In the SQL statement, you must specify values of the partitioning key column within the range of the partition at which to split the partition. </p>
                        <p>You can optionally specify new attributes for the partitions resulting from the split. If there are local indexes defined on the table, this statement also splits the matching partition in each local index.</p>
                        <p>If you do not specify new partition names, then the database assigns names of the form <code class="codeph">SYS_P</code><span class="italic"><code class="codeph">n</code></span>. You can examine the data dictionary to locate the names assigned to the new local index partitions. You may want to rename them. Any attributes that you do not specify are inherited from the original partition. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__GUID-93E946E8-A9E4-4F6B-9D04-1B5FFDE6C579">
                        <p class="titleinexample">Example 4-35 Splitting a partition of a range-partitioned table and rebuilding indexes</p>
                        <p>In this example <code class="codeph">fee_katy</code> is a partition in the table <code class="codeph">vet_cats</code>, which has a local index, <code class="codeph">jaf1</code>. There is also a global index, <code class="codeph">vet</code> on the table. <code class="codeph">vet</code> contains two partitions, <code class="codeph">vet_parta</code>, and <code class="codeph">vet_partb</code>. The first of the resulting two new partitions includes all rows in the original partition whose partitioning key column values map lower than the specified value. The second partition contains all rows whose partitioning key column values map greater than or equal to the specified value. The following SQL statement split the partition <code class="codeph">fee_katy</code>, and rebuild the index partitions.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE vet_cats SPLIT PARTITION 
      fee_katy at (100) INTO ( PARTITION
      fee_katy1, PARTITION fee_katy2);
ALTER INDEX JAF1 REBUILD PARTITION fee_katy1;
ALTER INDEX JAF1 REBUILD PARTITION fee_katy2;
ALTER INDEX VET REBUILD PARTITION vet_parta;
ALTER INDEX VET REBUILD PARTITION vet_partb;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__SPLITTINGAPARTITIONOFARANGE-PARTITI-F7059E9E">
                        <p class="titleinexample">Example 4-36 Splitting a partition of a range-partitioned table online</p>
                        <p>In this example, the <code class="codeph">sales_q4_2016</code> partition of the<code class="codeph">ORDERS</code> table is split into separate partitions for each month. The <code class="codeph">ONLINE</code> keyword is specified to enable concurrent DML operations while a partition maintenance operation is ongoing. 
                        </p>
                        <p>If there were any indexes on the <code class="codeph">ORDERS</code> table, then those would be maintained automatically as part of the online split.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders
 (prod_id       NUMBER(6),
  cust_id       NUMBER,
  time_id       DATE,
  channel_id    CHAR(1),
  promo_id      NUMBER(6),
  quantity_sold NUMBER(3),
  amount_sold   NUMBER(10,2)
  ) 
  PARTITION BY RANGE (time_id)
  (PARTITION sales_q1_2016 VALUES LESS THAN (TO_DATE('01-APR-2016','dd-MON-yyyy')),
   PARTITION sales_q2_2016 VALUES LESS THAN (TO_DATE('01-JUL-2016','dd-MON-yyyy')),
   PARTITION sales_q3_2016 VALUES LESS THAN (TO_DATE('01-OCT-2016','dd-MON-yyyy')),
   PARTITION sales_q4_2016 VALUES LESS THAN (TO_DATE('01-JAN-2017','dd-MON-yyyy')) 
   );

ALTER TABLE orders 
  SPLIT PARTITION sales_q4_2016 INTO
  (PARTITION sales_oct_2016 VALUES LESS THAN (TO_DATE('01-NOV-2016','dd-MON-yyyy')),
   PARTITION sales_nov_2016 VALUES LESS THAN (TO_DATE('01-DEC-2016','dd-MON-yyyy')),
   PARTITION sales_dec_2016
   )
  ONLINE;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1210"></a><div class="props_rev_3"><a id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" name="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA"></a><h4 id="VLDBG-GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" class="sect4">Splitting a Partition of a List-Partitioned Table</h4>
                  <div>
                     <p>You can split a list partition with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p>The <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> clause enables you to specify a list of literal values that define a partition into which rows with corresponding partitioning key values are inserted. The remaining rows of the original partition are inserted into a second partition whose value list contains the remaining values from the original partition. You can optionally specify new attributes for the two partitions that result from the split. 
                        </p>
                        <p>The following statement splits the partition <code class="codeph">region_east</code> into two partitions:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region 
   SPLIT PARTITION region_east VALUES ('CT', 'MA', 'MD') 
   INTO 
    ( PARTITION region_east_1 
         TABLESPACE tbs2,
      PARTITION region_east_2
        STORAGE (INITIAL 8M)) 
   PARALLEL 5;
</pre><p>The literal value list for the original <code class="codeph">region_east</code> partition was specified as:
                        </p><pre class="oac_no_warn" dir="ltr">PARTITION region_east VALUES ('MA','NY','CT','NH','ME','MD','VA','PA','NJ')
</pre><p>The two new partitions are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">region_east_1</code> with a literal value list of <code class="codeph">('CT','MA','MD')</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">region_east_2</code> inheriting the remaining literal value list of <code class="codeph">('NY','NH','ME','VA','PA','NJ')</code></p>
                           </li>
                        </ul>
                        <p>The individual partitions have new physical attributes specified at the partition level. The operation is executed with parallelism of degree 5.</p>
                        <p>You can split a default list partition just like you split any other list partition. This is also the only means of adding a new partition to a list-partitioned table that contains a default partition. When you split the default partition, you create a new partition defined by the values that you specify, and a second partition that remains the default partition.</p>
                        <div class="infoboxnote" id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA__GUID-334B2EDE-84D0-4413-A121-C717D022E07E">
                           <p class="notep1">Live SQL:</p>
                           <p>View and run a related example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/split-list-partition.html" target="_blank"><span class="italic">Oracle Live SQL: Splitting the DEFAULT Partition of a List-Partitioned Table</span></a>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA__GUID-1410DBBB-613F-4204-A60B-DC90BED80D61">
                        <p class="titleinexample">Example 4-37 Splitting the default partition of a list-partitioned table</p>
                        <p>This example splits the default partition of <code class="codeph">sales_by_region</code>, creating new partitions.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_region
     (dept_number         NUMBER NOT NULL,
      dept_name           VARCHAR2(20),
      quarterly_sales     NUMBER(10,2),
      state               VARCHAR2(2)
 )
 PARTITION BY LIST (state)
 (
  PARTITION yearly_north VALUES ('MN','WI','MI'),
  PARTITION yearly_south VALUES ('NM','TX','GA'),
  PARTITION yearly_east VALUES  ('MA','NY','NC'),
  PARTITION yearly_west VALUES  ('CA','OR','WA'),
  PARTITION unknown VALUES (DEFAULT)
 );

SELECT PARTITION_NAME, HIGH_VALUE FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='SALES_BY_REGION';
PARTITION_NAME       HIGH_VALUE
--------------       ---------------
UNKNOWN              DEFAULT
YEARLY_EAST          'MA', 'NY', 'NC'
YEARLY_NORTH         'MN', 'WI', 'MI'
YEARLY_SOUTH         'NM', 'TX', 'GA'
YEARLY_WEST          'CA', 'OR', 'WA
5 rows selected.

INSERT INTO SALES_BY_REGION VALUES (002, 'AUTO NORTH', 450000, 'MN');
INSERT INTO SALES_BY_REGION VALUES (002, 'AUTO NORTH', 495000, 'WI');
INSERT INTO SALES_BY_REGION VALUES (002, 'AUTO NORTH', 850000, 'MI');

INSERT INTO SALES_BY_REGION VALUES (004, 'AUTO SOUTH',  595000, 'NM');
INSERT INTO SALES_BY_REGION VALUES (004, 'AUTO SOUTH', 4825000, 'TX');
INSERT INTO SALES_BY_REGION VALUES (004, 'AUTO SOUTH',  945000, 'GA');

INSERT INTO SALES_BY_REGION VALUES (006, 'AUTO EAST', 2125000, 'MA');
INSERT INTO SALES_BY_REGION VALUES (006, 'AUTO EAST', 6101000, 'NY');
INSERT INTO SALES_BY_REGION VALUES (006, 'AUTO EAST',  741000, 'NC');

INSERT INTO SALES_BY_REGION VALUES (008, 'AUTO WEST', 7201000, 'CA');
INSERT INTO SALES_BY_REGION VALUES (008, 'AUTO WEST',  901000, 'OR');
INSERT INTO SALES_BY_REGION VALUES (008, 'AUTO WEST', 1125000, 'WA');

INSERT INTO SALES_BY_REGION VALUES (009, 'AUTO MIDWEST', 1950000, 'AZ');
INSERT INTO SALES_BY_REGION VALUES (009, 'AUTO MIDWEST', 5725000, 'UT');

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(yearly_north);
DEPT_NUMBER DEPT_NAME            QUARTERLY_SALES ST
----------- -------------------- --------------- --
2           AUTO NORTH                    450000 MN
2           AUTO NORTH                    495000 WI
2           AUTO NORTH                    850000 MI

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(yearly_south);
DEPT_NUMBER DEPT_NAME            QUARTERLY_SALES ST
----------- -------------------- --------------- --
4           AUTO SOUTH                    595000 NM
4           AUTO SOUTH                   4825000 TX
4           AUTO SOUTH                    945000 GA

…

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(unknown);
DEPT_NUMBER DEPT_NAME            QUARTERLY_SALES ST
----------- -------------------- --------------- --
9           AUTO MIDWEST                 1950000 AZ
9           AUTO MIDWEST                 5725000 UT
<span class="bold">
REM Note that the following ADD PARTITION statement fails. This action fails because 
REM all undefined values are automatically included in the DEFAULT partition.</span>
ALTER TABLE sales_by_region ADD PARTITION yearly_midwest VALUES ('AZ', 'UT');
<span class="bold">ORA-14323: cannot add partition when DEFAULT partition exists</span> 

<span class="bold">REM You must SPLIT the DEFAULT partition to add a new partition.</span>
ALTER TABLE sales_by_region
   SPLIT PARTITION unknown VALUES ('AZ', 'UT')
   INTO
    ( PARTITION yearly_midwest,
      PARTITION unknown);

SELECT PARTITION_NAME, HIGH_VALUE FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='SALES_BY_REGION';
PARTITION_NAME       HIGH_VALUE
--------------       ---------------
UNKNOWN              DEFAULT
YEARLY_EAST          'MA', 'NY', 'NC'
YEARLY_MIDWEST       'AZ', 'UT'
YEARLY_NORTH         'MN', 'WI', 'MI'
YEARLY_SOUTH         'NM', 'TX', 'GA'
YEARLY_WEST          'CA', 'OR', 'WA'
6 Rows selected.

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(yearly_midwest);
DEPT_NUMBER DEPT_NAME            QUARTERLY_SALES ST
----------- -------------------- --------------- --
          9 AUTO MIDWEST                 1950000 AZ
          9 AUTO MIDWEST                 5725000 UT

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(unknown);
no rows selected

<span class="bold">REM Split the DEFAULT partition again to add a new 'yearly_mideast' partition.</span>
ALTER TABLE sales_by_region
   SPLIT PARTITION unknown VALUES ('OH', 'IL')
   INTO
    ( PARTITION yearly_mideast,
      PARTITION unknown);
Table altered.

SELECT PARTITION_NAME, HIGH_VALUE FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='SALES_BY_REGION';
PARTITION_NAME      HIGH_VALUE
------------------  ------------------
UNKNOWN             DEFAULT
YEARLY_EAST         'MA', 'NY', 'NC'
YEARLY_MIDEAST      'OH', 'IL'
YEARLY_MIDWEST      'AZ', 'UT'
YEARLY_NORTH        'MN', 'WI', 'MI'
YEARLY_SOUTH        'NM', 'TX', 'GA'
YEARLY_WEST         'CA', 'OR', 'WA'
7 rows selected.

INSERT INTO SALES_BY_REGION VALUES (007, 'AUTO MIDEAST',  925000, 'OH');
INSERT INTO SALES_BY_REGION VALUES (007, 'AUTO MIDEAST', 1325000, 'IL');

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(yearly_mideast);
DEPT_NUMBER DEPT_NAME            QUARTERLY_SALES ST
----------- -------------------- --------------- --
          7 AUTO MIDEAST                  925000 OH
          7 AUTO MIDEAST                 1325000 IL

SELECT DEPT_NUMBER, DEPT_NAME, QUARTERLY_SALES, STATE FROM SALES_BY_REGION PARTITION(unknown);
no rows selected
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1211"></a><div class="props_rev_3"><a id="GUID-D329CC2A-57CB-470D-8990-89C5240F029C" name="GUID-D329CC2A-57CB-470D-8990-89C5240F029C"></a><h4 id="VLDBG-GUID-D329CC2A-57CB-470D-8990-89C5240F029C" class="sect4">Splitting a Partition of an Interval-Partitioned Table</h4>
                  <div>
                     <p>You can split a range or a materialized interval partition with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement in an interval-partitioned table.
                     </p>
                     <div class="section">
                        <p> Splitting a range partition in the interval-partitioned table is described in <a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="You can split a range partition using the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a Range-Partitioned Table</a>.
                        </p>
                        <p>To split a materialized interval partition, you specify a value of the partitioning key column within the interval partition at which to split the partition. The first of the resulting two new partitions includes all rows in the original partition whose partitioning key column values map lower than the specified value. The second partition contains all rows whose partitioning key column values map greater than or equal to the specified value. The split partition operation moves the transition point up to the higher boundary of the partition you just split, and all materialized interval partitions lower than the newly split partitions are implicitly converted into range partitions, with their upper boundaries defined by the upper boundaries of the intervals.</p>
                        <p>You can optionally specify new attributes for the two range partitions resulting from the split. If there are local indexes defined on the table, then this statement also splits the matching partition in each local index. You cannot split interval partitions that have not yet been created.</p>
                        <p>The following example shows splitting the May 2007 partition in the monthly interval partitioned table <code class="codeph">transactions</code>.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE transactions
    SPLIT PARTITION FOR(TO_DATE('01-MAY-2007','dd-MON-yyyy'))
    AT (TO_DATE('15-MAY-2007','dd-MON-yyyy'));</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1212"></a><div class="props_rev_3"><a id="GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" name="GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574"></a><h4 id="VLDBG-GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" class="sect4">Splitting a *-Hash Partition</h4>
                  <div>
                     <p>You can split a hash partition with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p>This is the opposite of merging *-hash partitions. When you split *-hash partitions, the new subpartitions are rehashed into either the number of subpartitions specified in a <code class="codeph">SUBPARTITIONS</code> or <code class="codeph">SUBPARTITION</code> clause. Or, if no such clause is included, the new partitions inherit the number of subpartitions (and tablespaces) from the partition being split.
                        </p>
                        <p>The inheritance of properties is different when a *-hash partition is split, versus when two *-hash partitions are merged. When a partition is split, the new partitions can inherit properties from the original partition because there is only one parent. However, when partitions are merged, properties must be inherited from <span class="italic">table level </span>defaults because there are two parents and the new partition cannot inherit from either at the expense of the other.
                        </p>
                        <p>The following example splits a range-hash partition:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE all_seasons SPLIT PARTITION quarter_1 
     AT (TO_DATE('16-dec-1997','dd-mon-yyyy'))
     INTO (PARTITION q1_1997_1 SUBPARTITIONS 4 STORE IN (ts1,ts3),
           PARTITION q1_1997­_2);
</pre><p>The rules for splitting an interval-hash partitioned table follow the rules for splitting an interval-partitioned table. As described in <a href="maintenance-partition-tables-indexes.html#GUID-D329CC2A-57CB-470D-8990-89C5240F029C" title="You can split a range or a materialized interval partition with the ALTER TABLE SPLIT PARTITION statement in an interval-partitioned table.">Splitting a Partition of an Interval-Partitioned Table</a>, the transition point is changed to the higher boundary of the split partition.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1213"></a><div class="props_rev_3"><a id="GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" name="GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2"></a><h4 id="VLDBG-GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" class="sect4">Splitting Partitions in a *-List Partitioned Table</h4>
                  <div>
                     <p>Partitions can be split at both the partition level and at the subpartition level in a list partitioned table..</p>
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" title="You can split a list partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a *-List Partition</a></p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" title="You can split a list subpartition with the ALTER TABLE SPLIT SUBPARTITION statement.">Splitting a *-List Subpartition</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="VLDBG1214"></a><div class="props_rev_3"><a id="GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" name="GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E"></a><h5 id="VLDBG-GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" class="sect5">Splitting a *-List Partition</h5>
                     <div>
                        <p>You can split a list partition with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                        </p>
                        <div class="section">
                           <p>Splitting a partition of a *-list partitioned table is similar to the description in <a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="You can split a list partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a List-Partitioned Table</a>. No subpartition literal value list can be specified for either of the new partitions. The new partitions inherit the subpartition descriptions from the original partition being split.
                           </p>
                           <p>The following example splits the <code class="codeph">q1_1999</code> partition of the <code class="codeph">quarterly_regional_sales</code> table:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales SPLIT PARTITION q1_1999
   AT (TO_DATE('15-Feb-1999','dd-mon-yyyy'))
   INTO ( PARTITION q1_1999_jan_feb
             TABLESPACE ts1,
          PARTITION q1_1999_feb_mar
             STORAGE (INITIAL 8M) TABLESPACE ts2) 
   PARALLEL 5;
</pre><p>This operation splits the partition <code class="codeph">q1_1999</code> into two resulting partitions: <code class="codeph">q1_1999_jan_feb</code> and <code class="codeph">q1_1999_feb_mar</code>. Both partitions inherit their subpartition descriptions from the original partition. The individual partitions have new physical attributes, including tablespaces, specified at the partition level. These new attributes become the default attributes of the new partitions. This operation is run with parallelism of degree 5.
                           </p>
                           <p>The <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement provides no means of specifically naming subpartitions resulting from the split of a partition in a composite partitioned table. However, for those subpartitions in the parent partition with names of the form <span class="italic"><code class="codeph">partition name_subpartition name</code></span>, the database generates corresponding names in the newly created subpartitions using the new partition names. All other subpartitions are assigned system generated names of the form <code class="codeph">SYS_SUBP</code><span class="italic"><code class="codeph">n</code></span>. System generated names are also assigned for the subpartitions of any partition resulting from the split for which a name is not specified. Unnamed partitions are assigned a system generated partition name of the form <code class="codeph">SYS_P</code><span class="italic"><code class="codeph">n</code></span>.
                           </p>
                           <p>The following query displays the subpartition names resulting from the previous split partition operation on table <code class="codeph">quarterly_regional_sales</code>. It also reflects the results of other operations performed on this table in preceding sections of this chapter since its creation in <a href="create-composite-partition-table.html#GUID-BE937517-A04E-45B9-A5C9-D7957B8D65F3" title="The range partitions of a range-list composite partitioned table are described as the same for non-composite range partitioned tables.">About Creating Composite Range-List Partitioned Tables</a>.
                           </p><pre class="oac_no_warn" dir="ltr">SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLESPACE_NAME
  FROM DBA_TAB_SUBPARTITIONS
  WHERE TABLE_NAME='QUARTERLY_REGIONAL_SALES'
  ORDER BY PARTITION_NAME;

PARTITION_NAME       SUBPARTITION_NAME              TABLESPACE_NAME
-------------------- ------------------------------ ---------------
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_WEST           TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_NORTHEAST      TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTHEAST      TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_NORTHCENTRAL   TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTHCENTRAL   TS2
Q1_1999_FEB_MAR      Q1_1999_FEB_MAR_SOUTH          TS2
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_WEST           TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_NORTHEAST      TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTHEAST      TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_NORTHCENTRAL   TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTHCENTRAL   TS1
Q1_1999_JAN_FEB      Q1_1999_JAN_FEB_SOUTH          TS1
Q1_2000              Q1_2000_NORTHWEST              TS3
Q1_2000              Q1_2000_SOUTHWEST              TS3
Q1_2000              Q1_2000_NORTHEAST              TS3
Q1_2000              Q1_2000_SOUTHEAST              TS3
Q1_2000              Q1_2000_NORTHCENTRAL           TS3
Q1_2000              Q1_2000_SOUTHCENTRAL           TS3
Q2_1999              Q2_1999_NORTHWEST              TS4
Q2_1999              Q2_1999_SOUTHWEST              TS4
Q2_1999              Q2_1999_NORTHEAST              TS4
Q2_1999              Q2_1999_SOUTHEAST              TS4
Q2_1999              Q2_1999_NORTHCENTRAL           TS4
Q2_1999              Q2_1999_SOUTHCENTRAL           TS4
Q3_1999              Q3_1999_NORTHWEST              TS4
Q3_1999              Q3_1999_SOUTHWEST              TS4
Q3_1999              Q3_1999_NORTHEAST              TS4
Q3_1999              Q3_1999_SOUTHEAST              TS4
Q3_1999              Q3_1999_NORTHCENTRAL           TS4
Q3_1999              Q3_1999_SOUTHCENTRAL           TS4
Q4_1999              Q4_1999_NORTHWEST              TS4
Q4_1999              Q4_1999_SOUTHWEST              TS4
Q4_1999              Q4_1999_NORTHEAST              TS4
Q4_1999              Q4_1999_SOUTHEAST              TS4
Q4_1999              Q4_1999_NORTHCENTRAL           TS4
Q4_1999              Q4_1999_SOUTHCENTRAL           TS4

36 rows selected.</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1215"></a><div class="props_rev_3"><a id="GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" name="GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746"></a><h5 id="VLDBG-GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" class="sect5">Splitting a *-List Subpartition</h5>
                     <div>
                        <p>You can split a list subpartition with the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code> statement.
                        </p>
                        <div class="section">
                           <p>Splitting a list subpartition of a *-list partitioned table is similar to the description in <a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="You can split a list partition with the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a List-Partitioned Table</a>, but the syntax is that of <code class="codeph">SUBPARTITION</code> rather than <code class="codeph">PARTITION</code>. For example, the following statement splits a subpartition of the <code class="codeph">quarterly_regional_sales</code> table:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales SPLIT SUBPARTITION q2_1999_southwest
   VALUES ('UT') INTO
      ( SUBPARTITION q2_1999_utah
           TABLESPACE ts2,
        SUBPARTITION q2_1999_southwest
           TABLESPACE ts3
      ) 
   PARALLEL;
</pre><p>This operation splits the subpartition <code class="codeph">q2_1999_southwest</code> into two subpartitions: 
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">q2_1999_utah</code> with literal value list of <code class="codeph">('UT')</code> 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">q2_1999_southwest</code> which inherits the remaining literal value list of <code class="codeph">('AZ','NM')</code></p>
                              </li>
                           </ul>
                           <p>The individual subpartitions have new physical attributes that are inherited from the subpartition being split.</p>
                           <p>You can only split subpartitions in an interval-list partitioned table for range partitions or materialized interval partitions. To change subpartition values for future interval partitions, you must modify the subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1216"></a><div class="props_rev_3"><a id="GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" name="GUID-FE363371-932E-4D94-AC73-1F6690B1A52A"></a><h4 id="VLDBG-GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" class="sect4">Splitting a *-Range Partition</h4>
                  <div>
                     <p>You can split a range partition using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> statement.
                     </p>
                     <div class="section">
                        <p>Splitting a partition of a *-range partitioned table is similar to the description in <a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="You can split a range partition using the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a Range-Partitioned Table</a>. No subpartition range values can be specified for either of the new partitions. The new partitions inherit the subpartition descriptions from the original partition being split.
                        </p>
                        <p>The following example splits the May 2007 interval partition of the interval-range partitioned <code class="codeph">orders</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders
    SPLIT PARTITION FOR(TO_DATE('01-MAY-2007','dd-MON-yyyy'))
    AT (TO_DATE('15-MAY-2007','dd-MON-yyyy'))
    INTO (PARTITION p_fh_may07,PARTITION p_sh_may2007);
</pre><p>This operation splits the interval partition <code class="codeph">FOR('01-MAY-2007')</code> into two resulting partitions: <code class="codeph">p_fh_may07</code> and <code class="codeph">p_sh_may_2007</code>. Both partitions inherit their subpartition descriptions from the original partition. Any interval partitions before the June 2007 partition have been converted into range partitions, as described in <a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="The contents of two adjacent interval partitions can be merged into one partition.">Merging Interval Partitions</a>.
                        </p>
                        <p>The <code class="codeph">ALTER TABLE SPLIT PARTITION</code> statement provides no means of specifically naming subpartitions resulting from the split of a partition in a composite partitioned table. However, for those subpartitions in the parent partition with names of the form <span class="italic"><code class="codeph">partition name</code></span><code class="codeph">_</code><span class="italic"><code class="codeph">subpartition name</code></span>, the database generates corresponding names in the newly created subpartitions using the new partition names. All other subpartitions are assigned system generated names of the form <code class="codeph">SYS_SUBP</code><span class="italic"><code class="codeph">n</code></span>. System generated names are also assigned for the subpartitions of any partition resulting from the split for which a name is not specified. Unnamed partitions are assigned a system generated partition name of the form <code class="codeph">SYS_P</code><span class="italic"><code class="codeph">n</code></span>.
                        </p>
                        <p>The following query displays the subpartition names and high values resulting from the previous split partition operation on table <code class="codeph">orders</code>. It also reflects the results of other operations performed on this table in preceding sections of this chapter since its creation.
                        </p><pre class="oac_no_warn" dir="ltr">BREAK ON partition_name

SELECT partition_name, subpartition_name, high_value
FROM user_tab_subpartitions
WHERE table_name = 'ORCERS'
ORDER BY partition_name, subpartition_position;

PARTITION_NAME            SUBPARTITION_NAME              HIGH_VALUE
------------------------- ------------------------------ ---------------
P_BEFORE_2007             P_BEFORE_2007_P_SMALL          1000
                          P_BEFORE_2007_P_MEDIUM         10000
                          P_BEFORE_2007_P_LARGE          100000
                          P_BEFORE_2007_P_EXTRAORDINARY  MAXVALUE
P_FH_MAY07                SYS_SUBP2985                   1000
                          SYS_SUBP2986                   10000
                          SYS_SUBP2987                   100000
                          SYS_SUBP2988                   MAXVALUE
P_PRE_MAY_2007            P_PRE_MAY_2007_P_SMALL         1000
                          P_PRE_MAY_2007_P_MEDIUM        10000
                          P_PRE_MAY_2007_P_LARGE         100000
                          P_PRE_MAY_2007_P_EXTRAORDINARY MAXVALUE
P_SH_MAY2007              SYS_SUBP2989                   1000
                          SYS_SUBP2990                   10000
                          SYS_SUBP2991                   100000
                          SYS_SUBP2992                   MAXVALUE</pre></div>
                     <!-- class="section" -->
                  </div><a id="VLDBG1217"></a><div class="props_rev_3"><a id="GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0" name="GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0"></a><h5 id="VLDBG-GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0" class="sect5">Splitting a *-Range Subpartition</h5>
                     <div>
                        <p>You can split a range subpartition using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code> statement.
                        </p>
                        <div class="section">
                           <p>Splitting a range subpartition of a *-range partitioned table is similar to the description in <a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="You can split a range partition using the ALTER TABLE SPLIT PARTITION statement.">Splitting a Partition of a Range-Partitioned Table</a>, but the syntax is that of <code class="codeph">SUBPARTITION</code> rather than <code class="codeph">PARTITION</code>. For example, the following statement splits a subpartition of the <code class="codeph">orders</code> table:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders
SPLIT SUBPARTITION p_pre_may_2007_p_large AT (50000)
INTO (SUBPARTITION p_pre_may_2007_med_large TABLESPACE TS4
     , SUBPARTITION p_pre_may_2007_large_large TABLESPACE TS5
     );
</pre><p>This operation splits the subpartition <code class="codeph">p_pre_may_2007_p_large</code> into two subpartitions:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">p_pre_may_2007_med_large</code> with values between 10000 and 50000
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">p_pre_may_2007_large_large</code> with values between 50000 and 100000
                                 </p>
                              </li>
                           </ul>
                           <p>The individual subpartitions have new physical attributes that are inherited from the subpartition being split.</p>
                           <p>You can only split subpartitions in an interval-range partitioned table for range partitions or materialized interval partitions. To change subpartition boundaries for future interval partitions, you must modify the subpartition template.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1218"></a><div class="props_rev_3"><a id="GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" name="GUID-B28D3E86-190D-44CC-A279-00D867A5B80B"></a><h4 id="VLDBG-GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" class="sect4">Splitting Index Partitions</h4>
                  <div>
                     <p>You cannot explicitly split a partition in a local index. A local index partition is split only when you split a partition in the underlying table.</p>
                     <div class="section">
                        <p>However, you can split a global index partition as is done in the following example:</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX quon1 SPLIT 
    PARTITION canada AT ( 100 ) INTO 
    PARTITION canada1 ..., PARTITION canada2 ...);
ALTER INDEX quon1 REBUILD PARTITION canada1;
ALTER INDEX quon1 REBUILD PARTITION canada2;
</pre><p>The index being split can contain index data, and the resulting partitions do not require rebuilding, unless the original partition was previously marked <code class="codeph">UNUSABLE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14114"></a><div class="props_rev_3"><a id="GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" name="GUID-01C14320-0D7B-48BE-A5AD-003DDA761277"></a><h4 id="VLDBG-GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" class="sect4">Splitting into Multiple Partitions</h4>
                  <div>
                     <p>You can redistribute the contents of one partition or subpartition into multiple partitions or subpartitions with the <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> and <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code> clauses of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement. 
                     </p>
                     <div class="section">
                        <p>When splitting multiple partitions, the segment associated with the current partition is discarded. Each new partitions obtains a new segment and inherits all unspecified physical attributes from the current source partition.You can also use fast split when splitting into multiple partitions.</p>
                        <p>You can use the extended split syntax to specify a list of new partition descriptions similar to the create partitioned table SQL statements, rather than specifying the <code class="codeph">AT</code> or <code class="codeph">VALUES</code> clause. Additionally, the range or list values clause for the last new partition description is derived based on the high bound of the source partition and the bound values specified for the first (N-1) new partitions resulting from the split. 
                        </p>
                        <p>The following SQL statements are examples of splitting a partition into multiple partitions. </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE SPLIT PARTITION p0 INTO 
  (PARTITION p01 VALUES LESS THAN (25),
   PARTITION p02 VALUES LESS THAN (50), 
   PARTITION p03 VALUES LESS THAN (75),
   PARTITION p04);

ALTER TABLE SPLIT PARTITION p0 INTO 
  (PARTITION p01 VALUES LESS THAN (25),
   PARTITION p02);
</pre><p>In the second SQL example, partition <code class="codeph">p02</code> has the high bound of the original partition <code class="codeph">p0</code>.
                        </p>
                        <p>To split a range partition into N partitions, (N-1) values of the partitioning key column must be specified within the range of the partition at which to split the partition. The new non-inclusive upper bound values specified must be in ascending order. The high bound of Nth new partition is assigned the value of the high bound of the partition being split. The names and physical attributes of the N new partitions resulting from the split can be optionally specified.</p>
                        <p>To split a list partition into N partitions, (N-1) lists of literal values must be specified, each of which defines the first (N-1) partitions into which rows with corresponding partitioning key values are inserted. The remaining rows of the original partition are inserted into the Nth new partition whose value list contains the remaining literal values from the original partition. No two value lists can contain the same partition value. The (N-1) value lists that are specified cannot contain all of the partition values of the current partition because the Nth new partition would be empty. Also, the (N-1) value lists cannot contain any partition values that do not exist for the current partition.</p>
                        <p>When splitting a <code class="codeph">DEFAULT</code> list partition or a <code class="codeph">MAXVALUE</code> range partition into multiple partitions, the first (N-1) new partitions are created using the literal value lists or high bound values specified, while the Nth new partition resulting from the split have the <code class="codeph">DEFAULT</code> value or <code class="codeph">MAXVALUE</code>. Splitting a partition of a composite partitioned table into multiple partitions assumes the existing behavior with respect to inheritance of the number, names, bounds and physical properties of the subpartitions of the new partitions resulting from the split. The <code class="codeph">SPLIT_TABLE_SUBPARTITION</code> clause is extended similarly to allow split of a range or list subpartition into N new subpartitions.
                        </p>
                        <p>The behavior of the SQL statement with respect to local and global indexes remains unchanged. Corresponding local index partition are split into multiple partitions. If the partitioned table contains LOB columns, then existing semantics for the <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> clause apply with the extended syntax; that is, LOB data and index segments is dropped for current partition and new segments are created for each LOB column for each new partition. Fast split optimization is applied to multipartition split operations when required conditions are met.
                        </p>
                        <p>For example, the following SQL statement splits the <code class="codeph">sales_Q4_2007</code> partition of the partitioned by range table <code class="codeph">sales</code> splits into five partitions corresponding to the quarters of the next year. In this example, the partition <code class="codeph">sales_Q4_2008</code> implicitly becomes the high bound of the split partition.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales SPLIT PARTITION sales_Q4_2007 INTO
( PARTITION sales_Q4_2007 VALUES LESS THAN (TO_DATE('01-JAN-2008','dd-MON-yyyy')),
  PARTITION sales_Q1_2008 VALUES LESS THAN (TO_DATE('01-APR-2008','dd-MON-yyyy')),
  PARTITION sales_Q2_2008 VALUES LESS THAN (TO_DATE('01-JUL-2008','dd-MON-yyyy')),
  PARTITION sales_Q3_2008 VALUES LESS THAN (TO_DATE('01-OCT-2008','dd-MON-yyyy')),
  PARTITION sales_Q4_2008);
</pre><p>For the sample table <code class="codeph">customers</code> partitioned by list, the following statement splits the partition <span class="bold">Europe</span> into three partitions.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE list_customers SPLIT PARTITION Europe INTO
  (PARTITION western-europe VALUES ('GERMANY', 'FRANCE'),
   PARTITION southern-europe VALUES ('ITALY'), 
   PARTITION rest-europe);
</pre><p></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG00304"></a><div class="props_rev_3"><a id="GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" name="GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7"></a><h4 id="VLDBG-GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" class="sect4">Fast SPLIT PARTITION and SPLIT SUBPARTITION Operations</h4>
                  <div>
                     <p>Oracle Database implements a <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> operation by creating two new partitions and redistributing the rows from the partition being split into the two new partitions.
                     </p>
                     <p> This is a time-consuming operation because it is necessary to scan all the rows of the partition being split and then insert them one-by-one into the new partitions. Further if you do not use the <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause, then both local and global indexes also require rebuilding.
                     </p>
                     <p>Sometimes after a split operation, one new partition contains all of the rows from the partition being split, while the other partition contains no rows. This is often the case when splitting the first partition of a table. The database can detect such situations and can optimize the split operation. This optimization results in a fast split operation that behaves like an add partition operation.</p>
                     <p>Specifically, the database can optimize and speed up <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> operations if all of the following conditions are met:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>One of the two resulting partitions must be empty.</p>
                        </li>
                        <li>
                           <p>The non-empty resulting partition must have storage characteristics identical to those of the partition being split. Specifically:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If the partition being split is composite, then the storage characteristics of each subpartition in the new non-empty resulting partition must be identical to those of the subpartitions of the partition being split.</p>
                              </li>
                              <li>
                                 <p>If the partition being split contains a <code class="codeph">LOB</code> column, then the storage characteristics of each <code class="codeph">LOB</code> (sub)partition in the new non-empty resulting partition must be identical to those of the <code class="codeph">LOB</code> (sub)partitions of the partition being split.
                                 </p>
                              </li>
                              <li>
                                 <p>If a partition of an index-organized table with overflow is being split, then the storage characteristics of each overflow (sub)partition in the new nonempty resulting partition must be identical to those of the overflow (sub)partitions of the partition being split.</p>
                              </li>
                              <li>
                                 <p>If a partition of an index-organized table with mapping table is being split, then the storage characteristics of each mapping table (sub)partition in the new nonempty resulting partition must be identical to those of the mapping table (sub)partitions of the partition being split.</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>If these conditions are met after the split, then all global indexes remain usable, even if you did not specify the <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> clause. Local index (sub)partitions associated with both resulting partitions remain usable if they were usable before the split. Local index (sub)partitions corresponding to the non-empty resulting partition are identical to the local index (sub)partitions of the partition that was split. The same optimization holds for <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code> operations.
                     </p>
                  </div>
               </div>
            </div><a id="VLDBG1219"></a><div class="props_rev_3"><a id="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" name="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B"></a><h3 id="VLDBG-GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" class="sect3">About Truncating Partitions and Subpartitions</h3>
               <div>
                  <p>Truncating a partition is similar to dropping a partition, except that the partition is emptied of its data, but not physically dropped.</p>
                  <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement to remove all rows from a table partition. You cannot truncate an index partition. However, if local indexes are defined for the table, the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement truncates the matching partition in each local index. Unless you specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>, any global indexes are marked <code class="codeph">UNUSABLE</code> and must be rebuilt. You cannot use <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> for index-organized tables. Use <code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> instead.
                  </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-603A7284-9B65-4A27-B192-9B7944851BF3" title="Use the ALTER TABLE TRUNCATE PARTITION statement to remove all rows from a table partition, with or without reclaiming space.">About Truncating a Table Partition</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" title="You can truncate multiple partitions from a range or list partitioned table with the TRUNCATE PARTITION clause of the ALTER TABLE statement.">Truncating Multiple Partitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" title="Use the ALTER TABLE TRUNCATE SUBPARTITION statement to remove all rows from a subpartition of a composite partitioned table.">Truncating Subpartitions</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" title="You can use cascade truncate operations to a reference partitioned child table with the CASCADE option of TRUNCATE TABLE, ALTER TABLE TRUNCATE PARTITION, and ALTER TABLE TRUNCATE SUBPARTITION SQL statements.">Truncating a Partition with the Cascade Option</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B__GUID-50894CF8-1291-4B3B-9E76-69F04F99B1E9">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="maintenance-partition-can-be-performed.html#GUID-087B87A6-959A-40C6-82AF-36E401FD089B" title="The partition maintenance operations DROP PARTITION and TRUNCATE PARTITION are optimized by making the index maintenance for metadata only.">Asynchronous Global Index Maintenance for Dropping and Truncating Partitions</a> for information about asynchronous index maintenance for truncating partitions
                              </p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" title="You can drop partitions from range, interval, list, or composite *-[range | list] partitioned tables.">About Dropping Partitions and Subpartitions</a> for information about dropping a partition
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="VLDBG1220"></a><div class="props_rev_3"><a id="GUID-603A7284-9B65-4A27-B192-9B7944851BF3" name="GUID-603A7284-9B65-4A27-B192-9B7944851BF3"></a><h4 id="VLDBG-GUID-603A7284-9B65-4A27-B192-9B7944851BF3" class="sect4">About Truncating a Table Partition</h4>
                  <div>
                     <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement to remove all rows from a table partition, with or without reclaiming space.
                     </p>
                     <p> Truncating a partition in an interval-partitioned table does not move the transition point. You can truncate partitions and subpartitions in a reference-partitioned table.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" title="When truncating a table partition that contains data and global indexes, you can use one of several methods.">Truncating Table Partitions Containing Data and Global Indexes</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-FEAAC43A-1066-4697-8474-863181FE4F38" title="If a partition contains data and has referential integrity constraints, then you cannot truncate the partition. However, if no other data is referencing any data in the partition to remove, then you can use one of several methods.">Truncating a Partition Containing Data and Referential Integrity Constraints</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1222"></a><a id="VLDBG1223"></a><a id="VLDBG1224"></a><a id="VLDBG1221"></a><div class="props_rev_3"><a id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" name="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26"></a><h5 id="VLDBG-GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" class="sect5">Truncating Table Partitions Containing Data and Global Indexes</h5>
                     <div>
                        <p>When truncating a table partition that contains data and global indexes, you can use one of several methods.</p>
                        <p>If the partition contains data and global indexes, use one of the following methods (method 1, 2, or 3) to truncate the table partition.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-A8B2637A-58EC-4610-8D6F-13F377F2046B">Method 1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Leave the global indexes in place during the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement. In this example, table <code class="codeph">sales</code> has a global index <code class="codeph">sales_area_ix</code>, which is rebuilt. 
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales TRUNCATE PARTITION dec98;
ALTER INDEX sales_area_ix REBUILD;
</pre><p>This method is most appropriate for large tables where the partition being truncated contains a significant percentage of the total data in the table.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-A1210B85-4D3E-4CDF-BB7F-8D63EB5B610E">Method 2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Run the <code class="codeph">DELETE</code> statement to delete all rows from the partition before you issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <a id="d29958e13977" class="indexterm-anchor"></a><code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement. The <code class="codeph">DELETE</code> statement updates the global indexes, and also fires triggers and generates redo and undo logs. 
                           </p>
                           <p>For example, to truncate the first partition, run the following statements:</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales PARTITION (dec98);
ALTER TABLE sales TRUNCATE PARTITION dec98;
</pre><p>This method is most appropriate for small tables, or for large tables when the partition being truncated contains a small percentage of the total data in the table.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-D06E8ED6-19E9-4739-A32E-B91232190EF9">Method 3</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Specify <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> in the <code class="codeph">ALTER TABLE</code> statement. This causes the global index to be truncated at the time the partition is truncated.
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales TRUNCATE PARTITION dec98
     UPDATE INDEXES;
</pre><p>With asynchronous global index maintenance, this operation is a metadata-only operation.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1226"></a><a id="VLDBG1227"></a><a id="VLDBG1225"></a><div class="props_rev_3"><a id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38" name="GUID-FEAAC43A-1066-4697-8474-863181FE4F38"></a><h5 id="VLDBG-GUID-FEAAC43A-1066-4697-8474-863181FE4F38" class="sect5">Truncating a Partition Containing Data and Referential Integrity Constraints</h5>
                     <div>
                        <p>If a partition contains data and has referential integrity constraints, then you cannot truncate the partition. However, if no other data is referencing any data in the partition to remove, then you can use one of several methods.</p>
                        <p>Choose either of the following methods (method 1 or 2) to truncate the table partition.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38__GUID-7376CAF8-6AEE-4AC5-90A5-2D30CE8883D4">Method 1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Disable the integrity constraints, run the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement, then re-enable the integrity constraints. This method is most appropriate for large tables where the partition being truncated contains a significant percentage of the total data in the table. If there is still referencing data in other tables, then you must remove that data to be able to re-enable the integrity constraints.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38__GUID-ADD6B570-A92F-426F-85E8-0A163F2B2527">Method 2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Issue the <code class="codeph">DELETE</code> statement to delete all rows from the partition before you issue the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> statement. The <code class="codeph">DELETE</code> statement enforces referential integrity constraints, and also fires triggers and generates redo and undo logs. Data in referencing tables is deleted if the foreign key constraints were created with the <code class="codeph">ON DELETE CASCADE</code> option.
                           </p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition (dec94);
ALTER TABLE sales TRUNCATE PARTITION dec94;
</pre><p>This method is most appropriate for small tables, or for large tables when the partition being truncated contains a small percentage of the total data in the table.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG14116"></a><div class="props_rev_3"><a id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" name="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB"></a><h4 id="VLDBG-GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" class="sect4">Truncating Multiple Partitions</h4>
                  <div>
                     <p>You can truncate multiple partitions from a range or list partitioned table with the <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement.
                     </p>
                     <div class="section">
                        <p>The corresponding partitions of local indexes are truncated in the operation. Global indexes must be rebuilt unless <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> is specified.
                        </p>
                        <p>In the following example, the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL statement truncates multiple partitions in a table. Note that the data is truncated, but the partitions are not dropped.
                        </p>
                        <div class="infoboxnote" id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB__GUID-31635179-EE91-4831-A4E8-5EB39B836A8B">
                           <p class="notep1">Live SQL:</p>
                           <p>View and run a related example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/truncate-partitions.html" target="_blank"><span class="italic">Oracle Live SQL: Truncating a Range-Partitioned Table</span></a>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB__GUID-461A8427-7529-4E61-A43F-527409033757">
                        <p class="titleinexample">Example 4-38 Truncating Multiple Partitions</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_partition_truncate
  ( product_id       NUMBER(6) NOT NULL,
    customer_id      NUMBER    NOT NULL,
    channel_id       CHAR(1),
    promo_id         NUMBER(6),
    sales_date       DATE,
    quantity_sold    INTEGER,
    amount_sold      NUMBER(10,2)
  )
 PARTITION BY RANGE (sales_date) 
 SUBPARTITION BY LIST (channel_id)
(  PARTITION q3_2018 VALUES LESS THAN (TO_DATE('1-OCT-2018','DD-MON-YYYY'))
   ( SUBPARTITION q3_2018_p_catalog VALUES ('C'),
     SUBPARTITION q3_2018_p_internet VALUES ('I'),
     SUBPARTITION q3_2018_p_partners VALUES ('P'),
     SUBPARTITION q3_2018_p_direct_sales VALUES ('S'),
     SUBPARTITION q3_2018_p_tele_sales VALUES ('T')
   ),
  PARTITION q4_2018 VALUES LESS THAN (TO_DATE('1-JAN-2019','DD-MON-YYYY'))
   ( SUBPARTITION q4_2018_p_catalog VALUES ('C'),
     SUBPARTITION q4_2018_p_internet VALUES ('I'),
     SUBPARTITION q4_2018_p_partners VALUES ('P'),
     SUBPARTITION q4_2018_p_direct_sales VALUES ('S'),
     SUBPARTITION q4_2018_p_tele_sales VALUES ('T')
   ),
  PARTITION q1_2019 VALUES LESS THAN (TO_DATE('1-APR-2019','DD-MON-YYYY'))
   ( SUBPARTITION q1_2019_p_catalog VALUES ('C')
   , SUBPARTITION q1_2019_p_internet VALUES ('I')
   , SUBPARTITION q1_2019_p_partners VALUES ('P')
   , SUBPARTITION q1_2019_p_direct_sales VALUES ('S')
   , SUBPARTITION q1_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q2_2019 VALUES LESS THAN (TO_DATE('1-JUL-2019','DD-MON-YYYY'))
   ( SUBPARTITION q2_2019_p_catalog VALUES ('C'),
     SUBPARTITION q2_2019_p_internet VALUES ('I'),
     SUBPARTITION q2_2019_p_partners VALUES ('P'),
     SUBPARTITION q2_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q2_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q3_2019 VALUES LESS THAN (TO_DATE('1-OCT-2019','DD-MON-YYYY'))
   ( SUBPARTITION q3_2019_p_catalog VALUES ('C'),
     SUBPARTITION q3_2019_p_internet VALUES ('I'),
     SUBPARTITION q3_2019_p_partners VALUES ('P'),
     SUBPARTITION q3_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q3_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q4_2019 VALUES LESS THAN (TO_DATE('1-JAN-2020','DD-MON-YYYY'))
   ( SUBPARTITION q4_2019_p_catalog VALUES ('C'),
     SUBPARTITION q4_2019_p_internet VALUES ('I'),
     SUBPARTITION q4_2019_p_partners VALUES ('P'),
     SUBPARTITION q4_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q4_2019_p_tele_sales VALUES ('T')
   )
  );

SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS 
       WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE';
TABLE_NAME                  PARTITION_NAME    SUBPARTITION_NAME
&#x2013;------------------------   &#x2013;--------------   &#x2013;------------------
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_CATALOG
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_DIRECT_SALES
...
30 rows selected.

INSERT INTO sales_partition_truncate VALUES (1001,100,'C',150,'10-SEP-2018',500,2000);
INSERT INTO sales_partition_truncate VALUES (1021,200,'C',160,'16-NOV-2018',100,1500);
INSERT INTO sales_partition_truncate VALUES (1001,100,'C',150,'10-FEB-2019',500,2000);
INSERT INTO sales_partition_truncate VALUES (1021,200,'S',160,'16-FEB-2019',100,1500);
INSERT INTO sales_partition_truncate VALUES (1002,110,'I',180,'15-JUN-2019',100,1000);
INSERT INTO sales_partition_truncate VALUES (5010,150,'P',200,'20-AUG-2019',1000,10000);
INSERT INTO sales_partition_truncate VALUES (1001,100,'T',150,'12-OCT-2019',500,2000);

SELECT * FROM sales_partition_truncate;
PRODUCT_ID CUSTOMER_ID C   PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD
---------- ----------- - ---------- --------- ------------- -----------
      1001         100 C        150 10-SEP-18           500        2000
      1021         200 C        160 16-NOV-18           100        1500
      1001         100 C        150 10-FEB-19           500        2000
      1021         200 S        160 16-FEB-19           100        1500
      1002         110 I        180 15-JUN-19           100        1000
      5010         150 P        200 20-AUG-19          1000       10000
      1001         100 T        150 12-OCT-19           500        2000
7 rows selected.

ALTER TABLE sales_partition_truncate
   TRUNCATE PARTITIONS q3_2018, q4_2018;

SELECT * FROM sales_partition_truncate;
PRODUCT_ID CUSTOMER_ID C   PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD
---------- ----------- - ---------- --------- ------------- -----------
      1001         100 C        150 10-FEB-19           500        2000
      1021         200 S        160 16-FEB-19           100        1500
      1002         110 I        180 15-JUN-19           100        1000
      5010         150 P        200 20-AUG-19          1000       10000
      1001         100 T        150 12-OCT-19           500        2000
5 rows selected.

SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS 
       WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE';
TABLE_NAME                  PARTITION_NAME    SUBPARTITION_NAME
&#x2013;------------------------   &#x2013;--------------   &#x2013;------------------
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_CATALOG
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_DIRECT_SALES
...
SALES_PARTITION_TRUNCATE    Q3_2018           Q3_2018_P_CATALOG
SALES_PARTITION_TRUNCATE    Q3_2018           Q3_2018_P_DIRECT_SALES
SALES_PARTITION_TRUNCATE    Q3_2018           Q3_2018_P_INTERNET
SALES_PARTITION_TRUNCATE    Q3_2018           Q3_2018_P_PARTNERS
SALES_PARTITION_TRUNCATE    Q3_2018           Q3_2018_P_TELE_SALES
...
SALES_PARTITION_TRUNCATE    Q4_2018           Q4_2018_P_CATALOG
SALES_PARTITION_TRUNCATE    Q4_2018           Q4_2018_P_DIRECT_SALES
SALES_PARTITION_TRUNCATE    Q4_2018           Q4_2018_P_INTERNET
SALES_PARTITION_TRUNCATE    Q4_2018           Q4_2018_P_PARTNERS
SALES_PARTITION_TRUNCATE    Q4_2018           Q4_2018_P_TELE_SALES
...
30 rows selected.
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1228"></a><div class="props_rev_3"><a id="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" name="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D"></a><h4 id="VLDBG-GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" class="sect4">Truncating Subpartitions</h4>
                  <div>
                     <p>Use the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code> statement to remove all rows from a subpartition of a composite partitioned table. 
                     </p>
                     <div class="section">
                        <p>When truncating a subpartition, corresponding local index subpartitions are also truncated. </p>
                        <p>In the following example, the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement truncates data in subpartitions of a table. In this example, the space occupied by the deleted rows is made available for use by other schema objects in the tablespace with the <code class="codeph">DROP</code> <code class="codeph">STORAGE</code> clause. Note that the data is truncated, but the subpartitions are not dropped.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D__GUID-B273F97F-4084-4441-BC8C-459C6D11432C">
                        <p class="titleinexample">Example 4-39 Truncating Multiple Subpartitions</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_partition_truncate
  ( product_id       NUMBER(6) NOT NULL,
    customer_id      NUMBER    NOT NULL,
    channel_id       CHAR(1),
    promo_id         NUMBER(6),
    sales_date       DATE,
    quantity_sold    INTEGER,
    amount_sold      NUMBER(10,2)
  )
 PARTITION BY RANGE (sales_date) 
 SUBPARTITION BY LIST (channel_id)
(  PARTITION q3_2018 VALUES LESS THAN (TO_DATE('1-OCT-2018','DD-MON-YYYY'))
   ( SUBPARTITION q3_2018_p_catalog VALUES ('C'),
     SUBPARTITION q3_2018_p_internet VALUES ('I'),
     SUBPARTITION q3_2018_p_partners VALUES ('P'),
     SUBPARTITION q3_2018_p_direct_sales VALUES ('S'),
     SUBPARTITION q3_2018_p_tele_sales VALUES ('T')
   ),
  PARTITION q4_2018 VALUES LESS THAN (TO_DATE('1-JAN-2019','DD-MON-YYYY'))
   ( SUBPARTITION q4_2018_p_catalog VALUES ('C'),
     SUBPARTITION q4_2018_p_internet VALUES ('I'),
     SUBPARTITION q4_2018_p_partners VALUES ('P'),
     SUBPARTITION q4_2018_p_direct_sales VALUES ('S'),
     SUBPARTITION q4_2018_p_tele_sales VALUES ('T')
   ),
  PARTITION q1_2019 VALUES LESS THAN (TO_DATE('1-APR-2019','DD-MON-YYYY'))
   ( SUBPARTITION q1_2019_p_catalog VALUES ('C')
   , SUBPARTITION q1_2019_p_internet VALUES ('I')
   , SUBPARTITION q1_2019_p_partners VALUES ('P')
   , SUBPARTITION q1_2019_p_direct_sales VALUES ('S')
   , SUBPARTITION q1_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q2_2019 VALUES LESS THAN (TO_DATE('1-JUL-2019','DD-MON-YYYY'))
   ( SUBPARTITION q2_2019_p_catalog VALUES ('C'),
     SUBPARTITION q2_2019_p_internet VALUES ('I'),
     SUBPARTITION q2_2019_p_partners VALUES ('P'),
     SUBPARTITION q2_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q2_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q3_2019 VALUES LESS THAN (TO_DATE('1-OCT-2019','DD-MON-YYYY'))
   ( SUBPARTITION q3_2019_p_catalog VALUES ('C'),
     SUBPARTITION q3_2019_p_internet VALUES ('I'),
     SUBPARTITION q3_2019_p_partners VALUES ('P'),
     SUBPARTITION q3_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q3_2019_p_tele_sales VALUES ('T')
   ),
  PARTITION q4_2019 VALUES LESS THAN (TO_DATE('1-JAN-2020','DD-MON-YYYY'))
   ( SUBPARTITION q4_2019_p_catalog VALUES ('C'),
     SUBPARTITION q4_2019_p_internet VALUES ('I'),
     SUBPARTITION q4_2019_p_partners VALUES ('P'),
     SUBPARTITION q4_2019_p_direct_sales VALUES ('S'),
     SUBPARTITION q4_2019_p_tele_sales VALUES ('T')
   )
  );

SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS 
       WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE';
TABLE_NAME                  PARTITION_NAME    SUBPARTITION_NAME
&#x2013;------------------------   &#x2013;--------------   &#x2013;------------------
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_CATALOG
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_DIRECT_SALES
...
30 rows selected.

INSERT INTO sales_partition_truncate VALUES (1001,100,'C',150,'10-SEP-2018',500,2000);
INSERT INTO sales_partition_truncate VALUES (1021,200,'C',160,'16-NOV-2018',100,1500);
INSERT INTO sales_partition_truncate VALUES (1001,100,'C',150,'10-FEB-2019',500,2000);
INSERT INTO sales_partition_truncate VALUES (1021,200,'S',160,'16-FEB-2019',100,1500);
INSERT INTO sales_partition_truncate VALUES (1002,110,'I',180,'15-JUN-2019',100,1000);
INSERT INTO sales_partition_truncate VALUES (5010,150,'P',200,'20-AUG-2019',1000,10000);
INSERT INTO sales_partition_truncate VALUES (1001,100,'T',150,'12-OCT-2019',500,2000);

SELECT * FROM sales_partition_truncate;
PRODUCT_ID CUSTOMER_ID C   PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD
---------- ----------- - ---------- --------- ------------- -----------
      1001         100 C        150 10-SEP-18           500        2000
      1021         200 C        160 16-NOV-18           100        1500
      1001         100 C        150 10-FEB-19           500        2000
      1021         200 S        160 16-FEB-19           100        1500
      1002         110 I        180 15-JUN-19           100        1000
      5010         150 P        200 20-AUG-19          1000       10000
      1001         100 T        150 12-OCT-19           500        2000
7 rows selected.

ALTER TABLE sales_subpartition_truncate
   TRUNCATE SUBPARTITIONS q3_2018_p_catalog, q4_2018_p_catalog, q1_2019_p_catalog, 
                          q2_2019_p_catalog, q3_2019_p_catalog, q4_2019_p_catalog
        DROP STORAGE;

SELECT * FROM sales_partition_truncate;
PRODUCT_ID CUSTOMER_ID C   PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD
---------- ----------- - ---------- --------- ------------- -----------
      1021         200 S        160 16-FEB-19           100        1500
      1002         110 I        180 15-JUN-19           100        1000
      5010         150 P        200 20-AUG-19          1000       10000
      1001         100 T        150 12-OCT-19           500        2000
4 rows selected.

SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS 
       WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE';
TABLE_NAME                  PARTITION_NAME    SUBPARTITION_NAME
&#x2013;------------------------   &#x2013;--------------   &#x2013;------------------
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_CATALOG
SALES_PARTITION_TRUNCATE    Q1_2019           Q1_2019_P_DIRECT_SALES
...
30 rows selected.
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14115"></a><div class="props_rev_3"><a id="GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" name="GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464"></a><h4 id="VLDBG-GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" class="sect4">Truncating a Partition with the Cascade Option</h4>
                  <div>
                     <p>You can use cascade truncate operations to a reference partitioned child table with the <code class="codeph">CASCADE</code> option of <code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code>, <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>, and <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code> SQL statements.
                     </p>
                     <div class="section">
                        <p>When the <code class="codeph">CASCADE</code> option is specified for <code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code>, the truncate table operation also truncates child tables that reference the targeted table through an enabled referential constraint that has <code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code> enabled. This cascading action applies recursively to grandchildren, great-grandchildren, and so on. After determining the set of tables to be truncated based on the enabled <code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code> referential constraints, an error is raised if any table in this set is referenced through an enabled constraint from a child outside of the set. If a parent and child are connected by multiple referential constraints, a <code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code> <code class="codeph">CASCADE</code> operation targeting the parent succeeds if at least one constraint has <code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code> enabled.
                        </p>
                        <p>Privileges are required on all tables affected by the operation. Any other options specified for the operation, such as <code class="codeph">DROP</code> <code class="codeph">STORAGE</code> or <code class="codeph">PURGE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code>, apply for all tables affected by the operation.
                        </p>
                        <p>When the <code class="codeph">CASCADE</code> option is specified, the <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> and <code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code> operations cascade to reference partitioned tables that are children of the targeted table. The <code class="codeph">TRUNCATE</code> can be targeted at any level in a reference partitioned hierarchy and cascades to child tables starting from the targeted table. Privileges are not required on the child tables, but the usual restrictions on the <code class="codeph">TRUNCATE</code> operation, such as the table cannot be referenced by an enabled referential constraint that is not a partitioning constraint, apply for all tables affected by the operation. 
                        </p>
                        <p>The <code class="codeph">CASCADE</code> option is ignored if it is specified for a table that does not have reference partitioned children. Any other options specified for the operation, such as <code class="codeph">DROP</code> <code class="codeph">STORAGE</code> or <code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>, apply to all tables affected by the operation.
                        </p>
                        <p>The cascade options are off by default so they do not affect Oracle Database compatibility.</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales 
     TRUNCATE PARTITION dec2016
     DROP STORAGE
     CASCADE
     UPDATE INDEXES;
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>