<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Programming with Unicode</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database Globalization Support Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database Globalization Support Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-globalization-support-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T02:55:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2007, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96349-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="supporting-multilingual-databases-with-unicode.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-globalization-development-kit.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Globalization Support Guide">
    <meta name="dcterms.isVersionOf" content="NLSPG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="supporting-multilingual-databases-with-unicode.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-globalization-development-kit.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database Globalization Support Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Programming with Unicode </li>
            </ol>
            <a id="GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095" name="GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095"></a><a id="NLSPG007"></a>
            
            <h2 id="NLSPG-GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095" class="sect2"><span class="enumeration_chapter">7 </span> Programming with Unicode 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes how to use programming and access products for Oracle Database with Unicode. This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8">Overview of Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE">SQL and PL/SQL Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">OCI Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-302CBDBC-3A81-415F-86B0-86BB56796B33">Pro*C/C++ Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-39A80CED-25E1-416B-8723-267A504599C0">JDBC Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE">ODBC and OLE DB Programming with Unicode</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA">XML Programming with Unicode</a></p>
                  </li>
               </ul>
            </div><a id="NLSPG0072"></a><div class="props_rev_3"><a id="GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8" name="GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8"></a><h3 id="NLSPG-GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8" class="sect3"><span class="enumeration_section">7.1 </span>Overview of Programming with Unicode
               </h3>
               <div>
                  <p><a id="d59478e181" class="indexterm-anchor"></a>Oracle offers several database access products for inserting and retrieving Unicode data. Oracle offers database access products for commonly used programming environments such as Java and C/C++. Data is transparently converted between the database and client programs, which ensures that client programs are independent of the database character set and national character set. In addition, client programs are sometimes even independent of the character data type, such as <code class="codeph">NCHAR</code> or <code class="codeph">CHAR</code>, used in the database. 
                  </p>
                  <p>To avoid overloading the database server with data conversion operations, Oracle always tries to move them to the client side database access products. In a few cases, data must be converted in the database, which affects performance. This chapter discusses details of the data conversion paths.</p>
               </div><a id="NLSPG800"></a><a id="NLSPG801"></a><a id="NLSPG334"></a><div class="props_rev_3"><a id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C" name="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C"></a><h4 id="NLSPG-GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C" class="sect4"><span class="enumeration_section">7.1.1 </span>Database Access Product Stack and Unicode
                  </h4>
                  <div>
                     <p>Oracle offers a comprehensive set of database access products that enable programs from different development environments to access Unicode data stored in the database. These products are listed in the following table.</p>
                     <div class="tblformal" id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C__CACBBCAG">
                        <p class="titleintable">Table 7-1 Oracle Database Access Products </p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle Database Access Products " summary="This table lists database access products for different programming environments. " width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e280">Programming Environment</th>
                                 <th align="left" valign="bottom" id="d59478e283">Oracle Database Access Products</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e288" headers="d59478e280 ">
                                    <p>C/C++</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e288 d59478e283 ">
                                    <p>Oracle Call Interface (OCI)</p>
                                    <p>Oracle Pro*C/C++ </p>
                                    <p>Oracle ODBC driver </p>
                                    <p>Oracle Provider for OLE DB</p>
                                    <p>Oracle Data Provider for .NET</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e303" headers="d59478e280 ">
                                    <p>Java</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e303 d59478e283 ">
                                    <p>Oracle JDBC OCI or thin driver</p>
                                    <p>Oracle server-side thin driver</p>
                                    <p>Oracle server-side internal driver</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e314" headers="d59478e280 ">
                                    <p>PL/SQL</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e314 d59478e283 ">
                                    <p>Oracle PL/SQL and SQL</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e321" headers="d59478e280 ">
                                    <p>Visual Basic/C#</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e321 d59478e283 ">
                                    <p>Oracle ODBC driver</p>
                                    <p>Oracle Provider for OLE DB</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>The following figure shows how the database access products can access the database.</p>
                     <div class="figure" id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C__I1005974">
                        <p class="titleinfigure">Figure 7-1 Oracle Database Access Products </p><img src="img/nlspg024.gif" alt="Description of Figure 7-1 follows" title="Description of Figure 7-1 follows" longdesc="img_text/nlspg024.html"><br><a href="img_text/nlspg024.html">Description of "Figure 7-1 Oracle Database Access Products "</a></div>
                     <!-- class="figure" -->
                     <p>The <a id="d59478e338" class="indexterm-anchor"></a><a id="d59478e340" class="indexterm-anchor"></a><a id="d59478e344" class="indexterm-anchor"></a>Oracle Call Interface (OCI) is the lowest level API that the rest of the client-side database access products use. It provides a flexible way for C/C++ programs to access Unicode data stored in SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types. Using OCI, you can programmatically specify the character set (UTF-8, UTF-16, and others) for the data to be inserted or retrieved. It accesses the database through Oracle Net.
                     </p>
                     <p><a id="d59478e354" class="indexterm-anchor"></a><a id="d59478e356" class="indexterm-anchor"></a>Oracle Pro*C/C++ enables you to embed SQL and PL/SQL in your programs. It uses OCI's Unicode capabilities to provide UTF-16 and UTF-8 data access for SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types.
                     </p>
                     <p>The <a id="d59478e369" class="indexterm-anchor"></a><a id="d59478e371" class="indexterm-anchor"></a>Oracle ODBC driver enables C/C++, Visual Basic, and VBScript programs running on Windows platforms to access Unicode data stored in SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types of the database. It provides UTF-16 data access by implementing the <code class="codeph">SQLWCHAR</code> interface specified in the ODBC standard specification. 
                     </p>
                     <p>The <a id="d59478e387" class="indexterm-anchor"></a><a id="d59478e389" class="indexterm-anchor"></a>Oracle Provider for OLE DB enables C/C++, Visual Basic, and VBScript programs running on Windows platforms to access Unicode data stored in SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types. It provides UTF-16 data access through wide string OLE DB data types. 
                     </p>
                     <p>The <a id="d59478e402" class="indexterm-anchor"></a><a id="d59478e404" class="indexterm-anchor"></a>Oracle Data Provider for .NET enables programs running in any .NET programming environment on Windows platforms to access Unicode data stored in SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types. It provides UTF-16 data access through Unicode data types.
                     </p>
                     <p>Oracle JDBC drivers are the primary Java programmatic interface for accessing an Oracle database. Oracle provides the following JDBC drivers:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <a id="d59478e421" class="indexterm-anchor"></a><a id="d59478e425" class="indexterm-anchor"></a>JDBC OCI driver that is used by Java applications and requires the OCI library
                           </p>
                        </li>
                        <li>
                           <p>The <a id="d59478e433" class="indexterm-anchor"></a><a id="d59478e437" class="indexterm-anchor"></a>JDBC thin driver, which is a pure Java driver that is primarily used by Java applets and supports the Oracle Net protocol over TCP/IP
                           </p>
                        </li>
                        <li>
                           <p>The<a id="d59478e445" class="indexterm-anchor"></a><a id="d59478e449" class="indexterm-anchor"></a> JDBC server-side thin driver, a pure Java driver used inside Java stored procedures to connect to another Oracle server
                           </p>
                        </li>
                        <li>
                           <p>The <a id="d59478e457" class="indexterm-anchor"></a><a id="d59478e461" class="indexterm-anchor"></a>JDBC server-side internal driver that is used inside the Oracle server to access the data in the database
                           </p>
                        </li>
                     </ul>
                     <p>All drivers support Unicode data access to SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types in the database.
                     </p>
                     <p>The <a id="d59478e477" class="indexterm-anchor"></a><a id="d59478e479" class="indexterm-anchor"></a>PL/SQL and SQL engines process PL/SQL programs and SQL statements on behalf of client-side programs such as OCI and server-side PL/SQL stored procedures. They allow PL/SQL programs to declare <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, <code class="codeph">NCHAR</code>, and <code class="codeph">NVARCHAR2</code> variables and to access SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types in the database.
                     </p>
                     <p>The following sections describe how each of the database access products supports Unicode data access to an Oracle database and offer examples for using those products:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE">SQL and PL/SQL Programming with Unicode</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">OCI Programming with Unicode</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-302CBDBC-3A81-415F-86B0-86BB56796B33">Pro*C/C++ Programming with Unicode</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-39A80CED-25E1-416B-8723-267A504599C0">JDBC Programming with Unicode</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE">ODBC and OLE DB Programming with Unicode</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="NLSPG0073"></a><div class="props_rev_3"><a id="GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE" name="GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE"></a><h3 id="NLSPG-GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE" class="sect3"><span class="enumeration_section">7.2 </span>SQL and PL/SQL Programming with Unicode
               </h3>
               <div>
                  <p>SQL is the fundamental language with which all programs and users access data in an Oracle database either directly or indirectly. PL/SQL is a procedural language that combines the data manipulating power of SQL with the data processing power of procedural languages. Both SQL and PL/SQL can be embedded in other programming languages. This section describes Unicode-related features in SQL and PL/SQL that you can deploy for multilingual applications. </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1">SQL NCHAR Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5">Implicit Data Type Conversion Between NCHAR and Other Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D">Exception Handling for Data Loss During Data Type Conversion</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F">Rules for Implicit Data Type Conversion</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B">SQL Functions for Unicode Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88">Other SQL Functions</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-9F223401-9892-4380-92FA-656ADCF84B50">Unicode String Literals</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC">Using the UTL_FILE Package with NCHAR Data</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG0071"></a><div class="props_rev_3"><a id="GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1" name="GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1"></a><h4 id="NLSPG-GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1" class="sect4"><span class="enumeration_section">7.2.1 </span>SQL NCHAR Data Types
                  </h4>
                  <div>
                     <p>There are three SQL <code class="codeph">NCHAR</code> data types:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511">The NCHAR Data Type</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007">The NVARCHAR2 Data Type</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7">The NCLOB Data Type</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG335"></a><div class="props_rev_3"><a id="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511" name="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511"></a><h5 id="NLSPG-GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511" class="sect5"><span class="enumeration_section">7.2.1.1 </span>The NCHAR Data Type
                     </h5>
                     <div>
                        <p>When you define a table column or a PL/SQL variable as the <code class="codeph">NCHAR</code> data type, the length is always specified as the number of characters. For example, the following statement creates a column with a maximum length of 30 characters:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE table1 (column1 NCHAR(30)); 
</pre><p>The maximum number of bytes for the column is determined as follows:</p><pre class="oac_no_warn" dir="ltr">maximum number of bytes = (maximum number of characters) x (maximum number of bytes for each character)
</pre><p>For example, if the national character set is UTF8, then the maximum byte length is 30 characters times 3 bytes for each character, or 90 bytes. </p>
                        <p>The national character set, which is used for all <code class="codeph">NCHAR</code> data types, is defined when the database is created. The national character set can be either UTF8 or AL16UTF16. The default is AL16UTF16.<a id="d59478e831" class="indexterm-anchor"></a><a id="d59478e833" class="indexterm-anchor"></a></p>
                        <p>The maximum column size allowed is 32000 characters when the national character set is UTF8 and 8000 when it is AL16UTF16. The actual data is subject to the maximum byte limit of 16000. The two size constraints must be satisfied at the same time. In PL/SQL, the maximum length of <code class="codeph">NCHAR</code> data is 32767 bytes. You can define an <code class="codeph">NCHAR</code> variable of up to 32767 characters, but the actual data cannot exceed 32767 bytes. If you insert a value that is shorter than the column length, then Oracle pads the value with blanks to whichever length is smaller: maximum character length or maximum byte length. 
                        </p>
                        <div class="infoboxnote" id="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511__GUID-C16BB030-5266-471B-BC4F-D0ADF8BAFA80">
                           <p class="notep1">Note:</p>
                           <p>UTF8 may affect performance because it is a variable-width character set. Excessive blank padding of <code class="codeph">NCHAR</code> fields decreases performance. Consider using the <code class="codeph">NVARCHAR2</code> data type or changing to the AL16UTF16 character set for the <code class="codeph">NCHAR</code> data type.
                           </p>
                        </div>
                     </div>
                  </div><a id="NLSPG336"></a><div class="props_rev_3"><a id="GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007" name="GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007"></a><h5 id="NLSPG-GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007" class="sect5"><span class="enumeration_section">7.2.1.2 </span>The NVARCHAR2 Data Type
                     </h5>
                     <div>
                        <p>The <code class="codeph">NVARCHAR2</code> data type specifies a variable length character string that uses the national character set<a id="d59478e934" class="indexterm-anchor"></a><a id="d59478e936" class="indexterm-anchor"></a>. When you create a table with an <code class="codeph">NVARCHAR2</code> column, you specify the maximum number of characters for the column. Lengths for <code class="codeph">NVARCHAR2</code> are always in units of characters, just as for <code class="codeph">NCHAR</code>. Oracle subsequently stores each value in the column exactly as you specify it, if the value does not exceed the column's maximum length. Oracle does not pad the string value to the maximum length.
                        </p>
                        <p>The maximum length for the <code class="codeph">NVARCHAR2</code> type is 4000 characters if <code class="codeph">MAX_STRING_SIZE</code> <code class="codeph">=</code> <code class="codeph">STANDARD</code> or 32767 characters if <code class="codeph">MAX_STRING_SIZE</code> <code class="codeph">=</code> <code class="codeph">EXTENDED</code>. These lengths are based on using UTF8; the values are 2000 and 16383 characters when using AL16UTF16.
                        </p>
                        <p>In PL/SQL, the maximum length for an <code class="codeph">NVARCHAR2</code> variable is 32767 bytes. You can define <code class="codeph">NVARCHAR2</code> variables up to 32767 characters, but the actual data cannot exceed 32767 bytes. 
                        </p>
                        <p>The following statement creates a table with one <code class="codeph">NVARCHAR2</code> column whose maximum length in characters is 2000 and maximum length in bytes is 4000. 
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE table2 (column2 NVARCHAR2(2000)); </pre></div>
                  </div><a id="NLSPG337"></a><div class="props_rev_3"><a id="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7" name="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7"></a><h5 id="NLSPG-GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7" class="sect5"><span class="enumeration_section">7.2.1.3 </span>The NCLOB Data Type
                     </h5>
                     <div>
                        <p><code class="codeph">NCLOB</code> is a character large object containing Unicode characters, with a maximum size of 4 gigabytes. Unlike the <code class="codeph">BLOB</code> data type, the <code class="codeph">NCLOB</code> data type has full transactional support so that changes made through SQL, the <code class="codeph">DBMS_LOB</code> package, or OCI participate fully in transactions. Manipulations of <code class="codeph">NCLOB</code> value can be committed and rolled back. Note, however, that you cannot save an <code class="codeph">NCLOB</code> locator in a PL/SQL or OCI variable in one transaction and then use it in another transaction or session.
                        </p>
                        <p><code class="codeph">NCLOB</code> values are stored in the database in a format that is compatible with UCS-2, regardless of the national character set. Oracle translates the stored Unicode value to the character set requested on the client or on the server, which can be fixed-width or variable-width. When you insert data into an <code class="codeph">NCLOB</code> column using a variable-width character set, Oracle converts the data into a format that is compatible with UCS-2 before storing it in the database. 
                        </p>
                        <div class="infoboxnotealso" id="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7__GUID-DEFD2C2D-4B81-4AFB-BA5D-032E88823688">
                           <p class="notep1">See Also:</p>
                           <p><a href="../adlob/introduction-to-large-objects.html#ADLOB45125" target="_blank"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide </span></a>for more information about the <code class="codeph">NCLOB</code> data type
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="NLSPG338"></a><div class="props_rev_3"><a id="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5" name="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5"></a><h4 id="NLSPG-GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5" class="sect4"><span class="enumeration_section">7.2.2 </span>Implicit Data Type Conversion Between NCHAR and Other Data Types
                  </h4>
                  <div>
                     <p>Oracle supports implicit conversions between SQL <code class="codeph">NCHAR</code> data types and other Oracle data types, such as <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, <code class="codeph">NUMBER</code>, <code class="codeph">DATE</code>, <code class="codeph">ROWID</code>, and <code class="codeph">CLOB</code>. Any implicit conversions for <code class="codeph">CHAR</code> and <code class="codeph">VARCHAR2</code> data types are also supported for SQL <code class="codeph">NCHAR</code> data types. You can use SQL <code class="codeph">NCHAR</code> data types the same way as SQL <code class="codeph">CHAR</code> data types.
                     </p>
                     <p>Type conversions between SQL <code class="codeph">CHAR</code> data types and SQL <code class="codeph">NCHAR</code> data types may involve character set conversion when the database and national character sets are different. Padding with blanks may occur if the target data is either <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5__GUID-86CA036A-7A43-475E-8F50-993B4320D184">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/TO_NCHAR-character.html#SQLRF06136" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                     </div>
                  </div>
               </div><a id="NLSPG339"></a><div class="props_rev_3"><a id="GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D" name="GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D"></a><h4 id="NLSPG-GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D" class="sect4"><span class="enumeration_section">7.2.3 </span>Exception Handling for Data Loss During Data Type Conversion
                  </h4>
                  <div>
                     <p>Data loss can occur during<a id="d59478e1309" class="indexterm-anchor"></a><a id="d59478e1315" class="indexterm-anchor"></a> data type conversion when character set conversion is necessary. If a character in the source character set is not defined in the target character set, then a replacement character is used in its place. For example, if you try to insert <code class="codeph">NCHAR</code> data into a regular <code class="codeph">CHAR</code> column and the character data in <code class="codeph">NCHAR</code> (Unicode) form cannot be converted to the database character set, then the character is replaced by a replacement character defined by the database character set. The <code class="codeph">NLS_NCHAR_CONV_EXCP</code> initialization parameter controls the behavior of data loss during character type conversion. When this parameter is set to <code class="codeph">TRUE</code>, any SQL statements that result in data loss return an <code class="codeph">ORA-12713</code> error and the corresponding operation is stopped. When this parameter is set to <code class="codeph">FALSE</code>, data loss is not reported and the unconvertible characters are replaced with replacement characters. The default value is <code class="codeph">FALSE</code>. This parameter works for both implicit and explicit conversion.
                     </p>
                     <p>In PL/SQL, when data loss occurs during conversion of SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types, the <code class="codeph">LOSSY_CHARSET_CONVERSION</code> exception is raised for both implicit and explicit conversion.
                     </p>
                  </div>
               </div><a id="NLSPG802"></a><a id="NLSPG340"></a><div class="props_rev_3"><a id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F" name="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F"></a><h4 id="NLSPG-GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F" class="sect4"><span class="enumeration_section">7.2.4 </span>Rules for Implicit Data Type Conversion
                  </h4>
                  <div>
                     <p>In some <a id="d59478e1431" class="indexterm-anchor"></a><a id="d59478e1433" class="indexterm-anchor"></a>cases, conversion between data types is possible in only one direction. In other cases, conversion in both directions is possible. Oracle defines a set of rules for conversion between data types. The following table contains the rules for conversion between data types.
                     </p>
                     <div class="tblformalwide" id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__G1010142">
                        <p class="titleintable">Table 7-2 Rules for Conversion Between Data Types</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Rules for Conversion Between Data Types" summary="This table is described in the preceding text" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d59478e1448">Statement</th>
                                 <th align="left" valign="bottom" width="71%" id="d59478e1451">Rule</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1456" headers="d59478e1448 ">
                                    <p><code class="codeph">INSERT</code>/<code class="codeph">UPDATE</code> statement
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1456 d59478e1451 ">
                                    <p>Values are converted to the data type of the target database column.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1468" headers="d59478e1448 ">
                                    <p><code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1468 d59478e1451 ">
                                    <p>Data from the database is converted to the data type of the target variable.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1480" headers="d59478e1448 ">
                                    <p>Variable assignments</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1480 d59478e1451 ">
                                    <p>Values on the right of the equal sign are converted to the data type of the target variable on the left of the equal sign. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1487" headers="d59478e1448 ">
                                    <p>Parameters in SQL and PL/SQL functions</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1487 d59478e1451 ">
                                    <p><code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, <code class="codeph">NCHAR</code>, and <code class="codeph">NVARCHAR2</code> are loaded the same way. An argument with a <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, <code class="codeph">NCHAR</code> or <code class="codeph">NVARCHAR2</code> data type is compared to a formal parameter of any of the <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, <code class="codeph">NCHAR</code> or <code class="codeph">NVARCHAR2</code> data types. If the argument and formal parameter data types do not match exactly, then implicit conversions are introduced when data is copied into the parameter on function entry and copied out to the argument on function exit.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1530" headers="d59478e1448 ">
                                    <p>Concatenation || operation or <code class="codeph">CONCAT</code> function
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1530 d59478e1451 ">
                                    <p>If one operand is a SQL <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code> data type and the other operand is a <code class="codeph">NUMBER</code> or other non-character data type, then the other data type is converted to <code class="codeph">VARCHAR2</code> or <code class="codeph">NVARCHAR2</code>. For concatenation between character data types, see <span class="q">"<a href="programming-with-unicode.html#GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__I1006225">SQL NCHAR data types and SQL CHAR data types</a>"</span>. 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1560" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code> data types and <code class="codeph">NUMBER</code> data type
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1560 d59478e1451 ">
                                    <p>Character values are converted to <code class="codeph">NUMBER</code> data type.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1579" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code> data types and <code class="codeph">DATE</code> data type
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1579 d59478e1451 ">
                                    <p>Character values are converted to <code class="codeph">DATE</code> data type.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1598" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code> or <code class="codeph">NCHAR</code> data types and <code class="codeph">ROWID</code> data type
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1598 d59478e1451 ">
                                    <p>Character values are converted to <code class="codeph">ROWID</code> data type.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1617" headers="d59478e1448 ">
                                    <p id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__I1006225">SQL <code class="codeph">NCHAR</code> data types and SQL <code class="codeph">CHAR</code> data types
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1617 d59478e1451 ">
                                    <p>Comparisons between SQL <code class="codeph">NCHAR</code> data types and SQL <code class="codeph">CHAR</code> data types are more complex because they can be encoded in different character sets.
                                    </p>
                                    <p>When <code class="codeph">CHAR</code> and <code class="codeph">VARCHAR2</code> values are compared, the <code class="codeph">CHAR</code> values are converted to <code class="codeph">VARCHAR2</code> values.
                                    </p>
                                    <p>When <code class="codeph">NCHAR</code> and <code class="codeph">NVARCHAR2</code> values are compared, the <code class="codeph">NCHAR</code> values are converted to <code class="codeph">NVARCHAR2</code> values.
                                    </p>
                                    <p>When there is comparison between SQL <code class="codeph">NCHAR</code> data types and SQL <code class="codeph">CHAR</code> data types, character set conversion occurs if they are encoded in different character sets. The character set for SQL <code class="codeph">NCHAR</code> data types is always Unicode and can be either UTF8 or AL16UTF16 encoding, which have the same character repertoires but are different encodings of the Unicode standard. SQL <code class="codeph">CHAR</code> data types use the database character set, which can be any character set that Oracle supports. Unicode is a superset of any character set supported by Oracle, so SQL <code class="codeph">CHAR</code> data types can always be converted to SQL <code class="codeph">NCHAR</code> data types without data loss.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="NLSPG803"></a><a id="NLSPG804"></a><a id="NLSPG805"></a><a id="NLSPG341"></a><div class="props_rev_3"><a id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B" name="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B"></a><h4 id="NLSPG-GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B" class="sect4"><span class="enumeration_section">7.2.5 </span>SQL Functions for Unicode Data Types
                  </h4>
                  <div>
                     <p>SQL <code class="codeph">NCHAR</code> data types can be converted to and from SQL <code class="codeph">CHAR</code> data types and other data types using explicit conversion functions. The examples in this section use the table created by the following statement:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE customers 
  (id NUMBER, name NVARCHAR2(50), address NVARCHAR2(200), birthdate DATE);</pre><div class="infoboxnotealso" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-DD3D3716-941F-4FB1-9437-5A129E3C43D2">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/Data-Types.html#SQLRF50975" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about explicit conversion functions for SQL <code class="codeph">NCHAR</code> data types
                        </p>
                     </div>
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-FF24217D-38DA-4835-89AC-D0650F1851C3">
                        <p class="titleinexample">Example 7-1 Populating the Customers Table Using the TO_NCHAR Function</p>
                        <p>The <code class="codeph">TO_NCHAR</code> function converts the data at run time, while the <code class="codeph">N</code> function converts the data at compilation time.
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO customers VALUES (1000, 
  TO_NCHAR('John Smith'),N'500 Oracle Parkway',sysdate);</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-4FE44629-6F9A-4687-B030-023EF0E60512">
                        <p class="titleinexample">Example 7-2 Selecting from the Customer Table Using the TO_CHAR Function</p>
                        <p>The following statement converts the values of <code class="codeph">name</code> from characters in the national character set to characters in the database character set before selecting them according to the <code class="codeph">LIKE</code> clause:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT name FROM customers WHERE TO_CHAR(name) LIKE '%Sm%';
</pre><p>You should see the following output:</p><pre class="oac_no_warn" dir="ltr">NAME
--------------------------------------
John Smith</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__CACIACHB">
                        <p class="titleinexample">Example 7-3 Selecting from the Customer Table Using the TO_DATE Function</p>
                        <p>Using the <code class="codeph">N</code> function shows that either <code class="codeph">NCHAR</code> or <code class="codeph">CHAR</code> data can be passed as parameters for the <code class="codeph">TO_DATE</code> function. The data types can mixed because they are converted at run time.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
   ndatestring NVARCHAR2(20) := N'12-SEP-1975';
   ndstr NVARCHAR2(50);
BEGIN
   SELECT name INTO ndstr FROM customers
   WHERE (birthdate)&gt; TO_DATE(ndatestring, 'DD-MON-YYYY', NLS_DATE_LANGUAGE = 
   'AMERICAN');
END;
</pre><p>As demonstrated in <a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__CACIACHB">Example 7-3</a>, SQL <code class="codeph">NCHAR</code> data can be passed to explicit conversion functions. SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data can be mixed together when using multiple string parameters. 
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="NLSPG806"></a><a id="NLSPG807"></a><a id="NLSPG808"></a><a id="NLSPG342"></a><div class="props_rev_3"><a id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88" name="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88"></a><h4 id="NLSPG-GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88" class="sect4"><span class="enumeration_section">7.2.6 </span>Other SQL Functions
                  </h4>
                  <div>
                     <p>Most SQL functions can take arguments of SQL <code class="codeph">NCHAR</code> data types as well as mixed character data types. The return data type is based on the type of the first argument. If a non-string data type like <code class="codeph">NUMBER</code> or <code class="codeph">DATE</code> is passed to these functions, then it is converted to <code class="codeph">VARCHAR2</code>. The following examples use the <code class="codeph">customer</code> table created in <span class="q">"<a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B">SQL Functions for Unicode Data Types</a>"</span>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-7309E921-8B4C-417E-A41B-B42B0D740131">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/RPAD.html#SQLRF06103" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                     </div>
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-275110E1-47F5-431A-9E89-4C4F01719A17">
                        <p class="titleinexample">Example 7-4 INSTR Function </p>
                        <p>In this example, the string literal <code class="codeph">'Sm'</code> is converted to <code class="codeph">NVARCHAR2</code> and then scanned by <code class="codeph">INSTR</code>, to detect the position of the first occurrence of this string in <code class="codeph">name</code>.
                        </p><pre class="oac_no_warn" dir="ltr"><a id="d59478e1974" class="indexterm-anchor"></a><a id="d59478e1976" class="indexterm-anchor"></a>SELECT INSTR(name, N'Sm', 1, 1) FROM customers;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-7E86FEF4-3C16-4BE4-A6AE-9B30041D7277">
                        <p class="titleinexample">Example 7-5 CONCAT Function</p><pre class="oac_no_warn" dir="ltr">SELECT CONCAT(name,id) FROM customers;
</pre><p><code class="codeph">id</code> is converted to <code class="codeph">NVARCHAR2</code> and then concatenated with <code class="codeph">name</code>.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-AF0EE263-44DA-4C73-976F-6EC3F37F3714">
                        <p class="titleinexample">Example 7-6 RPAD Function</p><pre class="oac_no_warn" dir="ltr"><a id="d59478e2000" class="indexterm-anchor"></a><a id="d59478e2002" class="indexterm-anchor"></a>SELECT RPAD(name,100,' ') FROM customers;
</pre><p>The following output results:</p><pre class="oac_no_warn" dir="ltr">RPAD(NAME,100,'')
------------------------------------------
John Smith
</pre><p>The space character ' ' is converted to the corresponding character in the <code class="codeph">NCHAR</code> character set and then padded to the right of <code class="codeph">name</code> until the total display length reaches 100.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="NLSPG343"></a><div class="props_rev_3"><a id="GUID-9F223401-9892-4380-92FA-656ADCF84B50" name="GUID-9F223401-9892-4380-92FA-656ADCF84B50"></a><h4 id="NLSPG-GUID-9F223401-9892-4380-92FA-656ADCF84B50" class="sect4"><span class="enumeration_section">7.2.7 </span>Unicode String Literals
                  </h4>
                  <div>
                     <p>You can input <a id="d59478e2093" class="indexterm-anchor"></a><a id="d59478e2097" class="indexterm-anchor"></a>Unicode string literals in SQL and PL/SQL as follows: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Put a prefix <code class="codeph">N</code> before a string literal that is enclosed with single quotation marks. This explicitly indicates that the following string literal is an <code class="codeph">NCHAR</code> string literal. For example, <code class="codeph">N'rsum'</code> is an <code class="codeph">NCHAR</code> string literal. For information about limitations of this method, see <span class="q">"<a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR String Literal Replacement</a>"</span>.
                           </p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">NCHR(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> SQL function, which returns a unit of character code in the national character set, which is AL16UTF16 or UTF8. The result of concatenating several <code class="codeph">NCHR(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> functions is <code class="codeph">NVARCHAR2</code> data. In this way, you can bypass the client and server character set conversions and create an <code class="codeph">NVARCHAR2</code> string directly. For example, <code class="codeph">NCHR(32)</code> represents a blank character.
                           </p>
                           <p>Because <code class="codeph">NCHR(</code><span class="italic"><code class="codeph">n</code></span><code class="codeph">)</code> is associated with the national character set, portability of the resulting value is limited to applications that run with the same national character set. If this is a concern, then use the <code class="codeph">UNISTR</code> function to remove portability limitations.
                           </p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">UNISTR</code>('<span class="italic"><code class="codeph">string'</code></span>) SQL function. <code class="codeph">UNISTR</code>('<span class="italic"><code class="codeph">string'</code></span>) converts a string to the national character set. To ensure portability and to preserve data, include only ASCII characters and Unicode encoding in the following form: <code class="codeph">\xxxx</code>, where <code class="codeph">xxxx</code> is the hexadecimal value of a character code value in UTF-16 encoding format. For example, <code class="codeph">UNISTR('G\0061ry')</code> represents <code class="codeph">'Gary'</code>. The ASCII characters are converted to the database character set and then to the national character set. The Unicode encoding is converted directly to the national character set.
                           </p>
                        </li>
                     </ul>
                     <p>The last two methods can be used to encode any Unicode string literals.</p>
                  </div>
               </div><a id="NLSPG344"></a><div class="props_rev_3"><a id="GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D" name="GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D"></a><h4 id="NLSPG-GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D" class="sect4"><span class="enumeration_section">7.2.8 </span>NCHAR String Literal Replacement
                  </h4>
                  <div>
                     <p>This section provides information on how to avoid data loss when performing <code class="codeph">NCHAR</code> string literal replacement.
                     </p>
                     <p>Being part of a SQL or PL/SQL statement, the text of any literal, with or without the prefix <code class="codeph">N</code>, is encoded in the same character set as the rest of the statement. On the client side, the statement is in the client character set, which is determined by the client character set defined in <code class="codeph">NLS_LANG</code>, or specified in the <code class="codeph">OCIEnvNlsCreate()</code> call, or predefined as UTF-16 in JDBC. On the server side, the statement is in the database character set.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When the SQL or PL/SQL statement is transferred from client to the database server, its character set is converted accordingly. It is important to note that if the database character set does not contain all characters used in the text literals, then the data is lost in this conversion. This problem affects <code class="codeph">NCHAR</code> string literals more than the <code class="codeph">CHAR</code> text literals. This is because the <code class="codeph">N'</code> literals are designed to be independent of the database character set, and should be able to provide any data that the client character set supports.
                           </p>
                           <p>To avoid data loss in conversion to an incompatible database character set, you can activate the <code class="codeph">NCHAR</code> literal replacement functionality. The functionality transparently replaces the <code class="codeph">N'</code> literals on the client side with an internal format. The database server then decodes this to Unicode when the statement is executed.
                           </p>
                        </li>
                        <li>
                           <p>The sections <span class="q">"<a href="programming-with-unicode.html#GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2">Handling SQL NCHAR String Literals in OCI</a>"</span> and <span class="q">"<a href="programming-with-unicode.html#GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497">Using SQL NCHAR String Literals in JDBC</a>"</span> show how to switch on the replacement functionality in OCI and JDBC, respectively. Because many applications, for example, SQL*Plus, use OCI to connect to a database, and they do not control <code class="codeph">NCHAR</code> literal replacement explicitly, you can set the client environment variable <code class="codeph">ORA_NCHAR_LITERAL_REPLACE</code> to <code class="codeph">TRUE</code> to control the functionality for them. By default, the functionality is switched off to maintain backward compatibility.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="NLSPG345"></a><div class="props_rev_3"><a id="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC" name="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC"></a><h4 id="NLSPG-GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC" class="sect4"><span class="enumeration_section">7.2.9 </span>Using the UTL_FILE Package with NCHAR Data
                  </h4>
                  <div>
                     <p>The <code class="codeph">UTL_FILE</code> package handles Unicode national character set data of the <code class="codeph">NVARCHAR2</code> data type. <code class="codeph">NCHAR</code> and <code class="codeph">NCLOB</code> are supported through implicit conversion. The functions and procedures include the following:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">FOPEN_NCHAR</code></p>
                           <p>This function opens a file in national character set mode for input or output, with the maximum line size specified. Even though the contents of an <code class="codeph">NVARCHAR2</code> buffer may be AL16UTF16 or UTF8 (depending on the national character set of the database), the contents of the file are always read and written in UTF8. See <span class="q">"<a href="supporting-multilingual-databases-with-unicode.html#GUID-CD422E4F-C5C6-4E22-B95F-CA9CABBCB543">Support for the Unicode Standard in Oracle Database</a>"</span> for more information. <code class="codeph">UTL_FILE</code> converts between UTF8 and AL16UTF16 as necessary.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">GET_LINE_NCHAR</code></p>
                           <p>This procedure reads text from the open file identified by the file handle and places the text in the output buffer parameter. The file must be opened in national character set mode, and must be encoded in the UTF8 character set. The expected buffer data type is <code class="codeph">NVARCHAR2</code>. If a variable of another data type, such as <code class="codeph">NCHAR</code>, <code class="codeph">NCLOB</code>, or <code class="codeph">VARCHAR2</code> is specified, PL/SQL performs standard implicit conversion from <code class="codeph">NVARCHAR2</code> after the text is read.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUT_NCHAR</code></p>
                           <p>This procedure writes the text string stored in the buffer parameter to the open file identified by the file handle. The file must be opened in the national character set mode. The text string will be written in the UTF8 character set. The expected buffer data type is <code class="codeph">NVARCHAR2</code>. If a variable of another data type is specified, PL/SQL performs implicit conversion to <code class="codeph">NVARCHAR2</code> before writing the text.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUT_LINE_NCHAR</code></p>
                           <p>This procedure is equivalent to <code class="codeph">PUT_NCHAR</code>, except that the line separator is appended to the written text.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUTF_NCHAR</code></p>
                           <p>This procedure is a formatted version of a <code class="codeph">PUT_NCHAR</code> procedure. It accepts a format string with formatting elements \n and %s, and up to five arguments to be substituted for consecutive instances of %s in the format string. The expected data type of the format string and the arguments is <code class="codeph">NVARCHAR2</code>. If variables of another data type are specified, PL/SQL performs implicit conversion to <code class="codeph">NVARCHAR2</code> before formatting the text. Formatted text is written in the UTF8 character set to the file identified by the file handle. The file must be opened in the national character set mode.
                           </p>
                        </li>
                     </ul>
                     <p>The above functions and procedures process text files encoded in the UTF8 character set, that is, in the Unicode CESU-8 encoding. See <span class="q">"<a href="appendix-A-locale-data.html#GUID-9221C05D-B37A-4586-94AD-1CFC35B796F5">Universal Character Sets</a>"</span> for more information about CESU-8. The functions and procedures convert between UTF8 and the national character set of the database, which can be UTF8 or AL16UTF16, as needed.
                     </p>
                     <div class="infoboxnotealso" id="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC__GUID-758942EF-3F58-4F9C-B5AD-ACF843ABF06B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/UTL_FILE.html#ARPLS069" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">UTL_FILE</code> package
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="NLSPG0074"></a><div class="props_rev_3"><a id="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E" name="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E"></a><h3 id="NLSPG-GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E" class="sect3"><span class="enumeration_section">7.3 </span>OCI Programming with Unicode
               </h3>
               <div>
                  <p>OCI is the lowest-level API for accessing a database, so it offers the best possible performance. When using Unicode with OCI, consider these topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F">OCIEnvNlsCreate() Function for Unicode Programming</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F">OCI Unicode Code Conversion</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92">Setting UTF-8 to the NLS_LANG Character Set in OCI</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10">Binding and Defining SQL CHAR Data Types in OCI</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9">Binding and Defining SQL NCHAR Data Types in OCI</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2">Handling SQL NCHAR String Literals in OCI</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-83EB573B-5265-45A5-A053-46F460D4CC64">Binding and Defining CLOB and NCLOB Unicode Data in OCI</a></p>
                        <div class="infoboxnotealso" id="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E__GUID-3F1406B0-954A-4282-8083-08637D845792">
                           <p class="notep1">See Also:</p>
                           <p><a href="OCI-programming-in-global-environment.html#GUID-EC6C34A4-EBA0-4AA6-BBDC-191A1068A2E9">OCI Programming in a Global Environment</a></p>
                        </div>
                     </li>
                  </ul>
               </div><a id="NLSPG346"></a><div class="props_rev_3"><a id="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F" name="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F"></a><h4 id="NLSPG-GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F" class="sect4"><span class="enumeration_section">7.3.1 </span>OCIEnvNlsCreate() Function for Unicode Programming
                  </h4>
                  <div>
                     <p>The <code class="codeph">OCIEnvNlsCreate()</code> function is used to specify a SQL <code class="codeph">CHAR</code> character set and a SQL <code class="codeph">NCHAR</code> character set when the OCI environment is created. It is an enhanced version of the <code class="codeph">OCIEnvCreate()</code> function and has extended arguments for two character set IDs. The <a id="d59478e2701" class="indexterm-anchor"></a>OCI_UTF16ID UTF-16 character set ID replaces the <a id="d59478e2705" class="indexterm-anchor"></a>Unicode mode introduced in Oracle9<span class="italic">i</span> release 1 (9.0.1). For example:
                     </p><pre class="oac_no_warn" dir="ltr">OCIEnv *envhp;
status = OCIEnvNlsCreate((OCIEnv **)&amp;envhp,
(ub4)0,
(void *)0,
(void *(*) ()) 0,
(void *(*) ()) 0,
(void(*) ()) 0,
(size_t) 0,
(void **)0,
(ub2)OCI_UTF16ID, /* Metadata and SQL CHAR character set */
(ub2)OCI_UTF16ID /* SQL NCHAR character set */);
</pre><p>The Unicode mode, in which the OCI_UTF16 flag is used with the <code class="codeph">OCIEnvCreate()</code> function, is deprecated. 
                     </p>
                     <p>When OCI_UTF16ID is specified for both SQL <code class="codeph">CHAR</code> and SQL <code class="codeph">NCHAR</code> character sets, all metadata and bound and defined data are encoded in UTF-16. Metadata includes SQL statements, user names, error messages, and column names. Thus, all inherited operations are independent of the <code class="codeph">NLS_LANG</code> setting, and all metatext data parameters (<code class="codeph">text*</code>) are assumed to be Unicode text data types (<code class="codeph">utext*</code>) in UTF-16 encoding.
                     </p>
                     <p>To prepare the SQL statement when the <code class="codeph">OCIEnv()</code> function is initialized with the OCI_UTF16ID character set ID, call the <code class="codeph">OCIStmtPrepare()</code> function with a <code class="codeph">(utext*)</code> string. The following example runs on the Windows platform only. You may need to change <code class="codeph">wchar_t</code> data types for other platforms.
                     </p><pre class="oac_no_warn" dir="ltr">const wchar_t sqlstr[] = L"SELECT * FROM ENAME=:ename";
...
OCIStmt* stmthp;
sts = OCIHandleAlloc(envh, (void **)&amp;stmthp, OCI_HTYPE_STMT, 0,
NULL);
status = OCIStmtPrepare(stmthp, errhp,(const text*)sqlstr,
wcslen(sqlstr), OCI_NTV_SYNTAX, OCI_DEFAULT);
</pre><p>To bind and define data, you do not have to set the <code class="codeph">OCI_ATTR_CHARSET_ID</code> attribute because the <code class="codeph">OCIEnv()</code> function has already been initialized with UTF-16 character set IDs. The bind variable names also must be UTF-16 strings.
                     </p><pre class="oac_no_warn" dir="ltr">/* Inserting Unicode data */
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (const text*)L":ename",
(sb4)wcslen(L":ename"),
              (void *) ename, sizeof(ename), SQLT_STR, (void
*)&amp;insname_ind,
              (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *)0,
OCI_DEFAULT);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *)
&amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
...
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
               (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0,
(ub2*)0, (ub4)OCI_DEFAULT);
</pre><p>The <code class="codeph">OCIExecute()</code> function performs the operation.
                     </p>
                     <div class="infoboxnotealso" id="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F__GUID-351A32F4-F15F-4683-A8DE-6426AD158269">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="OCI-programming-in-global-environment.html#GUID-862EA6EF-0D7E-43DD-9ADE-D6648D8F7988">Specifying Character Sets in OCI</a>"</span></p>
                     </div>
                  </div>
               </div><a id="NLSPG347"></a><div class="props_rev_3"><a id="GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F" name="GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F"></a><h4 id="NLSPG-GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F" class="sect4"><span class="enumeration_section">7.3.2 </span>OCI Unicode Code Conversion
                  </h4>
                  <div>
                     <p>Unicode <a id="d59478e2848" class="indexterm-anchor"></a><a id="d59478e2852" class="indexterm-anchor"></a>character set conversions take place between an OCI client and the database server if the client and server character sets are different. The conversion occurs on either the client or the server depending on the circumstances, but usually on the client side.
                     </p>
                  </div><a id="NLSPG348"></a><div class="props_rev_3"><a id="GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9" name="GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9"></a><h5 id="NLSPG-GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9" class="sect5"><span class="enumeration_section">7.3.2.1 </span>Data Integrity
                     </h5>
                     <div>
                        <p>You can <a id="d59478e2931" class="indexterm-anchor"></a><a id="d59478e2935" class="indexterm-anchor"></a>lose data during conversion if you call an OCI API inappropriately. If the server and client character sets are different, then you can lose data when the destination character set is a smaller set than the source character set. You can avoid this potential problem if both character sets are Unicode character sets (for example, UTF8 and AL16UTF16).
                        </p>
                        <p>When you bind or define SQL <code class="codeph">NCHAR</code> data types, you should set the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute to <code class="codeph">SQLCS_NCHAR</code>. Otherwise, you can lose data because the data is converted to the database character set before converting to or from the national character set. This occurs only if the database character set is not Unicode.
                        </p>
                     </div>
                  </div><a id="NLSPG809"></a><a id="NLSPG349"></a><div class="props_rev_3"><a id="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376" name="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376"></a><h5 id="NLSPG-GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376" class="sect5"><span class="enumeration_section">7.3.2.2 </span>OCI Performance Implications When Using Unicode
                     </h5>
                     <div>
                        <p>Redundant data conversions can cause performance degradation in your OCI applications. These conversions occur in two cases:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>When you bind or define SQL <code class="codeph">CHAR</code> data types and set the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute to <code class="codeph">SQLCS_NCHAR</code>, data conversions take place from client character set to the national database character set, and from the national character set to the database character set. No data loss is expected, but two conversions happen, even though it requires only one. 
                              </p>
                           </li>
                           <li>
                              <p>When you bind or define SQL <code class="codeph">NCHAR</code> data types and do not set <code class="codeph">OCI_ATTR_CHARSET_FORM</code>, data conversions take place from client character set to the database character set, and from the database character set to the national database character set. In the worst case, data loss can occur if the database character set is smaller than the client's. 
                              </p>
                           </li>
                        </ul>
                        <p>To avoid performance problems, you should always set <code class="codeph">OCI_ATTR_CHARSET_FORM</code> correctly, based on the data type of the target columns. If you do not know the target data type, then you should set the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute to <code class="codeph">SQLCS_NCHAR</code> when binding and defining.
                        </p>
                        <p>The following table contains information about OCI character set conversions.</p>
                        <div class="tblformalwide" id="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376__G1010212">
                           <p class="titleintable">Table 7-3 OCI Character Set Conversions </p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OCI Character Set Conversions " summary="This table describes settings for OCI_ATTR_CHARSET_FORM, based on the type of the target columns." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e3086">Data Types for OCI Client Buffer</th>
                                    <th align="left" valign="bottom" id="d59478e3089">OCI_ATTR_CHARSET_FORM</th>
                                    <th align="left" valign="bottom" id="d59478e3092">Data Types of the Target Column in the Database</th>
                                    <th align="left" valign="bottom" id="d59478e3095">Conversion Between</th>
                                    <th align="left" valign="bottom" id="d59478e3098">Comments</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3103" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3092 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3095 ">
                                       <p>UTF-16 and database character set in OCI</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3098 ">
                                       <p>No unexpected data loss</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3125" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3092 ">
                                       <p><code class="codeph">NCHAR,NVARCHAR2,</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3095 ">
                                       <p>UTF-16 and national character set in OCI</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3098 ">
                                       <p>No unexpected data loss</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3147" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3092 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3095 ">
                                       <p>UTF-16 and national character set in OCI</p>
                                       <p>National character set and database character set in database server</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3098 ">
                                       <p>No unexpected data loss, but may degrade performance because the conversion goes through the national character set</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3171" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3092 ">
                                       <p><code class="codeph">NCHAR,NVARCHAR2,</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3095 ">
                                       <p>UTF-16 and database character set in OCI</p>
                                       <p>Database character set and national character set in database server</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3098 ">
                                       <p>Data loss may occur if the database character set is not Unicode</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3195" headers="d59478e3086 ">
                                       <p><code class="codeph">text</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3092 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3095 ">
                                       <p><code class="codeph">NLS_LANG</code> character set and database character set in OCI
                                       </p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3098 ">
                                       <p>No unexpected data loss</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3219" headers="d59478e3086 ">
                                       <p><code class="codeph">text</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3092 ">
                                       <p><code class="codeph">NCHAR,NVARCHAR2,</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3095 ">
                                       <p><code class="codeph">NLS_LANG</code> character set and national character set in OCI
                                       </p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3098 ">
                                       <p>No unexpected data loss</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3243" headers="d59478e3086 ">
                                       <p><code class="codeph">text</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3092 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3095 ">
                                       <p><code class="codeph">NLS_LANG</code> character set and national character set in OCI
                                       </p>
                                       <p>National character set and database character set in database server</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3098 ">
                                       <p>No unexpected data loss, but may degrade performance because the conversion goes through the national character set</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3269" headers="d59478e3086 ">
                                       <p><code class="codeph">text</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3092 ">
                                       <p><code class="codeph">NCHAR,NVARCHAR2,</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3095 ">
                                       <p><code class="codeph">NLS_LANG</code> character set and database character set in OCI
                                       </p>
                                       <p>Database character set and national character set in database server</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3098 ">
                                       <p>Data loss may occur because the conversion goes through the database character set</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG350"></a><div class="props_rev_3"><a id="GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7" name="GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7"></a><h5 id="NLSPG-GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7" class="sect5"><span class="enumeration_section">7.3.2.3 </span>OCI Unicode Data Expansion
                     </h5>
                     <div>
                        <p>Data conversion can result in <a id="d59478e3369" class="indexterm-anchor"></a><a id="d59478e3373" class="indexterm-anchor"></a>data expansion, which can cause a buffer to overflow. For binding operations, you must set the <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute to a large enough size to hold the expanded data on the server. If this is difficult to do, then you must consider changing the table schema. For defining operations, client applications must allocate enough buffer space for the expanded data. The size of the buffer should be the maximum length of the expanded data. You can estimate the maximum buffer length with the following calculation:
                        </p>
                        <ol>
                           <li>
                              <p>Get the column data byte size.</p>
                           </li>
                           <li>
                              <p>Multiply it by the maximum number of bytes for each character in the client character set.</p>
                           </li>
                        </ol>
                        <p>This method is the simplest and quickest way, but it may not be accurate and can waste memory. It is applicable to any character set combination. For example, for UTF-16 data binding and defining, the following example calculates the client buffer:</p><pre class="oac_no_warn" dir="ltr">ub2 csid = OCI_UTF16ID;
oratext *selstmt = "SELECT ename FROM emp";
counter = 1;
... 
OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char*)selstmt),
               OCI_NTV_SYNTAX, OCI_DEFAULT);
OCIStmtExecute ( svchp, stmthp, errhp, (ub4)0, (ub4)0,
                 (CONST OCISnapshot*)0, (OCISnapshot*)0,
                 OCI_DESCRIBE_ONLY);
OCIParamGet(stmthp, OCI_HTYPE_STMT, errhp, &amp;myparam, (ub4)counter);
OCIAttrGet((void*)myparam, (ub4)OCI_DTYPE_PARAM, (void*)&amp;col_width,
           (ub4*)0, (ub4)OCI_ATTR_DATA_SIZE, errhp);
... 
maxenamelen = (col_width + 1) * sizeof(utext);
cbuf = (utext*)malloc(maxenamelen);
...
OCIDefineByPos(stmthp, &amp;dfnp, errhp, (ub4)1, (void *)cbuf,
                (sb4)maxenamelen, SQLT_STR, (void *)0, (ub2 *)0,
                (ub2*)0, (ub4)OCI_DEFAULT);
OCIAttrSet((void *) dfnp, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIStmtFetch(stmthp, errhp, 1, OCI_FETCH_NEXT, OCI_DEFAULT);
...</pre></div>
                  </div>
               </div><a id="NLSPG351"></a><div class="props_rev_3"><a id="GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92" name="GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92"></a><h4 id="NLSPG-GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92" class="sect4"><span class="enumeration_section">7.3.3 </span>Setting UTF-8 to the NLS_LANG Character Set in OCI
                  </h4>
                  <div>
                     <p>For OCI client applications that support Unicode UTF-8 encoding, use AL32UTF8 to specify the<a id="d59478e3467" class="indexterm-anchor"></a><a id="d59478e3471" class="indexterm-anchor"></a> <code class="codeph">NLS_LANG</code> character set, unless the database character set is UTF8. Use UTF8 if the database character set is UTF8.
                     </p>
                     <p>Do not set <code class="codeph">NLS_LANG</code> to AL16UTF16, because AL16UTF16 is the national character set for the server. If you need to use UTF-16, then you should specify the client character set to <code class="codeph">OCI_UTF16ID</code>, using the <code class="codeph">OCIAttrSet()</code> function when binding or defining data.
                     </p>
                  </div>
               </div><a id="NLSPG352"></a><div class="props_rev_3"><a id="GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10" name="GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10"></a><h4 id="NLSPG-GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10" class="sect4"><span class="enumeration_section">7.3.4 </span>Binding and Defining SQL CHAR Data Types in OCI
                  </h4>
                  <div>
                     <div class="section">
                        <p>To specify a <a id="d59478e3565" class="indexterm-anchor"></a><a id="d59478e3567" class="indexterm-anchor"></a><a id="d59478e3571" class="indexterm-anchor"></a>Unicode character set for binding and defining data with SQL <code class="codeph">CHAR</code> data types, you may need to call the <code class="codeph">OCIAttrSet()</code> function to set the appropriate character set ID after <code class="codeph">OCIBind()</code> or <code class="codeph">OCIDefine()</code> APIs. There are two typical cases:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Call <code class="codeph">OCIBind()</code> or <code class="codeph">OCIDefine()</code> followed by <code class="codeph">OCIAttrSet</code>() to specify UTF-16 Unicode character set encoding. For example:
                              </p><pre class="oac_no_warn" dir="ltr">...
ub2 csid = OCI_UTF16ID;
utext ename[100]; /* enough buffer for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
             (sb4)strlen((char *)":ENAME"), (void *) ename, sizeof(ename),
             SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0, (ub4) 0,
             (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename, 
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0,
                (ub2*)0, (ub4)OCI_DEFAULT); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp); 
...
</pre><p>If bound buffers are of the <code class="codeph">utext</code> data type, then you should add a cast (<code class="codeph">text</code>*) when <code class="codeph">OCIBind()</code> or <code class="codeph">OCIDefine()</code> is called. The value of the <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> attribute is usually determined by the column size of the server character set because this size is only used to allocate temporary buffer space for conversion on the server when you perform binding operations.
                              </p>
                           </li>
                           <li>
                              <p>Call <code class="codeph">OCIBind()</code> or <code class="codeph">OCIDefine()</code> with the <code class="codeph">NLS_LANG</code> character set specified as UTF8 or AL32UTF8.
                              </p>
                              <p>UTF8 or AL32UTF8 can be set in the <code class="codeph">NLS_LANG</code> environment variable. You call <code class="codeph">OCIBind()</code> and <code class="codeph">OCIDefine()</code> in exactly the same manner as when you are not using Unicode. Set the <code class="codeph">NLS_LANG</code> environment variable to UTF8 or AL32UTF8 and run the following OCI program:
                              </p><pre class="oac_no_warn" dir="ltr">...
oratext ename[100]; /* enough buffer size for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
              (sb4)strlen((char *)":ENAME"), (void *) ename, sizeof(ename),
              SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0,
              (ub4) 0, (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0, (ub2*)0,
                (ub4)OCI_DEFAULT); 
...</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG353"></a><div class="props_rev_3"><a id="GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9" name="GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9"></a><h4 id="NLSPG-GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9" class="sect4"><span class="enumeration_section">7.3.5 </span>Binding and Defining SQL NCHAR Data Types in OCI
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d59478e3724" class="indexterm-anchor"></a><a id="d59478e3726" class="indexterm-anchor"></a><a id="d59478e3730" class="indexterm-anchor"></a>Oracle recommends that you access SQL <code class="codeph">NCHAR</code> data types using UTF-16 binding or defining when using OCI. Beginning with Oracle9<span class="italic">i</span>, SQL <code class="codeph">NCHAR</code> data types are Unicode data types with an encoding of either UTF8 or AL16UTF16. To access data in SQL <code class="codeph">NCHAR</code> data types, set the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute to <code class="codeph">SQLCS_NCHAR</code> between binding or defining and execution so that it performs an appropriate data conversion without data loss. The length of data in SQL <code class="codeph">NCHAR</code> data types is always in the number of Unicode code units.
                        </p>
                        <p>The following program is a typical example of inserting and fetching data against an <code class="codeph">NCHAR</code> data column:
                        </p><pre class="oac_no_warn" dir="ltr">...
ub2 csid = OCI_UTF16ID;
ub1 cform = SQLCS_NCHAR;
utext ename[100]; /* enough buffer for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
              (sb4)strlen((char *)":ENAME"), (void *) ename,
              sizeof(ename), SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0,
              (ub2 *) 0, (ub4) 0, (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;cform, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_FORM, errhp); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0, (ub2*)0,
                (ub4)OCI_DEFAULT); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_ID, errhp); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;cform, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_FORM, errhp); 
...</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG354"></a><div class="props_rev_3"><a id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2" name="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2"></a><h4 id="NLSPG-GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2" class="sect4"><span class="enumeration_section">7.3.6 </span>Handling SQL NCHAR String Literals in OCI
                  </h4>
                  <div>
                     <div class="section">
                        <p>By default, the <code class="codeph">NCHAR</code> literal replacement is not enabled in OCI. You can enable it in OCI by setting the environment variable <code class="codeph">ORA_NCHAR_LITERAL_REPLACE</code> to <code class="codeph">TRUE</code>.
                        </p>
                        <p>You can also enable literal replacement programmatically in OCI by using the <code class="codeph">OCI_NCHAR_LITERAL_REPLACE_ON</code> and <code class="codeph">OCI_NCHAR_LITERAL_REPLACE_OFF</code> modes in <code class="codeph">OCIEnvCreate()</code> and <code class="codeph">OCIEnvNlsCreate()</code>. For example, <code class="codeph">OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_ON)</code> enables <code class="codeph">NCHAR</code> literal replacement and <code class="codeph">OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_OFF)</code> disables it.
                        </p>
                        <p>As an example, consider the following statement:</p><pre class="oac_no_warn" dir="ltr">int main(argc, argv)
{
   OCIEnv *envhp;

   if (OCIEnvCreate((OCIEnv **) &amp;envhp,
      (ub4)OCI_THREADED|OCI_NCHAR_LITERAL_REPLACE_ON,
      (dvoid *)0, (dvoid * (*)(dvoid *, size_t)) 0,
      (dvoid * (*)(dvoid *, dvoid *, size_t))0,
      (void (*)(dvoid *, dvoid *)) 0,
      (size_t) 0, (dvoid **) 0))
   {
      printf("FAILED: OCIEnvCreate()\n";
      return 1;
   }
   ...
}
</pre><div class="infoboxnote" id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2__GUID-F27310A1-2F79-4956-91D8-900896E9E8C0">
                           <p class="notep1">Note:</p>
                           <p>When <code class="codeph">NCHAR</code> literal replacement is enabled, <code class="codeph">OCIStmtPrepare</code> and <code class="codeph">OCIStmtPrepare2</code> transform <code class="codeph">N'</code> literals with <code class="codeph">U'</code> literals in the SQL text and store the resulting SQL text in the statement handle. Thus, if an application uses <code class="codeph">OCI_ATTR_STATEMENT</code> to retrieve the SQL text from the OCI statement handle, the SQL text returns <code class="codeph">U'</code> instead of <code class="codeph">N'</code> as specified in the original text.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2__GUID-9423E3AA-B9DE-4327-94D7-4A28F44515D4">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR String Literal Replacement</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/getting-started-with-database-administration.html#ADMIN12475" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about how to set environment variables
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG355"></a><div class="props_rev_3"><a id="GUID-83EB573B-5265-45A5-A053-46F460D4CC64" name="GUID-83EB573B-5265-45A5-A053-46F460D4CC64"></a><h4 id="NLSPG-GUID-83EB573B-5265-45A5-A053-46F460D4CC64" class="sect4"><span class="enumeration_section">7.3.7 </span>Binding and Defining CLOB and NCLOB Unicode Data in OCI
                  </h4>
                  <div>
                     <div class="section">
                        <p>In order to write (bind) and read (define) UTF-16 data for <code class="codeph">CLOB</code> or <code class="codeph">NCLOB</code> columns, the UTF-16 character set ID must be specified as <code class="codeph">OCILobWrite()</code> and <code class="codeph">OCILobRead()</code>. When you write UTF-16 data into a <code class="codeph">CLOB</code> column, call <code class="codeph">OCILobWrite()</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">...
ub2 csid = OCI_UTF16ID;
err = OCILobWrite (ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;amtp, offset, (void *) buf,
                   (ub4) BUFSIZE, OCI_ONE_PIECE, (void *)0,
                   (sb4 (*)()) 0, (ub2) csid, (ub1) SQLCS_IMPLICIT); 
</pre><p>The <code class="codeph">amtp</code> parameter is the data length in number of Unicode code units. The <code class="codeph">offset</code> parameter indicates the offset of data from the beginning of the data column. The <code class="codeph">csid</code> parameter must be set for UTF-16 data.
                        </p>
                        <p>To read UTF-16 data from <code class="codeph">CLOB</code> columns, call <code class="codeph">OCILobRead()</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">...
ub2 csid = OCI_UTF16ID;
err = OCILobRead(ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;amtp, offset, (void *) buf,
                 (ub4)BUFSIZE , (void *) 0, (sb4 (*)()) 0, (ub2)csid,
                 (ub1) SQLCS_IMPLICIT);
</pre><p>The data length is always represented in the number of Unicode code units. Note one Unicode supplementary character is counted as two code units, because the encoding is UTF-16. After binding or defining a <code class="codeph">LOB</code> column, you can measure the data length stored in the <code class="codeph">LOB</code> column using <code class="codeph">OCILobGetLength()</code>. The returning value is the data length in the number of code units if you bind or define as UTF-16.
                        </p><pre class="oac_no_warn" dir="ltr">err = OCILobGetLength(ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;lenp);
</pre><p>If you are using an <code class="codeph">NCLOB</code>, then you must set <code class="codeph">OCI_ATTR_CHARSET_FORM</code> to <code class="codeph">SQLCS_NCHAR</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="NLSPG0075"></a><div class="props_rev_3"><a id="GUID-302CBDBC-3A81-415F-86B0-86BB56796B33" name="GUID-302CBDBC-3A81-415F-86B0-86BB56796B33"></a><h3 id="NLSPG-GUID-302CBDBC-3A81-415F-86B0-86BB56796B33" class="sect3"><span class="enumeration_section">7.4 </span>Pro*C/C++ Programming with Unicode
               </h3>
               <div>
                  <p>Pro*C/C++ provides the following ways to insert or retrieve Unicode data into or from the database:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Using the <code class="codeph">VARCHAR</code> Pro*C/C++ data type or the native C/C++ <code class="codeph">text</code> data type, a program can access Unicode data stored in SQL <code class="codeph">CHAR</code> data types of a UTF8 or AL32UTF8 database. Alternatively, a program could use the C/C++ native <code class="codeph">text</code> type.
                        </p>
                     </li>
                     <li>
                        <p>Using the <code class="codeph">UVARCHAR</code> Pro*C/C++ data type or the native C/C++ <code class="codeph">utext</code> data type, a program can access Unicode data stored in <code class="codeph">NCHAR</code> data types of a database.
                        </p>
                     </li>
                     <li>
                        <p>Using the <code class="codeph">NVARCHAR</code> Pro*C/C++ data type, a program can access Unicode data stored in <code class="codeph">NCHAR</code> data types. The difference between <code class="codeph">UVARCHAR</code> and <code class="codeph">NVARCHAR</code> in a Pro*C/C++ program is that the data for the <code class="codeph">UVARCHAR</code> data type is stored in a <code class="codeph">utext</code> buffer while the data for the <code class="codeph">NVARCHAR</code> data type is stored in a <code class="codeph">text</code> data type.
                        </p>
                     </li>
                  </ul>
                  <p>Pro*C/C++ does not use the Unicode OCI API for SQL text. As a result, embedded SQL text must be encoded in the character set specified in the <code class="codeph">NLS_LANG</code> environment variable.
                  </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899">Pro*C/C++ Data Conversion in Unicode</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52">Using the VARCHAR Data Type in Pro*C/C++</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E">Using the NVARCHAR Data Type in Pro*C/C++</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-386C60EE-7DAA-47DC-91C8-6905F5255733">Using the UVARCHAR Data Type in Pro*C/C++</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG810"></a><a id="NLSPG356"></a><div class="props_rev_3"><a id="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899" name="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899"></a><h4 id="NLSPG-GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899" class="sect4"><span class="enumeration_section">7.4.1 </span>Pro*C/C++ Data Conversion in Unicode
                  </h4>
                  <div>
                     <p>Data <a id="d59478e4306" class="indexterm-anchor"></a><a id="d59478e4310" class="indexterm-anchor"></a>conversion occurs in the OCI layer, but it is the Pro*C/C++ preprocessor that instructs OCI which conversion path should be taken based on the data types used in a Pro*C/C++ program. The following table shows the conversion paths.
                     </p>
                     <div class="tblformalwide" id="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899__G1010270">
                        <p class="titleintable">Table 7-4 Pro*C/C++ Bind and Define Data Conversion </p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Pro*C/C++ Bind and Define Data Conversion " summary="This table describes Pro*C/C++ conversion paths." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e4326">Pro*C/C++ Data Type</th>
                                 <th align="left" valign="bottom" id="d59478e4329">SQL Data Type</th>
                                 <th align="left" valign="bottom" id="d59478e4332">Conversion Path</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4337" headers="d59478e4326 ">
                                    <p><code class="codeph">VARCHAR</code> or <code class="codeph">text</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4337 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4337 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code> character set to and from the database character set happens in OCI
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4354" headers="d59478e4326 ">
                                    <p><code class="codeph">VARCHAR</code> or <code class="codeph">text</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4354 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4354 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code> character set to and from database character set happens in OCI
                                    </p>
                                    <p>Database character set to and from national character set happens in database server</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4373" headers="d59478e4326 ">
                                    <p><code class="codeph">NVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4373 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4373 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code> character set to and from national character set happens in OCI
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4387" headers="d59478e4326 ">
                                    <p><code class="codeph">NVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4387 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4387 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code> character set to and from national character set happens in OCI
                                    </p>
                                    <p>National character set to and from database character set in database server</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4403" headers="d59478e4326 ">
                                    <p><code class="codeph">UVARCHAR</code> or <code class="codeph">utext</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4403 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4403 d59478e4332 ">
                                    <p>UTF-16 to and from the national character set happens in OCI</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4418" headers="d59478e4326 ">
                                    <p><code class="codeph">UVARCHAR</code> or <code class="codeph">utext</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4418 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4418 d59478e4332 ">
                                    <p>UTF-16 to and from national character set happens in OCI</p>
                                    <p>National character set to database character set happens in database server</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="NLSPG357"></a><div class="props_rev_3"><a id="GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52" name="GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52"></a><h4 id="NLSPG-GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52" class="sect4"><span class="enumeration_section">7.4.2 </span>Using the VARCHAR Data Type in Pro*C/C++
                  </h4>
                  <div>
                     <div class="section">
                        <p>The Pro*C/C++ <code class="codeph">VARCHAR</code> data type is <a id="d59478e4512" class="indexterm-anchor"></a><a id="d59478e4516" class="indexterm-anchor"></a>preprocessed to a struct with a <code class="codeph">length</code> field and <code class="codeph">text</code> buffer field. The following example uses the C/C++ <code class="codeph">text</code> native data type and the <code class="codeph">VARCHAR</code> Pro*C/C++ data types to bind and define table columns. 
                        </p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; 
main() 
{ 
   ... 
   /* Change to STRING datatype:    */ 
   EXEC ORACLE OPTION (CHAR_MAP=STRING) ; 
   text ename[20] ;          /* unsigned short type */ 
   varchar address[50] ;     /* Pro*C/C++ varchar type */ 

   EXEC SQL SELECT ename, address INTO :ename, :address FROM emp; 
   /* ename is NULL-terminated */ 
   printf(L"ENAME = %s, ADDRESS = %.*s\n", ename, address.len, address.arr); 
   ... 
} 
</pre><p>When you use the <code class="codeph">VARCHAR</code> data type or native <code class="codeph">text</code> data type in a Pro*C/C++ program, the preprocessor assumes that the program intends to access columns of SQL <code class="codeph">CHAR</code> data types instead of SQL <code class="codeph">NCHAR</code> data types in the database. The preprocessor generates C/C++ code to reflect this fact by doing a bind or define using the <code class="codeph">SQLCS_IMPLICIT</code> value for the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute. As a result, if a bind or define variable is bound to a column of SQL <code class="codeph">NCHAR</code> data types in the database, then implicit conversion occurs in the database server to convert the data from the database character set to the national database character set and vice versa. During the conversion, data loss occurs when the database character set is a smaller set than the national character set. 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG358"></a><div class="props_rev_3"><a id="GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E" name="GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E"></a><h4 id="NLSPG-GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E" class="sect4"><span class="enumeration_section">7.4.3 </span>Using the NVARCHAR Data Type in Pro*C/C++
                  </h4>
                  <div>
                     <p>The <a id="d59478e4635" class="indexterm-anchor"></a><a id="d59478e4639" class="indexterm-anchor"></a>Pro*C/C++ <code class="codeph">NVARCHAR</code> data type is similar to the Pro*C/C++ <code class="codeph">VARCHAR</code> data type. It should be used to access SQL <code class="codeph">NCHAR</code> data types in the database. It tells Pro*C/C++ preprocessor to bind or define a text buffer to the column of SQL <code class="codeph">NCHAR</code> data types. The preprocessor specifies the <code class="codeph">SQLCS_NCHAR</code> value for the <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute of the bind or define variable. As a result, no implicit conversion occurs in the database. 
                     </p>
                     <p>If the <code class="codeph">NVARCHAR</code> buffer is bound against columns of SQL <code class="codeph">CHAR</code> data types, then the data in the <code class="codeph">NVARCHAR</code> buffer (encoded in the <code class="codeph">NLS_LANG</code> character set) is converted to or from the national character set in OCI, and the data is then converted to the database character set in the database server. Data can be lost when the <code class="codeph">NLS_LANG</code> character set is a larger set than the database character set. 
                     </p>
                  </div>
               </div><a id="NLSPG359"></a><div class="props_rev_3"><a id="GUID-386C60EE-7DAA-47DC-91C8-6905F5255733" name="GUID-386C60EE-7DAA-47DC-91C8-6905F5255733"></a><h4 id="NLSPG-GUID-386C60EE-7DAA-47DC-91C8-6905F5255733" class="sect4"><span class="enumeration_section">7.4.4 </span>Using the UVARCHAR Data Type in Pro*C/C++
                  </h4>
                  <div>
                     <p>The <code class="codeph">UVARCHAR</code> data type is preprocessed to a struct with a <code class="codeph">length</code> field and <code class="codeph">utext</code> buffer field. The following example code contains two host variables, <code class="codeph">ename</code> and <code class="codeph">address</code>. The <code class="codeph">ename</code> host variable is declared as a <code class="codeph">utext</code> buffer containing 20 Unicode characters. The <code class="codeph">address</code> host variable is declared as a <code class="codeph">uvarchar</code> buffer containing 50 Unicode characters. The <code class="codeph">len</code> and <code class="codeph">arr</code> fields are accessible as fields of a struct. 
                     </p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; 
#include &lt;sqlucs2.h&gt; 

main() 
{ 
   ... 
   /* Change to STRING datatype */ 
   EXEC ORACLE OPTION (CHAR_MAP=STRING); 
   utext ename[20];          /* unsigned short type */ 
   uvarchar address[50];     /* Pro*C/C++ uvarchar type */ 

   EXEC SQL SELECT ename, address INTO :ename, :address FROM emp; 

   /* ename is NULL-terminated */ 
   wprintf(L"ENAME = %s, ADDRESS = %.*s\n", ename, address.len, address.arr); 
   ... 
} 
</pre><p>When you use the <code class="codeph">UVARCHAR</code> data type or native <code class="codeph">utext</code> data type in Pro*C/C++ programs, the preprocessor assumes that the program intends to access SQL <code class="codeph">NCHAR</code> data types. The preprocessor generates C/C++ code by binding or defining using the <code class="codeph">SQLCS_NCHAR</code> value for <code class="codeph">OCI_ATTR_CHARSET_FORM</code> attribute. As a result, if a bind or define variable is bound to a column of a SQL <code class="codeph">NCHAR</code> data type, then an implicit conversion of the data from the national character set occurs in the database server. However, there is no data lost in this scenario because the national character set is always a larger set than the database character set.
                     </p>
                  </div>
               </div>
            </div><a id="NLSPG0076"></a><div class="props_rev_3"><a id="GUID-39A80CED-25E1-416B-8723-267A504599C0" name="GUID-39A80CED-25E1-416B-8723-267A504599C0"></a><h3 id="NLSPG-GUID-39A80CED-25E1-416B-8723-267A504599C0" class="sect3"><span class="enumeration_section">7.5 </span>JDBC Programming with Unicode
               </h3>
               <div>
                  <p>Oracle provides the following <a id="d59478e4885" class="indexterm-anchor"></a><a id="d59478e4889" class="indexterm-anchor"></a>JDBC drivers for Java programs to access character data in an Oracle database: 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The JDBC OCI driver</p>
                     </li>
                     <li>
                        <p>The JDBC thin driver</p>
                     </li>
                     <li>
                        <p>The JDBC server-side internal driver</p>
                     </li>
                     <li>
                        <p>The JDBC server-side thin driver</p>
                     </li>
                  </ul>
                  <p>Java programs can insert or retrieve character data to and from columns of SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types. Specifically, JDBC enables Java programs to bind or define Java strings to SQL <code class="codeph">CHAR</code> and <code class="codeph">NCHAR</code> data types. Because Java's <code class="codeph">string</code> data type is UTF-16 encoded, data retrieved from or inserted into the database must be converted from UTF-16 to the database character set or the national character set and vice versa. JDBC also enables you to specify the PL/SQL and SQL statements in Java strings so that any non-ASCII schema object names and string literals can be used. 
                  </p>
                  <p>At database connection time, JDBC sets the server <code class="codeph">NLS_LANGUAGE</code> and <code class="codeph">NLS_TERRITORY</code> parameters to correspond to the locale of the Java VM that runs the JDBC driver. This operation ensures that the server and the Java client communicate in the same language. As a result, Oracle error messages returned from the server are in the same language as the client locale.
                  </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-76F911E3-904B-4DE4-92DD-8935EBED166D">Binding and Defining Java Strings to SQL CHAR Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38">Binding and Defining Java Strings to SQL NCHAR Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-1C0A42B0-11F8-405B-98A9-18804C681B88">Using the SQL NCHAR Data Types Without Changing the Code</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497">Using SQL NCHAR String Literals in JDBC</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">Data Conversion in JDBC</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786">Using oracle.sql.CHAR in Oracle Object Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C">Restrictions on Accessing SQL CHAR Data with JDBC</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG360"></a><div class="props_rev_3"><a id="GUID-76F911E3-904B-4DE4-92DD-8935EBED166D" name="GUID-76F911E3-904B-4DE4-92DD-8935EBED166D"></a><h4 id="NLSPG-GUID-76F911E3-904B-4DE4-92DD-8935EBED166D" class="sect4"><span class="enumeration_section">7.5.1 </span>Binding and Defining Java Strings to SQL CHAR Data Types
                  </h4>
                  <div>
                     <p>Oracle JDBC <a id="d59478e5044" class="indexterm-anchor"></a><a id="d59478e5048" class="indexterm-anchor"></a>  drivers allow you to access SQL <code class="codeph">CHAR</code> data types in the database using Java string bind or define variables. The following code illustrates how to bind a Java string to a <code class="codeph">CHAR</code> column.
                     </p><pre class="oac_no_warn" dir="ltr">int employee_id = 12345;
String last_name = "Joe";
PreparedStatement pstmt = conn.prepareStatement("INSERT INTO" +
    "employees (last_name, employee_id) VALUES (?, ?)");
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                   /* execute to insert into first row */
employee_id += 1;                  /* next employee number */
last_name = "\uFF2A\uFF4F\uFF45";  /* Unicode characters in name */
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                   /* execute to insert into second row */
</pre><p>You can define the target SQL columns by specifying their data types and lengths. When you define a SQL <code class="codeph">CHAR</code> column with the data type and the length, JDBC uses this information to optimize the performance of fetching SQL <code class="codeph">CHAR</code> data from the column. The following is an example of defining a SQL <code class="codeph">CHAR</code> column.
                     </p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement pstmt = (OraclePreparedStatement)
     conn.prepareStatement("SELECT ename, empno from emp");
pstmt.defineColumnType(1,Types.VARCHAR, 3);
pstmt.defineColumnType(2,Types.INTEGER);
ResultSet rest = pstmt.executeQuery();
String name = rset.getString(1);
int id = reset.getInt(2);
</pre><p>You must cast <code class="codeph">PreparedStatement</code> to <code class="codeph">OraclePreparedStatement</code> to call <code class="codeph">defineColumnType()</code>. The second parameter of <code class="codeph">defineColumnType()</code> is the data type of the target SQL column. The third parameter is the length in number of characters.
                     </p>
                  </div>
               </div><a id="NLSPG361"></a><div class="props_rev_3"><a id="GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38" name="GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38"></a><h4 id="NLSPG-GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38" class="sect4"><span class="enumeration_section">7.5.2 </span>Binding and Defining Java Strings to SQL NCHAR Data Types
                  </h4>
                  <div>
                     <p>For binding or defining Java string variables to SQL <code class="codeph">NCHAR</code> data types, Oracle provides an extended <code class="codeph">PreparedStatement</code> which has the <code class="codeph">setFormOfUse()</code> method through which you can explicitly specify the target column of a bind variable to be a SQL <code class="codeph">NCHAR</code> data type. The following code illustrates how to bind a Java string to an <code class="codeph">NCHAR</code> column.
                     </p><pre class="oac_no_warn" dir="ltr">int employee_id = 12345;
String last_name = "Joe"
oracle.jdbc.OraclePreparedStatement pstmt =
    (oracle.jdbc.OraclePreparedStatement)
    conn.prepareStatement("INSERT INTO employees (last_name, employee_id) 
    VALUES (?, ?)");
pstmt.setFormOfUse(1, oracle.jdbc.OraclePreparedStatement.FORM_NCHAR);
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                  /* execute to insert into first row */
employee_id += 1;                 /* next employee number */
last_name = "\uFF2A\uFF4F\uFF45"; /* Unicode characters in name */
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                  /* execute to insert into second row */
</pre><p>You can define the target SQL <code class="codeph">NCHAR</code> columns by specifying their data types, forms of use, and lengths. JDBC uses this information to optimize the performance of fetching SQL <code class="codeph">NCHAR</code> data from these columns. The following is an example of defining a SQL <code class="codeph">NCHAR</code> column.
                     </p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement pstmt = (OraclePreparedStatement)
           conn.prepareStatement("SELECT ename, empno from emp");
pstmt.defineColumnType(1,Types.VARCHAR, 3, 
                       OraclePreparedStatement.FORM_NCHAR);
pstmt.defineColumnType(2,Types.INTEGER);
ResultSet rest = pstmt.executeQuery();
String name = rset.getString(1);
int id = reset.getInt(2);
</pre><p>To define a SQL <code class="codeph">NCHAR</code> column, you must specify the data type that is equivalent to a SQL <code class="codeph">CHAR</code> column in the first argument, the length in number of characters in the second argument, and the form of use in the fourth argument of <code class="codeph">defineColumnType()</code>.
                     </p>
                     <p>You can bind or define a Java string against an <code class="codeph">NCHAR</code> column without explicitly specifying the form of use argument. This implies the following: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If you do not specify the argument in the <code class="codeph">setString()</code> method, then JDBC assumes that the bind or define variable is for the SQL <code class="codeph">CHAR</code> column. As a result, it tries to convert them to the database character set. When the data gets to the database, the database implicitly converts the data in the database character set to the national character set. During this conversion, data can be lost when the database character set is a subset of the national character set. Because the national character set is either UTF8 or AL16UTF16, data loss would happen if the database character set is not UTF8 or AL32UTF8. 
                           </p>
                        </li>
                        <li>
                           <p>Because implicit conversion from SQL <code class="codeph">CHAR</code> to SQL <code class="codeph">NCHAR</code> data types happens in the database, database performance is degraded.
                           </p>
                        </li>
                     </ul>
                     <p>In addition, if you bind or define a Java string for a column of SQL <code class="codeph">CHAR</code> data types but specify the form of use argument, then performance of the database is degraded. However, data should not be lost because the national character set is always a larger set than the database character set. 
                     </p>
                  </div><a id="NLSPG978"></a><div class="props_rev_3"><a id="GUID-389D66B5-0693-41E9-848D-2842E84EE315" name="GUID-389D66B5-0693-41E9-848D-2842E84EE315"></a><h5 id="NLSPG-GUID-389D66B5-0693-41E9-848D-2842E84EE315" class="sect5"><span class="enumeration_section">7.5.2.1 </span>New JDBC4.0 Methods for NCHAR Data Types
                     </h5>
                     <div>
                        <p>JDBC 11.1 adds support for the new JDBC 4.0 (JDK6) SQL data types <code class="codeph">NCHAR</code>, <code class="codeph">NVARCHAR</code>, <code class="codeph">LONGNVARCHAR</code>, and <code class="codeph">NCLOB</code>. To retrieve a national character value, an application can call one of the following methods:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">getNString</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">getNClob</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">getNCharacterStream</code></p>
                           </li>
                        </ul>
                        <p>The <code class="codeph">getNClob</code> method verifies that the retrieved value is indeed an <code class="codeph">NCLOB</code>. Otherwise, these methods are equivalent to corresponding methods without the letter <code class="codeph">N</code>.
                        </p>
                        <p>To specify a value for a parameter marker of national character type, an application can call one of the following methods:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">setNString</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setNCharacterStream</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setNClob</code></p>
                           </li>
                        </ul>
                        <p>These methods are equivalent to corresponding methods without the letter <code class="codeph">N</code> preceded by a call to <code class="codeph">setFormOfUse(..., OraclePreparedStatement.FORM_NCHAR)</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-389D66B5-0693-41E9-848D-2842E84EE315__GUID-E69E9B6F-D2F1-4154-AC80-9E9D8DE935D4">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/globalization-support.html#JJDBC28647" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for more information
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="NLSPG362"></a><div class="props_rev_3"><a id="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88" name="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88"></a><h4 id="NLSPG-GUID-1C0A42B0-11F8-405B-98A9-18804C681B88" class="sect4"><span class="enumeration_section">7.5.3 </span>Using the SQL NCHAR Data Types Without Changing the Code
                  </h4>
                  <div>
                     <p>A Java system property has been introduced in the Oracle JDBC drivers for customers to tell whether the form of use argument should be specified by default in a Java application. This property has the following purposes:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Existing applications accessing the SQL <code class="codeph">CHAR</code> data types can be migrated to support the SQL <code class="codeph">NCHAR</code> data types for worldwide deployment without changing a line of code.
                           </p>
                        </li>
                        <li>
                           <p>Applications do not need to call the <code class="codeph">setFormOfUse()</code> method when binding and defining a SQL <code class="codeph">NCHAR</code> column. The application code can be made neutral and independent of the data types being used in the back-end database. With this property set, applications can be easily switched from using SQL <code class="codeph">CHAR</code> or SQL <code class="codeph">NCHAR</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The Java system property is specified in the command line that invokes the Java application. The syntax of specifying this flag is as follows:</p><pre class="oac_no_warn" dir="ltr">java -Doracle.jdbc.defaultNChar=true &lt;application class&gt;
</pre><p>With this property specified, the Oracle JDBC drivers assume the presence of the form of use argument for all bind and define operations in the application.</p>
                     <p>If you have a database schema that consists of both the SQL <code class="codeph">CHAR</code> and SQL <code class="codeph">NCHAR</code> columns, then using this flag may have some performance impact when accessing the SQL <code class="codeph">CHAR</code> columns because of implicit conversion done in the database server.
                     </p>
                     <div class="infoboxnotealso" id="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88__GUID-4FB1CC94-2C35-4D23-87E1-1773F402D47A">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">Data Conversion in JDBC</a>"</span> for more information about the performance impact of implicit conversion
                        </p>
                     </div>
                  </div>
               </div><a id="NLSPG363"></a><div class="props_rev_3"><a id="GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497" name="GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497"></a><h4 id="NLSPG-GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497" class="sect4"><span class="enumeration_section">7.5.4 </span>Using SQL NCHAR String Literals in JDBC
                  </h4>
                  <div>
                     <p>When using <code class="codeph">NCHAR</code> string literals in JDBC, there is a potential for data loss because characters are converted to the database character set before processing. See <span class="q">"<a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR String Literal Replacement</a>"</span> for more details.
                     </p>
                     <p>The desired behavior for preserving the <code class="codeph">NCHAR</code> string literals can be achieved by enabling the property set <code class="codeph">oracle.jdbc.convertNcharLiterals</code>. If the value is true, then this option is enabled; otherwise, it is disabled. The default setting is false. It can be enabled in two ways: a) as a Java system property or b) as a connection property. Once enabled, conversion is performed on all SQL in the VM (system property) or in the connection (connection property). For example, the property can be set as a Java system property as follows:
                     </p><pre class="oac_no_warn" dir="ltr">java -Doracle.jdbc.convertNcharLiterals="true" ...
</pre><p>Alternatively, you can set this as a connection property as follows:</p><pre class="oac_no_warn" dir="ltr">Properties props = new Properties();
...
props.setProperty("oracle.jdbc.convertNcharLiterals", "true");
Connection conn = DriverManager.getConnection(url, props);
</pre><p>If you set this as a connection property, it overrides a system property setting.</p>
                  </div>
               </div><a id="NLSPG364"></a><div class="props_rev_3"><a id="GUID-AA384DD0-E46C-477E-826F-F43A099BD651" name="GUID-AA384DD0-E46C-477E-826F-F43A099BD651"></a><h4 id="NLSPG-GUID-AA384DD0-E46C-477E-826F-F43A099BD651" class="sect4"><span class="enumeration_section">7.5.5 </span>Data Conversion in JDBC
                  </h4>
                  <div>
                     <p>Because <a id="d59478e5668" class="indexterm-anchor"></a><a id="d59478e5672" class="indexterm-anchor"></a><a id="d59478e5676" class="indexterm-anchor"></a>Java strings are always encoded in UTF-16, JDBC drivers transparently convert data from the database character set to UTF-16 or the national character set. The conversion paths taken are different for the JDBC drivers: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-51032586-15D4-41F1-9BDA-3559C54A8E32">Data Conversion for the OCI Driver</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A">Data Conversion for Thin Drivers</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47">Data Conversion for the Server-Side Internal Driver</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG811"></a><a id="NLSPG365"></a><div class="props_rev_3"><a id="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32" name="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32"></a><h5 id="NLSPG-GUID-51032586-15D4-41F1-9BDA-3559C54A8E32" class="sect5"><span class="enumeration_section">7.5.5.1 </span>Data Conversion for the OCI Driver
                     </h5>
                     <div>
                        <p>For the OCI driver, the SQL statements are always converted to the database character set by the driver before it is sent to the database for processing. When the database character set is neither US7ASCII nor WE8ISO8859P1, the driver converts the SQL statements to UTF-8 first in Java and then to the database character set in C. Otherwise, it converts the SQL statements directly to the database character set. For Java string bind variables, The following table summarizes the conversion paths taken for different scenarios. For Java string define variables, the same conversion paths, but in the opposite direction, are taken.</p>
                        <div class="tblformalwide" id="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32__G1010302">
                           <p class="titleintable">Table 7-5 OCI Driver Conversion Path</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OCI Driver Conversion Path" summary="This table summarizes OCI driver conversion paths for various types of SQL statements." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e5789">Form of Use</th>
                                    <th align="left" valign="bottom" id="d59478e5792">SQL Data Type</th>
                                    <th align="left" valign="bottom" id="d59478e5795">Conversion Path</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5800" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5800 d59478e5792 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5800 d59478e5795 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the JDBC driver.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5812" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5812 d59478e5792 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5812 d59478e5795 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the JDBC driver. Then, conversion between the database character set and the national character set happens in the database server.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5824" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5824 d59478e5792 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5824 d59478e5795 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the JDBC driver.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5836" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5836 d59478e5792 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5836 d59478e5795 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the JDBC driver. Then, conversion between the national character set and the database character set happens in the database server.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG812"></a><a id="NLSPG366"></a><div class="props_rev_3"><a id="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A" name="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A"></a><h5 id="NLSPG-GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A" class="sect5"><span class="enumeration_section">7.5.5.2 </span>Data Conversion for Thin Drivers
                     </h5>
                     <div>
                        <p>SQL statements are always converted to either the database character set or to UTF-8 by the driver before they are sent to the database for processing. The driver converts the SQL statement to the database character set when the database character set is one of the following character sets:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>US7ASCII</p>
                           </li>
                           <li>
                              <p>WE8ISO8859P1</p>
                           </li>
                           <li>
                              <p>WE8DEC</p>
                           </li>
                           <li>
                              <p>WE8MSWIN1252</p>
                           </li>
                        </ul>
                        <p>Otherwise, the driver converts the SQL statement to UTF-8 and notifies the database that the statement requires further conversion before being processed. The database, in turn, converts the SQL statement to the database character set. For Java string bind variables, the conversion paths shown in the following table are taken for the thin driver. For Java string define variables, the same conversion paths but in the opposite direction are taken. The four character sets listed earlier are called <span class="bold">selected</span> <span class="bold">characters</span> <span class="bold">sets</span> in the table.
                        </p>
                        <div class="tblformalwide" id="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A__G1010326">
                           <p class="titleintable">Table 7-6 Thin Driver Conversion Path </p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Thin Driver Conversion Path " summary="This table describes the conversion path for thin drivers. " width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e5964">Form of Use</th>
                                    <th align="left" valign="bottom" id="d59478e5967">SQL Data Type</th>
                                    <th align="left" valign="bottom" id="d59478e5970">Database Character Set</th>
                                    <th align="left" valign="bottom" id="d59478e5973">Conversion Path</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5978" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5970 ">
                                       <p>One of the selected character sets</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the thin driver.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5993" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5970 ">
                                       <p>One of the selected character sets</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the thin driver. Then, conversion between the database character set and the national character set happens in the database server.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6008" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5970 ">
                                       <p>Other than the selected character sets</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and UTF-8 happens in the thin driver. Then, conversion between UTF-8 and the database character set happens in the database server.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6023" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR (Default)</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5970 ">
                                       <p>Other than the selected character sets</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and UTF-8 happens in the thin driver. Then, conversion from UTF-8 to the database character set and then to the national character set happens in the database server.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6038" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5970 ">
                                       <p>Any</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the thin driver. Then, conversion between the national character set and the database character set happens in the database server.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6053" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5970 ">
                                       <p>Any</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5973 ">
                                       <p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the thin driver.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG367"></a><div class="props_rev_3"><a id="GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47" name="GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47"></a><h5 id="NLSPG-GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47" class="sect5"><span class="enumeration_section">7.5.5.3 </span>Data Conversion for the Server-Side Internal Driver
                     </h5>
                     <div>
                        <p>All data conversion occurs in the database server because the server-side internal driver works inside the database.</p>
                     </div>
                  </div>
               </div><a id="NLSPG368"></a><div class="props_rev_3"><a id="GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786" name="GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786"></a><h4 id="NLSPG-GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786" class="sect4"><span class="enumeration_section">7.5.6 </span>Using oracle.sql.CHAR in Oracle Object Types
                  </h4>
                  <div>
                     <p>JDBC drivers support Oracle object types. Oracle objects are always sent from database to client as an object represented in the database character set or national character set. That means the data conversion path in <span class="q">"<a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">Data Conversion in JDBC</a>"</span> does not apply to Oracle object access. Instead, the <code class="codeph">oracle.sql.CHAR</code> class is used for passing SQL <code class="codeph">CHAR</code> and SQL <code class="codeph">NCHAR</code> data of an object type from the database to the client.
                     </p>
                     <p>This section includes the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C">oracle.sql.CHAR</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD">Accessing SQL CHAR and NCHAR Attributes with oracle.sql.CHAR</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG369"></a><div class="props_rev_3"><a id="GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C" name="GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C"></a><h5 id="NLSPG-GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C" class="sect5"><span class="enumeration_section">7.5.6.1 </span>oracle.sql.CHAR
                     </h5>
                     <div>
                        <p>The <code class="codeph">oracle.sql.CHAR</code> class has a special functionality for conversion of character data. The Oracle character set is a key attribute of the <code class="codeph">oracle.sql.CHAR</code> class. The Oracle character set is always passed in when an <code class="codeph">oracle.sql.CHAR</code> object is constructed. Without a known character set, the bytes of data in the <code class="codeph">oracle.sql.CHAR</code> object are meaningless.
                        </p>
                        <p>The <code class="codeph">oracle.sql.CHAR</code> class provides the following methods for converting character data to strings:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">getString()</code></p>
                              <p>Converts the sequence of characters represented by the <code class="codeph">oracle.sql.CHAR</code> object to a string, returning a Java string object. If the character set is not recognized, then <code class="codeph">getString()</code> returns a <code class="codeph">SQLException</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">toString()</code></p>
                              <p>Identical to <code class="codeph">getString()</code>, except that if the character set is not recognized, then <code class="codeph">toString()</code> returns a hexadecimal representation of the <code class="codeph">oracle.sql.CHAR</code> data and does not returns a <code class="codeph">SQLException</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getStringWithReplacement()</code></p>
                              <p>Identical to <code class="codeph">getString()</code>, except that a default replacement character replaces characters that have no Unicode representation in the character set of this <code class="codeph">oracle.sql.CHAR</code> object. This default character varies among character sets, but it is often a question mark.
                              </p>
                           </li>
                        </ul>
                        <p>You may want to construct an <code class="codeph">oracle.sql.CHAR</code> object yourself (to pass into a prepared statement, for example). When you construct an <code class="codeph">oracle.sql.CHAR</code> object, you must provide character set information to the <code class="codeph">oracle.sql.CHAR</code> object by using an instance of the <code class="codeph">oracle.sql.CharacterSet</code> class. Each instance of the <code class="codeph">oracle.sql.CharacterSet</code> class represents one of the character sets that Oracle supports. 
                        </p>
                        <p>Complete the following tasks to construct an <code class="codeph">oracle.sql.CHAR</code> object: 
                        </p>
                        <ol>
                           <li>
                              <p>Create a <code class="codeph">CharacterSet</code> instance by calling the static <code class="codeph">CharacterSet.make()</code> method. This method creates the character set class. It requires as input a valid Oracle character set (<code class="codeph">OracleId)</code>. For example: 
                              </p><pre class="oac_no_warn" dir="ltr">int OracleId = CharacterSet.JA16SJIS_CHARSET; // this is character set 832
...
CharacterSet mycharset = CharacterSet.make(OracleId);
</pre><p>Each character set that Oracle supports has a unique predefined <code class="codeph">OracleId</code>. The <code class="codeph">OracleId</code> can always be referenced as a character set specified as <span class="italic"><code class="codeph">Oracle_character_set_name</code></span><code class="codeph">_CHARSET</code> where <span class="italic"><code class="codeph">Oracle_character_set_name</code></span> is the Oracle character set. 
                              </p>
                           </li>
                           <li>
                              <p>Construct an <code class="codeph">oracle.sql.CHAR</code> object. Pass to the constructor a string (or the bytes that represent the string) and the <code class="codeph">CharacterSet</code> object that indicates how to interpret the bytes based on the character set. For example:
                              </p><pre class="oac_no_warn" dir="ltr">String mystring = "teststring";
...
oracle.sql.CHAR mychar = new oracle.sql.CHAR(teststring, mycharset);
</pre><p>The <code class="codeph">oracle.sql.CHAR</code> class has multiple constructors: they can take a string, a byte array, or an object as input along with the <code class="codeph">CharacterSet</code> object. In the case of a string, the string is converted to the character set indicated by the <code class="codeph">CharacterSet</code> object before being placed into the <code class="codeph">oracle.sql.CHAR</code> object.
                              </p>
                           </li>
                        </ol>
                        <p>The server (database) and the client (or application running on the client) can use different character sets. When you use the methods of this class to transfer data between the server and the client, the JDBC drivers must convert the data between the server character set and the client character set.</p>
                     </div>
                  </div><a id="NLSPG370"></a><div class="props_rev_3"><a id="GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD" name="GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD"></a><h5 id="NLSPG-GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD" class="sect5"><span class="enumeration_section">7.5.6.2 </span>Accessing SQL CHAR and NCHAR Attributes with oracle.sql.CHAR
                     </h5>
                     <div>
                        <p>The following is an example of an object type created using SQL:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT (
   name VARCHAR2(30), address NVARCHAR2(256), age NUMBER);
CREATE TABLE employees (id NUMBER, person PERSON_TYPE);
</pre><p>The Java class corresponding to this object type can be constructed as follows:</p><pre class="oac_no_warn" dir="ltr">public class person implement SqlData  
{
   oracle.sql.CHAR name;
   oracle.sql.CHAR address;
   oracle.sql.NUMBER age;
   // SqlData interfaces
   getSqlType() {...}
   writeSql(SqlOutput stream) {...}
   readSql(SqlInput stream, String sqltype) {...}
}
</pre><p>The <code class="codeph">oracle.sql.CHAR</code> class is used here to map to the <code class="codeph">NAME</code> attributes of the Oracle object type, which is of <code class="codeph">VARCHAR2</code> data type. JDBC populates this class with the byte representation of the <code class="codeph">VARCHAR2</code> data in the database and the <code class="codeph">CharacterSet</code> object corresponding to the database character set. The following code retrieves a <code class="codeph">person</code> object from the <code class="codeph">employees</code> table:
                        </p><pre class="oac_no_warn" dir="ltr">TypeMap map = ((OracleConnection)conn).getTypeMap();
map.put("PERSON_TYPE", Class.forName("person"));
conn.setTypeMap(map);
    .       .        .
    .       .        .
ResultSet rs = stmt.executeQuery("SELECT PERSON FROM EMPLOYEES");
rs.next();
person p = (person) rs.getObject(1);
oracle.sql.CHAR sql_name = p.name;
oracle.sql.CHAR sql_address=p.address;
String java_name = sql_name.getString();
String java_address = sql_address.getString();
</pre><p>The <code class="codeph">getString()</code> method of the <code class="codeph">oracle.sql.CHAR</code> class converts the byte array from the database character set or national character set to UTF-16 by calling Oracle's Java data conversion classes and returning a Java string. For the <code class="codeph">rs.getObject(1)</code> call to work, the <code class="codeph">SqlData</code> interface has to be implemented in the class <code class="codeph">person</code>, and the <code class="codeph">Typemap</code> <code class="codeph">map</code> has to be set up to indicate the mapping of the object type <code class="codeph">PERSON_TYPE</code> to the Java class.
                        </p>
                     </div>
                  </div>
               </div><a id="NLSPG371"></a><div class="props_rev_3"><a id="GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C" name="GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C"></a><h4 id="NLSPG-GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C" class="sect4"><span class="enumeration_section">7.5.7 </span>Restrictions on Accessing SQL CHAR Data with JDBC
                  </h4>
                  <div>
                     <p>This section contains the following topic:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-80320823-4869-4584-8426-3B1C7BCD669A">Character Integrity Issues in a Multibyte Database Environment</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG813"></a><a id="NLSPG372"></a><div class="props_rev_3"><a id="GUID-80320823-4869-4584-8426-3B1C7BCD669A" name="GUID-80320823-4869-4584-8426-3B1C7BCD669A"></a><h5 id="NLSPG-GUID-80320823-4869-4584-8426-3B1C7BCD669A" class="sect5"><span class="enumeration_section">7.5.7.1 </span>Character Integrity Issues in a Multibyte Database Environment
                     </h5>
                     <div>
                        <p>Oracle JDBC drivers perform character set conversions as appropriate when character data is inserted into or retrieved from the database. The drivers convert Unicode characters used by Java clients to Oracle database character set characters, and vice versa. Character data that makes a round trip from the Java Unicode character set to the database character set and back to Java can suffer some loss of information. This happens when multiple Unicode characters are mapped to a single character in the database character set. An example is the Unicode full-width tilde character (0xFF5E) and its mapping to Oracle's JA16SJIS character set. The round-trip conversion for this Unicode character results in the Unicode character 0x301C, which is a <a id="d59478e6751" class="indexterm-anchor"></a><a id="d59478e6753" class="indexterm-anchor"></a>wave dash (a character commonly used in Japan to indicate range), not a tilde.
                        </p>
                        <p>The following figure shows the round-trip conversion of the tilde character.</p>
                        <div class="figure" id="GUID-80320823-4869-4584-8426-3B1C7BCD669A__I1008863">
                           <p class="titleinfigure">Figure 7-2 Character Integrity</p><img src="img/nlspg015.gif" alt="Description of Figure 7-2 follows" title="Description of Figure 7-2 follows" longdesc="img_text/nlspg015.html"><br><a href="img_text/nlspg015.html">Description of "Figure 7-2 Character Integrity"</a></div>
                        <!-- class="figure" -->
                        <p>This issue is not a bug in Oracle's JDBC. It is an unfortunate side effect of the ambiguity in character mapping specifications on different operating systems. Fortunately, this problem affects only a small number of characters in a small number of Oracle character sets such as JA16SJIS, JA16EUC, ZHT16BIG5, and KO16KS5601. The workaround is to avoid making a full round-trip with these characters. </p>
                     </div>
                  </div>
               </div>
            </div><a id="NLSPG0077"></a><div class="props_rev_3"><a id="GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE" name="GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE"></a><h3 id="NLSPG-GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE" class="sect3"><span class="enumeration_section">7.6 </span>ODBC and OLE DB Programming with Unicode
               </h3>
               <div>
                  <p>You should <a id="d59478e6840" class="indexterm-anchor"></a>use the Oracle ODBC driver or Oracle Provider for OLE DB to access the Oracle server when using a Windows platform. This section describes how these drivers support Unicode. It includes the following topics:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B">Unicode-Enabled Drivers in ODBC and OLE DB</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-67C78306-3FE9-4391-BAB4-F073325E424F">OCI Dependency in Unicode</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-635555B8-B4F2-4675-95F4-DBEEC3614675">ODBC and OLE DB Code Conversion in Unicode</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294">ODBC Unicode Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E">OLE DB Unicode Data Types</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-737B1514-13C8-41AE-8243-2831B556AD64">ADO Access</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG373"></a><div class="props_rev_3"><a id="GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B" name="GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B"></a><h4 id="NLSPG-GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B" class="sect4"><span class="enumeration_section">7.6.1 </span>Unicode-Enabled Drivers in ODBC and OLE DB
                  </h4>
                  <div>
                     <p>Oracle's ODBC driver and Oracle Provider for OLE DB can handle Unicode data properly without data loss. For example, you can run a Unicode ODBC application containing Japanese data on English Windows if you install Japanese fonts and an input method editor for entering Japanese characters.</p>
                     <p>Oracle provides ODBC and OLE DB products for Windows platforms only. For UNIX platforms, contact your vendor.</p>
                  </div>
               </div><a id="NLSPG374"></a><div class="props_rev_3"><a id="GUID-67C78306-3FE9-4391-BAB4-F073325E424F" name="GUID-67C78306-3FE9-4391-BAB4-F073325E424F"></a><h4 id="NLSPG-GUID-67C78306-3FE9-4391-BAB4-F073325E424F" class="sect4"><span class="enumeration_section">7.6.2 </span>OCI Dependency in Unicode
                  </h4>
                  <div>
                     <p>OCI Unicode binding and defining features are used by the ODBC and OLE DB drivers to handle Unicode data. OCI Unicode data binding and defining features are independent from <code class="codeph">NLS_LANG</code>. This means Unicode data is handled properly, irrespective of the <code class="codeph">NLS_LANG</code> setting on the platform.
                     </p>
                     <div class="infoboxnotealso" id="GUID-67C78306-3FE9-4391-BAB4-F073325E424F__GUID-6B30F08B-B962-4D73-8579-B7845BF097B0">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">OCI Programming with Unicode</a>"</span></p>
                     </div>
                  </div>
               </div><a id="NLSPG814"></a><a id="NLSPG375"></a><div class="props_rev_3"><a id="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675" name="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675"></a><h4 id="NLSPG-GUID-635555B8-B4F2-4675-95F4-DBEEC3614675" class="sect4"><span class="enumeration_section">7.6.3 </span>ODBC and OLE DB Code Conversion in Unicode
                  </h4>
                  <div>
                     <p>In general, no redundant <a id="d59478e7114" class="indexterm-anchor"></a>data conversion occurs unless you specify a different client data type from that of the server. If you bind Unicode buffer <code class="codeph">SQL_C_WCHAR</code> with a Unicode data column like <code class="codeph">NCHAR</code>, for example, then ODBC and OLE DB drivers bypass it between the application and OCI layer.
                     </p>
                     <p>If you do not specify data types before fetching, but call <code class="codeph">SQLGetData</code> with the client data types instead, then the conversions described in the following table occur.
                     </p>
                     <div class="tblformalwide" id="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675__G1010369">
                        <p class="titleintable">Table 7-7 ODBC Implicit Binding Code Conversions </p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="ODBC Implicit Binding Code Conversions " summary="This table describes conversions that occur when you do not specify data types before fetching, but call SQLGetData with client data types." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7142">Data Types of ODBC Client Buffer</th>
                                 <th align="left" valign="bottom" id="d59478e7145">Data Types of the Target Column in the Database</th>
                                 <th align="left" valign="bottom" id="d59478e7148">Fetch Conversions</th>
                                 <th align="left" valign="bottom" id="d59478e7151">Comments</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7156" headers="d59478e7142 ">
                                    <p><code class="codeph">SQL_C_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7145 ">
                                    <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7148 ">
                                    <p>If the database character set is a subset of the <code class="codeph">NLS_LANG</code> character set, then the conversions occur in the following order:
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Database character set</p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NLS_LANG</code></p>
                                       </li>
                                       <li>
                                          <p>UTF-16 in OCI</p>
                                       </li>
                                       <li>
                                          <p>UTF-16 in ODBC</p>
                                       </li>
                                    </ul>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7151 ">
                                    <p>No unexpected data loss</p>
                                    <p>May degrade performance if database character set is a subset of the <code class="codeph">NLS_LANG</code> character set
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7196" headers="d59478e7142 ">
                                    <p><code class="codeph">SQL_C_CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7145 ">
                                    <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7148 ">
                                    <p>If database character set is a subset of <code class="codeph">NLS_LANG</code> character set:
                                    </p>
                                    <p>Database character set to <code class="codeph">NLS_LANG</code> in OCI
                                    </p>
                                    <p>If database character set is NOT a subset of <code class="codeph">NLS_LANG</code> character set:
                                    </p>
                                    <p>Database character set, UTF-16, to <code class="codeph">NLS_LANG</code> character set in OCI and ODBC
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7151 ">
                                    <p>No unexpected data loss</p>
                                    <p>May degrade performance if database character set is not a subset of <code class="codeph">NLS_LANG</code> character set
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>You must specify the data type for inserting and updating operations.</p>
                     <p>The data type of the ODBC client buffer is given when you call <code class="codeph">SQLGetData</code> but not immediately. Hence, <code class="codeph">SQLFetch</code> does not have the information.
                     </p>
                     <p>Because the ODBC driver guarantees data integrity, if you perform implicit bindings, then redundant conversion may result in performance degradation. Your choice is the trade-off between performance with explicit binding or usability with implicit binding.</p>
                  </div><a id="NLSPG815"></a><a id="NLSPG376"></a><div class="props_rev_3"><a id="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0" name="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0"></a><h5 id="NLSPG-GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0" class="sect5"><span class="enumeration_section">7.6.3.1 </span>OLE DB Code Conversions
                     </h5>
                     <div>
                        <p>Unlike ODBC, OLE DB only enables you to perform implicit bindings for inserting, updating, and fetching data. The conversion algorithm for determining the intermediate character set is the same as the implicit binding cases of ODBC.</p>
                        <div class="tblformalwide" id="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0__GUID-416EC808-D122-4B71-8B72-64709760C4FD">
                           <p class="titleintable">Table 7-8 OLE DB Implicit Bindings</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OLE DB Implicit Bindings" summary="This table describes implicit bindings for OLE DB code conversions." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e7335">Data Types of OLE_DB Client Buffer</th>
                                    <th align="left" valign="bottom" id="d59478e7338">Data Types of the Target Column in the Database</th>
                                    <th align="left" valign="bottom" id="d59478e7341">In-Binding and Out-Binding Conversions</th>
                                    <th align="left" valign="bottom" id="d59478e7344">Comments</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e7349" headers="d59478e7335 ">
                                       <p><code class="codeph">DBTYPE_WCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7338 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7341 ">
                                       <p>If database character set is a subset of the <code class="codeph">NLS_LANG</code> character set:
                                       </p>
                                       <p>Database character set to and from <code class="codeph">NLS_LANG</code> character set in OCI. <code class="codeph">NLS_LANG</code> character set to UTF-16 in OLE DB
                                       </p>
                                       <p>If database character set is NOT a subset of <code class="codeph">NLS_LANG</code> character set:
                                       </p>
                                       <p>Database character set to and from UTF-16 in OCI</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7344 ">
                                       <p>No unexpected data loss</p>
                                       <p>May degrade performance if database character set is a subset of <code class="codeph">NLS_LANG</code> character set
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e7390" headers="d59478e7335 ">
                                       <p><code class="codeph">DBTYPE_CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7338 ">
                                       <p><code class="codeph">CHAR,VARCHAR2,</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7341 ">
                                       <p>If database character set is a subset of the <code class="codeph">NLS_LANG</code> character set:
                                       </p>
                                       <p>Database character set to and from <code class="codeph">NLS_LANG</code> in OCI
                                       </p>
                                       <p>If database character set is not a subset of <code class="codeph">NLS_LANG</code> character set:
                                       </p>
                                       <p>Database character set to and from UTF-16 in OCI. UTF-16 to <code class="codeph">NLS_LANG</code> character set in OLE DB
                                       </p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7344 ">
                                       <p>No unexpected data loss</p>
                                       <p>May degrade performance if database character set is not a subset of <code class="codeph">NLS_LANG</code> character set
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="NLSPG816"></a><a id="NLSPG377"></a><div class="props_rev_3"><a id="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294" name="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294"></a><h4 id="NLSPG-GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294" class="sect4"><span class="enumeration_section">7.6.4 </span>ODBC Unicode Data Types
                  </h4>
                  <div>
                     <p>In <a id="d59478e7505" class="indexterm-anchor"></a>ODBC Unicode applications, use <code class="codeph">SQLWCHAR</code> to store Unicode data. All standard Windows Unicode functions can be used for <code class="codeph">SQLWCHAR</code> data manipulations. For example, <code class="codeph">wcslen</code> counts the number of characters of <code class="codeph">SQLWCHAR</code> data:
                     </p><pre class="oac_no_warn" dir="ltr">SQLWCHAR sqlStmt[] = L"select ename from emp";
len = wcslen(sqlStmt);
</pre><p>Microsoft's ODBC 3.5 specification defines three Unicode data type identifiers for the <code class="codeph">SQL_C_WCHAR</code>, <code class="codeph">SQL_C_WVARCHAR</code>, and <code class="codeph">SQL_WLONGVARCHAR</code> clients; and three Unicode data type identifiers for servers <code class="codeph">SQL_WCHAR</code>, <code class="codeph">SQL_WVARCHAR</code>, and <code class="codeph">SQL_WLONGVARCHAR</code>.
                     </p>
                     <p>For binding operations, specify data types for both client and server using <code class="codeph">SQLBindParameter</code>. The following is an example of Unicode binding, where the client buffer <code class="codeph">Name</code> indicates that Unicode data (<code class="codeph">SQL_C_WCHAR</code>) is bound to the first bind variable associated with the Unicode column (<code class="codeph">SQL_WCHAR</code>):
                     </p><pre class="oac_no_warn" dir="ltr">SQLBindParameter(StatementHandle, 1, SQL_PARAM_INPUT, SQL_C_WCHAR,
SQL_WCHAR, NameLen, 0, (SQLPOINTER)Name, 0, &amp;Name);
</pre><p>The following table represents the data type mappings of the ODBC Unicode data types for the server against SQL <code class="codeph">NCHAR</code> data types.
                     </p>
                     <div class="tblformal" id="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294__G1010407">
                        <p class="titleintable">Table 7-9 Server ODBC Unicode Data Type Mapping</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Server ODBC Unicode Data Type Mapping" summary="This table describes data type mappings of the ODBC Unicode data types for the server against SQL NCHAR data types." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7574">ODBC Data Type</th>
                                 <th align="left" valign="bottom" id="d59478e7577">Oracle Data Type</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7582" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7582 d59478e7577 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7591" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7591 d59478e7577 ">
                                    <p><code class="codeph">NVARCHAR2</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7600" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WLONGVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7600 d59478e7577 ">
                                    <p><code class="codeph">NCLOB</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>According to ODBC specifications, <code class="codeph">SQL_WCHAR</code>, <code class="codeph">SQL_WVARCHAR</code>, and <code class="codeph">SQL_WLONGVARCHAR</code> are treated as Unicode data, and are therefore measured in the number of characters instead of the number of bytes.
                     </p>
                  </div>
               </div><a id="NLSPG817"></a><a id="NLSPG378"></a><div class="props_rev_3"><a id="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E" name="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E"></a><h4 id="NLSPG-GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E" class="sect4"><span class="enumeration_section">7.6.5 </span>OLE DB Unicode Data Types
                  </h4>
                  <div>
                     <p><a id="d59478e7693" class="indexterm-anchor"></a>OLE DB offers the <code class="codeph">wchar_t</code>, <code class="codeph">BSTR</code>, and <code class="codeph">OLESTR</code> data types for a Unicode C client. In practice, <code class="codeph">wchar_t</code> is the most common data type and the others are for specific purposes. The following example assigns a static SQL statement:
                     </p><pre class="oac_no_warn" dir="ltr">wchar_t *sqlStmt = OLESTR("SELECT ename FROM emp");
</pre><p>The <code class="codeph">OLESTR</code> macro works exactly like an "L" modifier to indicate the Unicode string. If you need to allocate Unicode data buffer dynamically using <code class="codeph">OLESTR</code>, then use the <code class="codeph">IMalloc</code> allocator (for example, <code class="codeph">CoTaskMemAlloc</code>). However, using <code class="codeph">OLESTR</code> is not the normal method for variable length data; use <code class="codeph">wchar_t</code>* instead for generic string types. <code class="codeph">BSTR</code> is similar. It is a string with a length prefix in the memory location preceding the string. Some functions and methods can accept only <code class="codeph">BSTR</code> Unicode data types. Therefore, <code class="codeph">BSTR</code> Unicode string must be manipulated with special functions like <code class="codeph">SysAllocString</code> for allocation and <code class="codeph">SysFreeString</code> for freeing memory. 
                     </p>
                     <p>Unlike ODBC, OLE DB does not allow you to specify the server data type explicitly. When you set the client data type, the OLE DB driver automatically performs data conversion if necessary.</p>
                     <p>The following table shows the OLE DB data type mapping.</p>
                     <div class="tblformal" id="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E__G1010423">
                        <p class="titleintable">Table 7-10 OLE DB Data Type Mapping</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="OLE DB Data Type Mapping" summary="This table OLE DB data type to Oracle data type mapping." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7760">OLE DB Data Type</th>
                                 <th align="left" valign="bottom" id="d59478e7763">Oracle Data Type</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7768" headers="d59478e7760 ">
                                    <p><code class="codeph">DBTYPE_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7768 d59478e7763 ">
                                    <p><code class="codeph">NCHAR or NVARCHAR2</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>If <code class="codeph">DBTYPE_BSTR</code> is specified, then it is assumed to be <code class="codeph">DBTYPE_WCHAR</code> because both are Unicode strings.
                     </p>
                  </div>
               </div><a id="NLSPG379"></a><div class="props_rev_3"><a id="GUID-737B1514-13C8-41AE-8243-2831B556AD64" name="GUID-737B1514-13C8-41AE-8243-2831B556AD64"></a><h4 id="NLSPG-GUID-737B1514-13C8-41AE-8243-2831B556AD64" class="sect4"><span class="enumeration_section">7.6.6 </span>ADO Access
                  </h4>
                  <div>
                     <p>ADO <a id="d59478e7859" class="indexterm-anchor"></a>is a high-level API to access database with the OLE DB and ODBC drivers. Most database application developers use the ADO interface on Windows because it is easily accessible from Visual Basic, the primary scripting language for Active Server Pages (ASP) for the Internet Information Server (IIS). To OLE DB and ODBC drivers, ADO is simply an OLE DB consumer or ODBC application. ADO assumes that OLE DB and ODBC drivers are Unicode-aware components; hence, it always attempts to manipulate Unicode data.
                     </p>
                  </div>
               </div>
            </div><a id="NLSPG0078"></a><div class="props_rev_3"><a id="GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA" name="GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA"></a><h3 id="NLSPG-GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA" class="sect3"><span class="enumeration_section">7.7 </span>XML Programming with Unicode
               </h3>
               <div>
                  <p> XML support of Unicode is essential for software development for global markets so that text information can be exchanged in any language. Unicode uniformly supports almost every character and language, which makes it much easier to support multiple languages within XML. To enable Unicode for XML within an Oracle database, the character set of the database must be UTF-8. By enabling Unicode text handling in your application, you acquire a basis for supporting any language. Every XML document is Unicode text and potentially multilingual, unless it is guaranteed that only a known subset of Unicode characters will appear on your documents. Thus Oracle recommends that you enable Unicode for XML. Unicode support comes with Java and many other modern programming environments.</p>
                  <p>This section includes the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD">Writing an XML File in Unicode with Java</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312">Reading an XML File in Unicode with Java</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33">Parsing an XML Stream in Unicode with Java</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG380"></a><div class="props_rev_3"><a id="GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD" name="GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD"></a><h4 id="NLSPG-GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD" class="sect4"><span class="enumeration_section">7.7.1 </span>Writing an XML File in Unicode with Java
                  </h4>
                  <div>
                     <p>A common mistake in reading and writing XML files is using the <code class="codeph">Reader</code> and <code class="codeph">Writer</code> classes for character input and output. Using <code class="codeph">Reader</code> and <code class="codeph">Writer</code> for XML files should be avoided because it requires character set conversion based on the default character encoding of the run-time environment.
                     </p>
                     <p>For example, using <code class="codeph">FileWriter</code> class is not safe because it converts the document to the default character encoding. The output file can suffer from a parsing error or data loss if the document contains characters that are not available in the default character encoding.
                     </p>
                     <p>UTF-8 is popular for XML documents, but UTF-8 is not usually the default file encoding for Java. Thus using a Java class that assumes the default file encoding can cause problems.</p>
                     <p>The following example shows how to avoid these problems:</p><pre class="oac_no_warn" dir="ltr">import java.io.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLFileWritingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create a test document
    XMLDocument doc = new XMLDocument();
    doc.setVersion( "1.0" );
    doc.appendChild(doc.createComment( "This is a test empty document." ));
    doc.appendChild(doc.createElement( "root" ));
    
    // create a file
    File file = new File( "myfile.xml" );

    // create a binary output stream to write to the file just created
    FileOutputStream fos = new FileOutputStream( file );

    // create a Writer that converts Java character stream to UTF-8 stream
    OutputStreamWriter osw = new OutputStreamWriter( fos, "UTF8" );

    // buffering for efficiency
    Writer w = new BufferedWriter( osw );

    // create a PrintWriter to adapt to the printing method
    PrintWriter out = new PrintWriter( w );

    // print the document to the file through the connected objects
    doc.print( out ); 
  }
}</pre></div>
               </div><a id="NLSPG381"></a><div class="props_rev_3"><a id="GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312" name="GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312"></a><h4 id="NLSPG-GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312" class="sect4"><span class="enumeration_section">7.7.2 </span>Reading an XML File in Unicode with Java
                  </h4>
                  <div>
                     <p>Do not read XML files as text input. When reading an XML document stored in a file system, use the parser to automatically detect the character encoding of the document. Avoid using a <code class="codeph">Reader</code> class or specifying a character encoding on the input stream. Given a binary input stream with no external encoding information, the parser automatically figures out the character encoding based on the byte order mark and encoding declaration of the XML document. Any well-formed document in any supported encoding can be successfully parsed using the following sample code: 
                     </p><pre class="oac_no_warn" dir="ltr">import java.io.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLFileReadingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create an instance of the xml file
    File file = new File( "myfile.xml" );

    // create a binary input stream
    FileInputStream fis = new FileInputStream( file );

    // buffering for efficiency
    BufferedInputStream in = new BufferedInputStream( fis );

    // get an instance of the parser
    DOMParser parser = new DOMParser();

    // parse the xml file
    parser.parse( in );
  }
}</pre></div>
               </div><a id="NLSPG382"></a><div class="props_rev_3"><a id="GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33" name="GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33"></a><h4 id="NLSPG-GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33" class="sect4"><span class="enumeration_section">7.7.3 </span>Parsing an XML Stream in Unicode with Java
                  </h4>
                  <div>
                     <p>When the source of an XML document is not a file system, the encoding information is usually available before reading the document. For example, if the input document is provided in the form of a Java character stream or Reader, its encoding is evident and no detection should take place. The parser can begin parsing a Reader in Unicode without regard to the character encoding. </p>
                     <p>The following is an example of parsing a document with external encoding information:</p><pre class="oac_no_warn" dir="ltr">import java.io.*;
import java.net.*;
import org.xml.sax.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLStreamReadingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create an instance of the xml file
    URL url = new URL( "http://myhost/mydocument.xml" );

    // create a connection to the xml document    
    URLConnection conn = url.openConnection();

    // get an input stream
    InputStream is = conn.getInputStream();

    // buffering for efficiency
    BufferedInputStream bis = new BufferedInputStream( is );

    /* figure out the character encoding here                              */
    /* a typical source of encoding information is the content-type header */
    /* we assume it is found to be utf-8 in this example                   */
    String charset = "utf-8";

    // create an InputSource for UTF-8 stream
    InputSource in = new InputSource( bis );
    in.setEncoding( charset );
    
    // get an instance of the parser
    DOMParser parser = new DOMParser();

    // parse the xml stream
    parser.parse( in );  
  }
}</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>