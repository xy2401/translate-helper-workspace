<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>SQL for Pattern Matching</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="sql-aggregation-data-warehouses.html" title="Previous" type="text/html">
      <link rel="next" href="sql-modeling-data-warehouses.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-aggregation-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="sql-modeling-data-warehouses.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">Relational Analytics </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> SQL for Pattern Matching </li>
            </ol>
            <a id="GUID-136DAC89-DA17-45C6-9E37-C9892723AC79" name="GUID-136DAC89-DA17-45C6-9E37-C9892723AC79"></a><a id="DWHSG8956"></a>
            
            <h2 id="DWHSG-GUID-136DAC89-DA17-45C6-9E37-C9892723AC79" class="sect2"><span class="enumeration_chapter">21 </span> SQL for Pattern Matching 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Recognizing <a id="d80268e20" class="indexterm-anchor"></a><a id="d80268e22" class="indexterm-anchor"></a><a id="d80268e26" class="indexterm-anchor"></a>patterns in a sequence of rows has been a capability that was widely desired, but not possible with SQL until now. There were many workarounds, but these were difficult to write, hard to understand, and inefficient to execute. Beginning in Oracle Database 12<span class="italic">c</span>, you can use the <code class="codeph">MATCH_RECOGNIZE</code> clause to achieve this capability in native SQL that executes efficiently. This chapter discusses how to do this, and includes the following sections:
               </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6">Overview of Pattern Matching in Data Warehouses</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323">Basic Topics in Pattern Matching</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117">Pattern Matching Details</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-F120C679-9C56-4703-970E-07C276EA50F1">Advanced Topics in Pattern Matching</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6">Rules and Restrictions in Pattern Matching</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75">Examples of Pattern Matching</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8958"></a><a id="DWHSG8957"></a><div class="props_rev_3"><a id="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6" name="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6"></a><h3 id="DWHSG-GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6" class="sect3"><span class="enumeration_section">21.1 </span>Overview of Pattern Matching in Data Warehouses
               </h3>
               <div>
                  <p>Pattern matching in SQL is performed using the <code class="codeph">MATCH_RECOGNIZE</code> clause. <code class="codeph">MATCH_RECOGNIZE</code> enables you to do the following tasks:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Logically partition and order the data that is used in the <code class="codeph">MATCH_RECOGNIZE</code> clause with its <code class="codeph">PARTITION</code> <code class="codeph">BY</code> and <code class="codeph">ORDER</code> <code class="codeph">BY</code> clauses.
                        </p>
                     </li>
                     <li>
                        <p>Define patterns of rows to seek using the <code class="codeph">PATTERN</code> clause of the <code class="codeph">MATCH_RECOGNIZE</code> clause. These patterns use regular expression syntax, a powerful and expressive feature, applied to the pattern variables you define.
                        </p>
                     </li>
                     <li>
                        <p>Specify the logical conditions required to map a row to a row pattern variable in the <code class="codeph">DEFINE</code> clause.
                        </p>
                     </li>
                     <li>
                        <p>Define measures, which are expressions usable in other parts of the SQL query, in the <code class="codeph">MEASURES</code> clause.
                        </p>
                     </li>
                  </ul>
                  <p>As a simple case of pattern matching, consider the stock price chart illustrated in <a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">Figure 21-1</a>.
                  </p>
                  <div class="figure" id="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">
                     <p class="titleinfigure">Figure 21-1 Stock Chart</p><img src="img/dwhsg140.png" alt="Description of Figure 21-1 follows" title="Description of Figure 21-1 follows" longdesc="img_text/dwhsg140.html"><br><a href="img_text/dwhsg140.html">Description of "Figure 21-1 Stock Chart"</a></div>
                  <!-- class="figure" -->
                  <p>Pattern matching can let you identify price patterns, such as V-shapes and W-shapes illustrated in <a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">Figure 21-1</a>, along with performing many types of calculations. For example, your calculations might include the count of observations or the average value on a downward or upward slope.
                  </p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69">Why Use Pattern Matching?</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E">How Data is Processed in Pattern Matching</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D">About Pattern Matching Special Capabilities</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8960"></a><a id="DWHSG8961"></a><a id="DWHSG8962"></a><a id="DWHSG8959"></a><div class="props_rev_3"><a id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69" name="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69"></a><h4 id="DWHSG-GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69" class="sect4"><span class="enumeration_section">21.1.1 </span>Why Use Pattern Matching?
                  </h4>
                  <div>
                     <p>The ability to recognize patterns found across multiple rows is important for many kinds of work. Examples include all kinds of business processes driven by sequences of events, such as security applications, where unusual behavior must be detected, and financial applications, where you seek patterns of pricing, trading volume, and other behavior. Other common uses are fraud detection applications and sensor data analysis. One term that describes this general area is complex event processing, and pattern matching is a powerful aid to this activity.</p>
                     <p>Now consider the query in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a>. It uses the stock price shown in <a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">Figure 21-1</a>, which you can load into your database with the <code class="codeph">CREATE</code> and <code class="codeph">INSERT</code> statements that follow. The query finds all cases where stock prices dipped to a bottom price and then rose. This is generally called a V-shape. Before studying the query, look at the output. There are only three rows because the code was written to report just one row per match, and three matches were found. The <code class="codeph">MATCH_RECOGNIZE</code> clause lets you choose between showing one row per match and all rows per match. In this example, the shorter output of one row per match is used.
                     </p>
                     <div class="example" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">
                        <p class="titleinexample">Example 21-1 Pattern Match: Simple V-Shape with 1 Row Output per Match</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Ticker (SYMBOL VARCHAR2(10), tstamp DATE, price NUMBER);
 
INSERT INTO Ticker VALUES('ACME', '01-Apr-11', 12);
INSERT INTO Ticker VALUES('ACME', '02-Apr-11', 17);
INSERT INTO Ticker VALUES('ACME', '03-Apr-11', 19);
INSERT INTO Ticker VALUES('ACME', '04-Apr-11', 21);
INSERT INTO Ticker VALUES('ACME', '05-Apr-11', 25);
INSERT INTO Ticker VALUES('ACME', '06-Apr-11', 12);
INSERT INTO Ticker VALUES('ACME', '07-Apr-11', 15);
INSERT INTO Ticker VALUES('ACME', '08-Apr-11', 20);
INSERT INTO Ticker VALUES('ACME', '09-Apr-11', 24);
INSERT INTO Ticker VALUES('ACME', '10-Apr-11', 25);
INSERT INTO Ticker VALUES('ACME', '11-Apr-11', 19);
INSERT INTO Ticker VALUES('ACME', '12-Apr-11', 15);
INSERT INTO Ticker VALUES('ACME', '13-Apr-11', 25);
INSERT INTO Ticker VALUES('ACME', '14-Apr-11', 25);
INSERT INTO Ticker VALUES('ACME', '15-Apr-11', 14);
INSERT INTO Ticker VALUES('ACME', '16-Apr-11', 12);
INSERT INTO Ticker VALUES('ACME', '17-Apr-11', 14);
INSERT INTO Ticker VALUES('ACME', '18-Apr-11', 24);
INSERT INTO Ticker VALUES('ACME', '19-Apr-11', 23);
INSERT INTO Ticker VALUES('ACME', '20-Apr-11', 22);

SELECT *
FROM Ticker MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES  STRT.tstamp AS start_tstamp,
               LAST(DOWN.tstamp) AS bottom_tstamp,
               LAST(UP.tstamp) AS end_tstamp
     ONE ROW PER MATCH
     AFTER MATCH SKIP TO LAST UP
     PATTERN (STRT DOWN+ UP+)
     DEFINE
        DOWN AS DOWN.price &lt; PREV(DOWN.price),
        UP AS UP.price &gt; PREV(UP.price)
     ) MR
ORDER BY MR.symbol, MR.start_tstamp;

SYMBOL     START_TST BOTTOM_TS END_TSTAM
---------- --------- --------- ---------
ACME       05-APR-11 06-APR-11 10-APR-11
ACME       10-APR-11 12-APR-11 13-APR-11
ACME       14-APR-11 16-APR-11 18-APR-11
 </pre><p>What does this query do? The following explains each line in the <code class="codeph">MATCH_RECOGNIZE</code> clause:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">PARTITION</code> <code class="codeph">BY</code> divides the data from the <code class="codeph">Ticker</code> table into logical groups where each group contains one stock symbol.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ORDER</code> <code class="codeph">BY</code> orders the data within each logical group by <code class="codeph">tstamp</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">MEASURES</code> defines three measures: the timestamp at the beginning of a V-shape (<code class="codeph">start_tstamp</code>), the timestamp at the bottom of a V-shape (<code class="codeph">bottom_tstamp</code>), and the timestamp at the end of the a V-shape (<code class="codeph">end_tstamp</code>). The <code class="codeph">bottom_tstamp</code> and <code class="codeph">end_tstamp</code> measures use the <code class="codeph">LAST()</code> function to ensure that the values retrieved are the final value of the timestamp within each pattern match.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> means that for every pattern match found, there will be one row of output.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code> means that whenever you find a match you restart your search at the row that is the last row of the <code class="codeph">UP</code> pattern variable. A pattern variable is a variable used in a <code class="codeph">MATCH_RECOGNIZE</code> statement, and is defined in the <code class="codeph">DEFINE</code> clause.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PATTERN (STRT DOWN+ UP+)</code> says that the pattern you are searching for has three pattern variables: <code class="codeph">STRT</code>, <code class="codeph">DOWN</code>, and <code class="codeph">UP</code>. The plus sign (<code class="codeph">+</code>) after <code class="codeph">DOWN</code> and <code class="codeph">UP</code> means that at least one row must be mapped to each of them. The pattern defines a regular expression, which is a highly expressive way to search for patterns.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">DEFINE</code> gives us the conditions that must be met for a row to map to your row pattern variables <code class="codeph">STRT</code>, <code class="codeph">DOWN</code>, and <code class="codeph">UP</code>. Because there is no condition for <code class="codeph">STRT</code>, any row can be mapped to <code class="codeph">STRT</code>. Why have a pattern variable with no condition? You use it as a starting point for testing for matches. Both <code class="codeph">DOWN</code> and <code class="codeph">UP</code> take advantage of the <code class="codeph">PREV()</code> function, which lets them compare the price in the current row to the price in the prior row. <code class="codeph">DOWN</code> is matched when a row has a lower price than the row that preceded it, so it defines the downward (left) leg of our V-shape. A row can be mapped to <code class="codeph">UP</code> if the row has a higher price than the row that preceded it.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <p>The following two figures will help you better understand the results returned by <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a>. <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a> shows the dates mapped to specific pattern variables, as specified in the <code class="codeph">PATTERN</code> clause. After the mappings of pattern variables to dates are available, that information is used by the <code class="codeph">MEASURES</code> clause to calculate the measure values. The measures results are shown in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">Figure 21-3</a>.
                     </p>
                     <div class="figure" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">
                        <p class="titleinfigure">Figure 21-2 Stock Chart Illustrating Which Dates are Mapped to Which Pattern Variables</p><img src="img/dwhsg143.png" alt="Description of Figure 21-2 follows" title="Description of Figure 21-2 follows" longdesc="img_text/dwhsg143.html"><br><a href="img_text/dwhsg143.html">Description of "Figure 21-2 Stock Chart Illustrating Which Dates are Mapped to Which Pattern Variables"</a></div>
                     <!-- class="figure" -->
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a> labels every date mapped to a pattern variable. The mapping is based on the pattern specified in the <code class="codeph">PATTERN</code> clause and the logical conditions specified in the <code class="codeph">DEFINE</code> clause. The thin vertical lines show the borders of the three matches that were found for the pattern. In each match, the first date has the <code class="codeph">STRT</code> pattern variable mapped to it (labeled as <span class="italic">Start</span>), followed by one or more dates mapped to the <code class="codeph">DOWN</code> pattern variable, and finally, one or more dates mapped to the <code class="codeph">UP</code> pattern variable.
                     </p>
                     <p>Because you specified <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code> in the query, two adjacent matches can share a row. That means a single date can have two variables mapped to it. For example, 10-April has both the pattern variables <code class="codeph">UP</code> and <code class="codeph">STRT</code> mapped to it: April 10 is the end of Match 1 and the start of Match 2.
                     </p>
                     <div class="figure" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">
                        <p class="titleinfigure">Figure 21-3 Stock Chart Showing the Dates to Which the Measures Correspond</p><img src="img/dwhsg144.png" alt="Description of Figure 21-3 follows" title="Description of Figure 21-3 follows" longdesc="img_text/dwhsg144.html"><br><a href="img_text/dwhsg144.html">Description of "Figure 21-3 Stock Chart Showing the Dates to Which the Measures Correspond"</a></div>
                     <!-- class="figure" -->
                     <p>In <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">Figure 21-3</a>, the labels are solely for the measures defined in the <code class="codeph">MEASURES</code> clause of the query: <code class="codeph">START</code> (<code class="codeph">start_tstamp</code> in the query), <code class="codeph">BOTTOM</code> (<code class="codeph">bottom_tstamp</code> in the query), and <code class="codeph">END</code> (<code class="codeph">end_tstamp</code> in the query). As in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a>, the thin vertical lines show the borders of the three matches found for the pattern. Every match has a <code class="codeph">Start</code> date, a <code class="codeph">Bottom</code> date, and an <code class="codeph">End</code> date. As with <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a>, the date 10-April is found in two matches: it is the <code class="codeph">END</code> measure for Match 1 and the <code class="codeph">START</code> measure for Match 2. The labeled dates of <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">Figure 21-3</a> show which dates correspond to the measure definitions, which are based on the pattern variable mappings shown in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a>.
                     </p>
                     <p>Note that the dates labeled in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">Figure 21-3</a> correspond to the nine dates shown earlier in the output of the example. The first row of the output has the dates shown in Match 1, the second row of the output has the dates shown in Match 2, and the third row of the output has the dates shown in Match 3.
                     </p>
                  </div>
               </div><a id="DWHSG8963"></a><div class="props_rev_3"><a id="GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E" name="GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E"></a><h4 id="DWHSG-GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E" class="sect4"><span class="enumeration_section">21.1.2 </span>How Data is Processed in Pattern Matching
                  </h4>
                  <div>
                     <p>The <code class="codeph">MATCH_RECOGNIZE</code> clause performs these steps:
                     </p>
                     <ol>
                        <li>
                           <p>The row pattern input table is partitioned according to the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause. Each partition consists of the set of rows of the input table that have the same value on the partitioning columns.
                           </p>
                        </li>
                        <li>
                           <p>Each row pattern partition is ordered according to the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.
                           </p>
                        </li>
                        <li>
                           <p>Each ordered row pattern partition is searched for matches to the <code class="codeph">PATTERN</code>.
                           </p>
                        </li>
                        <li>
                           <p>Pattern matching operates by seeking the match at the earliest row, considering the rows in a row pattern partition in the order specified by the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause.
                           </p>
                           <p>Pattern matching in a sequence of rows is an incremental process, with one row after another examined to see if it fits the pattern. With this incremental processing model, at any step until the complete pattern is recognized, you only have a partial match, and you do not know what rows might be added in the future, nor to what variables those future rows might be mapped.</p>
                           <p>If no match is found at the earliest row, the search moves to the next row in the partition, checking if a match can be found starting with that row.</p>
                        </li>
                        <li>
                           <p>After a match is found, row pattern matching calculates the row pattern measure columns, which are expressions defined by the <code class="codeph">MEASURES</code> clause.
                           </p>
                        </li>
                        <li>
                           <p>Using <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, as shown in the first example, pattern matching generates one row for each match that is found. If you use <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, every row that is matched is included in the pattern match output.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> clause determines where row pattern matching resumes within a row pattern partition after a non-empty match is found. In the previous example, row pattern matching resumes at the last row of the match found (<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code>).
                           </p>
                        </li>
                     </ol>
                  </div>
               </div><a id="DWHSG8964"></a><div class="props_rev_3"><a id="GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D" name="GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D"></a><h4 id="DWHSG-GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D" class="sect4"><span class="enumeration_section">21.1.3 </span>About Pattern Matching Special Capabilities
                  </h4>
                  <div>
                     <p>The capabilities are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Regular expressions are a robust and long-established way for systems to search for patterns in data. The regular expression features of the language Perl were adopted as the design target for pattern matching rules, and Oracle Database 12<span class="italic">c</span> Release 1, implements a subset of those rules for pattern matching.
                           </p>
                        </li>
                        <li>
                           <p>Oracle's regular expressions differ from typical regular expressions in that the row pattern variables are defined by Boolean conditions rather than characters or sets of characters.</p>
                        </li>
                        <li>
                           <p>While pattern matching uses the notation of regular expressions to express patterns, it is actually a richer capability, because the pattern variables may be defined to depend upon the way previous rows were mapped to row pattern variables. The <code class="codeph">DEFINE</code> clause enables pattern variables to be built upon other pattern variables.
                           </p>
                        </li>
                        <li>
                           <p>Subqueries are permitted in the definition of row pattern variables and the definition of measures.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8965"></a><div class="props_rev_3"><a id="GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323" name="GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323"></a><h3 id="DWHSG-GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323" class="sect3"><span class="enumeration_section">21.2 </span>Basic Topics in Pattern Matching
               </h3>
               <div>
                  <p>This section discusses:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B">Basic Examples of Pattern Matching</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48">Tasks and Keywords in Pattern Matching</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4">Pattern Matching Syntax</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8967"></a><a id="DWHSG8968"></a><a id="DWHSG8969"></a><a id="DWHSG8966"></a><div class="props_rev_3"><a id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B" name="GUID-8EB29CC4-77D4-4375-A323-74910D66564B"></a><h4 id="DWHSG-GUID-8EB29CC4-77D4-4375-A323-74910D66564B" class="sect4"><span class="enumeration_section">21.2.1 </span>Basic Examples of Pattern Matching
                  </h4>
                  <div>
                     <p>This section includes some basic examples for matching patterns.</p>
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCCGDH">
                        <p class="titleinexample">Example 21-2 Pattern Match for a Simple V-Shape with All Rows Output per Match</p>
                        <p>The first line in this example is to improve formatting if you are using SQL*Plus.</p><pre class="oac_no_warn" dir="ltr">column var_match format a4

SELECT *
FROM Ticker MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES  STRT.tstamp AS start_tstamp,
               FINAL LAST(DOWN.tstamp) AS bottom_tstamp,
               FINAL LAST(UP.tstamp) AS end_tstamp,
               MATCH_NUMBER() AS match_num,
               CLASSIFIER() AS var_match
     ALL ROWS PER MATCH
     AFTER MATCH SKIP TO LAST UP
     PATTERN (STRT DOWN+ UP+)
     DEFINE
        DOWN AS DOWN.price &lt; PREV(DOWN.price),
        UP AS UP.price &gt; PREV(UP.price)
     ) MR
ORDER BY MR.symbol, MR.match_num, MR.tstamp;

SYMBOL     TSTAMP    START_TST BOTTOM_TS END_TSTAM  MATCH_NUM VAR_      PRICE
---------- --------- --------- --------- --------- ---------- ---- ----------
ACME       05-APR-11 05-APR-11 06-APR-11 10-APR-11          1 STRT         25
ACME       06-APR-11 05-APR-11 06-APR-11 10-APR-11          1 DOWN         12
ACME       07-APR-11 05-APR-11 06-APR-11 10-APR-11          1 UP           15
ACME       08-APR-11 05-APR-11 06-APR-11 10-APR-11          1 UP           20
ACME       09-APR-11 05-APR-11 06-APR-11 10-APR-11          1 UP           24
ACME       10-APR-11 05-APR-11 06-APR-11 10-APR-11          1 UP           25
ACME       10-APR-11 10-APR-11 12-APR-11 13-APR-11          2 STRT         25
ACME       11-APR-11 10-APR-11 12-APR-11 13-APR-11          2 DOWN         19
ACME       12-APR-11 10-APR-11 12-APR-11 13-APR-11          2 DOWN         15
ACME       13-APR-11 10-APR-11 12-APR-11 13-APR-11          2 UP           25
ACME       14-APR-11 14-APR-11 16-APR-11 18-APR-11          3 STRT         25
ACME       15-APR-11 14-APR-11 16-APR-11 18-APR-11          3 DOWN         14
ACME       16-APR-11 14-APR-11 16-APR-11 18-APR-11          3 DOWN         12
ACME       17-APR-11 14-APR-11 16-APR-11 18-APR-11          3 UP           14
ACME       18-APR-11 14-APR-11 16-APR-11 18-APR-11          3 UP           24
 
15 rows selected.
</pre><p>What does this query do? It is similar to the query in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a> except for items in the <code class="codeph">MEASURES</code> clause, the change to <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, and a change to the <code class="codeph">ORDER</code> <code class="codeph">BY</code> at the end of the query. In the <code class="codeph">MEASURES</code> clause, there are these additions:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">MATCH_NUMBER()</code> <code class="codeph">AS</code> <code class="codeph">match_num</code></p>
                              <p>Because this example gives multiple rows per match, you need to know which rows are members of which match. <code class="codeph">MATCH_NUMBER</code> assigns the same number to each row of a specific match. For instance, all the rows in the first match found in a row pattern partition are assigned the <code class="codeph">match_num</code> value of 1. Note that match numbering starts over again at 1 in each row pattern partition.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">CLASSIFIER()</code> <code class="codeph">AS</code> <code class="codeph">var_match</code></p>
                              <p>To know which rows map to which variable, use the <code class="codeph">CLASSIFIER</code> function. In this example, some rows will map to the <code class="codeph">STRT</code> variable, some rows the <code class="codeph">DOWN</code> variable, and others to the <code class="codeph">UP</code> variable.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">FINAL</code> <code class="codeph">LAST()</code> 
                              </p>
                              <p>By specifying <code class="codeph">FINAL</code> and using the <code class="codeph">LAST()</code> function for <code class="codeph">bottom_tstamp</code>, every row inside each match shows the same date for the bottom of its V-shape. Likewise, applying <code class="codeph">FINAL</code> <code class="codeph">LAST()</code> to the <code class="codeph">end_tstamp</code> measure makes every row in each match show the same date for the end of its V-shape. Without this syntax, the dates shown would be the running value for each row.
                              </p>
                           </li>
                        </ul>
                        <p>Changes were made in two other lines:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> - While <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a> gave a summary with just 1 row about each match using the line <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, this example asks to show every row of each match.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ORDER</code> <code class="codeph">BY</code> on the last line - This was changed to take advantage of the <code class="codeph">MATCH_NUM</code>, so all rows in the same match are together and in chronological order.
                              </p>
                           </li>
                        </ul>
                        <p>Note that the row for April 10 appears twice because it is in two pattern matches: it is the last day of the first match and the first day of the second match.</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCIFAC">
                        <p class="titleinexample">Example 21-3 Pattern Match with an Aggregate on a Variable</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCIFAC">Example 21-3</a> highlights the use of aggregate functions in pattern matching queries.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM Ticker MATCH_RECOGNIZE (
  PARTITION BY symbol
  ORDER BY tstamp
  MEASURES
    MATCH_NUMBER() AS match_num,
    CLASSIFIER() AS var_match,
    FINAL COUNT(UP.tstamp) AS up_days,
    FINAL COUNT(tstamp) AS total_days,
    RUNNING COUNT(tstamp) AS cnt_days,
    price - STRT.price AS price_dif
  ALL ROWS PER MATCH
  AFTER MATCH SKIP TO LAST UP
  PATTERN (STRT DOWN+ UP+)
  DEFINE
    DOWN AS DOWN.price &lt; PREV(DOWN.price),
    UP AS UP.price &gt; PREV(UP.price)
  ) MR
ORDER BY MR.symbol, MR.match_num, MR.tstamp;
 
SYMBOL TSTAMP    MATCH_NUM VAR_ UP_DAYS TOTAL_DAYS CNT_DAYS PRICE_DIF PRICE
------ --------- --------- ---- ------- ---------- -------- --------- -----
ACME   05-APR-11         1 STRT       4          6        1         0    25
ACME   06-APR-11         1 DOWN       4          6        2       -13    12
ACME   07-APR-11         1 UP         4          6        3       -10    15
ACME   08-APR-11         1 UP         4          6        4        -5    20
ACME   09-APR-11         1 UP         4          6        5        -1    24
ACME   10-APR-11         1 UP         4          6        6         0    25
ACME   10-APR-11         2 STRT       1          4        1         0    25
ACME   11-APR-11         2 DOWN       1          4        2        -6    19
ACME   12-APR-11         2 DOWN       1          4        3       -10    15
ACME   13-APR-11         2 UP         1          4        4         0    25
ACME   14-APR-11         3 STRT       2          5        1         0    25
ACME   15-APR-11         3 DOWN       2          5        2       -11    14
ACME   16-APR-11         3 DOWN       2          5        3       -13    12
ACME   17-APR-11         3 UP         2          5        4       -11    14
ACME   18-APR-11         3 UP         2          5        5        -1    24
 
15 rows selected.
</pre><p>What does this query do? It builds on <a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCCGDH">Example 21-2</a> by adding three measures that use the aggregate function <code class="codeph">COUNT()</code>. It also adds a measure showing how an expression can use a qualified and unqualified column.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <code class="codeph">up_days</code> measure (with <code class="codeph">FINAL</code> <code class="codeph">COUNT</code>) shows the number of days mapped to the <code class="codeph">UP</code> pattern variable within each match. You can verify this by counting the <code class="codeph">UP</code> labels for each match in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">Figure 21-2</a>.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">total_days</code> measure (also with <code class="codeph">FINAL</code> <code class="codeph">COUNT</code>) introduces the use of unqualified columns. Because this measure specified the <code class="codeph">FINAL</code> <code class="codeph">count(tstamp)</code> with no pattern variable to qualify the <code class="codeph">tstamp</code> column, it returns the count of all rows included in a match.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">cnt_days</code> measure introduces the <code class="codeph">RUNNING</code> keyword. This measure gives a running count that helps distinguish among the rows in a match. Note that it also has no pattern variable to qualify the <code class="codeph">tstamp</code> column, so it applies to all rows of a match. You do not need to use the <code class="codeph">RUNNING</code> keyword explicitly in this case because it is the default. See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B">Running Versus Final Semantics and Keywords</a>"</span> for more information.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">price_dif</code> measure shows us each day's difference in stock price from the price at the first day of a match. In the expression "<code class="codeph">price - STRT.price)</code>," you see a case where an unqualified column, "<code class="codeph">price</code>," is used with a qualified column, "<code class="codeph">STRT.price</code>".
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACDGBEA">
                        <p class="titleinexample">Example 21-4 Pattern Match for a W-Shape</p>
                        <p>This example illustrates a W-Shape.</p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM Ticker MATCH_RECOGNIZE (
  PARTITION BY symbol
  ORDER BY tstamp
  MEASURES
    MATCH_NUMBER() AS match_num,
    CLASSIFIER()  AS  var_match, 
    STRT.tstamp AS start_tstamp,
    FINAL LAST(UP.tstamp) AS end_tstamp
  ALL ROWS PER MATCH
  AFTER MATCH SKIP TO LAST UP
  PATTERN (STRT DOWN+ UP+ DOWN+ UP+)
  DEFINE
    DOWN AS DOWN.price &lt; PREV(DOWN.price),
    UP AS UP.price &gt; PREV(UP.price)
  ) MR
ORDER BY MR.symbol, MR.match_num, MR.tstamp;
 
SYMBOL     TSTAMP     MATCH_NUM  VAR_  START_TST  END_TSTAM      PRICE
---------- --------- ----------  ----  ---------  --------- ----------
ACME       05-APR-11          1  STRT  05-APR-11  13-APR-11         25
ACME       06-APR-11          1  DOWN  05-APR-11  13-APR-11         12
ACME       07-APR-11          1  UP    05-APR-11  13-APR-11         15
ACME       08-APR-11          1  UP    05-APR-11  13-APR-11         20
ACME       09-APR-11          1  UP    05-APR-11  13-APR-11         24
ACME       10-APR-11          1  UP    05-APR-11  13-APR-11         25
ACME       11-APR-11          1  DOWN  05-APR-11  13-APR-11         19
ACME       12-APR-11          1  DOWN  05-APR-11  13-APR-11         15
ACME       13-APR-11          1  UP    05-APR-11  13-APR-11         25
</pre><p>What does this query do? It builds on the concepts introduced in <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a> and seeks W-shapes in the data rather than V-shapes. The query results show one W-shape. To find the W-shape, the line defining the <code class="codeph">PATTERN</code> regular expression was modified to seek the pattern <code class="codeph">DOWN</code> followed by <code class="codeph">UP</code> two consecutive times: <code class="codeph">PATTERN</code> <code class="codeph">(STRT DOWN+ UP+ DOWN+ UP+)</code>. This pattern specification means it can only match a W-shape where the two V-shapes have no separation between them. For instance, if there is a flat interval with the price unchanging, and that interval occurs between two V-shapes, the pattern will not match that data. To illustrate the data returned, the output is set to <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>. Note that <code class="codeph">FINAL</code> <code class="codeph">LAST(UP.tstamp)</code> in the <code class="codeph">MEASURES</code> clause returns the timestamp value for the last row mapped to <code class="codeph">UP</code>.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8970"></a><div class="props_rev_3"><a id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48" name="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48"></a><h4 id="DWHSG-GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48" class="sect4"><span class="enumeration_section">21.2.2 </span>Tasks and Keywords in Pattern Matching
                  </h4>
                  <div>
                     <p>This section discus<a id="d80268e1048" class="indexterm-anchor"></a>ses the following tasks and keywords in pattern matching.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-15B5EF24-F543-4439-A6A6-22246AE834E9">PARTITION BY: Logically Dividing the Rows into Groups</p>
                        <p>You will typically want to divide your input data into logical groups for analysis. In the example with stocks, you divide the pattern matching so that it applies to just one stock at a time. You do this with the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> keyword. <code class="codeph">PARTITION</code> <code class="codeph">BY</code> is used to specify that the rows of the row pattern input table are to be partitioned by one or more columns. Matches are found within partitions and do not cross partition boundaries.
                        </p>
                        <p>If there is no <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, then all rows of the row pattern input table constitute a single row pattern partition.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-A36AD094-C8BE-4AEC-B662-F50069283674">ORDER BY: Logically Ordering the Rows in a Partition</p>
                        <p>After you divided your input data into logical partitions, you will want to order the data inside each partition. Without row ordering, you cannot have a reliable sequence to check for pattern matches. The <code class="codeph">ORDER</code> <code class="codeph">BY</code> keyword is used to specify the order of rows within a row pattern partition.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-9D80679D-833F-4926-94DF-6C1EEF22A032">[ONE ROW | ALL ROWS] PER MATCH: Choosing Summaries or Details for Each Match</p>
                        <p>You will sometimes want summary data about the matches and other times need details. You can do that with the following SQL keywords:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                              <p>Each match produces one summary row. This is the default.</p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                              <p>A match spanning multiple rows will produce one output row for each row in the match.</p>
                           </li>
                        </ul>
                        <p>The output is explained in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">Row Pattern Output</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-4F8661E5-A920-49FC-95FB-57A574AEBC47">MEASURES: Defining Calculations for Export from the Pattern Matching</p>
                        <p>The pattern matching clause enables you to create expressions useful in a wide range of analyses. These are presented as columns in the output by using the <code class="codeph">MEASURES</code> clause. The <code class="codeph">MEASURES</code> clause defines row pattern measure columns, whose value is computed by evaluating an expression related to a particular match.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-377262F0-AB19-4CD8-A186-152CE0922431">PATTERN: Defining the Row Pattern That Will be Matched</p>
                        <p>The <code class="codeph">PATTERN</code> clause lets you define which pattern variables must be matched, the sequence in which they must be matched, and the quantity of rows which must be matched. The <code class="codeph">PATTERN</code> clause specifies a regular expression for the match search. 
                        </p>
                        <p>A row pattern match consists of a set of contiguous rows in a row pattern partition. Each row of the match is mapped to a pattern variable. Mapping of rows to pattern variables must conform to the regular expression in the <code class="codeph">PATTERN</code> clause, and all conditions in the <code class="codeph">DEFINE</code> clause must be true.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-7910E083-0636-418C-93F0-861FB0B478D3">DEFINE: Defining Primary Pattern Variables</p>
                        <p>Because the <code class="codeph">PATTERN</code> clause depends on pattern variables, you must have a clause to define these variables. They are specified in the <code class="codeph">DEFINE</code> clause. 
                        </p>
                        <p><code class="codeph">DEFINE</code> is a required clause, used to specify the conditions that a row must meet to be mapped to a specific pattern variable.
                        </p>
                        <p>A pattern variable does not require a definition. Any row can be mapped to an undefined pattern variable.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-9DC05558-50D7-4867-9553-3FCE75235A58">AFTER MATCH SKIP: Restarting the Matching Process After a Match is Found</p>
                        <p>After the query finds a match, it must look for the next match at exactly the correct point. Do you want to find matches where the end of the earlier match overlaps the start of the next match? Do you want some other variation? Pattern matching provides great flexibility in specifying the restart point. The <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> clause determines the point to resume row pattern matching after a non-empty match was found. The default for the clause is <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code>: resume pattern matching at the next row after the last row of the current match.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-3CC279F9-63F2-4092-94BB-D9E03B097787">MATCH_NUMBER: Finding Which Rows are Members of Which Match</p>
                        <p>You might have a large number of matches for your pattern inside a given row partition. How do you tell apart all these matches? This is done with the <code class="codeph">MATCH_NUMBER</code> function. Matches within a row pattern partition are numbered sequentially starting with 1 in the order they are found. Note that match numbering starts over again at 1 in each row pattern partition, because there is no inherent ordering between row pattern partitions.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-B5F70FF5-1022-4C07-9349-516CEE462296">CLASSIFIER: Finding Which Pattern Variable Applies to Which Rows</p>
                        <p>Along with knowing which <code class="codeph">MATCH_NUMBER</code> you are seeing, you may want to know which component of a pattern applies to a specific row. This is done using the <code class="codeph">CLASSIFIER</code> function. The classifier of a row is the pattern variable that the row is mapped to by a row pattern match. The <code class="codeph">CLASSIFIER</code> function returns a character string whose value is the name of the variable the row is mapped to.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8980"></a><div class="props_rev_3"><a id="GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4" name="GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4"></a><h4 id="DWHSG-GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4" class="sect4"><span class="enumeration_section">21.2.3 </span>Pattern Matching Syntax
                  </h4>
                  <div>
                     <div class="section">
                        <p>The pattern matching syntax is as follows:</p><pre class="oac_no_warn" dir="ltr">table_reference ::=
  {only (query_table_expression) | query_table_expression }[flashback_query_clause]
   [pivot_clause|unpivot_clause|row_pattern_recognition_clause] [t_alias]

row_pattern_recognition_clause ::=
  MATCH_RECOGNIZE (
   [row_pattern_partition_by ]
   [row_pattern_order_by ]
   [row_pattern_measures ]
   [row_pattern_rows_per_match ]
   [row_pattern_skip_to ]
   PATTERN (row_pattern)
   [ row_pattern_subset_clause]
   DEFINE row_pattern_definition_list
   )

row_pattern_partition_by ::=
   PARTITION BY column[, column]...

row_pattern_order_by ::=
   ORDER BY column[, column]...

row_pattern_measures ::=
   MEASURES row_pattern_measure_column[, row_pattern_measure_column]...

row_pattern_measure_column ::=
   expression AS c_alias

row_pattern_rows_per_match ::=
   ONE ROW PER MATCH
  | ALL ROWS PER MATCH

row_pattern_skip_to ::=
   AFTER MATCH {
    SKIP TO NEXT ROW
   | SKIP PAST LAST ROW
   | SKIP TO FIRST variable_name
   | SKIP TO LAST variable_name
   | SKIP TO variable_name}

row_pattern ::=
   row_pattern_term
  | row_pattern "|" row_pattern_term

row_pattern_term ::=
   row_pattern_factor
  | row_pattern_term row_pattern_factor

row_pattern_factor ::=
   row_pattern_primary [row_pattern_quantifier]

row_pattern_quantifier ::=
    *[?]
   |+[?]
   |?[?]
   |"{"[unsigned_integer ],[unsigned_integer]"}"[?]
   |"{"unsigned_integer "}"

row_pattern_primary ::=
   variable_name
   |$
   |^
   |([row_pattern])
   |"{-" row_pattern"-}"
   | row_pattern_permute

row_pattern_permute ::=
   PERMUTE (row_pattern [, row_pattern] ...)

row_pattern_subset_clause ::=
   SUBSET row_pattern_subset_item [, row_pattern_subset_item] ...

row_pattern_subset_item ::=
   variable_name = (variable_name[ , variable_name]...)

row_pattern_definition_list ::=
   row_pattern_definition[, row_pattern_definition]...

row_pattern_definition ::=
   variable_name AS condition
</pre><p>The syntax for row pattern operations inside pattern matching is:</p><pre class="oac_no_warn" dir="ltr">function ::=
 single_row_function
| aggregate_function
| analytic_function
| object_reference_function
| model_function
| user_defined_function
| OLAP_function
| data_cartridge_function
| row_pattern_recognition_function
 
row_pattern_recognition_function ::=
 row_pattern_classifier_function
| row_pattern_match_number_function
| row_pattern_navigation_function
| row_pattern_aggregate_function
 
row_pattern_classifier_function ::=
  CLASSIFIER( )
 
row_pattern_match_number_function ::=
  MATCH_NUMBER( )

row_pattern_navigation_function ::=
   row_pattern_navigation_logical
  | row_pattern_navigation_physical
  | row_pattern_navigation_compound

row_pattern_navigation_logical ::=
   [RUNNING|FINAL] {FIRST|LAST} (expression[,offset])

row_pattern_navigation_physical ::=
   {PREV|NEXT}(expression[, offset])

row_pattern_navigation_compound ::=
   {PREV | NEXT} (
     [RUNNING| FINAL] {FIRST|LAST} (expression[, offset]) [,offset])
</pre><p>The syntax for set function specification inside the pattern matching clause is:</p><pre class="oac_no_warn" dir="ltr">row_pattern_aggregate_function ::=
   [RUNNING | FINAL] aggregate_function</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8981"></a><div class="props_rev_3"><a id="GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117" name="GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117"></a><h3 id="DWHSG-GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117" class="sect3"><span class="enumeration_section">21.3 </span>Pattern Matching Details
               </h3>
               <div>
                  <p>This section presents details on the items discussed in <a href="sql-pattern-matching-data-warehouses.html#GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4">Pattern Matching Syntax</a>, plus additional topics. Note that some of the material is unavoidably intricate. Certain aspects of pattern matching require careful attention to subtle details.
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E508A372-0287-4515-859A-74B070A356A5">PARTITION BY: Logically Dividing the Rows into Groups</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E">ORDER BY: Logically Ordering the Rows in a Partition</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-FF7F2D64-503F-411C-9E57-15755441D7A2">[ONE ROW | ALL ROWS] PER MATCH: Choosing Summaries or Details for Each Match</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2">MEASURES: Defining Calculations for Use in the Query</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1">PATTERN: Defining the Row Pattern to Be Matched</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET: Defining Union Row Pattern Variables</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8">DEFINE: Defining Primary Pattern Variables</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8">AFTER MATCH SKIP: Defining Where to Restart the Matching Process After a Match Is Found</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">Expressions in MEASURES and DEFINE</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">Row Pattern Output</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8982"></a><div class="props_rev_3"><a id="GUID-E508A372-0287-4515-859A-74B070A356A5" name="GUID-E508A372-0287-4515-859A-74B070A356A5"></a><h4 id="DWHSG-GUID-E508A372-0287-4515-859A-74B070A356A5" class="sect4"><span class="enumeration_section">21.3.1 </span>PARTITION BY: Logically Dividing the Rows into Groups
                  </h4>
                  <div>
                     <div class="section">
                        <p>Typically, you want to divide your input data into logical groups for analysis. In the examples with stocks, the pattern matching is divided so that it applies to just one stock at a time. To do this, use the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> clause. <code class="codeph">PARTITION</code> <code class="codeph">BY</code> specifies that the rows of the input table are to be partitioned by one or more columns. Matches are found within partitions and do not cross partition boundaries.
                        </p>
                        <p>If there is no <code class="codeph">PARTITION</code> <code class="codeph">BY</code>, then all rows of the row pattern input table constitute a single row pattern partition.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8983"></a><div class="props_rev_3"><a id="GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E" name="GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E"></a><h4 id="DWHSG-GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E" class="sect4"><span class="enumeration_section">21.3.2 </span>ORDER BY: Logically Ordering the Rows in a Partition
                  </h4>
                  <div>
                     <p>The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is used to specify the order of rows within a row pattern partition. If the order of two rows in a row pattern partition is not determined by <code class="codeph">ORDER</code> <code class="codeph">BY</code>, then the result of the <code class="codeph">MATCH_RECOGNIZE</code> clause is non-deterministic: it may not give consistent results each time the query is run.
                     </p>
                  </div>
               </div><a id="DWHSG8984"></a><div class="props_rev_3"><a id="GUID-FF7F2D64-503F-411C-9E57-15755441D7A2" name="GUID-FF7F2D64-503F-411C-9E57-15755441D7A2"></a><h4 id="DWHSG-GUID-FF7F2D64-503F-411C-9E57-15755441D7A2" class="sect4"><span class="enumeration_section">21.3.3 </span>[ONE ROW | ALL ROWS] PER MATCH: Choosing Summaries or Details for Each Match
                  </h4>
                  <div>
                     <p>You will sometimes want summary data about the matches and other times need details. You can do that with the following SQL:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                           <p>Each match produces one summary row. This is the default.</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                           <p>A match spanning multiple rows will produce one output row for each row in the match.</p>
                        </li>
                     </ul>
                     <p>The output is explained in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">Row Pattern Output</a>"</span>.
                     </p>
                     <p>The <code class="codeph">MATCH_RECOGNIZE</code> clause may find a match with zero rows. For an empty match, <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> returns a summary row: the <code class="codeph">PARTITION</code> <code class="codeph">BY</code> columns take the values from the row where the empty match occurs, and the measure columns are evaluated over an empty set of rows.
                     </p>
                     <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> has three suboptions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code></p>
                        </li>
                     </ul>
                     <p>These options are explained in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-F120C679-9C56-4703-970E-07C276EA50F1">Advanced Topics in Pattern Matching</a>"</span>.
                     </p>
                  </div>
               </div><a id="DWHSG8985"></a><div class="props_rev_3"><a id="GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2" name="GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2"></a><h4 id="DWHSG-GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2" class="sect4"><span class="enumeration_section">21.3.4 </span>MEASURES: Defining Calculations for Use in the Query
                  </h4>
                  <div>
                     <p>The <code class="codeph">MEASURES</code> clause defines a list of columns for the pattern output table. Each pattern measure column is defined with a column name whose value is specified by a corresponding pattern measure expression.
                     </p>
                     <p>A value expression is defined with respect to the pattern variables. Value expression can contain set functions, pattern navigation operations, <code class="codeph">CLASSIFIER()</code>, <code class="codeph">MATCH_NUMBER()</code>, and column references to any column of the input table. See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">Expressions in MEASURES and DEFINE</a>"</span> for more information.
                     </p>
                  </div>
               </div><a id="DWHSG8986"></a><div class="props_rev_3"><a id="GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1" name="GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1"></a><h4 id="DWHSG-GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1" class="sect4"><span class="enumeration_section">21.3.5 </span>PATTERN: Defining the Row Pattern to Be Matched
                  </h4>
                  <div>
                     <p>The <code class="codeph">PATTERN</code> keyword specifies the pattern to be recognized in the ordered sequence of rows in a partition. Each variable name in a pattern corresponds to a Boolean condition, which is specified later using the <code class="codeph">DEFINE</code> component of the syntax.
                     </p>
                     <p>The <code class="codeph">PATTERN</code> clause is used to specify a regular expression. It is outside the scope of this material to explain regular expression concepts and details. If you are not familiar with regular expressions, you are encouraged to familiarize yourself with the topic using other sources.
                     </p>
                     <p>The regular expression in a <code class="codeph">PATTERN</code> clause is enclosed in parentheses. <code class="codeph">PATTERN</code> may use the following operators:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Concatenation</p>
                           <p>Concatenation is used to list two or more items in a pattern to be matched in that order. Items are concatenated when there is no operator sign between two successive items. For example: <code class="codeph">PATTERN (A B C)</code>.
                           </p>
                        </li>
                        <li>
                           <p>Quantifiers</p>
                           <p>Quantifiers are POSIX operators that define the number of iterations accepted for a match. The syntax of POSIX extended regular expressions is similar to that of traditional UNIX regular expressions. The following are choices for quantifiers:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">*</code> — 0 or more iterations
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">+</code> — 1 or more iterations
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">?</code> — 0 or 1 iterations
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n}</code> — <code class="codeph">n</code> iterations (n &gt; 0)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n,}</code> — <code class="codeph">n</code> or more iterations (n &gt;= 0)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n,m}</code> — between <code class="codeph">n</code> and <code class="codeph">m</code> (inclusive) iterations (<code class="codeph">0 &lt;= n</code> <code class="codeph">&lt;= m</code>, <code class="codeph">0 &lt; m</code>)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">{,m} </code>— between 0 and <code class="codeph">m</code> (inclusive) iterations (<code class="codeph">m &gt; 0</code>)
                                 </p>
                              </li>
                              <li>
                                 <p>reluctant quantifiers — indicated by an additional question mark following a quantifier <code class="codeph">(*?, +?, ??, {n,}?, { n, m }?, {,m}?)</code>. See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-11206451-1F14-41AC-828F-F97C694F325C">Reluctant Versus Greedy Quantifier</a>"</span> for the difference between reluctant and non-reluctant quantifiers.
                                 </p>
                              </li>
                           </ul>
                           <p>The following are examples of using quantifier operators:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">A*</code> matches 0 or more iterations of <code class="codeph">A</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">A{3,6}</code> matches 3 to 6 iterations of <code class="codeph">A</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">A{,4}</code> matches 0 to 4 iterations of <code class="codeph">A</code></p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Alternation</p>
                           <p>Alternation matches a single regular expression from a list of several possible regular expressions. The alternation list is created by placing a vertical bar (|) between each regular expression. Alternatives are preferred in the order they are specified. As an example, <code class="codeph">PATTERN (A | B | C)</code> attempts to match <code class="codeph">A</code> first. If <code class="codeph">A</code> is not matched, it attempts to match <code class="codeph">B</code>. If <code class="codeph">B</code> is not matched, it attempts to match <code class="codeph">C</code>.
                           </p>
                        </li>
                        <li>
                           <p>Grouping</p>
                           <p>Grouping treats a portion of the regular expression as a single unit, enabling you to apply regular expression operators such as quantifiers to that group. Grouping is created with parentheses. As an example, <code class="codeph">PATTERN ((A B){3} C)</code> attempts to match the group <code class="codeph">(A B)</code> three times and then seeks one occurrence of <code class="codeph">C</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PERMUTE</code></p>
                           <p>See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7">How to Express All Permutations</a>"</span> for more information.
                           </p>
                        </li>
                        <li>
                           <p>Exclusion</p>
                           <p>Parts of the pattern to be excluded from the output of <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> are enclosed between {- and -}. See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">How to Exclude Portions of the Pattern from the Output</a>"</span>.
                           </p>
                        </li>
                        <li>
                           <p>Anchors</p>
                           <p>Anchors work in terms of positions rather than rows. They match a position either at the start or end of a partition.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph"> ^</code> matches the position before the first row in the partition.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">$</code> matches the position after the last row in the partition.
                                 </p>
                              </li>
                           </ul>
                           <p>As an example, <code class="codeph">PATTERN (^A+$)</code> will match only if all rows in a partition satisfy the condition for <code class="codeph">A</code>. The resulting match spans the entire partition.
                           </p>
                        </li>
                        <li>
                           <p>Empty pattern (), matches an empty set of rows</p>
                        </li>
                     </ul>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-11206451-1F14-41AC-828F-F97C694F325C">Reluctant Versus Greedy Quantifier</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0">Operator Precedence</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8987"></a><div class="props_rev_3"><a id="GUID-11206451-1F14-41AC-828F-F97C694F325C" name="GUID-11206451-1F14-41AC-828F-F97C694F325C"></a><h5 id="DWHSG-GUID-11206451-1F14-41AC-828F-F97C694F325C" class="sect5"><span class="enumeration_section">21.3.5.1 </span>Reluctant Versus Greedy Quantifier
                     </h5>
                     <div>
                        <p>Pattern quantifiers are referred to as greedy; they will attempt to match as many instances of the regular expression on which they are applied as possible. The exception is pattern quantifiers that have a question mark <code class="codeph">?</code> as a suffix, and those are referred to as reluctant. They will attempt to match as few instances as possible of the regular expression on which they are applied.
                        </p>
                        <p>The difference between greedy and reluctant quantifiers appended to a single pattern variable is illustrated as follows: <code class="codeph">A*</code> tries to map as many rows as possible to <code class="codeph">A</code>, whereas <code class="codeph">A*?</code> tries to map as few rows as possible to <code class="codeph">A</code>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">PATTERN (X Y* Z)
</pre><p>The pattern consists of three variable names, <code class="codeph">X</code>, <code class="codeph">Y</code>, and <code class="codeph">Z</code>, with <code class="codeph">Y</code> quantified with <code class="codeph">*</code>. This means a pattern match will be recognized and reported when the following condition is met by consecutive incoming input rows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A row satisfies the condition that defines variable <code class="codeph">X</code> followed by zero or more rows that satisfy the condition that defines the variable <code class="codeph">Y</code> followed by a row that satisfies the condition that defines the variable <code class="codeph">Z</code>.
                              </p>
                           </li>
                        </ul>
                        <p>During the pattern matching process, after a row was mapped to <code class="codeph">X</code> and 0 or more rows were mapped to <code class="codeph">Y</code>, if the following row can be mapped to both variables <code class="codeph">Y</code> and <code class="codeph">Z</code> (which satisfies the defining condition of both <code class="codeph">Y</code> and <code class="codeph">Z</code>), then, because the quantifier <code class="codeph">*</code> for <code class="codeph">Y</code> is greedy, the row is preferentially mapped to <code class="codeph">Y</code> instead of <code class="codeph">Z</code>. Due to this greedy property, <code class="codeph">Y</code> gets preference over <code class="codeph">Z</code> and a greater number of rows to <code class="codeph">Y</code> are mapped. If the pattern expression was <code class="codeph">PATTERN (X Y*? Z)</code>, which uses a reluctant quantifier <code class="codeph">*?</code> over <code class="codeph">Y</code>, then <code class="codeph">Z</code> gets preference over <code class="codeph">Y</code>.
                        </p>
                     </div>
                  </div><a id="DWHSG8988"></a><div class="props_rev_3"><a id="GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0" name="GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0"></a><h5 id="DWHSG-GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0" class="sect5"><span class="enumeration_section">21.3.5.2 </span>Operator Precedence
                     </h5>
                     <div>
                        <p>The precedence of the elements in a regular expression, in decreasing order, is as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">row_pattern_primary</code></p>
                              <p>These elements include primary pattern variables (pattern variables not created with the <code class="codeph">SUBSET</code> clause described in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET: Defining Union Row Pattern Variables</a>"</span>), anchors, <code class="codeph">PERMUTE</code>, parenthetic expressions, exclusion syntax, and empty pattern
                              </p>
                           </li>
                           <li>
                              <p>Quantifier</p>
                              <p>A <code class="codeph">row_pattern_primary</code> may have zero or one quantifier.
                              </p>
                           </li>
                           <li>
                              <p>Concatenation</p>
                           </li>
                           <li>
                              <p>Alternation</p>
                           </li>
                        </ul>
                        <p>Precedence of alternation is illustrated by <code class="codeph">PATTERN</code><code class="codeph">(A B | C D)</code>, which is equivalent to <code class="codeph">PATTERN</code> (<code class="codeph">(A B) | (C D))</code>. It is not, however, equivalent to <code class="codeph">PATTERN</code> <code class="codeph">(A (B | C) D)</code>.
                        </p>
                        <p>Precedence of quantifiers is illustrated by <code class="codeph">PATTERN</code> (<code class="codeph">A B *)</code>, which is equivalent to <code class="codeph">PATTERN</code> <code class="codeph">(A (B*))</code>. It is not, however, <code class="codeph">PATTERN</code> (<code class="codeph">(A B)*)</code>.
                        </p>
                        <p>A quantifier may not immediately follow another quantifier. For example, <code class="codeph">PATTERN</code><code class="codeph">(A**)</code> is prohibited.
                        </p>
                        <p>It is permitted for a primary pattern variable to occur more than once in a pattern, for example, <code class="codeph">PATTERN</code> <code class="codeph">(X Y X)</code>.
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8990"></a><a id="DWHSG8989"></a><div class="props_rev_3"><a id="GUID-55087E05-983A-4B47-94FE-556D04FF9842" name="GUID-55087E05-983A-4B47-94FE-556D04FF9842"></a><h4 id="DWHSG-GUID-55087E05-983A-4B47-94FE-556D04FF9842" class="sect4"><span class="enumeration_section">21.3.6 </span>SUBSET: Defining Union Row Pattern Variables
                  </h4>
                  <div>
                     <p>At times, it is helpful to create a grouping of multiple pattern variables that can be referred to with a variable name of its own. These groupings are called union row pattern variables, and you create them with the <code class="codeph">SUBSET</code> clause. The union row pattern variable created by <code class="codeph">SUBSET</code> can be used in the <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code> clauses. The <code class="codeph">SUBSET</code> clause is optional. It is used to declare union row pattern variables. For example, here is a query using <code class="codeph">SUBSET</code> to calculate an average based on all rows that are mapped to the union of <code class="codeph">STRT</code> and <code class="codeph">DOWN</code> variables, where <code class="codeph">STRT</code> is the starting point for a pattern, and <code class="codeph">DOWN</code> is the downward (left) leg of a V shape.
                     </p>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842__CACHECJD">Example 21-5</a> illustrates creating a union row pattern variable.
                     </p>
                     <div class="example" id="GUID-55087E05-983A-4B47-94FE-556D04FF9842__CACHECJD">
                        <p class="titleinexample">Example 21-5 Defining Union Row Pattern Variables</p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM Ticker MATCH_RECOGNIZE(
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES FIRST(STRT.tstamp) AS strt_time,
              LAST(DOWN.tstamp) AS bottom,
              AVG(STDN.Price) AS stdn_avgprice
     ONE ROW PER MATCH
     AFTER MATCH SKIP TO LAST UP
     PATTERN (STRT DOWN+ UP+)
     SUBSET STDN= (STRT, DOWN)
     DEFINE
        UP AS UP.Price &gt; PREV(UP.Price),
        DOWN AS DOWN.Price &lt; PREV (DOWN.Price)
);
 
SYMBOL    STRT_TIME BOTTOM    STDN_AVGPRICE
------    --------- --------- -------------
ACME      05-APR-11 06-APR-11          18.5
ACME      10-APR-11 12-APR-11    19.6666667
ACME      14-APR-11 16-APR-11            17
</pre></div>
                     <!-- class="example" -->
                     <p>This example declares a single union row pattern variable, <code class="codeph">STDN</code>, and defines it as the union of the rows mapped to <code class="codeph">STRT</code> and the rows mapped to <code class="codeph">DOWN</code>. There can be multiple union row pattern variables in a query. For example:
                     </p><pre class="oac_no_warn" dir="ltr">PATTERN (W+ X+ Y+ Z+)
SUBSET XY = (X, Y),
       WZ = (W, Z)
</pre><p>The right-hand side of a <code class="codeph">SUBSET</code> item is a comma-separated list of distinct primary row pattern variables within parentheses. This defines the union row pattern variable (on the left-hand side) as the union of the primary row pattern variables (on the right-hand side).
                     </p>
                     <p>Note that the list of pattern variables on the right-hand side may not include any union row pattern variables (there are no unions of unions).</p>
                     <p>For every match, there is one implicit union row pattern variable called the universal row pattern variable. The universal row pattern variable is the union of all primary row pattern variables. For instance, if your pattern has primary pattern variable <code class="codeph">A</code>, <code class="codeph">B</code>, and <code class="codeph">C</code>, then the universal row pattern variable is equivalent to a <code class="codeph">SUBSET</code> clause with the argument <code class="codeph">(A, B, C)</code>. Thus, every row of a match is mapped to the universal row pattern variable. Any unqualified column reference within the <code class="codeph">MEASURES</code> or <code class="codeph">DEFINE</code> clauses is implicitly qualified by the universal row pattern variable. Note that there is no keyword to explicitly specify the universal row pattern variable.
                     </p>
                  </div>
               </div><a id="DWHSG8992"></a><a id="DWHSG8991"></a><div class="props_rev_3"><a id="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8" name="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8"></a><h4 id="DWHSG-GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8" class="sect4"><span class="enumeration_section">21.3.7 </span>DEFINE: Defining Primary Pattern Variables
                  </h4>
                  <div>
                     <p><code class="codeph">DEFINE</code> is a mandatory clause, used to specify the conditions that define primary pattern variables. In the example:
                     </p><pre class="oac_no_warn" dir="ltr">DEFINE UP AS UP.Price &gt; PREV(UP.Price),
DOWN AS DOWN.Price &lt; PREV(DOWN.Price)
</pre><p><code class="codeph">UP</code> is defined by the condition <code class="codeph">UP.Price &gt; PREV (UP.Price)</code>, and <code class="codeph">DOWN</code> is defined by the condition <code class="codeph">DOWN.Price &lt; PREV (DOWN.Price)</code>. (<code class="codeph">PREV</code> is a row pattern navigation operation which evaluates an expression in the previous row; see <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">Row Pattern Navigation Operations</a>"</span> regarding the complete set of row pattern navigation operations.)
                     </p>
                     <p>A pattern variable does not require a definition; if there is no definition, any row can be mapped to the pattern variable.</p>
                     <p>A union row pattern variable (see discussion of <code class="codeph">SUBSET</code> in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET: Defining Union Row Pattern Variables</a>"</span>) cannot be defined by <code class="codeph">DEFINE</code>, but can be referenced in the definition of a pattern variable.
                     </p>
                     <p>The definition of a pattern variable can reference another pattern variable, which is illustrated in <a href="sql-pattern-matching-data-warehouses.html#GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8__CACGBDEB">Example 21-6</a>.
                     </p>
                     <div class="example" id="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8__CACGBDEB">
                        <p class="titleinexample">Example 21-6 Defining Pattern Variables</p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM Ticker MATCH_RECOGNIZE (
     PARTITION BY Symbol
     FROM Ticker
     MATCH_RECOGNIZE (
     PARTITION BY Symbol
     ORDER BY tstamp
     MEASURES FIRST (A.tstamp) AS A_Firstday,
              LAST (D.tstamp) AS D_Lastday,
              AVG (B.Price) AS B_Avgprice,
              AVG (D.Price) AS D_Avgprice
     PATTERN (A B+ C+ D)
     SUBSET BC = (B,C)
     DEFINE A AS Price &gt; 100,
            B AS B.Price &gt; A.Price,
            C AS C.Price &lt; AVG (B.Price),
            D AS D.Price &gt; MAX (BC.Price)
) M
</pre></div>
                     <!-- class="example" -->
                     <p>In this example:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The definition of <code class="codeph">A</code> implicitly references the universal row pattern variable (because of the unqualified column reference <code class="codeph">Price</code>).
                           </p>
                        </li>
                        <li>
                           <p>The definition of <code class="codeph">B</code> references the pattern variable <code class="codeph">A</code>.
                           </p>
                        </li>
                        <li>
                           <p>The definition of <code class="codeph">C</code> references the pattern variable <code class="codeph">B</code>.
                           </p>
                        </li>
                        <li>
                           <p>The definition of <code class="codeph">D</code> references the union row pattern variable <code class="codeph">BC</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The conditions are evaluated on successive rows of a partition in a trial match, with the current row being tentatively mapped to a pattern variable as permitted by the pattern. To be successfully mapped, the condition must evaluate to true.</p>
                     <p>In the previous example:</p><pre class="oac_no_warn" dir="ltr">A AS Price &gt; 100
</pre><p><code class="codeph">Price</code> refers to the <code class="codeph">Price</code> in the current row, because the last row mapped to any primary row pattern variable is the current row, which is tentatively mapped to <code class="codeph">A</code>. Alternatively, in this example, using <code class="codeph">A.Price</code> would have led to the same results.
                     </p><pre class="oac_no_warn" dir="ltr">B AS B.Price &gt; A.Price
</pre><p><code class="codeph">B.Price</code> refers to the <code class="codeph">Price</code> in the current row (because <code class="codeph">B</code> is being defined), whereas <code class="codeph">A.Price</code> refers to the last row mapped to <code class="codeph">A</code>. In view of the pattern, the only row mapped to <code class="codeph">A</code> is the first row to be mapped.
                     </p><pre class="oac_no_warn" dir="ltr">C AS C.Price &lt; AVG(B.Price)
</pre><p>Here <code class="codeph">C.Price</code> refers to the <code class="codeph">Price</code> in the current row, because <code class="codeph">C</code> is being defined. The aggregate <code class="codeph">AVG</code> (that is, insert <code class="codeph">Price</code>) is computed as the average of all rows that are already mapped to <code class="codeph">B</code>.
                     </p><pre class="oac_no_warn" dir="ltr">D AS D.Price &gt; MAX(BC.Price)
</pre><p>The pattern variable <code class="codeph">D</code> is similar to pattern variable <code class="codeph">C</code>, though it illustrates the use of a union row pattern variable in the Boolean condition. In this case, <code class="codeph">MAX(BC.Price)</code> returns the maximum price value of the rows matched to variable <code class="codeph">B</code> or variable <code class="codeph">C</code>. The semantics of Boolean conditions are discussed in more detail in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">Expressions in MEASURES and DEFINE</a>"</span>.
                     </p>
                  </div>
               </div><a id="DWHSG8993"></a><div class="props_rev_3"><a id="GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8" name="GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8"></a><h4 id="DWHSG-GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8" class="sect4"><span class="enumeration_section">21.3.8 </span>AFTER MATCH SKIP: Defining Where to Restart the Matching Process After a Match Is Found
                  </h4>
                  <div>
                     <p>The <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> clause determines the point to resume row pattern matching after a non-empty match was found. The default for the clause is <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code>. The options are as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code></p>
                           <p>Resume pattern matching at the row after the first row of the current match.</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code></p>
                           <p>Resume pattern matching at the next row after the last row of the current match.</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">FIRST</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>Resume pattern matching at the first row that is mapped to the pattern variable.</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>Resume pattern matching at the last row that is mapped to the pattern variable.</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>The same as <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <span class="italic"><code class="codeph">pattern_variable</code></span>.
                           </p>
                        </li>
                     </ul>
                     <p>When using <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">FIRST</code> or <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">[LAST]</code>, it is possible that no row is mapped to the pattern_variable. For example:
                     </p><pre class="oac_no_warn" dir="ltr">AFTER MATCH SKIP TO A
PATTERN (X A* X),
</pre><p>The pattern variable <code class="codeph">A</code> in the example might have no rows mapped to <code class="codeph">A</code>. If there is no row mapped to <code class="codeph">A</code>, then there is no row to skip to, so a runtime exception is generated. Another problem condition is that <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> may try to resume pattern matching at the same row that the last match started. For example:
                     </p><pre class="oac_no_warn" dir="ltr">AFTER MATCH SKIP TO X
PATTERN (X Y+ Z),
</pre><p>In this example, <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">X</code> tries to resume pattern matching at the same row where the previous match was found. This would result in an infinite loop, so a runtime exception is generated for this scenario.
                     </p>
                     <p>Note that the <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> syntax only determines the point to resume scanning for a match after a non-empty match. When an empty match is found, one row is skipped (as if <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code> had been specified). Thus an empty match never causes one of these exceptions. A query that gets one of these exceptions should be rewritten, as, for example, in the following:
                     </p><pre class="oac_no_warn" dir="ltr">AFTER MATCH SKIP TO A
PATTERN (X (A | B) Y)
</pre><p>This will cause a run-time error when a row is mapped to <code class="codeph">B</code>, because no row was mapped to <code class="codeph">A</code>. If the intent is to skip to either <code class="codeph">A</code> or <code class="codeph">B</code>, the following will work:
                     </p><pre class="oac_no_warn" dir="ltr">AFTER MATCH SKIP TO C
PATTERN (X (A | B) Y)
SUBSET C = (A, B)
</pre><p>In the revised example, no runtime error is possible, whether <code class="codeph">A</code> or <code class="codeph">B</code> is matched.
                     </p>
                     <p>As another example:</p><pre class="oac_no_warn" dir="ltr">AFTER MATCH SKIP TO FIRST A
PATTERN (A* X)
</pre><p>This example gets an exception after the first match, either for skipping to the first row of the match (if <code class="codeph">A*</code> matches) or for skipping to a nonexistent row (if <code class="codeph">A*</code> does not match). In this example, <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code> is a better choice.
                     </p>
                     <p>When using <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> together with skip options other than <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code>, it is possible for consecutive matches to overlap, in which case a row <code class="codeph">R</code> of the row pattern input table might occur in more than one match. In that case, the row pattern output table will have one row for each match in which the row participates. If a row of the row pattern input table participates in multiple matches, the <code class="codeph">MATCH_NUMBER</code> function can be used to distinguish among the matches. When a row participates in more than one match, its classifier can be different in each match.
                     </p>
                  </div>
               </div><a id="DWHSG9192"></a><a id="DWHSG8996"></a><div class="props_rev_3"><a id="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF" name="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF"></a><h4 id="DWHSG-GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF" class="sect4"><span class="enumeration_section">21.3.9 </span>Expressions in MEASURES and DEFINE
                  </h4>
                  <div>
                     <p>Pattern matching provides the following scalar expressions that are unique to row pattern matching:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Row pattern navigation operations, using the functions <code class="codeph">PREV</code>, <code class="codeph">NEXT</code>, <code class="codeph">FIRST</code> and <code class="codeph">LAST</code>. Row pattern navigation operations are discussed in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">Row Pattern Navigation Operations</a>"</span>.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">MATCH_NUMBER</code> function, which returns the sequential number of a row pattern match within its row pattern partition, discussed in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08">MATCH_NUMBER: Finding Which Rows Are in Which Match</a>"</span>.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">CLASSIFIER</code> function, which returns the name of the primary row pattern variable that a row is mapped to, discussed in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C">CLASSIFIER: Finding Which Pattern Variable Applies to Which Rows</a>"</span>.
                           </p>
                        </li>
                     </ul>
                     <p>Expressions in <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code> clauses have the same syntax and semantics, with the following exceptions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">DEFINE</code> clause only supports running semantics.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">MEASURES</code> clause defaults to running semantics, but also supports final semantics. This distinction is discussed in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0">RUNNING Versus FINAL Semantics</a>"</span>.
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF__GUID-7D2633F1-0B96-4572-8128-434747FB16F5">Working with Expressions</p>
                     </div>
                     <!-- class="section" -->
                     <p>This section discusses some of the considerations when working with expressions in pattern matching, and includes:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08">MATCH_NUMBER: Finding Which Rows Are in Which Match</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C">CLASSIFIER: Finding Which Pattern Variable Applies to Which Rows</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C">Row Pattern Column References</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC">Aggregates</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">Row Pattern Navigation Operations</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8994"></a><div class="props_rev_3"><a id="GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08" name="GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08"></a><h5 id="DWHSG-GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08" class="sect5"><span class="enumeration_section">21.3.9.1 </span>MATCH_NUMBER: Finding Which Rows Are in Which Match
                     </h5>
                     <div>
                        <p>Matches within a row pattern partition are numbered sequentially starting with 1 in the order they are found. Note that match numbering starts over again at 1 in each row pattern partition, because there is no inherent ordering between row pattern partitions. <code class="codeph">MATCH_NUMBER()</code> is a function that returns a numeric value with scale 0 (zero) whose value is the sequential number of the match within the row pattern partition.
                        </p>
                        <p>The previous examples using <code class="codeph">MATCH_NUMBER()</code> have shown it used in the <code class="codeph">MEASURES</code> clause. It is also possible to use <code class="codeph">MATCH_NUMBER()</code> in the <code class="codeph">DEFINE</code> clause, where it can be used to define conditions that depend upon the match number.
                        </p>
                     </div>
                  </div><a id="DWHSG8995"></a><div class="props_rev_3"><a id="GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C" name="GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C"></a><h5 id="DWHSG-GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C" class="sect5"><span class="enumeration_section">21.3.9.2 </span>CLASSIFIER: Finding Which Pattern Variable Applies to Which Rows
                     </h5>
                     <div>
                        <p>The <code class="codeph">CLASSIFIER</code> function returns a character string whose value is the name of the pattern variable to which a row is mapped. The <code class="codeph">CLASSIFIER</code> function is allowed in both the <code class="codeph">MEASURES</code> and the <code class="codeph">DEFINE</code> clauses.
                        </p>
                        <p>In the <code class="codeph">DEFINE</code> clause, the <code class="codeph">CLASSIFIER</code> function returns the name of the primary pattern variable to which the current row is mapped.
                        </p>
                        <p>In the <code class="codeph">MEASURES</code> clause:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, the query is using the last row of the match when processing the <code class="codeph">MEASURES</code> clause, so the <code class="codeph">CLASSIFIER</code> function returns the name of the pattern variable to which the last row of the match is mapped.
                              </p>
                           </li>
                           <li>
                              <p>If <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, for each row of the match found, the <code class="codeph">CLASSIFIER</code> function returns the name of the pattern variable to which the row is mapped.
                              </p>
                           </li>
                        </ul>
                        <p>The classifier for the starting row of an empty match is the null value.</p>
                     </div>
                  </div><a id="DWHSG8997"></a><div class="props_rev_3"><a id="GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C" name="GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C"></a><h5 id="DWHSG-GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C" class="sect5"><span class="enumeration_section">21.3.9.3 </span>Row Pattern Column References
                     </h5>
                     <div>
                        <p>A row pattern column reference is a column name qualified by an explicit or implicit pattern variable, such as the following:</p><pre class="oac_no_warn" dir="ltr">A.Price
</pre><p><code class="codeph">A</code> is the pattern variable and <code class="codeph">Price</code> is a column name. A column name with no qualifier, such as <code class="codeph">Price</code>, is implicitly qualified by the universal row pattern variable, which references the set of all rows in a match. Column references can be nested within other syntactic elements, notably aggregates and navigation operators. (However, nesting in row pattern matching is subject to limitations described in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0">Prohibited Nesting in the MATCH_RECOGNIZE Clause</a>"</span> for the <code class="codeph">FROM</code> clause.)
                        </p>
                        <p>Pattern column references are classified as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Nested within an aggregate, such as <code class="codeph">SUM</code>: an aggregated row pattern column reference.
                              </p>
                           </li>
                           <li>
                              <p>Nested within a row pattern navigation operation (<code class="codeph">PREV</code>, <code class="codeph">NEXT</code>, <code class="codeph">FIRST</code>, and <code class="codeph">LAST</code>): a navigated row pattern column reference.
                              </p>
                           </li>
                           <li>
                              <p>Otherwise: an ordinary row pattern column reference.</p>
                           </li>
                        </ul>
                        <p>All pattern column references in an aggregate or row pattern navigation operation must be qualified by the same pattern variable. For example:</p><pre class="oac_no_warn" dir="ltr">PATTERN (A+ B+)
DEFINE B AS AVG(A.Price + B.Tax) &gt; 100
</pre><p>The preceding example is a syntax error, because <code class="codeph">A</code> and <code class="codeph">B</code> are two different pattern variables. Aggregate semantics require a single set of rows; there is no way to form a single set of rows on which to evaluate <code class="codeph">A.Price + B.Tax</code>. However, the following is acceptable:
                        </p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG (B.Price + B.Tax) &gt; 100
</pre><p>In the preceding example, all pattern column references in the aggregate are qualified by <code class="codeph">B</code>.
                        </p>
                        <p>An unqualified column reference is implicitly qualified by the universal row pattern variable, which references the set of all rows in a match. For example:</p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG(Price + B.Tax) &gt; 1000
</pre><p>The preceding example is a syntax error, because the unqualified column reference <code class="codeph">Price</code> is implicitly qualified by the universal row pattern variable, whereas <code class="codeph">B.Tax</code> is explicitly qualified by <code class="codeph">B</code>. However, the following is acceptable:
                        </p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG (Price + Tax) &gt; 1000
</pre><p>In the preceding example, both <code class="codeph">Price</code> and <code class="codeph">Tax</code> are implicitly qualified by the universal row pattern variable.
                        </p>
                     </div>
                  </div><a id="DWHSG8998"></a><div class="props_rev_3"><a id="GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC" name="GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC"></a><h5 id="DWHSG-GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC" class="sect5"><span class="enumeration_section">21.3.9.4 </span>Aggregates
                     </h5>
                     <div>
                        <p>The aggregates (<code class="codeph">COUNT</code>, <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">MAX</code>, and <code class="codeph">MIN</code>) can be used in both the <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code> clauses. Note that the <code class="codeph">DISTINCT</code> keyword is not supported. When used in row pattern matching, aggregates operate on a set of rows that are mapped to a particular pattern variable, using either running or final semantics. For example:
                        </p><pre class="oac_no_warn" dir="ltr">MEASURES SUM (A.Price) AS RunningSumOverA,
         FINAL SUM(A.Price) AS FinalSumOverA
ALL ROWS PER MATCH
</pre><p>In this example, <code class="codeph">A</code> is a pattern variable. The first pattern measure, <code class="codeph">RunningSumOverA</code>, does not specify either <code class="codeph">RUNNING</code> or <code class="codeph">FINAL</code>, so it defaults to <code class="codeph">RUNNING</code>. This means that it is computed as the sum of <code class="codeph">Price</code> in those rows that are mapped to <code class="codeph">A</code> by the current match, up to and including the current row. The second pattern measure, <code class="codeph">FinalSumOverA</code>, computes the sum of <code class="codeph">Price</code> over all rows that are mapped to <code class="codeph">A</code> by the current match, including rows that may be later than the current row. Final aggregates are only available in the <code class="codeph">MEASURES</code> clause, not in the <code class="codeph">DEFINE</code> clause.
                        </p>
                        <p>An unqualified column reference contained in an aggregate is implicitly qualified by the universal row pattern variable, which references all rows of the current pattern match. For example:</p><pre class="oac_no_warn" dir="ltr">SUM (Price)
</pre><p>The running sum of <code class="codeph">Price</code> over all rows of the current row pattern match is computed.
                        </p>
                        <p>All column references contained in an aggregate must be qualified by the same pattern variable. For example:</p><pre class="oac_no_warn" dir="ltr">SUM (Price + A.Tax)
</pre><p>Because <code class="codeph">Price</code> is implicitly qualified by the universal row pattern variable, whereas <code class="codeph">A.Tax</code> is explicitly qualified by <code class="codeph">A</code>, you get a syntax error.
                        </p>
                        <p>The <code class="codeph">COUNT</code> aggregate has special syntax for pattern matching, so that <code class="codeph">COUNT(A.*)</code> can be specified. <code class="codeph">COUNT(A.*)</code> is the number of rows that are mapped to the pattern variable A by the current pattern match. As for <code class="codeph">COUNT(*)</code>, the <code class="codeph">*</code> implicitly covers the rows of the universal row pattern variable, so that <code class="codeph">COUNT(*)</code> is the number of rows in the current pattern match.
                        </p>
                     </div>
                  </div><a id="DWHSG9000"></a><div class="props_rev_3"><a id="GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86" name="GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86"></a><h5 id="DWHSG-GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86" class="sect5"><span class="enumeration_section">21.3.9.5 </span>Row Pattern Navigation Operations
                     </h5>
                     <div>
                        <p>There are four functions — <code class="codeph">PREV</code>, <code class="codeph">NEXT</code>, <code class="codeph">FIRST</code>, and <code class="codeph">LAST</code> — that enable navigation within the row pattern by either physical or logical offsets.
                        </p>
                     </div><a id="DWHSG8999"></a><div class="props_rev_3"><a id="GUID-D53633CB-550C-4574-BF90-A91797D1E8DB" name="GUID-D53633CB-550C-4574-BF90-A91797D1E8DB"></a><h6 id="DWHSG-GUID-D53633CB-550C-4574-BF90-A91797D1E8DB" class="sect6"><span class="enumeration_section">21.3.9.5.1 </span>PREV and NEXT
                        </h6>
                        <div>
                           <p>The <code class="codeph">PREV</code> function can be used to evaluate an expression using a previous row in a partition. It operates in terms of physical rows and is not limited to the rows mapped to a specific variable. If there is no previous row, the null value is returned. For example:
                           </p><pre class="oac_no_warn" dir="ltr">DEFINE A AS PREV (A.Price) &gt; 100
</pre><p>The preceding example says that the current row can be mapped to <code class="codeph">A</code> if the row preceding the current row has a price greater than 100. If the preceding row does not exist (that is, the current row is the first row of a row pattern partition), then <code class="codeph">PREV(A.Price)</code> is null, so the condition is not <code class="codeph">True</code>, and therefore the first row cannot be mapped to <code class="codeph">A</code>.
                           </p>
                           <p>Note that you can use another pattern variable (such as <code class="codeph">B</code>) in defining the pattern variable <code class="codeph">A</code>, and have the condition apply a <code class="codeph">PREV()</code> function to that other pattern variable. That might resemble:
                           </p><pre class="oac_no_warn" dir="ltr">DEFINE A AS PREV (B.PRICE) &gt; 100
</pre><p>In that case, the starting row used by the <code class="codeph">PREV()</code> function for its navigation is the last row mapped to pattern variable <code class="codeph">B</code>.
                           </p>
                           <p>The <code class="codeph">PREV</code> function can accept an optional non-negative integer argument indicating the physical offset to the previous rows. Thus:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">PREV (A.Price, 0)</code> is equivalent to <code class="codeph">A.Price</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PREV (A.price, 1)</code> is equivalent to <code class="codeph">PREV (A.Price)</code>. Note: 1 is the default offset.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PREV (A.Price, 2)</code> is the value of <code class="codeph">Price</code> in the row two rows before to the row denoted by A with running semantics. (If no row is mapped to A, or if there is no row two rows prior, then <code class="codeph">PREV (A.Price, 2)</code> is null.)
                                 </p>
                              </li>
                           </ul>
                           <p>The offset must be a runtime constant (literal, bind variable, and expressions involving them), but not a column or a subquery.</p>
                           <p>The <code class="codeph">NEXT</code> function is a forward-looking version of the <code class="codeph">PREV</code> function. It can be used to reference rows in the forward direction in the row pattern partition using a physical offset. The syntax is the same as for <code class="codeph">PREV</code>, except for the name of the function. For example:
                           </p><pre class="oac_no_warn" dir="ltr">DEFINE A AS NEXT (A.Price) &gt; 100
</pre><p>The preceding example looks forward one row in the row pattern partition. Note that pattern matching does not support aggregates that look past the current row during the <code class="codeph">DEFINE</code> clause, because of the difficulty of predicting what row will be mapped to what pattern variable in the future. The <code class="codeph">NEXT</code> function does not violate this principle, because it navigates to "future" rows on the basis of a physical offset, which does not require knowing the future mapping of rows.
                           </p>
                           <p>For example, to find an isolated row that is more than twice the average of the two rows before and two rows after it: using <code class="codeph">NEXT</code>, this can be expressed:
                           </p><pre class="oac_no_warn" dir="ltr">PATTERN ( X )
DEFINE X AS X.Price &gt; 2 * ( PREV (X.Price, 2)
       + PREV (X.Price, 1)
       + NEXT (X.Price, 1)
       + NEXT (X.Price, 2) ) / 4
</pre><p>Note that the row in which <code class="codeph">PREV</code> or <code class="codeph">NEXT</code> is evaluated is not necessarily mapped to the pattern variable in the argument. For example, in this example, <code class="codeph">PREV (X.Price, 2)</code> is evaluated in a row that is not part of the match. The purpose of the pattern variable is to identify the row from which to offset, not the row that is ultimately reached. (If the definition of pattern variable refers to itself in a <code class="codeph">PREV()</code> or <code class="codeph">NEXT()</code>, then it is referring to the current row as the row from which to offset.) This point is discussed further in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">Nesting FIRST and LAST Within PREV and NEXT in Pattern Matching</a>"</span>.
                           </p>
                           <p><code class="codeph">PREV</code> and <code class="codeph">NEXT</code> may be used with more than one column reference; for example:
                           </p><pre class="oac_no_warn" dir="ltr">DEFINE A AS PREV (A.Price + A.Tax) &lt; 100
</pre><p>When using a complex expression as the first argument of <code class="codeph">PREV</code> or <code class="codeph">NEXT</code>, all qualifiers must be the same pattern variable (in this example, <code class="codeph">A</code>).
                           </p>
                           <p><code class="codeph">PREV</code> and <code class="codeph">NEXT</code> always have running semantics; the keywords <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> cannot be used with <code class="codeph">PREV</code> or <code class="codeph">NEXT</code>. (See the section on <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B">Running Versus Final Semantics and Keywords</a>"</span>). To obtain final semantics, use, for example, <code class="codeph">PREV</code> (<code class="codeph">FINAL</code> <code class="codeph">LAST (A.Price))</code> as explained in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">Nesting FIRST and LAST Within PREV and NEXT in Pattern Matching</a>"</span>.
                           </p>
                        </div><a id="DWHSG9002"></a><a id="DWHSG9001"></a><div class="props_rev_3"><a id="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5" name="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5"></a><h6 id="DWHSG-GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5" class="sect6"><span class="enumeration_section">21.3.9.5.1.1 </span>FIRST and LAST
                           </h6>
                           <div>
                              <p>In contrast to the <code class="codeph">PREV</code> and <code class="codeph">NEXT</code> functions, the <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> functions navigate only among the rows mapped to pattern variables: they use logical, not physical, offsets. <code class="codeph">FIRST</code> returns the value of an expression evaluated in the first row of the group of rows mapped to a pattern variable. For example:
                              </p><pre class="oac_no_warn" dir="ltr">FIRST (A.Price)
</pre><p>If no row is mapped to <code class="codeph">A</code>, then the value is null.
                              </p>
                              <p>Similarly, <code class="codeph">LAST</code> returns the value of an expression evaluated in the last row of the group of rows mapped to a pattern variable. For example:
                              </p><pre class="oac_no_warn" dir="ltr">LAST (A.Price)
</pre><p>The preceding example evaluates <code class="codeph">A.Price</code> in the last row that is mapped to <code class="codeph">A</code> (null if there is no such row).
                              </p>
                              <p>The <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> operators can accept an optional non-negative integer argument indicating a logical offset within the set of rows mapped to the pattern variable. For example:
                              </p><pre class="oac_no_warn" dir="ltr">FIRST (A.Price, 1)
</pre><p>The preceding line evaluates <code class="codeph">Price</code> in the second row that is mapped to <code class="codeph">A</code>. Consider the following data set and mappings in <a href="sql-pattern-matching-data-warehouses.html#GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5__CACHFFDJ" title="This table contains a data set and mappings that are used in the FIRST and LAST function examples.">Table 21-1</a>.
                              </p>
                              <div class="tblformal" id="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5__CACHFFDJ">
                                 <p class="titleintable">Table 21-1 Pattern and Row</p>
                                 <table cellpadding="4" cellspacing="0" class="Formal" title="Pattern and Row" summary="This table contains a data set and mappings that are used in the FIRST and LAST function examples." width="100%" frame="hsides" border="1" rules="rows">
                                    <thead>
                                       <tr align="left" valign="top">
                                          <th align="left" valign="bottom" width="32%" id="d80268e3657">Row</th>
                                          <th align="left" valign="bottom" width="25%" id="d80268e3660">Price</th>
                                          <th align="left" valign="bottom" width="43%" id="d80268e3663">Mapping</th>
                                       </tr>
                                    </thead>
                                    <tbody>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3668" headers="d80268e3657 ">
                                             <p>R1</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3668 d80268e3660 ">
                                             <p>10</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3668 d80268e3663 ">
                                             <p>A</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3678" headers="d80268e3657 ">
                                             <p>R2</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3678 d80268e3660 ">
                                             <p>20</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3678 d80268e3663 ">
                                             <p>B</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3688" headers="d80268e3657 ">
                                             <p>R3</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3688 d80268e3660 ">
                                             <p>30</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3688 d80268e3663 ">
                                             <p>A</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3698" headers="d80268e3657 ">
                                             <p>R4</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3698 d80268e3660 ">
                                             <p>40</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3698 d80268e3663 ">
                                             <p>C</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3708" headers="d80268e3657 ">
                                             <p>R5</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3708 d80268e3660 ">
                                             <p>50</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3708 d80268e3663 ">
                                             <p>A</p>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </div>
                              <!-- class="inftblhruleinformal" -->
                              <p>Then the following:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price)</code> = <code class="codeph">FIRST (A.Price, 0)</code> = <code class="codeph">LAST (A.Price, 2) = 10</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 1)</code> = <code class="codeph">LAST (A.Price, 1) = 30</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 2)</code> = <code class="codeph">LAST (A.Price, 0) = LAST (A.Price) = 50</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 3)</code> is null, as is <code class="codeph">LAST (A.Price, 3)</code></p>
                                 </li>
                              </ul>
                              <p>Note that the offset is a logical offset, moving within the set of rows <code class="codeph">{R1, R3, R5}</code> that are mapped to the pattern variable <code class="codeph">A</code>. It is not a physical offset, as with <code class="codeph">PREV</code> or <code class="codeph">NEXT</code>.
                              </p>
                              <p>The optional integer argument must be a runtime constant (literal, bind variable, and expressions involving them), but not a column or subquery.</p>
                              <p>The first argument of <code class="codeph">FIRST</code> or <code class="codeph">LAST</code> must have at least one row pattern column reference. Thus, <code class="codeph">FIRST(1)</code> is a syntax error.
                              </p>
                              <p>The first argument of <code class="codeph">FIRST</code> or <code class="codeph">LAST</code> may have more than one row pattern column reference, in which case all qualifiers must be the same pattern variable. For example, <code class="codeph">FIRST (A.Price + B.Tax)</code> is a syntax error, but <code class="codeph">FIRST (A.Price + A.Tax)</code> is acceptable.
                              </p>
                              <p><code class="codeph">FIRST</code> and <code class="codeph">LAST</code> support both running and final semantics. The <code class="codeph">RUNNING</code> keyword is the default, and the only supported option in the <code class="codeph">DEFINE</code> clause. Final semantics can be accessed in the <code class="codeph">MEASURES</code> by using the keyword <code class="codeph">FINAL</code>, as in:
                              </p><pre class="oac_no_warn" dir="ltr">MEASURES FINAL LAST (A.Price) AS FinalPrice
ALL ROWS PER MATCH</pre></div>
                        </div>
                     </div>
                  </div><a id="DWHSG9193"></a><div class="props_rev_3"><a id="GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B" name="GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B"></a><h5 id="DWHSG-GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B" class="sect5"><span class="enumeration_section">21.3.9.6 </span>Running Versus Final Semantics and Keywords
                     </h5>
                     <div>
                        <p>This section discusses some of the considerations to keep in mind when working with <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code>.
                        </p>
                     </div><a id="DWHSG9007"></a><a id="DWHSG9008"></a><a id="DWHSG9009"></a><a id="DWHSG9010"></a><a id="DWHSG9011"></a><a id="DWHSG9194"></a><div class="props_rev_3"><a id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0" name="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0"></a><h6 id="DWHSG-GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0" class="sect6"><span class="enumeration_section">21.3.9.6.1 </span>RUNNING Versus FINAL Semantics
                        </h6>
                        <div>
                           <p>Pattern matching in a sequence of rows is usually thought of as an incremental process, with one row after another examined to see if it fits the pattern. With this incremental processing model, at any step until the complete pattern has been recognized, there is only a partial match and it is not known what rows might be added in the future, nor to what variables those future rows might be mapped. Therefore, in pattern matching, a row pattern column reference in the Boolean condition of a <code class="codeph">DEFINE</code> clause has running semantics. This means that a pattern variable represents the set of rows that were already mapped to the pattern variable, up to and including the current row, but not any future rows.
                           </p>
                           <p>After the complete match is established, it is possible to have final semantics. Final semantics is the same as running semantics on the last row of a successful match. Final semantics is only available in <code class="codeph">MEASURES</code>, because in <code class="codeph">DEFINE</code> there is uncertainty about whether a complete match was achieved.
                           </p>
                           <p>The keywords <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> are used to indicate running or final semantics, respectively; the rules for these keywords are discussed in <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2">RUNNING Versus FINAL Keywords</a>"</span>.
                           </p>
                           <p>The fundamental rule for expression evaluation in <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code> is as follows:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>When an expression involving a pattern variable is computed on a group of rows, then the set of rows that is mapped to the pattern variable is used. If the set is empty, then <code class="codeph">COUNT</code> is 0 and any other expression involving the pattern variable is null.
                                 </p>
                              </li>
                              <li>
                                 <p>When an expression requires evaluation in a single row, then the latest row of the set is used. If the set is empty, then the expression is null.</p>
                              </li>
                           </ul>
                           <p>For example, consider the following table and query in <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJHBAI">Example 21-7</a>.
                           </p>
                           <div class="example" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJHBAI">
                              <p class="titleinexample">Example 21-7 RUNNING Versus FINAL Semantics</p><pre class="oac_no_warn" dir="ltr">SELECT M.Symbol, M.Tstamp, M.Price, M.RunningAvg, M.FinalAvg
FROM TICKER MATCH_RECOGNIZE (
     PARTITION BY Symbol
     ORDER BY tstamp
     MEASURES RUNNING AVG (A.Price) AS RunningAvg,
              FINAL AVG (A.Price) AS FinalAvg
     ALL ROWS PER MATCH
     PATTERN (A+)
     DEFINE A AS A.Price &gt;= AVG (A.Price)
     ) M
;
</pre></div>
                           <!-- class="example" -->
                           <p>Consider the following ordered row pattern partition of data shown in <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACEDGJH" title="This table displays ordered pattern and partitioned data.">Table 21-2</a>.
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACEDGJH">
                              <p class="titleintable">Table 21-2 Pattern and Partitioned Data</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Pattern and Partitioned Data" summary="This table displays ordered pattern and partitioned data." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="22%" id="d80268e3939">Row</th>
                                       <th align="left" valign="bottom" width="20%" id="d80268e3942">Symbol</th>
                                       <th align="left" valign="bottom" width="27%" id="d80268e3945">Timestamp</th>
                                       <th align="left" valign="bottom" width="32%" id="d80268e3948">Price</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3953" headers="d80268e3939 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3953 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3953 d80268e3945 ">
                                          <p>09-Jun-09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3953 d80268e3948 ">
                                          <p>10</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3966" headers="d80268e3939 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3966 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3966 d80268e3945 ">
                                          <p>10-Jun-09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3966 d80268e3948 ">
                                          <p>16</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3979" headers="d80268e3939 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3979 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3979 d80268e3945 ">
                                          <p>11-Jun-09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3979 d80268e3948 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3992" headers="d80268e3939 ">
                                          <p>R4</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3992 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3992 d80268e3945 ">
                                          <p>12-Jun-09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3992 d80268e3948 ">
                                          <p>9</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>The following logic can be used to find a match:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>On the first row of the row pattern partition, tentatively map row <code class="codeph">R1</code> to pattern variable <code class="codeph">A</code>. At this point, the set of rows mapped to variable <code class="codeph">A</code> is <code class="codeph">{R1}</code>. To confirm whether this mapping is successful, evaluate the predicate:
                                 </p>
                                 <p><code class="codeph">A.Price &gt;= AVG (A.Price)</code></p>
                                 <p>On the left-hand side, <code class="codeph">A.Price</code> must be evaluated in a single row, which is the last row of the set using running semantics. The last row of the set is <code class="codeph">R1</code>; therefore <code class="codeph">A.Price</code> is 10.
                                 </p>
                                 <p>On the right hand side, <code class="codeph">AVG (A.Price)</code> is an aggregate, which is computed using the rows of the set. This average is 10/1 = 10.
                                 </p>
                                 <p>Thus the predicate asks if <code class="codeph">10 &gt;= 10.</code> The answer is yes, so the mapping is successful. However, the pattern <code class="codeph">A+</code> is greedy, so the query must try to match more rows if possible.
                                 </p>
                              </li>
                              <li>
                                 <p>On the second row of the row pattern partition, tentatively map <code class="codeph">R2</code> to pattern variable <code class="codeph">A</code>. At this point there are two rows mapped to <code class="codeph">A</code>, so the set is <code class="codeph">{R1, R2}</code>. Confirm whether the mapping is successful by evaluating the predicate.
                                 </p>
                                 <p><code class="codeph">A.Price &gt;= AVG (A.Price)</code></p>
                                 <p>On the left hand side, <code class="codeph">A.Price</code> must be evaluated in a single row, which is the last row of the set using running semantics. The last row of the set is <code class="codeph">R2</code>; therefore <code class="codeph">A.Price</code> is 16.On the right hand side, <code class="codeph">AVG (A.Price)</code> is an aggregate, which is computed using the rows of the set. This average is (10+16)/2 = 13.Thus the predicate asks if 16 &gt;= 13. The answer is yes, so the mapping is successful.
                                 </p>
                              </li>
                              <li>
                                 <p>On the third row of the row pattern partition, tentatively map <code class="codeph">R3</code> to pattern variable <code class="codeph">A</code>. Now there are three rows mapped to <code class="codeph">A</code>, so the set is <code class="codeph">{R1, R2, R3}</code>. Confirm whether the mapping is successful by evaluating the predicate:
                                 </p>
                                 <p><code class="codeph">A.Price &gt;= AVG (A.Price)</code></p>
                                 <p>On the left-hand side, <code class="codeph">A.Price</code> is evaluated in <code class="codeph">R3</code>; therefore, <code class="codeph">A.Price</code> is 13.
                                 </p>
                                 <p>On the right-hand side, <code class="codeph">AVG (A.Price)</code> is an aggregate, which is computed using the rows of the set. This average is (10+16+13)/3 = 13.Thus the predicate asks if 13 &gt;= 13. The answer is yes, so the mapping is successful.
                                 </p>
                              </li>
                              <li>
                                 <p>On the fourth row of the row pattern partition, tentatively map <code class="codeph">R4</code> to pattern variable <code class="codeph">A</code>. At this point, the set is<code class="codeph"> {R1, R2, R3, R4}</code>. Confirm whether the mapping is successful by evaluating the predicate:
                                 </p>
                                 <p><code class="codeph">A.Price &gt;= AVG (A.Price)</code></p>
                                 <p>On the left-hand side, <code class="codeph">A.Price </code>is evaluated in <code class="codeph">R4</code>; therefore, <code class="codeph">A.Price</code> is 9.
                                 </p>
                                 <p>On the right-hand side, <code class="codeph">AVG (A.Price)</code> is an aggregate, which is computed using the rows of the set. This average is (10+16+13+9)/4 = 12.Thus the predicate asks if 9 &gt;= 12. The answer is no, so the mapping is not successful.
                                 </p>
                              </li>
                           </ul>
                           <p><code class="codeph">R4</code> did not satisfy the definition of <code class="codeph">A</code>, so the longest match to <code class="codeph">A+</code> is <code class="codeph">{R1, R2, R3}</code>. Because <code class="codeph">A+</code> has a greedy quantifier, this is the preferred match.
                           </p>
                           <p>The averages computed in the <code class="codeph">DEFINE</code> clause are running averages. In <code class="codeph">MEASURES</code>, especially with <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, it is possible to distinguish final and running aggregates. Notice the use of the keywords <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> in the <code class="codeph">MEASURES</code> clause. The distinction can be observed in the result of the example in <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJDBGA" title="This table displays the running average and final average.">Table 21-3</a>.
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJDBGA">
                              <p class="titleintable">Table 21-3 Row Pattern Navigation</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Row Pattern Navigation" summary="This table displays the running average and final average." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="18%" id="d80268e4211">Symbol</th>
                                       <th align="left" valign="bottom" width="20%" id="d80268e4214">Timestamp</th>
                                       <th align="left" valign="bottom" width="21%" id="d80268e4217">Price</th>
                                       <th align="left" valign="bottom" width="23%" id="d80268e4220">Running Average</th>
                                       <th align="left" valign="bottom" width="18%" id="d80268e4223">Final Average</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4228" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4228 d80268e4214 ">
                                          <p>2009-06-09</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4228 d80268e4217 ">
                                          <p>10</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4228 d80268e4220 ">
                                          <p>10</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4228 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4244" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4244 d80268e4214 ">
                                          <p>2009-06-10</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4244 d80268e4217 ">
                                          <p>16</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4244 d80268e4220 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4244 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4260" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4260 d80268e4214 ">
                                          <p>2009-06-11</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4260 d80268e4217 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4260 d80268e4220 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4260 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>It is possible that the set of rows mapped to a pattern variable is empty. When evaluating over an empty set:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">COUNT</code> is 0.
                                 </p>
                              </li>
                              <li>
                                 <p>Any other aggregate, row pattern navigation operation, or ordinary pattern column reference is null.</p>
                              </li>
                           </ul>
                           <p>For example:</p><pre class="oac_no_warn" dir="ltr">PATTERN ( A? B+ )
DEFINE A AS A.Price &gt; 100,
       B AS B.Price &gt; COUNT (A.*) * 50
</pre><p>With the preceding example, consider the following ordered row pattern partition of data in <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACIAFHB" title="This table displays the price values for three rows.">Table 21-4</a>.
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACIAFHB">
                              <p class="titleintable">Table 21-4 Pattern and Row</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Pattern and Row" summary="This table displays the price values for three rows." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="40%" id="d80268e4307">Row</th>
                                       <th align="left" valign="bottom" width="60%" id="d80268e4310">Price</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4315" headers="d80268e4307 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4315 d80268e4310 ">
                                          <p>60</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4322" headers="d80268e4307 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4322 d80268e4310 ">
                                          <p>70</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4329" headers="d80268e4307 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4329 d80268e4310 ">
                                          <p>40</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>A match can be found in this data as follows:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Tentatively map row <code class="codeph">R1</code> to pattern variable <code class="codeph">A</code>. (The quantifier <code class="codeph">?</code> means to try first for a single match to <code class="codeph">A</code>; if that fails, then an empty match is taken as matching <code class="codeph">A?</code>). To see if the mapping is successful, the predicate <code class="codeph">A.Price &gt; 100</code> is evaluated. <code class="codeph">A.Price</code> is 60; therefore, the predicate is false and the mapping to <code class="codeph">A</code> does not succeed.
                                 </p>
                              </li>
                              <li>
                                 <p>Because the mapping to <code class="codeph">A</code> failed, the empty match is taken as matching <code class="codeph">A?</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Tentatively map row <code class="codeph">R1</code> to <code class="codeph">B</code>. The predicate to check for this mapping is <code class="codeph">B.Price &gt; COUNT (A.*) * 50</code></p>
                                 <p>No rows are mapped to <code class="codeph">A</code>, therefore <code class="codeph">COUNT (A.*)</code> is 0. Because <code class="codeph">B.Price = 60</code> is greater than 0, the mapping is successful.
                                 </p>
                              </li>
                              <li>
                                 <p>Similarly, rows <code class="codeph">R2</code> and <code class="codeph">R3</code> can be successfully mapped to <code class="codeph">B</code>. Because there are no more rows, this is the complete match: no rows mapped <code class="codeph">A</code>, and rows {R1, R2, R3} mapped to <code class="codeph">B</code>.
                                 </p>
                              </li>
                           </ul>
                           <p>A pattern variable can make a forward reference, that is, a reference to a pattern variable that was not matched yet. For example:</p><pre class="oac_no_warn" dir="ltr">PATTERN (X+ Y+)
DEFINE X AS COUNT (Y.*) &gt; 3,
Y AS Y.Price &gt; 10
</pre><p>The previous example is valid syntax. However, this example will never be matched because at the time that a row is mapped to <code class="codeph">X</code>, no row has been mapped to <code class="codeph">Y</code>. Thus <code class="codeph">COUNT(Y.*)</code> is 0 and can never be greater than three. This is true even if there are four future rows that might be successfully mapped to <code class="codeph">Y</code>. Consider this data set in <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACFHCII" title="This table displays the data set for pattern partition of data.">Table 21-5</a>.
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACFHCII">
                              <p class="titleintable">Table 21-5 Pattern and Row</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Pattern and Row" summary="This table displays the data set for pattern partition of data." width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="46%" id="d80268e4449">Row</th>
                                       <th align="left" valign="bottom" width="54%" id="d80268e4452">Price</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4457" headers="d80268e4449 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4457 d80268e4452 ">
                                          <p>2</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4464" headers="d80268e4449 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4464 d80268e4452 ">
                                          <p>11</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4471" headers="d80268e4449 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4471 d80268e4452 ">
                                          <p>12</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4478" headers="d80268e4449 ">
                                          <p>R4</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4478 d80268e4452 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4485" headers="d80268e4449 ">
                                          <p>R5</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4485 d80268e4452 ">
                                          <p>14</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>Mapping <code class="codeph">{R2, R3, R4, R5} </code>to <code class="codeph">Y</code> would be successful, because all four of these rows satisfy the Boolean condition defined for <code class="codeph">Y</code>. In that case, you might think that you could map <code class="codeph">R1</code> to <code class="codeph">X</code> and have a complete successful match. However, the rules of pattern matching will not find this match, because, according to the pattern <code class="codeph">X+ Y+</code>, at least one row must be mapped to <code class="codeph">X</code> before any rows are mapped to <code class="codeph">Y</code>.
                           </p>
                        </div>
                     </div><a id="DWHSG9195"></a><div class="props_rev_3"><a id="GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2" name="GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2"></a><h6 id="DWHSG-GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2" class="sect6"><span class="enumeration_section">21.3.9.6.2 </span>RUNNING Versus FINAL Keywords
                        </h6>
                        <div>
                           <p><code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> are keywords used to indicate whether running or final semantics are desired. <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> can be used with aggregates and the row pattern navigation operations <code class="codeph">FIRST</code> and <code class="codeph">LAST</code>.
                           </p>
                           <p>Aggregates, <code class="codeph">FIRST</code> and <code class="codeph">LAST</code> can occur in the following places in a row pattern matching query:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>In the <code class="codeph">DEFINE</code> clause. When processing the <code class="codeph">DEFINE</code> clause, the query is still in the midst of recognizing a match, therefore the only supported semantics is running.
                                 </p>
                              </li>
                              <li>
                                 <p>In the <code class="codeph">MEASURES</code> clause. When processing the <code class="codeph">MEASURES</code> clause, the query has finished recognizing a match; therefore, it becomes possible to consider final semantics. There are two subcases:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>If <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, then conceptually the query is positioned on the last row of the match, and there is no real difference between running versus final semantics.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, then the row pattern output table will have one row for each row of the match. In this circumstance, the user may wish to see both running and final values, so pattern matching provides the <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> keywords to support that distinction.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <p>Based on this analysis, pattern matching specifies the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>In <code class="codeph">MEASURES</code>, the keywords <code class="codeph">RUNNING</code> and <code class="codeph">FINAL</code> can be used to indicate the desired semantics for an aggregate, <code class="codeph">FIRST</code> or <code class="codeph">LAST</code>. The keyword is written before the operator, for example, <code class="codeph">RUNNING</code> <code class="codeph">COUNT</code> <code class="codeph">(A.*)</code> or <code class="codeph">FINAL</code> <code class="codeph">SUM</code> <code class="codeph">(B.Price)</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>In both <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code>, the default is <code class="codeph">RUNNING</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>In <code class="codeph">DEFINE</code>, <code class="codeph">FINAL</code> is not permitted; <code class="codeph">RUNNING</code> may be used for added clarity if desired.
                                 </p>
                              </li>
                              <li>
                                 <p>In <code class="codeph">MEASURES</code> with <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, all aggregates, <code class="codeph">FIRST</code>, and <code class="codeph">LAST</code> are computed after the last row of the match is recognized, so that the default <code class="codeph">RUNNING</code> semantics is actually no different from <code class="codeph">FINAL</code> semantics. The user may prefer to think of expressions defaulting to <code class="codeph">FINAL</code> in these cases or the user may choose to write <code class="codeph">FINAL</code> for added clarity.
                                 </p>
                              </li>
                              <li>
                                 <p>Ordinary column references have running semantics. (For <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, to get final semantics in <code class="codeph">MEASURES</code>, use the <code class="codeph">FINAL</code> <code class="codeph">LAST</code> row pattern navigation operation instead of an ordinary column reference.)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="DWHSG9196"></a><div class="props_rev_3"><a id="GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8" name="GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8"></a><h6 id="DWHSG-GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8" class="sect6"><span class="enumeration_section">21.3.9.6.3 </span>Ordinary Row Pattern Column References
                        </h6>
                        <div>
                           <p>An ordinary row pattern column reference is one that is neither aggregated nor navigated, for example:</p><pre class="oac_no_warn" dir="ltr">A.Price
</pre><p><span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2">RUNNING Versus FINAL Keywords</a>"</span> stated that ordinary row pattern column references always have running semantics. This means:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>In <code class="codeph">DEFINE</code>, an ordinary column reference references the last row that is mapped to the pattern variable, up to and including the current row. If there is no such row, then the value is null.
                                 </p>
                              </li>
                              <li>
                                 <p>In <code class="codeph">MEASURES</code>, there are two subcases:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>If <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, then there is also a notion of current row, and the semantics are the same as in <code class="codeph">DEFINE</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, then conceptually the query is positioned on the last row of the match. An ordinary column reference references the last row that is mapped to the pattern variable. If the variable is not mapped to any row, then the value is null.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <p>These semantics are the same as the <code class="codeph">LAST</code> operator, with the implicit <code class="codeph">RUNNING</code> default. Consequently, an ordinary column reference such as <code class="codeph">X.Price</code> is equivalent to <code class="codeph">RUNNING LAST (X.Price)</code>.
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9003"></a><div class="props_rev_3"><a id="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5" name="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5"></a><h4 id="DWHSG-GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5" class="sect4"><span class="enumeration_section">21.3.10 </span>Row Pattern Output
                  </h4>
                  <div>
                     <p>The result of <code class="codeph">MATCH_RECOGNIZE</code> is called the row pattern output table. The shape (row type) of the row pattern output table depends on the choice of <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> or <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>.
                     </p>
                     <p>If <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified or implied, then the columns of the row pattern output table are the row pattern partitioning columns in their order of declaration, followed by the row pattern measure columns in their order of declaration. Because a table must have at least one column, this implies that there must be at least one row pattern partitioning column or one row pattern measure column.
                     </p>
                     <p>If <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> is specified, then the columns of the row pattern output table are the row pattern partitioning columns in their order of declaration, the ordering columns in their order of declaration, the row pattern measure columns in their order of declaration, and finally any remaining columns of the row pattern input table, in the order they occur in the row pattern input table.
                     </p>
                     <p>The names and declared types of the pattern measure columns are determined by the <code class="codeph">MEASURES</code> clause. The names and declared types of the non-measure columns are inherited from the corresponding columns of the pattern input table.
                     </p>
                     <div class="infoboxnotealso" id="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5__GUID-DF5E7851-B9D4-4F1A-9BB8-19E1286ACDC6">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF">Correlation Name and Row Pattern Output</a>"</span> for information about assigning a correlation name to row pattern output
                        </p>
                     </div>
                  </div><a id="DWHSG9004"></a><div class="props_rev_3"><a id="GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF" name="GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF"></a><h5 id="DWHSG-GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF" class="sect5"><span class="enumeration_section">21.3.10.1 </span>Correlation Name and Row Pattern Output
                     </h5>
                     <div>
                        <p>A correlation name can be assigned to the row pattern output table, similar to the following:</p><pre class="oac_no_warn" dir="ltr">SELECT M.Matchno
FROM Ticker MATCH_RECOGNIZE (...
     MEASURE MATCH_NUMBER() AS Matchno
     ...
) M
</pre><p>In the preceding example, <code class="codeph">M</code> is the correlation name assigned to the row pattern output table. The benefit to assigning a correlation name is that the correlation name can be used to qualify the column names of the row pattern output table, as in <code class="codeph">M.Matchno</code> in the preceding example. This is especially important to resolve ambiguous column names if there are other tables in the <code class="codeph">FROM</code> clause.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9014"></a><div class="props_rev_3"><a id="GUID-F120C679-9C56-4703-970E-07C276EA50F1" name="GUID-F120C679-9C56-4703-970E-07C276EA50F1"></a><h3 id="DWHSG-GUID-F120C679-9C56-4703-970E-07C276EA50F1" class="sect3"><span class="enumeration_section">21.4 </span>Advanced Topics in Pattern Matching
               </h3>
               <div>
                  <p>This section discusses the following advanced topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">Nesting FIRST and LAST Within PREV and NEXT in Pattern Matching</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D">Handling Empty Matches or Unmatched Rows in Pattern Matching</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">How to Exclude Portions of the Pattern from the Output</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7">How to Express All Permutations</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9016"></a><a id="DWHSG9015"></a><div class="props_rev_3"><a id="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42" name="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42"></a><h4 id="DWHSG-GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42" class="sect4"><span class="enumeration_section">21.4.1 </span>Nesting FIRST and LAST Within PREV and NEXT in Pattern Matching
                  </h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">FIRST</code> and <code class="codeph">LAST</code> provide navigation within the set of rows already mapped to a particular pattern variable; <code class="codeph">PREV</code> and <code class="codeph">NEXT</code> provide navigation using a physical offset from a particular row. These kinds of navigation can be combined by nesting <code class="codeph">FIRST</code> or <code class="codeph">LAST</code> within <code class="codeph">PREV</code> or <code class="codeph">NEXT</code>. This permits expressions such as the following:
                        </p><pre class="oac_no_warn" dir="ltr">PREV (LAST (A.Price + A.Tax, 1), 3)
</pre><p>In this example, <code class="codeph">A</code> must be a pattern variable. It is required to have a row pattern column reference, and all pattern variables in the compound operator must be equivalent (<code class="codeph">A</code>, in this example).
                        </p>
                        <p>This compound operator is evaluated as follows:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>The inner operator, <code class="codeph">LAST</code>, operates solely on the set of rows that are mapped to the pattern variable <code class="codeph">A</code>. In this set, find the row that is <span class="italic">the last minus 1</span>. (If there is no such row, the result is null.)</span></li>
                        <li><span>The outer operator, <code class="codeph">PREV</code>, starts from the row found in Step 1 and backs up three rows in the row pattern partition. (If there is no such row, the result is null.)</span></li>
                        <li><span>Let <code class="codeph">R</code> be an implementation-dependent range variable that references the row found by Step 2. In the expression <code class="codeph">A.Price + A.Tax</code>, replace every occurrence of the pattern variable <code class="codeph">A</code> with <code class="codeph">R</code>. The resulting expression <code class="codeph">R.Price + R.Tax</code> is evaluated and determines the value of the compound navigation operation.</span></li>
                     </ol>
                     <div class="section">
                        <p>For example, consider the data set and mappings in <a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42__CACIACEJ" title="This table displays a data set and mappings to illustrate the FIRST and LAST functions in pattern matching.">Table 21-6</a>.
                        </p>
                        <div class="tblformal" id="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42__CACIACEJ">
                           <p class="titleintable">Table 21-6 Data Set and Mappings</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Data Set and Mappings" summary="This table displays a data set and mappings to illustrate the FIRST and LAST functions in pattern matching." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d80268e5125">Row</th>
                                    <th align="left" valign="bottom" width="28%" id="d80268e5128">Price</th>
                                    <th align="left" valign="bottom" width="24%" id="d80268e5131">Tax</th>
                                    <th align="left" valign="bottom" width="29%" id="d80268e5134">Mapping</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5139" headers="d80268e5125 ">
                                       <p>R1</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5139 d80268e5128 ">
                                       <p>10</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5139 d80268e5131 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5139 d80268e5134 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5151" headers="d80268e5125 ">
                                       <p>R2</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5151 d80268e5128 ">
                                       <p>20</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5151 d80268e5131 ">
                                       <p>2</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5151 d80268e5134 ">
                                       <p>A</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5164" headers="d80268e5125 ">
                                       <p>R3</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5164 d80268e5128 ">
                                       <p>30</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5164 d80268e5131 ">
                                       <p>3</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5164 d80268e5134 ">
                                       <p>B</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5177" headers="d80268e5125 ">
                                       <p>R4</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5177 d80268e5128 ">
                                       <p>40</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5177 d80268e5131 ">
                                       <p>4</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5177 d80268e5134 ">
                                       <p>A</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5190" headers="d80268e5125 ">
                                       <p>R5</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5190 d80268e5128 ">
                                       <p>50</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5190 d80268e5131 ">
                                       <p>5</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5190 d80268e5134 ">
                                       <p>C</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5203" headers="d80268e5125 ">
                                       <p>R6</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5203 d80268e5128 ">
                                       <p>60</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5203 d80268e5131 ">
                                       <p>6</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5203 d80268e5134 ">
                                       <p>A</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>To evaluate <code class="codeph">PREV (LAST (A.Price + A.Tax, 1), 3)</code>, the following steps can be used:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The set of rows mapped to <code class="codeph">A</code> is <code class="codeph">{R2, R4, R6}</code>. <code class="codeph">LAST</code> operates on this set, offsetting from the end to arrive at row <code class="codeph">R4</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PREV</code> performs a physical offset, 3 rows before <code class="codeph">R4</code>, arriving at <code class="codeph">R1</code>.
                              </p>
                           </li>
                           <li>
                              <p>Let <code class="codeph">R</code> be a range variable pointing at <code class="codeph">R1</code>. <code class="codeph">R.Price + R.Tax</code> is evaluated, giving 10+1 = 11.
                              </p>
                           </li>
                        </ul>
                        <p>Note that this nesting is not defined as a typical evaluation of nested functions. The inner operator <code class="codeph">LAST</code> does not actually evaluate the expression <code class="codeph">A.Price + A.Tax</code>; it uses this expression to designate a pattern variable <code class="codeph">(A)</code> and then navigate within the rows mapped to that variable. The outer operator <code class="codeph">PREV</code> performs a further physical navigation on rows. The expression <code class="codeph">A.Price + A.Tax</code> is not actually evaluated as such, because the row that is eventually reached is not necessarily mapped to the pattern variable <code class="codeph">A</code>. In this example, <code class="codeph">R1</code> is not mapped to any pattern variable.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9017"></a><div class="props_rev_3"><a id="GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D" name="GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D"></a><h4 id="DWHSG-GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D" class="sect4"><span class="enumeration_section">21.4.2 </span>Handling Empty Matches or Unmatched Rows in Pattern Matching
                  </h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> has three suboptions:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code></p>
                           </li>
                        </ul>
                        <p>These options are explained in the following topics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88">Handling Empty Matches in Pattern Matching</a></p>
                           </li>
                           <li>
                              <p><a href="sql-pattern-matching-data-warehouses.html#GUID-09B27A5F-0354-4D07-AC0E-FF2644732178">Handling Unmatched Rows in Pattern Matching</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG9018"></a><div class="props_rev_3"><a id="GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88" name="GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88"></a><h5 id="DWHSG-GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88" class="sect5"><span class="enumeration_section">21.4.2.1 </span>Handling Empty Matches in Pattern Matching
                     </h5>
                     <div>
                        <div class="section">
                           <p>Some patterns permit empty matches. For example, <code class="codeph">PATTERN (A*)</code> can be matched by zero or more rows that are mapped to <code class="codeph">A</code>.
                           </p>
                           <p>An empty match does not map any rows to pattern variables; nevertheless, an empty match has a starting row. For example, there can be an empty match at the first row of a partition, an empty match at the second row of a partition, and so on. An empty match is assigned a sequential match number, based on the ordinal position of its starting row, the same as any other match.</p>
                           <p>When using <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, an empty match results in one row of the output table. The row pattern measures for an empty match are computed as follows:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The value of <code class="codeph">MATCH_NUMBER()</code> is the sequential match number of the empty match.
                                 </p>
                              </li>
                              <li>
                                 <p>Any <code class="codeph">COUNT</code> is 0.
                                 </p>
                              </li>
                              <li>
                                 <p>Any other aggregate, row pattern navigation operation, or ordinary row pattern column reference is null.</p>
                              </li>
                           </ul>
                           <p>As for <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, the question arises, whether to generate a row of output for an empty match, because there are no rows in the empty match. To govern this, there are two options:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>: with this option, any empty match generates a single row in the row pattern output table.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>: with this option, an empty match is omitted from the row pattern output table. (This may cause gaps in the sequential match numbering.)
                                 </p>
                              </li>
                           </ul>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> defaults to <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>. Using this option, an empty match generates one row in the row pattern output table. In this row:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The value of the <code class="codeph">CLASSIFIER()</code> function is null.
                                 </p>
                              </li>
                              <li>
                                 <p>The value of the <code class="codeph">MATCH_NUMBER</code> <code class="codeph">()</code> function is the sequential match number of the empty match.
                                 </p>
                              </li>
                              <li>
                                 <p>The value of any ordinary row pattern column reference is null.</p>
                              </li>
                              <li>
                                 <p>The value of any aggregate or row pattern navigation operation is computed using an empty set of rows (so any <code class="codeph">COUNT</code> is 0, and all other aggregates and row pattern navigation operations are null).
                                 </p>
                              </li>
                              <li>
                                 <p>The value of any column corresponding to a column of the row pattern input table is the same as the corresponding column in the starting row of the empty match.</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9019"></a><div class="props_rev_3"><a id="GUID-09B27A5F-0354-4D07-AC0E-FF2644732178" name="GUID-09B27A5F-0354-4D07-AC0E-FF2644732178"></a><h5 id="DWHSG-GUID-09B27A5F-0354-4D07-AC0E-FF2644732178" class="sect5"><span class="enumeration_section">21.4.2.2 </span>Handling Unmatched Rows in Pattern Matching
                     </h5>
                     <div>
                        <div class="section">
                           <p>Some rows of the row pattern input table may be neither the starting row of an empty match, nor mapped by a non-empty match. Such rows are called unmatched rows.</p>
                           <p>The option <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> shows both empty matches and unmatched rows. Empty matches are handled the same as with <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>. When displaying an unmatched row, all row pattern measures are null, somewhat analogous to the null-extended side of an outer join. Thus, <code class="codeph">COUNT</code> and <code class="codeph">MATCH_NUMBER</code> may be used to distinguish an unmatched row from the starting row of an empty match. The exclusion syntax {- -} is prohibited as contrary to the spirit of <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>. See <span class="q">"<a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">How to Exclude Portions of the Pattern from the Output</a>"</span> for more information.
                           </p>
                           <p>It is not possible for a pattern to permit empty matches and also have unmatched rows. The reason is that if a row of the row pattern input table cannot be mapped to a primary row pattern variable, then that row can still be the starting row of an empty match, and will not be regarded as unmatched, assuming that the pattern permits empty matches. Thus, if a pattern permits empty matches, then the output using <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> is the same as the output using <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>. Thus <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> is primarily intended for use with patterns that do not permit empty matches. However, the user may prefer to specify <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> if the user is uncertain whether a pattern may have empty matches or unmatched rows.
                           </p>
                           <p>Note that if <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> is used with the default skipping behavior (<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code>), then there is exactly one row in the output for every row in the input.
                           </p>
                           <p>Other skipping behaviors are permitted using <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>, in which case it becomes possible for a row to be mapped by more than one match and appear in the row pattern output table multiple times. Unmatched rows will appear in the output only once.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG9021"></a><a id="DWHSG9020"></a><div class="props_rev_3"><a id="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522" name="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522"></a><h4 id="DWHSG-GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522" class="sect4"><span class="enumeration_section">21.4.3 </span>How to Exclude Portions of the Pattern from the Output
                  </h4>
                  <div>
                     <div class="section">
                        <p>When using <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> with either the <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> or <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> suboptions, rows matching a portion of the <code class="codeph">PATTERN</code> may be excluded from the row pattern output table. The excluded portion is bracketed between <code class="codeph">{-</code> and <code class="codeph">-}</code> in the <code class="codeph">PATTERN</code> clause.
                        </p>
                        <p>For example, the following example finds the longest periods of increasing prices that start with a price no less than ten.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522__GUID-3D476B17-DFB1-49AB-A1DD-A31727C6FD7E">
                        <p class="titleinexample">Example 21-8 Periods of Increasing Prices</p><pre class="oac_no_warn" dir="ltr">SELECT M.Symbol, M.Tstamp, M.Matchno, M.Classfr, M.Price, M.Avgp
FROM Ticker MATCH_RECOGNIZE (
     PARTITION BY Symbol
     ORDER BY tstamp
     MEASURES FINAL AVG(S.Price) AS Avgp,
              CLASSIFIER() AS Classfr,
              MATCH_NUMBER() AS Matchno
     ALL ROWS PER MATCH
     AFTER MATCH SKIP TO LAST B
     PATTERN ( {- A -} B+ {- C+ -} )
     SUBSET S = (A,B)
     DEFINE
        A AS A.Price &gt;= 10,
        B AS B.Price &gt; PREV(B.Price),
        C AS C.Price &lt;= PREV(C.Price)
)  M
ORDER BY symbol, tstamp;

SYMBOL     TSTAMP       MATCHNO CLAS      PRICE         AVGP
---------- --------- ---------- ---- ----------   ----------
ACME       02-APR-11          1 B            17         18.8
ACME       03-APR-11          1 B            19         18.8
ACME       04-APR-11          1 B            21         18.8
ACME       05-APR-11          1 B            25         18.8
ACME       07-APR-11          2 B            15         19.2
ACME       08-APR-11          2 B            20         19.2
ACME       09-APR-11          2 B            24         19.2
ACME       10-APR-11          2 B            25         19.2
ACME       13-APR-11          3 B            25           20
ACME       17-APR-11          4 B            14   16.6666667
ACME       18-APR-11          4 B            24   16.6666667
</pre><p>The row pattern output table will only have rows that are mapped to <code class="codeph">B</code>, the rows mapped to <code class="codeph">A</code> and <code class="codeph">C</code> will be excluded from the output. Although the excluded rows do not appear in the row pattern output table, they are not excluded from the definitions of union pattern variables, or from the calculation of scalar expressions in the <code class="codeph">DEFINE</code> or <code class="codeph">MEASURES</code>. For example, see the definitions of the primary pattern variables <code class="codeph">A</code> and <code class="codeph">C</code>, the definition of union pattern variable <code class="codeph">S</code>, or the <code class="codeph">Avgp</code> row pattern measure in the previous example.
                        </p>
                        <p>The exclusion syntax is not permitted with <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>.
                        </p>
                        <p>The exclusion syntax is permitted with <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>, though it has no effect because in this case there is only a single summary row per match.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9022"></a><div class="props_rev_3"><a id="GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7" name="GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7"></a><h4 id="DWHSG-GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7" class="sect4"><span class="enumeration_section">21.4.4 </span>How to Express All Permutations
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">PERMUTE</code> syntax may be used to express a pattern that is a permutation of simpler patterns. For example, <code class="codeph">PATTERN (PERMUTE (A, B, C))</code> is equivalent to an alternation of all permutations of three pattern variables <code class="codeph">A</code>, <code class="codeph">B</code>, and <code class="codeph">C</code>, similar to the following:
                        </p><pre class="oac_no_warn" dir="ltr">PATTERN (A B C | A C B | B A C | B C A | C A B | C B A)
</pre><p>Note that <code class="codeph">PERMUTE</code> is expanded lexicographically and that each element to permute must be comma-separated from the other elements. (In this example, because the three pattern variables <code class="codeph">A</code>, <code class="codeph">B</code>, and <code class="codeph">C</code> are listed in alphabetic order, it follows from lexicographic expansion that the expanded possibilities are also listed in alphabetic order.) This is significant because alternatives are attempted in the order written in the expansion. Thus a match to <code class="codeph">(A B C)</code> is attempted before a match to <code class="codeph">(</code><code class="codeph">A C B)</code>, and so on; the first attempt that succeeds is what can be called the "winner".
                        </p>
                        <p>As another example:</p><pre class="oac_no_warn" dir="ltr">PATTERN (PERMUTE (X{3}, B C?, D))
</pre><p>This is equivalent to the following:</p><pre class="oac_no_warn" dir="ltr">PATTERN ((X{3} B C? D)
| (X{3} D B C?)
| (B C? X{3} D)
| (B C? D X{3})
| (D X{3} B C?)
| (D B C? X{3}))
</pre><p>Note that the pattern elements "<code class="codeph">B C?</code>" are not comma-separated and so they are treated as a single unit.) 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9023"></a><div class="props_rev_3"><a id="GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6" name="GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6"></a><h3 id="DWHSG-GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6" class="sect3"><span class="enumeration_section">21.5 </span>Rules and Restrictions in Pattern Matching
               </h3>
               <div>
                  <div class="section">
                     <p>This section discusses the following rules and restrictions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484">Input Table Requirements in Pattern Matching</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0">Prohibited Nesting in the MATCH_RECOGNIZE Clause</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B58FE3AD-0285-4516-A464-8110530033B9">Concatenated MATCH_RECOGNIZE Clause</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-733B9762-654B-47D7-971F-9F1AF70E06CB">Aggregate Restrictions</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9024"></a><div class="props_rev_3"><a id="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484" name="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484"></a><h4 id="DWHSG-GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484" class="sect4"><span class="enumeration_section">21.5.1 </span>Input Table Requirements in Pattern Matching
                  </h4>
                  <div>
                     <div class="section">
                        <p>The row pattern input table is the input argument to <code class="codeph">MATCH_RECOGNIZE</code>. You can use a table or view, or a named query (defined in a <code class="codeph">WITH</code> clause). The row pattern input table can also be a derived table (also known as in-line view). For example.
                        </p><pre class="oac_no_warn" dir="ltr">FROM (SELECT S.Name, T.Tstamp, T.Price
      FROM Ticker T, SymbolNames S
      WHERE T.Symbol = S.Symbol)
MATCH_RECOGNIZE (...) M
</pre><p>The row pattern input table cannot be a joined table. The work-around is to use a derived table, such as the following:</p><pre class="oac_no_warn" dir="ltr">FROM (SELECT * FROM A LEFT OUTER JOIN B ON (A.X = B.Y))
MATCH_RECOGNIZE (...) M
</pre><p>Column names in the pattern input table must be unambiguous. If the row pattern input table is a base table or a view, this is not a problem, because SQL does not allow ambiguous column names in a base table or view. This is only an issue when the row pattern input table is a derived table. For example, consider a join of two tables, <code class="codeph">Emp</code> and <code class="codeph">Dept</code>, each of which has a column called <code class="codeph">Name</code>. The following is a syntax error:
                        </p><pre class="oac_no_warn" dir="ltr">FROM (SELECT D.Name, E.Name, E.Empno, E.Salary
      FROM Dept D, Emp E
      WHERE D.Deptno = E.Deptno)
MATCH_RECOGNIZE (
      PARTITION BY D.Name
   ...)
</pre><p>The previous example is an error because the variable <code class="codeph">D</code> is not visible within the <code class="codeph">MATCH_RECOGNIZE</code> clause (The scope of <code class="codeph">D</code> is just the derived table). Rewriting similar to the following does not help:
                        </p><pre class="oac_no_warn" dir="ltr">FROM (SELECT D.Name, E.Name, E.Empno, E.Salary
      FROM Dept D, Emp E
      WHERE D.Deptno = E.Deptno)
MATCH_RECOGNIZE (
      PARTITION BY Name
   ...)
</pre><p>This rewrite eliminates the use of the variable <code class="codeph">D</code> within the <code class="codeph">MATCH_RECOGNIZE</code> clause. However, now the error is that <code class="codeph">Name</code> is ambiguous, because there are two columns of the derived table called <code class="codeph">Name</code>. The way to handle this is to disambiguate the column names within the derived table itself, similar to the following:
                        </p><pre class="oac_no_warn" dir="ltr">FROM (SELECT D.Name AS Dname, E.Name AS Ename,
         E.Empno, E.Salary
      FROM Dept D, Emp E
      WHERE D.Deptno = E.Deptno)
MATCH_RECOGNIZE (
      PARTITION BY Dname
   ...)
</pre><div class="infoboxnotealso" id="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484__GUID-E828B32B-A8A8-4502-86E8-59003DE9D9F3">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/Pattern-matching-Conditions.html#SQLRF52141" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9025"></a><div class="props_rev_3"><a id="GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0" name="GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0"></a><h4 id="DWHSG-GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0" class="sect4"><span class="enumeration_section">21.5.2 </span>Prohibited Nesting in the MATCH_RECOGNIZE Clause
                  </h4>
                  <div>
                     <div class="section">
                        <p>The following kinds of nesting are prohibited in the <code class="codeph">MATCH_RECOGNIZE</code> clause:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Nesting one <code class="codeph">MATCH_RECOGNIZE</code> clause within another.
                              </p>
                           </li>
                           <li>
                              <p>Outer references in the <code class="codeph">MEASURES</code> clause or the <code class="codeph">DEFINE</code> subclause. This means that a <code class="codeph">MATCH_RECOGNIZE</code> clause cannot reference any table in an outer query block except the row pattern input table.
                              </p>
                           </li>
                           <li>
                              <p>Correlated subqueries cannot be used in <code class="codeph">MEASURES</code> or <code class="codeph">DEFINE</code>. Also, subqueries in <code class="codeph">MEASURES</code> or <code class="codeph">DEFINE</code> cannot reference pattern variables.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">MATCH_RECOGNIZE</code> clause cannot be used in recursive queries.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> statement cannot use the <code class="codeph">MATCH_RECOGNIZE</code> clause.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9026"></a><div class="props_rev_3"><a id="GUID-B58FE3AD-0285-4516-A464-8110530033B9" name="GUID-B58FE3AD-0285-4516-A464-8110530033B9"></a><h4 id="DWHSG-GUID-B58FE3AD-0285-4516-A464-8110530033B9" class="sect4"><span class="enumeration_section">21.5.3 </span>Concatenated MATCH_RECOGNIZE Clause
                  </h4>
                  <div>
                     <div class="section">
                        <p>Note that it is not prohibited to feed the output of one <code class="codeph">MATCH_RECOGNIZE</code> clause into the input of another, as in this example:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT ...
FROM ( SELECT *
       FROM Ticker
            MATCH_RECOGNIZE (...) )
       MATCH_RECOGNIZE (...)
</pre><p>In this example, the first <code class="codeph">MATCH_RECOGNIZE</code> clause is in a derived table, which then provides the input to the second <code class="codeph">MATCH_RECOGNIZE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9027"></a><div class="props_rev_3"><a id="GUID-733B9762-654B-47D7-971F-9F1AF70E06CB" name="GUID-733B9762-654B-47D7-971F-9F1AF70E06CB"></a><h4 id="DWHSG-GUID-733B9762-654B-47D7-971F-9F1AF70E06CB" class="sect4"><span class="enumeration_section">21.5.4 </span>Aggregate Restrictions
                  </h4>
                  <div>
                     <div class="section">
                        <p>The aggregate functions <code class="codeph">COUNT</code>, <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">MAX</code>, and <code class="codeph">MIN</code> can be used in both the <code class="codeph">MEASURES</code> and <code class="codeph">DEFINE</code> clauses. The <code class="codeph">DISTINCT</code> keyword is not supported.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9028"></a><div class="props_rev_3"><a id="GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75" name="GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75"></a><h3 id="DWHSG-GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75" class="sect3"><span class="enumeration_section">21.6 </span>Examples of Pattern Matching
               </h3>
               <div>
                  <div class="section">
                     <p>This section contains the following types of advanced pattern matching examples:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4">Pattern Matching Examples: Stock Market</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219">Pattern Matching Examples: Security Log Analysis</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8">Pattern Matching Examples: Sessionization</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD">Pattern Matching Example: Financial Tracking</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9030"></a><a id="DWHSG9031"></a><a id="DWHSG9032"></a><a id="DWHSG9033"></a><a id="DWHSG9034"></a><a id="DWHSG9035"></a><a id="DWHSG9036"></a><a id="DWHSG9029"></a><div class="props_rev_3"><a id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4" name="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4"></a><h4 id="DWHSG-GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4" class="sect4"><span class="enumeration_section">21.6.1 </span>Pattern Matching Examples: Stock Market
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section contains pattern matching examples that are based on common tasks involving share prices and patterns.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">
                        <p class="titleinexample">Example 21-9 Price Dips of a Specified Magnitude</p>
                        <p>The query in <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">Example 21-9</a> shows stocks where the current price is more than a specific percentage (in this example 8%) below the prior day's closing price.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Ticker3Wave (SYMBOL VARCHAR2(10), tstamp DATE, PRICE NUMBER);
 
INSERT INTO Ticker3Wave VALUES('ACME', '01-Apr-11', 1000);
INSERT INTO Ticker3Wave VALUES('ACME', '02-Apr-11', 775);
INSERT INTO Ticker3Wave VALUES('ACME', '03-Apr-11', 900);
INSERT INTO Ticker3Wave VALUES('ACME', '04-Apr-11', 775);
INSERT INTO Ticker3Wave VALUES('ACME', '05-Apr-11', 900);
INSERT INTO Ticker3Wave VALUES('ACME', '06-Apr-11', 775);
INSERT INTO Ticker3Wave VALUES('ACME', '07-Apr-11', 900);
INSERT INTO Ticker3Wave VALUES('ACME', '08-Apr-11', 775);
INSERT INTO Ticker3Wave VALUES('ACME', '09-Apr-11', 800);
INSERT INTO Ticker3Wave VALUES('ACME', '10-Apr-11', 550);
INSERT INTO Ticker3Wave VALUES('ACME', '11-Apr-11', 900);
INSERT INTO Ticker3Wave VALUES('ACME', '12-Apr-11', 800);
INSERT INTO Ticker3Wave VALUES('ACME', '13-Apr-11', 1100);
INSERT INTO Ticker3Wave VALUES('ACME', '14-Apr-11', 800);
INSERT INTO Ticker3Wave VALUES('ACME', '15-Apr-11', 550);
INSERT INTO Ticker3Wave VALUES('ACME', '16-Apr-11', 800);
INSERT INTO Ticker3Wave VALUES('ACME', '17-Apr-11', 875);
INSERT INTO Ticker3Wave VALUES('ACME', '18-Apr-11', 950);
INSERT INTO Ticker3Wave VALUES('ACME', '19-Apr-11', 600);
INSERT INTO Ticker3Wave VALUES('ACME', '20-Apr-11', 300);
 
SELECT *
FROM Ticker3Wave MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES B.tstamp AS timestamp,
              A.price AS Aprice,
              B.price AS Bprice,
              ((B.price - A.price)*100) / A.price AS PctDrop
    ONE ROW PER MATCH
    AFTER MATCH SKIP TO B
    PATTERN (A B)
    DEFINE
       B AS (B.price - A.price) / A.price  &lt; -0.08
   );
 
SYMBOL  TIMESTAMP    APRICE     BPRICE    PCTDROP
------  ---------  ---------- -------   ----------
ACME    02-APR-11  1000           775        -22.5
ACME    04-APR-11   900           775   -13.888889
ACME    06-APR-11   900           775   -13.888889
ACME    08-APR-11   900           775   -13.888889
ACME    10-APR-11   800           550   -31.25
ACME    12-APR-11   900           800   -11.111111
ACME    14-APR-11  1100           800   -27.272727
ACME    15-APR-11   800           550   -31.25
ACME    19-APR-11   950           600   -36.842105
ACME    20-APR-11   600           300   -50.0

10 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACCFCAF">
                        <p class="titleinexample">Example 21-10 Prices Dips of Specified Magnitude When They Have Returned to the Original Price</p>
                        <p>The query in <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACCFCAF">Example 21-10</a> extends the pattern defined in <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">Example 21-9</a>. It finds a stock with a price drop of more than 8%. It also seeks zero or more additional days when the stock price remains below the original price. Then, it identifies when the stock has risen in price to equal or exceed its initial value. Because it can be useful to know the number of days that the pattern occurs, it is included here. The <code class="codeph">start_price</code> column is the starting price of a match and the <code class="codeph">end_price</code> column is the end price of a match, when the price is equal to or greater than the start price.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * 
 FROM Ticker3Wave MATCH_RECOGNIZE (
   PARTITION BY symbol 
   ORDER BY tstamp 
   MEASURES
      A.tstamp      as start_timestamp,
      A.price       as start_price,
      B.price       as drop_price, 
      COUNT(C.*)+1  as cnt_days,
      D.tstamp      as end_timestamp, 
      D.price       as end_price   
   ONE ROW PER MATCH 
   AFTER MATCH SKIP PAST LAST ROW 
   PATTERN (A B C* D) 
   DEFINE
      B as (B.price - A.price)/A.price &lt; -0.08, 
      C as C.price &lt; A.price, 
      D as D.price &gt;= A.price
   );
 
SYMBOL     START_TIM START_PRICE DROP_PRICE  CNT_DAYS  END_TIMES  END_PRICE
---------- --------- ----------- ----------  --------  --------- ----------
ACME       01-APR-11        1000        775        11  13-APR-11       1100
ACME       14-APR-11         800        550         1  16-APR-11        800</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGJACI">
                        <p class="titleinexample">Example 21-11 Find both V and U Shapes in Trading History</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGJACI">Example 21-11</a> shows how important it is to take all possible data behavior into account when defining a pattern. The table <code class="codeph">TickerVU</code> is just like the first example's table <code class="codeph">Ticker</code>, except that it has two equal-price days in a row at the low point of its third bottom, April 16 and 17. This sort of flat bottom price drop is called a U-shape. Can the original example, <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a>, recognize that the modified data is a lot like a V-shape, and include the U-shape in its output? No, the query needs to be modified as shown.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE TickerVU (SYMBOL VARCHAR2(10), tstamp DATE, PRICE NUMBER);

INSERT INTO TickerVU values('ACME', '01-Apr-11', 12);
INSERT INTO TickerVU values('ACME', '02-Apr-11', 17);
INSERT INTO TickerVU values('ACME', '03-Apr-11', 19);
INSERT INTO TickerVU values('ACME', '04-Apr-11', 21);
INSERT INTO TickerVU values('ACME', '05-Apr-11', 25);
INSERT INTO TickerVU values('ACME', '06-Apr-11', 12);
INSERT INTO TickerVU values('ACME', '07-Apr-11', 15);
INSERT INTO TickerVU values('ACME', '08-Apr-11', 20);
INSERT INTO TickerVU values('ACME', '09-Apr-11', 24);
INSERT INTO TickerVU values('ACME', '10-Apr-11', 25);
INSERT INTO TickerVU values('ACME', '11-Apr-11', 19);
INSERT INTO TickerVU values('ACME', '12-Apr-11', 15);
INSERT INTO TickerVU values('ACME', '13-Apr-11', 25);
INSERT INTO TickerVU values('ACME', '14-Apr-11', 25);
INSERT INTO TickerVU values('ACME', '15-Apr-11', 14);
INSERT INTO TickerVU values('ACME', '16-Apr-11', 12);
INSERT INTO TickerVU values('ACME', '17-Apr-11', 12);
INSERT INTO TickerVU values('ACME', '18-Apr-11', 24);
INSERT INTO TickerVU values('ACME', '19-Apr-11', 23);
INSERT INTO TickerVU values('ACME', '20-Apr-11', 22);
 </pre><p>What happens if you run your original query of <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">Example 21-1</a>, modified to use this table name?
                        </p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM TickerVU MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES STRT.tstamp AS start_tstamp,
              DOWN.tstamp AS bottom_tstamp,
              UP.tstamp AS end_tstamp
    ONE ROW PER MATCH
    AFTER MATCH SKIP TO LAST UP
    PATTERN (STRT DOWN+ UP+)
    DEFINE DOWN AS DOWN.price &lt; PREV(DOWN.price),
           UP AS UP.price &gt; PREV(UP.price)
) MR
ORDER BY MR.symbol, MR.start_tstamp;
 
SYMBOL     START_TST BOTTOM_TS END_TSTAM
---------- --------- --------- ---------
ACME       05-APR-11 06-APR-11 10-APR-11
ACME       10-APR-11 12-APR-11 13-APR-11
</pre><p>Instead of showing three rows of output (one per price drop), the query shows only two. This happens because no variable was defined to handle a flat stretch of data at the bottom of a price dip. Now, use a modified version of this query, adding a variable for flat data in the <code class="codeph">DEFINE</code> clause and using that variable in the <code class="codeph">PATTERN</code> clause.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT *
FROM TickerVU MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES STRT.tstamp AS start_tstamp,
              DOWN.tstamp AS bottom_tstamp,
              UP.tstamp AS end_tstamp
     ONE ROW PER MATCH
     AFTER MATCH SKIP TO LAST UP
     PATTERN (STRT DOWN+ FLAT* UP+)
     DEFINE
         DOWN AS DOWN.price &lt; PREV(DOWN.price),
         FLAT AS FLAT.price = PREV(FLAT.price),
         UP AS UP.price &gt; PREV(UP.price)
) MR
ORDER BY MR.symbol, MR.start_tstamp;
 
SYMBOL     START_TST   BOTTOM_TS   END_TSTAM
---------- ---------   ---------   ---------
ACME       05-APR-11   06-APR-11   10-APR-11
ACME       10-APR-11   12-APR-11   13-APR-11
ACME       14-APR-11   16-APR-11   18-APR-11
</pre><p>Now, you get output that includes all three price dips in the data. The lesson here is to consider all possible variations in your data sequence and include those possibilities in your <code class="codeph">PATTERN</code>, <code class="codeph">DEFINE</code>, and <code class="codeph">MEASURES</code> clauses as needed.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">
                        <p class="titleinexample">Example 21-12 Finding Elliott Wave Pattern: Multiple Instances of Inverted-V</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">Example 21-12</a> shows a simple version of a class of stock price patterns referred to as the Elliott Wave which has multiple consecutive patterns of inverted V-shapes. In this particular case, the pattern expression searches for 1 or more days up followed by 1 or more days down, and this sequence must appear five times consecutively with no gaps. That is, the pattern looks similar to:   /\/\/\/\/\.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_ELLIOTT.*
FROM Ticker3Wave MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES
              COUNT(*) as CNT,
              COUNT(P.*) AS CNT_P,
              COUNT(Q.*) AS CNT_Q,
              COUNT(R.*) AS CNT_R,
              COUNT(S.*) AS CNT_S,
              COUNT(T.*) AS CNT_T,
              COUNT(U.*) AS CNT_U,
              COUNT(V.*) AS CNT_V,
              COUNT(W.*) AS CNT_W,
              COUNT(X.*) AS CNT_X,
              COUNT(Y.*) AS CNT_Y,
              COUNT(Z.*) AS CNT_Z,
              CLASSIFIER() AS CLS,
     MATCH_NUMBER() AS MNO
     ALL ROWS PER MATCH
     AFTER MATCH SKIP TO LAST Z
     PATTERN (P Q+ R+ S+ T+ U+ V+ W+ X+ Y+ Z+)
     DEFINE
        Q AS Q.price &gt; PREV(Q.price),
        R AS R.price &lt; PREV(R.price),
        S AS S.price &gt; PREV(S.price),
        T AS T.price &lt; PREV(T.price),
        U AS U.price &gt; PREV(U.price),
        V AS V.price &lt; PREV(V.price),
        W AS W.price &gt; PREV(W.price),
        X AS X.price &lt; PREV(X.price),
        Y AS Y.price &gt; PREV(Y.price),
        Z AS Z.price &lt; PREV(Z.price)
   ) MR_ELLIOTT
ORDER BY symbol, tstamp;
</pre><pre class="oac_no_warn" dir="ltr">SYMB TSTAMP    CNT  CNT_P CNT_Q CNT_R CNT_S CNT_T CNT_U CNT_V CNT_W CNT_X CNT_Y CNT_Z CLS MNO PRICE
---- --------- ---- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- --- --- -----
ACME 02-APR-11    1     1     0     0     0     0     0     0     0     0     0     0 P     1   775
ACME 03-APR-11    2     1     1     0     0     0     0     0     0     0     0     0 Q     1   900
ACME 04-APR-11    3     1     1     1     0     0     0     0     0     0     0     0 R     1   775
ACME 05-APR-11    4     1     1     1     1     0     0     0     0     0     0     0 S     1   900
ACME 06-APR-11    5     1     1     1     1     1     0     0     0     0     0     0 T     1   775
ACME 07-APR-11    6     1     1     1     1     1     1     0     0     0     0     0 U     1   900
ACME 08-APR-11    7     1     1     1     1     1     1     1     0     0     0     0 V     1   775
ACME 09-APR-11    8     1     1     1     1     1     1     1     1     0     0     0 W     1   800
ACME 10-APR-11    9     1     1     1     1     1     1     1     1     1     0     0 X     1   550
ACME 11-APR-11   10     1     1     1     1     1     1     1     1     1     1     0 Y     1   900
ACME 12-APR-11   11     1     1     1     1     1     1     1     1     1     1     1 Z     1   800
 
11 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJEHCH">
                        <p class="titleinexample">Example 21-13 Finding Elliott Waves and Specifying a Range of Acceptable Row Counts</p>
                        <p>Similar to <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">Example 21-12</a>, <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJEHCH">Example 21-13</a> specifies an Elliott Wave of inverted Vs. However, in this case, regular expressions are used to specify for each pattern variable the number of consecutive rows to match, and it is specified as a range. Set each pattern variable to seek three or four consecutive matches, using the syntax <code class="codeph">"{3,4}"</code>. The output shows all rows for one full match of the pattern and lets you see exactly when each pattern variable has its beginning and end. Note that variables <code class="codeph">W</code> and <code class="codeph">X</code> each have four rows which match, while variables <code class="codeph">Y</code> and <code class="codeph">Z</code> each have only three rows matching.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE tickerwavemulti (symbol VARCHAR2(10), tstamp DATE, price NUMBER);

INSERT INTO tickerwavemulti VALUES('ACME', '01-May-10', 36.25 );
INSERT INTO tickerwavemulti VALUES('BLUE', '01-May-10', 177.85);
INSERT INTO tickerwavemulti VALUES('EDGY', '01-May-10', 27.18);
INSERT INTO tickerwavemulti VALUES('ACME', '02-May-10', 36.47);
INSERT INTO tickerwavemulti VALUES('BLUE', '02-May-10', 177.25);
INSERT INTO tickerwavemulti VALUES('EDGY', '02-May-10', 27.41);
INSERT INTO tickerwavemulti VALUES('ACME', '03-May-10', 36.36);
INSERT INTO tickerwavemulti VALUES('BLUE', '03-May-10', 176.16);
INSERT INTO tickerwavemulti VALUES('EDGY', '03-May-10', 27.43);
INSERT INTO tickerwavemulti VALUES('ACME', '04-May-10', 36.25);
INSERT INTO tickerwavemulti VALUES('BLUE', '04-May-10', 176.28);
INSERT INTO tickerwavemulti VALUES('EDGY', '04-May-10', 27.56);
INSERT INTO tickerwavemulti VALUES('ACME', '05-May-10', 36.36);
INSERT INTO tickerwavemulti VALUES('BLUE', '05-May-10', 177.72);
INSERT INTO tickerwavemulti VALUES('EDGY', '05-May-10', 27.31);
INSERT INTO tickerwavemulti VALUES('ACME', '06-May-10', 36.70);
INSERT INTO tickerwavemulti VALUES('BLUE', '06-May-10', 178.36);
INSERT INTO tickerwavemulti VALUES('EDGY', '06-May-10', 27.23);
INSERT INTO tickerwavemulti VALUES('ACME', '07-May-10', 36.50);
INSERT INTO tickerwavemulti VALUES('BLUE', '07-May-10', 178.93);
INSERT INTO tickerwavemulti VALUES('EDGY', '07-May-10', 27.08);
INSERT INTO tickerwavemulti VALUES('ACME', '08-May-10', 36.66);
INSERT INTO tickerwavemulti VALUES('BLUE', '08-May-10', 178.18);
INSERT INTO tickerwavemulti VALUES('EDGY', '08-May-10', 26.90);
INSERT INTO tickerwavemulti VALUES('ACME', '09-May-10', 36.98);
INSERT INTO tickerwavemulti VALUES('BLUE', '09-May-10', 179.15);
INSERT INTO tickerwavemulti VALUES('EDGY', '09-May-10', 26.73);
INSERT INTO tickerwavemulti VALUES('ACME', '10-May-10', 37.08);
INSERT INTO tickerwavemulti VALUES('BLUE', '10-May-10', 180.39);
INSERT INTO tickerwavemulti VALUES('EDGY', '10-May-10', 26.86);
INSERT INTO tickerwavemulti VALUES('ACME', '11-May-10', 37.43);
INSERT INTO tickerwavemulti VALUES('BLUE', '11-May-10', 181.44);
INSERT INTO tickerwavemulti VALUES('EDGY', '11-May-10', 26.78);
INSERT INTO tickerwavemulti VALUES('ACME', '12-May-10', 37.68);
INSERT INTO tickerwavemulti VALUES('BLUE', '12-May-10', 183.11);
INSERT INTO tickerwavemulti VALUES('EDGY', '12-May-10', 26.59);
INSERT INTO tickerwavemulti VALUES('ACME', '13-May-10', 37.66);
INSERT INTO tickerwavemulti VALUES('BLUE', '13-May-10', 181.50);
INSERT INTO tickerwavemulti VALUES('EDGY', '13-May-10', 26.39);
INSERT INTO tickerwavemulti VALUES('ACME', '14-May-10', 37.32);
INSERT INTO tickerwavemulti VALUES('BLUE', '14-May-10', 180.65);
INSERT INTO tickerwavemulti VALUES('EDGY', '14-May-10', 26.31);
INSERT INTO tickerwavemulti VALUES('ACME', '15-May-10', 37.16);
INSERT INTO tickerwavemulti VALUES('BLUE', '15-May-10', 179.51);
INSERT INTO tickerwavemulti VALUES('EDGY', '15-May-10', 26.53);
INSERT INTO tickerwavemulti VALUES('ACME', '16-May-10', 36.98);
INSERT INTO tickerwavemulti VALUES('BLUE', '16-May-10', 180.00);
INSERT INTO tickerwavemulti VALUES('EDGY', '16-May-10', 26.76);
INSERT INTO tickerwavemulti VALUES('ACME', '17-May-10', 37.19);
INSERT INTO tickerwavemulti VALUES('BLUE', '17-May-10', 179.24);
INSERT INTO tickerwavemulti VALUES('EDGY', '17-May-10', 26.63);
INSERT INTO tickerwavemulti VALUES('ACME', '18-May-10', 37.45);
INSERT INTO tickerwavemulti VALUES('BLUE', '18-May-10', 180.48);
INSERT INTO tickerwavemulti VALUES('EDGY', '18-May-10', 26.84);
INSERT INTO tickerwavemulti VALUES('ACME', '19-May-10', 37.79);
INSERT INTO tickerwavemulti VALUES('BLUE', '19-May-10', 181.21);
INSERT INTO tickerwavemulti VALUES('EDGY', '19-May-10', 26.90);
INSERT INTO tickerwavemulti VALUES('ACME', '20-May-10', 37.49);
INSERT INTO tickerwavemulti VALUES('BLUE', '20-May-10', 179.79);
INSERT INTO tickerwavemulti VALUES('EDGY', '20-May-10', 27.06);
INSERT INTO tickerwavemulti VALUES('ACME', '21-May-10', 37.30);
INSERT INTO tickerwavemulti VALUES('BLUE', '21-May-10', 181.19);
INSERT INTO tickerwavemulti VALUES('EDGY', '21-May-10', 27.17);
INSERT INTO tickerwavemulti VALUES('ACME', '22-May-10', 37.08);
INSERT INTO tickerwavemulti VALUES('BLUE', '22-May-10', 179.88);
INSERT INTO tickerwavemulti VALUES('EDGY', '22-May-10', 26.95);
INSERT INTO tickerwavemulti VALUES('ACME', '23-May-10', 37.34);
INSERT INTO tickerwavemulti VALUES('BLUE', '23-May-10', 181.21);
INSERT INTO tickerwavemulti VALUES('EDGY', '23-May-10', 26.71);
INSERT INTO tickerwavemulti VALUES('ACME', '24-May-10', 37.54);
INSERT INTO tickerwavemulti VALUES('BLUE', '24-May-10', 181.94);
INSERT INTO tickerwavemulti VALUES('EDGY', '24-May-10', 26.96);
INSERT INTO tickerwavemulti VALUES('ACME', '25-May-10', 37.69);
INSERT INTO tickerwavemulti VALUES('BLUE', '25-May-10', 180.88);
INSERT INTO tickerwavemulti VALUES('EDGY', '25-May-10', 26.72);
INSERT INTO tickerwavemulti VALUES('ACME', '26-May-10', 37.60);
INSERT INTO tickerwavemulti VALUES('BLUE', '26-May-10', 180.72);
INSERT INTO tickerwavemulti VALUES('EDGY', '26-May-10', 26.47);
INSERT INTO tickerwavemulti VALUES('ACME', '27-May-10', 37.93);
INSERT INTO tickerwavemulti VALUES('BLUE', '27-May-10', 181.54);
INSERT INTO tickerwavemulti VALUES('EDGY', '27-May-10', 26.73);
INSERT INTO tickerwavemulti VALUES('ACME', '28-May-10', 38.17);
INSERT INTO tickerwavemulti VALUES('BLUE', '28-May-10', 182.93);
INSERT INTO tickerwavemulti VALUES('EDGY', '28-May-10', 26.89);
  
SELECT MR_EW.*
FROM tickerwavemulti MATCH_RECOGNIZE (
     PARTITION by symbol
     ORDER by tstamp
     MEASURES V.tstamp AS START_T,
              Z.tstamp AS END_T,
              COUNT(V.price) AS CNT_V,
              COUNT(W.price) AS UP__W,
              COUNT(X.price) AS DWN_X,
              COUNT(Y.price) AS UP__Y,
              COUNT(Z.price) AS DWN_Z,
    MATCH_NUMBER() AS MNO
    ALL ROWS PER MATCH
    AFTER MATCH SKIP TO LAST Z
    PATTERN (V W{3,4} X{3,4} Y{3,4} Z{3,4})
    DEFINE
       W AS W.price &gt; PREV(W.price),
       X AS X.price &lt; PREV(X.price),
       Y AS Y.price &gt; PREV(Y.price),
       Z AS Z.price &lt; PREV(Z.price)
) MR_EW
ORDER BY symbol, tstamp;

SYMB TSTAMP    START_T   END_T     CNT_V UP__W DWN_X UP__Y DWN_Z   MNO   PRICE
---- --------- --------- --------- ----- ----- ----- ----- ----- ----- -------
ACME 08-MAY-10 08-MAY-10               1     0     0     0     0     1   36.66
ACME 09-MAY-10 08-MAY-10               1     1     0     0     0     1   36.98
ACME 10-MAY-10 08-MAY-10               1     2     0     0     0     1   37.08
ACME 11-MAY-10 08-MAY-10               1     3     0     0     0     1   37.43
ACME 12-MAY-10 08-MAY-10               1     4     0     0     0     1   37.68
ACME 13-MAY-10 08-MAY-10               1     4     1     0     0     1   37.66
ACME 14-MAY-10 08-MAY-10               1     4     2     0     0     1   37.32
ACME 15-MAY-10 08-MAY-10               1     4     3     0     0     1   37.16
ACME 16-MAY-10 08-MAY-10               1     4     4     0     0     1   36.98
ACME 17-MAY-10 08-MAY-10               1     4     4     1     0     1   37.19
ACME 18-MAY-10 08-MAY-10               1     4     4     2     0     1   37.45
ACME 19-MAY-10 08-MAY-10               1     4     4     3     0     1   37.79
ACME 20-MAY-10 08-MAY-10 20-MAY-10     1     4     4     3     1     1   37.49
ACME 21-MAY-10 08-MAY-10 21-MAY-10     1     4     4     3     2     1   37.30
ACME 22-MAY-10 08-MAY-10 22-MAY-10     1     4     4     3     3     1   37.08
</pre><pre class="oac_no_warn" dir="ltr">15 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACBDBHA">
                        <p class="titleinexample">Example 21-14 Skipping into the Middle of a Match to Check for Overlapping Matches</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACBDBHA">Example 21-14</a> highlights the power of the <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> clause to find overlapping matches. It has a simple pattern that seeks a W-shape made up of pattern variables <code class="codeph">Q</code>, <code class="codeph">R</code>, <code class="codeph">S</code>, and <code class="codeph">T</code>. For each leg of the W, the number of rows can be one or more. The match also takes advantage of the <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> clause: when a match is found, it will skip forward only to the last <code class="codeph">R</code> value, which is the midpoint of the W-shape. This enables the query to find matches in the W-shape where the second half of a W-shape is the first half of a following overlapped W-shape. In the following output, you can see that match one ends on April 5, but match two overlaps and begins on April 3.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_W.*
FROM Ticker3Wave MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES 
        MATCH_NUMBER() AS MNO,
        P.tstamp AS START_T,
        T.tstamp AS END_T,
        MAX(P.price) AS TOP_L,
        MIN(Q.price) AS BOTT1,
        MAX(R.price) AS TOP_M,
        MIN(S.price) AS BOTT2,
        MAX(T.price) AS TOP_R
     ALL ROWS PER MATCH
     AFTER MATCH SKIP TO LAST R
     PATTERN ( P Q+ R+ S+ T+ )
     DEFINE
        Q AS Q.price &lt; PREV(Q.price),
        R AS R.price &gt; PREV(R.price),
        S AS S.price &lt; PREV(S.price),
        T AS T.price &gt; PREV(T.price)
) MR_W
ORDER BY symbol, mno, tstamp;

SYMB TSTAMP      MNO START_T   END_T     TOP_L BOTT1 TOP_M BOTT2 TOP_R PRICE
---- --------- ----- --------- --------- ----- ----- ----- ----- ----- -----
ACME 01-APR-11     1 01-APR-11            1000                          1000
ACME 02-APR-11     1 01-APR-11            1000   775                     775
ACME 03-APR-11     1 01-APR-11            1000   775   900               900
ACME 04-APR-11     1 01-APR-11            1000   775   900   775         775
ACME 05-APR-11     1 01-APR-11 05-APR-11  1000   775   900   775   900   900
ACME 03-APR-11     2 03-APR-11             900                           900
ACME 04-APR-11     2 03-APR-11             900   775                     775
ACME 05-APR-11     2 03-APR-11             900   775   900               900
ACME 06-APR-11     2 03-APR-11             900   775   900   775         775
ACME 07-APR-11     2 03-APR-11 07-APR-11   900   775   900   775   900   900
ACME 05-APR-11     3 05-APR-11             900                           900
ACME 06-APR-11     3 05-APR-11             900   775                     775
ACME 07-APR-11     3 05-APR-11             900   775   900               900
ACME 08-APR-11     3 05-APR-11             900   775   900   775         775
ACME 09-APR-11     3 05-APR-11 09-APR-11   900   775   900   775   800   800
ACME 07-APR-11     4 07-APR-11             900                           900
ACME 08-APR-11     4 07-APR-11             900   775                     775
ACME 09-APR-11     4 07-APR-11             900   775   800               800
ACME 10-APR-11     4 07-APR-11             900   775   800   550         550
ACME 11-APR-11     4 07-APR-11 11-APR-11   900   775   800   550   900   900
ACME 09-APR-11     5 09-APR-11             800                           800
ACME 10-APR-11     5 09-APR-11             800   550                     550
ACME 11-APR-11     5 09-APR-11             800   550   900               900
ACME 12-APR-11     5 09-APR-11             800   550   900   800         800
ACME 13-APR-11     5 09-APR-11 13-APR-11   800   550   900   800  1100  1100
ACME 11-APR-11     6 11-APR-11             900                           900
ACME 12-APR-11     6 11-APR-11             900   800                     800
ACME 13-APR-11     6 11-APR-11             900   800  1100              1100
ACME 14-APR-11     6 11-APR-11             900   800  1100   800         800
ACME 15-APR-11     6 11-APR-11             900   800  1100   550         550
ACME 16-APR-11     6 11-APR-11 16-APR-11   900   800  1100   550   800   800
ACME 17-APR-11     6 11-APR-11 17-APR-11   900   800  1100   550   875   875
ACME 18-APR-11     6 11-APR-11 18-APR-11   900   800  1100   550   950   950
 
33 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACEHIDF">
                        <p class="titleinexample">Example 21-15 Find Large Transactions Occurring Within a Specified Time Interval</p>
                        <p>In <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACEHIDF">Example 21-15</a>, you find stocks which have heavy trading, that is, large transactions in a concentrated period. In this example, heavy trading is defined as three transactions occurring in a single hour where each transaction was for more than 30,000 shares. Note that it is essential to include a pattern variable such as <code class="codeph">B</code>, so the pattern can accept the trades that do not meet the condition. Without the <code class="codeph">B</code> variable, the pattern would only match cases where there were three consecutive transactions meeting the conditions.
                        </p>
                        <p>The query in this example uses table <code class="codeph">stockT04</code>.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE STOCKT04 (symbol varchar2(10), tstamp TIMESTAMP, 
                       price NUMBER, volume NUMBER);
 
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.00.00.000000 PM', 35, 35000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.05.00.000000 PM', 35, 15000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.10.00.000000 PM', 35,  5000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.11.00.000000 PM', 35, 42000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.16.00.000000 PM', 35,  7000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.19.00.000000 PM', 35,  5000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.20.00.000000 PM', 35,  5000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.33.00.000000 PM', 35, 55000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.36.00.000000 PM', 35, 15000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.48.00.000000 PM', 35, 15000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 12.59.00.000000 PM', 35, 15000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 01.09.00.000000 PM', 35, 55000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 01.19.00.000000 PM', 35, 55000);
INSERT INTO STOCKT04 VALUES('ACME', '01-Jan-10 01.29.00.000000 PM', 35, 15000);
  
SELECT *
FROM stockT04 MATCH_RECOGNIZE (
     PARTITION BY symbol
     ORDER BY tstamp
     MEASURES FIRST (A.tstamp) AS in_hour_of_trade,
              SUM (A.volume) AS sum_of_large_volumes
     ONE ROW PER MATCH
     AFTER MATCH SKIP PAST LAST ROW
     PATTERN (A B* A B* A)
     DEFINE
        A AS ((A.volume &gt; 30000) AND 
        ((A.tstamp - FIRST (A.tstamp)) &lt; '0    01:00:00.00' )),
        B AS ((B.volume &lt;= 30000) AND ((B.tstamp - FIRST (A.tstamp)) &lt; '0
        01:00:00.00'))
);
 
SYMBOL IN_HOUR_OF_TRADE                SUM_OF_LARGE_VOLUMES
------ -----------------------------   --------------------
ACME    01-JAN-10 12.00.00.000000 PM                 132000

1 row selected.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9038"></a><a id="DWHSG9039"></a><a id="DWHSG9040"></a><a id="DWHSG9037"></a><div class="props_rev_3"><a id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219" name="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219"></a><h4 id="DWHSG-GUID-C261911B-CDFC-47C8-8692-BA9301C6E219" class="sect4"><span class="enumeration_section">21.6.2 </span>Pattern Matching Examples: Security Log Analysis
                  </h4>
                  <div>
                     <div class="section">
                        <p>The examples in this section deal with a computer system that issues error messages and authentication checks, and stores the events in a system file. To determine if there are security issues and other problems, you want to analyze the system file. This activity is also referred to as log combing because the software combs through the file to find items of concern. Note that the source data for these examples is not shown because it would use too much space. In these examples, the <code class="codeph">AUTHENLOG</code> table comes from the log file.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACCHHEA">
                        <p class="titleinexample">Example 21-16 Four or More Consecutive Identical Messages</p>
                        <p>The query in this example seeks occurrences of four or more consecutive identical messages from a set of three possible <code class="codeph">'errtype'</code> values: <code class="codeph">error</code>, <code class="codeph">notice</code>, and <code class="codeph">warn</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_SEC.ERRTYPE,
       MR_SEC.MNO     AS Pattern,
       MR_SEC.CNT     AS Count,
       SUBSTR(MR_SEC.MSG_W, 1, 30)   AS Message,
       MR_SEC.START_T AS Starting_on,
       MR_SEC.END_T   AS Ending_on
FROM AUTHENLOG
MATCH_RECOGNIZE(
    PARTITION BY errtype
    ORDER BY tstamp
    MEASURES
        S.tstamp         AS START_T,
        W.tstamp         AS END_T,
        W.message        AS MSG_W,
        COUNT(*)         AS CNT,
        MATCH_NUMBER()   AS MNO
    ONE ROW PER MATCH
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ( S W{3,} )
    DEFINE  W  AS  W.message = PREV (W.message)
    ) MR_SEC
ORDER BY ErrType, Pattern;
</pre><pre class="oac_no_warn" dir="ltr">ERRTYP PATTERN COUNT MESSAGE              STARTING_ON                  ENDING_ON
------ ------- ----- -------------------  ---------------------------- ----------------------------
error        1     4 script not found or  09-JAN-10 12.00.06.000006 PM 09-JAN-10 12.00.15.000015 PM
error        2     4 File does not exist  04-FEB-10 12.00.18.000018 PM 04-FEB-10 12.00.23.000023 PM
error        3     4 File does not exist  06-FEB-10 12.00.25.000025 PM 06-FEB-10 12.00.33.000033 PM
error        4     4 File does not exist  13-FEB-10 12.00.19.000019 PM 14-FEB-10 12.00.07.000007 PM
error        5     5 File does not exist  28-FEB-10 12.00.27.000027 PM 28-FEB-10 12.00.34.000034 PM
error        6     4 script not found or  05-APR-10 12.00.19.000019 PM 05-MAR-10 12.00.23.000023 PM
error        7     4 File does not exist  07-MAR-10 12.00.31.000031 PM 08-MAR-10 12.00.02.000002 PM
error        8     4 File does not exist  14-MAR-10 12.00.19.000019 PM 15-MAR-10 12.00.00.000000 PM
error        9     4 File does not exist  20-MAR-10 12.00.02.000002 PM 20-MAR-10 12.00.06.000006 PM
error       10     5 File does not exist  28-APR-10 12.00.24.000024 PM 28-APR-10 12.00.31.000031 PM
error       11     5 script not found or  01-MAY-10 12.00.15.000015 PM 02-MAY-10 12.00.11.000011 PM
error       12     5 user jsmith: authen  02-MAY-10 12.00.54.000054 PM 03-MAY-10 12.00.11.000011 PM
error       13     4 File does not exist  09-MAY-10 12.00.46.000046 PM 10-MAY-10 12.00.01.000001 PM
error       14     4 File does not exist  20-MAY-10 12.00.42.000042 PM 20-MAY-10 12.00.47.000047 PM
error       15     4 user jsmith: authen  21-MAY-10 12.00.08.000008 PM 21-MAY-10 12.00.18.000018 PM
error       16     4 File does not exist  24-MAY-10 12.00.07.000007 PM 25-MAY-10 12.00.01.000001 PM
error       17     4 user jsmith: authen  12-JUN-10 12.00.00.000000 PM 12-JUN-10 12.00.07.000007 PM
error       18     4 script not found or  12-JUN-10 12.00.18.000018 PM 13-JUN-10 12.00.01.000001 PM
error       19     4 File does not exist  17-JUN-10 12.00.23.000023 PM 17-JUN-10 12.00.30.000030 PM
error       20     5 File does not exist  21-JUN-10 12.00.31.000031 PM 22-JUN-10 12.00.01.000001 PM
error       21     4 user jsmith: authen  22-JUN-10 12.00.36.000036 PM 22-JUN-10 12.00.56.000056 PM
error       22     4 File does not exist  08-JUL-10 12.00.29.000029 PM 08-JUL-10 12.00.32.000032 PM
error       23     6 user jsmith: authen  10-JUL-10 12.00.43.000043 PM 11-JUL-10 12.00.06.000006 PM
error       24     4 File does not exist  12-JUL-10 12.00.09.000009 PM 12-JUL-10 12.00.22.000022 PM
error       25     4 File does not exist  26-JUL-10 12.00.18.000018 PM 27-JUL-10 12.00.04.000004 PM
error       26     4 File does not exist  03-AUG-10 12.00.02.000002 PM 03-AUG-10 12.00.11.000011 PM
error       27     4 File does not exist  23-AUG-10 12.00.04.000004 PM 23-AUG-10 12.00.18.000018 PM
error       28     5 File does not exist  24-AUG-10 12.00.09.000009 PM 26-AUG-10 12.00.00.000000 PM
error       29     4 script not found or  09-SEP-10 12.00.03.000003 PM 09-SEP-10 12.00.09.000009 PM
error       30     4 script not found or  11-SEP-10 12.00.22.000022 PM 11-SEP-10 12.00.31.000031 PM
error       31     4 script not found or  23-SEP-10 12.00.09.000009 PM 23-SEP-10 12.00.16.000016 PM
error       32     5 script not found or  17-OCT-10 12.00.02.000002 PM 18-OCT-10 12.00.09.000009 PM
error       33     4 File does not exist  20-OCT-10 12.00.35.000035 PM 21-OCT-10 12.00.00.000000 PM
error       34     5 File does not exist  21-OCT-10 12.00.16.000016 PM 21-OCT-10 12.00.35.000035 PM
error       35     4 File does not exist  26-OCT-10 12.00.25.000025 PM 26-OCT-10 12.00.35.000035 PM
error       36     4 user jsmith: authen  26-OCT-10 12.00.43.000043 PM 26-OCT-10 12.00.49.000049 PM
error       37     4 user jsmith: authen  01-NOV-10 12.00.35.000035 PM 01-NOV-10 12.00.39.000039 PM
error       38     4 File does not exist  09-NOV-10 12.00.46.000046 PM 10-NOV-10 12.00.09.000009 PM
error       39     4 user jsmith: authen  11-NOV-10 12.00.14.000014 PM 11-NOV-10 12.00.30.000030 PM
error       40     4 user jsmith: authen  22-NOV-10 12.00.46.000046 PM 23-NOV-10 12.00.07.000007 PM
error       41     4 script not found or  03-DEC-10 12.00.14.000014 PM 03-DEC-10 12.00.27.000027 PM
error       42     5 File does not exist  07-DEC-10 12.00.02.000002 PM 07-DEC-10 12.00.37.000037 PM
error       43     4 user jsmith: authen  11-DEC-10 12.00.06.000006 PM 11-DEC-10 12.00.11.000011 PM
error       44     4 user jsmith: authen  19-DEC-10 12.00.26.000026 PM 20-DEC-10 12.00.04.000004 PM
error       45     4 user jsmith: authen  25-DEC-10 12.00.11.000011 PM 25-DEC-10 12.00.17.000017 PM
error       46     4 File does not exist  04-JAN-11 12.00.09.000009 PM 04-JAN-11 12.00.19.000019 PM
error       47     4 user jsmith: authen  10-JAN-11 12.00.23.000023 PM 11-JAN-11 12.00.03.000003 PM
error       48     4 File does not exist  11-JAN-11 12.00.14.000014 PM 11-JAN-11 12.00.24.000024 PM
notice       1     4 Child 3228: Release  08-JAN-10 12.00.38.000038 PM 09-JAN-10 12.00.02.000002 PM
notice       2     4 Child 3228: Release  16-JAN-10 12.00.10.000010 PM 17-JAN-10 12.00.13.000013 PM
notice       3     4 Child 1740: Startin  28-JAN-10 12.00.17.000017 PM 28-JAN-10 12.00.22.000022 PM
notice       4     4 Child 1740: Child p  08-MAR-10 12.00.37.000037 PM 08-MAR-10 12.00.40.000040 PM
notice       5     4 Child 3228: All wor  19-APR-10 12.00.10.000010 PM 19-APR-10 12.00.15.000015 PM
notice       6     4 Child 1740: Acquire  02-MAY-10 12.00.38.000038 PM 02-MAY-10 12.00.46.000046 PM
notice       7     4 Child 1740: Starting 09-MAY-10 12.00.03.000003 PM 09-MAY-10 12.00.08.000008 PM
notice       8     4 Child 3228: Child pr 18-MAY-10 12.00.38.000038 PM 18-MAY-10 12.00.45.000045 PM
notice       9     4 Child 3228: All work 25-JUL-10 12.00.04.000004 PM 25-JUL-10 12.00.09.000009 PM
notice      10     4 Child 3228: All work 24-AUG-10 12.00.11.000011 PM 24-AUG-10 12.00.18.000018 PM
notice      11     4 Child 1740: Starting 19-SEP-10 12.00.05.000005 PM 19-SEP-10 12.00.15.000015 PM
notice      12     4 Child 1740: Acquired 06-OCT-10 12.00.07.000007 PM 06-OCT-10 12.00.13.000013 PM
notice      13     4 Child 1740: Starting 09-JAN-11 12.00.12.000012 PM 09-JAN-11 12.00.18.000018 PM
warn         1  3448 The ScriptAlias dire 01-JAN-10 12.00.00.000000 PM 17-JAN-11 12.00.18.000018 PM
 
62 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACBDDGJ">
                        <p class="titleinexample">Example 21-17 Four or More Consecutive Authentication Failures</p>
                        <p>In this example, you are looking for four or more consecutive authentication failures, regardless of IP origination address. The output shows two matches, the first with five rows and the last one with four rows.</p><pre class="oac_no_warn" dir="ltr">SELECT MR_SEC2.ERRTYPE  AS Authen,
       MR_SEC2.MNO      AS Pattern,
       MR_SEC2.CNT      AS Count,
       MR_SEC2.IPADDR   AS On_IP,
       MR_SEC2.TSTAMP   AS Occurring_on
FROM AUTHENLOG
MATCH_RECOGNIZE(
    PARTITION BY errtype
    ORDER BY tstamp
    MEASURES
        COUNT(*)          AS CNT,
        MATCH_NUMBER()    AS MNO
    ALL ROWS PER MATCH
    AFTER MATCH SKIP TO LAST W
    PATTERN ( S W{3,} )
    DEFINE S AS S.message LIKE '%authenticat%',
           W AS W.message = PREV (W.message)
    ) MR_SEC2
ORDER BY Authen, Pattern, Count;</pre><pre class="oac_no_warn" dir="ltr">
AUTHEN     PATTERN      COUNT  ON_IP            OCCURRING_ON
------     -------  ---------  ------------     ----------------------------
error            1          1  10.111.112.3     02-MAY-10 12.00.54.000054 PM
error            1          2  10.111.112.6     03-MAY-10 12.00.07.000007 PM
error            1          3  10.111.112.6     03-MAY-10 12.00.08.000008 PM
error            1          4  10.111.112.6     03-MAY-10 12.00.09.000009 PM
error            1          5  10.111.112.6     03-MAY-10 12.00.11.000011 PM
error            2          1  10.111.112.5     21-MAY-10 12.00.08.000008 PM
error            2          2  10.111.112.6     21-MAY-10 12.00.16.000016 PM
error            2          3  10.111.112.4     21-MAY-10 12.00.17.000017 PM
error            2          4  10.111.112.6     21-MAY-10 12.00.18.000018 PM
error            3          1  10.111.112.5     12-JUN-10 12.00.00.000000 PM
error            3          2  10.111.112.4     12-JUN-10 12.00.04.000004 PM
error            3          3  10.111.112.3     12-JUN-10 12.00.06.000006 PM
error            3          4  10.111.112.3     12-JUN-10 12.00.07.000007 PM
error            4          1  10.111.112.5     22-JUN-10 12.00.36.000036 PM
error            4          2  10.111.112.5     22-JUN-10 12.00.50.000050 PM
error            4          3  10.111.112.5     22-JUN-10 12.00.53.000053 PM
error            4          4  10.111.112.6     22-JUN-10 12.00.56.000056 PM
error            5          1  10.111.112.4     10-JUL-10 12.00.43.000043 PM
error            5          2  10.111.112.6     10-JUL-10 12.00.48.000048 PM
error            5          3  10.111.112.6     10-JUL-10 12.00.51.000051 PM
error            5          4  10.111.112.3     11-JUL-10 12.00.00.000000 PM
error            5          5  10.111.112.5     11-JUL-10 12.00.04.000004 PM
error            5          6  10.111.112.3     11-JUL-10 12.00.06.000006 PM
error            6          1  10.111.112.4     26-OCT-10 12.00.43.000043 PM
error            6          2  10.111.112.4     26-OCT-10 12.00.47.000047 PM
error            6          3  10.111.112.4     26-OCT-10 12.00.48.000048 PM
error            6          4  10.111.112.5     26-OCT-10 12.00.49.000049 PM
error            7          1  10.111.112.3     01-NOV-10 12.00.35.000035 PM
error            7          2  10.111.112.5     01-NOV-10 12.00.37.000037 PM
error            7          3  10.111.112.5     01-NOV-10 12.00.38.000038 PM
error            7          4  10.111.112.3     01-NOV-10 12.00.39.000039 PM
error            8          1  10.111.112.6     11-NOV-10 12.00.14.000014 PM
error            8          2  10.111.112.5     11-NOV-10 12.00.20.000020 PM
error            8          3  10.111.112.6     11-NOV-10 12.00.24.000024 PM
error            8          4  10.111.112.3     11-NOV-10 12.00.30.000030 PM
error            9          1  10.111.112.5     22-NOV-10 12.00.46.000046 PM
error            9          2  10.111.112.5     22-NOV-10 12.00.51.000051 PM
error            9          3  10.111.112.3     23-NOV-10 12.00.06.000006 PM
error            9          4  10.111.112.3     23-NOV-10 12.00.07.000007 PM
error           10          1  10.111.112.5     11-DEC-10 12.00.06.000006 PM
error           10          2  10.111.112.4     11-DEC-10 12.00.07.000007 PM
error           10          3  10.111.112.5     11-DEC-10 12.00.08.000008 PM
error           10          4  10.111.112.6     11-DEC-10 12.00.11.000011 PM
error           11          1  10.111.112.5     19-DEC-10 12.00.26.000026 PM
error           11          2  10.111.112.5     20-DEC-10 12.00.01.000001 PM
error           11          3  10.111.112.4     20-DEC-10 12.00.03.000003 PM
error           11          4  10.111.112.3     20-DEC-10 12.00.04.000004 PM
error           12          1  10.111.112.4     25-DEC-10 12.00.11.000011 PM
error           12          2  10.111.112.4     25-DEC-10 12.00.12.000012 PM
error           12          3  10.111.112.4     25-DEC-10 12.00.16.000016 PM
error           12          4  10.111.112.3     25-DEC-10 12.00.17.000017 PM
error           13          1  10.111.112.6     10-JAN-11 12.00.23.000023 PM
error           13          2  10.111.112.6     11-JAN-11 12.00.00.000000 PM
error           13          3  10.111.112.3     11-JAN-11 12.00.02.000002 PM
error           13          4  10.111.112.4     11-JAN-11 12.00.03.000003 PM
 
55 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACDABEB">
                        <p class="titleinexample">Example 21-18 Authentication Failures from the Same IP Address</p>
                        <p>The query in <a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACDABEB">Example 21-18</a> is similar to <a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACBDDGJ">Example 21-17</a>, but it finds authentication failures from the same IP origination address that occurred three or more consecutive times.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_S3.MNO AS Pattern, MR_S3.CNT AS Count,
       MR_S3.ERRTYPE AS Type, MR_S3.IPADDR AS On_IP_addr,
       MR_S3.START_T AS Starting_on, MR_S3.END_T AS Ending_on
FROM AUTHENLOG
MATCH_RECOGNIZE(
    PARTITION BY errtype
    ORDER BY tstamp
    MEASURES
        S.tstamp         AS START_T,
        W.tstamp         AS END_T,
        W.ipaddr         AS IPADDR,
        COUNT(*)         AS CNT,
        MATCH_NUMBER()   AS MNO
    ONE ROW  PER MATCH
    AFTER MATCH SKIP TO LAST W
    PATTERN ( S W{2,} )
    DEFINE  S AS S.message LIKE '%authenticat%',
            W  AS  W.message = PREV (W.message)
                   AND W.ipaddr = PREV (W.ipaddr)
    ) MR_S3
ORDER BY Type, Pattern;
</pre><pre class="oac_no_warn" dir="ltr">PATTERN COUNT  TYPE    ON_IP_ADDR     STARTING_ON                     ENDING_ON
------- -----  -----   ------------   ----------------------------    ----------------------------
      1     4  error   10.111.112.6   03-MAY-10 12.00.07.000007 PM    03-MAY-10 12.00.11.000011 PM
      2     3  error   10.111.112.5   22-JUN-10 12.00.36.000036 PM    22-JUN-10 12.00.53.000053 PM
      3     3  error   10.111.112.4   27-JUN-10 12.00.03.000003 PM    27-JUN-10 12.00.08.000008 PM
      4     3  error   10.111.112.6   19-JUL-10 12.00.15.000015 PM    19-JUL-10 12.00.17.000017 PM
      5     3  error   10.111.112.4   26-OCT-10 12.00.43.000043 PM    26-OCT-10 12.00.48.000048 PM
      6     3  error   10.111.112.4   25-DEC-10 12.00.11.000011 PM    25-DEC-10 12.00.16.000016 PM
      7     3  error   10.111.112.5   12-JAN-11 12.00.01.000001 PM    12-JAN-11 12.00.08.000008 PM
 
7 rows selected.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9198"></a><a id="DWHSG9200"></a><a id="DWHSG9202"></a><a id="DWHSG9197"></a><div class="props_rev_3"><a id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8" name="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8"></a><h4 id="DWHSG-GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8" class="sect4"><span class="enumeration_section">21.6.3 </span>Pattern Matching Examples: Sessionization
                  </h4>
                  <div>
                     <div class="section">
                        <p>Sessionization is the process of defining distinct sessions of user activity, typically involving multiple events in a single session. Pattern matching makes it easy to express queries for sessionization. For instance, you may want to know how many pages visitors to your website view during a typical session. If you are a communications provider, you may want to know the characteristics of phone sessions between two users where the sessions involve dropped connections and users redialing. Enterprises can derive significant value from understanding their user session behavior, because it can help firms define service offerings and enhancements, pricing, marketing and more.</p>
                        <p>The following examples include two introductory examples of sessionization related to web site clickstreams followed by an example involving phone calls.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">
                        <p class="titleinexample">Example 21-19 Simple Sessionization for Clickstream Data</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">Example 21-19</a> is a simple illustration of sessionization for clickstream data analysis. For a set of rows, the goal is to detect the sessions, assign a session ID to each session, and to display each input row with its session ID. The data below would come from a web server system log that tracks all page requests. You start with a set of rows where each row is the event of a user requesting a page. In this simple example, the data includes a partition key, which is the user ID, and a timestamp indicating when the user requested a page. Web system logs show when a user requested a given page, but there is no indication of when the user stopped looking at the page.
                        </p>
                        <p>In <a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">Example 21-19</a>, a session is defined as a sequence of one or more time-ordered rows with the same partition key (<code class="codeph">User_ID</code>) where the time gap between timestamps is less than a specified threshold. In this case, the threshold is ten time units. If rows have a timestamp greater than ten units apart, they are considered to be in different sessions.   Note that the 10-unit threshold used here is an arbitrary number: each real-world case requires the analyst's judgment to determine the most suitable threshold time gap. Historically, a 30-minute gap has been a commonly used threshold for separating sessions of website visits.
                        </p>
                        <p>Start by creating a table of clickstream events.</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Events(
   Time_Stamp NUMBER,
   User_ID VARCHAR2(10)
  );
</pre><p>Next insert the data. The insert statements below have been ordered and spaced for your reading convenience so that you can see the partitions and the sessions within them. In real life, the events would arrive in timestamp order and the rows for different user sessions would be intermingled.</p><pre class="oac_no_warn" dir="ltr">  INSERT INTO Events(Time_Stamp, User_ID) VALUES ( 1, 'Mary');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (11, 'Mary');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (23, 'Mary');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (34, 'Mary');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (44, 'Mary');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (53, 'Mary');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (63, 'Mary');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES ( 3, 'Richard');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (13, 'Richard');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (23, 'Richard');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (33, 'Richard');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (43, 'Richard');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (54, 'Richard');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (63, 'Richard');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES ( 2, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (12, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (22, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (32, 'Sam');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (43, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (47, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (48, 'Sam');
 
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (59, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (60, 'Sam');
  INSERT INTO Events(Time_Stamp, User_ID) VALUES (68, 'Sam');
</pre><p>The row pattern matching query below will display each input row with its <code class="codeph">Session_ID</code>. As noted above, events are considered to be part of the same session if they are ten or fewer time units apart. That session threshold is expressed in the <code class="codeph">DEFINE</code> clause for pattern variables.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT time_stamp, user_id, session_id
FROM Events MATCH_RECOGNIZE
         (PARTITION BY User_ID ORDER BY Time_Stamp
          MEASURES match_number() AS session_id
          ALL ROWS PER MATCH
          PATTERN (b s*)
          DEFINE
             s AS (s.Time_Stamp - prev(Time_Stamp) &lt;= 10)
         )
ORDER BY user_id, time_stamp;
</pre><p>The output will be:</p><pre class="oac_no_warn" dir="ltr">TIME_STAMP USER_ID    SESSION_ID
---------- ---------- ----------
         1 Mary                1
        11 Mary                1
        23 Mary                2
        34 Mary                3
        44 Mary                3
        53 Mary                3
        63 Mary                3
         3 Richard             1
        13 Richard             1
        23 Richard             1
        33 Richard             1
        43 Richard             1
        54 Richard             2
        63 Richard             2
         2 Sam                 1
        12 Sam                 1
        22 Sam                 1
        32 Sam                 1
        43 Sam                 2
        47 Sam                 2
        48 Sam                 2
        59 Sam                 3
        60 Sam                 3
        68 Sam                 3
 
24 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACEGADH">
                        <p class="titleinexample">Example 21-20 Simple Sessionization with Aggregation</p>
                        <p>Assigning session numbers to detail-level rows as in example <a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">Example 21-19</a> just begins the analytic process. The business value of sessionized data emerges only after aggregating by session.
                        </p>
                        <p>This example aggregates the data to give one row per session with these columns: <code class="codeph">Session_ID</code>, <code class="codeph">User_ID</code>, number of aggregated events per session, and total session duration. This output makes it easy to see how many clicks each user has per session and how long each session lasts. In turn, data from this query could be used to drive many other analyses such as maximum, minimum, and average session duration.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT session_id, user_id, start_time, no_of_events, duration
FROM Events MATCH_RECOGNIZE
     (PARTITION BY User_ID
      ORDER BY Time_Stamp
      MEASURES MATCH_NUMBER() session_id,
               COUNT(*) AS no_of_events,
               FIRST(time_stamp) start_time,
               LAST(time_stamp) - FIRST(time_stamp) duration
      PATTERN (b s*)
      DEFINE
         s AS (s.Time_Stamp - PREV(Time_Stamp) &lt;= 10)
     )
ORDER BY user_id, session_id;
</pre><p>The output will be:</p><pre class="oac_no_warn" dir="ltr">SESSION_ID USER_ID    START_TIME NO_OF_EVENTS   DURATION
---------- ---------- ---------- ------------ ----------
         1 Mary                1            2         10
         2 Mary               23            1          0
         3 Mary               34            4         29
         1 Richard             3            5         40
         2 Richard            54            2          9
         1 Sam                 2            4         30
         2 Sam                43            3          5
         3 Sam                59            3          9
 
8 rows selected.</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACBHIHI">
                        <p class="titleinexample">Example 21-21 Sessionization for Phone Calls with Dropped Connections</p>
                        <p>In the examples <a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">Example 21-19</a> and <a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACEGADH">Example 21-20</a> with clickstream data, there was no explicit end point in the source data to indicate the end time for viewing a page. Even if there are clear end points for user activity, an end point may not indicate that a user wanted to end the session.   Consider a person using a mobile phone service whose phone connection is dropped: typically, the user will redial and continue the phone call. In that scenario, multiple phone calls involving the same pair of phone numbers should be considered part of a single phone session.
                        </p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACBHIHI">Example 21-21</a> illustrates phone call sessionization. It uses call detail record data as the base for sessionization, where the call data record rows include <code class="codeph">Start_Time</code>, <code class="codeph">End_Time</code>, <code class="codeph">Caller_ID</code>, <code class="codeph">Callee_ID</code>. The query below does the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Partitions the data by <code class="codeph">caller_id</code> and <code class="codeph">callee_id</code>.
                              </p>
                           </li>
                           <li>
                              <p>Finds sessions where calls from a caller to a callee are grouped into a session if the gap between subsequent calls is within a threshold of 60 seconds. That threshold is specified in the <code class="codeph">DEFINE</code> clause for pattern variable <code class="codeph">B</code>.
                              </p>
                           </li>
                           <li>
                              <p>Returns for each session (see the <code class="codeph">MEASURES</code> clause):
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The <code class="codeph">session_id</code>, the caller and callee
                                    </p>
                                 </li>
                                 <li>
                                    <p>How many times calls were restarted in a session</p>
                                 </li>
                                 <li>
                                    <p>Total effective call duration (total time during the session when the phones were connected)</p>
                                 </li>
                                 <li>
                                    <p>Total interrupted duration (total time during the session when the phones were disconnected</p>
                                 </li>
                              </ul>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">SELECT  Caller, Callee, Start_Time, Effective_Call_Duration,
                (End_Time - Start_Time) - Effective_Call_Duration 
                     AS Total_Interruption_Duration, No_Of_Restarts, Session_ID 
FROM my_cdr MATCH_RECOGNIZE 
        ( PARTITION BY Caller, Callee ORDER BY Start_Time 
           MEASURES 
                A.Start_Time               AS Start_Time,
                End_Time                   AS End_Time,
                SUM(End_Time - Start_Time) AS Effective_Call_Duration,
                COUNT(B.*)                 AS No_Of_Restarts,
                MATCH_NUMBER()             AS Session_ID 
           PATTERN (A B*) 
           DEFINE B AS B.Start_Time - PREV(B.end_Time) &lt; 60 
         );
</pre><p>Because the previous query needs a significant amount of data to be meaningful, and that would consume substantial space, no <code class="codeph">INSERT</code> statement is included here. However, the following is sample output.
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; desc my_cdr
Name            Null?        Type
--------------  ----------   ----------
CALLER          NOT NULL     NUMBER(38)
CALLEE          NOT NULL     NUMBER(38)
START_TIME      NOT NULL     NUMBER(38)
END_TIME        NOT NULL     NUMBER(38)
 
SELECT * FROM my_cdr ORDER BY 1, 2, 3, 4;
 
CALLER   CALLEE  START_TIME   END_TIME
------   ------  ----------   ---------
     1        7        1354        1575
     1        7        1603        1829
     1        7        1857        2301
     1        7        2320        2819
     1        7        2840        2964
     1        7       64342       64457
     1        7       85753       85790
     1        7       85808       85985
     1        7       86011       86412
     1        7       86437       86546
     1        7      163436      163505
     1        7      163534      163967
     1        7      163982      164454
     1        7      214677      214764
     1        7      214782      215248
     1        7      216056      216271
     1        7      216297      216728
     1        7      216747      216853
     1        7      261138      261463
     1        7      261493      261864
     1        7      261890      262098
     1        7      262115      262655
     1        7      301931      302226
     1        7      302248      302779
     1        7      302804      302992
     1        7      303015      303258
     1        7      303283      303337
     1        7      383019      383378
     1        7      383407      383534
     1        7      424800      425096
 
30 rows selected.

CALLER CALLEE START_TIME EFFECTIVE_CALL TOTAL_INTERUPTION NO_OF_RE SESSION_ID
------ ------- --------- -------------- ----------------- -------- ----------
    1        7      1354           1514                96        4          1
    1        7     64342            115                 0        0          2
    1        7     85753            724                69        3          3
    1        7    163436            974                44        2          4
    1        7    214677            553                18        1          5
    1        7    216056            752                45        2          6
    1        7    261138           1444                73        3          7
    1        7    301931           1311                95        4          8
    1        7    383019            486                29        1          9
    1        7    424800            296                 0        0         10
 
10 rows selected.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9304"></a><a id="DWHSG9303"></a><div class="props_rev_3"><a id="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD" name="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD"></a><h4 id="DWHSG-GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD" class="sect4"><span class="enumeration_section">21.6.4 </span>Pattern Matching Example: Financial Tracking
                  </h4>
                  <div>
                     <div class="section">
                        <p>A common financial application is to search for suspicious financial patterns. <a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">Example 21-22</a> illustrates how to detect money transfers that seem suspicious because certain criteria you have defined as being unusual have been met.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">
                        <p class="titleinexample">Example 21-22 Suspicious Money Transfer</p>
                        <p>In <a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">Example 21-22</a>, we search for a pattern that seems suspicious when transferring funds. In this case, that is defined as three or more small (less than $2000) money transfers within 30 days followed by a large transfer (over $1,000,000) within 10 days of the last small transfer. To simplify things, the table and data are made very basic.
                        </p>
                        <p>First, we create a table that contains the necessary data:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE event_log
     ( time          DATE,
       userid        VARCHAR2(30),
       amount        NUMBER(10),
       event         VARCHAR2(10),
       transfer_to   VARCHAR2(10));
</pre><p>Then we insert data into <code class="codeph">event_log</code>:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO event_log VALUES 
   (TO_DATE('01-JAN-2012', 'DD-MON-YYYY'), 'john', 1000000, 'deposit', NULL);
INSERT INTO event_log VALUES 
   (TO_DATE('05-JAN-2012', 'DD-MON-YYYY'), 'john', 1200000, 'deposit', NULL);
INSERT INTO event_log VALUES 
   (TO_DATE('06-JAN-2012', 'DD-MON-YYYY'), 'john', 1000, 'transfer', 'bob');
INSERT INTO event_log VALUES 
   (TO_DATE('15-JAN-2012', 'DD-MON-YYYY'), 'john', 1500, 'transfer', 'bob');
INSERT INTO event_log VALUES 
   (TO_DATE('20-JAN-2012', 'DD-MON-YYYY'), 'john', 1500, 'transfer', 'allen');
INSERT INTO event_log VALUES 
   (TO_DATE('23-JAN-2012', 'DD-MON-YYYY'), 'john', 1000, 'transfer', 'tim');
INSERT INTO event_log VALUES 
   (TO_DATE('26-JAN-2012', 'DD-MON-YYYY'), 'john', 1000000, 'transfer', 'tim');
INSERT INTO event_log VALUES 
   (TO_DATE('27-JAN-2012', 'DD-MON-YYYY'), 'john', 500000, 'deposit', NULL);
</pre><p>Next, we can query this table:</p><pre class="oac_no_warn" dir="ltr">SELECT userid, first_t, last_t, amount
FROM (SELECT * FROM event_log WHERE event = 'transfer')
MATCH_RECOGNIZE
   (PARTITION BY userid ORDER BY time
    MEASURES FIRST(x.time) first_t, y.time last_t, y.amount amount
    PATTERN ( x{3,} y )
    DEFINE x AS (event='transfer' AND amount <span class="bold">&lt; 2000</span>),
           y AS (event='transfer' AND amount <span class="bold">&gt;= 1000000</span> AND
                 LAST(x.time) - FIRST(x.time) <span class="bold">&lt; 30</span> AND
                 y.time - LAST(x.time) <span class="bold">&lt; 10</span>));

USERID        FIRST_T      LAST_T       AMOUNT
----------    ---------    ---------    -------
john          06-JAN-12    26-JAN-12    1000000
</pre><p>In this statement, the first text in bold represents the small transfers, the second represents a large transfer, the third that the small transfers occurred within 30 days, and the fourth that the large transfer occurred within 10 days of the last small transfer.</p>
                        <p>This statement can be further refined to include the recipient of the suspicious transfer, as in the following:</p><pre class="oac_no_warn" dir="ltr">SELECT userid, first_t, last_t, amount, transfer_to
FROM (SELECT * FROM event_log WHERE event = 'transfer')
MATCH_RECOGNIZE
   (PARTITION BY userid ORDER BY time
    MEASURES z.time first_t, y.time last_t, y.amount amount, 
             y.transfer_to transfer_to
    PATTERN ( z x{2,} y )
    DEFINE z AS (event='transfer' AND amount <span class="bold">&lt; 2000</span>),
           x AS (event='transfer' AND amount &lt;= 2000 AND
                 <span class="bold">PREV(x.transfer_to) &lt;&gt; x.transfer_to)</span>,
           y AS (event='transfer' AND amount <span class="bold">&gt;= 1000000</span> AND
                 LAST(x.time) - z.time <span class="bold">&lt; 30</span> AND
                 y.time - LAST(x.time) <span class="bold">&lt; 10</span> AND
                 SUM(x.amount) + z.amount <span class="bold">&lt; 20000</span>);

USERID        FIRST_T      LAST_T       AMOUNT      TRANSFER_TO
----------    ---------    ---------    -------     -----------
john          15-JAN-12    26-JAN-12    1000000     tim
</pre><p>In this statement, the first text in bold represents the first small transfer, the next represents two or more small transfers to different accounts, the third represents the sum of all small transfers less than $20,000.</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>