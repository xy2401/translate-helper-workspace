<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Advanced Language Features</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQLJ Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQLJ Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96458-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="objects-collections-and-OPAQUE-types.html" title="Previous" type="text/html">
      <link rel="next" href="translator-command-line-and-options.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JSQLJ">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="objects-collections-and-OPAQUE-types.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="translator-command-line-and-options.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Advanced Language Features</li>
            </ol>
            <a id="GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58" name="GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58"></a><a id="JSQLJ494"></a>
            
            <h2 id="JSQLJ-GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58" class="sect2"><span class="enumeration_chapter">8 </span> Advanced Language Features
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses advanced SQLJ language features for use in coding your application. For more basic topics, refer to <a href="basic-language-features.html#GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5"> Basic Language Features</a>.
               </p>
               <p>The following topics are discussed:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">Connection Contexts</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">Execution Contexts</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-C7787089-2507-43D1-91A3-FEC222903639">Multithreading in SQLJ</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF">Iterator Class Implementation and Advanced Functionality</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">Advanced Transaction Control</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568">SQLJ and JDBC Interoperability</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">Support for Dynamic SQL</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69">Using Stored Outlines</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-8465DD7E-5943-4BBD-911D-F1318A55552E">Using Plan Baselines</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ495"></a><div class="props_rev_3"><a id="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A" name="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A"></a><h3 id="JSQLJ-GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A" class="sect3">Connection Contexts</h3>
               <div>
                  <p>SQLJ supports the concept of connection contexts, allowing strongly typed connections for use with different sets of SQL entities. You can think of a connection context as being associated with a particular set of SQL entities, such as tables, views, and stored procedures. SQLJ lets you declare additional connection context classes so that you can use each class for connections that use a particular set of SQL entities. Different instances of a single connection context class are not required to use the same physical entities or connect to the same schema, but will at least use sets of entities with the same names and data types.</p>
                  <div class="infoboxnotealso" id="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A__GUID-DB141E7F-B6CE-45BE-A3A8-E67EBED8F73F">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">Connection Considerations</a>"</span> for an overview of connection basics, focusing on situations where you are using just a single set of SQL entities and a single connection context class.
                     </p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E">Connection Context Concepts</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43">Connection Context Logistics</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC">Declaring and Using a Connection Context Class</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F">Example of Multiple Connection Contexts</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-50ACAE7A-118A-4D0B-B18B-03813798054C">Implementation and Functionality of Connection Context Classes</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC">Using the IMPLEMENTS Clause in Connection Context Declarations</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1">Semantics-Checking of Your Connection Context Usage</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">Standard Data Source Support</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75">SQLJ-Specific Data Sources</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-51755815-E5DB-41A3-8427-8969A0B90404">SQLJ-Specific Connection JavaBeans for JavaServer Pages</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-02D73030-0352-4669-9152-0A331260FBC8">SQLJ Support for Global Transactions</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1">Connecting to PDBs</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ496"></a><div class="props_rev_3"><a id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E" name="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E"></a><h4 id="JSQLJ-GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E" class="sect4">Connection Context Concepts</h4>
                  <div>
                     <p>If your application uses different sets of SQL entities, then you will typically want to declare and use one or more additional connection context classes, as discussed in <span class="q">"<a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">Overview of SQLJ Declarations</a>"</span>. Each connection context class can be used for a particular set of interrelated SQL entities, meaning that all the connections you define using a particular connection context class will use tables, views, stored procedures, and so on, which have the same names and use the same data types.
                     </p>
                     <p>An example of a set of SQL entities is the set of tables and stored procedures used by the Human Resources (HR) department. Perhaps they use the <code class="codeph">EMPLOYEES</code> and <code class="codeph">DEPARTMENTS</code> tables and the <code class="codeph">CHANGE_DEPT</code> and <code class="codeph">UPDATE_HEALTH_PLAN</code> stored procedures. Another set of SQL entities might be the set of tables and procedures used by the Payroll department, perhaps consisting of the <code class="codeph">EMPS</code> table (another table of employees, but different than the one used by HR) and the <code class="codeph">GIVE_RAISE</code> and <code class="codeph">CHANGE_WITHHOLDING</code> stored procedures.
                     </p>
                     <p>The advantage in tailoring connection context classes to sets of SQL entities is in the degree of online semantics-checking that this allows. Online checking verifies that all the SQL entities appearing in SQLJ statements that use a given connection context class match SQL entities found in the exemplar schema used during translation. An exemplar schema is a database account that SQLJ connects to for online checking of all the SQLJ statements that use a particular connection context class. You provide exemplar schemas to the translator through the SQLJ command-line <code class="codeph">-user</code>, <code class="codeph">-password</code>, and <code class="codeph">-url</code> options. An exemplar schema may or may not be the same account your application will use at run time.
                     </p>
                     <div class="infoboxnotealso" id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E__GUID-454DAED1-AA45-4861-BBA6-40BBAB5D2E1E">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">Connection Options</a>"</span></p>
                     </div>
                     <p>If you have SQLJ statements that use a broad and perhaps unrelated group of SQL entities, but you use only a single connection context class for these statements, then the exemplar schema you provide must be very general. It must contain all the tables, views, and stored procedures used throughout all the statements. Alternatively, if all the SQLJ statements using a given connection context class use a tight, presumably interrelated, set of SQL entities, then you can provide a more specific exemplar schema that enables more thorough and meaningful semantics-checking.</p>
                     <div class="infoboxnote" id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E__GUID-850E839F-E7A1-4A92-A386-72D1C4DEB012">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Be aware that a connection context class declaration does not define a set of SQL entities to be used with the declared connection context class, and it is permissible to use the same connection context class for connections that use disparate and unrelated sets of entities. How you use your connection context classes is at your discretion. All that limits the SQL entities you can use with a particular connection context class are the set of entities available in the exemplar schema, if you use online semantics-checking during translation, and the set of entities available in the schema you connect to at run time, using instances of the connection context class.</p>
                           </li>
                           <li>
                              <p>If you use qualified SQL names in your application, such as <code class="codeph">HR.EMPLOYEES</code>, which specifies the schema where the entity resides, then the exemplar schema, if you use online checking, and run-time schema must have permission to access resources by these fully qualified names.
                              </p>
                           </li>
                           <li>
                              <p>It is possible to use a single connection context class, even for connections to databases from different vendors, as long as each schema you connect to has entities that are accessible by the same names and that use compatible data types.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ497"></a><div class="props_rev_3"><a id="GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43" name="GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43"></a><h4 id="JSQLJ-GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43" class="sect4">Connection Context Logistics</h4>
                  <div>
                     <p>Declaring a connection context class results in the SQLJ translator defining a class for you in the translator-generated code. In addition to any connection context classes that you declare, there is always the default connection context class:</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ref.DefaultContext
</pre><p>When you construct a connection context instance, specify a particular schema and a particular session and transaction in which SQL operations will execute. You typically accomplish this by specifying a user name, password, and database URL as input to the constructor of the connection context class. The connection context instance manages the set of SQL operations performed during the session.</p>
                     <p>In each SQLJ statement, you can specify a connection context instance to use. The following example shows basic declaration and use of a connection context class, <code class="codeph">MyContext</code>, to connect to two different schemas. For typical usage, assume these schemas include a set of SQL entities with common names and data types.
                     </p><pre class="oac_no_warn" dir="ltr">#sql context MyContext;

...
MyContext mctx1 = new MyContext
  ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", false);
MyContext mctx2 =  new MyContext
  ("jdbc:oracle:thin@localhost:5221/myservice", "brian", "mypasswd", false);
</pre><p>Note that connection context class constructors specify a boolean auto-commit parameter. In addition, note that you can connect to the same schema with different connection context instances. In the preceding example, both <code class="codeph">mctx1</code> and <code class="codeph">mctx2</code> can specify <code class="codeph">HR/hr</code> if desired. However, during run time, one connection context instance would not see changes to the database made from the other until the changes are committed. The only exception to this would be if both connection context instances were created from the same underlying Java Database Connectivity (JDBC) connection instance. One of the constructors of any connection context class takes a JDBC connection instance as input.
                     </p>
                  </div>
               </div><a id="JSQLJ499"></a><a id="JSQLJ500"></a><a id="JSQLJ501"></a><a id="JSQLJ502"></a><a id="JSQLJ498"></a><div class="props_rev_3"><a id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC" name="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC"></a><h4 id="JSQLJ-GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC" class="sect4">Declaring and Using a Connection Context Class</h4>
                  <div>
                     <div class="section">
                        <p>This section gives a detailed example of how to declare a connection context class, then define a database connection using an instance of the class.</p>
                        <p>A connection context class has constructors for opening a connection to a database schema that take any of the following input parameter sets (as with the <code class="codeph">DefaultContext</code> class):
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>URL (<code class="codeph">String</code>), user name (<code class="codeph">String</code>), password (<code class="codeph">String</code>), auto-commit (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code>), <code class="codeph">java.util.Properties</code> object, auto-commit (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>URL (<code class="codeph">String</code> fully specifying connection and including user name and password), auto-commit setting (<code class="codeph">boolean</code>)
                              </p>
                           </li>
                           <li>
                              <p>JDBC connection object (<code class="codeph">Connection</code>)
                              </p>
                           </li>
                           <li>
                              <p>SQLJ connection context object</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-15ABC42D-4E25-464D-800C-9F100FE76266">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>When using the constructor that takes a JDBC connection object, do not initialize the connection context instance with a null JDBC connection.</p>
                              </li>
                              <li>
                                 <p>The auto-commit setting determines whether SQL operations are automatically committed. For more information, refer to <span class="q">"<a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">Basic Transaction Control</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>If a connection context class is declared with a data source <code class="codeph">with</code> clause, then it incorporates a different set of constructors. Refer to <span class="q">"<a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">Standard Data Source Support</a>"</span> for more information.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-9C64BCC6-2469-490E-A093-E712C71AFF12">Declaring the Connection Context Class</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following declaration creates a connection context class: </p><pre class="oac_no_warn" dir="ltr">#sql context OrderEntryCtx &lt;<span class="italic">implements_clause</span>&gt; &lt;<span class="italic">with_clause</span>&gt;; 
</pre><p>This results in the SQLJ translator generating a class that implements the <code class="codeph">sqlj.runtime.ConnectionContext</code> interface and extends some base class, probably an abstract class, that also implements the <code class="codeph">ConnectionContext</code> interface. This base class would be a feature of the particular SQLJ implementation you are using. The <code class="codeph">implements</code> clause and <code class="codeph">with</code> clause are optional, specifying additional interfaces to implement and variables to define and initialize, respectively.
                        </p>
                        <div class="infoboxnotealso" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-0EE8E5FC-FE61-43DA-A250-89AB61910F3C">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">Declaration IMPLEMENTS Clause</a>"</span> and <span class="q">"<a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a>"</span></p>
                        </div>
                        <p>The following is an example of what the SQLJ translator generates (with method implementations omitted): </p><pre class="oac_no_warn" dir="ltr">
class OrderEntryCtx implements sqlj.runtime.ConnectionContext 
      extends ...
{ 
   public OrderEntryCtx(String url, Properties info, boolean autocommit)
          throws SQLException {...} 
   public OrderEntryCtx(String url, boolean autocommit) 
          throws SQLException {...}   
   public OrderEntryCtx(String url, String user, String password, 
          boolean autocommit) throws SQLException {...} 
   public OrderEntryCtx(Connection conn) throws SQLException {...} 
   public OrderEntryCtx(ConnectionContext other) throws SQLException {...} 

   public static OrderEntryCtx getDefaultContext() {...} 
   public static void setDefaultContext(OrderEntryCtx ctx) {...} 
} 
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-275BCAF5-E37F-42D2-95B4-6824C333E5FE">Creating a Connection Context Instance</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Continuing the preceding example, instantiate the <code class="codeph">OrderEntryCtx</code> class with the following syntax:
                        </p><pre class="oac_no_warn" dir="ltr">OrderEntryCtx myOrderConn = new OrderEntryCtx
                            (<span class="italic">url</span>, <span class="italic">username</span>, <span class="italic">password, autocommit</span>);
</pre><p>For example:</p><pre class="oac_no_warn" dir="ltr">OrderEntryCtx myOrderConn = new OrderEntryCtx
  ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", true);
</pre><p>This is accomplished in the same way as instantiating the <code class="codeph">DefaultContext</code> class. All connection context classes, including <code class="codeph">DefaultContext</code>, have the same constructor signatures.
                        </p>
                        <div class="infoboxnote" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-E735C636-A11E-4235-B0DB-D689A9461D16">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>You typically must register your JDBC driver prior to constructing a connection context instance. Refer to <span class="q">"<a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">Driver Selection and Registration for Run Time</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>If a connection context class is declared with a data source <code class="codeph">with</code> clause, then it incorporates a different set of constructors. Refer to <span class="q">"<a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">Standard Data Source Support</a>"</span> for more information.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-EFBB9C99-D952-4ACC-ACBB-E66C2378C9DC">Specifying a Connection Context Instance for a SQLJ Clause</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Recall that the basic SQLJ statement syntax is as follows: </p><pre class="oac_no_warn" dir="ltr">#sql &lt;[&lt;<span class="italic">conn</span>&gt;<span class="italic">&lt;, &gt;&lt;exec</span>&gt;]&gt; { <span class="italic">SQL operation</span> };
</pre><p>Specify the connection context instance inside square brackets following the <code class="codeph">#sql</code> token. For example, in the following SQLJ statement, the connection context instance is <code class="codeph">myOrderConn</code> from the previous example:
                        </p><pre class="oac_no_warn" dir="ltr">#sql [myOrderConn] { UPDATE TAB2 SET COL1 = :w WHERE :v &lt; COL2 };
</pre><p>In this way, you can specify an instance of either the <code class="codeph">DefaultContext</code> class or any declared connection context class.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-80F22B68-1771-4D63-962C-F88CE0E7F896">Closing a Connection Context Instance</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>It is advisable to close all connection context instances when you are done. Each connection context class includes a <code class="codeph">close()</code> method, as discussed for the <code class="codeph">DefaultContext</code> class in <span class="q">"<a href="key-programming-considerations.html#GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC">Closing Connections</a>"</span>.
                        </p>
                        <p>In closing a connection context instance that shares the underlying connection with another connection instance, you might want to keep the underlying connection open.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ503"></a><div class="props_rev_3"><a id="GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F" name="GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F"></a><h4 id="JSQLJ-GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F" class="sect4">Example of Multiple Connection Contexts</h4>
                  <div>
                     <p>The following is an example of a SQLJ application using multiple connection contexts. It implicitly uses an instance of the <code class="codeph">DefaultContext</code> class for one set of SQL entities and an instance of the declared <code class="codeph">DeptContext</code> connection context class for another set of SQL entities.
                     </p>
                     <p>This example uses the static <code class="codeph">Oracle.connect()</code> method to establish a default connection, then constructs an additional connection by using the static <code class="codeph">Oracle.getConnection()</code> method to pass another <code class="codeph">DefaultContext</code> instance to the <code class="codeph">DeptContext</code> constructor. As previously mentioned, this is just one of several ways you can construct a SQLJ connection context instance.
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.SQLException;
import oracle.sqlj.runtime.Oracle;

// declare a new context class for obtaining departments
#sql context DeptContext;

#sql iterator Employees (String ename, int deptno);

class MultiSchemaDemo 
{
  public static void main(String[] args) throws SQLException 
  {
    // set the default connection to the URL, user, and password
    // specified in your connect.properties file
    Oracle.connect(MultiSchemaDemo.class, "connect.properties");

    // create a context for querying department info using
    // a second connection
    DeptContext deptCtx = 
      new DeptContext(Oracle.getConnection(MultiSchemaDemo.class, 
                     "connect.properties"));

    new MultiSchemaDemo().printEmployees(deptCtx);
    deptCtx.close();
  }

  // performs a join on deptno field of two tables accessed from
  // different connections. 
  void printEmployees(DeptContext deptCtx) throws SQLException
  {
    // obtain the employees from the default context
    Employees emps;
    #sql emps = { SELECT first_name, department_id FROM employees }; 

    // for each employee, obtain the department name
    // using the dept table connection context
    while (emps.next()) {
      String dname;
      int deptno = emps.deptno();
      #sql [deptCtx] { 
        SELECT dname INTO :dname FROM departments WHERE department_id = :deptno
      };
      System.out.println("employee: " +emps.ename() +
                         ", department: " + dname);
    }
    emps.close();
  }
}
</pre></div>
               </div><a id="JSQLJ505"></a><a id="JSQLJ506"></a><a id="JSQLJ504"></a><div class="props_rev_3"><a id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C" name="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C"></a><h4 id="JSQLJ-GUID-50ACAE7A-118A-4D0B-B18B-03813798054C" class="sect4">Implementation and Functionality of Connection Context Classes</h4>
                  <div>
                     <p>This section discusses how SQLJ implements connection context classes, including the <code class="codeph">DefaultContext</code> class, and what noteworthy methods they contain. As mentioned earlier, the <code class="codeph">DefaultContext</code> class and all generated connection context classes implement the <code class="codeph">ConnectionContext</code> interface.
                     </p>
                     <div class="infoboxnote" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-8FB01559-8F2A-4BAD-987A-680D26ADFFA5">
                        <p class="notep1">Note:</p>
                        <p>Extending connection context classes is not permitted in the SQLJ specification and is not supported by the Oracle SQLJ implementation.</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-A5EA131A-0CC0-4ABD-A62C-E9B8641BF263">ConnectionContext Interface</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Each connection context class implements the <code class="codeph">sqlj.runtime.ConnectionContext</code> interface.
                        </p>
                        <p><a id="d36232e718" class="indexterm-anchor"></a><a id="d36232e722" class="indexterm-anchor"></a><a id="d36232e726" class="indexterm-anchor"></a><a id="d36232e730" class="indexterm-anchor"></a>Basic methods specified by this interface include the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">close(boolean CLOSE_CONNECTION/KEEP_CONNECTION)</code>: Releases all resources used in maintaining this connection and closes any open connected profiles. It may close the underlying JDBC connection, depending on whether <code class="codeph">CLOSE_CONNECTION</code> or <code class="codeph">KEEP_CONNECTION</code> is specified. These are static boolean constants of the <code class="codeph">ConnectionContext</code> interface.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getConnection()</code>: Returns the underlying JDBC connection object for this connection context instance.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getExecutionContext()</code>: Returns the default <code class="codeph">ExecutionContext</code> instance for this connection context instance.
                              </p>
                              <div class="infoboxnotealso" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-90D1763B-32BA-49FF-AEE1-44A42096A270">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">Execution Contexts</a>"</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-79031DD9-BCA2-49BB-94FF-F57E986DFF3B">Additional Connection Context Class Methods</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In addition to the methods specified and defined in the <code class="codeph">ConnectionContext</code> interface, each connection context class defines the following methods:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic"><code class="codeph">YourCtxClass</code></span><code class="codeph"> getDefaultContext()</code>: This is a static method that returns the default connection context instance for a given connection context class.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setDefaultContext(</code><span class="italic"><code class="codeph">YourCtxClass</code></span><code class="codeph"> </code><span class="italic"><code class="codeph">connctxinstance</code></span><code class="codeph">)</code>: This is a static method that defines the given connection context instance as the default connection context instance for its class.
                              </p>
                           </li>
                        </ul>
                        <p>Although it is true that you can use an instance of only the <code class="codeph">DefaultContext</code> class as your default connection, it might still be useful to designate an instance of a declared connection context class as the default context for that class, using the <code class="codeph">setDefaultContext()</code> method. Then you could conveniently retrieve it using the <code class="codeph">getDefaultContext()</code> method of the particular class. This would enable you, for example, to specify a connection context instance for a SQLJ executable statement as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql context MyContext;

...
MyContext myctx1 = new MyContext(<span class="italic">url, user, password, autocommit</span>);
...
MyContext.setDefaultContext(myctx1);
...
#sql [MyContext.getDefaultContext()] { <span class="italic">SQL operations</span> };
...
</pre><p>Additionally, each connection context class defines methods for control of SQLJ statement caching. The following are the static methods:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">setDefaultStmtCacheSize(int)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getDefaultStmtCacheSize()</code></p>
                           </li>
                        </ul>
                        <p>The following are the instance methods:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">setStmtCacheSize(int)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getStmtCacheSize()</code></p>
                           </li>
                        </ul>
                        <p>By default, statement caching is enabled.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ507"></a><div class="props_rev_3"><a id="GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC" name="GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC"></a><h4 id="JSQLJ-GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC" class="sect4">Using the IMPLEMENTS Clause in Connection Context Declarations</h4>
                  <div>
                     <p>There may be situations where it is useful to implement an interface in your connection context declarations. For example, you may want to define an interface that exposes just a subset of the functionality of a connection context class. More specifically, you may want a class that has the <code class="codeph">getConnection()</code> functionality, but does not have other functionality of a connection context class.
                     </p>
                     <p>You can create an interface called <code class="codeph">HasConnection</code>, for example, that specifies a <code class="codeph">getConnection()</code> method, but does not specify other methods found in a connection context class. You can then declare a connection context class but expose only the <code class="codeph">getConnection()</code> functionality by assigning a connection context instance to a variable of the <code class="codeph">HasConnection</code> type, instead of to a variable that has the type of your declared connection context class.
                     </p>
                     <p>Assuming <code class="codeph">HasConnection</code> is in the <code class="codeph">mypackage</code> package, the declaration will be as follows:
                     </p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext implements mypackage.HasConnection;
</pre><p>You can then instantiate a connection instance as follows:</p><pre class="oac_no_warn" dir="ltr">HasConnection myConn = new MyContext (<span class="italic">url</span>, <span class="italic">username</span>, <span class="italic">password, autocommit</span>);
</pre><p>For example:</p><pre class="oac_no_warn" dir="ltr">HasConnection myConn = new MyContext 
   ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", true);</pre></div>
               </div><a id="JSQLJ508"></a><div class="props_rev_3"><a id="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1" name="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1"></a><h4 id="JSQLJ-GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1" class="sect4">Semantics-Checking of Your Connection Context Usage</h4>
                  <div>
                     <div class="section">
                        <p>A significant feature of SQLJ is strong typing of connections, with each connection context class typically used for operations on a particular set of interrelated SQL entities. This does not mean that all the connection instances of a single class use the same physical entities. Instead, they use entities that have the same properties, such as names and privileges associated with tables and views, data types of their rows, and names and definitions of stored procedures. This strong typing allows SQLJ semantics-checking to verify during translation that you are using your SQL operations correctly, with respect to your database connections.</p>
                        <p>To use online semantics-checking during translation, provide a sample schema, which includes an appropriate set of SQL entities, for each connection context class. These sample schemas are referred to as exemplar schemas. Provide exemplar schemas through an appropriate combination of the SQLJ <code class="codeph">-user</code>, <code class="codeph">-password</code>, and <code class="codeph">-url</code> options. Following are two examples, one for the <code class="codeph">DefaultContext</code> class and one for a declared connection context class, where the user, password, and URL are all specified through the <code class="codeph">-user</code> option:
                        </p><pre class="oac_no_warn" dir="ltr">-user=HR/hr@jdbc:oracle:oci:@
-user@MyContext=HR/hr@jdbc:oracle:oci:@
</pre><p>During semantics-checking, the translator connects to the specified exemplar schema for a particular connection context class and accomplishes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It examines each SQLJ statement in your code that specifies an instance of the connection context class and checks its SQL operations, such as what tables you access and what stored procedures you use.</p>
                           </li>
                           <li>
                              <p>It verifies that entities in the SQL operations match the set of entities existing in the exemplar schema.</p>
                           </li>
                        </ul>
                        <p>It is your responsibility to pick an exemplar schema that represents the run-time schema in appropriate ways. For example, it must have tables, views, stored functions, and stored procedures with names and data types that match what are used in your SQL operations, and with privileges set appropriately.</p>
                        <p>If no appropriate exemplar schema is available during translation for one of your connection context classes, then it is not necessary to specify SQLJ translator options for that particular connection context class. In that case, SQLJ statements specifying connection objects of that connection context class are semantically checked only to the extent possible. </p>
                        <div class="infoboxnote" id="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1__GUID-DEBBFCFC-1622-42D2-9EAD-34BEF758E92E">
                           <p class="notep1">Note:</p>
                           <p>Remember that the exemplar schema you specify in your translator option settings does not specify the schema to be used at run time. The exemplar schema furnishes the translator only with a set of SQL entities to compare against the entities you use in your SQLJ executable statements.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ510"></a><a id="JSQLJ511"></a><a id="JSQLJ512"></a><a id="JSQLJ513"></a><a id="JSQLJ509"></a><div class="props_rev_3"><a id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314" name="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314"></a><h4 id="JSQLJ-GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314" class="sect4">Standard Data Source Support</h4>
                  <div>
                     <p>The JDBC 2.0 extended application programming interface (API) specifies the use of data sources and Java Naming and Directory Interface (JNDI) as a portable alternative to the <code class="codeph">DriverManager</code> mechanism for obtaining JDBC connections. It permits database connections to be established through a JNDI name lookup. This name is bound to a particular database and schema prior to program run time through a <code class="codeph">javax.sql.DataSource</code> object, typically installed through a graphical user interface (GUI) JavaBeans deployment tool. The name can be bound to different physical connections without any source code changes simply by rebinding the name in the directory service.
                     </p>
                     <p>SQLJ uses the same mechanism to create connection context instances in a flexible and portable way. Data sources can also be implemented using a connection pool or distributed transaction service, as defined by the JDBC 2.0 extended API.</p>
                     <div class="infoboxnotealso" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-62C40DAA-B075-4215-86F3-02672587D93F">
                        <p class="notep1">See Also:</p>
                        <p><span class="italic"><a href="../jjdbc/data-sources-and-URLs.html#JJDBC-GUID-44572C63-10D2-478A-BB2E-ACF6674C59CC" target="_blank"><span><cite>Oracle Database JDBC Developerâ€™s Guide</cite></span></a></span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-45B351FF-937F-415D-88F7-17BE5417A606">Associating a Connection Context with a Data Source</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In SQLJ it is natural to associate a connection context class with a logical schema, in much the same way that a data source name serves as a symbolic name for a JDBC connection. Combine both concepts by adding the data source name to the connection context declaration. For example:</p><pre class="oac_no_warn" dir="ltr">#sql context EmpCtx with (dataSource="jdbc/EmpDB");
</pre><p>Any connection context class that you declare with a <code class="codeph">dataSource</code> property provides additional constructors. To continue the <code class="codeph">EmpCtx</code> example, the following constructors are provided:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">EmpCtx()</code>: Looks up the data source for <code class="codeph">jdbc/EmpDB</code> and then calls the <code class="codeph">getConnection()</code> method on the data source to obtain a connection.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String user, String password)</code>: Looks up the data source for <code class="codeph">jdbc/EmpDB</code> and calls the <code class="codeph">getConnection(user,password)</code> method on the data source to obtain a connection.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(ConnectionContext ctx)</code>: Delegates to <code class="codeph">ctx</code> to obtain a connection.
                              </p>
                           </li>
                        </ul>
                        <p>Any connection context class declared with a <code class="codeph">dataSource</code> property also omits a number of <code class="codeph">DriverManager</code>-based constructors. Continuing the <code class="codeph">EmpCtx</code> example, the following constructors are omitted:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">EmpCtx(Connection conn)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String url, String user, String password, boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String url, boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String url, java.util.Properties info, boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String url, boolean autoCommit)</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-7461EAE5-2788-4993-85CB-B77133B74C55">Auto-Commit Mode for Data Source Connections</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The constructors based on data source, unlike those base on <code class="codeph">DriverManager</code>, do not include an explicit auto-commit parameter. They always use the auto-commit mode defined by the data source.
                        </p>
                        <p>Data sources are configured to have a default auto-commit mode depending on the deployment scenario. For example, data sources in the server and middle tier typically have auto-commit off. Those on the client may have it on. However, it is also possible to configure data sources with a specific auto-commit setting. This permits data sources to be configured for a particular application and deployment scenario. Contrast this with JDBC URLs that may specify only a single database/driver configuration.</p>
                        <p>Programs can verify and possibly override the current auto-commit setting with the JDBC connection that underlies their connection context instance.</p>
                        <div class="infoboxnote" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-5862CCBB-C2EB-4542-A78D-CD1092B83AF0">
                           <p class="notep1">Note:</p>
                           <p>Be aware of the following points related to the auto-commit status of the connections you establish:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If you use the <code class="codeph">Oracle</code> class, then auto-commit is off unless you turn it on explicitly.
                                 </p>
                              </li>
                              <li>
                                 <p>If you use <code class="codeph">DefaultContext</code> or a connection context class with <code class="codeph">DriverManager</code>-style constructors, then the auto-commit setting must always be specified explicitly.
                                 </p>
                              </li>
                              <li>
                                 <p>If you use the data source mechanism, then the auto-commit setting is inherited from the underlying data source. In most environments, the data source object originates from JDBC and the auto-commit option is on. To avoid unexpected behavior, always check the auto-commit setting.</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-C5C42120-10E9-478E-BC61-B6D70DF871A7">Associating a Data Source with the Default Context</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If a SQLJ program accesses the default connection context, and the default context has not yet been set, then the SQLJ run time will use the SQLJ default data source to establish its connection. The SQLJ default data source is bound to the JNDI name, <code class="codeph">jdbc/defaultDataSource</code>.
                        </p>
                        <p>This mechanism provides a portable means to define and install a default JDBC connection for the default SQLJ connection context.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-4F4371B0-BF40-452F-91D8-0E31D9965AEF">Data Source Support Requirements</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>For your program to use data sources, you must supply the <code class="codeph">javax.sql.*</code> and <code class="codeph">javax.naming.*</code> packages and an <code class="codeph">InitialContext</code> provider in your Java environment. The latter is required to obtain the JNDI context in which the SQLJ run time can look up the data source object.
                        </p>
                        <p>All SQLJ run-time libraries provided by Oracle support data sources. However, if you use the <code class="codeph">runtime12ee</code> library you must have <code class="codeph">javax.sql.*</code> and <code class="codeph">javax.naming.*</code> in your classpath in order for the run time to load. By contrast, the other run-time libraries use reflection to retrieve <code class="codeph">DataSource</code> objects.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ515"></a><a id="JSQLJ516"></a><a id="JSQLJ517"></a><a id="JSQLJ514"></a><div class="props_rev_3"><a id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75" name="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75"></a><h4 id="JSQLJ-GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75" class="sect4">SQLJ-Specific Data Sources</h4>
                  <div>
                     <div class="section">
                        <p>The Oracle SQLJ implementation provides SQLJ-specific data source support in the <code class="codeph">runtime12ee</code> library. Currently, SQLJ-specific data sources can be used in client-side or middle-tier applications, but not inside the server.
                        </p>
                        <p>SQLJ-specific data sources extend JDBC data source functionality with methods that return SQLJ connection context instances. This enables a SQLJ developer to manage connection contexts just as a JDBC developer manages connections. In general, each SQLJ-specific data source interface or class is based on a corresponding standard JDBC data source interface or Oracle data source class.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-FBCC4E11-8F48-4663-BF27-A5B6D69973CE">SQLJ Data Source Interfaces</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">sqlj.runtime.ConnectionContextFactory</code> interface acts as a base interface for SQLJ data source functionality. It is implemented by a set of more specialized Oracle data source interfaces that add support for features such as connection pooling, connection caching, or distributed transactions.
                        </p>
                        <p>The <code class="codeph">ConnectionContextFactory</code> interface specifies the following methods to return SQLJ connection context instances:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext(boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext(String user,                                  String password)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext(String user,                  String password, boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext(Class aContextClass)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext(Class aContextClass,                               boolean autoCommit)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext(Class aContextClass,                               String user, String password)</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext(Class aContextClass,           String user, String password, boolean autoCommit)</code></p>
                           </li>
                        </ul>
                        <p>The <code class="codeph">getDefaultContext</code> methods return a <code class="codeph">sqlj.runtime.ref.DefaultContext</code> instance for the SQLJ default context. The <code class="codeph">getContext()</code> methods return a <code class="codeph">sqlj.runtime.ConnectionContext</code> instance. Specifically, it returns an instance of a user-declared connection context class that is specified in the method call.
                        </p>
                        <p>For both <code class="codeph">getDefaultContext()</code> and <code class="codeph">getContext()</code>, there are signatures that enable you to specify connection parameters for the JDBC connection that underlies the connection context instance: the auto-commit setting, user and password settings, or all three. If you do not specify the user and password, then they are obtained from the underlying data source that generates the connection. If you do not specify an auto-commit setting, then the default is <code class="codeph">false</code> unless it was explicitly set to <code class="codeph">true</code> for the underlying data source.
                        </p>
                        <p>Each Oracle data source interface that implements <code class="codeph">ConnectionContextFactory</code> also implements a standard JDBC data source interface to specify methods for the appropriate functionality, such as for basic data sources, connection pooling data sources, or distributed transaction (XA) data sources. Oracle has implemented the <code class="codeph">SqljDataSource</code>, <code class="codeph">SqljConnectionPoolDataSource</code>, and <code class="codeph">SqljXADataSource</code> interfaces, located in the <code class="codeph">sqlj.runtime</code> package and specified as follows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">interface SqljDataSource extends javax.sql.DataSource, ConnectionContextFactory { }</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">interface SqljDataSource extends javax.sql.ConnectionPoolDataSource, ConnectionContextFactory { }</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">interface SqljXADataSource extends javax.sql.XADataSource, ConnectionContextFactory { }</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-DF84B27E-A754-4FF1-B008-886DC399D0A4">SQLJ Data Source Classes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle provides SQLJ-specific counterparts for the following JDBC data source classes: <code class="codeph">OracleDataSource</code>, <code class="codeph">OracleConnectionPoolDataSource</code>, <code class="codeph">OracleXADataSource</code>, <code class="codeph">OracleConnectionCacheImpl</code>, <code class="codeph">OracleXAConnectionCacheImpl</code>, and <code class="codeph">OracleOCIConnectionPool</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-BE239C0B-0DAB-41BC-9970-D90C51D2D799">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/JDBC-support-Oracle-FAN.html#JJDBC-GUID-069265AF-BBEE-4682-9906-98D8429BFC1C" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                        </div>
                        <p>Oracle SQLJ-specific data source classes are located in two packages: <code class="codeph">oracle.sqlj.runtime</code> and <code class="codeph">oracle.sqlj.runtime.client</code>.
                        </p>
                        <p>The <code class="codeph">oracle.sqlj.runtime</code> package includes the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">class OracleSqljDataSource  extends oracle.jdbc.pool.OracleDataSource implements ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-4B2EC029-EBF1-4BDD-8E4F-2C1FE1C1720B">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">OracleSqljDataSource</code> class implements the <code class="codeph">java.io.Serializable</code> interface. It is therefore serializable and can be used in clustered environments, such as Oracle9<span class="italic">i</span> Application Server Containers for J2EE (OC4J).
                           </p>
                        </div>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">class OracleSqljConnectionPoolDataSource extends oracle.jdbc.pool.OracleConnectionPoolDataSource implements ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">abstract class OracleSqljXADataSource extends oracle.jdbc.xa.OracleXADataSource implements ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljConnectionCacheImpl extends oracle.jdbc.pool.OracleConnectonCacheImpl implements ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljXAConnectionCacheImpl extends oracle.jdbc.pool.OracleXAConnectonCacheImpl implements ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljOCIConnectionPool extends oracle.jdbc.pool.OracleOCIConnectionPool implements ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-CCD4E6F2-3D03-476F-BCB0-81B53D52BFE4">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If you are using <code class="codeph">OracleSqljConnectionCacheImpl</code>, then you need to replace it with <code class="codeph">OracleSqljDataSource</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>If you are using <code class="codeph">OracleSqljXAConnectionCacheImpl</code>, then you need to replace it with <code class="codeph">OracleSqljXADataSource</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>The <code class="codeph">oracle.sqlj.runtime.client</code> package includes the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">class OracleSqljXADataSource extends oracle.jdbc.xa.client.OracleXADataSource implements ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <p>You can use these classes in place of the corresponding JDBC classes that they extend. They include the <code class="codeph">getDefaultContext()</code> and <code class="codeph">getContext()</code> methods. When you call these methods, the following steps take place for you:
                        </p>
                        <ol>
                           <li>
                              <p>A new logical JDBC connection is acquired from the present data source.</p>
                           </li>
                           <li>
                              <p>A connection context instance is created from the logical connection and returned.</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-5AFFB2E6-73DA-41CA-9DD6-B8512976A7B2">Examples: Using SQLJ Data Sources</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When used in middle-tier environments, SQLJ-specific data sources, like JDBC data sources, are bound to JNDI locations. You can do the binding explicitly, as in the following example:</p><pre class="oac_no_warn" dir="ltr">//Initialize the data source 
SqljXADataSource sqljDS = new OracleSqljXADataSource(); 
sqljDS.setUser("HR"); 
sqljDS.setPassword("hr"); 
sqljDS.setServerName("myserver"); 
sqljDS.setDatabaseName("orcl"); 
sqljDS.setDataSourceName("jdbc/OracleSqljXADS"); 

//Bind the data source to JNDI 
Context ctx = new InitialContext(); 
ctx.bind("jdbc/OracleSqljXADS");
</pre><p>In a middle-tier OC4J environment, another alternative is to instantiate data sources and bind them to JNDI through settings in the <code class="codeph">j2ee/home/config/data-sources.xml</code> file. For example, the following <code class="codeph">&lt;data-source&gt;</code> element in that file creates an <code class="codeph">OracleSqljXADataSource</code> instance and binds it to the JNDI location, <code class="codeph">jdbc/OracleSqljXADS</code>:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;data-source 
     class="oracle.sqlj.runtime.OracleSqljXADataSource" 
     name="jdbc/OracleSqljXADS" 
     location="jdbc/OracleSqljXADS" 
     xa-location="jdbc/OracleSqljXADS/xa" 
     username="HR" 
     password="hr" 
     url="jdbc:oracle:thin:@myhost:5221/myservice" 
/&gt;
</pre><p>A SQLJ-specific data source bound to a JNDI location can be looked up and used in creating connection context instances. The following code segment uses information from the preceding <code class="codeph">&lt;data-source&gt;</code> element to create connection context instances, a <code class="codeph">DefaultContext</code> instance and an instance of a user-declared <code class="codeph">MyCtx</code> class, respectively:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.SqljDataSource sqljDS; 
InitialContext initCtx = new InitialContext(); 
sqljDS = (sqlj.runtime.SqljDataSource)initCtx.lookup("jdbc/OracleSqljXADS"); 
// getDefaultContext
DefaultContext ctx = sqljDS.getDefaultContext(); 
// getContext
/* Declare MyCtx connection context class. You could optionally use a "with"
   clause to specify  any desired connection parameters not available 
   through the underlying data source.
*/
#sql public static context MyCtx; 
MyCtx ctx = (MyCtx) sqljDS.getContext(MyCtx.class);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ519"></a><a id="JSQLJ520"></a><a id="JSQLJ521"></a><a id="JSQLJ518"></a><div class="props_rev_3"><a id="GUID-51755815-E5DB-41A3-8427-8969A0B90404" name="GUID-51755815-E5DB-41A3-8427-8969A0B90404"></a><h4 id="JSQLJ-GUID-51755815-E5DB-41A3-8427-8969A0B90404" class="sect4">SQLJ-Specific Connection JavaBeans for JavaServer Pages</h4>
                  <div>
                     <p>Oracle has implemented a set of JavaBeans for database connections from within Java Server Pages (JSP) pages.</p>
                     <p>The Oracle SQLJ implementation provides the following extensions of these JavaBeans in the <code class="codeph">runtime12ee</code> library for use in SQLJ JSP pages:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">oracle.sqlj.runtime.SqljConnBean</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">oracle.sqlj.runtime.SqljConnCacheBean</code></p>
                        </li>
                     </ul>
                     <p><code class="codeph">ConnBean</code> and <code class="codeph">ConnCacheBean</code> include methods that return JDBC connection objects. <code class="codeph">SqljConnBean</code> and <code class="codeph">SqljConnCacheBean</code> extend this functionality to support a bean property called <code class="codeph">ContextClass</code> of type <code class="codeph">String</code> and to return SQLJ connection context instances.
                     </p>
                     <div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-BBB8AFC1-7E8B-428F-A5B4-F0E888C9035B">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">SqljConnBean</code> class implements the <code class="codeph">java.io.Serializable</code> interface. It is therefore serializable and can be used in clustered environments, such as OC4J.
                        </p>
                     </div>
                     <p><code class="codeph">SqljConnBean</code> and <code class="codeph">SqljConnCacheBean</code> provide the following methods:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">void setContextClass(String contextClassName)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">String getContextClass()</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DefaultContext getDefaultContext()</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ConnectionContext getContext()</code></p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">ContextClass</code> property specifies the name of a user-declared connection context class, if you are not using <code class="codeph">DefaultContext</code>. You can set this property through the <code class="codeph">setContextClass()</code> method.
                     </p>
                     <p>To retrieve a connection context instance, use <code class="codeph">getDefaultContext()</code> or <code class="codeph">getContext()</code>, as appropriate. The former returns a <code class="codeph">sqlj.runtime.ref.DefaultContext</code> instance, and the latter returns a <code class="codeph">sqlj.runtime.ConnectionContext</code> instance, specifically, an instance of the class specified in the <code class="codeph">ContextClass</code> property (by default, <code class="codeph">DefaultContext</code>).
                     </p>
                     <p>However, note that the <code class="codeph">getDefaultContext()</code> and <code class="codeph">getContext()</code> methods are implemented differently between <code class="codeph">SqljConnBean</code> and <code class="codeph">SqljConnCacheBean</code>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-11696AA5-2A6E-4787-9A24-534E6ED5503A">Behavior of SqljConnBean (Simple Connections)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>A <code class="codeph">SqljConnBean</code> instance can wrap only one logical JDBC connection and one SQLJ connection context instance at any given time.
                        </p>
                        <p>The first <code class="codeph">getDefaultContext()</code> or <code class="codeph">getContext()</code> method call will create and return a connection context instance based on the underlying JDBC connection. This connection context instance will also be stored in the <code class="codeph">SqljConnBean</code> instance. 
                        </p>
                        <p>Once a connection context instance has been created and stored, the behavior of subsequent <code class="codeph">getDefaultContext()</code> or <code class="codeph">getContext()</code> calls will depend on the type of the stored connection context and, for <code class="codeph">getContext()</code>, on the connection context type specified in the <code class="codeph">ContextClass</code> property, as follows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>For subsequent <code class="codeph">getDefaultContext()</code> calls:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the stored connection context instance is a <code class="codeph">DefaultContext</code> instance: The method will keep returning that instance.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If the stored connection context instance is <span class="italic">not</span> a <code class="codeph">DefaultContext</code> instance: The method will close the stored connection context instance and reuse the underlying JDBC connection to create and return a new connection context as a <code class="codeph">DefaultContext</code> instance (regardless of the previous connection context type). This becomes the new connection context instance stored in the <code class="codeph">SqljConnBean</code> instance.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>For subsequent <code class="codeph">getContext()</code> calls:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the stored connection context instance is of the same type as that specified by the <code class="codeph">ContextClass</code> property: The method will keep returning that instance. 
                                    </p>
                                 </li>
                                 <li>
                                    <p>If the stored connection context instance is <span class="italic">not</span> of the same type as that specified by <code class="codeph">ContextClass</code>: The method will close the stored connection context instance and reuse the underlying JDBC connection to create and return a new connection context instance, an instance of what is specified in <code class="codeph">ContextClass</code>. This becomes the new connection context instance stored in the <code class="codeph">SqljConnBean</code> instance.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-77F1FD48-462D-42E6-95BA-F79F499B96DA">
                           <p class="notep1">Note:</p>
                           <p>When <code class="codeph">SqljConnBean</code> closes a connection context instance, it does so with the <code class="codeph">KEEP_CONNECTION</code> setting, leaving the underlying JDBC connection intact.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-6948CC15-2E02-4A7E-89FD-520AE7BEEAC5">Behavior of SqljConnCacheBean (Connection Caching)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Unlike with <code class="codeph">SqljConnBean</code>, the <code class="codeph">SqljConnCacheBean</code> JavaBean creates and returns a new connection context instance, based on a new logical JDBC connection, for each invocation of <code class="codeph">getDefaultContext()</code> or <code class="codeph">getContext()</code>. The connection context type will be <code class="codeph">DefaultContext</code> for a <code class="codeph">getDefaultContext()</code> call or the type specified in the <code class="codeph">ContextClass</code> property for a <code class="codeph">getContext()</code> call.
                        </p>
                        <p><code class="codeph">SqljConnCacheBean</code> does not store the connection context instances it creates.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-0EC57B36-69AF-4EE6-9684-2CA57AA6A3C2">Example: SQLJ JSP Page Using SqljConnCacheBean</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following program, <code class="codeph">SQLJSelectInto.sqljsp</code>, demonstrates the use of <code class="codeph">SqljConnCacheBean</code>, its <code class="codeph">ContextClass</code> bean property, and its <code class="codeph">getContext()</code> method:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;%@ page language="sqlj" 
         import="java.sql.*, oracle.sqlj.runtime.SqljConnCacheBean" %&gt; 
&lt;jsp:useBean id="cbean" class="oracle.sqlj.runtime.SqljConnCacheBean"
             scope="session"&gt; 
     &lt;jsp:setProperty name="cbean" property="User" value="HR"/&gt; 
     &lt;jsp:setProperty name="cbean" property="Password" value="hr"/&gt; 
     &lt;jsp:setProperty name="cbean" property="URL"
                      value="jdbc:oracle:thin:@myhost:5221/myservice"/&gt; 
     &lt;jsp:setProperty name="cbean" property="ContextClass"
                      value="sqlj.runtime.ref.DefaultContext"/&gt; 
&lt;/jsp:useBean&gt; 
&lt;HTML&gt; 
&lt;HEAD&gt; &lt;TITLE&gt; The SQLJSelectInto JSP  &lt;/TITLE&gt; &lt;/HEAD&gt; 
&lt;BODY BGCOLOR=white&gt; 
&lt;% String empno = request.getParameter("employee_id"); 
   if (empno != null) { %&gt; 
      &lt;H3&gt; Employee # &lt;%=empno %&gt; Details: &lt;/H3&gt; 
      &lt;% String ename = null;  double sal = 0.0;  String hireDate = null; 
         StringBuffer sb = new StringBuffer(); 
         sqlj.runtime.ref.DefaultContext ctx=null; 
         try { 
           // Make the Connection 
           ctx = (sqlj.runtime.ref.DefaultContext) cbean.getContext(); 
         } catch (SQLException e) { 
         } 
          try { 
             #sql [ctx] { SELECT first_name, salary, TO_CHAR(hire_date, 'DD-MON-YYYY') 
                           INTO :ename, :sal, :hireDate 
                           FROM HR.employees WHERE UPPER(employee_id) = UPPER(:empno) 
             }; 
             sb.append("&lt;BLOCKQUOTE&gt;&lt;BIG&gt;&lt;B&gt;&lt;PRE&gt;\n"); 
             sb.append("Name       : " + ename + "\n"); 
             sb.append("Salary     : " + sal + "\n"); 
             sb.append("Date hired : " + hireDate); 
             sb.append("&lt;/PRE&gt;&lt;/B&gt;&lt;/BIG&gt;&lt;/BLOCKQUOTE&gt;"); 
          } catch (java.sql.SQLException e) { 
              sb.append("&lt;P&gt; SQL error: &lt;PRE&gt; " + e + " &lt;/PRE&gt; &lt;/P&gt;\n"); 
          } finally { 
              if (ctx!= null) ctx.close(); 
          } 
      %&gt; 
     &lt;H3&gt;&lt;%=sb.toString()%&gt;&lt;/H3&gt; 
&lt;%} 
%&gt; 
&lt;B&gt;Enter an employee number:&lt;/B&gt; 
&lt;FORM METHOD=get&gt; 
&lt;INPUT TYPE="text" NAME="empno" SIZE=10&gt; 
&lt;INPUT TYPE="submit" VALUE="Ask Oracle"); 
&lt;/FORM&gt; 
&lt;/BODY&gt; 
&lt;/HTML&gt; 
</pre><div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-68B47675-DB96-4AC7-A297-D8D616E8B2F6">
                           <p class="notep1">Note:</p>
                           <p>This example uses the <code class="codeph">ContextClass</code> property for illustrative purposes. However, be aware that <code class="codeph">DefaultContext</code> is the default value anyway and if you want to use <code class="codeph">DefaultContext</code>, then the value of <code class="codeph">ContextClass</code> is irrelevant, if you use <code class="codeph">getDefaultContext()</code> instead of <code class="codeph">getContext()</code>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ523"></a><a id="JSQLJ524"></a><a id="JSQLJ525"></a><a id="JSQLJ526"></a><a id="JSQLJ527"></a><a id="JSQLJ528"></a><a id="JSQLJ529"></a><a id="JSQLJ530"></a><a id="JSQLJ531"></a><a id="JSQLJ532"></a><a id="JSQLJ533"></a><a id="JSQLJ522"></a><div class="props_rev_3"><a id="GUID-02D73030-0352-4669-9152-0A331260FBC8" name="GUID-02D73030-0352-4669-9152-0A331260FBC8"></a><h4 id="JSQLJ-GUID-02D73030-0352-4669-9152-0A331260FBC8" class="sect4">SQLJ Support for Global Transactions</h4>
                  <div>
                     <p>A distributed transaction, sometimes referred to as a global transaction, is a set of two or more related transactions that must be managed in a coordinated way. The transactions that constitute a distributed transaction might be in the same database, but more typically are in different databases and often in different locations. Each individual transaction of a distributed transaction is referred to as a transaction branch.</p>
                     <p>The X/Open Distributed Transaction Processing (DTP) architecture defines a standard architecture that enables multiple but related transactions belonging to the same resource manager or different resource managers to work as a single unit. It coordinates the work between an application program (AP) and a resource manager (RM) into global transactions. Either all the transactions are committed or rolled back.</p>
                     <p>The Oracle XA library is an external interface that enables transaction managers other than Oracle server to coordinate global transactions. XA library use supports non-Oracle resource managers, in distributed transactions. This is particularly useful in transactions between several databases and resources. The implementation of the Oracle XA library conforms to the X/Open Distributed Transaction Processing (DTP) software architecture's XA interface specification. The Oracle XA Library is installed as part of Oracle Database Enterprise Edition.</p>
                     <div class="infoboxnote" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-6F94CB5F-4EAE-4585-98C4-04D4D35BBA76">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>JDBC provides several classes and interfaces to support XA. The OracleXADataSource implements the <code class="codeph">XADataSource</code> interface. The OracleXADatasource is a factory for XA connections. For more information refer to <span class="italic">Oracle Database JDBC Developerâ€™s Guide</span>.
                              </p>
                           </li>
                           <li>
                              <p>This document clearly specifies the methods supported by SQLJ to form a Connection Context in a XA application. To form the connection context, SQLJ uses the JDBC connection formed from the OracleXADataSource.</p>
                           </li>
                        </ul>
                     </div>
                     <div class="figure" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-4936CC72-C051-486F-BA48-6A46F19D4DE5">
                        <p class="titleinfigure">Figure 8-1 Global Transaction</p><img src="img/connection_context.gif" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/connection_context.html"><br><a href="img_text/connection_context.html">Description of "Figure 8-1 Global Transaction"</a></div>
                     <!-- class="figure" -->
                     <p>Following is an example of Distributed Transaction Processing (DTP) model:</p>
                     <p>The <span class="bold">transaction manager</span> is an external middle tier component residing outside Oracle Database. It provides an API for specifying the boundaries of the transaction and manages commit and recovery. The TM implements a two-phase commit engine to provide an <span class="italic">all-or-none</span> semantics across distributed RMs.
                     </p>
                     <p>A <span class="bold">resource manager</span> controls a shared, recoverable resource that can be returned to a consistent state after a failure. For example, Oracle is a resource manager.
                     </p>
                     <p>The <code class="codeph">javax.sql.XADataSource</code> interface outlines standard functionality of XA data sources. An XA data source is a factory for XA connections. Oracle JDBC implements the <code class="codeph">XADataSource</code> interface though the OracleXADatasource class. The <code class="codeph">getConnection( )</code> method of the OracleXADatasource class returns an XA connection to the underlying data source. In SQLJ, connections to the database can be obtained through the <code class="codeph">DefaultContext</code> class or the <code class="codeph">ConnectionContext</code> class. For multiple connections that use different SQL entities, it is advantageous to use connection context declarations to define additional connection context classes.
                     </p>
                     <p>The code snippet shows how to create an <code class="codeph">XADatasource</code> first and then a JDBC connection from the datasource through the following steps:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Start XA Resource1</p>
                        </li>
                        <li>
                           <p>Start XA Resource2</p>
                        </li>
                        <li>
                           <p>Perform DML operations with the first Connection object</p>
                        </li>
                        <li>
                           <p>End XA Resource1</p>
                        </li>
                        <li>
                           <p>End XA Resource2</p>
                        </li>
                        <li>
                           <p>Prepare Resource1</p>
                        </li>
                        <li>
                           <p>Prepare Resource2</p>
                        </li>
                        <li>
                           <p>Commit 1</p>
                        </li>
                        <li>
                           <p>Commit 2</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-22BF6171-EBE0-4D1B-912A-13B51C1CB927">
                        <p class="notep1">Note:</p>
                        <p>The following is not a complete example and contains only relevant codes to create and use an <code class="codeph">XADatasource</code>.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-AD1B6EA7-CA83-4E58-9002-098477294E99">Example: Creating an XADatasource and using it to create a JDBC connection</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import javax.sql.*;
import javax.transaction.*;
import javax.transaction.xa.*;
...
import oracle.jdbc.driver.*;
import oracle.jdbc.xa.OracleXid;
import oracle.jdbc.xa.OracleXAException;
import oracle.jdbc.xa.client.*;
â€¦â€¦â€¦â€¦
#sql context MyContext;
#sql iterator Iterator2 (String job_id, String job_title);
#sql iterator Iterator3 (String region_id, String region_name);
â€¦â€¦â€¦â€¦
class XA3mod{
public static void main (String args [])throws SQLException{
try{
<span class="bold">/*create an XADataSource instance*/</span>
OracleXADataSource oxds = new OracleXADataSource();
oxds.setURL(url);
oxds.setUser("hr");
oxds.setPassword("hr");
<span class="bold">/*get an XA connection to the underlying data source*/</span>
javax.sql.XAConnection pc1  = oxds.getXAConnection();
<span class="bold">/*use the same data source */</span>
javax.sql.XAConnection pc2  = oxds.getXAConnection();
<span class="bold">/*get the Physical Connections*/</span>
java.sql.Connection conn1 = pc1.getConnection();
java.sql.Connection conn2 = pc2.getConnection();
<span class="bold">/*an application may access data through multiple database connections. Each database connection is enlisted </span>
<span class="bold">with the transaction manager as a transactional resource. The transaction manager obtains an XAResource</span>
<span class="bold"> for each connection participating in a global transaction */</span>
XAResource oxar1 = pc1.getXAResource();
XAResource oxar2 = pc2.getXAResource();
<span class="bold">/*create the Xids With the Same Global Ids. The Xid interface is a Java mapping of the X/Open transaction</span> 
<span class="bold">identifier XID structure*/</span>
Xid xid1 = createXid(1);
Xid xid2 = createXid(2);
<span class="bold">/*start the Resources. This would start work on behalf of a transaction branch specified in xid1 and xid2. </span>
<span class="bold">The transaction manager uses the start method to associate the global transaction with the resource, </span>
<span class="bold">and it uses the end method to disassociate the transaction from the resource */</span>
oxar1.start (xid1, XAResource.TMNOFLAGS);
oxar2.start (xid2, XAResource.TMNOFLAGS);
<span class="bold">/*Do something with conn1 */</span>
DoSomeWork (conn1);
<span class="bold">/*END both the branches */</span>
xar1.end(xid1, XAResource.TMSUCCESS);
xar2.end(xid2, XAResource.TMSUCCESS);
<span class="bold">/*Prepare the RMs. The Oracle XA library interface follows the two-phase commit protocol. Preparing the transactions </span>
<span class="bold">is the first step in this protocol. The two phase commit protocol is explained in detail in the glossary section. */</span>
int prp1 =  oxar1.prepare (xid1);
int prp2 =  oxar2.prepare (xid2);
boolean do_commit = true;
if(!((prp1==XAResource.XA_OK)||(prp1==XAResource.XA_RDONLY)))
            do_commit = false;
if(!((prp2==XAResource.XA_OK)||(prp2==XAResource.XA_RDONLY)))
            do_commit = false;
<span class="bold">/*issue a commit on all transactions only if all the transactions completed without and errors. Rollback even </span>
<span class="bold">if a single transaction failed.*/</span>
if (prp1 == XAResource.XA_OK)
           if (do_commit)
           oxar1.commit (xid1, false);
           else
              oxar1.rollback (xid1);
if (prp2 == XAResource.XA_OK)
           if (do_commit)
              oxar2.commit (xid2, false);
           else
              oxar2.rollback (xid2);
<span class="bold">/* close connections */</span>
conn1.close(); conn1 = null;
conn2.close(); conn2 = null;
pc1.close();   pc1 = null;
pc2.close();   pc2 = null;
} catch (XAException xae){
if (xae instanceof OracleXAException) {
System.out.println("XA Error is " + ((OracleXAException)xae).getXAError());
System.out.println("SQL Error is " +((OracleXAException)xae).getOracleError());
}
}
} //end class
</pre><p>The following examples explain the different SQLJ methods that can accept a JDBC connection obtained from an OracleXADatasource.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-524405F0-0621-4214-B5DB-DE6B5CBADD3F">Using Oracle.connect( ) method with a JDBC connection obtained from an XA Datasource:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
Oracle.connect(conn);
#sql  {insert into xa_test values (1,:chr)};
try{
     Iterator3 iter = null;
     #sql iter = {SELECT id,name FROM xa_test};
     while (iter.next( )){
     System.out.print(iter.id());
     System.out.print(" ");
     System.out.println(iter.name());
     }
}
catch (Exception e){
     System.out.println(e);
     e.printStackTrace();
     }
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-0DB882A5-6A0F-4A8D-9286-F5D165CAFE96">Using Oracle.getConnection( ) method with a JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
DefaultContext  ctx = Oracle.getConnection(conn);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-6EA7A070-B3A7-4894-AAF6-17AE6A6FB145">Using  DefaultContext Constructor  with a JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
DefaultContext  ctx = new DefaultContext(conn)
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
Iterator3 iter = null;
#sql [ctx] iter = {SELECT id,name FROM xa_test};
while (iter.next( )){
System.out.print(iter.id());
System.out.print(" ");
System.out.println(iter.name());
}
}
catch (Exception e){
System.out.println(e);
e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-4A823490-533C-4DD0-A6C7-7043C6FC6613">Using  DefaultContext Constructor  by passing a ConnectionContext to it. The ConnectionContext is created through  the JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
MyContext myctx1= new MyContext (conn);
DefaultContext  ctx = new DefaultContext(myctx1);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-D22FF91A-5A8E-4DF0-B51A-208A071785D6">Using Oracle.connect( ) method by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
MyContext myctx1= new MyContext (conn);
Oracle.connect(myctx1);
#sql {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
    }
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-E359B839-82E7-4149-AA67-7674A32A7BD8">Using Oracle. getConnection( ) method by passing a ConnectionContext to it. The ConnectionContext is created through the JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
MyContext myctx1= new MyContext (conn);
DefaultContext  ctx = Oracle.getConnection(myctx1);
#sql [ctx]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [ctx] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-ADD052F5-4E6D-49B1-BEF1-D2B94E181F38">The setDefaultContext( ) method of the DefaultContext class can also be used to set a context which was created through the JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">DefaultContext.setDefaultContext(ctx);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-F81953E4-84FF-449C-990F-4F693BFEDA6A">Using  the ConnectionContext constructor by passing a JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
			MyContext myctx1= new MyContext (conn);
#sql [myctx1]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [myctx1] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-C6A2124A-6071-4F4C-8506-25D241AFFEC0">Using  the ConnectionContext constructor by passing a ConnectionContext to it. The ConnectionContext is created through  the JDBC connection obtained from an XA Datasource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork (java.sql.Connection conn) throws SQLException{
String chr = "XA_CERT";
MyContext myctx= new MyContext (conn);
MyContext myctx1= new MyContext (myctx);
#sql [myctx1]  {insert into xa_test values (1,:chr)};
try{
    Iterator3 iter = null;
    #sql [myctx1] iter = {SELECT id,name FROM xa_test};
    while (iter.next( )){
    System.out.print(iter.id());
    System.out.print(" ");
    System.out.println(iter.name());
    }
}
catch (Exception e){
    System.out.println(e);
    e.printStackTrace();
}
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ922"></a><div class="props_rev_3"><a id="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1" name="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1"></a><h4 id="JSQLJ-GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1" class="sect4">Connecting to PDBs</h4>
                  <div>
                     <p>A pluggable database (PDB) enables an Oracle Database to contain a portable collection of schemas, schema objects, and nonschema objects that appears to an Oracle client as a separate database. A multitenant container database (CDB) is an Oracle Database that includes one or more PDBs. SQLJ applications can connect to a PDB using a service, whose <code class="codeph">PLUGGABLE DATABASE</code> property is set to the relevant PDB.
                     </p>
                     <div class="infoboxnotealso" id="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1__GUID-152F090B-86CA-48D0-A4B3-2018A72959AD">
                        <p class="notep1">See Also:</p>
                        <p><a href="../bradv/glossary.html#BRADV-GUID-D4239448-A344-41EF-9566-0B7716FEAE72" target="_blank"><span><cite>Oracle Database Backup and Recovery Userâ€™s Guide</cite></span></a> for more information about configuring the services to connect to various pluggable databases
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ534"></a><div class="props_rev_3"><a id="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603" name="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603"></a><h3 id="JSQLJ-GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603" class="sect3">Execution Contexts</h3>
               <div>
                  <p>An execution context is an instance of the <code class="codeph">sqlj.runtime.ExecutionContext</code> class and provides a context in which SQL operations are executed. An execution context instance is associated either implicitly or explicitly with each SQL operation in your SQLJ application.
                  </p>
                  <p>The <code class="codeph">ExecutionContext</code> class contains methods for the following features:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Execution control operations modify the semantics of subsequent SQL operations.</p>
                     </li>
                     <li>
                        <p>Execution status operations describe the results of the most recent SQL operation.</p>
                     </li>
                     <li>
                        <p>Execution cancellation operations terminate the SQL operation that is currently executing.</p>
                     </li>
                     <li>
                        <p>Update-batching operations enable and disable update batching, set the batch limit, and get update counts.</p>
                     </li>
                     <li>
                        <p>Savepoint operations set a savepoint, roll back to a savepoint, and release a savepoint.</p>
                     </li>
                     <li>
                        <p>Closure operations close the execution context instance to avoid resource leakage.</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603__GUID-F1679FA2-F9E5-4B7A-8B4A-CB82FCE4706B">
                     <p class="notep1">Note:</p>
                     <p>There is only one execution context class, unlike connection context classes where you declare additional classes as desired. Every execution context is an instance of the <code class="codeph">ExecutionContext</code> class. So while the term connection context usually refers to a class that you have declared, the term execution context always refers to an instance of the <code class="codeph">ExecutionContext</code> class. This document specifies connection context class, connection context instance, and execution context instance to avoid confusion.
                     </p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF">Relation of Execution Contexts to Connection Contexts</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-AC767320-7338-42AD-90B5-5359E764110A">Creating and Specifying Execution Context Instances</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90">Execution Context Synchronization</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA">Execution Context Methods</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30">Relation of Execution Contexts to Multithreading</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ535"></a><div class="props_rev_3"><a id="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF" name="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF"></a><h4 id="JSQLJ-GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF" class="sect4">Relation of Execution Contexts to Connection Contexts</h4>
                  <div>
                     <p>Each connection context instance implicitly has its own default execution context instance, which you can retrieve by using the <code class="codeph">getExecutionContext()</code> method of the connection context instance.
                     </p>
                     <p>A single execution context instance will be sufficient for a connection context instance except in the following circumstances:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You are using multiple threads with a single connection context instance.</p>
                           <p>When using multithreading, each thread must have its own execution context instance.</p>
                        </li>
                        <li>
                           <p>You want to use different SQL execution control operations on different SQLJ statements that use the same connection context instance.</p>
                        </li>
                        <li>
                           <p>You want to retain different sets of SQL status information from multiple SQL operations that use the same connection context instance.</p>
                           <p>As you execute successive SQL operations that use the same execution context instance, the status information from each operation overwrites the status information from the previous operation.</p>
                        </li>
                     </ul>
                     <p>Although execution context instances might appear to be associated with connection context instances (given that each connection context instance has a default execution context instance, and you can specify a connection context instance and an execution context instance together for a particular SQLJ statement), they actually operate independently. You can use different execution context instances in statements that use the same connection context instance, and vice versa. </p>
                     <p>For example, it is useful to use multiple execution context instances with a single connection context instance if you use multithreading, with a separate execution context instance for each thread. And you can use multiple connection context instances with a single explicit execution context instance if your program is single-threaded and you want the same set of SQL control parameters to apply to all the connection context instances.</p>
                     <div class="infoboxnotealso" id="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF__GUID-779E4D2C-B45F-4DF6-8AD2-0DB0C6C6A331">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-language-features.html#GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA">Execution Context Methods</a>"</span></p>
                     </div>
                     <p>To use different execution context instances with a single connection context instance, you must create additional instances of the <code class="codeph">ExecutionContext</code> class and specify them appropriately with your SQLJ statements.
                     </p>
                  </div>
               </div><a id="JSQLJ536"></a><div class="props_rev_3"><a id="GUID-AC767320-7338-42AD-90B5-5359E764110A" name="GUID-AC767320-7338-42AD-90B5-5359E764110A"></a><h4 id="JSQLJ-GUID-AC767320-7338-42AD-90B5-5359E764110A" class="sect4">Creating and Specifying Execution Context Instances</h4>
                  <div>
                     <div class="section">
                        <p>To use an execution context instance other than the default with a given connection context instance, you must construct another execution context instance. There are no input parameters for the <code class="codeph">ExectionContext</code> constructor. For example:
                        </p><pre class="oac_no_warn" dir="ltr">ExecutionContext myExecCtx = new ExecutionContext();
</pre><p>You can then specify this execution context instance for use with any particular SQLJ statement, much as you would specify a connection context instance. The general syntax is as follows:</p><pre class="oac_no_warn" dir="ltr">#sql [&lt;<span class="italic">conn_context</span>&gt;&lt;, &gt;&lt;<span class="italic">exec_context</span>&gt;] { <span class="italic">SQL operation</span> };
</pre><p>For example, if you also declare and instantiate a connection context class, <code class="codeph">MyConnCtxClass</code>, and create an instance, <code class="codeph">myConnCtx</code>, then you can use the following statement:
                        </p><pre class="oac_no_warn" dir="ltr">#sql [myConnCtx, myExecCtx] { DELETE FROM employees WHERE salary &gt; 30000 };
</pre><p>You can subsequently use different execution context instances with <code class="codeph">myConnCtx</code> or different connection context instances with <code class="codeph">myExecCtx</code>.
                        </p>
                        <p>You can optionally specify an execution context instance while using the default connection context instance, as follows:</p><pre class="oac_no_warn" dir="ltr">#sql [myExecCtx] { DELETE FROM employees WHERE salary &gt; 30000 };
</pre><div class="infoboxnote" id="GUID-AC767320-7338-42AD-90B5-5359E764110A__GUID-FA8C0995-AE92-4AA4-B6A1-20BF546A0D1B">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If you specify a connection context instance without an execution context instance, then the default execution context instance of that connection context instance is used.</p>
                              </li>
                              <li>
                                 <p>If you specify an execution context instance without a connection context instance, then the execution context instance is used with the default connection context instance of your application.</p>
                              </li>
                              <li>
                                 <p>If you specify no connection context instance and no execution context instance, then SQLJ uses the default connection and its default execution context instance.</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ537"></a><div class="props_rev_3"><a id="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90" name="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90"></a><h4 id="JSQLJ-GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90" class="sect4">Execution Context Synchronization</h4>
                  <div>
                     <p><code class="codeph">ExecutionContext</code> methods are all <code class="codeph">synchronized</code> methods. Therefore, for ISO standard code generation, anytime a statement tries to use an execution context instance already in use, the second statement will be blocked until the first statement completes.
                     </p>
                     <p>In a client application, this typically involves multithreading situations. A thread that tries to use an execution context instance currently in use by another thread will be blocked. To avoid such blockage, you must specify a separate execution context instance for each thread that you use.</p>
                     <div class="infoboxnotealso" id="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90__GUID-35B675A1-C35F-4028-9B81-17457C18AB04">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-language-features.html#GUID-C7787089-2507-43D1-91A3-FEC222903639">Multithreading in SQLJ</a>"</span></p>
                     </div>
                     <p>The preceding discussion does not apply for default Oracle-specific code generation. For performance reasons, SQLJ performs no additional synchronization against <code class="codeph">ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code class="codeph">NullPointer</code> exceptions.
                     </p>
                     <p>Another exception to the discussion is for recursion, which is encountered only in the server. Multiple SQLJ statements in the same thread are allowed to simultaneously use the same execution context instance if this situation results from recursive calls. An example of this is where a SQLJ stored procedure or function has a call to another SQLJ stored procedure or function. If both use the default execution context instance, as is typical, then the SQLJ statements in the second procedure will use this execution context while the SQLJ call statement from the first procedure is also still using it. This is allowed.</p>
                  </div>
               </div><a id="JSQLJ538"></a><div class="props_rev_3"><a id="GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA" name="GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA"></a><h4 id="JSQLJ-GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA" class="sect4">Execution Context Methods</h4>
                  <div>
                     <p>The following sections list public methods of the <code class="codeph">ExecutionContext</code> class and provide an example:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630">Status Methods</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E">Control Methods</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2">Cancellation Method</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1">Update Batching Methods</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123">Savepoint Methods</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF">Close Method</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-AD6833B1-11DB-4B42-95A4-D06390430364">Example: Using ExecutionContext Methods</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ539"></a><div class="props_rev_3"><a id="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630" name="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630"></a><h5 id="JSQLJ-GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630" class="sect5">Status Methods</h5>
                     <div>
                        <p>Use the following methods of an execution context instance to obtain status information about the most recent SQL operation that completed using that instance:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">SQLWarning getWarnings()</code>: Returns a <code class="codeph">java.sql.SQLWarning</code> object containing the first warning reported by the most recent SQL operation that completed using this execution context instance. Warnings are returned in a chain. Use the <code class="codeph">getWarnings()</code> method of the execution context instance to get the first warning, then use the <code class="codeph">getNextWarning()</code> method of each <code class="codeph">SQLWarning</code> object to get the next warning. The chain contains all warnings generated during the execution of the SQL operation.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getUpdateCount()</code>: Except when update batching is enabled, this returns an <code class="codeph">int</code> value specifying the number of rows updated by the last SQL operation that completed using this execution context instance. Zero (<code class="codeph">0</code>) is returned if the last SQL operation was not a data manipulation language (DML) statement. The <code class="codeph">QUERY_COUNT</code> constant is returned, if the last SQL operation produced an iterator or result set. The <code class="codeph">EXCEPTION_COUNT</code> constant is returned, if the last SQL operation terminated before completing execution or if no operation has yet been attempted using this execution context instance.
                              </p>
                              <p>For batch-enabled applications, the value returned by <code class="codeph">getUpdateCount()</code> would be one of several batch-related constant values: <code class="codeph">NEW_BATCH_COUNT</code>, <code class="codeph">ADD_BATCH_COUNT</code>, or <code class="codeph">EXEC_BATCH_COUNT</code>.
                              </p>
                              <div class="infoboxnotealso" id="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630__GUID-EAAEA405-1D75-4153-963B-24BF56E05FF0">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006039">Execution Context Update Counts</a>"</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ540"></a><div class="props_rev_3"><a id="GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E" name="GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E"></a><h5 id="JSQLJ-GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E" class="sect5">Control Methods</h5>
                     <div>
                        <p>Use the following methods of an execution context instance to control the operation of future SQL operations executed using that instance (operations that have not yet started):</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">int getMaxFieldSize()</code>: Returns an <code class="codeph">int</code> value specifying the maximum amount of data (in bytes) that would be returned from a SQL operation subsequently, using this execution context instance. This applies only to columns of the <code class="codeph">BINARY</code>, <code class="codeph">VARBINARY</code>, <code class="codeph">LONGVARBINARY</code>, <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code>, or <code class="codeph">LONGVARCHAR</code> type.
                              </p>
                              <p>By default this parameter is set to <code class="codeph">0</code>, meaning there is no size limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setMaxFieldSize(int)</code>: Takes an <code class="codeph">int</code> value as input to modify the maximum field-size.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getMaxRows()</code>: Returns an <code class="codeph">int</code> value specifying the maximum number of rows that can be contained by any SQLJ iterator or JDBC result set created using this execution context instance. If the limit is exceeded, then the excess rows are silently dropped without any error report or warning.
                              </p>
                              <p>By default, this parameter is set to <code class="codeph">0</code>, meaning there is no row limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setMaxRows(int)</code>: Takes an <code class="codeph">int</code> value as input to modify the maximum row value.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getQueryTimeout()</code>: Returns an <code class="codeph">int</code> value specifying the timeout interval, in seconds, for any SQL operation that uses this execution context instance. If a SQL operation exceeds this limit, then a SQL exception is thrown.
                              </p>
                              <p>By default, this parameter is set to <code class="codeph">0</code>, meaning there is no query timeout limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setQueryTimeout(int)</code>: Takes an <code class="codeph">int</code> value as input to modify the query timeout limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchSize()</code>: Retrieves the number of rows that is the current fetch size for iterator objects generated from this <code class="codeph">ExecutionContext</code> object. If this <code class="codeph">ExecutionContext</code> object has not set a fetch size by calling <code class="codeph">setFetchSize()</code>, then the value returned is <code class="codeph">0</code>. If this <code class="codeph">ExecutionContext</code> object has set a non-negative fetch size by calling the method <code class="codeph">setFetchSize()</code>, then the return value is the fetch size specified on <code class="codeph">setFetchSize()</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setFetchSize(int)</code>: Gives the SQLJ run time a hint as to the number of rows that should be fetched when more rows are needed. The number of rows specified affects only iterator objects created using this <code class="codeph">ExecutionContext</code> object. Specifying zero means that an implementation-dependent default value will be used for the fetch size.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchDirection()</code>: Retrieves the default direction for fetching data, for scrollable iterator objects that are generated from this <code class="codeph">ExecutionContext</code> object. If this <code class="codeph">ExecutionContext</code> object has not set a fetch direction by calling the method <code class="codeph">setFetchDirection()</code>, then the return value is <code class="codeph">FETCH_FORWARD</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setFetchDirection(int)</code>: Gives the SQLJ run time a hint as to the direction in which rows of scrollable iterator objects are processed. The hint applies only to scrollable iterator objects that are created using this <code class="codeph">ExecutionContext</code> object. The default value is:
                              </p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ResultSetIterator.FETCH_FORWARD.
</pre><p>This method throws a <code class="codeph">SQLException</code> if the given direction is not one of <code class="codeph">FETCH_FORWARD</code>, <code class="codeph">FETCH_REVERSE</code>, or <code class="codeph">FETCH_UNKNOWN</code> (<code class="codeph">int</code> constants).
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ541"></a><div class="props_rev_3"><a id="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2" name="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2"></a><h5 id="JSQLJ-GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2" class="sect5">Cancellation Method</h5>
                     <div>
                        <p>Use the following method to cancel SQL operations in a multithreading environment or to cancel a pending statement batch if update batching is enabled:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">cancel()</code>: In a multithreading environment, use this method in one thread to cancel a SQL operation currently executing in another thread. It cancels the most recent operation that has started but not completed, using this execution context instance. This method has no effect if no statement is currently being executed using this execution context instance.
                              </p>
                              <p>In a batch-enabled environment, use this to cancel a pending statement batch. The batch is emptied, and none of the statements in the batch are executed. After you cancel a batch, the next batchable statement encountered will be added to a new batch.</p>
                              <div class="infoboxnotealso" id="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2__GUID-7E5D4522-B34A-419B-8D31-C75324DFC8F9">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006005">Canceling a Batch</a>"</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ542"></a><div class="props_rev_3"><a id="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1" name="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1"></a><h5 id="JSQLJ-GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1" class="sect5">Update Batching Methods</h5>
                     <div>
                        <p>Use the following methods to control update batching if you want your application to use that performance enhancement feature:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">int[] executeBatch()</code>: Executes the pending statement batch, returning an array of <code class="codeph">int</code> update counts.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getBatchLimit()</code>: Returns an <code class="codeph">int</code> value indicating the current batch limit. If there is a batch limit, then a pending batch is implicitly executed once it contains that number of statements.
                              </p>
                              <p>By default, the batch limit is set to the <code class="codeph">ExecutionContext</code> static constant value <code class="codeph">UNLIMITED_BATCH</code>, meaning there is no batch limit.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int[] getBatchUpdateCounts()</code>: Returns an array of <code class="codeph">int</code> update counts for the last batch executed. This method is useful in situations where the batch was executed implicitly.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isBatching()</code>: Returns a boolean value indicating whether update batching is enabled.
                              </p>
                              <p>This does not indicate whether there is currently a pending batch, but you can use the <code class="codeph">getUpdateCount()</code> method to see whether a batch has been newly created, added to, or executed.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setBatching(boolean)</code>: Takes a boolean value to enable update batching.
                              </p>
                              <p>Update batching is disabled by default.</p>
                           </li>
                           <li>
                              <p><code class="codeph">setBatchLimit(int)</code>: Takes a positive, nonzero <code class="codeph">int</code> value as input to set the current batch limit. Two special values you can assign are <code class="codeph">UNLIMITED_BATCH</code>, which means there is no limit, and <code class="codeph">AUTO_BATCH</code>, which lets the SQLJ run time to dynamically determine a batch limit.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1__GUID-84077021-7B2D-4BC9-AF56-6D4B724C677B">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/performance-extensions.html#JJDBC-GUID-8B920135-D97D-4F33-8FF5-5774E802C520" target="_blank"><span><cite>Oracle Database JDBC Developerâ€™s Guide</cite></span></a></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ543"></a><div class="props_rev_3"><a id="GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123" name="GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123"></a><h5 id="JSQLJ-GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123" class="sect5">Savepoint Methods</h5>
                     <div>
                        <p>The Oracle SQLJ implementation supports JDBC 3.0 savepoints. Savepoints are stored in the <code class="codeph">ExecutionContext</code> instance, and the following public methods exist to support the SQLJ savepoint statements:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">Object oracleSetSavepoint(ConnectionContextImpl, String)</code></p>
                              <p>Register a savepoint and return the savepoint as an <code class="codeph">Object</code> instance. This method takes the connection context as an instance of the <code class="codeph">sqlj.runtime.ref.ConnectionContextImpl</code> class and a string that specifies the savepoint name.
                              </p>
                              <p>The Oracle SQLJ implementation instantiates a savepoint as an instance of the <code class="codeph">oracle.jdbc.OracleSavepoint</code> class, which extends the <code class="codeph">java.sql.Savepoint</code> interface.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void oracleRollbackToSavepoint                      (ConnectionContextImpl, Object)</code></p>
                              <p>Roll back changes to the specified savepoint. This method takes the connection context as an instance of <code class="codeph">ConnectionContextImpl</code> and the savepoint as an <code class="codeph">Object</code> instance.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void oracleReleaseSavepoint(ConnectionContextImpl, Object)</code></p>
                              <p>Release the specified savepoint. This method takes the connection context as an instance of <code class="codeph">ConnectionContextImpl</code> and the savepoint as an <code class="codeph">Object</code> instance.
                              </p>
                           </li>
                        </ul>
                        <p>You will generally use SQLJ savepoint statements instead of using these methods directly.</p>
                     </div>
                  </div><a id="JSQLJ544"></a><div class="props_rev_3"><a id="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF" name="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF"></a><h5 id="JSQLJ-GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF" class="sect5">Close Method</h5>
                     <div>
                        <p>The Oracle SQLJ implementation provides extended functionality with a <code class="codeph">close()</code> method for the <code class="codeph">ExecutionContext</code> class:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">close()</code>: To avoid resource leakage, use this method if the following circumstances are all true:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>You are using the Oracle-specific code generation.</p>
                                 </li>
                                 <li>
                                    <p>You explicitly created and used the <code class="codeph">ExecutionContext</code> instance, instead of using the default instance available through the connection context instance.
                                    </p>
                                 </li>
                                 <li>
                                    <p>You are <span class="italic">not</span> issuing SQLJ rollback or commit statements explicitly using the <code class="codeph">ExecutionContext</code> instance:
                                    </p><pre class="oac_no_warn" dir="ltr">#sql [ec] { COMMIT };
#sql [ec] { ROLLBACK };
</pre></li>
                                 <li>
                                    <p>You are <span class="italic">not</span> calling <code class="codeph">executeBatch()</code> on the <code class="codeph">ExecutionContext</code> instance.
                                    </p>
                                 </li>
                              </ul>
                              <p>Under this set of circumstances, a batchable statement might remain open on the <code class="codeph">ExecutionContext</code> instance and over time you may run out of database cursors. To avoid this, use the <code class="codeph">close()</code> method as in the following example:
                              </p><pre class="oac_no_warn" dir="ltr">Execution Context ec = new ExecutionContext();
...
try {
   ...
   #sql [ec] { <span class="italic">SQL operation</span> };
   ...
} finally { ec.close(); }
</pre></li>
                        </ul>
                        <div class="infoboxnote" id="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF__GUID-C5ED67C3-64F8-486F-B69A-9E9AE4802A45">
                           <p class="notep1">Note:</p>
                           <p>When an execution context instance is associated with a connection context instance, instead of being declared explicitly, then closing the connection context instance, with or without closing the underlying JDBC connection, will automatically close any statement remaining on the execution context instance.</p>
                        </div>
                     </div>
                  </div><a id="JSQLJ545"></a><div class="props_rev_3"><a id="GUID-AD6833B1-11DB-4B42-95A4-D06390430364" name="GUID-AD6833B1-11DB-4B42-95A4-D06390430364"></a><h5 id="JSQLJ-GUID-AD6833B1-11DB-4B42-95A4-D06390430364" class="sect5">Example: Using ExecutionContext Methods</h5>
                     <div>
                        <p>The following code demonstrates the use of some <code class="codeph">ExecutionContext</code> methods:
                        </p><pre class="oac_no_warn" dir="ltr">ExecutionContext execCtx =
   DefaultContext.getDefaultContext().getExecutionContext();

// Wait only 3 seconds for operations to complete
execCtx.setQueryTimeout(3);

// delete using execution context of default connection context
#sql { DELETE FROM employees WHERE salary &gt; 10000 };

System.out.println
     ("removed " + execCtx.getUpdateCount() + " employees");
</pre></div>
                  </div>
               </div><a id="JSQLJ546"></a><div class="props_rev_3"><a id="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30" name="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30"></a><h4 id="JSQLJ-GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30" class="sect4">Relation of Execution Contexts to Multithreading</h4>
                  <div>
                     <p>Do not use multiple threads with a single execution context. If you do, and two SQLJ statements try to use the same execution context simultaneously, then the second statement will be blocked until the first statement completes. Furthermore, status information from the first operation will likely be overwritten before it can be retrieved.</p>
                     <p>Therefore, if you are using multiple threads with a single connection context instance, then you should take the following steps:</p>
                     <ol>
                        <li>
                           <p>Instantiate a unique execution context instance for use with each thread.</p>
                        </li>
                        <li>
                           <p>Specify execution contexts with your <code class="codeph">#sql</code> statements so that each thread uses its own execution context.
                           </p>
                        </li>
                     </ol>
                     <p>If you are using a different connection context instance with each thread, then no instantiation and specification of execution context instances is necessary, because each connection context instance implicitly has its own default execution context instance.</p>
                     <div class="infoboxnote" id="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30__GUID-B11DFDF4-A508-498F-A304-988B725AF5C9">
                        <p class="notep1">Note:</p>
                        <p>For performance reasons, SQLJ performs no additional synchronization against <code class="codeph">ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code class="codeph">NullPointer</code> exceptions.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ548"></a><a id="JSQLJ547"></a><div class="props_rev_3"><a id="GUID-C7787089-2507-43D1-91A3-FEC222903639" name="GUID-C7787089-2507-43D1-91A3-FEC222903639"></a><h3 id="JSQLJ-GUID-C7787089-2507-43D1-91A3-FEC222903639" class="sect3">Multithreading in SQLJ</h3>
               <div>
                  <p>This section discusses SQLJ support and requirements for multithreading and the relation between multithreading and execution context instances.</p>
                  <p>You can use SQLJ in writing multithreaded applications. However, any use of multithreading in your SQLJ application is subject to the limitations of your JDBC driver or proprietary database access vehicle. This includes any synchronization limitations.</p>
                  <p>You are required to use a different execution context instance for each thread. You can accomplish this in one of two ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Specify connection context instances for your SQLJ statements such that a different connection context instance is used for each thread. Each connection context instance automatically has its own default execution context instance.</p>
                     </li>
                     <li>
                        <p>If you are using the same connection context instance with multiple threads, then declare additional execution context instances and specify execution context instances for your SQLJ statements such that a different execution context instance is used for each thread.</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-0204D45A-35C7-4BF7-944E-D20B1C201E92">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="basic-language-features.html#GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60">Specifying Connection Context Instances and Execution Context Instances</a>"</span></p>
                  </div>
                  <p>If you are using one of Oracle JDBC drivers, then multiple threads can use the same connection context instance, if desired, as long as different execution context instances are specified and there are no synchronization requirements directly visible to you. However, note that data access is sequential. Only one thread is accessing data at any given time. Synchronization refers to the control flow of the various stages of the SQL operations executing through your threads. For example, each statement can bind input parameters, then execute, and then bind output parameters. With some JDBC drivers, special care must be taken not to intermingle these stages.</p>
                  <p>For ISO standard code generation, if a thread attempts to execute a SQL operation that uses an execution context that is in use by another operation, then the thread is blocked until the current operation completes. If an execution context were shared between threads, then the results of a SQL operation performed by one thread would be visible in the other thread. If both threads were executing SQL operations, then a race condition might occur. The results of an execution in one thread might be overwritten by the results of an execution in the other thread before the first thread had processed the original results. This is why multiple threads are not allowed to share an execution context instance.</p>
                  <div class="infoboxnote" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-B1836AE6-7A38-4939-9226-C69610E9AD77">
                     <p class="notep1">Note:</p>
                     <p>The preceding paragraph does not apply if you use default Oracle-specific code generation. For performance reasons, SQLJ performs no additional synchronization against <code class="codeph">ExecutionContext</code> instances for Oracle-specific generated code. Therefore, you are responsible for ensuring that the same execution context instance will not be used by more than one thread. If multiple threads use the same execution context, then your application, rather than blocking, will experience errors such as incorrect results or <code class="codeph">NullPointer</code> exceptions.
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-FBC8E8A9-75DA-4324-A811-CF1DBFC4DEF8">Multithreading: MultiThreadDemo.sqlj</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>The following is an example of a SQLJ application using multithreading. A <code class="codeph">ROLLBACK</code> operation is executed before closing the connection, so the data is not permanently altered.
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.SQLException;
import java.util.Random;
import sqlj.runtime.ExecutionContext;
import oracle.sqlj.runtime.Oracle;
/**
  Each instance of MultiThreadDemo is a thread that gives all employees
  a raise of some ammount when run.  The main program creates two such 
  instances and computes the net raise after both threads have completed.
  **/
class MultiThreadDemo extends Thread
{
  double raise;
  static Random randomizer = new Random(); 
 
  public static void main (String args[]) 
  {
    try { 
      // set the default connection to the URL, user, and password
      // specified in your connect.properties file
      Oracle.connect(MultiThreadDemo.class, "connect.properties");
      double avgStart = calcAvgSal();
      MultiThreadDemo t1 = new MultiThreadDemo(250.50);
      MultiThreadDemo t2 = new MultiThreadDemo(150.50);
      t1.start();
      t2.start();
      t1.join();
      t2.join();
      double avgEnd = calcAvgSal();
      System.out.println("average salary change: " + (avgEnd - avgStart));
    } catch (Exception e) { 
      System.err.println("Error running the example: " + e);
    }
    try { #sql { ROLLBACK }; Oracle.close(); } catch (SQLException e) { }
  } 
  static double calcAvgSal() throws SQLException
  {
    double avg;
    #sql { SELECT AVG(salary) INTO :avg FROM employees };
    return avg;
  }
  MultiThreadDemo(double raise)
  {
    this.raise = raise;
  }
  public void run()
  {
    // Since all threads will be using the same default connection
    // context, each run uses an explicit execution context instance to
    // avoid conflict during execution
    try {
      delay();
      ExecutionContext execCtx = new ExecutionContext();
      #sql [execCtx] { UPDATE EMPLOYEES SET salary = salary + :raise };
      int updateCount = execCtx.getUpdateCount();
      System.out.println("Gave raise of " + raise + " to " + 
                          updateCount + " employees");
    } catch (SQLException e) {
      System.err.println("error updating employees: " + e);
    }
  }
  // delay is used to introduce some randomness into the execution order
  private void delay()
  {
    try {
      sleep((long)Math.abs(randomizer.nextInt()/10000000));
    } catch (InterruptedException e) {}
  }
}
</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSQLJ549"></a><div class="sect2"><a id="GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF" name="GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF"></a><h3 id="JSQLJ-GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF" class="sect3">Iterator Class Implementation and Advanced Functionality</h3>
               <div>
                  <p>This section discusses how iterator classes are implemented and what additional functionality is available beyond the essential methods. The following topics are covered:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997">Implementation and Functionality of Iterator Classes</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-6504E582-745D-4419-AE90-97CB95181C4C">Using the IMPLEMENTS Clause in Iterator Declarations</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1">Support for Extending Iterator Classes</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-8A659A48-2847-4CC2-97B1-39116D628C9F">Result Set Iterators</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ550"></a><div class="props_rev_3"><a id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997" name="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997"></a><h4 id="JSQLJ-GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997" class="sect4">Implementation and Functionality of Iterator Classes</h4>
                  <div>
                     <p>Any named iterator class you declare will be generated by the SQLJ translator to implement the <code class="codeph">sqlj.runtime.NamedIterator</code> interface. Classes implementing the <code class="codeph">NamedIterator</code> interface have functionality that maps iterator columns to database columns by name, not by position.
                     </p>
                     <p>Any positional iterator class you declare will be generated by the SQLJ translator to implement the <code class="codeph">sqlj.runtime.PositionedIterator</code> interface. Classes implementing the <code class="codeph">PositionedIterator</code> interface have functionality that maps iterator columns to database columns by position, not by name.
                     </p>
                     <p>Both the <code class="codeph">NamedIterator</code> interface and the <code class="codeph">PositionedIterator</code> interface, and therefore all generated SQLJ iterator classes as well, implement or extend the <code class="codeph">sqlj.runtime.ResultSetIterator</code> interface.
                     </p>
                     <p>The <code class="codeph">ResultSetIterator</code> interface specifies the following methods for all SQLJ iterators:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">close()</code>: Closes the iterator.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ResultSet getResultSet()</code>: Extracts the underlying JDBC result set from the iterator.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">boolean isClosed()</code>: Determines if the iterator has been closed.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">boolean next()</code>: Moves to the next row of the iterator, returning <code class="codeph">true</code> if there is a valid next row to go to.
                           </p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">PositionedIterator</code> interface adds the following method specification for positional iterators:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">boolean endFetch()</code>: Determines if you have reached the last row of a positional iterator.
                           </p>
                        </li>
                     </ul>
                     <p>Use the <code class="codeph">next()</code> method to advance through the rows of a named iterator and accessor methods to retrieve the data. The SQLJ generation of a named iterator class defines an accessor method for each iterator column, where each method name is identical to the corresponding column name. For example, if you declare a <code class="codeph">name</code> column, then a <code class="codeph">name()</code> method will be generated.
                     </p>
                     <p>Use a <code class="codeph">FETCH INTO</code> statement together with the <code class="codeph">endFetch()</code> method to advance through the rows of a positional iterator and retrieve the data. A <code class="codeph">FETCH INTO</code> statement implicitly calls the <code class="codeph">next()</code> method. Do not explicitly use the <code class="codeph">next()</code> method in a positional iterator unless you are using the special <code class="codeph">FETCH CURRENT</code> syntax. The <code class="codeph">FETCH INTO</code> statement also implicitly calls accessor methods that are named according to iterator column numbers. The SQLJ generation of a positional iterator class defines an accessor method for each iterator column, where each method name corresponds to the column position.
                     </p>
                     <div class="infoboxnotealso" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-3A08E78D-78BA-427F-945C-BBF3B6629557">
                        <p class="notep1">See Also:</p>
                        <p>\</p>
                     </div>
                     <p>Use the <code class="codeph">close()</code> method to close any iterator once you are done with it. The <code class="codeph">getResultSet()</code> method is central to SQLJ-JDBC interoperability.
                     </p>
                     <div class="infoboxnotealso" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-DD33DB29-C265-44A8-ADE2-890A7DC83230">
                        <p class="notep1">See Also:</p>
                        <p><a href="../jjdbc/resultset.html#JJDBC-GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" target="_blank"><span><cite>Oracle Database JDBC Developerâ€™s Guide</cite></span></a></p>
                     </div>
                     <div class="infoboxnote" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-601C228E-D514-4C36-A064-080104C15AF7">
                        <p class="notep1">Note:</p>
                        <p>Alternatively, you can use a <code class="codeph">ResultSetIterator</code> instance or a <code class="codeph">ScrollableResultSetIterator</code> instance directly as a weakly typed iterator. (<code class="codeph">ScrollableResultSetIterator</code> extends <code class="codeph">ResultSetIterator</code>.) This is convenient if you are interested only in converting it to a JDBC result set and you do not need named or positional iterator functionality. You can also access it through SQLJ <code class="codeph">FETCH CURRENT</code> syntax.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ551"></a><div class="props_rev_3"><a id="GUID-6504E582-745D-4419-AE90-97CB95181C4C" name="GUID-6504E582-745D-4419-AE90-97CB95181C4C"></a><h4 id="JSQLJ-GUID-6504E582-745D-4419-AE90-97CB95181C4C" class="sect4">Using the IMPLEMENTS Clause in Iterator Declarations</h4>
                  <div>
                     <div class="section">
                        <p>There may be situations where it will be useful to implement an interface in your iterator declaration. For example, you may have an iterator class where you want to restrict access to one or more columns. A named iterator class generated by SQLJ has an accessor method for each column in the iterator. If you want to restrict access to certain columns, you can create an interface with only a subset of the accessor methods, then expose instances of the interface type to the user instead of exposing instances of the iterator class type.</p>
                        <p>For example, assume you are creating a named iterator of employee data, with columns <code class="codeph">ENAME</code> (employee name), <code class="codeph">EMPNO</code> (employee number), and <code class="codeph">SAL</code> (salary). Accomplish this as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter (String ename, int empno, float sal);
</pre><p>This generates a class <code class="codeph">EmpIter</code> with <code class="codeph">ename()</code>, <code class="codeph">empno()</code>, and <code class="codeph">sal()</code> accessor methods.
                        </p>
                        <p>Assume, though, that you want to prevent access to the <code class="codeph">SAL</code> column. You can create an <code class="codeph">EmpIterIntfc</code> interface that has <code class="codeph">ename()</code> and <code class="codeph">empno()</code> methods, but no <code class="codeph">sal()</code> method. Then you can use the following iterator declaration instead of the preceding declaration (presuming <code class="codeph">EmpIterIntfc</code> is in the <code class="codeph">mypackage</code> package):
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter implements mypackage.EmpIterIntfc 
     (String emame, int empno, float sal);
</pre><p>Then if you code your application so that users can access data only through <code class="codeph">EmpIterIntfc</code> instances, then they will not have access to the <code class="codeph">SAL</code> column.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ552"></a><div class="props_rev_3"><a id="GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1" name="GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1"></a><h4 id="JSQLJ-GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1" class="sect4">Support for Extending Iterator Classes</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ supports the ability to extend iterator classes. This feature can be very useful in allowing you to add functionality to your queries and query results.</p>
                        <p>The one key requirement of an iterator subclass is that you must supply a public constructor that takes an instance of <code class="codeph">sqlj.runtime.RTResultSet</code> as input. The SQLJ run time will call this constructor in assigning query results to an instance of your subclass. Beyond that, you provide functionality as you choose.
                        </p>
                        <p>You can continue to use functionality of the original iterator class (the superclass of your subclass). For example, you can advance through query results by calling the <code class="codeph">super.next()</code> method.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ553"></a><div class="props_rev_3"><a id="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F" name="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F"></a><h4 id="JSQLJ-GUID-8A659A48-2847-4CC2-97B1-39116D628C9F" class="sect4">Result Set Iterators</h4>
                  <div>
                     <p>You may have situations where you do not require the strongly typed functionality of a SQLJ iterator.</p>
                     <p>For such circumstances, you can directly use instances of the <code class="codeph">sqlj.runtime.ResultSetIterator</code> type to receive query data, so that you are not required to declare a named or positional iterator class. Alternatively, you can use the <code class="codeph">sqlj.runtime.ScrollableResultSetIterator</code> type, which extends <code class="codeph">ResultSetIterator</code>. This enables you to use SQLJ scrollable iterator functionality. In using a result set iterator instead of a strongly typed iterator, you are trading the strong type-checking of the SQLJ <code class="codeph">SELECT</code> operation for the convenience of not having to declare an iterator class.
                     </p>
                     <p>The <code class="codeph">ResultSetIterator</code> interface underlies all named and positional iterator classes and specifies the <code class="codeph">getResultSet()</code> and <code class="codeph">close()</code> methods. If you want to use SQLJ to process a result set iterator instance, then use a <code class="codeph">ScrollableResultSetIterator</code> instance and the <code class="codeph">FETCH CURRENT</code> syntax.
                     </p>
                     <p>If you want to use JDBC to process a result set iterator instance, you can use its <code class="codeph">getResultSet()</code> method and then process the underlying result set that you retrieve. If you process a result set iterator through its underlying result set, you should close the result set iterator, not the result set, when you are finished. Closing the result set iterator will also close the result set, but closing the result set will not close the result set iterator.
                     </p>
                     <div class="infoboxnote" id="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F__GUID-21A3B7E6-E59E-49DC-B0EF-65023D4CE482">
                        <p class="notep1">Note:</p>
                        <p>The Oracle SQLJ implementation supports result set iterators for use as host expressions and to represent cursors in <code class="codeph">FETCH</code> statements. This functionality was not supported prior to Oracle9<span class="italic">i</span> Database.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ555"></a><a id="JSQLJ556"></a><a id="JSQLJ557"></a><a id="JSQLJ558"></a><a id="JSQLJ559"></a><a id="JSQLJ560"></a><a id="JSQLJ561"></a><a id="JSQLJ554"></a><div class="props_rev_3"><a id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18" name="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18"></a><h4 id="JSQLJ-GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18" class="sect4">Scrollable Iterators</h4>
                  <div>
                     <p>The ISO standard for SQLJ supports scrollable iterators, with functionality being patterned after the JDBC 2.0 specification for scrollable JDBC result sets. The Oracle SQLJ implementation supports this functionality.</p>
                     <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-5410F46A-3E0C-4996-B41F-796BDFA16C1C">
                        <p class="notep1">See Also:</p>
                        <p><a href="../jjdbc/resultset.html#JJDBC-GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                     </div>
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006761">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-AD609C89-825F-480A-9A28-4CD88F918EC4">Declaring Scrollable Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To characterize an iterator as scrollable, add the following clause to the iterator declaration:</p><pre class="oac_no_warn" dir="ltr">implements sqlj.runtime.Scrollable
</pre><p>This instructs the SQLJ translator to generate an iterator that implements the <code class="codeph">Scrollable</code> interface. Following is an example of a declaration of a named, scrollable iterator:
                        </p><pre class="oac_no_warn" dir="ltr">#sql public static MyScrIter implements sqlj.runtime.Scrollable
                             (String ename, int empno);
</pre><p>The code that the SQLJ translator generates for the <code class="codeph">MyScrIter</code> class will automatically support all the methods of the <code class="codeph">Scrollable</code> interface.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006775">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-06C2FB02-8C6F-44AF-A7D0-2ABB2A1429ED">Scrollable Iterator Sensitivity</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>You can declare scrollable iterators, like scrollable result sets, to have sensitivity to changes to the underlying data. By default, scrollable iterators in the Oracle SQLJ implementation have a <code class="codeph">sensitivity</code> setting of <code class="codeph">INSENSITIVE</code>, meaning they do not detect any such changes in the underlying data. However, you can use a <code class="codeph">with</code> clause to alter this setting. The following example expands an earlier example to specify sensitivity:
                        </p><pre class="oac_no_warn" dir="ltr">#sql public static MyScrIter implements sqlj.runtime.Scrollable
                             with (sensitivity=SENSITIVE) 
                             (String ename, int empno);
</pre><div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-0387B448-20D7-4643-B5C0-8E29960AD331">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">implements</code> clause must precede the <code class="codeph">with</code> clause.
                           </p>
                        </div>
                        <p>The SQLJ standard also allows a setting of <code class="codeph">ASENSITIVE</code>, which means accepting the default <code class="codeph">sensitivity</code> of the Database. But, in Oracle, if you set <code class="codeph">sensitivity</code> to <code class="codeph">ASENSITIVE</code>, then it results in the default setting <code class="codeph">INSENSITIVE</code> being used.
                        </p>
                        <p>Given the preceding declaration, <code class="codeph">MyScrIter</code> instances will be sensitive to data changes, subject to factors such as the fetch size window.
                        </p>
                        <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-822F6292-D459-4028-9597-F3957411AFA6">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/resultset.html#JJDBC-GUID-16116A5C-1A33-4F65-B9DD-1BDCE925343B" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for information about scrollable result sets
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006795">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-B32E1907-1580-4FC8-8C0D-1027440A2D09">The Scrollable Interface</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This section documents some key methods of the <code class="codeph">sqlj.runtime.Scrollable</code> interface.
                        </p>
                        <p>You can provide hints about the fetch direction to scrollable iterators. The following methods are defined on scrollable iterators as well as on execution contexts. Use an <code class="codeph">ExecutionContext</code> instance to provide the default direction to be used in creation of scrollable iterators.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">setFetchDirection(int)</code>: Gives the SQLJ run time a hint as to the direction in which rows are processed. The direction should be one of <code class="codeph">sqlj.runtime.ResultSetIterator.FETCH_FORWARD</code>, <code class="codeph">FETCH_REVERSE</code>, or <code class="codeph">FETCH_UNKNOWN</code>.
                              </p>
                              <p>If you do not specify a value for the direction on the <code class="codeph">ExecutionContext</code>, then <code class="codeph">FETCH_FORWARD</code> will be used as a default.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchDirection()</code>: Retrieves the current direction for fetching rows of data (one of the integer constants described in the previous point).
                              </p>
                           </li>
                        </ul>
                        <p>There are also a number of scrollable iterator methods that will return information about the current position of the iterator object in the underlying result set. All these methods will return <code class="codeph">false</code> whenever the result set underlying the iterator contains no rows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">boolean isBeforeFirst()</code>: Indicates whether the iterator object is before the first row in the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isFirst()</code>: Indicates whether the iterator object is on the first row of the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isLast()</code>: Indicates whether the iterator object is on the last row of the result set. Note that calling the <code class="codeph">isLast()</code> method may be expensive, because the JDBC driver may have to fetch ahead one row to determine whether the current row is the last row in the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isAfterLast()</code>: Indicates whether the iterator object is after the last row in the result set.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-56CDDC95-CBCD-4A7B-853E-BEA81DEC4DDD">
                           <p class="notep1">Note:</p>
                           <p>Additional methods for navigation, also defined in the <code class="codeph">Scrollable</code> interface, are available as well.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006816">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-52384EFC-4A97-4B52-A495-6B562DA00979">Scrollable Named Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Named iterators use navigation methods, defined in the <code class="codeph">Scrollable</code> interface, to move through the rows of a result set. As described earlier in this manual, nonscrollable iterators have only the following method for navigation:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">boolean next()</code>: Moves the iterator object to the next row in the result set.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-2B265A7D-0D2A-4C96-BB06-40CD192BAC89">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">Using Named Iterators</a>"</span></p>
                        </div>
                        <p>Additional navigation methods are available for scrollable named iterators. These methods function similarly to the <code class="codeph">next()</code> method. In that they try to position the iterator on an actual row of the result set. They return <code class="codeph">true</code> if the iterator ends up on a valid row and <code class="codeph">false</code> if it does not. Additionally, if you attempt to position the iterator object before the first row or after the last row in the result set, this leaves the iterator object in the "before first" or "after last" position, respectively. 
                        </p>
                        <p>The following methods are supported:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">boolean previous()</code>: Moves the iterator object to the previous row in the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean first()</code>: Moves the iterator object to the first row in the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean last()</code>: Moves the iterator object to the last row in the result set.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean absolute(int)</code>: Moves the iterator object to the given row number in the result set. The first row is row 1, the second is row 2, and so on. If the given row number is negative, then the iterator object moves to a row position relative to the end of the result set. For example, calling <code class="codeph">absolute(-1)</code> positions the iterator object on the last row, <code class="codeph">absolute(-2)</code> indicates the next-to-last row, and so on.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean relative(int)</code>: Moves the iterator object a relative number of rows, either positive or negative from the current position. Calling <code class="codeph">relative(0)</code> is valid, but does not change the iterator position.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void beforeFirst()</code>: Moves the iterator object to the front of the result set, before the first row. This has no effect if the result set contains no rows.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void afterLast()</code>: Moves the iterator object to the end of the result set, after the last row. This has no effect if the result set contains no rows.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-DE0ED949-46F2-4A00-9A23-9FB96C09F3EF">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">beforeFirst()</code> and <code class="codeph">afterLast()</code> methods return <code class="codeph">void</code>, because they never place the iterator object on an actual row of the result set.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-F790EA73-4BE5-4A91-B6DF-CF1CA7DC7290">Scrollable Positional Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>General <code class="codeph">FETCH</code> syntax for positional iterators was described earlier, in <span class="q">"<a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">Using Positional Iterators</a>"</span>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { FETCH :iter INTO :x, :y, :z };
</pre><p>This is actually an abbreviated version of the following syntax:</p><pre class="oac_no_warn" dir="ltr">#sql { FETCH NEXT FROM :iter INTO :x, :y, :z  };
</pre><p>This suggests the pattern for alternatively moving to the previous, first, or last row in the result set. Unfortunately, JDBC 2.0, after which the movement methods were modeled, uses <code class="codeph">previous()</code>. The <code class="codeph">FETCH</code> syntax, which is patterned after SQL, employs <code class="codeph">PRIOR</code>. In case you forget this inconsistency, the Oracle Database 12<span class="italic">c </span>Release 1 (12.1) SQLJ translator will also accept <code class="codeph">FETCH PREVIOUS</code>.
                        </p>
                        <p>The syntax are:</p><pre class="oac_no_warn" dir="ltr">#sql { FETCH PRIOR FROM :iter INTO :x, :y, :z  };
#sql { FETCH FIRST FROM :iter INTO :x, :y, :z  };
#sql { FETCH LAST FROM :iter INTO :x, :y, :z  };
</pre><p>There is also syntax to pass a numeric value for absolute or relative movements, to move to a particular (absolute) row, or to move forward or backward from the current position. The syntax are:</p><pre class="oac_no_warn" dir="ltr">#sql { FETCH ABSOLUTE :n FROM :iter INTO :x, :y, :z  };
#sql { FETCH RELATIVE :n FROM :iter INTO :x, :y, :z  };
</pre><div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-9D6D40D6-1CB2-48AE-A040-585FA3394A29">
                           <p class="notep1">Note:</p>
                           <p>In all of the preceding cases, the iterator <code class="codeph">endFetch()</code> method returns <code class="codeph">true</code> whenever the <code class="codeph">FETCH</code> fails to move to a valid row and retrieve values.
                           </p>
                        </div>
                        <p>Note that you <span class="italic">must</span> use a host expression to specify the movement. You cannot simply use a constant for the numeric value. Thus, instead of the following:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { FETCH RELATIVE 0 FROM :iter INTO :x, :y, :z };
</pre><p>You must write the following:</p><pre class="oac_no_warn" dir="ltr">#sql { FETCH RELATIVE :(0) FROM :iter INTO :x, :y, :z  };
</pre><p>Incidentally, this command leaves the position of the iterator unchanged. If the iterator is on a valid row, then the command just populates the variables.</p>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-212957F3-D936-4441-9F85-882AEC922151">
                           <p class="notep1">Note:</p>
                           <p>Alternatively, you can navigate through a scrollable positional iterator through a combination of the navigation methods and the <code class="codeph">FETCH CURRENT</code> syntax.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006889">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-F5C4C5CB-384E-4025-8D18-1B74AC09CBE3">FETCH CURRENT Syntax: from JDBC Result Sets to SQLJ Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Consider a situation where you have an existing JDBC program that you want to rewrite in SQLJ with as little modification as possible.</p>
                        <p>Your JDBC result set will use only movement methods, such as <code class="codeph">next()</code>, <code class="codeph">previous()</code>, <code class="codeph">absolute()</code>, and so on. You can immediately model this in SQLJ through a named iterator. However, this also implies that all columns of the SQL result set must have a proper name. In practice, many columns of the result set, if not all, will require introduction of alias names. This is unacceptable if the query text is to remain untouched.
                        </p>
                        <p>The alternative, to avoid change to the query source, is to define a positional iterator type for the result set. However, this approach forces changes to the control-flow logic of the program. Consider the following JDBC code sample:</p><pre class="oac_no_warn" dir="ltr">ResultSet rs = ... // execute ...query...;
while (rs.next()) {
   x := rs.get<span class="italic">Xxx</span>(1); y:=rs.get<span class="italic">Xxx</span>(2);
   ...<span class="italic">process</span>...
}
</pre><p>This translates along the following lines to SQLJ:</p><pre class="oac_no_warn" dir="ltr">MyIter iter;
#sql iter = { ...query... };
while(true) {
   #sql { FETCH :iter INTO :x, :y };
   if (iter.endFetch()) break;
   ...process...
}
</pre><p>The transformations to the program logic will become even more difficult when considering arbitrary movements on scrollable iterators. Because positional iterators implement all the movement commands of named iterators, it is possible to exploit this and use <code class="codeph">RELATIVE :(0)</code> to populate variables from the iterator:
                        </p><pre class="oac_no_warn" dir="ltr">MyIter iter;
#sql iter = { ...query... };
while (iter.next()) {
   #sql { FETCH RELATIVE :(0) FROM :iter INTO :x, :y };
   ...process...
}
</pre><p>Now, you can preserve both the original query and the original program logic. Unfortunately, there still is one drawback to this approach. The <code class="codeph">MyIter</code> iterator type must implement the <code class="codeph">Scrollable</code> interface, even if this property is not really needed. To address this, the Oracle SQLJ implementation supports the following syntax extension:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { FETCH CURRENT FROM :iter INTO :x, :y, :z  };
</pre><p>Given this syntax, you can rewrite the JDBC example in SQLJ for scrollable as well as nonscrollable iterators:</p><pre class="oac_no_warn" dir="ltr">AnyIterator ai;
#sql ai = { ...query... };
while (ai.next()) {
   #sql { FETCH CURRENT FROM :ai INTO :x, :y };
   ...<span class="italic">process</span>...
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-3412CA95-37F0-4F1B-A061-97CE49C663D7">Scrollable Result Set Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Support in the Oracle SQLJ implementation for weakly typed result set iterators includes a scrollable result set iterator type:</p><pre class="oac_no_warn" dir="ltr">package sqlj.runtime;
public interface ScrollableResultSetIterator
                 extends ResultSetIterator
                 implements Scrollable
{ }
</pre><p>Because this type extends <code class="codeph">sqlj.runtime.ResultSetIterator</code>, it supports the methods described in <span class="q">"<a href="advanced-language-features.html#GUID-8A659A48-2847-4CC2-97B1-39116D628C9F">Result Set Iterators</a>"</span>.
                        </p>
                        <p>Because it also implements the <code class="codeph">sqlj.runtime.Scrollable</code> interface, it supports the methods described in <span class="q">"<a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a>"</span> and <span class="q">"<a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a>"</span>.
                        </p>
                        <p>Furthermore, scrollable result set iterators support the <code class="codeph">FETCH CURRENT</code> syntax described in <span class="q">"<a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a>"</span>.
                        </p>
                        <p>Consider the following JDBC code:</p><pre class="oac_no_warn" dir="ltr">Statement st = conn.createStatement("SELECT first_name, employee_id FROM employees");
ResultSet rs = st.executeQuery();
while (rs.next()) { 
   x = rs.getString(1); 
   y = rs.getInt(2);
}
rs.close();
</pre><p>You can use a SQLJ result set iterator in writing equivalent code, as follows:</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ResultSetIterator rsi;
#sql rsi = { SELECT first_name, employee_id FROM employees };
while (rsi.next()) {
   #sql { FETCH CURRENT FROM :rsi INTO :x, :y };
}
rsi.close();
</pre><p>To take advantage of scrollability features, you could also write the following code:</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ScrollableResultSetIterator srsi;
#sql srsi = { SELECT first_name, employee_id FROM employees };
srsi.afterLast();
while (srsi.previous()) {
   #sql { FETCH CURRENT FROM :srsi INTO :x, :y };
}
srsi.close();
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ562"></a><div class="sect2"><a id="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8" name="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8"></a><h3 id="JSQLJ-GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8" class="sect3">Advanced Transaction Control</h3>
               <div>
                  <p>SQLJ supports the SQL <code class="codeph">SET TRANSACTION</code> statement to specify the access mode and isolation level of any given transaction. Standard SQLJ supports <code class="codeph">READ ONLY</code> and <code class="codeph">READ WRITE</code> access mode settings, but the Oracle JDBC implementation does not support <code class="codeph">READ ONLY</code>. However, you can set permissions to have the same effect. Supported settings for isolation level are <code class="codeph">SERIALIZABLE</code>, <code class="codeph">READ COMMITTED</code>, <code class="codeph">READ UNCOMMITTED</code>, and <code class="codeph">REPEATABLE READ</code>. However, the Oracle SQL implementation does not support <code class="codeph">READ UNCOMMITTED</code> or <code class="codeph">REPEATABLE READ</code>.
                  </p>
                  <p><code class="codeph">READ WRITE</code> is the default access mode in both standard SQL and the Oracle SQL implementation. <code class="codeph">READ COMMITTED</code> is the default isolation level in the Oracle SQL implementation. <code class="codeph">SERIALIZABLE</code> is the default in standard SQL.
                  </p>
                  <p>The following sections provide details:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B">SET TRANSACTION Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-930E9F53-1611-4999-8A17-73CDD7E6E649">Access Mode Settings</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B">Isolation Level Settings</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-958C951B-678A-417B-959F-354975386F77">Using JDBC Connection Class Methods</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8__GUID-D211C78E-E1B7-4B27-8042-9EBB18B6DD95">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">Basic Transaction Control</a>"</span></p>
                  </div>
               </div><a id="JSQLJ563"></a><div class="sect3"><a id="GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B" name="GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B"></a><h4 id="JSQLJ-GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B" class="sect4">SET TRANSACTION Syntax</h4>
                  <div>
                     <p>The SQLJ <code class="codeph">SET TRANSACTION</code> statement has the following syntax:
                     </p><pre class="oac_no_warn" dir="ltr">#sql { SET TRANSACTION &lt;<span class="italic">access_mode</span>&gt;, &lt;ISOLATION LEVEL <span class="italic">isolation_level</span>&gt; };</pre><p>If you do not specify a connection context instance, then the statement applies to the default connection. If you use <code class="codeph">SET TRANSACTION</code>, then it must be the first statement in a transaction, preceding any DML statements. In other words, the first statement since your connection to the database or your most recent <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code>.
                     </p>
                     <p>In standard SQLJ, any access mode or isolation level you set will remain in effect across transactions until you explicitly reset it at the beginning of a subsequent transaction. In a standard SQLJ <code class="codeph">SET TRANSACTION</code> statement, you can optionally specify the isolation level first or only the access mode or only the isolation level. Following are some examples:
                     </p><pre class="oac_no_warn" dir="ltr">#sql { SET TRANSACTION READ WRITE };

#sql { SET TRANSACTION ISOLATION LEVEL SERIALIZABLE };

#sql { SET TRANSACTION READ WRITE, ISOLATION LEVEL SERIALIZABLE };

#sql { SET TRANSACTION ISOLATION LEVEL READ COMMITTED, READ WRITE };
</pre><p>You can also specify a particular connection context instance for a <code class="codeph">SET TRANSACTION</code> statement, as opposed to having it apply to the default connection:
                     </p><pre class="oac_no_warn" dir="ltr">#sql [myCtxt] { SET TRANSACTION ISOLATION LEVEL SERIALIZABLE };
</pre><p>Note that in SQLJ, both the access mode and the isolation level can be set in a single <code class="codeph">SET TRANSACTION</code> statement. This is not true in other Oracle SQL tools, such as Server Manager or SQL*Plus, where a single statement can set one or the other, but not both.
                     </p>
                  </div>
               </div><a id="JSQLJ564"></a><div class="sect3"><a id="GUID-930E9F53-1611-4999-8A17-73CDD7E6E649" name="GUID-930E9F53-1611-4999-8A17-73CDD7E6E649"></a><h4 id="JSQLJ-GUID-930E9F53-1611-4999-8A17-73CDD7E6E649" class="sect4">Access Mode Settings</h4>
                  <div>
                     <p><a id="d36232e4526" class="indexterm-anchor"></a><a id="d36232e4528" class="indexterm-anchor"></a>The <code class="codeph">READ WRITE</code> and <code class="codeph">READ ONLY</code> access mode settings, where supported, have the following functionality:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">READ WRITE</code> (default): In a <code class="codeph">READ WRITE</code> transaction, you are not allowed to update the database. <code class="codeph">SELECT</code>, <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">DELETE</code> are all legal.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">READ ONLY</code> (also supported by the Oracle JDBC implementation): In a <code class="codeph">READ ONLY</code> transaction, you are not allowed to update the database. <code class="codeph">SELECT</code> is legal, but <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, and <code class="codeph">SELECT FOR UPDATE</code> are not.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ565"></a><div class="sect3"><a id="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B" name="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B"></a><h4 id="JSQLJ-GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B" class="sect4">Isolation Level Settings</h4>
                  <div>
                     <p><a id="d36232e4614" class="indexterm-anchor"></a><a id="d36232e4616" class="indexterm-anchor"></a><a id="d36232e4618" class="indexterm-anchor"></a><a id="d36232e4620" class="indexterm-anchor"></a><a id="d36232e4622" class="indexterm-anchor"></a><a id="d36232e4624" class="indexterm-anchor"></a><a id="d36232e4626" class="indexterm-anchor"></a>The <code class="codeph">READ COMMITTED</code>, <code class="codeph">SERIALIZABLE</code>, <code class="codeph">READ UNCOMMITTED</code>, and <code class="codeph">REPEATABLE READ</code> isolation level settings, where supported, have the following functionality:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">READ UNCOMMITTED</code>: Dirty reads, nonrepeatable reads, and phantom reads are all allowed.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">READ COMMITTED</code> (default): Dirty reads are prevented, and nonrepeatable reads and phantom reads are allowed. If the transaction contains DML statements that require row locks held by other transactions, then any of the statements will block until the row lock it needs is released by the other transaction.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">REPEATABLE READ</code>: Dirty reads and nonrepeatable reads are prevented, and phantom reads are allowed.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SERIALIZABLE</code>: Dirty reads, nonrepeatable reads, and phantom reads are all prevented. Any DML statements in the transaction cannot update any resource that might have had changes committed after the transaction began. Such DML statements will fail.
                           </p>
                        </li>
                     </ul>
                     <p>A dirty read occurs when transaction B accesses a row that was updated by transaction A, but transaction A later rolls back the updates. As a result, transaction B sees data that was never actually committed to the database.</p>
                     <p>A nonrepeatable read occurs when transaction A retrieves a row, transaction B subsequently updates the row, and transaction A later retrieves the same row again. Transaction A retrieves the same row twice but sees different data.</p>
                     <p>A phantom read occurs when transaction A retrieves a set of rows satisfying a given condition, transaction B subsequently inserts or updates a row such that the row now meets the condition in transaction A, and transaction A later repeats the conditional retrieval. Transaction A now sees an additional row. This row is referred to as a phantom.</p>
                     <p>You can think of the four isolation level settings being in a progression:</p><pre class="oac_no_warn" dir="ltr">SERIALIZABLE &gt; REPEATABLE READ &gt; READ COMMITTED &gt; READ UNCOMMITTED
</pre><p>If a desired setting is unavailable to you, such as <code class="codeph">REPEATABLE READ</code> or <code class="codeph">READ UNCOMMITTED</code> if you use Oracle Database 12<span class="italic">c </span>Release 1 (12.1), use a greater setting (one further to the left) to ensure having at least the level of isolation that you want.
                     </p>
                     <div class="infoboxnotealso" id="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B__GUID-F09CEDE1-E9AD-4218-B93F-BF82303A5C50">
                        <p class="notep1">See Also:</p>
                        <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-6F888B25-FB84-456F-BF6E-675C955D3E52" target="_blank"><span class="italic">Oracle Database Development Guide</span></a></p>
                     </div>
                  </div>
               </div><a id="JSQLJ566"></a><div class="sect3"><a id="GUID-958C951B-678A-417B-959F-354975386F77" name="GUID-958C951B-678A-417B-959F-354975386F77"></a><h4 id="JSQLJ-GUID-958C951B-678A-417B-959F-354975386F77" class="sect4">Using JDBC Connection Class Methods</h4>
                  <div>
                     <p>You can optionally access and set the access mode and isolation level of a transaction, using methods of the underlying JDBC connection instance of your connection context instance. SQLJ code using these JDBC methods is not portable, however.</p>
                     <p>Following are the <code class="codeph">Connection</code> class methods for access mode and isolation level settings:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">abstract int getTransactionIsolation()</code>: Returns the current transaction isolation level as one of the following constant values: 
                           </p>
                           <p><code class="codeph">TRANSACTION_NONE TRANSACTION_READ_COMMITTED TRANSACTION_SERIALIZABLE TRANSACTION_READ_UNCOMMITTED TRANSACTION_REPEATABLE_READ</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract void setTransactionIsolation(int)</code>: Sets the transaction isolation level, taking as input one of the preceding constant values.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract boolean isReadOnly()</code>: Returns <code class="codeph">true</code> if the transaction is <code class="codeph">READ ONLY</code>. Returns <code class="codeph">false</code> if the transaction is <code class="codeph">READ WRITE</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract void setReadOnly(boolean)</code>: Sets the transaction access mode to <code class="codeph">READ ONLY</code> if <code class="codeph">true</code> is input. Sets the access mode to <code class="codeph">READ WRITE</code> if <code class="codeph">false</code> is input.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ567"></a><div class="sect2"><a id="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568" name="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568"></a><h3 id="JSQLJ-GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568" class="sect3">SQLJ and JDBC Interoperability</h3>
               <div>
                  <p>SQLJ<a id="d36232e4812" class="indexterm-anchor"></a> statements are typically used for static SQL operations. Oracle Database 12<span class="italic">c </span>Release 1 (12.1) has extensions to support dynamic SQL as well, but another alternative is to use JDBC code within your SQLJ application for dynamic operations, which would be more portable. And there might be additional scenarios where using JDBC code in your SQLJ application might be useful or even required. Because of this, SQLJ enables you to use SQLJ and JDBC statements concurrently and provides interoperability between SQLJ and JDBC constructs.
                  </p>
                  <p>Two kinds of interactions between SQLJ and JDBC are particularly useful:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Between SQLJ connection contexts and JDBC connections</p>
                     </li>
                     <li>
                        <p>Between SQLJ iterators and JDBC result sets</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568__GUID-356C7DBE-59E2-4EC2-B61B-96AD0F8D2541">
                     <p class="notep1">See Also:</p>
                     <p><a href="../jjdbc/JDBC-getting-started.html#JJDBC-GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a></p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310">SQLJ Connection Context and JDBC Connection Interoperability</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D">SQLJ Iterator and JDBC Result Set Interoperability</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ569"></a><a id="JSQLJ570"></a><a id="JSQLJ571"></a><a id="JSQLJ572"></a><a id="JSQLJ573"></a><a id="JSQLJ568"></a><div class="sect3"><a id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310" name="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310"></a><h4 id="JSQLJ-GUID-340AFCEF-E421-46F9-B136-DF9CC3723310" class="sect4">SQLJ Connection Context and JDBC Connection Interoperability</h4>
                  <div>
                     <p>SQLJ enables you to convert, in either direction, between SQLJ connection context instances and JDBC connection instances.</p>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-C7EA4813-99D9-44F6-9E84-BCF476DEF3DF">
                        <p class="notep1">Note:</p>
                        <p>When converting between a SQLJ connection context and a JDBC connection, bear in mind that the two objects are sharing the same underlying physical connection.</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-6F49BC14-F807-4C69-ABC1-6B5166E7E703">Converting from Connection Contexts to JDBC Connections</p>
                     </div>
                     <!-- class="section" -->
                     <p>If you want to perform a JDBC operation through a database connection that you have established in SQLJ (for example, if your application calls a library routine that returns a JDBC connection object), then you must convert the SQLJ connection context instance to a JDBC connection instance.</p>
                     <p>Any connection context instance in a SQLJ application, whether an instance of the <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class or of a declared connection context class, contains an underlying JDBC connection instance and a <code class="codeph">getConnection()</code> method that returns that JDBC connection instance. Use the JDBC connection instance to create JDBC statement objects if you want to use JDBC operations.
                     </p>
                     <p>Following is an example of how to use the <code class="codeph">getConnection()</code> method.
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.*;

...
DefaultContext ctx = new DefaultContext 
      ("jdbc:oracle:thin:@localhost:5221/myservice", "HR", "hr", true);
...
(<span class="italic">SQLJ operations through SQLJ </span>ctx <span class="italic">connection context instance</span>)
...
Connection conn = ctx.getConnection();
...
(<span class="italic">JDBC operations through JDBC</span> conn <span class="italic">connection instance</span>)
...
</pre><p>The connection context instance can be an instance of the <code class="codeph">DefaultContext</code> class or of any connection context class that you have declared.
                     </p>
                     <p>To retrieve the underlying JDBC connection of your default SQLJ connection, you can use <code class="codeph">getConnection()</code> directly from a <code class="codeph">DefaultContext.getDefaultContext()</code> call, where <code class="codeph">getDefaultContext()</code> returns a <code class="codeph">DefaultContext</code> instance that you had previously initialized as your default connection and <code class="codeph">getConnection()</code> returns its underlying JDBC connection instance. In this case, because you do not have to use the <code class="codeph">DefaultContext</code> instance explicitly, you can also use the <code class="codeph">Oracle.connect()</code> method. This method implicitly creates the instance and makes it the default connection.
                     </p>
                     <div class="infoboxnotealso" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-543EEB1A-EBAB-40DA-B9B1-6E237D090FB1">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">Connection Considerations</a>"</span> and <span class="q">"<a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">More About the Oracle Class</a>"</span></p>
                     </div>
                     <p>Following is an example:</p><pre class="oac_no_warn" dir="ltr">import java.sql.*;

...
Connection conn = Oracle.connect
   ("jdbc:oracle:thin:@localhost:5221/myservice", 
    "HR", "hr").getConnection();
...
(<span class="italic">JDBC operations through JDBC</span> conn <span class="italic">connection instance</span>)
...
</pre><div class="section" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__CBBEJJFD">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-6BA0A471-2625-42FE-9838-ADEB3BE564E5">Example: JDBC and SQLJ Connection Interoperability for Dynamic SQL</p>
                     </div>
                     <!-- class="section" -->
                     <p>Following is a sample method that uses the underlying JDBC connection instance of the default SQLJ connection context instance to perform dynamic SQL operations in JDBC. The dynamic operations are performed using JDBC <code class="codeph">java.sql.Connection</code>, <code class="codeph">java.sql.PreparedStatement</code>, and <code class="codeph">java.sql.ResultSet</code> objects. Alternatively, you can use Oracle SQLJ extensions for dynamic SQL operations.
                     </p>
                     <div class="infoboxnotealso" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-2C001A50-71A4-4395-A25D-DCA3932E5609">
                        <p class="notep1">See Also:</p>
                        <p><a href="../jjdbc/overview-of-JDBC.html#JJDBC-GUID-78462728-C5D3-4999-BDB9-7E676F772674" target="_blank"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> and <span class="q">"<a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">Support for Dynamic SQL</a>"</span></p>
                     </div><pre class="oac_no_warn" dir="ltr">import java.sql.*;

public static void projectsDue(boolean dueThisMonth) throws SQLException {

   // Get JDBC connection from previously initialized SQLJ DefaultContext.
   Connection conn = DefaultContext.getDefaultContext().getConnection();

   String query = "SELECT name, start_date + duration " +
                  "FROM projects WHERE start_date + duration &gt;= sysdate";
   if (dueThisMonth)
      query += " AND to_char(start_date + duration, 'fmMonth') " +
               " = to_char(sysdate, 'fmMonth') ";

   PreparedStatement pstmt = conn.prepareStatement(query);
   ResultSet rs = pstmt.executeQuery();
   while (rs.next()) {
      System.out.println("Project: " + rs.getString(1) + " Deadline: " +
                         rs.getDate(2));
   }
   rs.close();
   pstmt.close();
}
</pre><div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-B95F78ED-4E0C-4C68-BAFF-AC1CA873AB93">Converting from JDBC Connections to Connection Contexts</p>
                     </div>
                     <!-- class="section" -->
                     <p>If you initiate a connection as a JDBC <code class="codeph">Connection</code> instance but later want to use it as a SQLJ connection context instance (for example, if you want to use it in a context expression to specify the connection to use for a SQLJ executable statement), you can convert the JDBC connection instance to a SQLJ connection context instance.
                     </p>
                     <p>The <code class="codeph">DefaultContext</code> class and all declared connection context classes have a constructor that takes a JDBC connection instance as input and constructs a SQLJ connection context instance.
                     </p>
                     <p>For example, presume you instantiated and defined the JDBC connection instance <code class="codeph">conn</code> and want to use the same connection for an instance of a declared SQLJ connection context class <code class="codeph">MyContext</code>. You can do this as follows:
                     </p><pre class="oac_no_warn" dir="ltr">...
#sql context MyContext;
...
MyContext myctx = new MyContext(conn);
...
</pre><div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-906475FA-FFBD-40CA-8CDD-997E014D92D1">About Shared Connections</p>
                     </div>
                     <!-- class="section" -->
                     <p>A SQLJ connection context instance and the associated JDBC connection instance share the same underlying physical connection. As a result, the following is true:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When you get a JDBC connection instance from a SQLJ connection context instance (using the connection context <code class="codeph">getConnection()</code> method), the <code class="codeph">Connection</code> instance inherits the state of the connection context instance. Among other things, the <code class="codeph">Connection</code> instance will retain the auto-commit setting of the connection context instance.
                           </p>
                        </li>
                        <li>
                           <p>When you construct a SQLJ connection context instance from a JDBC connection instance (using the connection context constructor that takes a connection instance as input), the connection context instance inherits the state of the <code class="codeph">Connection</code> instance. Among other things, the connection context instance will retain the auto-commit setting of the <code class="codeph">Connection</code> instance. By default, a JDBC connection instance has an auto-commit setting of <code class="codeph">true</code>, but you can alter this through the <code class="codeph">setAutoCommit()</code> method of the <code class="codeph">Connection</code> instance.
                           </p>
                        </li>
                        <li>
                           <p>Given a SQLJ connection context instance and associated JDBC connection instance, calls to methods that alter session state in one instance will also affect the other instance, because it is actually the underlying shared session that is being altered.</p>
                        </li>
                        <li>
                           <p>Because there is just a single underlying physical connection, there is also a single underlying set of transactions. A <code class="codeph">COMMIT</code> or <code class="codeph">ROLLBACK</code> operation in one connection instance will affect any other connection instances that share the same underlying connection.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-FDA46A98-91B3-4F15-8F28-8DD66E5D3A77">
                        <p class="notep1">Note:</p>
                        <p>It is also possible for multiple SQLJ connection context instances to be created from the same JDBC connection instance and, therefore, to share the same underlying physical connection. This might be useful, for example, if you want to share the same set of transactions between program modules. The preceding notes apply to this situation as well.</p>
                     </div>
                     <div class="section" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-BC14DD55-2F26-4502-BD33-353E272807AA">Closing Shared Connections</p>
                     </div>
                     <!-- class="section" -->
                     <p>When you get a JDBC connection instance from a SQLJ connection context instance (using the <code class="codeph">getConnection()</code> method) or you create a SQLJ connection context instance from a JDBC connection instance (using the connection context constructor), you must close only the connection context instance. By default, calling the <code class="codeph">close()</code> method of a connection context instance closes the associated JDBC connection instance and the underlying physical connection, thereby freeing all resources associated with the connection.
                     </p>
                     <p>If you want to close a SQLJ connection context instance <span class="italic">without</span> closing the associated JDBC connection instance (if, for example, the <code class="codeph">Connection</code> instance is being used elsewhere, either directly or by another connection context instance), then you can specify the boolean constant <code class="codeph">KEEP_CONNECTION</code> to the <code class="codeph">close()</code> method, as follows (assume a connection context instance <code class="codeph">ctx</code>):
                     </p><pre class="oac_no_warn" dir="ltr">ctx.close(ConnectionContext.KEEP_CONN<a id="d36232e5121" class="indexterm-anchor"></a>ECTION);
</pre><p>If you do not specify <code class="codeph">KEEP_CONNECTION</code>, then the associated JDBC connection instance is closed by default. You can also specify this explicitly:
                     </p><pre class="oac_no_warn" dir="ltr">ctx.close(ConnectionContext.CLOSE_CONN<a id="d36232e5131" class="indexterm-anchor"></a>ECTION);
</pre><p><code class="codeph">KEEP_CONNECTION</code> and <code class="codeph">CLOSE_CONNECTION</code> are static constants of the <code class="codeph">sqlj.runtime.ConnectionContext</code> interface.
                     </p>
                     <p>If you close only the JDBC connection instance, this will <span class="italic">not</span> close the associated SQLJ connection context instance. The underlying physical connection would be closed, but the resources of the connection context instance would not be freed until garbage collection.
                     </p>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-37A03D05-F24B-4E4F-9622-146FD8830B12">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the same underlying JDBC connection is shared by multiple connection context instances, then use <code class="codeph">KEEP_CONNECTION</code> when closing all but the last remaining open connection context instance.
                              </p>
                           </li>
                           <li>
                              <p>An error message will be issued if you try to close a connection context instance whose underlying JDBC connection has already been closed, or if you try to close the underlying connection when it has already been closed. If you encounter this, then verify that the JDBC connection is not being closed independently by JDBC code and all preceding <code class="codeph">close()</code> calls on SQLJ connection context instances that use the underlying connection use the <code class="codeph">KEEP_CONNECTION</code> parameter.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ575"></a><a id="JSQLJ576"></a><a id="JSQLJ577"></a><a id="JSQLJ574"></a><div class="sect3"><a id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D" name="GUID-76329A99-A510-4BEB-8271-46F689A10D2D"></a><h4 id="JSQLJ-GUID-76329A99-A510-4BEB-8271-46F689A10D2D" class="sect4">SQLJ Iterator and JDBC Result Set Interoperability</h4>
                  <div>
                     <p>SQLJ enables you to convert in either direction between SQLJ iterators and JDBC result sets. For situations where you are selecting data in a SQLJ statement but do not care about strongly typed iterator functionality, SQLJ also supports a weakly typed iterator, which you can convert to a JDBC result set.</p>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007234">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-9ADE2497-94E9-4128-89BE-136360C00247">Converting from Result Sets to Named or Positional Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <p>There are a number of situations where you might find yourself manipulating JDBC result sets. For example, another package might be implemented in JDBC and provide access to data only through result sets or might require <code class="codeph">ResultSetMetaData</code> information because it is a routine written generically for any type of result set. Or your SQLJ application might invoke a stored procedure that returns a JDBC result set. 
                     </p>
                     <p>If the dynamic result set has a known structure, it is typically desirable to manipulate it as an iterator to use the strongly typed paradigm that iterators offer.</p>
                     <p>In SQLJ, you can populate a named or positional iterator object by converting an existing JDBC result set object. This can be thought of as casting a result set to an iterator, and the syntax reflects this as follows:</p><pre class="oac_no_warn" dir="ltr">#sql iter = { CAST :rs };
</pre><p>This binds the result set object, <code class="codeph">rs</code>, into the SQLJ executable statement, converts the result set, and populates the iterator, <code class="codeph">iter</code>, with the result set data.
                     </p>
                     <p>Following is an example. Assume <code class="codeph">myEmpQuery()</code> is a static Java function in a class called <code class="codeph">RSClass</code>, with a predefined query that returns a JDBC result set object:
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.*;
...
#sql public iterator MyIterator (String ename, float sal);
...
ResultSet rs;
MyIterator iter;
...
rs = RSClass.myEmpQuery();
#sql iter = { CAST :rs };
...
(<span class="italic">process iterator</span>)
...
iter.close();
...
</pre><p>This example could have used a positional iterator instead of a named iterator. The functionality is identical.</p>
                     <p>The following rules apply when converting a JDBC result set to a SQLJ iterator and processing the data:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>To convert to a positional iterator, the result set and iterator must have the same number of columns and the types must map correctly.</p>
                        </li>
                        <li>
                           <p>To convert to a named iterator, the result set must have at least as many columns as the iterator and all columns of the iterator must be matched by name and type. If the result set and iterator do not have the same number of columns, then the SQLJ translator will generate a warning unless you use the <code class="codeph">-warn=nostrict</code> option setting.
                           </p>
                        </li>
                        <li>
                           <p>The result set being cast must implement the <code class="codeph">java.sql.ResultSet</code> interface. The class <code class="codeph">oracle.jdbc.OracleResultSet</code> implements this interface, as does any standard result set class.
                           </p>
                        </li>
                        <li>
                           <p>The iterator receiving the cast must be an instance of an iterator class that was declared as <code class="codeph">public</code>.
                           </p>
                        </li>
                        <li>
                           <p>Do not access data from the result set, either before or after the conversion. Access data from the iterator only.</p>
                        </li>
                        <li>
                           <p>When you are finished, close the iterator, not the result set. Closing the iterator will also close the result set, but closing the result set will not close the iterator. When interoperating with JDBC, always close the SQLJ entity.</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007269">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-5B8EBAAE-6780-476E-8EBA-72D73AD82CAA">Converting from Named or Positional Iterators to Result Sets</p>
                     </div>
                     <!-- class="section" -->
                     <p>You might also encounter situations where you want to define a query using SQLJ but ultimately need a result set.</p>
                     <div class="infoboxnote" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-2EA53CA9-3F18-4481-9153-9116A6A7388D">
                        <p class="notep1">Note:</p>
                        <p>SQLJ offers more natural and concise syntax, but perhaps you want to do dynamic processing of the results, or perhaps you want to use an existing Java method that takes a result set as input.</p>
                     </div>
                     <p>So that you can convert iterators to result sets, every SQLJ iterator class, whether named or positional, is generated with a <code class="codeph">getResultSet()</code> method. This method can be used to return the underlying JDBC result set object of an iterator object. 
                     </p>
                     <p>Following is an example showing use of the <code class="codeph">getResultSet()</code> method:
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.*;

#sql public iterator MyIterator (String ename, float sal);

...
MyIterator iter;
...
#sql iter = { SELECT * FROM employees };
ResultSet rs = iter.getResultSet();
...
(<span class="italic">process result set</span>)
...
iter.close();
...
</pre><p>The following rules apply when converting a SQLJ iterator to a JDBC result set and processing the data.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When writing iterator data to a result set, you should access data only through the result set. Do not attempt to directly access the iterator, either before or after the conversion.</p>
                        </li>
                        <li>
                           <p>When you finish, close the original iterator, not the result set. Closing the iterator will also close the result set, but closing the result set will not close the iterator. When interoperating with JDBC, always close the SQLJ entity.</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007295">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-02C4C7D6-A513-4E5F-98C5-1865D91991B4">Using and Converting Weakly Typed Iterators (ResultSetIterator)</p>
                     </div>
                     <!-- class="section" -->
                     <p>You might have a situation similar to what is discussed in <span class="q">"<a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D">SQLJ Iterator and JDBC Result Set Interoperability</a>"</span>, but where you do not require the strongly typed functionality of the iterator. In such a case, you should be able to use SQLJ syntax for the query and then processing the data dynamically from a result set. For such circumstances, you can directly use the <code class="codeph">sqlj.runtime.ResultSetIterator</code> type to receive query data.
                     </p>
                     <p>In using SQLJ statements and <code class="codeph">ResultSetIterator</code> functionality instead of using JDBC statements and standard result set functionality, you enable yourself to use the more concise <code class="codeph">SELECT</code> syntax of SQLJ.
                     </p>
                     <p>Following is an example of how to use and convert a weakly typed result set iterator:</p><pre class="oac_no_warn" dir="ltr">import sqlj.runtime.*;
import java.sql.*;

...
ResultSetIterator rsiter;
...
#sql rsiter = { SELECT * FROM table };
ResultSet rs = rsiter.getResultSet();
...
(<span class="italic">process result set</span>)
...
rsiter.close();
...
</pre><div class="infoboxnote" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-A8C67155-0CAB-4D3E-AF4E-A63B1F5B7222">
                        <p class="notep1">Note:</p>
                        <p>The Oracle SQLJ implementation permits navigation through a result set iterator using the <code class="codeph">next()</code> method and <code class="codeph">FETCH CURRENT</code> syntax. Furthermore, for scrollable result set iterators, additional navigation methods are supported.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ578"></a><div class="sect2"><a id="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA" name="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA"></a><h3 id="JSQLJ-GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA" class="sect3">Support for Dynamic SQL</h3>
               <div>
                  <p>The Oracle SQLJ implementation includes extensions to support dynamic SQL, operations that are not predefined and can change in real time. Dynamic SQL expressions embedded in SQLJ statements are referred to as meta bind expressions.</p>
                  <div class="infoboxnote" id="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA__GUID-EE4FE99B-3E77-4261-BA34-FE7D1BC2EAFD">
                     <p class="notep1">Note:</p>
                     <p>Using JDBC code is still an option for dynamic SQL in Oracle Database 12<span class="italic">c </span>Release 1 (12.1) and might be preferable if code portability is a concern, but SQLJ support for dynamic SQL permits use of SQLJ as a single, simplified API for data access.
                     </p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76572A3E-02EE-41E4-98AD-9937A46C050D">Meta Bind Expressions</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67">SQLJ Dynamic SQL Examples</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ580"></a><a id="JSQLJ581"></a><a id="JSQLJ582"></a><a id="JSQLJ583"></a><a id="JSQLJ584"></a><a id="JSQLJ585"></a><a id="JSQLJ579"></a><div class="sect3"><a id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D" name="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D"></a><h4 id="JSQLJ-GUID-76572A3E-02EE-41E4-98AD-9937A46C050D" class="sect4">Meta Bind Expressions</h4>
                  <div>
                     <p>Meta bind expressions are used for dynamic SQL in SQLJ statements, where otherwise static SQL clauses would appear. A meta bind expression contains a Java identifier of <code class="codeph">String</code> type or a string-valued Java expression that is interpreted at run time. In addition, so that SQLJ can perform online semantics-checking, a meta bind expression can optionally include static SQL replacement code to be used for checking during translation.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-3D48A66D-8AC0-46A2-B3E6-FB3DB510FC0C">Meta Bind Expressions: General Usage and Restrictions</p>
                     </div>
                     <!-- class="section" -->
                     <p>You can use a meta bind expression in place of any of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Table name</p>
                        </li>
                        <li>
                           <p>Column name in a <code class="codeph">SELECT</code> statement (without the column alias, if specified)
                           </p>
                        </li>
                        <li>
                           <p>All or part of a <code class="codeph">WHERE</code> clause condition
                           </p>
                        </li>
                        <li>
                           <p>Role, schema, catalog, or package name in a data definition language (DDL) or DML statement</p>
                        </li>
                        <li>
                           <p>SQL literal value or SQL expression</p>
                        </li>
                     </ul>
                     <p>Be aware of the following restrictions on meta bind expressions, enforced to ensure that the SQLJ translator can properly determine the nature of the SQL operation and can perform syntactic analysis of the SQLJ statement as a whole:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A meta bind expression cannot be the first noncomment of the SQL operation within a SQLJ statement.</p>
                        </li>
                        <li>
                           <p>A meta bind expression cannot contain the <code class="codeph">INTO</code> token of a SQLJ <code class="codeph">SELECT INTO</code> statement and cannot expand to become the <code class="codeph">INTO</code>-list of a <code class="codeph">SELECT INTO</code> statement.
                           </p>
                        </li>
                        <li>
                           <p>A meta bind expression cannot appear in any of the following kinds of SQL/SQLJ instructions or clauses: <code class="codeph">CALL</code>, <code class="codeph">VALUES</code>, <code class="codeph">PSM SET</code>, <code class="codeph">COMMIT</code>, <code class="codeph">ROLLBACK</code>, <code class="codeph">FETCH INTO</code>, or <code class="codeph">CAST</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-5C7F34D1-2067-44AF-9A4B-8BDB30BD1D95">Meta Bind Expressions: Syntax and Behavior</p>
                     </div>
                     <!-- class="section" -->
                     <p>Following is the general syntax for meta bind expressions:</p><pre class="oac_no_warn" dir="ltr">:{ <span class="italic">Java_bind_expression</span> }
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">:{ <span class="italic">Java_bind_expression</span> :: <span class="italic">SQL_replacement_code</span> }
</pre><p>Note that spaces are optional. There can be multiple meta bind expressions within the SQL instructions of a SQLJ statement.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-602E808A-0E37-492B-86AA-520FF8F8EFCF">Java Bind Expression</p>
                     </div>
                     <!-- class="section" -->
                     <p>A Java bind expression can be either of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Java identifier of the <code class="codeph">String</code> type
                           </p>
                        </li>
                        <li>
                           <p>Java expression that evaluates to a character string</p>
                        </li>
                     </ul>
                     <p>Java bind expressions within meta bind expressions are subject to standard Java lexing rules and have syntax similar to that of SQLJ host expressions. However, unlike host expressions, Java bind expressions within meta bind expressions are not enclosed within parentheses. This is because, if there is SQL replacement code, then the <code class="codeph">::</code> token acts as a separator between the Java bind expression and the SQL code. If there is no SQL replacement code, then the closing braces (}) acts as a terminator. In either case, there is no ambiguity.
                     </p>
                     <div class="infoboxnote" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-16384EC8-3939-4A39-9266-1073E780D00B">
                        <p class="notep1">Note:</p>
                        <p>There can be no mode specifiers, <code class="codeph">IN</code>, <code class="codeph">OUT</code>, or <code class="codeph">INOUT</code>, within a Java bind expression or between <code class="codeph">:</code> and <code class="codeph">{</code> of the meta bind expression.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-C6B84308-0B23-4D91-952B-BB083E2D43B7">SQL Replacement Code</p>
                     </div>
                     <!-- class="section" -->
                     <p>A SQL replacement code clause consists of a sequence of zero or more SQL tokens, with the following requirements and restrictions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It is subject to SQL lexing rules.</p>
                        </li>
                        <li>
                           <p>Braces ({ }) must occur in matching pairs (with the exception of those that are part of a SQL comment, constant, or identifier).</p>
                        </li>
                        <li>
                           <p>There can be no SQLJ host expressions or nested meta bind expressions within the SQL instructions.</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-1BA1FB81-45D8-4B88-A555-BD5A0DC564EA">
                        <p class="notep1">Note:</p>
                        <p>It is permissible for the SQL replacement code to be empty.</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-C05AEAE7-A241-4C81-B27A-239072972DCD">Translation-Time Behavior</p>
                     </div>
                     <!-- class="section" -->
                     <p>Whenever there is SQL replacement code (even if only an empty string) in a meta bind expression, then the meta bind expression is replaced by the SQL code during translation. The purpose of SQL replacement code is to enable the SQLJ translator to perform online semantics-checking.</p>
                     <p>If any meta bind expression within a SQLJ statement has no SQL replacement code clause, then the SQLJ translator cannot perform online semantics-checking on the statement. It is only checked syntactically. </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-00BAC44C-F683-4AD2-9592-D511911C7998">Run-Time Behavior</p>
                     </div>
                     <!-- class="section" -->
                     <p>At run time, each meta bind expression is replaced by the evaluation of its Java bind expression. If a Java bind expression evaluates to <code class="codeph">null</code>, then the dynamic SQL statement as a whole becomes undefined.
                     </p>
                  </div>
               </div><a id="JSQLJ587"></a><a id="JSQLJ588"></a><a id="JSQLJ589"></a><a id="JSQLJ590"></a><a id="JSQLJ591"></a><a id="JSQLJ586"></a><div class="sect3"><a id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67" name="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67"></a><h4 id="JSQLJ-GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67" class="sect4">SQLJ Dynamic SQL Examples</h4>
                  <div>
                     <p>This section provides examples of dynamic SQL usage in SQLJ code.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-1785F89C-FE40-4B19-A516-3C5D0DD84405">Example 1</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...
int x = 10;
int y = x + 10;
int z = y + 10;
String table = "new_Emp";
#sql { INSERT INTO :{table :: emp} VALUES (:x, :y, :z) };
...
</pre><p>During translation, the SQL operation becomes:</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES (10, 20, 30);
</pre><p>SQLJ can perform online semantics-checking against a schema that has an <code class="codeph">emp</code> table. Perhaps <code class="codeph">new_Emp</code> only exists in the run-time schema and is not created until the application executes.
                     </p>
                     <p>During run time, the SQL operation becomes:</p><pre class="oac_no_warn" dir="ltr">INSERT INTO new_Emp VALUES (10, 20, 30);
</pre><div class="section">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-CA666E24-C321-458C-A527-01E006EB9DBF">Example 2</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...
String table = "new_Emp";
String query = "ename LIKE 'S%' AND sal&gt;1000";
#sql myIter = { SELECT * FROM :{table :: emp2} 
                         WHERE :{query :: ename='HR'} };
...
</pre><p>During translation, the SQL operation becomes:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp2 WHERE ename='HR';
</pre><p>SQLJ can perform online semantics-checking against a schema that has an <code class="codeph">emp2</code> table.
                     </p>
                     <p>During run time, the SQL operation becomes:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM new_Emp WHERE ename LIKE 'S%' AND sal&gt;1000;
</pre><div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007458">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-DAD3CD99-51CE-4D0F-AC43-8836D151FA8F">Example 3</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...
double raise = 1.12;
String col = "comm";
String whereQuery = "WHERE "+col+" IS NOT null";
for (int i=0; i&lt;5; i++)
{
   #sql { UPDATE :{"emp"+i :: emp} 
          SET :{col :: sal} = :{col :: sal} * :raise :{whereQuery ::} };
}
...
</pre><p>During translation, the SQL operation becomes:</p><pre class="oac_no_warn" dir="ltr">UPDATE emp SET sal = sal * 1.12;
</pre><p>SQLJ can perform online semantics-checking against a schema that has an <code class="codeph">emp</code> table. There is no <code class="codeph">WHERE</code> clause during translation, because the SQL replacement code is empty.
                     </p>
                     <p>During run time, the SQL operation is executed five times, becoming:</p><pre class="oac_no_warn" dir="ltr">UPDATE emp0 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp1 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp2 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp3 SET comm = comm * 1.12 WHERE comm IS NOT null;
UPDATE emp4 SET comm = comm * 1.12 WHERE comm IS NOT null;
</pre><div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007483">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-FB0CA7C0-F8DB-4E2D-A952-DEE6EFBA34E9">Example 4</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...
double raise = 1.12;
String col = "comm";
String whereQuery = "WHERE "+col+" IS NOT null";
for (int i=0; i&lt;10; i++)
{
   #sql { UPDATE :{"emp"+i} 
          SET :{col :: sal} = :{col :: sal} * :raise :{whereQuery ::} };
}
...
</pre><p>The run-time behaviors of Example 3 and Example 4 are identical. However, a difference occurs during translation, where SQLJ cannot perform online semantics-checking for Example 4, because there is no SQL replacement code for the first meta bind expression, <code class="codeph">:{"emp"+i}</code>.
                     </p>
                     <div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007507">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-0656E79B-6203-4FBD-B843-20D1439590D3">Example 5: Dynamic SQL with FETCH from Result Set Iterator</p>
                     </div>
                     <!-- class="section" -->
                     <p>This example is a rework of <span class="q">"<a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__CBBEJJFD">Example: JDBC and SQLJ Connection Interoperability for Dynamic SQL</a>"</span>, using SQLJ statements instead of JDBC statements. This example also uses <code class="codeph">FETCH CURRENT</code> functionality from a result set iterator.
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql.*;

public static void projectsDue(boolean dueThisMonth) throws SQLException {

   ResultSetIterator rsi;
   String andClause = (dueThisMonth) ? 
                       " AND to_char(start_date + duration, 'fmMonth' ) " 
                       + " = to_char(sysdate, 'fmMonth') " 
                       : "";
   #sql rsi = { SELECT name, start_date + duration FROM projects
                WHERE start_date + duration &gt;= sysdate :{andClause :: } };
   while (rsi.next())
   {
      String name = null;
      java.sql.Date deadline = null;
      #sql { FETCH CURRENT FROM :rsi INTO :name, :deadline };
      System.out.println("Project: " + name + "Deadline: " + deadline);
   } 
   rsi.close();
}
</pre></div>
               </div>
            </div><a id="JSQLJ594"></a><a id="JSQLJ595"></a><a id="JSQLJ596"></a><a id="JSQLJ597"></a><a id="JSQLJ598"></a><a id="JSQLJ599"></a><a id="JSQLJ600"></a><a id="JSQLJ601"></a><a id="JSQLJ592"></a><div class="sect2"><a id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69" name="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69"></a><h3 id="JSQLJ-GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69" class="sect3">Using Stored Outlines</h3>
               <div>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-25DE8CAA-1FD3-46FD-B291-F39DF71E9C62">
                     <p class="notep1">Note:</p>
                     <p>Starting from Oracle Database 12<span class="italic">c </span>Release 2 (12.2), this feature is deprecated, and replaced with SQL Plan Management (SPM). Oracle recommends that you take advantage of the new feature, which is more powerful and offers better performance. For more information about SPM, refer to <span class="q">"<a href="advanced-language-features.html#GUID-8465DD7E-5943-4BBD-911D-F1318A55552E">Using Plan Baselines</a>"</span>.
                     </p>
                  </div>
                  <p>If you run the risk of any performance changes in the application due to change in the environment, then you may use the outline feature of Oracle. An outline is implemented as a set of optimizer hints that are associated with the SQL statement. If the use of the outline is enabled for the statement, Oracle automatically considers the stored hints and tries to generate an execution plan in accordance with those hints. You can group outlines into categories, that is, whether they are default or as specified by the client, and control the category of outlines Oracle uses to simplify outline administration and deployment. The hints in the outlines are used during the execution of respective statements if you have set <code class="codeph">USE_STORED_OUTLINES</code> to the category name or to <code class="codeph">TRUE.</code></p>
                  <div class="infoboxnotealso" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-4BF405CD-1EA7-4F65-A023-2DACD6B20466">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/CREATE-OUTLINE.html#SQLRF-GUID-7CC033AF-DB19-4616-87D9-8173939FD627" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a>for more information about outlines.
                     </p>
                  </div>
                  <p>When you translate the file with the new outline option set to <code class="codeph">true</code> or the category name, then:
                  </p>
                  <ol>
                     <li>
                        <p>A separate SQL file is created containing the <code class="codeph">CREATE OUTLINE</code> statements for all the SQL statements present in the input SQLJ file.
                        </p>
                     </li>
                     <li>
                        <p>A log file containing the SQL statements, outline name, outline SQL statement, outline category, and status information is generated.</p>
                     </li>
                     <li>
                        <p>If you specify the <code class="codeph">-runoutline option</code>, then the SQL file generated is run at the end of successful translation of the input file.
                        </p>
                     </li>
                  </ol>
                  <p>SQL statements that can be used to create outlines are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>SELECT</p>
                     </li>
                     <li>
                        <p>DELETE</p>
                     </li>
                     <li>
                        <p>UPDATE</p>
                     </li>
                     <li>
                        <p>INSERT ... SELECT</p>
                     </li>
                     <li>
                        <p>CREATE TABLE ... AS SELECT</p>
                     </li>
                  </ul>
                  <p>You have the following restrictions on creating outlines:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You cannot create outlines on MERGE statements.</p>
                     </li>
                     <li>
                        <p>You cannot create outlines on a multi-table INSERT statement.</p>
                     </li>
                     <li>
                        <p>The SQL statement in the outline cannot include any DML operation on a remote object.</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-3126F6DE-D7B7-41BA-8E3C-C7192753FD9F">Options to Generate Outlines</p>
                  </div>
                  <!-- class="section" -->
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-EC1A2812-F955-46F2-BBC2-6C4DCE45C1D5">
                     <p class="notep1">Note:</p>
                     <p>The outline options are valid <span class="italic">only</span> if online checking is done.
                     </p>
                  </div>
                  <p>Consider the SQLJ program <code class="codeph">abc.sqlj</code> contains the following code snippet:
                  </p><pre class="oac_no_warn" dir="ltr">{
#sql iter = {SELECT * FROM employees WHERE employee_id=:var;}
#sql iter1 = {SELECT * FROM departments};
}
</pre><p>Compile the SQLJ program as:</p><pre class="oac_no_warn" dir="ltr">%sqlj -url=jdbc:oracle:oci8:@ -user=HR -outline=abccat abc.sqlj
Password: <span class="italic">password</span>
</pre><p>The generated SQL file <code class="codeph">abc_sqlj.sql</code> for the above SQLJ code snippet looks as follows:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 
/* abccat_abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments 
/* abccat_abc_sqlj_0002 */;
</pre><div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-E64C2682-3CFE-4412-B4F6-ED7432598AF3">
                     <p class="notep1">Note:</p>
                     <p>The filename is not included in the outline name or comment when a prefix is given. In this section, you will see examples with and without using prefix. For more information on prefix, refer to <span class="q">"<a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CHDFFGHI">sqlj.outlineprefix</a>"</span>.
                     </p>
                  </div>
                  <p>The option <code class="codeph">-outline</code> generates two files at the end of successful translation: a SQL file and a LOG file. The generated SQL file name has the following format:
                  </p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_&lt;filetype&gt;.sql
</pre><p>For example, the generated SQL file for filename <code class="codeph">abc.sqlj</code> is <code class="codeph">abc_sqlj.sql.</code></p>
                  <p>The format of the unique identifier used as outline name and comment is:</p><pre class="oac_no_warn" dir="ltr">&lt;categoryname &gt;_&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence no.&gt;
</pre><p>where, the sequence number is a four-digit sequence number ranging from 0001 to 9999. If the SQLJ program contains more than 9999 SQL statements, then you get the "<code class="codeph">Max sequence number exceeded for outlines</code>" error. For example, the format of the unique identifier generated for <code class="codeph">abc.sqlj</code> is <code class="codeph">abccat_abc_sqlj_0001</code>, where, <code class="codeph">abccat</code> is the name of the category.
                  </p>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-B65FAFBB-EDD2-4350-A6E4-5F4D88C848D8">
                     <p class="notep1">Note:</p>
                     <p>The same comment is added to the SQLs in the generated java or class file that is used at runtime.</p>
                  </div>
                  <p>If you set outline to <code class="codeph">true</code>, then the default category will be used to store the outlines:
                  </p><pre class="oac_no_warn" dir="ltr">%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=true abc.sqlj
Password: <span class="italic">password</span>
</pre><p>In this case, the generated SQL file <code class="codeph">abc_sqlj.sql</code> looks as follows:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OUTLINE default_abc_sqlj_0001 ON SELECT * FROM employees WHERE employee_id=:B1 /* default_abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE default_abc_sqlj_0002 ON SELECT * FROM departments /* default_abc_sqlj_0002 */;
</pre><p>You can use the following command to set the outline name to a particular prefix:</p><pre class="oac_no_warn" dir="ltr">%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=pref1 abc.sqlj
Password: <span class="italic">password</span>
</pre><p>In this case, the generated SQL file <code class="codeph">abc_sqlj.sql</code> looks as follows:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OUTLINE pref1_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 /* pref1_0001 */';

CREATE OR REPLACE OUTLINE pref1_0002 FOR CATEGORY abccat ON SELECT * FROM departments /* pref1_0002 */';
</pre><div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-0E0733F0-D929-41AD-B516-FF928333FF94">
                     <p class="notep1">Note:</p>
                     <p>If you set the <code class="codeph">-outlineprefix</code> option, then you can pass only one SQLJ file to the translator.
                     </p>
                  </div>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-66117AC5-9F9F-4DD5-8F61-748050535433">
                     <p class="notep1">Note:</p>
                     <p>To translate multiple files with the <code class="codeph">outlineprefix</code> option, you can do the following:
                     </p><pre class="oac_no_warn" dir="ltr">%sqlj -outline=abccat -outlineprefix=pref1,pref2,pref3 abc.sqlj def.sqlj fgh.sqlj
</pre></div>
                  <p>Currently, the upper limit on the length of the outline name is 30 bytes. Hence, if the generated outline name exceeds 30 bytes, a SQLJ error "<code class="codeph">Outline name exceeds maximum limit. Use -outlineprefix option</code>" is thrown. In such cases, if you want to use the <code class="codeph">-outline</code> option, you need to call <code class="codeph">-outlineprefix</code> option as shown in the preceding example. If you want database server to generate the outline names instead of the SQLJ generated outline names, then you can set the <code class="codeph">-outlineprefix</code> option to <code class="codeph">none.</code> For example:
                  </p><pre class="oac_no_warn" dir="ltr">%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=none abc.sqlj
Password: <span class="italic">password</span>
</pre><p>In this case, the generated SQL file <code class="codeph">abc_sqlj.sql</code> looks as follows:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OUTLINE FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 /* abccat_abc_sqlj_0001 */';

CREATE OR REPLACE OUTLINE FOR CATEGORY abccat ON SELECT * FROM departments /* abccat_abc_sqlj_0002 */';
</pre><p>If you want to translate multiple files with the <code class="codeph">-outlineprefix</code> option, then you can use the following command:
                  </p><pre class="oac_no_warn" dir="ltr">%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=abccat -outlineprefix=pref1,pref2 abc.sqlj def.sqlj
Password: <span class="italic">password</span>
</pre><p>If the SQLJ file is part of a package and you have not specified the <code class="codeph">-outlineprefix</code> option, then the package name is appended to the outline name and is added to the comment. For example, if <code class="codeph">abc.sqlj</code> is part of <code class="codeph">xyz.def.fgh</code> package, then generated SQL file <code class="codeph">abc_sqlj.sql</code>, for the command <code class="codeph">%sqlj -url=jdbc:oracle:oci8:@ -user=HR/</code><span class="italic"><code class="codeph">password</code></span><code class="codeph"> -outline=abccat abc.sqlj</code> looks as follows:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE OUTLINE abccat_xyz$def$fgh$abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id=:B1 
/* abccat_xyz$def$fgh$abc_sqlj_0001 */;

CREATE OR REPLACE OUTLINE abccat_xyz$def$fgh$abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments 
/* abccat_xyz$def$fgh$abc_sqlj_0002 */;
</pre><p>If you want the generated SQL file to be executed by the translator at the end of successful translation, then you can set the <code class="codeph">runoutline</code> option to <code class="codeph">true</code>. By default it is <code class="codeph">false.</code> For example:
                  </p><pre class="oac_no_warn" dir="ltr">%sqlj -user=HR -url=jdbc:oracle:oci8:@ -outline=default -runoutline=true abc.sqlj
Password: <span class="italic">password</span>
</pre><p>Now, if you want to retrieve the outline name for exporting or for modifying the plan of the SQL code, then you can retrieve the same from the <code class="codeph">OL$</code> table, either manually or by using a tool. You can use the comment in the SQL query to search for the appropriate SQL statement to identify the outline name because the comment uniquely identifies the SQL statement.
                  </p>
                  <p><a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CBBEEECI" title="Table showing options and values for generating outlines">Table 8-1</a> shows all the options and values you can pass to the translator for generating outlines.
                  </p>
                  <div class="tblformal" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CBBEEECI">
                     <p class="titleintable">Table 8-1 Table showing the options and values for generating outlines</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="Table showing the options and values for generating outlines" summary="Table showing options and values for generating outlines" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="50%" id="d36232e6098">Option Name</th>
                              <th align="left" valign="bottom" width="50%" id="d36232e6101">Option Value</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6106" headers="d36232e6098 ">
                                 <p><code class="codeph">-outline</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6106 d36232e6101 ">
                                 <p><code class="codeph">true</code>&lt;category name&gt;
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6116" headers="d36232e6098 ">
                                 <p><code class="codeph">-outlineprefix</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6116 d36232e6101 ">
                                 <p><code class="codeph">none</code>&lt;prefix name&gt;|<code class="codeph">none</code>&lt;prefix name 1, prefix name 2,â€¦&gt;
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6129" headers="d36232e6098 ">
                                 <p><code class="codeph">-runoutline</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6129 d36232e6101 ">
                                 <p><code class="codeph">true</code>|<code class="codeph">false</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnotealso" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-E9D5A9E3-85AD-4256-925B-5EBEDAEDEEF5">
                     <p class="notep1">See Also:</p>
                     <p><a href="../refrn/DBA_OUTLINES.html#REFRN-GUID-D311BC8E-FB08-4990-8DED-C6AB221088F2" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for more information about outlines.
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-92B9F11C-2046-40EB-AC52-6339AA7953C9">Generated LOG File Name</p>
                  </div>
                  <!-- class="section" -->
                  <p>The format of the generated file name is:</p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_&lt;filetype&gt;.log
</pre><p>For example, on translating <code class="codeph">abc.sqlj</code>, the generated log file is <code class="codeph">abc_sqlj.log.</code></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-F942FC80-8EB1-42CB-B941-85CFC2042A2B">Generated LOG File Format</p>
                  </div>
                  <!-- class="section" -->
                  <p>Suppose, you have the following code snippet:</p><pre class="oac_no_warn" dir="ltr">#sql iter = {SELECT * FROM employees WHERE employee_id=:var };
#sql iter1 = {SELECT * FROM departments };
</pre><p>The generated log file for the preceding code snippet is as follows:</p><pre class="oac_no_warn" dir="ltr">CATERGORY abccat
Source SQL_1
SELECT * FROM employees WHERE employee_id=:B1
OUTLINE NAME
abccat_abc_sqlj_0001
OUTLINE SQL_1
CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id = :B1 
/* abccat_abc_sqlj_0001 */
STATUS success
Source SQL_2
SELECT * FROM departments
OUTLINE NAME
abccat_abc_sqlj_0002
OUTLINE SQL_2
CREATE OR REPLACE OUTLINE abccat_abc_sqlj_2 FOR abccat ON SELECT * FROM departments
/* abccat_abc_sqlj_2 */
STATUS fail
</pre><p>In the preceding example of the generated log file format:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Category means the category of the outline to be generated</p>
                     </li>
                     <li>
                        <p>Source means the SQL statements for which outline is to be generated</p>
                     </li>
                     <li>
                        <p>Outline Name is the name of the outline to be generated</p>
                     </li>
                     <li>
                        <p>Status is the execution status of the SQL statements used as the source. If the execution is successful, then status is <code class="codeph">success.</code> Otherwise, it is <code class="codeph">fail.</code></p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-8E8DAD66-15EF-4C6E-8DB4-357084867674">Configuration Files</p>
                  </div>
                  <!-- class="section" -->
                  <p>You can set the different command-line options in the configuration file as follows:</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-3C5B9EE1-C1EE-430E-B330-5209851A6DD0">sqlj.outline</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Parameter Name: <code class="codeph">outline</code></p>
                     </li>
                     <li>
                        <p>Parameter Type: String</p>
                     </li>
                     <li>
                        <p>Allowable Values: {true|category_name}</p>
                     </li>
                     <li>
                        <p>Default Value: true</p>
                     </li>
                     <li>
                        <p>Description: Indicates that outline SQL file needs to be generated for the SQL statements and it should be in:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>DEFAULT category if the value is default, that is, <code class="codeph">true</code></p>
                           </li>
                           <li>
                              <p>The category name if <span class="italic">category_name</span> is mentioned
                              </p>
                           </li>
                        </ul>
                        <p>Outline SQL file is not generated if this option is not used.</p>
                     </li>
                     <li>
                        <p>Dependency on other parameters: Online check should be full when this option is turned on</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-44394535-9071-482A-955C-711DADF86DDF">sqlj.runoutline</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Parameter Name: <code class="codeph">runoutline</code></p>
                     </li>
                     <li>
                        <p>Parameter Type: boolean</p>
                     </li>
                     <li>
                        <p>Allowable Values: {true|false}</p>
                     </li>
                     <li>
                        <p>Default Value: false</p>
                     </li>
                     <li>
                        <p>Description: If <code class="codeph">runoutline=true</code> then the generated SQL file should be executed by the translator at the end of successful translation.
                        </p>
                     </li>
                     <li>
                        <p>Dependency on other parameters: Online check should be full when this option is turned on, and the outline option should be set.</p>
                     </li>
                  </ul>
                  <div class="section" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CHDFFGHI">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-BAC61B19-BF5F-4575-8C34-5A46D18A40AE">sqlj.outlineprefix</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Parameter Name: <code class="codeph">outlineprefix</code></p>
                     </li>
                     <li>
                        <p>Parameter Type: String</p>
                     </li>
                     <li>
                        <p>Allowable Values:  {prefix name}, none</p>
                     </li>
                     <li>
                        <p>Description: If this option is set, the outline name in the generated SQL is set to <code class="codeph">&lt;prefix&gt;_&lt;seqno&gt;</code>. When this option is set to any value apart from <code class="codeph">none</code> in the properties file, only one SQLJ file may be passed to the translator. If the option is set to <code class="codeph">none</code>, outline name is generated by the system when the <code class="codeph">create outline</code> statement is executed in the server. Also, you may pass multiple files to the translator when <code class="codeph">&#x2013;outlineprefix</code> is set to none.
                        </p>
                     </li>
                     <li>
                        <p>Dependency on other parameters: Online check should be full when this option is turned on, and the outline option should be set.</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JSQLJ889"></a><div class="sect2"><a id="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E" name="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E"></a><h3 id="JSQLJ-GUID-8465DD7E-5943-4BBD-911D-F1318A55552E" class="sect3">Using Plan Baselines</h3>
               <div>
                  <p>Starting from Oracle Database 12<span class="italic">c</span> Release 2 (12.2), SQLJ supports the creation of plan baselines using Oracle Database SQL Plan Management (SPM). You can generate plan baselines at the time of translating the SQLJ files. The necessary SQL statements to create the plan baselines are generated in the <code class="codeph">.sql</code> files. You can review, tune, and fix the plan baselines before deploying the SQLJ application.
                  </p>
                  <div class="infoboxnotealso" id="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E__GUID-A69CE7F9-38E9-49AE-8288-35D6F465AF5A">
                     <p class="notep1">See Also:</p>
                     <p><a href="../tgsql/glossary.html#TGSQL-GUID-0C3F70B2-94F7-4ABF-B433-0F8E2925EE22" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a> for more information about plan baselines
                     </p>
                  </div>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB">Generating Plan Baselines</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5">Command-Line and Property File Options</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ891"></a><a id="JSQLJ890"></a><div class="sect3"><a id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB" name="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB"></a><h4 id="JSQLJ-GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB" class="sect4">Generating Plan Baselines</h4>
                  <div>
                     <p>You can generate plan baselines for all the SQL statements that are supported by SPM. The generated log file reports the unsupported statements, if any.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-31BF86BF-8375-48FC-A30E-3BAD1DBBA3C5">Parameters</p>
                     </div>
                     <!-- class="section" -->
                     <p>When specifying plan baseline options, SQLJ generates SQL files with calls to the <code class="codeph">dbms_spm_internal.create_sql_plan_baseline</code> procedure. This procedure has the following parameters:
                     </p>
                     <div class="tblformal" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-D7DF942E-3319-4254-9441-4A7645BCB194">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="This table describes the parameters of create_sql_plan procedure" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d36232e6404">Parameter</th>
                                 <th align="left" valign="bottom" width="71%" id="d36232e6407">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6412" headers="d36232e6404 ">
                                    <p><code class="codeph">SQL_TEXT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6412 d36232e6407 ">
                                    <p>Specifies the SQL text for which the plan baseline needs to be created.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6420" headers="d36232e6404 ">
                                    <p><code class="codeph">PARSING_SCHEMA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6420 d36232e6407 ">
                                    <p>Specifies the schema that is used for semantic checking of the SQL text passed.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6428" headers="d36232e6404 ">
                                    <p><code class="codeph">PLAN_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6428 d36232e6407 ">
                                    <p>Specifies the name of the plan baseline. This parameter is optional. If this parameter is not specified, then the default plan name is <code class="codeph">default.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6438" headers="d36232e6404 ">
                                    <p><code class="codeph">ENABLED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6438 d36232e6407 ">
                                    <p>Specifies whether the plan is to be enabled or not. Default value is <code class="codeph">yes</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6449" headers="d36232e6404 ">
                                    <p><code class="codeph">FIXED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6449 d36232e6407 ">
                                    <p>Specifies whether the plan will be a fixed plan or not. Default value is <code class="codeph">no</code>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-C7C8F261-D814-49D2-AEDB-6FD4D47BEEC0">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>To generate and execute the plan baseline SQL statements, you must have the <code class="codeph">Execute</code> privilege on the <code class="codeph">DBMS_SPM_INTERNAL</code> package and the <code class="codeph">Administer</code> <code class="codeph">SQL</code> <code class="codeph">Management</code> <code class="codeph">Object</code> privilege.
                              </p>
                           </li>
                           <li>
                              <p>The plan baseline options are valid only if online semantic checking is done. If you specify these options with offline semantic checking, then the options are ignored and a warning is thrown informing that the options should be used with online semantic checking only.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ892"></a><div class="sect3"><a id="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5" name="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5"></a><h4 id="JSQLJ-GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5" class="sect4">Command-Line and Property File Options</h4>
                  <div>
                     <p>Use the following command-line options for generating plan baseline SQL statements:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07">plan_baseline</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-E210E14E-B525-4EFD-A500-BF519E95C725">plan_prefix</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-30E179ED-C131-4617-8F31-93D98ACC0948">plan_run</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3">plan_fixed</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1">plan_enabled</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5__GUID-BB1D20D0-F185-49D8-90E2-5D0CD1B836AA">
                        <p class="notep1">Note:</p>
                        <p>The generated files specify the appropriate user to run the files. For example, the following statements in a generated file specify that <code class="codeph">HR</code> can run the file:
                        </p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:='HR';
</pre></div>
                  </div><a id="JSQLJ894"></a><a id="JSQLJ895"></a><a id="JSQLJ896"></a><a id="JSQLJ893"></a><div class="sect4"><a id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07" name="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07"></a><h5 id="JSQLJ-GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07" class="sect5">plan_baseline</h5>
                     <div>
                        <p>Use the <code class="codeph">plan_baseline</code> option to specify whether baseline plans should be generated for all the SQL statements in the SQL file or not. If you set this option to <code class="codeph">true</code>, then <code class="codeph">default</code> is used as the baseline name. The baseline name is the equivalent to the category name when you use outlines. The value you provide for this option is used as the module name when running the SQL file.
                        </p>
                        <p>The name of the SQL file is translated with a sequence number and the combination is used to uniquely identify each SQL statement in the SQL file. This combination is also used as the name of the plan. The sequence number can vary from 0 to 9999. The format of the plan name is as follows:</p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_&lt;filetype&gt;_&lt;sequence_no&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-0A3F2DCE-288F-4C59-A1CA-35AA7249B8DA">Syntax</p>
                        </div>
                        <!-- class="section" -->
                        <p>In command-line, the <code class="codeph">plan_baseline</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">-plan_baseline= &lt;true/false/module_name&gt;
</pre><p>In the property file, the <code class="codeph">plan_baseline</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.plan_baseline=&lt;true/false/module_name&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-A186AC8B-D1F5-43D0-8634-ADB5C6BD19B6">Default Value</p>
                        </div>
                        <!-- class="section" -->
                        <p>The default value for the <code class="codeph">plan_baseline</code> option is <code class="codeph">false</code>, in which case the plan baselines are not generated. If you specify the value <code class="codeph">true</code> for this option, the module name is <code class="codeph">default.</code></p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-053EB3F7-8E7D-4B20-A3EB-A9101885A3BA">Example</p>
                        </div>
                        <!-- class="section" --><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj &#x2013;plan_baseline=true -user=HR/hr
</pre><p>If the <code class="codeph">test.sqlj</code> is a part of a package named <code class="codeph">mypackage</code> and contains only the following two SQL statements:
                        </p><pre class="oac_no_warn" dir="ltr">Select first_name from employees;
Select employee_id from employees;
</pre><p>Then, the content of the generated SQL file is:</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:='HR';
begin
    dbms_application_info.set_module(â€˜default','');
end;
 
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'mypackage_test_sqlj_0000') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select first_name from employees /*mypackage_test_sqlj_0000*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'mypackage_test_sqlj_0000', 
   'no', 
   'no'); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'mypackage_test_sqlj_0001') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select employee_id from employees /*mypackage_test_sqlj_0001*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'mypackage_test_sqlj_0001', 
   'no', 
   'no'); 
END ; 
/
</pre><p>If the <code class="codeph">test.sqlj</code> contains only the following two SQL statements:
                        </p><pre class="oac_no_warn" dir="ltr">Select first_name from employees;
Select employee_id from employees;
</pre><p>And you provide an SPM plan name as the following:</p><pre class="oac_no_warn" dir="ltr">sqlj &#x2013;plan_name=mybaseline -user=HR/hr test.sqlj
</pre><p>Then, the content of the generated SQL file is:</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2(30) ; 
exec :ORA_SPM_PARSE_SCHEMA:='HR'; 
begin
    dbms_application_info.set_module(â€˜mybaseline,'');
end;
 
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'mypackage_test_sqlj_0000') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select first_name from employees /*mypackage_test_sqlj_0000*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'mypackage_test_sqlj_0000', 
   'no', 
   'no'); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'mypackage_test_sqlj_0001') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select employee_id from employees /*mypackage_test_sqlj_0001*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'mypackage_test_sqlj_0001', 
   'no', 
   'no'); 
END ; 
/
</pre></div>
                  </div><a id="JSQLJ898"></a><a id="JSQLJ899"></a><a id="JSQLJ900"></a><a id="JSQLJ897"></a><div class="sect4"><a id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725" name="GUID-E210E14E-B525-4EFD-A500-BF519E95C725"></a><h5 id="JSQLJ-GUID-E210E14E-B525-4EFD-A500-BF519E95C725" class="sect5">plan_prefix</h5>
                     <div>
                        <p>Use the <code class="codeph">plan_prefix</code> option to specify a name for the plan. This corresponds to the <code class="codeph">PLAN_NAME</code> argument of the <code class="codeph">create_sql_plan_baseline</code> procedure. If you do not use this option, then a plan name is generated automatically. 
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-FBADDB9A-EC15-41DB-9F2A-D4E50B805D03">Syntax</p>
                        </div>
                        <!-- class="section" -->
                        <p>In command-line, the <code class="codeph">plan_prefix</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">-plan_prefix=&lt;name&gt;
</pre><p>In the property file, the <code class="codeph">plan_prefix</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.plan_prefix=&lt;name&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-9CAB3874-3526-4A2E-8BEE-EC6FA61C9500">Default Value</p>
                        </div>
                        <!-- class="section" -->
                        <p>The value for the <code class="codeph">plan_prefix</code> option is <code class="codeph">none</code>. If you specify any other value for this option, then the format of the plan name becomes the following:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;name&gt;_&lt;sequence_no&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-74371BFF-089E-442D-A6F6-F1BD93D775FD">Example</p>
                        </div>
                        <!-- class="section" -->
                        <p><code class="codeph">sqlj test.sqlj &#x2013;plan_baseline=mybaseline true -user=HR/hr &#x2013;plan_prefix=myprefix</code></p>
                        <p>Suppose, <code class="codeph">test.sqlj</code> contains only the following two SQL statements:
                        </p><pre class="oac_no_warn" dir="ltr">Select first_name from employees;
Select employee_id from employees;
</pre><p>Then, the content of the generated SQL file is:</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2(30);
exec :ORA_SPM_PARSE_SCHEMA:='HR';
begin
    dbms_application_info.set_module(â€˜default','');
end;
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'myprefix_0000') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select first_name from employees /*myprefix_0000*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'myprefix_0000', 
   'no', 
   'no'); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'myprefix_0001') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select employee_id from employees /*myprefix_0001*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'myprefix_0001', 
   'no', 
   'no'); 
END ; 
</pre></div>
                  </div><a id="JSQLJ902"></a><a id="JSQLJ903"></a><a id="JSQLJ901"></a><div class="sect4"><a id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948" name="GUID-30E179ED-C131-4617-8F31-93D98ACC0948"></a><h5 id="JSQLJ-GUID-30E179ED-C131-4617-8F31-93D98ACC0948" class="sect5">plan_run</h5>
                     <div>
                        <p>Use the <code class="codeph">plan_run</code> option to specify if you want SQLJ to execute the generated SQL file at the end of translation.
                        </p>
                        <div class="infoboxnote" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-C04CF5D7-8B7D-4ACC-A545-F6EF0BA72842">
                           <p class="notep1">Note:</p>
                           <p>You <span class="italic">must</span> have the following privileges to execute the generated SQL file:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Execute privilege on the <code class="codeph">DBMS_SPM_INTERNAL</code> package
                                 </p>
                              </li>
                              <li>
                                 <p>Administer SQL Management Object privilege</p>
                              </li>
                           </ul>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-9A82EADD-7626-429F-AB73-C0E7388EC320">Syntax</p>
                        </div>
                        <!-- class="section" -->
                        <p>In command-line, the <code class="codeph">plan_run</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">-plan_run=&lt;yes|no&gt;
</pre><p>In the property file, the <code class="codeph">plan_run</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.plan_run=&lt;yes|no&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-8C55A852-A37C-42F1-B9E8-9BC59A966AB7">Default Value</p>
                        </div>
                        <!-- class="section" -->
                        <p>This default value for the <code class="codeph">plan_run</code> option is <code class="codeph">yes</code>.
                        </p>
                     </div>
                  </div><a id="JSQLJ905"></a><a id="JSQLJ906"></a><a id="JSQLJ904"></a><div class="sect4"><a id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3" name="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3"></a><h5 id="JSQLJ-GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3" class="sect5">plan_fixed</h5>
                     <div>
                        <p>Use the <code class="codeph">plan_fixed</code> option to specify whether the generated baseline should be fixed or not.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3__GUID-C42D6644-6592-44AE-8C0D-2583A8BB73C8">Syntax</p>
                        </div>
                        <!-- class="section" -->
                        <p>In command-line, the <code class="codeph">plan_fixed</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">-plan_fixed = &lt;yes|no&gt;
</pre><p>In the property file, the <code class="codeph">plan_fixed</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.plan_fixed=&lt;yes|no&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3__GUID-DE5C9626-4A60-4E46-A64F-5CA6DD261263">Default Value</p>
                        </div>
                        <!-- class="section" -->
                        <p>This default value for this option is <code class="codeph">yes</code>.
                        </p>
                     </div>
                  </div><a id="JSQLJ908"></a><a id="JSQLJ909"></a><a id="JSQLJ907"></a><div class="sect4"><a id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1" name="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1"></a><h5 id="JSQLJ-GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1" class="sect5">plan_enabled</h5>
                     <div>
                        <p>Use the <code class="codeph">plan_enabled</code> option to specify whether the generated baseline should be enabled or not.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1__GUID-B1EE9C0E-03CB-48C8-AE9A-98DF4F674EF6">Syntax</p>
                        </div>
                        <!-- class="section" -->
                        <p>In command-line, the <code class="codeph">plan_enabled</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">-plan_enabled = &lt;yes|no&gt;
</pre><p>In the property file, the <code class="codeph">plan_enabled</code> option is specified as the following:
                        </p><pre class="oac_no_warn" dir="ltr">sqlj.plan_enabled=&lt;yes|no&gt;
</pre><div class="section">
                           <p class="subhead3" id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1__GUID-85B68844-4D2A-4519-B36D-6658FFC9CA83">Default Value</p>
                        </div>
                        <!-- class="section" -->
                        <p>This default value for this option is <code class="codeph">yes</code>.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ910"></a><div class="sect3"><a id="GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70" name="GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70"></a><h4 id="JSQLJ-GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70" class="sect4">Generated SQL File</h4>
                  <div>
                     <p>At the end of precompilation of the SQLJ file with options described in <a href="advanced-language-features.html#GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5">Command-Line and Property File Options</a>, a SQL file is generated. This SQL file contains the SQL statements for creating SPM plans for each SQL statement in the SQLJ file.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4">Generated SQL File Name</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192">Generated SQL File Format</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ911"></a><div class="sect4"><a id="GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4" name="GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4"></a><h5 id="JSQLJ-GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4" class="sect5">Generated SQL File Name</h5>
                     <div>
                        <p>The name of the generated SQL file is in the following format:</p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_&lt;filetype&gt;_bln.sql
</pre><p>For SQLJ, the file type is always <code class="codeph">.sqlj</code>. So, the name of the SQL file is always in the following format:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_sqlj_bln.sql
</pre></div>
                  </div><a id="JSQLJ912"></a><div class="sect4"><a id="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192" name="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192"></a><h5 id="JSQLJ-GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192" class="sect5">Generated SQL File Format</h5>
                     <div>
                        <p>Suppose, the <code class="codeph">test.sqlj</code> file is a part of the package <code class="codeph">mypackage</code> and it contains the following SQL statements:
                        </p><pre class="oac_no_warn" dir="ltr">#sql  {select * from employees };
#sql  {select manager_id from employees };
</pre><p>If you precompile the file with the following command:</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj &#x2013;plan_baseline=mybaseline &#x2013;plan_prefix=myprefix -userid=HR/hr
</pre><p>Then the content of the generated SQL file <code class="codeph">mypackage_test_sqlj_bln.sql</code> is:
                        </p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2(30) ;
exec :ORA_SPM_PARSE_SCHEMA:='HR';
begin
    dbms_application_info.set_module(â€˜default','');
end;
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'myprefix_0000') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select first_name from employees /*myprefix_0000*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'myprefix_0000', 
   'no', 
   'no'); 
END ; 
/
BEGIN 
  BEGIN 
    d := SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE( PLAN_NAME =&gt; 'myprefix_0001') ; 
    EXCEPTION 
    WHEN OTHERS THEN NULL; 
  END; 
  c:=SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE( 
   'Select employee_id from employees /*myprefix_0001*/', 
   :ORA_SPM_PARSE_SCHEMA, 
   'myprefix_0001', 
   'no', 
   'no'); 
END ;

</pre><div class="infoboxnote" id="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192__GUID-12F46793-B563-4528-A9DE-10A1DFC182B1">
                           <p class="notep1">Note:</p>
                           <p></p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The sequence number 0000 and 0001 are used to uniquely identify the plan name for each SQL statement.</p>
                              </li>
                              <li>
                                 <p>If you specify a value other than <code class="codeph">none</code> with the <code class="codeph">plan_prefix</code> option, then the prefix value is used instead of the value that is specified with the <code class="codeph">&#x2013;plan_baseline</code> option.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="JSQLJ913"></a><div class="sect3"><a id="GUID-62420BB6-38D6-43CB-82FB-753742261137" name="GUID-62420BB6-38D6-43CB-82FB-753742261137"></a><h4 id="JSQLJ-GUID-62420BB6-38D6-43CB-82FB-753742261137" class="sect4">Generated Log File</h4>
                  <div>
                     <p>At the end of precompilation a SQL file is generated. This section describes the following details of the log file:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-FA1C4957-E930-4959-B510-0FF3498A750D">Generated Log File Name</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE">Generated Log File Format</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ914"></a><div class="sect4"><a id="GUID-FA1C4957-E930-4959-B510-0FF3498A750D" name="GUID-FA1C4957-E930-4959-B510-0FF3498A750D"></a><h5 id="JSQLJ-GUID-FA1C4957-E930-4959-B510-0FF3498A750D" class="sect5">Generated Log File Name</h5>
                     <div>
                        <p>The name of the generated log file is in the following format:</p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_&lt;filetype&gt;_bln.log
</pre><p>For SQLJ, the file type is always <code class="codeph">.sqlj</code>. So, the name of the SQL file is always in the following format:
                        </p><pre class="oac_no_warn" dir="ltr">&lt;filename&gt;_sqlj_bln.log
</pre></div>
                  </div><a id="JSQLJ915"></a><div class="sect4"><a id="GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE" name="GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE"></a><h5 id="JSQLJ-GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE" class="sect5">Generated Log File Format</h5>
                     <div>
                        <p>Suppose, the <code class="codeph">test.sqlj</code> file is a part of the package <code class="codeph">mypackage</code> and it contains the following SQL statements:
                        </p><pre class="oac_no_warn" dir="ltr">#sql  {select * from employees };
#sql  {select manager_id from employees };
</pre><p>If you precompile the file with the following command:</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj &#x2013;plan_baseline=true userid=HR/hr
</pre><p>Then the content of the generated log file is:</p><pre class="oac_no_warn" dir="ltr">MODULE default 
    SOURCE SQL_0
       select * from employees;
    PLAN NAME 
       mypackage_test_sqlj_0000 
    STATUS Success 
 
/******************************************/ 
/******************************************/ 
MODULE default 
    SOURCE SQL_1
       select manager_id from employees 
    PLAN NAME 
       mypackage_test_sqlj_0001 
    STATUS Success 
 
/******************************************/

</pre><p>If you precompile the file with the following command:</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj &#x2013;plan_baseline=true  userid=HR/hr &#x2013;plan_prefix=myprefix
</pre><p>Then the content of the generated log file is:</p><pre class="oac_no_warn" dir="ltr">MODULE default 
    SOURCE SQL_0
       select * from employees;
    PLAN NAME 
       myprefix_0000 
    STATUS Success 
 
/******************************************/ 
/******************************************/ 
MODULE default 
    SOURCE SQL_1
       select manager_id from employees 
    PLAN NAME 
       myprefix_0001 
    STATUS Success 
 
/******************************************/
</pre></div>
                  </div>
               </div><a id="JSQLJ916"></a><div class="sect3"><a id="GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E" name="GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E"></a><h4 id="JSQLJ-GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E" class="sect4">Generated Java File</h4>
                  <div>
                     <p>At the end of precompilation a Java file is generated.</p>
                     <p>Suppose, the <code class="codeph">test.sqlj</code> file is a part of the package <code class="codeph">mypackage</code> and it contains the following SQL statements:
                     </p><pre class="oac_no_warn" dir="ltr">#sql {select * from employees };
</pre><p>If you precompile the file with the following command:</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj &#x2013;plan_baseline=mybaseline &#x2013;plan_prefix=myprefix -userid=HR/hr
</pre><p>Then the generated Java file has an identifier appended to the SQL statement as follows:</p><pre class="oac_no_warn" dir="ltr">try {
   String theSqlTS = "select first_name from employees  /*mybaseline_test_sqlj_0001*/";
   __sJT_st = __sJT_ec.prepareOracleStatement(__sJT_cc,"0Select",theSqlTS);
   // execute query
   iter = new Iter(new sqlj.runtime.ref.OraRTResultSet(__sJT_ec.oracleExecuteQuery(),__sJT_st,"0Select",null));
  } finally { __sJT_ec.oracleCloseQuery(); }
</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>