<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">
      <meta name="description" content="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">
      <title>Indexes for XMLType Data</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Developer's Guide ">
      <meta property="og:description" content="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96222-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="query-and-update-XML.html" title="Previous" type="text/html">
      <link rel="next" href="transformation-and-validation-of-XMLType-data.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer's Guide">
    <meta name="dcterms.isVersionOf" content="ADXDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="query-and-update-XML.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="transformation-and-validation-of-XMLType-data.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="manipulation-of-XML-in-XML-DB.html" property="item" typeof="WebPage"><span property="name"> Manipulation of XML Data in Oracle XML&nbsp;DB</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Indexes for XMLType Data</li>
            </ol>
            <a id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" name="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC"></a><a id="ADXDB0500"></a>
            
            <h2 id="ADXDB-GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" class="sect2"><span class="enumeration_chapter">6 </span>Indexes for XMLType Data
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='indexes-for-XMLType-data'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index <code class="codeph">XMLType</code> data, whether it is XML schema-based or non-schema-based, and regardless of the <code class="codeph">XMLType</code> storage model you use.
               </p>
               <div class="infoboxnote" id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC__GUID-9F40EC93-FD49-4583-8ACE-155B1FD58BE8">
                  <p class="notep1">Note:</p>
                  <p>The execution plans shown here are for illustration only. If you run the examples presented here in your environment then your execution plans might not be identical.</p>
               </div>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-9F243764-7945-4EF4-9C94-624BE732708F">Oracle XML&nbsp;DB Tasks Involving Indexes</a><br>Common tasks involving indexes for XML data are described.
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392">Overview of Indexing XMLType Data</a><br>Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a><br></li>
                  <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C">Indexing XML Data for Full-Text Queries</a><br>When you need full-text search over XML data, Oracle recommends that you store your <code class="codeph">XMLType</code> data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA">Indexing XMLType Data Stored Object-Relationally</a><br>You can effectively index <code class="codeph">XMLType</code> data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC__GUID-36013FE2-5AF4-4941-8955-75877975E687">
                  <p class="notep1">See Also:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="../cncpt/indexes-and-index-organized-tables.html#CNCPT811" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of indexing
                        </p>
                     </li>
                     <li>
                        <p><a href="../adfns/indexes.html#ADFNS005" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> for information about using indexes in application development
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="manipulation-of-XML-in-XML-DB.html#GUID-87C758D5-5792-483D-8894-4C01FCD2A8A0" title="The following are covered here: XQuery, XMLType operations, and indexing of XML data.">Manipulation of XML Data in Oracle XML&nbsp;DB</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5812"></a><a id="ADXDB5813"></a><a id="ADXDB5814"></a><a id="ADXDB5815"></a><a id="ADXDB4308"></a><div class="props_rev_3"><a id="GUID-9F243764-7945-4EF4-9C94-624BE732708F" name="GUID-9F243764-7945-4EF4-9C94-624BE732708F"></a><h3 id="ADXDB-GUID-9F243764-7945-4EF4-9C94-624BE732708F" class="sect3"><span class="enumeration_section">6.1 </span>Oracle XML&nbsp;DB Tasks Involving Indexes
               </h3>
               <div>
                  <p>Common tasks involving indexes for XML data are described.</p>
                  <p><a href="indexes-for-XMLType-data.html#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGBDDDE" title="This table shows the basic tasks involving indexing XML data.">Table 6-1</a> identifies the documentation for some basic user tasks involving indexes for XML data.
                  </p>
                  <div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGBDDDE">
                     <p class="titleintable">Table 6-1 Basic XML Indexing Tasks</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Basic XML Indexing Tasks" summary="This table shows the basic tasks involving indexing XML data." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="62%" id="d34642e145">For information about how to...</th>
                              <th align="left" valign="bottom" width="38%" id="d34642e148">See...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e153" headers="d34642e145 ">
                                 <p>Choose an indexing approach</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e153 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e164" headers="d34642e145 ">
                                 <p>Index <code class="codeph">XMLType</code> data stored object-relationally
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e164 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>, <a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" title="If a collection is stored as an ordered collection table (OCT) or as an XMLType instance, then you can directly access members of the collection. Each member becomes a table row, so you can access it directly with SQL. You can often improve performance by indexing such collection members.">Guideline: Create indexes on ordered collection tables</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e190" headers="d34642e145 ">
                                 <p>Create, drop, or rename an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e190 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-7</a>, <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">Example 6-9</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e202" headers="d34642e145 ">
                                 <p>Obtain the name of an <code class="codeph">XMLIndex</code> index for a given table or column
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e202 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">Example 6-8</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e212" headers="d34642e145 ">
                                 <p>Determine whether a given <code class="codeph">XMLIndex</code> index is used in evaluating a query
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e212 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" title="To know whether a particular XMLIndex index has been used in resolving a query, you can examine an execution plan for the query.">How to Tell Whether XMLIndex is Used</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e229" headers="d34642e145 ">
                                 <p>Turn off use of an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e229 d34642e148 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="You can turn off the use of XMLIndex by using optimizer hint: /*+ NO_XML_QUERY_REWRITE */ or optimizer hint /*+ NO_XMLINDEX_REWRITE */.">Turning Off Use of XMLIndex</a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="indexes-for-XMLType-data.html#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDECIA" title="This table shows the tasks involving XMLIndex indexes with a structured component.">Table 6-2</a> identifies the documentation for some user tasks involving <code class="codeph">XMLIndex</code> indexes that have a <span class="italic">structured</span> component.
                  </p>
                  <div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDECIA">
                     <p class="titleintable">Table 6-2 Tasks Involving XMLIndex Indexes with a Structured Component</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Tasks Involving XMLIndex Indexes with a Structured Component" summary="This table shows the tasks involving XMLIndex indexes with a structured component." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="61%" id="d34642e273">For information about how to...</th>
                              <th align="left" valign="bottom" width="39%" id="d34642e276">See...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e281" headers="d34642e273 ">
                                 <p>Create an <code class="codeph">XMLIndex</code> index with a structured component
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e281 d34642e276 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a>, <a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-21</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e293" headers="d34642e273 ">
                                 <p>Drop the structured component of an <code class="codeph">XMLIndex</code> index (drop all structure groups)
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e293 d34642e276 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">Example 6-25</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e303" headers="d34642e273 ">
                                 <p>Ensure data type correspondence between a query and an <code class="codeph">XMLIndex</code> index with a structured component 
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e303 d34642e276 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e320" headers="d34642e273 ">
                                 <p>Create a B-tree index on a content table of an <code class="codeph">XMLIndex</code> structured component 
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e320 d34642e276 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">Example 6-26</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e330" headers="d34642e273 ">
                                 <p>Create an Oracle Text <code class="codeph">CONTEXT</code> index on a content table of an <code class="codeph">XMLIndex</code> structured component
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e330 d34642e276 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-46</a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="indexes-for-XMLType-data.html#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGFHJJE" title="This table shows the tasks involving XMLIndex indexes with an unstructured component.">Table 6-3</a> identifies the documentation for some user tasks involving <code class="codeph">XMLIndex</code> indexes that have an <span class="italic">unstructured</span> component.
                  </p>
                  <div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGFHJJE">
                     <p class="titleintable">Table 6-3 Tasks Involving XMLIndex Indexes with an Unstructured Component</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Tasks Involving XMLIndex Indexes with an Unstructured Component" summary="This table shows the tasks involving XMLIndex indexes with an unstructured component." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="61%" id="d34642e364">For information about how to...</th>
                              <th align="left" valign="bottom" width="39%" id="d34642e367">See...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e372" headers="d34642e364 ">
                                 <p>Create an <code class="codeph">XMLIndex</code> index with an unstructured component
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e372 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-10</a>, <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-12</a>, <a href="indexes-for-XMLType-data.html#GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDIHICC">Example 6-33</a>, <a href="indexes-for-XMLType-data.html#GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDJEICC">Example 6-35</a>, <a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-36</a>, <a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-37</a>, <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-38</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e395" headers="d34642e364 ">
                                 <p>Drop the unstructured component of an <code class="codeph">XMLIndex</code> index (drop the path table)
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e395 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">Example 6-13</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e405" headers="d34642e364 ">
                                 <p>Name the path table when creating an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e405 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-10</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e415" headers="d34642e364 ">
                                 <p>Specify storage options when creating an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e415 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-12</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e425" headers="d34642e364 ">
                                 <p>Show all existing secondary indexes on an <code class="codeph">XMLIndex</code> path table
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e425 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-14</a>, <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-20</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e437" headers="d34642e364 ">
                                 <p>Obtain the name of a path table for an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e437 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-11</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e447" headers="d34642e364 ">
                                 <p>Obtain the name of an <code class="codeph">XMLIndex</code> index with an unstructured component, given its path table
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e447 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">Example 6-28</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e457" headers="d34642e364 ">
                                 <p>Create a secondary index on an <code class="codeph">XMLIndex</code> path table
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e457 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e474" headers="d34642e364 ">
                                 <p>Obtain information about all of the secondary indexes on an <code class="codeph">XMLIndex</code> path table
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e474 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-20</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e484" headers="d34642e364 ">
                                 <p>Create a function-based index on a path-table <code class="codeph">VALUE</code> column
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e484 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-15</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e494" headers="d34642e364 ">
                                 <p>Create a numeric index on a path-table <code class="codeph">VALUE</code> column
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e494 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-17</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e505" headers="d34642e364 ">
                                 <p>Create a date index on a path-table <code class="codeph">VALUE</code> column
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e505 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-18</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e515" headers="d34642e364 ">
                                 <p>Create an Oracle Text <code class="codeph">CONTEXT</code> index on a path-table <code class="codeph">VALUE</code> column
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e515 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-19</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e528" headers="d34642e364 ">
                                 <p>Exclude or include particular XPath expressions from use by an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e528 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e545" headers="d34642e364 ">
                                 <p>Specify namespace prefixes for XPath expressions used for <code class="codeph">XMLIndex</code></p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e545 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e561" headers="d34642e364 ">
                                 <p>Exclude or include particular XPath expressions from use by an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e561 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="61%" id="d34642e578" headers="d34642e364 ">
                                 <p>Specify namespace prefixes for XPath expressions used for <code class="codeph">XMLIndex</code></p>
                              </td>
                              <td align="left" valign="top" width="39%" headers="d34642e578 d34642e367 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="indexes-for-XMLType-data.html#GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDFDFE" title="This table shows the miscellaneous tasks involving XMLIndex indexes.">Table 6-4</a> identifies the documentation for some other user tasks involving <code class="codeph">XMLIndex</code> indexes.
                  </p>
                  <div class="tblformalwide" id="GUID-9F243764-7945-4EF4-9C94-624BE732708F__BCGDFDFE">
                     <p class="titleintable">Table 6-4 Miscellaneous Tasks Involving XMLIndex Indexes</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Miscellaneous Tasks Involving XMLIndex Indexes" summary="This table shows the miscellaneous tasks involving XMLIndex indexes." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="62%" id="d34642e612">For information about how to...</th>
                              <th align="left" valign="bottom" width="38%" id="d34642e615">See...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e620" headers="d34642e612 ">
                                 <p>Specify that an <code class="codeph">XMLIndex</code> index should be created and maintained using parallel processes
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e620 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e643" headers="d34642e612 ">
                                 <p>Change the parallelism of an <code class="codeph">XMLIndex</code> path table to tune index performance
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e643 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e666" headers="d34642e612 ">
                                 <p>Schedule maintenance for an <code class="codeph">XMLIndex</code> index
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e666 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e689" headers="d34642e612 ">
                                 <p>Manually synchronize an <code class="codeph">XMLIndex</code> index and its base table
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e689 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e712" headers="d34642e612 ">
                                 <p>Collect statistics on a table or index for the cost-based optimizer</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e712 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">Example 6-40</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e719" headers="d34642e612 ">
                                 <p>Create an XML search index</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e719 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-41</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e726" headers="d34642e612 ">
                                 <p>Use an XML search index for full-text search of XML data stored as binary XML</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e726 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">Example 6-42</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e733" headers="d34642e612 ">
                                 <p>Show whether an XML search index is used in a query</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e733 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">Example 6-43</a></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="62%" id="d34642e740" headers="d34642e612 ">
                                 <p>Create an Oracle Text <code class="codeph">CONTEXT</code> index on a content table of an <code class="codeph">XMLIndex</code> structured component
                                 </p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d34642e740 d34642e615 ">
                                 <p><a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-46</a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6280"></a><a id="ADXDB6281"></a><a id="ADXDB6282"></a><a id="ADXDB4310"></a><div class="props_rev_3"><a id="GUID-AEF30229-B377-4479-9627-45494B772392" name="GUID-AEF30229-B377-4479-9627-45494B772392"></a><h3 id="ADXDB-GUID-AEF30229-B377-4479-9627-45494B772392" class="sect3"><span class="enumeration_section">6.2 </span>Overview of Indexing XMLType Data
               </h3>
               <div>
                  <p>Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.</p>
                  <p>The principle way you index XML data is using <code class="codeph">XMLIndex</code>. You can also use Oracle Text <code class="codeph">CONTEXT</code> indexes to supplement the use of <code class="codeph">XMLIndex</code>.
                  </p>
                  <p>Here is a summary decision tree, as the place to start when choosing ways to index <code class="codeph">XMLType</code> data stored as binary XML:<a id="fn_1" name="fn_1" href="#fn_1" onclick="footdisplay(1, "For XMLType data stored object-relationally, see Indexing XMLType Data Stored Object-Relationally. If your data is highly structured throughout, or your queries are not known at index creation time, then this approach might be appropriate.")"><sup>Foot&nbsp;1</sup></a></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-AEF30229-B377-4479-9627-45494B772392__GUID-D6731D26-8B56-4474-9147-5F746253ACC6">If your XML data contains islands of structured, predictable data, and your queries are known</p>
                     <p>Use <code class="codeph">XMLIndex</code> with a <span class="italic">structured component</span> to index the structured islands (even if the data surrounding these islands is unstructured). 
                     </p>
                     <p>A structured index component reflects the queries you use. You can change this set of known queries over time, provided you update the index definition accordingly. See <a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AEF30229-B377-4479-9627-45494B772392__GUID-C4CB89B7-2199-4945-91E1-C4803A41609B">If you need to query full-text content within your XML data</p>
                     <p>Use an <span class="italic">XML search index</span>. See <a href="indexes-for-XMLType-data.html#GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63" title="Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages within XML text nodes. To query such content within XML data, you can use XQuery Full Text (XQFT) or Oracle-specific full-text constructs.">Oracle Text Indexes for XML Data</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AEF30229-B377-4479-9627-45494B772392__GUID-8ADD5654-FA33-4C5C-B234-E8E364B4266C">If you need to support ad-hoc XML queries that involve predicates</p>
                     <p>Use <code class="codeph">XMLIndex</code> with an <span class="italic">unstructured component</span> &#x2013; see <a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Does your XML data contain <span class="italic">islands of data that is highly structured and predictable</span> (even if the surrounding data might be unstructured)?
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Yes. Use <code class="codeph">XMLIndex</code> with a structured component to index the islands. See "XMLIndex Structured Component" on page&nbsp;612.
                           </p>
                        </li>
                        <li>
                           <p>No. Do you need to <span class="italic">query full-text content </span>within your XML data?
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Yes. Use an XML search index. See "Oracle Text Indexes for XML Data" on page&nbsp;65.</p>
                              </li>
                              <li>
                                 <p>No. Do you need to support <span class="italic">ad-hoc XML queries that involve predicates</span>? If so, use XMLIndex with an unstructured component &#x2013; see "XMLIndex Unstructured Component" on page&nbsp;616. If not, do not bother to index your XML data.
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0">XMLIndex Addresses the Fine-Grained Structure of XML Data</a><br>You can create indexes on one or more relational columns, or on a functional expression. XML data, however, has its own, fine-grained structure, which is not necessarily reflected in the structure of the database tables used to store it. For this reason, effectively indexing XML data can be a bit different from indexing most database data.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63">Oracle Text Indexes for XML Data</a><br>Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages within XML text nodes. To query such content within XML data, you can use XQuery Full Text (XQFT) or Oracle-specific full-text constructs.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462">Optimization Chooses the Right Indexes to Use</a><br>Which indexes are used when more than one might apply in a given case? Cost-based optimization determines the index or indexes to use, so that performance is maximized. 
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1">Function-Based Indexes Are Deprecated for XMLType</a><br>In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with <code class="codeph">XMLType</code> data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of <code class="codeph">XMLIndex</code> instead. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5816"></a><div class="props_rev_3"><a id="GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0" name="GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0"></a><h4 id="ADXDB-GUID-9AD9EB86-8877-4349-A6ED-69B779783AE0" class="sect4"><span class="enumeration_section">6.2.1 </span>XMLIndex Addresses the Fine-Grained Structure of XML Data
                  </h4>
                  <div>
                     <p>You can create indexes on one or more relational columns, or on a functional expression. XML data, however, has its own, fine-grained structure, which is not necessarily reflected in the structure of the database tables used to store it. For this reason, effectively indexing XML data can be a bit different from indexing most database data.</p>
                     <p>For object-relational <code class="codeph">XMLType</code> storage, XML objects such as elements and attributes correspond to object-relational columns and tables. Creating <span class="italic">B-tree indexes</span> on those columns and tables thus provides an excellent way to effectively index the corresponding XML objects. Here, the storage model directly reflects the fine-grained structure of the XML data, so there is no special problem for indexing structured XML data. See <a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>.
                     </p>
                     <p>In object-relational <code class="codeph">XMLType</code> storage, an XML document is broken up and stored object-relationally, but you can choose to store one or more of its XML fragments as embedded <code class="codeph">CLOB</code> instances. A typical use case for this is mapping an XML-schema <code class="codeph">complexType</code> or a complex element to <code class="codeph">CLOB</code> storage, because you generally access the entire fragment as a unit.
                     </p>
                     <p>But such an embedded <code class="codeph">CLOB</code> fragment also acts as an opaque unit when it comes to indexing; its parts are not indexed individually.
                     </p>
                     <p>Similarly, standard indexing is not helpful for binary XML storage. In both of these cases, indexing a database column using the standard sorts of index (B-tree, bitmap) is generally not helpful for accessing particular parts of an XML document.</p>
                     <p><span class="italic"><code class="codeph">XMLIndex</code></span> provides a general, XML-specific index that indexes the internal structure of XML data. One of its main purposes is to overcome the indexing limitation presented by binary XML storage.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>An <code class="codeph">XMLIndex</code> index with an <span class="italic">unstructured component</span> indexes the XML <span class="italic">tags</span> of your document and identifies document fragments based on XPath expressions that target them. It can also index scalar node <span class="italic">values</span>, to provide quick lookup based on individual values or ranges of values. It also records document <span class="italic">hierarchy</span> information for each node it indexes: relations parent&#x2013;child, ancestor&#x2013;descendant, and sibling. This index component is particularly useful for queries that extract XML fragments from documents that have little or variable structure.
                           </p>
                        </li>
                        <li>
                           <p>An <code class="codeph">XMLIndex</code> index with a <span class="italic">structured component</span> indexes highly structured and predictable parts of XML data that is nevertheless for the most part unstructured. This index component is particularly useful for queries that project and use such islands of structured content.
                           </p>
                        </li>
                     </ul>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5817"></a><div class="props_rev_3"><a id="GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63" name="GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63"></a><h4 id="ADXDB-GUID-08972B6C-A1E1-4458-A6EF-754BCDCB3F63" class="sect4"><span class="enumeration_section">6.2.2 </span>Oracle Text Indexes for XML Data
                  </h4>
                  <div>
                     <p>Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages within XML text nodes. To query such content within XML data, you can use XQuery Full Text (XQFT) or Oracle-specific full-text constructs.</p>
                     <p>In either case, you create an appropriate Oracle Text (full-text) index. In the case of XQFT, the index is an XML search index, which is designed specifically for use with <code class="codeph">XMLType</code> data stored as binary XML.
                     </p>
                     <p>Full-text indexing is particularly useful for <span class="italic">document-centric</span> applications, which often contain a mix of XML elements and text-node content. Full-text searching can often be made more powerful, more focused, by combining it with structural XML searching, that is, by restricting it to certain parts of an XML document, which are identified by using XPath expressions.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4319"></a><div class="props_rev_3"><a id="GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462" name="GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462"></a><h4 id="ADXDB-GUID-3C109433-1FDA-4A55-8196-CD11FDFCE462" class="sect4"><span class="enumeration_section">6.2.3 </span>Optimization Chooses the Right Indexes to Use
                  </h4>
                  <div>
                     <p>Which indexes are used when more than one might apply in a given case? Cost-based optimization determines the index or indexes to use, so that performance is maximized. </p>
                     <p>Oracle Text indexes apply only to text, which for XML data means text nodes. Whenever text nodes are targeted and a corresponding Oracle Text index is defined, it is used. If other indexes are also appropriate in a particular context, then they can be used as well. However, just because an index is defined and it might appear applicable in a given situation does not mean that it will be used. It will not be used if the cost-based optimizer deems that its use is not cost-effective.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4315"></a><div class="props_rev_3"><a id="GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" name="GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1"></a><h4 id="ADXDB-GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" class="sect4"><span class="enumeration_section">6.2.4 </span>Function-Based Indexes Are Deprecated for XMLType
                  </h4>
                  <div>
                     <p>In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with <code class="codeph">XMLType</code> data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of <code class="codeph">XMLIndex</code> instead. 
                     </p>
                     <p>Doing so obviates the overhead associated with maintenance operations on function-based indexes, and it increases the number of situations in which the optimizer can correctly select the index. No changes to existing DML statements are required as a result of this.</p>
                     <p>It continues to be the case that, for object-relational storage of <code class="codeph">XMLType</code>, defining an index for (deprecated) Oracle SQL function <code class="codeph">extractValue</code> often leads, by XPath rewrite, to automatic creation of B-tree indexes on the underlying objects (instead of a function-based index on <code class="codeph">extractValue</code>). The XPath target here must be a <span class="italic">singleton</span> element or attribute. A similar shortcut exists for <code class="codeph">XMLCast</code> applied to <code class="codeph">XMLQuery</code>. 
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-AEF30229-B377-4479-9627-45494B772392" title="Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.">Overview of Indexing XMLType Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4332"></a><div class="props_rev_3"><a id="GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" name="GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46"></a><h3 id="ADXDB-GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46" class="sect3"><span class="enumeration_section">6.3 </span>XMLIndex
               </h3>
               <div></div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7">Advantages of XMLIndex</a><br>B-tree indexes can be used advantageously with object-relational <code class="codeph">XMLType</code> storagethey provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of <code class="codeph">XMLIndex</code>.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9">Structured and Unstructured XMLIndex Components</a><br><code class="codeph">XMLIndex</code> is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to <code class="codeph">XMLType</code> data that is stored as binary XML.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB">XMLIndex Structured Component</a><br>You create and use the structured component of an <code class="codeph">XMLIndex</code> index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C">XMLIndex Unstructured Component</a><br>Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the <code class="codeph">XMLIndex</code> structured component, which applies to specific, structured document parts, the unstructured component of an <code class="codeph">XMLIndex</code> index is, by default, very general. 
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992">Creating, Dropping, Altering, and Examining an XMLIndex Index</a><br>Basic operations on an <code class="codeph">XMLIndex</code> index include creating it, dropping it, altering it, and examining it. Examples are presented.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246">Using XMLIndex with an Unstructured Component</a><br>You can perform various operations on an <code class="codeph">XMLIndex</code> index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9">Use of XMLIndex with a Structured Component</a><br>An <code class="codeph">XMLIndex</code> structured component indexes specific islands of structure in your XML data.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52">How to Tell Whether XMLIndex is Used</a><br>To know whether a particular <code class="codeph">XMLIndex</code> index has been used in resolving a query, you can examine an execution plan for the query. 
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-572DB598-0A31-4143-889B-98D883211FC6">Turning Off Use of XMLIndex</a><br>You can turn off the use of <code class="codeph">XMLIndex</code> by using optimizer hint: <code class="codeph">/*+ NO_XML_QUERY_REWRITE */</code> or optimizer hint <code class="codeph">/*+ NO_XMLINDEX_REWRITE */</code>.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a><br> If you know which XPath expressions you are most likely to query then you can narrow the focus of <code class="codeph">XMLIndex</code> indexing and thus improve performance.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF">Guidelines for Using XMLIndex with an Unstructured Component</a><br>There are several guidelines that can help you use <code class="codeph">XMLIndex</code> with an unstructured component.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821">Guidelines for Using XMLIndex with a Structured Component</a><br>There are several guidelines that can help you use <code class="codeph">XMLIndex</code> with a structured component.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652">XMLIndex Partitioning and Parallelism</a><br>If you partition an <code class="codeph">XMLType</code> table, or a table with an <code class="codeph">XMLType</code> column, using range, list, or hash partitioning, you can also create an <code class="codeph">XMLIndex</code> index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a><br>You can defer the cost of maintaining an <code class="codeph">XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a><br>The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects. 
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-486E91AE-9FE0-489A-A035-AF320D04350B">Data Dictionary Static Public Views Related to XMLIndex</a><br>Information about the standard database indexes is available in static public views <code class="codeph">USER_INDEXES</code>, <code class="codeph">ALL_INDEXES</code>, and <code class="codeph">DBA_INDEXES</code>. Similar information about <code class="codeph">XMLIndex</code> indexes is available in static public views <code class="codeph">USER_XML_INDEXES</code>, <code class="codeph">ALL_XML_INDEXES</code>, and <code class="codeph">DBA_XML_INDEXES</code>.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a><br>Creation or modification of an <code class="codeph">XMLIndex</code> index often involves the use of a <code class="codeph">PARAMETERS</code> clause with SQL statement <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code>. You can use it to specify index characteristics in detail.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4333"></a><div class="props_rev_3"><a id="GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" name="GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7"></a><h4 id="ADXDB-GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" class="sect4"><span class="enumeration_section">6.3.1 </span>Advantages of XMLIndex
                  </h4>
                  <div>
                     <p>B-tree indexes can be used advantageously with object-relational <code class="codeph">XMLType</code> storagethey provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of <code class="codeph">XMLIndex</code>.
                     </p>
                     <p><code class="codeph">XMLIndex</code> is a <span class="italic">domain</span> index; it is designed specifically for the domain of XML data. It is a <span class="italic">logical</span> index. An <code class="codeph">XMLIndex</code> index can be used for SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>. 
                     </p>
                     <p>XMLIndex presents the following advantages over other indexing methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>An <code class="codeph">XMLIndex</code> index is effective in any part of a query; it is not limited to use in a <code class="codeph">WHERE</code> clause. This is not the case for any of the other kinds of indexes you might use with XML data.
                           </p>
                        </li>
                        <li>
                           <p>An <code class="codeph">XMLIndex</code> index with an unstructured component can speed access to both <code class="codeph">SELECT</code> list data and <code class="codeph">FROM</code> list data, making it useful for XML <span class="italic">fragment</span> extraction, in particular. Function-based indexes, which are deprecated, cannot be used to extract document fragments.
                           </p>
                        </li>
                        <li>
                           <p>You can use an <code class="codeph">XMLIndex</code> index with either XML schema-based or non-schema-based XMLType data stored as binary XML. B-tree indexing is appropriate only for XML schema-based data that is stored object-relationally.
                           </p>
                        </li>
                        <li>
                           <p>You can use an <code class="codeph">XMLIndex</code> index for searches with XPath expressions that target <span class="italic">collections</span>, that is, nodes that occur multiple times within a document. This is not the case for function-based indexes.
                           </p>
                        </li>
                        <li>
                           <p>You need no prior knowledge of the XPath expressions that might be used in queries. The unstructured component of an <code class="codeph">XMLIndex</code> index can be completely general. This is not the case for function-based indexes.
                           </p>
                        </li>
                        <li>
                           <p>If you have prior knowledge of the XPath expressions to be used in queries, then you can improve performance either by using a <span class="italic">structured</span> <code class="codeph">XMLIndex</code> component that targets fixed, structured islands of data that are queried often.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">XMLIndex</code> indexingboth index creation and index maintenancecan be carried out in parallel, using multiple database processes. This is not the case for function-based indexes, which are deprecated.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4337"></a><a id="ADXDB4336"></a><div class="props_rev_3"><a id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" name="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9"></a><h4 id="ADXDB-GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" class="sect4"><span class="enumeration_section">6.3.2 </span>Structured and Unstructured XMLIndex Components
                  </h4>
                  <div>
                     <p><code class="codeph">XMLIndex</code> is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to <code class="codeph">XMLType</code> data that is stored as binary XML.
                     </p>
                     <p>Semi-structured XML data can sometimes nevertheless contain islands of predictable, structured data. An <code class="codeph">XMLIndex</code> index can therefore have two components: a <strong class="term">structured component</strong>, used to index such islands, and an <strong class="term">unstructured component</strong>, used to index data that has little or variable structure. 
                     </p>
                     <p>A structured component can help with queries that project and use islands of structured content. A typical example is a free-form specification with fixed fields author, date, and title. An unstructured component can help with queries that extract XML fragments. Either component can be omitted from a given <code class="codeph">XMLIndex</code> index.
                     </p>
                     <p>Unlike a structured component, an unstructured component is general and relatively untargeted. It is appropriate for general indexing of document-centric XML data. A typical example is an XML web document or a book chapter.</p>
                     <p>You can create an <code class="codeph">XMLIndex</code> index with both structured and unstructured components. A typical use case is supporting queries that extract an XML fragment from a document whenever some structured data is also present. The unstructured component is used for the fragment extraction. The structured component is used for a query predicate that checks for the structured data (for example, in the SQL <code class="codeph">WHERE</code> clause).
                     </p>
                     <p>Though you can restrict an unstructured component to apply only to certain XPath subsets, its path table indexes node content that can be of different scalar types, which can require you to create multiple secondary indexes on the <code class="codeph">VALUE</code> column to deal with the different data typessee <a href="indexes-for-XMLType-data.html#GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149" title="Even if you do not specify a secondary index for column VALUE when you create an XMLIndex index, a default secondary index is created on column VALUE. This default index has the default propertiesin particular, it is an index for text (string-valued) data only.">Secondary Indexes on Column VALUE</a>. Using an unstructured component alone can also lead to inefficiencies involving multiple probes and self-joins of its path table, for queries that project structured islands.
                     </p>
                     <p>On the other hand, a structured component is not suited for queries that involve little structure or queries that extract XML fragments. Use a structured component to index structured islands of data; use an unstructured component to index data that has little structure.</p>
                     <p>The last row indicates the applicability of <code class="codeph">XMLIndex</code> for different XML data use cases. It shows that <code class="codeph">XMLIndex</code> is appropriate for semi-structured XML data, however it is stored (last three columns). And an <code class="codeph">XMLIndex</code> index with a structured component is useful for document-centric data that contains structured islands (fourth column).
                     </p>
                     <div class="figure" id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9__GUID-E0FC24F4-FE6D-4B58-B641-C34BB1FA25FA">
                        <p class="titleinfigure">Figure 6-1 XML Use Cases and XML Indexing</p><img src="img/adxdb057.png" width="584" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows" longdesc="img_text/adxdb057.html"><br><a href="img_text/adxdb057.html">Description of "Figure 6-1 XML Use Cases and XML Indexing"</a></div>
                     <!-- class="figure" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9__GUID-ED6C9B32-3B30-4707-B35A-7D0AAE4379D7">
                        <p class="notep1">See Also:</p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-9E42982A-CDBB-40BC-86A9-04AAEF9869D7" title="B-tree indexes can be used advantageously with object-relational XMLType storagethey provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML. That is the special domain of XMLIndex.">Advantages of XMLIndex</a> for a summary of the advantages provided by each <code class="codeph">XMLIndex</code> component type
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4338"></a><div class="props_rev_3"><a id="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" name="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB"></a><h4 id="ADXDB-GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" class="sect4"><span class="enumeration_section">6.3.3 </span>XMLIndex Structured Component
                  </h4>
                  <div>
                     <p>You create and use the structured component of an <code class="codeph">XMLIndex</code> index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.
                     </p>
                     <p>A structured <code class="codeph">XMLIndex</code> component organizes such islands in a <span class="italic">relational</span> format. In this it is similar to SQL/XML <span class="italic">function</span> <code class="codeph">XMLTable</code>, and the syntax you use to define the structured component reflects this similarity. The relational tables used to store the indexing data are data-type aware, and each column can be of a different scalar data type.
                     </p>
                     <p>You can thus think of the act of creating the structured component of an <code class="codeph">XMLIndex</code> index as <span class="italic">decomposing</span> a structured portion of your XML data into relational format. This differs from the object-relational storage model of <code class="codeph">XMLType</code> in these ways:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A structured index component <span class="italic">explicitly</span> decomposes particular <span class="italic">portions</span> of your data, which you specifyportions that you commonly query. Object-relational <code class="codeph">XMLType</code> storage involves automatic decomposition of an entire <code class="codeph">XMLType</code> table or column.
                           </p>
                        </li>
                        <li>
                           <p>The structured component of an <code class="codeph">XMLIndex</code> index applies to both XML schema-based and non-schema-based data. Object-relational <code class="codeph">XMLType</code> storage applies only to data that is based on an XML schema.
                           </p>
                        </li>
                        <li>
                           <p>The decomposed data for a structured <code class="codeph">XMLIndex</code> component is stored in addition to the <code class="codeph">XMLType</code> data, as an index, rather than being the storage model for the <code class="codeph">XMLType</code> data itself.
                           </p>
                        </li>
                        <li>
                           <p>For a structured <code class="codeph">XMLIndex</code> component, the same data can be projected multiple times, as columns of different data type.
                           </p>
                        </li>
                     </ul>
                     <p>The index content tables used for the structured component of an <code class="codeph">XMLIndex</code> index are part of the index, but because they are normal relational tables you can, in turn, <span class="italic">index</span> them using any standard relational indexes, including indexes that satisfy primary-key and foreign-key constraints. You can also index them using domain indexes, such as an Oracle Text <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>Another way to look at the structured component of an <code class="codeph">XMLIndex</code> index sees that it acts as a <span class="italic">generalized function-based index</span>. A function-based index is similar to a structured <code class="codeph">XMLIndex</code> component that has only one relational column.
                     </p>
                     <p>If you find that for a particular application you are creating multiple function-based indexes, then consider using an <code class="codeph">XMLIndex</code> index with a structured component instead. Create also B-tree indexes on the columns of the structured index component. 
                     </p>
                     <div class="infoboxnote" id="GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB__GUID-A6499653-7B31-4560-9163-BB8CA6299F98">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Queries that use SQL/XML function <code class="codeph">XMLTable</code> can typically be automatically rewritten to use the relational indexing tables of an <code class="codeph">XMLIndex</code> structured component. In particular, SQL <code class="codeph">ORDER BY</code>, <code class="codeph">GROUP BY</code>, and window constructs operating on columns of an <code class="codeph">XMLTable</code> virtual table are rewritten to the same constructs operating on the real columns of the relational indexing tables of the structured <code class="codeph">XMLIndex</code> component.
                              </p>
                              <p>The relational tables used for <code class="codeph">XMLIndex</code> structured indexing also contain some internal, system-defined columns. These internal columns might change in the future, so do not write code that depends on any assumptions about their existence or contents.
                              </p>
                           </li>
                           <li>
                              <p>Queries that use Oracle SQL function <code class="codeph">XMLSequence</code> within a SQL <code class="codeph">TABLE</code> collection expression, that is, <code class="codeph">TABLE (XMLSequence(...))</code>, are <span class="italic">not</span> rewritten to use the indexing tables of an <code class="codeph">XMLIndex</code> structured component. Oracle SQL function <code class="codeph">XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11g Release 2; use standard SQL/XML function <code class="codeph">XMLTable</code> instead.
                              </p>
                              <p>See <a href="../sqlrf/SELECT.html#SQLRF30047" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about the SQL <code class="codeph">TABLE</code> collection expression.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65">Ignore the Index Content Tables; They Are Transparent</a><br>Although the index content tables of an <code class="codeph">XMLIndex</code> structured component are normal relational tables, they are also <span class="italic">read-only</span>: you cannot add or drop their columns or modify (insert, update, or delete) their rows. 
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254">Data Type Considerations for XMLIndex Structured Component</a><br>The relational tables that are used for an <code class="codeph">XMLIndex</code> structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11">Exchange Partitioning and XMLIndex</a><br>In exchange partitioning, you exchange a table with a partition of another table. The first table must have the same structure as the partition of the second table, with which it is to be exchanged. The two tables must also be similar with respect to indexing with an <code class="codeph">XMLIndex</code> index.
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></li>
                           <li><a href="xquery-and-XML-DB.html#GUID-4805CF1C-A00D-4B88-AF2E-00A9DB6F3392" title="SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages.">SQL/XML Functions XMLQUERY, XMLTABLE, XMLExists, and XMLCast</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4339"></a><div class="props_rev_3"><a id="GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65" name="GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65"></a><h5 id="ADXDB-GUID-74E9F37F-4593-4EC1-85B4-5516CF95FD65" class="sect5"><span class="enumeration_section">6.3.3.1 </span>Ignore the Index Content Tables; They Are Transparent
                     </h5>
                     <div>
                        <p>Although the index content tables of an <code class="codeph">XMLIndex</code> structured component are normal relational tables, they are also <span class="italic">read-only</span>: you cannot add or drop their columns or modify (insert, update, or delete) their rows. 
                        </p>
                        <p>You can thus generally ignore the relational index content tables. You cannot access them, other than to <code class="codeph">DESCRIBE</code> them and create (secondary) indexes on them. You need never explicitly gather statistics on them. You need only collect statistics on the <code class="codeph">XMLIndex</code> index itself or the base table on which the <code class="codeph">XMLIndex</code> index is defined; statistics are collected and maintained on the index content tables transparently.
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4341"></a><a id="ADXDB4342"></a><a id="ADXDB4343"></a><a id="ADXDB4340"></a><div class="props_rev_3"><a id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" name="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254"></a><h5 id="ADXDB-GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" class="sect5"><span class="enumeration_section">6.3.3.2 </span>Data Type Considerations for XMLIndex Structured Component
                     </h5>
                     <div>
                        <p>The relational tables that are used for an <code class="codeph">XMLIndex</code> structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).
                        </p>
                        <p>XQuery typing rules can automatically change the data type of a subexpression, to ensure coherence and type-checking. For example, if a document that is queried using XPath expression <code class="codeph">/PurchaseOrder/LineItem[@ItemNumber = 25]</code> is not XML schema-based, then the subexpression <code class="codeph">@ItemNumber</code> is untyped, and it is then automatically cast to <code class="codeph">xs:double</code> by the XQuery <code class="codeph">=</code> comparison operator. To index this data using an <code class="codeph">XMLIndex</code> structured component you must use <code class="codeph">BINARY_DOUBLE</code> as the SQL data type.
                        </p>
                        <p>This is a general rule. For an <code class="codeph">XMLIndex</code> index with structured component to apply to a query, the data types must correspond. <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH" title="This table shows the XML and SQL data type correspondence for XMLIndex.">Table 6-5</a> shows the data-type correspondences.
                        </p>
                        <div class="tblformal" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH">
                           <p class="titleintable">Table 6-5 XML and SQL Data Type Correspondence for XMLIndex</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="XML and SQL Data Type Correspondence for XMLIndex" summary="This table shows the XML and SQL data type correspondence for XMLIndex." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d34642e2257">XML Data Type</th>
                                    <th align="left" valign="bottom" width="50%" id="d34642e2260">SQL Data Type</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2265" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:decimal</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2265 d34642e2260 ">
                                       <p><code class="codeph">INTEGER</code> or <code class="codeph">NUMBER</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2277" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:double</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2277 d34642e2260 ">
                                       <p><code class="codeph">BINARY_DOUBLE</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2286" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:float</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2286 d34642e2260 ">
                                       <p><code class="codeph">BINARY_FLOAT</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2295" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:date</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2295 d34642e2260 ">
                                       <p><code class="codeph">DATE</code>, <code class="codeph">TIMESTAMP WITH TIMEZONE</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2307" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:dateTime</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2307 d34642e2260 ">
                                       <p><code class="codeph">TIMESTAMP</code>, <code class="codeph">TIMESTAMP WITH TIMEZONE</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2319" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:dayTimeDuration</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2319 d34642e2260 ">
                                       <p><code class="codeph">INTERVAL DAY TO SECOND</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e2328" headers="d34642e2257 ">
                                       <p><code class="codeph">xs:yearMonthDuration</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e2328 d34642e2260 ">
                                       <p><code class="codeph">INTERVAL YEAR TO MONTH</code> 
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnote" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__GUID-AEACAF8C-2578-483E-80BE-C8C5B1593678">
                           <p class="notep1">Note:</p>
                           <p>If the XML data type is <code class="codeph">xs:date</code> or <code class="codeph">xs:dateTime</code>, and if you know that the data that you will query and for which you are creating an index will <span class="italic">not</span> contain a time-zone component, then you can increase performance by using SQL data type <code class="codeph">DATE</code> or <code class="codeph">TIMESTAMP</code>. If the data might contain a time-zone component, then you must use SQL data type <code class="codeph">TIMESTAMP WITH TIMEZONE</code>.
                           </p>
                        </div>
                        <p>If the XML and SQL data types involved do not have a built-in one-to-one correspondence, then you must make them correspond (according to <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGFIFFH" title="This table shows the XML and SQL data type correspondence for XMLIndex.">Table 6-5</a>), in order for the index to be picked up for your query. There are two ways you can do this:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Make the index correspond to the query &#x2013;</span> Define (or redefine) the column in the structured index component, so that it corresponds to the XML data type. For example, if a query that you want to index uses the XML data type <code class="codeph">xs:double</code>, then define the index to use the corresponding SQL data type, <code class="codeph">BINARY_DOUBLE</code>.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Make the query correspond to the index &#x2013;</span> In your query, explicitly cast the relevant parts of an XQuery expression to data types that correspond to the SQL data types used in the index content table.
                              </p>
                           </li>
                        </ul>
                        <p><a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a> and <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a> show how you can cast an XQuery expression in your query to match the SQL data type used in the index content table.
                        </p>
                        <p>Notice that the number <code class="codeph">25</code> plays a different role in these two examples, even though in both cases it is the purchase-order item number. In <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a>, <code class="codeph">25</code> is a SQL number of data type <code class="codeph">INTEGER</code>; in <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a>, <code class="codeph">25</code> is an XQuery number of data type <code class="codeph">xs:decimal</code>. 
                        </p>
                        <p>In <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">Example 6-1</a>, the <code class="codeph">XMLQuery</code> result is cast to SQL type <code class="codeph">INTEGER</code>, which is compared with the SQL value 25. In <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">Example 6-2</a>, the value of attribute <code class="codeph">ItemNumber</code> is cast (in XQuery) to the XML data type <code class="codeph">xs:decimal</code>, which is compared with the XQuery value 25 and which corresponds to the SQL data type (<code class="codeph">INTEGER</code>) used for the index. There are thus two different kinds of data-type conversion in these examples, but they both convert query data to make it type-compatible with the index content table.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__GUID-D1F567CA-D4DF-4004-A406-D522210CFE7A">
                           <p class="notep1">See Also:</p>
                           <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="You use PL/SQL package DBMS_XMLSCHEMA to map data types for XML Schema attributes and elements to SQL data types.">Use DBMS_XMLSCHEMA to Map XML Schema Data Types to SQL Data Types</a> for information about the built-in correspondence between XML Schema data types and SQL data types
                           </p>
                        </div>
                        <div class="example" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGBBEIB">
                           <p class="titleinexample">Example 6-1 Making Query Data Compatible with Index Data &#x2013; SQL Cast</p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE <span class="bold">XMLCast</span>(XMLQuery('$p/PurchaseOrder/LineItem/@ItemNumber'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                <span class="bold">AS INTEGER</span>)
        = 25;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254__BCGIIDAA">
                           <p class="titleinexample">Example 6-2 Making Query Data Compatible with Index Data &#x2013; XQuery Cast</p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItem[<span class="bold">xs:decimal</span>(@ItemNumber) = 25]'
                  PASSING OBJECT_VALUE AS "p");
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6236"></a><a id="ADXDB6235"></a><div class="props_rev_3"><a id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11" name="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11"></a><h5 id="ADXDB-GUID-44226DE7-B9EB-4729-9989-F957D65BEE11" class="sect5"><span class="enumeration_section">6.3.3.3 </span>Exchange Partitioning and XMLIndex
                     </h5>
                     <div>
                        <p>In exchange partitioning, you exchange a table with a partition of another table. The first table must have the same structure as the partition of the second table, with which it is to be exchanged. The two tables must also be similar with respect to indexing with an <code class="codeph">XMLIndex</code> index.
                        </p>
                        <p>One of the following must be true:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Neither table has an <code class="codeph">XMLIndex</code> index.
                              </p>
                           </li>
                           <li>
                              <p>Both have an <code class="codeph">XMLIndex</code> index, and one of the following is true:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Neither index has a structured component.</p>
                                 </li>
                                 <li>
                                    <p>Both indexes have a structured component.</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>If none of those conditions holds then you <span class="italic">cannot</span> perform exchange partitioning.
                        </p>
                        <p>If both tables have an <code class="codeph">XMLIndex</code> index with a structured component then in the general case you must perform some preprocessing before invoking <code class="codeph">ALTER TABLE EXCHANGE PARTITION</code>, and you must perform some postprocessing after invoking it. Otherwise, the exchange-partition operation raises an error.
                        </p>
                        <p>You use PL/SQL procedures <span class="bold"><code class="codeph">exchangePreProc</code></span> and <span class="bold"><code class="codeph">exchangePostProc</code></span> in package <code class="codeph">DBMS_XMLSTORAGE_MANAGE</code> to perform this preprocessing and postprocessing, as illustrated in <a href="indexes-for-XMLType-data.html#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__CEGCBJIA">Example 6-3</a>. Each of the <code class="codeph">XMLType</code> tables there, <code class="codeph">table</code> and <code class="codeph">exchange_table</code>, has an <code class="codeph">XMLIndex</code> index that has a structured component.
                        </p>
                        <p>In the special case of <span class="italic">reference</span>-partitioned tables there are foreign-key constraints involved, so things are a bit more complex. In this case, you use PL/SQL procedure <span class="bold"><code class="codeph">refPartitionExchangeIn</code></span> or <span class="bold"><code class="codeph">refPartitionExchangeOut</code></span>, to load data into (exchange-in) or out of (exchange-out) the partitioned tables, respectively. 
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__EXCHANGE-PARTITIONINGREFERENCE-PART-2E0AB5D7">Example 6-4</a> illustrates this, loading data from exchange tables <code class="codeph">parent_ex</code> and <code class="codeph">child_ex</code> into base tables <code class="codeph">parent</code> and <code class="codeph">child</code>. <a href="indexes-for-XMLType-data.html#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__DATAUSEDINEXCHANGE-PARTITIONINGFORR-2E0AB9D1">Example 6-5</a> shows the table and index definitions.
                        </p>
                        <div class="infoboxnotealso" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__GUID-4A0F5F27-7CB6-4BDE-8979-1E74545280D8">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF53492" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ADDCI4492" target="_blank"><span><cite>Oracle Database Data Cartridge Developer's Guide</cite></span></a> for general information about using <code class="codeph">ALTER TABLE EXCHANGE PARTITION</code> with tables that have domain indexes (<code class="codeph">XMLIndex</code> is a domain index)
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_XMLSTORAGE_MANAGE.html#ARPLS-GUID-3E8838A7-1B14-4388-A588-DAEE9C5CD469" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information about procedures <code class="codeph">exchangePreProc</code>, <code class="codeph">exchangePostProc</code>, <code class="codeph">refPartitionExchangeIn</code>, and <code class="codeph">refPartitionExchangeIOut</code> in package <code class="codeph">DBMS_XMLSTORAGE_MANAGE</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="example" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__CEGCBJIA">
                           <p class="titleinexample">Example 6-3 Exchange-Partitioning Tables That Have an XMLIndex Structured Component</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_XMLSTORAGE_MANAGE.exchangePreProc(USER, 'table');
EXEC DBMS_XMLSTORAGE_MANAGE.exchangePreProc(USER, 'exchange_table');

ALTER TABLE table EXCHANGE PARTITION partition WITH TABLE exchange_table
  WITH VALIDATION UPDATE INDEXES;

EXEC DBMS_XMLSTORAGE_MANAGE.exchangePostProc(USER, 'table');
EXEC DBMS_XMLSTORAGE_MANAGE.exchangePostProc(USER, 'exchange_table');</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__EXCHANGE-PARTITIONINGREFERENCE-PART-2E0AB5D7">
                           <p class="titleinexample">Example 6-4 Exchange-Partitioning Reference-Partitioned Tables That Use XMLIndex</p>
                           <p>In this example:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="bold"><code class="codeph">parent</code></span> is the partitioned base table.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">child</code></span> is a <span class="italic">reference</span>-partitioned child table with <code class="codeph">XMLType</code> column <code class="codeph">xcol</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">child_xidx</code></span> is an <code class="codeph">XMLIndex</code> index with a structured component, defined on column <code class="codeph">xcol</code> of table <code class="codeph">child</code>. This is a local index, which is partitioned.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">parent_ex</code></span> is the exchange table for base table <code class="codeph">parent</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">child_ex</code></span> is the exchange table for child table <code class="codeph">child</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">child_xidx_ex</code></span> is an <code class="codeph">XMLIndex</code> index with a structured component, defined on column <code class="codeph">xcol</code> of table <code class="codeph">child_ex</code>. This is <span class="italic">not</span> a local index (unlike the case for index <code class="codeph">child_xidx</code>).
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold"><code class="codeph">USER</code></span> is the owner (database schema) of the tables.
                                 </p>
                              </li>
                           </ul>
                           <p>This example performs an exchange-in operation, loading data from the exchange tables into the partitioned tables. An exchange-out operations, which loads data out of the partitioned tables into the exchange tables, would look the same, except that it would use procedure <code class="codeph">refPartitionExchangeOut</code> instead. The procedure is passed the relevant tables and the necessary <code class="codeph">ALTER TABLE</code> ... <code class="codeph">EXCHANGE</code> statements.
                           </p><pre class="pre codeblock"><code>EXEC DBMS_XMLSTORAGE_MANAGE.<span class="bold">refPartitionExchangeIn</span>(
       USER, 'parent', 'child', 'parent_ex', 'child_ex',
       'ALTER TABLE <span class="bold">parent</span> EXCHANGE PARTITION part_all WITH TABLE <span class="bold">parent_ex</span>
          INCLUDING INDEXES WITH VALIDATION UPDATE INDEXES',
       'ALTER TABLE <span class="bold">child</span>  EXCHANGE PARTITION part_all WITH TABLE <span class="bold">child_ex</span>
          INCLUDING INDEXES WITH VALIDATION UPDATE INDEXES');</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__DATAUSEDINEXCHANGE-PARTITIONINGFORR-2E0AB9D1">
                           <p class="titleinexample">Example 6-5 Data Used in Example of Exchange-Partitioning for Reference-Partitioned Tables</p>
                           <p>This example shows the creation operations for the tables and indexes used in <a href="indexes-for-XMLType-data.html#GUID-44226DE7-B9EB-4729-9989-F957D65BEE11__EXCHANGE-PARTITIONINGREFERENCE-PART-2E0AB5D7">Example 6-4</a>.
                           </p><pre class="pre codeblock"><code>CREATE TABLE <span class="bold">parent</span> (id      NUMBER PRIMARY KEY,
                     created DATE)
  PARTITION BY RANGE (created)
    (PARTITION part_2014 VALUES LESS THAN (to_date('01-jan-2015', 'dd-mon-yyyy')),
     PARTITION part_all  VALUES LESS THAN (maxvalue));
</code></pre><pre class="pre codeblock"><code>CREATE TABLE <span class="bold">child</span> (parent_id NUMBER NOT NULL,
                    xcol      XMLType,
                    CONSTRAINT child_tab_fk FOREIGN KEY (parent_id)
                                            <span class="bold">REFERENCES</span> parent (id)
                    ENABLE VALIDATE)
  XMLType COLUMN xcol STORE AS BINARY XML <span class="bold">PARTITION BY REFERENCE</span> (child_tab_fk);
</code></pre><pre class="pre codeblock"><code>CREATE INDEX <span class="bold">child_xidx</span> ON child p (xcol) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_index_tab ''purchaseorder''
               COLUMNS pid NUMBER(4) PATH ''@id''') LOCAL ;</code></pre><pre class="pre codeblock"><code>CREATE TABLE <span class="bold">parent_ex</span> (id      NUMBER PRIMARY KEY,
                        created DATE);</code></pre><pre class="pre codeblock"><code>CREATE TABLE <span class="bold">child_ex</span> (parent_id NUMBER NOT NULL,
                       xcol      XMLType,
                       CONSTRAINT child_tab_fk1 FOREIGN KEY (parent_id)
                                                <span class="bold">REFERENCES</span> parent_ex(id)
                      ENABLE VALIDATE)
  XMLType COLUMN xcol STORE AS BINARY XML;</code></pre><pre class="pre codeblock"><code>CREATE INDEX <span class="bold">child_ex_xidx</span> ON child_ex p (xcol) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_index_tab_ex ''purchaseorder''
               COLUMNS pid NUMBER(4) PATH ''@id''');</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4345"></a><a id="ADXDB4346"></a><a id="ADXDB4344"></a><div class="props_rev_3"><a id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" name="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C"></a><h4 id="ADXDB-GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" class="sect4"><span class="enumeration_section">6.3.4 </span>XMLIndex Unstructured Component
                  </h4>
                  <div>
                     <p>Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the <code class="codeph">XMLIndex</code> structured component, which applies to specific, structured document parts, the unstructured component of an <code class="codeph">XMLIndex</code> index is, by default, very general. 
                     </p>
                     <p>Unless you specify a more narrow focus by detailing specific XPath expressions to use or not to use in indexing, an unstructured <code class="codeph">XMLIndex</code> component applies to <span class="italic">all possible XPath expressions</span> for your XML data. 
                     </p>
                     <p>The unstructured component of an <code class="codeph">XMLIndex</code> index has three logical parts:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A <strong class="term">path index</strong> &#x2013; This indexes the XML <span class="italic">tags</span> of a document and identifies its various document <span class="italic">fragments</span>.
                           </p>
                        </li>
                        <li>
                           <p>An <strong class="term">order index</strong> &#x2013; This indexes the hierarchical <span class="italic">positions</span> of the nodes in an XML document. It keeps track of parent&#x2013;child, ancestor&#x2013;descendant, and sibling relations.
                           </p>
                        </li>
                        <li>
                           <p>A <strong class="term">value index</strong> &#x2013; This indexes the <span class="italic">values</span> of an XML document. It provides lookup by either value equality or value range. A value index is used for values in query predicates (<code class="codeph">WHERE</code> clause).
                           </p>
                        </li>
                     </ul>
                     <p>The unstructured component of an <code class="codeph">XMLIndex</code> index uses a path table and a set of (local) secondary indexes on the path table, which implement the logical parts described above. Two secondary indexes are created automatically: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A <strong class="term">pikey index</strong>, which implements the logical indexes for both path and order.
                           </p>
                        </li>
                        <li>
                           <p>A real <strong class="term">value index</strong>, which implements the logical value index.
                           </p>
                        </li>
                     </ul>
                     <p>You can modify these two indexes or create additional secondary indexes. The path table and its secondary indexes are all owned by the owner of the base table upon which the <code class="codeph">XMLIndex</code> index is created.
                     </p>
                     <p>The pikey index handles paths and order relationships together, which gives the best performance in most cases. If you find in some particular case that the value index is not picked up when think it should be, you can replace the pikey index with separate indexes for the paths and order relationships. Such (optional) indexes are called <strong class="term">path id</strong> and <strong class="term">order key</strong> indexes, respectively. For best results, contact Oracle Support if you find that the pikey index is not sufficient for your needs in some case.
                     </p>
                     <p>The path table contains one row for each indexed node in the XML document. For each indexed node, the <strong class="term">path table</strong> stores:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The corresponding <span class="italic">rowid</span> of the table that stores the document.
                           </p>
                        </li>
                        <li>
                           <p>A <span class="italic">locator</span>, which provides fast access to the corresponding document fragment. For binary XML storage of XML schema-based data, it also stores data-type information.
                           </p>
                        </li>
                        <li>
                           <p>An <span class="italic">order key</span>, to record the hierarchical position of the node in the document. You can think of this as a Dewey decimal key like that used in library cataloging and Internet protocol SNMP. In such a system, the key <code class="codeph">3.21.5</code> represents the node position of the fifth child of the twenty-first child of the third child of the document root node.
                           </p>
                        </li>
                        <li>
                           <p>An identifier that represents an XPath <span class="italic">path</span> to the node.
                           </p>
                        </li>
                        <li>
                           <p>The effective <span class="italic">text value</span> of the node.
                           </p>
                        </li>
                     </ul>
                     <p><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDICGFB" title="This table shows the main information in the XMLIndex Path Table.">Table 6-6</a> shows the main information<a id="fn_2" name="fn_2" href="#fn_2" onclick="footdisplay(2, "The actual path table implementation may be slightly different.")"><sup>Foot&nbsp;2</sup></a> that is in the path table. 
                     </p>
                     <div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDICGFB">
                        <p class="titleintable">Table 6-6 XMLIndex Path Table</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="XMLIndex Path Table" summary="This table shows the main information in the XMLIndex Path Table." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d34642e3097">Column</th>
                                 <th align="left" valign="bottom" id="d34642e3100">Data Type</th>
                                 <th align="left" valign="bottom" id="d34642e3103">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e3108" headers="d34642e3097 ">
                                    <p><code class="codeph">PATHID</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3108 d34642e3100 ">
                                    <p><code class="codeph">RAW(8)</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3108 d34642e3103 ">
                                    <p>Unique identifier for the XPath path to the node. </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e3120" headers="d34642e3097 ">
                                    <p><code class="codeph">RID</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3120 d34642e3100 ">
                                    <p><code class="codeph">ROWID</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3120 d34642e3103 ">
                                    <p>Rowid of the table used to store the XML data.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e3132" headers="d34642e3097 ">
                                    <p><code class="codeph">ORDER_KEY</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3132 d34642e3100 ">
                                    <p><code class="codeph">RAW(1000)</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3132 d34642e3103 ">
                                    <p>Decimal order key that identifies the hierarchical position of the node. (Document ordering is preserved.)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e3144" headers="d34642e3097 ">
                                    <p><code class="codeph">LOCATOR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3144 d34642e3100 ">
                                    <p><code class="codeph">RAW(2000)</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3144 d34642e3103 ">
                                    <p>Fragment-location information. Used for fragment extraction. For binary XML storage of XML schema-based data, data-type information is also stored here.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e3156" headers="d34642e3097 ">
                                    <p><code class="codeph">VALUE</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3156 d34642e3100 ">
                                    <p><code class="codeph">VARCHAR2(4000)</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e3156 d34642e3103 ">
                                    <p>Effective text value the node. </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>The pikey index uses path table columns <code class="codeph">PATHID</code>, <code class="codeph">RID</code>, and <code class="codeph">ORDER_KEY</code> to represent the path and order indexes. An optional path id index uses columns <code class="codeph">PATHID</code> and <code class="codeph">RID</code> to represent the path index. A value index is an index on the <code class="codeph">VALUE</code> column.
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDJGGDH">Example 6-6</a> explores the contents of the path table for two purchase-order documents.
                     </p>
                     <div class="example" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__CHDJGGDH">
                        <p class="titleinexample">Example 6-6 Path Table Contents for Two Purchase Orders</p><pre class="pre codeblock"><code>&lt;PurchaseOrder&gt;
 &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;SVOLLMAN&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;

&lt;PurchaseOrder&gt;
 &lt;Reference&gt;ABEL-20021127121040897PST&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;ZLOTKEY&lt;/User&gt;
  &lt;/Action&gt;
  &lt;Action&gt;
   &lt;User&gt;KING&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;
</code></pre><p>An <code class="codeph">XMLIndex</code> index on an <code class="codeph">XMLType</code> table or column storing these purchase orders includes a path table that has one row for each indexed node in the XML documents. Suppose that the system assigns the following <code class="codeph">PATHID</code>s when indexing the nodes according to their XPath expressions:
                        </p>
                        <div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__GUID-698980B2-9DF1-4A47-8B38-0FD0A0DC7841">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="PATHIDs for sample XPath expressions" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d34642e3216">PATHID</th>
                                    <th align="left" valign="bottom" width="100%" id="d34642e3219">Indexed XPath</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d34642e3224" headers="d34642e3216 ">
                                       <p><code class="codeph">1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="100%" headers="d34642e3224 d34642e3219 ">
                                       <p><code class="codeph">/PurchaseOrder</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d34642e3233" headers="d34642e3216 ">
                                       <p><code class="codeph">2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="100%" headers="d34642e3233 d34642e3219 ">
                                       <p><code class="codeph">/PurchaseOrder/Reference</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d34642e3242" headers="d34642e3216 ">
                                       <p><code class="codeph">3</code></p>
                                    </td>
                                    <td align="left" valign="top" width="100%" headers="d34642e3242 d34642e3219 ">
                                       <p><code class="codeph">/PurchaseOrder/Actions</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d34642e3251" headers="d34642e3216 ">
                                       <p><code class="codeph">4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="100%" headers="d34642e3251 d34642e3219 ">
                                       <p><code class="codeph">/PurchaseOrder/Actions/Action</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d34642e3260" headers="d34642e3216 ">
                                       <p><code class="codeph">5</code></p>
                                    </td>
                                    <td align="left" valign="top" width="100%" headers="d34642e3260 d34642e3219 ">
                                       <p><code class="codeph">/PurchaseOrder/Actions/Action/User</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The resulting path table would then be something like this (column <code class="codeph">LOCATOR</code> is not shown):
                        </p>
                        <div class="tblformal" id="GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C__GUID-156D3508-DC4C-42AE-92BB-5EACB61027F6">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Path table corresponding to sample XPath expressions" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="12%" id="d34642e3283">PATHID</th>
                                    <th align="left" valign="bottom" width="7%" id="d34642e3286">RID</th>
                                    <th align="left" valign="bottom" width="19%" id="d34642e3289">ORDER_KEY</th>
                                    <th align="left" valign="bottom" width="62%" id="d34642e3292">VALUE</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3297" headers="d34642e3283 ">
                                       <p><code class="codeph">1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3297 d34642e3286 ">
                                       <p><code class="codeph">R1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3297 d34642e3289 ">
                                       <p><code class="codeph">1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3297 d34642e3292 ">
                                       <p><code class="codeph">SBELL-2002100912333601PDTSVOLLMAN</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3314" headers="d34642e3283 ">
                                       <p><code class="codeph">2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3314 d34642e3286 ">
                                       <p><code class="codeph">R1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3314 d34642e3289 ">
                                       <p><code class="codeph">1.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3314 d34642e3292 ">
                                       <p><code class="codeph">SBELL-2002100912333601PDT</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3331" headers="d34642e3283 ">
                                       <p><code class="codeph">3</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3331 d34642e3286 ">
                                       <p><code class="codeph">R1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3331 d34642e3289 ">
                                       <p><code class="codeph">1.2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3331 d34642e3292 ">
                                       <p><code class="codeph">SVOLLMAN</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3348" headers="d34642e3283 ">
                                       <p><code class="codeph">4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3348 d34642e3286 ">
                                       <p><code class="codeph">R1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3348 d34642e3289 ">
                                       <p><code class="codeph">1.2.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3348 d34642e3292 ">
                                       <p><code class="codeph">SVOLLMAN</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3365" headers="d34642e3283 ">
                                       <p><code class="codeph">5</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3365 d34642e3286 ">
                                       <p><code class="codeph">R1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3365 d34642e3289 ">
                                       <p><code class="codeph">1.2.1.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3365 d34642e3292 ">
                                       <p><code class="codeph">SVOLLMAN</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3382" headers="d34642e3283 ">
                                       <p><code class="codeph">1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3382 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3382 d34642e3289 ">
                                       <p><code class="codeph">1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3382 d34642e3292 ">
                                       <p><code class="codeph">ABEL-20021127121040897PSTZLOTKEYKING</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3399" headers="d34642e3283 ">
                                       <p><code class="codeph">2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3399 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3399 d34642e3289 ">
                                       <p><code class="codeph">1.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3399 d34642e3292 ">
                                       <p><code class="codeph">ABEL-20021127121040897PST</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3416" headers="d34642e3283 ">
                                       <p><code class="codeph">3</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3416 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3416 d34642e3289 ">
                                       <p><code class="codeph">1.2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3416 d34642e3292 ">
                                       <p><code class="codeph">ZLOTKEYKING</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3433" headers="d34642e3283 ">
                                       <p><code class="codeph">4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3433 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3433 d34642e3289 ">
                                       <p><code class="codeph">1.2.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3433 d34642e3292 ">
                                       <p><code class="codeph">ZLOTKEY</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3450" headers="d34642e3283 ">
                                       <p><code class="codeph">5</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3450 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3450 d34642e3289 ">
                                       <p><code class="codeph">1.2.1.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3450 d34642e3292 ">
                                       <p><code class="codeph">ZLOTKEY</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3467" headers="d34642e3283 ">
                                       <p><code class="codeph">4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3467 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3467 d34642e3289 ">
                                       <p><code class="codeph">1.2.2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3467 d34642e3292 ">
                                       <p><code class="codeph">KING</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="12%" id="d34642e3485" headers="d34642e3283 ">
                                       <p><code class="codeph">5</code></p>
                                    </td>
                                    <td align="left" valign="top" width="7%" headers="d34642e3485 d34642e3286 ">
                                       <p><code class="codeph">R2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="19%" headers="d34642e3485 d34642e3289 ">
                                       <p><code class="codeph">1.2.2.1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d34642e3485 d34642e3292 ">
                                       <p><code class="codeph">KING</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-2331505D-512A-4D65-9403-BF4030E1EFD4">Ignore the Path Table &#x2013; It Is Transparent</a><br>Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. 
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4">Column VALUE of an XMLIndex Path Table</a><br>A secondary index on column <code class="codeph">VALUE</code> is used with XPath expressions in a <code class="codeph">WHERE</code> clause that have predicates involving string matches. For example:
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149">Secondary Indexes on Column VALUE</a><br>Even if you do not specify a secondary index for column <code class="codeph">VALUE</code> when you create an <code class="codeph">XMLIndex</code> index, a default secondary index is created on column <code class="codeph">VALUE</code>. This default index has the default propertiesin particular, it is an index for <span class="italic">text</span> (string-valued) data only.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-5E7E3440-154B-49F1-B87F-DA877015FC48">XPath Expressions That Are Not Indexed by an XMLIndex Unstructured Component</a><br>A few types of XPath expressions are <span class="italic">not</span> indexed by <code class="codeph">XMLIndex</code>.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4347"></a><div class="props_rev_3"><a id="GUID-2331505D-512A-4D65-9403-BF4030E1EFD4" name="GUID-2331505D-512A-4D65-9403-BF4030E1EFD4"></a><h5 id="ADXDB-GUID-2331505D-512A-4D65-9403-BF4030E1EFD4" class="sect5"><span class="enumeration_section">6.3.4.1 </span>Ignore the Path Table &#x2013; It Is Transparent
                     </h5>
                     <div>
                        <p>Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. </p>
                        <p>You <span class="italic">cannot access</span> the path table, other than to <code class="codeph">DESCRIBE</code> it and create (secondary) indexes on it. You need never explicitly gather statistics on the path table. You need only collect statistics on the <code class="codeph">XMLIndex</code> index or the base table on which the <code class="codeph">XMLIndex</code> index is defined; statistics are collected and maintained on the path table and its secondary indexes transparently.
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4348"></a><div class="props_rev_3"><a id="GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4" name="GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4"></a><h5 id="ADXDB-GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4" class="sect5"><span class="enumeration_section">6.3.4.2 </span>Column VALUE of an XMLIndex Path Table
                     </h5>
                     <div>
                        <p>A secondary index on column <code class="codeph">VALUE</code> is used with XPath expressions in a <code class="codeph">WHERE</code> clause that have predicates involving string matches. For example:
                        </p>
                        <div class="section"><pre class="pre codeblock"><code>/PurchaseOrder[Reference/text() = "SBELL-2002100912333601PDT"]
</code></pre><p>Column <code class="codeph">VALUE</code> stores the <strong class="term">effective text value</strong> of an element or an attribute nodecomments and processing instructions are ignored during indexing. 
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>For an <span class="italic">attribute</span>, the effective text value is the attribute value.
                                 </p>
                              </li>
                              <li>
                                 <p>For a <span class="italic">simple</span> element (an element that has no children), the effective text value is the concatenation of all of the text nodes of the element. 
                                 </p>
                              </li>
                              <li>
                                 <p>For a <span class="italic">complex</span> element (an element that has children), the effective text value is the concatenation of (1) the text nodes of the element itself and (2) the effective text values of all of its simple-element descendants. (This is a recursive definition.)
                                 </p>
                              </li>
                           </ul>
                           <p>The effective text value is limited (truncated), however, to 4000 bytes for a simple element or attribute and to 80 bytes for a complex element.</p>
                           <p>Column <code class="codeph">VALUE</code> is a fixed size, <code class="codeph">VARCHAR2(4000)</code>. Any overflow (beyond 4000 bytes) during index creation or update is truncated.
                           </p>
                           <p>In addition to the 4000-byte limit for column <code class="codeph">VALUE</code>, there is a limit on the size of a key for the secondary index created on this column. This is the case for B-tree and function-based indexes as well; it is not an <code class="codeph">XMLIndex</code> limitation. The index-key size limit is a function of the block size for your database. It is this limit that determines how much of <code class="codeph">VALUE</code> is indexed.
                           </p>
                           <p>Thus, only the first 4000 bytes of the effective text value are stored in column <code class="codeph">VALUE</code>, and only the first <span class="italic">N</span> bytes of column <code class="codeph">VALUE</code> are indexed, where <span class="italic">N</span> is the index-key size limit (<span class="italic">N</span> &lt; 4000). Because of the index-key size limit, the index on column <code class="codeph">VALUE</code> acts only as a <span class="italic">preliminary filter</span> for the effective text value.
                           </p>
                           <p>For example, suppose that your database block size requires that the <code class="codeph">VALUE</code> index be no larger than 800 bytes, so that only the first 800 bytes of the effective text value is indexed. The first 800 bytes of the effective text value is first tested, using <code class="codeph">XMLIndex</code>, and only if that text prefix matches the query value is the rest of the effective text value tested. 
                           </p>
                           <p>The secondary index on column <code class="codeph">VALUE</code> is an index on SQL function <code class="codeph">substr</code> (substring equality), because that function is used to test the text prefix. This function-based index is created automatically as part of the implementation of <code class="codeph">XMLIndex</code> for column <code class="codeph">VALUE</code>.
                           </p>
                           <p>For example, the XPath expression <code class="codeph">/PurchaseOrder[Reference/text() = :1]</code> in a query <code class="codeph">WHERE</code> clause might, in effect, be rewritten to a test something like this:
                           </p><pre class="oac_no_warn" dir="ltr">substr(VALUE, 1 800) = substr(:1, 1, 800) AND VALUE = :1;
</pre><p>This conjunction contains two parts, which are processed from left to right. The first test uses the index on function <code class="codeph">substr</code> as a preliminary filter, to eliminate text whose first 800 bytes do not match the first 800 bytes of the value of bind variable <code class="codeph">:1</code>. 
                           </p>
                           <p>Only the first test uses an indexthe full value of column <code class="codeph">VALUE</code> is not indexed. After preliminary filtering by the first test, the second test checks the entire effective text valuethat is, the full value of column <code class="codeph">VALUE</code>for full equality with the value of <code class="codeph">:1</code>. This check does not use an index.
                           </p>
                           <p>Even if only the first 800 bytes of text is indexed, it is important for query performance that up to 4000 bytes be stored in column <code class="codeph">VALUE</code>, because that provides quick, direct access to the data, instead of requiring, for example, extracting it from deep within a <code class="codeph">CLOB</code>-instance XML document. If the effective text value is greater than 4000 bytes, then the second test in the <code class="codeph">WHERE</code>-clause conjunction requires accessing the base-table data.
                           </p>
                           <p>Neither the <code class="codeph">VALUE</code> column 4000-byte limit nor the index-key size affect query results in any way; they can affect only performance.
                           </p>
                           <div class="infoboxnote" id="GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4__GUID-B1D3EA19-0D86-46FF-B95E-DB315B75CBE8">
                              <p class="notep1">Note:</p>
                              <p>Because of the possibility of the <code class="codeph">VALUE</code> column being truncated, an Oracle Text <code class="codeph">CONTEXT</code> index created on the <code class="codeph">VALUE</code> column might return incorrect results.
                              </p>
                           </div>
                           <p>As mentioned, <code class="codeph">XMLIndex</code> can be used with XML schema-based data. If an XML schema specifies a <code class="codeph">defaultValue</code> value for a given element or attribute, and a particular document does not specify a value for that element or attribute, then the <code class="codeph">defaultValue</code> value is used for the <code class="codeph">VALUE</code> column.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4350"></a><div class="props_rev_3"><a id="GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149" name="GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149"></a><h5 id="ADXDB-GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149" class="sect5"><span class="enumeration_section">6.3.4.3 </span>Secondary Indexes on Column VALUE
                     </h5>
                     <div>
                        <p>Even if you do not specify a secondary index for column <code class="codeph">VALUE</code> when you create an <code class="codeph">XMLIndex</code> index, a default secondary index is created on column <code class="codeph">VALUE</code>. This default index has the default propertiesin particular, it is an index for <span class="italic">text</span> (string-valued) data only.
                        </p>
                        <p>You can, however, create a <code class="codeph">VALUE</code> index of a different type. For example, you can create a number-valued index if that is appropriate for many of your queries. You can create multiple secondary indexes on the <code class="codeph">VALUE</code> column. An index of a particular type is used only when it is appropriate. For example, a number-valued index is used only when the <code class="codeph">VALUE</code> column is a number; it is ignored for other values. Secondary indexes on path-table columns are treated like any other secondary indexesyou can alter them, drop them, mark them unusable, and so on.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-92768F0A-BAD2-407B-BF90-CDE3640FE149__GUID-B5CDB255-2C86-4F10-827E-460131E2E2A5">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a> for examples of creating secondary indexes on column <code class="codeph">VALUE</code></p>
                              </li>
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a> for the syntax of the <code class="codeph">PARAMETERS</code> clause
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4351"></a><div class="props_rev_3"><a id="GUID-5E7E3440-154B-49F1-B87F-DA877015FC48" name="GUID-5E7E3440-154B-49F1-B87F-DA877015FC48"></a><h5 id="ADXDB-GUID-5E7E3440-154B-49F1-B87F-DA877015FC48" class="sect5"><span class="enumeration_section">6.3.4.4 </span>XPath Expressions That Are Not Indexed by an XMLIndex Unstructured Component
                     </h5>
                     <div>
                        <p>A few types of XPath expressions are <span class="italic">not</span> indexed by <code class="codeph">XMLIndex</code>.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Applications of XPath functions, <span class="italic">except</span> <code class="codeph">ora:contains</code> (which is <span class="italic">deprecated</span>). In particular, user-defined XPath functions are <span class="italic">not</span> indexed.
                              </p>
                           </li>
                           <li>
                              <p>Axes other than <code class="codeph">child</code>, <code class="codeph">descendant</code>, and <code class="codeph">attribute</code>, that is, axes <code class="codeph">parent</code>, <code class="codeph">ancestor</code>, <code class="codeph">following-sibling</code>, <code class="codeph">preceding-sibling</code>, <code class="codeph">following</code>, <code class="codeph">preceding</code>, and <code class="codeph">ancestor-or-self</code>.
                              </p>
                           </li>
                           <li>
                              <p>Expressions using the union operator, <span class="bold"><code class="codeph">|</code></span> (vertical bar).
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-4A427DE6-21F9-45F6-8045-FF37C466A05C" title="Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the XMLIndex structured component, which applies to specific, structured document parts, the unstructured component of an XMLIndex index is, by default, very general.">XMLIndex Unstructured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4353"></a><a id="ADXDB4356"></a><a id="ADXDB4357"></a><a id="ADXDB4352"></a><div class="props_rev_3"><a id="GUID-AE06E648-B947-4171-929B-68A1DBD93992" name="GUID-AE06E648-B947-4171-929B-68A1DBD93992"></a><h4 id="ADXDB-GUID-AE06E648-B947-4171-929B-68A1DBD93992" class="sect4"><span class="enumeration_section">6.3.5 </span>Creating, Dropping, Altering, and Examining an XMLIndex Index
                  </h4>
                  <div>
                     <p>Basic operations on an <code class="codeph">XMLIndex</code> index include creating it, dropping it, altering it, and examining it. Examples are presented.
                     </p>
                     <div class="section">
                        <p>You create an <code class="codeph">XMLIndex</code> index by declaring the index type to be <code class="codeph">XDB.XMLIndex</code>, as illustrated in <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-7</a>.
                        </p>
                        <p>This creates an <code class="codeph">XMLIndex</code> index named <code class="codeph">po_xmlindex_ix</code> on <code class="codeph">XMLType</code> table <code class="codeph">po_binxml</code>. The index has only an unstructured component, no structured component.
                        </p>
                        <p>You specify inclusion of a <span class="italic">structured</span> component in an <code class="codeph">XMLIndex</code> index by including a <span class="italic"><code class="codeph">structured_clause</code></span> in the <code class="codeph">PARAMETERS</code> clause. You specify inclusion of an <span class="italic">unstructured</span> component by including a <span class="italic"><code class="codeph">path_table_clause</code></span> in the <code class="codeph">PARAMETERS</code> clause. 
                        </p>
                        <p>You can do this when you create the <code class="codeph">XMLIndex</code> index or when you modify it. If, as in <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-7</a>, you specify neither a <span class="italic"><code class="codeph">structured_clause</code></span> nor a <span class="italic"><code class="codeph">path_table_clause</code></span>, then <span class="italic">only</span> an unstructured component is included.
                        </p>
                        <p>If an <code class="codeph">XMLIndex</code> index has both an unstructured and a structured component, then you can drop either of these components using <code class="codeph">ALTER INDEX</code>.
                        </p>
                        <p>You can obtain the name of an <code class="codeph">XMLIndex</code> index on a particular <code class="codeph">XMLType</code> table (or column), as shown in <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">Example 6-8</a>. You can also select <code class="codeph">INDEX_NAME</code> from <code class="codeph">DBA_INDEXES</code> or <code class="codeph">ALL_INDEXES</code>, as appropriate.
                        </p>
                        <p>You rename or drop an <code class="codeph">XMLIndex</code> index just as you would any other index, as illustrated in <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">Example 6-9</a>. This renaming changes the name of the <code class="codeph">XMLIndex</code> index only. It does not change the name of the path tableyou can rename the path table separately.
                        </p>
                        <p>Similarly, you can change other index properties using other <code class="codeph">ALTER INDEX</code> options, such as <code class="codeph">REBUILD</code>. <code class="codeph">XMLIndex</code> is no different from other index types in this respect.
                        </p>
                        <p>The <code class="codeph">RENAME</code> clause of an <code class="codeph">ALTER INDEX</code> statement for <code class="codeph">XMLIndex</code> applies only to the <code class="codeph">XMLIndex</code> index itself. To rename the path table and secondary indexes, you must determine the names of these objects and use appropriate <code class="codeph">ALTER TABLE</code> or <code class="codeph">ALTER INDEX</code> statements on them directly. Similarly, to retrieve the physical properties of the secondary indexes or alter them in any other way, you must obtain their names, as in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-14</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__GUID-0FE22123-D012-4C96-8863-0C24357F7A5E">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a></p>
                              </li>
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">path_table_clause ::=</a></p>
                              </li>
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGGGBCB">drop_path_table_clause ::=</a></p>
                              </li>
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">alter_index_group_clause ::=</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">
                        <p class="titleinexample">Example 6-7 Creating an XMLIndex Index</p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS <span class="bold">XDB.XMLIndex</span>;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDDGHDF">
                        <p class="titleinexample">Example 6-8 Obtaining the Name of an XMLIndex Index on a Particular Table</p><pre class="pre codeblock"><code>SELECT INDEX_NAME FROM <span class="bold">USER_INDEXES</span>
  WHERE TABLE_NAME = 'PO_BINXML' AND <span class="bold">ITYP_NAME = 'XMLINDEX'</span>;

INDEX_NAME
---------------
PO_XMLINDEX_IX
 
1 row selected.
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDFIGIB">
                        <p class="titleinexample">Example 6-9 Renaming and Dropping an XMLIndex Index</p><pre class="pre codeblock"><code>ALTER INDEX po_xmlindex_ix <span class="bold">RENAME TO new_name_ix</span>;

DROP INDEX new_name_ix;
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" title="The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4358"></a><a id="ADXDB4359"></a><a id="ADXDB4360"></a><a id="ADXDB5827"></a><a id="ADXDB4361"></a><a id="ADXDB4362"></a><div class="props_rev_3"><a id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" name="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246"></a><h4 id="ADXDB-GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" class="sect4"><span class="enumeration_section">6.3.6 </span>Using XMLIndex with an Unstructured Component
                  </h4>
                  <div>
                     <p>You can perform various operations on an <code class="codeph">XMLIndex</code> index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.
                     </p>
                     <div class="section">
                        <p>To include an unstructured component in an <code class="codeph">XMLIndex</code> index, you can use a <span class="italic"><code class="codeph">path_table_clause</code></span> in the <code class="codeph">PARAMETERS</code> clause when you create or modify the <code class="codeph">XMLIndex</code> indexsee <a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">path_table_clause ::=</a>. 
                        </p>
                        <p>If you do not specify a <span class="italic">structured</span> component, then the index will have an unstructured component, even if you do not specify the path table. It is however generally a good idea to specify the path table, so that it has a recognizable, user-oriented name that you can refer to in other <code class="codeph">XMLIndex</code> operations.
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-10</a> shows how to name the path table ("my_path_table") when creating an <code class="codeph">XMLIndex</code> index with an unstructured component.
                        </p>
                        <p>If you do not name the path table then its name is generated by the system, using the index name you provide to <code class="codeph">CREATE INDEX</code> as a base. <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-11</a> shows this for the <code class="codeph">XMLIndex</code> index created in <a href="indexes-for-XMLType-data.html#GUID-AE06E648-B947-4171-929B-68A1DBD93992__CHDCGJHC">Example 6-7</a>.
                        </p>
                        <p>By default, the storage options of a path table and its secondary indexes are derived from the storage properties of the base table on which the <code class="codeph">XMLIndex</code> index is created. You can specify different storage options by using a <code class="codeph">PARAMETERS</code> clause when you create the index, as shown in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-12</a>. The <code class="codeph">PARAMETERS</code> clause of <code class="codeph">CREATE INDEX</code> (and <code class="codeph">ALTER INDEX</code>) must be between single quotation marks (<span class="bold"><code class="codeph">'</code></span>).
                        </p>
                        <p>Because <code class="codeph">XMLIndex</code> is a logical <span class="italic">domain</span> index, not a physical index, all physical attributes are either zero (<code class="codeph">0</code>) or <code class="codeph">NULL</code>.
                        </p>
                        <p>If an <code class="codeph">XMLIndex</code> index has both an unstructured and a structured component, then you can use <code class="codeph">ALTER INDEX</code> to drop the unstructured component. To do this, you drop the path table. <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">Example 6-13</a> illustrates this. (This assumes that you also have a structured component<a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a> results in an index with both structured and unstructured components.)
                        </p>
                        <p>In addition to specifying storage options for the path table, <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-12</a> names the secondary indexes on the path table.
                        </p>
                        <p>Like the name of the path table, the names of the secondary indexes on the path-table columns are generated automatically using the index name as a base, unless you specify them in the <code class="codeph">PARAMETERS</code> clause. <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">Example 6-14</a> illustrates this, and shows how you can determine these names using public view <code class="codeph">USER_IND_COLUMNS</code>. It also shows that the pikey index uses three columns.
                        </p>
                        <div class="infoboxnotealso" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__GUID-DE57EC3B-B5A9-4C0C-BA0B-12F4BC9984E6">
                           <p class="notep1">See Also:</p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-20</a> for a similar, but more complex example
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">
                        <p class="titleinexample">Example 6-10 Naming the Path Table of an XMLIndex Index</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  <span class="bold">PARAMETERS ('PATH TABLE my_path_table')</span>;
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">
                        <p class="titleinexample">Example 6-11 Determining the System-Generated Name of an XMLIndex Path Table</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="bold">PATH_TABLE_NAME</span> FROM <span class="bold">USER_XML_INDEXES</span>
  WHERE TABLE_NAME = 'PO_BINXML' AND INDEX_NAME = 'PO_XMLINDEX_IX';
 
PATH_TABLE_NAME
------------------------------
<span class="bold">SYS67567</span>_PO_XMLINDE_<span class="bold">PATH_TABLE</span>
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">
                        <p class="titleinexample">Example 6-12 Specifying Storage Options When Creating an XMLIndex Index</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS
    ('PATH TABLE po_path_table
      (PCTFREE 5 PCTUSED 90 INITRANS 5
       <span class="bold">STORAGE</span> (INITIAL 1k NEXT 2k MINEXTENTS 3 BUFFER_POOL KEEP)
       NOLOGGING ENABLE ROW MOVEMENT PARALLEL 3)
      <span class="bold">PIKEY INDEX</span> po_pikey_ix (LOGGING PCTFREE 1 INITRANS 3)
      <span class="bold">VALUE INDEX</span> po_value_ix (LOGGING PCTFREE 1 INITRANS 3)');
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__BCGHIIFB">
                        <p class="titleinexample">Example 6-13 Dropping an XMLIndex Unstructured Component</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX po_xmlindex_ix PARAMETERS('DROP PATH TABLE');
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJHFGG">
                        <p class="titleinexample">Example 6-14 Determining the Names of the Secondary Indexes of an XMLIndex Index</p><pre class="oac_no_warn" dir="ltr">SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION FROM USER_IND_COLUMNS
  WHERE TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                         WHERE INDEX_NAME = 'PO_XMLINDEX_IX')
  ORDER BY INDEX_NAME, COLUMN_NAME;
 
INDEX_NAME                     COLUMN_NAME  COLUMN_POSITION
------------------------------ ------------ ---------------
SYS67563_PO_XMLINDE_PIKEY_IX   ORDER_KEY                  3
SYS67563_PO_XMLINDE_PIKEY_IX   PATHID                     2
SYS67563_PO_XMLINDE_PIKEY_IX   RID                        1
SYS67563_PO_XMLINDE_VALUE_IX   SYS_NC00006$               1
 
4 rows selected.</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24">Creating Additional Secondary Indexes on an XMLIndex Path Table</a><br>You can add extra secondary indexes to an <code class="codeph">XMLIndex</code> unstructured component.
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" title="The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4363"></a><a id="ADXDB4364"></a><a id="ADXDB4365"></a><a id="ADXDB4366"></a><a id="ADXDB4367"></a><a id="ADXDB4368"></a><a id="ADXDB5828"></a><div class="props_rev_3"><a id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24" name="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24"></a><h5 id="ADXDB-GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24" class="sect5"><span class="enumeration_section">6.3.6.1 </span>Creating Additional Secondary Indexes on an XMLIndex Path Table
                     </h5>
                     <div>
                        <p>You can add extra secondary indexes to an <code class="codeph">XMLIndex</code> unstructured component.
                        </p>
                        <div class="section">
                           <p>Examples <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-15</a>, <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-17</a>, <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-18</a>, and <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-19</a> add extra secondary indexes to the <code class="codeph">XMLIndex</code> index created in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBIGIJ">Example 6-12</a>.
                           </p>
                           <p>You can create any number of additional secondary indexes on the <code class="codeph">VALUE</code> column of the path table of an <code class="codeph">XMLIndex</code> index. These can be of different types, including function-based indexes and Oracle Text indexes.
                           </p>
                           <p>Whether or not a given index is used for a given element occurrence when processing a query is determined by whether it is of the appropriate type for that value and whether it is cost-effective to use it. </p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-15</a> creates a function-based index on column <code class="codeph">VALUE</code> of the path table using SQL function <code class="codeph">substr</code>. This might be useful if your queries often use <code class="codeph">substr</code> applied to the text nodes of XML elements.
                           </p>
                           <p>If you have many elements whose text nodes represent numeric values, then it can make sense to create a numeric index on the column <code class="codeph">VALUE</code>. However, doing so directly, in a manner analogous to <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">Example 6-15</a>, raises an ORA-01722 error (invalid number) if some of the element values are <span class="italic">not</span> numbers. This is illustrated in <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJBCDD">Example 6-16</a>.
                           </p>
                           <p>What is needed is an index that is used for numeric-valued elements but is ignored for element occurrences that do not have numeric values. Procedure <code class="codeph">createNumberIndex</code> of package <code class="codeph">DBMS_XMLINDEX</code> exists specifically for this purpose. You pass it the names of the database schema, the <code class="codeph">XMLIndex</code> index, and the numeric index to be created. Creation of a numeric index is illustrated in <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">Example 6-17</a>.
                           </p>
                           <p>Because such an index is specifically designed to ignore elements that do not have numeric values, its use does not detect their presence. If there are non-numeric elements and, for whatever reason, the <code class="codeph">XMLIndex</code> index is not used in some query, then an <code class="codeph">ORA-01722</code> error is raised. However, if the index is used, no such error is raised, because the index ignores non-numeric data. As always, the use of an index never changes the result setit never gives you different results, but use of an index can prevent you from detecting erroneous data.
                           </p>
                           <p>Creating a date-valued index is similar to creating a numeric index; you use procedure <code class="codeph">DBMS_XMLINDEX.createDateIndex</code>. <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">Example 6-18</a> shows this.
                           </p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">Example 6-19</a> creates an Oracle Text <code class="codeph">CONTEXT</code> index on column <code class="codeph">VALUE</code>. This is useful for full-text queries on text values of XML elements. XPath predicates that use XPath function <code class="codeph">ora:contains</code> (<span class="italic">deprecated</span>) are rewritten to applications of Oracle SQL function <code class="codeph">contains</code> on column <code class="codeph">VALUE</code>. If a <code class="codeph">CONTEXT</code> index is defined on column <code class="codeph">VALUE</code>, then it is used during predicate evaluation. An Oracle Text index is independent of all other <code class="codeph">VALUE</code>-column indexes.
                           </p>
                           <p>The query in <a href="indexes-for-XMLType-data.html#GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">Example 6-20</a> shows all of the secondary indexes created on the path table of an <code class="codeph">XMLIndex</code> index. The indexes created explicitly are in bold. Note in particular that some indexes, such as the function-based index created on column <code class="codeph">VALUE</code>, do not appear as such; the column name listed for such an index is a system-generated name such as <code class="codeph">SYS_NC00007$</code>. You <span class="italic">cannot</span> see these columns by executing a query with <code class="codeph">COLUMN_NAME = 'VALUE'</code> in the <code class="codeph">WHERE</code> clause.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__GUID-92D20DAB-9879-4411-842A-2C91A76BDF82">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-18593F7F-21F2-46A0-9BBF-1B9C029CBBA4" title="A secondary index on column VALUE is used with XPath expressions in a WHERE clause that have predicates involving string matches. For example:">Column VALUE of an XMLIndex Path Table</a> for information about the possibility of an Oracle Text <code class="codeph">CONTEXT</code> index created on the <code class="codeph">VALUE</code> column returning incorrect results
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../ccref/oracle-text-SQL-statements-and-operators.html#CCREF-GUID-46981A92-A7F3-4431-AEDB-7E4F0C5FC862" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about <code class="codeph">CREATE INDEX</code> parameter <code class="codeph">TRANSACTIONAL</code></p>
                                 </li>
                                 <li>
                                    <p><a href="../arpls/DBMS_XMLINDEX.html#ARPLS212" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information on PL/SQL procedures <code class="codeph">createNumberIndex</code> and <code class="codeph">createDateIndex</code> in package <code class="codeph">DBMS_XMLINDEX</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDGADGI">
                           <p class="titleinexample">Example 6-15 Creating a Function-Based Index on Path-Table Column VALUE</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX fn_based_ix ON <span class="bold">po_path_table</span> (<span class="bold">substr</span>(<span class="bold">VALUE</span>, 1, 100));
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJBCDD">
                           <p class="titleinexample">Example 6-16 Trying to Create a Numeric Index on Path-Table Column VALUE Directly</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE));
CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE))
                                             <span class="bold">*</span>
ERROR at line 1:
ORA-01722: <span class="bold">invalid number</span>
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDFHBBJ">
                           <p class="titleinexample">Example 6-17 Creating a Numeric Index on Column VALUE with Procedure createNumberIndex</p><pre class="oac_no_warn" dir="ltr">CALL DBMS_XMLINDEX.<span class="bold">createNumberIndex</span>('OE', 'PO_XMLINDEX_IX', 'API_NUM_IX');
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDBABFD">
                           <p class="titleinexample">Example 6-18 Creating a Date Index on Column VALUE with Procedure createDateIndex</p><pre class="oac_no_warn" dir="ltr">CALL DBMS_XMLINDEX.<span class="bold">createDateIndex</span>('OE', 'PO_XMLINDEX_IX', 'API_DATE_IX', 
                                   'dateTime');
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJEHFC">
                           <p class="titleinexample">Example 6-19 Creating an Oracle Text CONTEXT Index on Path-Table Column VALUE</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_otext_ix ON po_path_table (VALUE)
  INDEXTYPE IS <span class="bold">CTXSYS.CONTEXT</span> PARAMETERS('TRANSACTIONAL');</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1242A13C-7D4E-40DF-8EDE-23B6C83DAC24__CHDJACJG">
                           <p class="titleinexample">Example 6-20 Showing All Secondary Indexes on an XMLIndex Path Table</p><pre class="oac_no_warn" dir="ltr">SELECT c.INDEX_NAME, c.COLUMN_NAME, c.COLUMN_POSITION, e.COLUMN_EXPRESSION
  FROM <span class="bold">USER_IND_COLUMNS</span> c LEFT OUTER JOIN <span class="bold">USER_IND_EXPRESSIONS</span> e
    ON (c.INDEX_NAME = e.INDEX_NAME)
  WHERE c.TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                           WHERE INDEX_NAME = 'PO_XMLINDEX_IX')
  ORDER BY c.INDEX_NAME, c.COLUMN_NAME;
 
INDEX_NAME           COLUMN_NAME  COLUMN_POSITION COLUMN_EXPRESSION
-------------------- ------------ --------------- ----------------------
<span class="bold">API_DATE_IX</span>          <span class="bold">SYS_NC00009$</span>               1 SYS_EXTRACT_UTC(SYS_XMLCONV("V
                                                  ALUE",3,8,0,0,181))
<span class="bold">API_NUM_IX</span>           <span class="bold">SYS_NC00008$</span>               1 TO_BINARY_DOUBLE("VALUE")
<span class="bold">FN_BASED_IX</span>          <span class="bold">SYS_NC00007$</span>               1 SUBSTR("VALUE",1,100)
<span class="bold">PO_OTEXT_IX</span>          VALUE                      1
PO_PIKEY_IX          ORDER_KEY                  3
PO_PIKEY_IX          PATHID                     2
PO_PIKEY_IX          RID                        1
PO_VALUE_IX          SYS_NC00006$               1 SUBSTRB("VALUE",1,1599)
 
8 rows selected.</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246" title="You can perform various operations on an XMLIndex index that has an unstructured component, including manipulating the path table and the secondary indexes of that component.">Using XMLIndex with an Unstructured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4369"></a><div class="props_rev_3"><a id="GUID-476331FD-F58B-4980-BECD-015F0A794AC9" name="GUID-476331FD-F58B-4980-BECD-015F0A794AC9"></a><h4 id="ADXDB-GUID-476331FD-F58B-4980-BECD-015F0A794AC9" class="sect4"><span class="enumeration_section">6.3.7 </span>Use of XMLIndex with a Structured Component
                  </h4>
                  <div>
                     <p>An <code class="codeph">XMLIndex</code> structured component indexes specific islands of structure in your XML data.
                     </p>
                     <p>To include a structured component in an <code class="codeph">XMLIndex</code> index, you use a <span class="italic"><code class="codeph">structured_clause</code></span> in the <code class="codeph">PARAMETERS</code> clause when you create or modify the <code class="codeph">XMLIndex</code> indexsee <a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a>. 
                     </p>
                     <p>A <span class="italic"><code class="codeph">structured_clause</code></span> specifies the structured islands that you want to index. You use the keyword <code class="codeph">GROUP</code> to specify each structured island: an island thus corresponds syntactically to a structure <strong class="term">group</strong>. If you specify no group explicitly, then the predefined group <code class="codeph">DEFAULT_GROUP</code> is used. For <code class="codeph">ALTER INDEX</code>, you precede the <code class="codeph">GROUP</code> keyword with the modification operation keyword: <code class="codeph">ADD_GROUP</code> specifies a new group (island); <code class="codeph">DROP_GROUP</code> deletes a group.
                     </p>
                     <p>Why have multiple groups within a single index, instead of simply using multiple <code class="codeph">XMLIndex</code> indexes? The reason is that <code class="codeph">XMLIndex</code> is a domain index, and you can create only one domain index of a given type on a given database column.
                     </p>
                     <p>The syntax for defining a structure group, that is, indexing a structured island, is similar to the syntax for invoking SQL/XML <span class="italic">function</span> <code class="codeph">XMLTable</code>: you use keywords <code class="codeph">XMLTable</code> and <code class="codeph">COLUMNS</code> to define relational columns, and you use multilevel chaining of <code class="codeph">XMLTable</code> to handle collections. To simplify the creation of such an index, you can use PL/SQL function 		<code class="codeph">DBMS_XMLSTORAGE_MANAGE.getSIDXDefFromView</code> to provide exactly the <code class="codeph">XMLTable</code> expression needed for creating the index.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B">Using Namespaces and Storage Clauses with an XMLIndex Structured Component</a><br>When you create an <code class="codeph">XMLIndex</code> index that has a structured component you can specify XML namespaces and storage options to use.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0">Adding a Structured Component to an XMLIndex Index</a><br>You can use <code class="codeph">ALTER INDEX</code> to add a structured component to an existing <code class="codeph">XMLIndex</code> index.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C">Using Non-Blocking ALTER INDEX with an XMLIndex Structured Component</a><br>You can prevent <code class="codeph">ALTER INDEX</code> from blocking when you add a group or column for  the structured component of an <code class="codeph">XMLIndex</code> index, so that queries that use the index do not need to wait.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE">Modifying the Data Type of a Structured XMLIndex Component</a><br>If an error is raised because some of your data does not match the data type used for the corresponding column of the structured <code class="codeph">XMLIndex</code> component, you can in some cases simply modify the index by passing keyword <code class="codeph">MODIFY_COLUMN_TYPE</code> to <code class="codeph">ALTER INDEX</code>. 
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8">Dropping an XMLIndex Structured Component</a><br>If an <code class="codeph">XMLIndex</code> index has both an unstructured and a structured component, then you can use <code class="codeph">ALTER INDEX</code> to drop the structured component. You do this by dropping <span class="italic">all</span> of the structure groups that compose the structured component. 
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9">Indexing the Relational Tables of a Structured XMLIndex Component</a><br>Because the tables used for the structured component of an <code class="codeph">XMLIndex</code> index are normal relational tables, you can index them using any standard relational indexes. 
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" title="The string value used for the PARAMETERS clause of a CREATE INDEX or ALTER INDEX statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures registerParameter and modifyParameter in package DBMS_XMLINDEX.">Using a Registered PARAMETERS Clause for XMLIndex</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-476331FD-F58B-4980-BECD-015F0A794AC9__GUID-9B8DB6E1-63C4-4EE7-973A-BC6B33A92472">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="relational-views-over-XML-data.html#GUID-DFEC1462-BAD9-44CA-A9C4-88C27A0CD46C" title="If the relational columns of the structured component of an XMLIndex index over binary XML data match the columns of a relational view over that data, then the view too is effectively indexed.">Indexing Binary XML Data Exposed Using a Relational View</a> for information about using <code class="codeph">DBMS_XMLSTORAGE_MANAGE.getSIDXDefFromView</code></p>
                           </li>
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-30</a></p>
                           </li>
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                           </li>
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">structured_clause ::=</a></p>
                           </li>
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" title="Certain considerations apply to using XMLIndex_xmltable_clause.">Usage of XMLIndex_xmltable_clause</a> for information about an <code class="codeph">XMLType</code> column in an <code class="codeph">XMLTable</code> clause
                              </p>
                           </li>
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-D4474161-F125-4703-98D2-7C609F8806E7" title="Certain considerations apply to using column_clause.">Usage of column_clause</a> for information about keywords <code class="codeph">COLUMNS</code> and <code class="codeph">VIRTUAL</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB5831"></a><a id="ADXDB6087"></a><div class="props_rev_3"><a id="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B" name="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B"></a><h5 id="ADXDB-GUID-6C638C44-A5E6-476F-95A0-151150EEF16B" class="sect5"><span class="enumeration_section">6.3.7.1 </span>Using Namespaces and Storage Clauses with an XMLIndex Structured Component
                     </h5>
                     <div>
                        <p>When you create an <code class="codeph">XMLIndex</code> index that has a structured component you can specify XML namespaces and storage options to use.
                        </p>
                        <div class="section">
                           <p><a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-21</a> shows the creation of an <code class="codeph">XMLIndex</code> index that has only a structured component (no path-table clause) and that uses the <code class="codeph">XMLNAMESPACES</code> clause to specify namespaces. It specifies that the index data be compressed and use tablespace <code class="codeph">USERTBS1</code>. The example assumes a binary XML table <code class="codeph">po_binxml</code> with non XML schema-based data.
                           </p>
                           <p>Each of the (identical) <code class="codeph">TABLESPACE</code> clauses in <a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">Example 6-21</a> applies at the table level (tables <code class="codeph">po_ptab</code> and <code class="codeph">li_tab</code>).
                           </p>
                           <p>In general you can specify storage options at both the table level and the partition level. A specification at the partition level overrides one at the table level. A <code class="codeph">TABLESPACE</code> clause can also be specified at the <span class="italic">index</span> level, that is, so that it applies to all of the partitions and tables used for the index. If <code class="codeph">TABLESPACE</code> is specified at more than one level, the partition level overrides the table level, which overrides the index level.
                           </p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__XMLINDEXWITHASTRUCTUREDCOMPONENTSPE-2AF51F5B">Example 6-22</a> specifies the same <code class="codeph">TABLESPACE</code> for each of the tables used in the index. This commonality can be factored out by specifying the <code class="codeph">TABLESPACE</code> at the index level, as shown in <a href="indexes-for-XMLType-data.html#GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__XMLINDEXWITHASTRUCTUREDCOMPONENTSPE-2AF51F5B">Example 6-22</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__BCGDDBDI">
                           <p class="titleinexample">Example 6-21 XMLIndex with a Structured Component, Using Namespaces and Storage Options</p><pre class="pre codeblock"><code>CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_ptab
                 (<span class="bold">TABLESPACE</span> "USERTBS1" COMPRESS FOR OLTP)
                  <span class="bold">XMLNAMESPACES</span> (DEFAULT ''http://www.example.com/po''),
                 ''/purchaseOrder''
                 COLUMNS orderdate   DATE          PATH ''@orderDate'',
                         id          BINARY_DOUBLE PATH ''@id'',
                         items       XMLType       PATH ''items/item'' VIRTUAL
               XMLTable li_tab
                 (<span class="bold">TABLESPACE</span> "USERTBS1" COMPRESS FOR OLTP)
                  <span class="bold">XMLNAMESPACES</span> (DEFAULT ''http://www.example.com/po''),
                 ''/item'' PASSING items
                 COLUMNS partnum     VARCHAR2(15)  PATH ''@partNum'',
                         description CLOB          PATH ''productName'',
                         usprice     BINARY_DOUBLE PATH ''USPrice'',
                         shipdat     DATE          PATH ''shipDate''');
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-6C638C44-A5E6-476F-95A0-151150EEF16B__XMLINDEXWITHASTRUCTUREDCOMPONENTSPE-2AF51F5B">
                           <p class="titleinexample">Example 6-22 XMLIndex with a Structured Component, Specifying TABLESPACE at the Index Level</p><pre class="pre codeblock"><code>CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_ptab,
                  XMLNAMESPACES (DEFAULT ''http://www.example.com/po''),
                 ''/purchaseOrder''
                 COLUMNS orderdate   DATE          PATH ''@orderDate'',
                         id          BINARY_DOUBLE PATH ''@id'',
                         items       XMLType       PATH ''items/item'' VIRTUAL
               XMLTable li_tab,
                  XMLNAMESPACES (DEFAULT ''http://www.example.com/po''),
                 ''/item'' PASSING items
                 COLUMNS partnum     VARCHAR2(15)  PATH ''@partNum'',
                         description CLOB          PATH ''productName'',
                         usprice     BINARY_DOUBLE PATH ''USPrice'',
                         shipdat     DATE          PATH ''shipDate''
               <span class="bold">TABLESPACE</span> "USERTBS1" COMPRESS FOR OLTP)');
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4370"></a><a id="ADXDB6088"></a><div class="props_rev_3"><a id="GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0" name="GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0"></a><h5 id="ADXDB-GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0" class="sect5"><span class="enumeration_section">6.3.7.2 </span>Adding a Structured Component to an XMLIndex Index
                     </h5>
                     <div>
                        <p>You can use <code class="codeph">ALTER INDEX</code> to add a structured component to an existing <code class="codeph">XMLIndex</code> index.
                        </p>
                        <div class="section">
                           <p><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a> shows the creation of an <code class="codeph">XMLIndex</code> index with only an unstructured component. An unstructured component is created because the <code class="codeph">PARAMETERS</code> clause explicitly names the path table.
                           </p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a> then uses <code class="codeph">ALTER INDEX</code> to add a structured component (group) named <code class="codeph">po_item</code>. This structure group includes two relational tables, each specified with keyword <code class="codeph">XMLTable</code>.
                           </p>
                           <p>The top-level table, <code class="codeph">po_idx_tab</code>, has columns <code class="codeph">reference</code>, <code class="codeph">requestor</code>, <code class="codeph">username</code>, and <code class="codeph">lineitem</code>. Column <code class="codeph">lineitem</code> is of type <code class="codeph">XMLType</code>. It represents a collection, so it is passed to the second <code class="codeph">XMLTable</code> construct to form the second-level relational table, <code class="codeph">po_index_lineitem</code>, which has columns <code class="codeph">itemno</code>, <code class="codeph">description</code>, <code class="codeph">partno</code>, <code class="codeph">quantity</code>, and <code class="codeph">unitprice</code>.
                           </p>
                           <p>The keyword <code class="codeph">VIRTUAL</code> is <span class="italic">required</span> for an <code class="codeph">XMLType</code> column. It specifies that the <code class="codeph">XMLType</code> column itself is not materialized: its data is stored in the <code class="codeph">XMLIndex</code> index only in the form of the relational columns specified by its corresponding <code class="codeph">XMLTable</code> table.
                           </p>
                           <p>You cannot create more than one <code class="codeph">XMLType</code> column in a given <code class="codeph">XMLTable</code> clause. To achieve that effect, you must instead define an additional group.
                           </p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a> also illustrates the use of a registered parameter string in the <code class="codeph">PARAMETERS</code> clause. It uses PL/SQL procedure <code class="codeph">DBMS_XMLINDEX.registerParameter</code> to register the parameters string named <code class="codeph">myparam</code>. Then it uses <code class="codeph">ALTER INDEX</code> to update the index parameters to include those in the string <code class="codeph">myparam</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">
                           <p class="titleinexample">Example 6-23 XMLIndex Index: Adding a Structured Component</p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE)
  INDEXTYPE IS XDB.XMLIndex PARAMETERS ('PATH TABLE path_tab');

BEGIN
  DBMS_XMLINDEX.<span class="bold">registerParameter</span>(
    'myparam',
    '<span class="bold">ADD_GROUP GROUP</span> po_item
       <span class="bold">XMLTable</span> po_idx_tab ''/PurchaseOrder''
         COLUMNS reference   VARCHAR2(30)  PATH ''Reference'',
                 requestor   VARCHAR2(30)  PATH ''Requestor'',
                 username    VARCHAR2(30)  PATH ''User'',
                 lineitem    XMLType       PATH ''LineItems/LineItem'' <span class="bold">VIRTUAL</span>
       <span class="bold">XMLTable</span> po_index_lineitem ''/LineItem'' PASSING lineitem
         COLUMNS itemno      BINARY_DOUBLE PATH ''@ItemNumber'',
                 description VARCHAR2(256) PATH ''Description'',
                 partno      VARCHAR2(14)  PATH ''Part/@Id'',
                 quantity    BINARY_DOUBLE PATH ''Part/@Quantity'',
                 unitprice   BINARY_DOUBLE PATH ''Part/@UnitPrice''');
END;
/

ALTER INDEX po_xmlindex_ix PARAMETERS('<span class="bold">PARAM</span> myparam');
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6090"></a><a id="ADXDB6089"></a><div class="props_rev_3"><a id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C" name="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C"></a><h5 id="ADXDB-GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C" class="sect5"><span class="enumeration_section">6.3.7.3 </span>Using Non-Blocking ALTER INDEX with an XMLIndex Structured Component
                     </h5>
                     <div>
                        <p>You can prevent <code class="codeph">ALTER INDEX</code> from blocking when you add a group or column for  the structured component of an <code class="codeph">XMLIndex</code> index, so that queries that use the index do not need to wait.
                        </p>
                        <div class="section">
                           <p>When you use <code class="codeph">ALTER INDEX</code> to add a group or a column for the structured component of an <code class="codeph">XMLIndex</code> index, this index-maintenance operation obtains an exclusive DDL lock on the base table and the index. 
                           </p>
                           <p>The base table is locked to DML operations, and the index cannot be used for queries until the <code class="codeph">ALTER INDEX</code> operation is finished. This means that during this index maintenance the index cannot be used by other sessions that query or perform DML operations on the base table. The duration of the <code class="codeph">ALTER INDEX</code> operation and the attendant locking depends on the volume of data in the base <code class="codeph">XMLType</code> column.
                           </p>
                           <p>You can avoid or work around this problem as follows:</p>
                           <ol>
                              <li>
                                 <p>Use keyword <span class="bold"><code class="codeph">NONBLOCKING</code></span> before <code class="codeph">ADD_GROUP</code> or <code class="codeph">ADD_COLUMN</code> in the <code class="codeph">PARAMETERS</code> clause of the <code class="codeph">ALTER INDEX</code> statement that creates the structured-component group or column. 
                                 </p>
                                 <p>This updates the index as needed, but it does not index any base-table data. Because it does not depend on the base-table data it is quick regardless of the base-table size.</p>
                              </li>
                              <li>
                                 <p>Invoke PL/SQL procedure <code class="codeph">DBMS_XMLINDEX.</code><span class="bold"><code class="codeph">process_pending</code></span>. 
                                 </p>
                                 <p>This procedure indexes rows of the base table and populates tables of the index, just as if keyword <code class="codeph">NONBLOCKING</code> were absent. However, in this case only a few rows are locked at a time while they are processed and the changes committed. Rows that have already been locked for some other purpose are skipped. This can significantly reduce lock contention and allow indexing of some rows to proceed at the same time as querying or DML on other rows.
                                 </p>
                                 <p>When procedure <code class="codeph">process_pending</code> finishes it returns, as <code class="codeph">OUT</code> parameters:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The number of rows that it could not index. This is either because they were <span class="italic">locked</span> for another purpose or because an error was raised (this number includes the number returned as the other <code class="codeph">OUT</code> parameter).
                                       </p>
                                       <p>After you think those locks have been removed, invoke procedure <code class="codeph">process_pending</code> again to try to process those pending rows.
                                       </p>
                                    </li>
                                    <li>
                                       <p>The number of rows that it could not index because an <span class="italic">error</span> was raised. (This should be rare.)
                                       </p>
                                       <p>Check table <code class="codeph">SYS_AIXSXI_</code><span class="italic"><code class="codeph">index_number</code></span><code class="codeph">_ERRORTAB</code> for information about those errors, then take action to fix the underlying problems. <span class="italic"><code class="codeph">index_number</code></span> is the object number of the index.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Repeat step 2 as many times as necessary until procedure <code class="codeph">process_pending</code> indicates that all rows have been successfully indexed or you encounter an insurmountable problem and decide to cancel the indexing operation altogether.
                                 </p>
                                 <p>You can cancel the indexing at any time (before step 2) by using keywords <span class="bold"><code class="codeph">NONBLOCKING ABORT</code></span> in the <code class="codeph">PARAMETERS</code> clause of a separate <code class="codeph">ALTER INDEX</code> statement for the same <code class="codeph">XMLIndex</code> index.
                                 </p>
                              </li>
                              <li>
                                 <p>If all rows have been successfully indexed then use keywords <span class="bold"><code class="codeph">NONBLOCKING COMPLETE</code></span> in the <code class="codeph">PARAMETERS</code> clause of a separate <code class="codeph">ALTER INDEX</code> statement for the same <code class="codeph">XMLIndex</code> index.
                                 </p>
                              </li>
                           </ol>
                           <p><a href="indexes-for-XMLType-data.html#GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__CEGBBCDG">Example 6-24</a> illustrates this.
                           </p>
                           <p>Just as table <code class="codeph">SYS_AIXSXI_</code><span class="italic"><code class="codeph">index_number</code></span><code class="codeph">_</code><span class="bold"><code class="codeph">ERRORTAB</code></span> reports errors, so table <code class="codeph">SYS_AIXSXI_</code><span class="italic"><code class="codeph">index_number</code></span><code class="codeph">_</code><span class="bold"><code class="codeph">PENDINGTAB</code></span> records the current status of each base-table row: whether or not it has been indexed. A row might not yet be indexed because it is locked by for some other purpose or because trying to index it raised an error. In the latter case, consult <code class="codeph">SYS_AIXSXI_</code><span class="italic"><code class="codeph">index_number</code></span><code class="codeph">_ERRORTAB</code> for specific information about the error.
                           </p>
                           <div class="infoboxnotealso" id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__GUID-198206E5-C3F2-401E-B227-1EDB6B7B002B">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">alter_index_group_clause ::=</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-E12BC8D6-70C9-44D1-90D5-346F37EA8B5C__CEGBBCDG">
                           <p class="titleinexample">Example 6-24 Using DBMS_XMLINDEX.PROCESS_PENDING To Index XML Data</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_idx_tab
                 ''/PurchaseOrder''
                 COLUMNS reference   VARCHAR2(30)  PATH ''Reference'',
                         requestor   VARCHAR2(30)  PATH ''Requestor'',
                         username    VARCHAR2(30)  PATH ''User'',
                         lineitem    XMLType       PATH ''LineItems/LineItem'' VIRTUAL
               XMLTable po_index_lineitem
                 ''/LineItem'' PASSING lineitem
                 COLUMNS itemno      BINARY_DOUBLE PATH ''@ItemNumber'',
                         description VARCHAR2(256) PATH ''Description'',
                         partno      VARCHAR2(14)  PATH ''Part/@Id'',
                         quantity    BINARY_DOUBLE PATH ''Part/@Quantity'',
                         unitprice   BINARY_DOUBLE PATH ''Part/@UnitPrice''');
 
ALTER INDEX po_struct
  PARAMETERS('<span class="bold">NONBLOCKING</span> ADD_GROUP GROUP po_action_group 
              XMLTABLE po_idx_tab
                ''/PurchaseOrder''
                COLUMNS actions       XMLType       PATH  ''Actions/Action'' VIRTUAL
              XMLTABLE po_idx_action
                ''/Action'' PASSING actions
                COLUMNS actioned_by   VARCHAR2(10)  PATH  ''User'',
                        date_actioned TIMESTAMP     PATH  ''Date''');

DECLARE
  num_pending NUMBER := 0;
  num_errored NUMBER := 0;
BEGIN
 DBMS_XMLINDEX.<span class="bold">process_pending</span>('oe', 'po_struct', num_pending, num_errored);
 DBMS_OUTPUT.put_line('Number of rows still pending = ' || num_pending);
 DBMS_OUTPUT.put_line('Number of rows with errors   = ' || num_errored);
END;
/
Number of rows still pending = <span class="bold">0</span>
Number of rows with errors   = <span class="bold">0</span>
 
PL/SQL procedure successfully completed.

ALTER INDEX po_struct PARAMETERS('<span class="bold">NONBLOCKING COMPLETE</span>');
</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6091"></a><div class="props_rev_3"><a id="GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE" name="GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE"></a><h5 id="ADXDB-GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE" class="sect5"><span class="enumeration_section">6.3.7.4 </span>Modifying the Data Type of a Structured XMLIndex Component
                     </h5>
                     <div>
                        <p>If an error is raised because some of your data does not match the data type used for the corresponding column of the structured <code class="codeph">XMLIndex</code> component, you can in some cases simply modify the index by passing keyword <code class="codeph">MODIFY_COLUMN_TYPE</code> to <code class="codeph">ALTER INDEX</code>. 
                        </p>
                        <div class="section">
                           <p>You can, for example, expand a <code class="codeph">VARCHAR2(30)</code> column to, say, <code class="codeph">VARCHAR2(40)</code> if it needs to accommodate data that is up to 40 characters. This is simpler and more efficient than dropping the column and then adding a new column. The new data type must be compatible with the old one: the same restrictions apply as apply for <code class="codeph">ALTER TABLE MODIFY COLUMN</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-2EAC8FBB-0C71-4E9E-BE9E-6BCF5E4D28BE__GUID-0C615772-8565-4D18-863B-5B122B496919">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about <code class="codeph">ALTER TABLE MODIFY COLUMN</code></p>
                              </li>
                              <li>
                                 <p><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__CEGEABGE">modify_column_type_clause :==</a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5829"></a><a id="ADXDB6092"></a><div class="props_rev_3"><a id="GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8" name="GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8"></a><h5 id="ADXDB-GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8" class="sect5"><span class="enumeration_section">6.3.7.5 </span>Dropping an XMLIndex Structured Component
                     </h5>
                     <div>
                        <p>If an <code class="codeph">XMLIndex</code> index has both an unstructured and a structured component, then you can use <code class="codeph">ALTER INDEX</code> to drop the structured component. You do this by dropping <span class="italic">all</span> of the structure groups that compose the structured component. 
                        </p>
                        <div class="section">
                           <p><a href="indexes-for-XMLType-data.html#GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">Example 6-25</a> shows how to drop the structured component that was added in <a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a>, by dropping its only structure group, <code class="codeph">po_item</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D3269FF1-D89D-43DE-B4EC-8C43D5B2F5F8__BCGJGJAD">
                           <p class="titleinexample">Example 6-25 Dropping an XMLIndex Structured Component</p><pre class="pre codeblock"><code>ALTER INDEX po_xmlindex_ix PARAMETERS('DROP_GROUP GROUP po_item');
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4371"></a><a id="ADXDB6093"></a><div class="props_rev_3"><a id="GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9" name="GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9"></a><h5 id="ADXDB-GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9" class="sect5"><span class="enumeration_section">6.3.7.6 </span>Indexing the Relational Tables of a Structured XMLIndex Component
                     </h5>
                     <div>
                        <p>Because the tables used for the structured component of an <code class="codeph">XMLIndex</code> index are normal relational tables, you can index them using any standard relational indexes. 
                        </p>
                        <div class="section">
                           <p>This is explained in section <a href="indexes-for-XMLType-data.html#GUID-2DC9E402-5C06-4AED-B04B-C37B687DB6BB" title="You create and use the structured component of an XMLIndex index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.">XMLIndex Structured Component</a>. It is illustrated by <a href="indexes-for-XMLType-data.html#GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">Example 6-26</a>, which creates a B-tree index on the <code class="codeph">reference</code> column of the index content table (structured fragment) for the <code class="codeph">XMLIndex</code> index of <a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a>. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-3958CA0D-1C5B-47C3-B68F-7B6EF9E5BFA9__BCGEGABJ">
                           <p class="titleinexample">Example 6-26 Creating a B-tree Index on an XMLIndex Index Content Table</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX idx_tab_ref_ix ON po_idx_tab (reference);</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-476331FD-F58B-4980-BECD-015F0A794AC9" title="An XMLIndex structured component indexes specific islands of structure in your XML data.">Use of XMLIndex with a Structured Component</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4373"></a><a id="ADXDB4374"></a><a id="ADXDB4375"></a><a id="ADXDB4376"></a><a id="ADXDB4377"></a><a id="ADXDB4372"></a><div class="props_rev_3"><a id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" name="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52"></a><h4 id="ADXDB-GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52" class="sect4"><span class="enumeration_section">6.3.8 </span>How to Tell Whether XMLIndex is Used
                  </h4>
                  <div>
                     <p>To know whether a particular <code class="codeph">XMLIndex</code> index has been used in resolving a query, you can examine an execution plan for the query. 
                     </p>
                     <p>It is at query compile time that Oracle Database determines whether or not a given <code class="codeph">XMLIndex</code> index can be used, that is, whether the query can be rewritten into a query against the index. 
                     </p>
                     <p>For an unstructured <code class="codeph">XMLIndex</code> component, if it cannot be determined at compile time that an XPath expression in the query is a subset of the paths you specified to be used for <code class="codeph">XMLIndex</code> indexing, then the unstructured component of the index is not used.
                     </p>
                     <p>For example, if the path <code class="codeph">/PurchaseOrder/LineItems//*</code> is included for indexing, then a query with <code class="codeph">/PurchaseOrder/LineItems/LineItem/Description</code> can use the index, but a query with <code class="codeph">//Description</code> cannot. The latter also matches potential <code class="codeph">Description</code> elements that are not children of <code class="codeph">/PurchaseOrder/LineItems</code>, and it is not possible at compile time to know if such additional <code class="codeph">Description</code> elements are present in the data.
                     </p>
                     <p>You can examine the execution plan for a query to see whether a particular <code class="codeph">XMLIndex</code> index has been used in resolving the query. 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If the <span class="italic">unstructured</span> component of the index is used, then its path table, order key, or path id is referenced in the execution plan. The execution plan does <span class="italic">not</span> directly indicate that a domain index was used; it does <span class="italic">not</span> refer to the <code class="codeph">XMLIndex</code> index by name. See <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">Example 6-27</a> and <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-29</a>.
                           </p>
                        </li>
                        <li>
                           <p>If the <span class="italic">structured</span> component of the index is used, then one or more of its index content tables is called out in the execution plan. See <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-30</a> and <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">Example 6-31</a>.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__GUID-BA086F5D-40BD-4DC7-BAC8-3B3D238BCFE6">
                        <p class="notep1">See Also:</p>
                        <p><a href="../tgsql/query-execution-plans.html#TGSQL-GUID-BE44BB45-C061-4F3A-8F18-4AAC5F74C68A" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a></p>
                     </div>
                     <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">Example 6-27</a> shows that the <code class="codeph">XMLIndex</code> index created in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-10</a> is used in a particular query. The reference to <code class="codeph">MY_PATH_TABLE</code> in the execution plan here indicates that the <code class="codeph">XMLIndex</code> index (created in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDJCDCF">Example 6-10</a>) is used in this query. Similarly, reference to columns <code class="codeph">LOCATOR</code>, <code class="codeph">ORDER_KEY</code>, and <code class="codeph">PATHID</code> indicates the same thing.
                     </p>
                     <p>Given the name of a path table from an execution plan such as this, you can obtain the name of its <code class="codeph">XMLIndex</code> index as shown in <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">Example 6-28</a>. (This is more or less opposite to the query in <a href="indexes-for-XMLType-data.html#GUID-07D1AAE8-0B4B-4DAC-806C-3DE4CA0A4246__CHDBCCHJ">Example 6-11</a>.)
                     </p>
                     <p><code class="codeph">XMLIndex</code> can be used for XPath expressions in the <code class="codeph">SELECT</code> list, the <code class="codeph">FROM</code> list, and the <code class="codeph">WHERE</code> clause of a query, and it is useful for SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLTable</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code>. Unlike function-based indexes, which are deprecated for <code class="codeph">XMLType</code>, <code class="codeph">XMLIndex</code> indexes can be used when you extract data from an XML fragment in a document.
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-29</a> illustrates this.
                     </p>
                     <p>The execution plan for the query in <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-29</a> shows, by referring to the path table, that <code class="codeph">XMLIndex</code> is used. It also shows the use of Oracle internal SQL function <code class="codeph">sys_orderkey_depth</code>see <a href="indexes-for-XMLType-data.html#GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" title="There are several guidelines that can help you use XMLIndex with an unstructured component.">Guidelines for Using XMLIndex with an Unstructured Component</a>.
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-30</a> shows an execution plan that indicates that the <code class="codeph">XMLIndex</code> index created in <a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a> is picked up for a query that uses two <code class="codeph">WHERE</code> clause predicates. It is the same query as in <a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-46</a>, and the same XML search index is in effect, as is also shown in the execution plan.
                     </p>
                     <p>With only the unstructured <code class="codeph">XMLIndex</code> component, the query would have involved a join of the path table to itself, because of the two different paths in the <code class="codeph">WHERE</code> clause.
                     </p>
                     <p>The presence in <a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">Example 6-30</a> of the path table name, <code class="codeph">path_tab</code>, indicates that the unstructured component of the index is used. The presence of the index content table <code class="codeph">po_idx_tab</code> indicates that the structured index component is used. The presence of the XML search index, <code class="codeph">po_ctx_idx</code>, indicates that it too is used.
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">Example 6-31</a> shows an execution plan that indicates that the same <code class="codeph">XMLIndex</code> index is also picked up for a query that uses multilevel <code class="codeph">XMLTable</code> chaining. With only the unstructured <code class="codeph">XMLIndex</code> component, this query too would involve a join of the path table to itself, because of the different paths in the two <code class="codeph">XMLTable</code> function calls.
                     </p>
                     <p>The execution plan shows direct access to the relational index content tables, <code class="codeph">po_idx_tab</code> and <code class="codeph">po_index_lineitem</code>. There is <span class="italic">no</span> access at all to the path table, <code class="codeph">path_tab</code>.
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDDJDGI">
                        <p class="titleinexample">Example 6-27 Checking Whether an XMLIndex Unstructured Component Is Used</p><pre class="pre codeblock"><code>SET AUTOTRACE ON EXPLAIN

SELECT XMLQuery('/PurchaseOrder/Requestor' PASSING OBJECT_VALUE RETURNING CONTENT) FROM po_binxml
  WHERE XMLExists('/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]' PASSING OBJECT_VALUE);
 
XMLQUERY('/PURCHASEORDER/REQUESTOR'PASSINGOBJECT_VALUERETURNINGCONTENT)
-----------------------------------------------------------------------
&lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
 
1 row selected.
 
 
Execution Plan
<span class="bold">. . .</span>
----------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   1 |  SORT GROUP BY                  |                              |     1 |  3524 |            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID   | MY_PATH_TABLE                |     2 |  7048 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN             | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     2   (0)| 00:00:01 |
|   4 |  NESTED LOOPS                   |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   5 |   VIEW                          | VW_SQ_1                      |     1 |    12 |    26   (0)| 00:00:01 |
|   6 |    HASH UNIQUE                  |                              |     1 |  5046 |            |          |
|   7 |     NESTED LOOPS                |                              |     1 |  5046 |    26   (0)| 00:00:01 |
|*  8 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    24   (0)| 00:00:01 |
|*  9 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |     1   (0)| 00:00:01 |
|* 10 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |     2   (0)| 00:00:01 |
|* 11 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     1   (0)| 00:00:01 |
|  12 |   TABLE ACCESS BY USER ROWID    | PO_BINXML                    |     1 |    12 |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P0"."<span class="bold">LOCATOR</span>")=1)
   3 - access("SYS_P0"."RID"=:B1 AND "SYS_P0"."<span class="bold">PATHID</span>"=HEXTORAW('76E2') )
   8 - filter("SYS_P4"."VALUE"='SBELL-2002100912333601PDT' AND "SYS_P4"."<span class="bold">PATHID</span>"=HEXTORAW('4F8C')  AND
              SYS_XMLI_LOC_ISNODE("SYS_P4"."<span class="bold">LOCATOR</span>")=1)
   9 - access(SUBSTRB("VALUE",1,1599)='SBELL-2002100912333601PDT')
  10 - filter(SYS_XMLI_LOC_ISNODE("SYS_P2"."<span class="bold">LOCATOR</span>")=1)
  11 - access("SYS_P4"."RID"="SYS_P2"."RID" AND "SYS_P2"."PATHID"=HEXTORAW('4E36')  AND
              "SYS_P2"."<span class="bold">ORDER_KEY</span>"&lt;"SYS_P4"."<span class="bold">ORDER_KEY</span>")
       filter("SYS_P4"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>") AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>")+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P4"."<span class="bold">ORDER_KEY</span>"))
<span class="bold">. . .</span>
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDBCJIG">
                        <p class="titleinexample">Example 6-28 Obtaining the Name of an XMLIndex Index from Its Path-Table Name</p><pre class="pre codeblock"><code>SELECT INDEX_NAME FROM USER_XML_INDEXES WHERE PATH_TABLE_NAME = 'MY_PATH_TABLE';
 
INDEX_NAME
------------------------------
PO_XMLINDEX_IX
 
1 row selected.
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">
                        <p class="titleinexample">Example 6-29 Extracting Data from an XML Fragment Using XMLIndex</p><pre class="pre codeblock"><code>SET AUTOTRACE ON EXPLAIN</code></pre><pre class="pre codeblock"><code> 
SELECT li.description, li.itemno
  FROM po_binxml, XMLTable('/PurchaseOrder/LineItems/LineItem'
                           PASSING OBJECT_VALUE
                           COLUMNS "DESCRIPTION" VARCHAR(40) PATH 'Description',
                                   "ITEMNO"      INTEGER     PATH '@ItemNumber') li
  WHERE XMLExists('/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE);
 
DESCRIPTION                                  ITEMNO
---------------------------------------- ----------
A Night to Remember                               1
The Unbearable Lightness Of Being                 2
Sisters                                           3
 
3 rows selected.</code></pre><pre class="pre codeblock"><code>
Execution Plan

----------------------------------------------------------------------------------------------------------------
| Id  | Operation                         | Name                         | Rows  | Bytes |Cost (%CPU)| Time    |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |                              |     1 |  1546 |   30   (4)|00:00:01 |
|*  1 |  FILTER                           |                              |       |       |           |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  3 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|*  4 |  FILTER                           |                              |       |       |           |         |
|*  5 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  6 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|   7 |  NESTED LOOPS                     |                              |       |       |           |         |
|   8 |   NESTED LOOPS                    |                              |     1 |  1546 |   30   (4)|00:00:01 |
|   9 |    NESTED LOOPS                   |                              |     1 |    24 |   28   (4)|00:00:01 |
|  10 |     VIEW                          | VW_SQ_1                      |     1 |    12 |   26   (0)|00:00:01 |
|  11 |      HASH UNIQUE                  |                              |     1 |  5046 |           |         |
|  12 |       NESTED LOOPS                |                              |     1 |  5046 |   26   (0)|00:00:01 |
|* 13 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |   24   (0)|00:00:01 |
|* 14 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |    1   (0)|00:00:01 |
|* 15 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
|* 16 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|  17 |     TABLE ACCESS BY USER ROWID    | PO_BINXML                    |     1 |    12 |    1   (0)|00:00:01 |
|* 18 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|* 19 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P2"."<span class="bold">LOCATOR</span>")=1)
   3 - access("SYS_P2"."RID"=:B1 AND "SYS_P2"."<span class="bold">PATHID</span>"=HEXTORAW('28EC')  AND "SYS_P2"."ORDER_KEY"&gt;:B2 AND
              "SYS_P2"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>")=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
   4 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   5 - filter(SYS_XMLI_LOC_ISNODE("SYS_P5"."<span class="bold">LOCATOR</span>")=1)
   6 - access("SYS_P5"."RID"=:B1 AND "SYS_P5"."<span class="bold">PATHID</span>"=HEXTORAW('60E0')  AND "SYS_P5"."<span class="bold">ORDER_KEY</span>"&gt;:B2 AND
              "SYS_P5"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P5"."<span class="bold">ORDER_KEY</span>")=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
  13 - filter("SYS_P10"."VALUE"='SBELL-2002100912333601PDT' AND "SYS_P10"."<span class="bold">PATHID</span>"=HEXTORAW('4F8C')  AND
              SYS_XMLI_LOC_ISNODE("SYS_P10"."<span class="bold">LOCATOR</span>")=1)
  14 - access(SUBSTRB("VALUE",1,1599)='SBELL-2002100912333601PDT')
  15 - filter(SYS_XMLI_LOC_ISNODE("SYS_P8"."<span class="bold">LOCATOR</span>")=1)
  16 - access("SYS_P10"."RID"="SYS_P8"."RID" AND "SYS_P8"."<span class="bold">PATHID</span>"=HEXTORAW('4E36')  AND
              "SYS_P8"."<span class="bold">ORDER_KEY</span>"&lt;"SYS_P10"."<span class="bold">ORDER_KEY</span>")
       filter("SYS_P10"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>("SYS_P8"."<span class="bold">ORDER_KEY</span>") AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P8"."<span class="bold">ORDER_KEY</span>")+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P10"."<span class="bold">ORDER_KEY</span>"))
  18 - access("PO_BINXML".ROWID="SYS_ALIAS_4"."RID" AND "SYS_ALIAS_4"."<span class="bold">PATHID</span>"=HEXTORAW('3748') )
  19 - filter(SYS_XMLI_LOC_ISNODE("SYS_ALIAS_4"."<span class="bold">LOCATOR</span>")=1)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGEFFEG">
                        <p class="titleinexample">Example 6-30 Using a Structured XMLIndex Component for a Query with Two Predicates</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR
  SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem'
                  PASSING OBJECT_VALUE RETURNING CONTENT)
    FROM po_binxml
    WHERE XMLExists('/PurchaseOrder/LineItems/LineItem
                     [Description contains text "Picnic"]'
                    PASSING OBJECT_VALUE)
      AND XMLExists('/PurchaseOrder[User="SBELL"]' PASSING OBJECT_VALUE);
 
Explained.
 </code></pre><pre class="pre codeblock"><code>----------------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name                         |Rows|Bytes| Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |                              |   1| 2051|     9   (0)| 00:00:01 |
|   1 |  SORT GROUP BY                       |                              |   1| 3524|            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID BATCHED| <span class="bold">PATH_TAB</span>                     |   2| 7048|     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN                  | SYS86751_PO_XMLINDE_PIKEY_IX |   1|     |     2   (0)| 00:00:01 |
|   4 |  NESTED LOOPS SEMI                   |                              |   1| 2051|     6   (0)| 00:00:01 |
|   5 |   TABLE ACCESS BY INDEX ROWID        | PO_BINXML                    |   1| 2024|     4   (0)| 00:00:01 |
|*  6 |    DOMAIN INDEX                      | <span class="bold">PO_CTX_IDX</span>                   |    |     |     4   (0)| 00:00:01 |
|*  7 |   TABLE ACCESS BY INDEX ROWID BATCHED| <span class="bold">PO_IDX_TAB</span>                   |  13|  351|     2   (0)| 00:00:01 |
|*  8 |    INDEX RANGE SCAN                  | SYS86751_86755_OID_IDX       |   1|     |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P1"."LOCATOR")=1)
   3 - access("SYS_P1"."RID"=:B1 AND "SYS_P1"."PATHID"=HEXTORAW('3748') )
   6 - access("CTXSYS"."CONTAINS"(SYS_MAKEXML(0,"XMLDATA"),'&lt;query&gt;&lt;textquery grammar="CONTEXT"
              lang="english"&gt;{Picnic} INPATH
              (/PurchaseOrder/LineItems/LineItem/Description)&lt;/textquery&gt;&lt;xquery&gt;&lt;offset&gt;0&lt;/
              offset&gt;&lt;/xquery&gt;&lt;/query&gt;')&gt;0)
   7 - filter("SYS_SXI_0"."USERNAME"='SBELL')
   8 - access("PO_BINXML"."SYS_NC_OID$"="SYS_SXI_0"."OID")
 
Note
-----
   - dynamic sampling used for this statement (level=2)
 
30 rows selected.</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__BCGJEDEA">
                        <p class="titleinexample">Example 6-31 Using a Structured XMLIndex Component for a Query with Multilevel Chaining</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR
  SELECT po.reference, li.*
    FROM po_binxml p,
         XMLTable('/PurchaseOrder' PASSING p.OBJECT_VALUE
                  COLUMNS reference   VARCHAR2(30)  PATH 'Reference',
                          lineitem    XMLType       PATH 'LineItems/LineItem') po,
         XMLTable('/LineItem' PASSING po.lineitem
                  COLUMNS itemno      BINARY_DOUBLE PATH '@ItemNumber',
                          description VARCHAR2(256) PATH 'Description',
                          partno      VARCHAR2(14)  PATH 'Part/@Id',
                          quantity    BINARY_DOUBLE PATH 'Part/@Quantity',
                          unitprice   BINARY_DOUBLE PATH 'Part/@UnitPrice') li
    WHERE po.reference = 'SBELL-20021009123335280PDT';
 </code></pre><pre class="pre codeblock"><code>-------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                   | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                        |    17 | 20366 |     8   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                |                        |       |       |            |          |
|   2 |   NESTED LOOPS               |                        |    17 | 20366 |     8   (0)| 00:00:01 |
|   3 |    NESTED LOOPS              |                        |     1 |   539 |     3   (0)| 00:00:01 |
|*  4 |     TABLE ACCESS FULL        | <span class="bold">PO_IDX_TAB</span>             |     1 |   529 |     3   (0)| 00:00:01 |
|*  5 |     INDEX UNIQUE SCAN        | SYS_C007442            |     1 |    10 |     0   (0)| 00:00:01 |
|*  6 |    INDEX RANGE SCAN          | SYS86751_86759_PKY_IDX |    17 |       |     1   (0)| 00:00:01 |
|   7 |   TABLE ACCESS BY INDEX ROWID| <span class="bold">PO_INDEX_LINEITEM</span>      |    17 | 11203 |     5   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter("SYS_SXI_2"."REFERENCE"='SBELL-20021009123335280PDT')
   5 - access("P"."SYS_NC_OID$"="SYS_SXI_2"."OID")
   6 - access("SYS_SXI_2"."KEY"="SYS_SXI_3"."PKEY")
 
Note
-----
   - dynamic sampling used for this statement
 
25 rows selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" title="The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4379"></a><a id="ADXDB4378"></a><div class="props_rev_3"><a id="GUID-572DB598-0A31-4143-889B-98D883211FC6" name="GUID-572DB598-0A31-4143-889B-98D883211FC6"></a><h4 id="ADXDB-GUID-572DB598-0A31-4143-889B-98D883211FC6" class="sect4"><span class="enumeration_section">6.3.9 </span>Turning Off Use of XMLIndex
                  </h4>
                  <div>
                     <p>You can turn off the use of <code class="codeph">XMLIndex</code> by using optimizer hint: <code class="codeph">/*+ NO_XML_QUERY_REWRITE */</code> or optimizer hint <code class="codeph">/*+ NO_XMLINDEX_REWRITE */</code>.
                     </p>
                     <div class="section">
                        <p>Each of these hints turns off the use of <span class="italic">all</span> <code class="codeph">XMLIndex</code> indexes. In addition to turning off the use of <code class="codeph">XMLIndex</code>, <code class="codeph">NO_XML_QUERY_REWRITE</code> turns off all XQuery optimization (<code class="codeph">XMLIndex</code> is part of XPath rewrite). 
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-572DB598-0A31-4143-889B-98D883211FC6__CHDBJFGE">Example 6-32</a> shows the use of these optimizer hints.
                        </p>
                        <div class="infoboxnote" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__GUID-2D3954A8-2FC9-476C-B405-525E36C71E8A">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">NO_INDEX</code> optimizer hint does not apply to <code class="codeph">XMLIndex</code>.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__GUID-E5938908-5F06-474D-BC76-9F29CF512045">
                           <p class="notep1">See Also:</p>
                           <p><a href="xquery-and-XML-DB.html#GUID-11B622EC-8551-43E9-BE1C-1E5EBE777C9E" title="The optional XQuery features that are not supported by Oracle XML&nbsp;DB are specified.">XQuery Optional Features</a> for information about XQuery pragmas <code class="codeph">ora:no_xmlquery_rewrite</code> and <code class="codeph">ora:xmlquery_rewrite</code>, which you can use for fine-grained control of XQuery optimization
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-572DB598-0A31-4143-889B-98D883211FC6__CHDBJFGE">
                        <p class="titleinexample">Example 6-32 Turning Off XMLIndex Using Optimizer Hints</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="bold">/*+ NO_XMLINDEX_REWRITE */</span> 
  count(*) FROM po_binxml WHERE XMLExists('$p/*' PASSING OBJECT_VALUE AS "p");

SELECT <span class="bold">/*+ NO_XML_QUERY_REWRITE */</span>
  count(*) FROM po_binxml WHERE XMLExists('$p/*' PASSING OBJECT_VALUE AS "p");
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4380"></a><div class="props_rev_3"><a id="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" name="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8"></a><h4 id="ADXDB-GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" class="sect4"><span class="enumeration_section">6.3.10 </span>XMLIndex Path Subsetting: Specifying the Paths You Want to Index
                  </h4>
                  <div>
                     <p> If you know which XPath expressions you are most likely to query then you can narrow the focus of <code class="codeph">XMLIndex</code> indexing and thus improve performance.
                     </p>
                     <div class="section">
                        <p>One of the advantages of an <code class="codeph">XMLIndex</code> index with an unstructured component is that it is very general: you need not specify which XPath locations to index; you need no prior knowledge of the XPath expressions that will be queried. By default, an unstructured <code class="codeph">XMLIndex</code> component indexes all possible XPath locations in your XML data.
                        </p>
                        <p>However, if you are aware of the XPath expressions that you are most likely to query, then you can narrow the focus of <code class="codeph">XMLIndex</code> indexing and thus improve performance. Having fewer indexed nodes means less space is required for indexing, which improves index maintenance during DML operations. Having fewer indexed nodes improves DDL performance, and having a smaller path table improves query performance.
                        </p>
                        <p>You narrow the focus of indexing by pruning the set of XPath expressions (paths) corresponding to XML fragments to be indexed, specifying a subset of all possible paths. You can do this in two alternative ways:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Exclusion &#x2013; Start with the default behavior of including all possible XPath expressions, and exclude some of them from indexing.</p>
                           </li>
                           <li>
                              <p>Inclusion &#x2013; Start with an empty set of XPath expressions to be used in indexing, and add paths to this inclusion set.</p>
                           </li>
                        </ul>
                        <p>You can specify path subsetting either when you create an <code class="codeph">XMLIndex</code> index using <code class="codeph">CREATE INDEX</code> or when you modify it using <code class="codeph">ALTER INDEX</code>. In both cases, you provide the subsetting information in the <code class="codeph">PATHS</code> parameter of the statement's <code class="codeph">PARAMETERS</code> clause. For exclusion, you use keyword <code class="codeph">EXCLUDE</code>. For inclusion, you use keyword <code class="codeph">INCLUDE</code> for <code class="codeph">ALTER INDEX</code> and no keyword for <code class="codeph">CREATE INDEX</code> (list the paths to include). You can also specify namespace mappings for the nodes targeted by the <code class="codeph">PATHS</code> parameter.
                        </p>
                        <p>For <code class="codeph">ALTER INDEX</code>, keyword <code class="codeph">INCLUDE</code> or <code class="codeph">EXCLUDE</code> is followed by keyword <code class="codeph">ADD</code> or <code class="codeph">REMOVE</code>, to indicate whether the list of paths that follows the keyword is to be added or removed from the inclusion or exclusion list. For example, this statement adds path <code class="codeph">/PurchaseOrder/Reference</code> to the list of paths to be excluded from indexing:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS ('PATHS (<span class="bold">EXCLUDE ADD</span> (/PurchaseOrder/Reference))');
</pre><p>To alter an <code class="codeph">XMLIndex</code> index so that it <span class="italic">includes all</span> possible paths, use keyword <code class="codeph">INDEX_ALL_PATHS</code>. See <a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFAECD">alter_index_paths_clause ::=</a>.
                        </p>
                        <div class="infoboxnote" id="GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8__GUID-935A6ECE-04FD-4C8F-B3D1-BAF2C47FE4C4">
                           <p class="notep1">Note:</p>
                           <p>If you create an <code class="codeph">XMLIndex</code> index that has both structured and unstructured components, then, by default, any nodes indexed in the structured component are also indexed in the unstructured component; that is, they are <span class="italic">not</span> automatically <span class="italic">excluded</span> from the unstructured component. If you do not want unstructured <code class="codeph">XMLIndex</code> indexing to apply to them, then you must explicitly use path subsetting to exclude them.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC">Examples of XMLIndex Path Subsetting</a><br>Some examples are presented of defining <code class="codeph">XMLIndex</code> indexes on subsets of XPath expressions.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6">XMLIndex Path-Subsetting Rules</a><br>Rules that apply to <code class="codeph">XMLIndex</code> path subsetting are described.
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" title="The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4382"></a><a id="ADXDB4383"></a><a id="ADXDB4384"></a><a id="ADXDB4381"></a><div class="props_rev_3"><a id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC" name="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC"></a><h5 id="ADXDB-GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC" class="sect5"><span class="enumeration_section">6.3.10.1 </span>Examples of XMLIndex Path Subsetting
                     </h5>
                     <div>
                        <p>Some examples are presented of defining <code class="codeph">XMLIndex</code> indexes on subsets of XPath expressions.
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDIHICC">
                           <p class="titleinexample">Example 6-33 XMLIndex Path Subsetting with CREATE INDEX</p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('PATHS (INCLUDE (/PurchaseOrder/LineItems//* 
                               /PurchaseOrder/Reference))');
</code></pre><p>This statement creates an index that indexes only top-level element <code class="codeph">PurchaseOrder</code> and some of its children, as follows: 
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All <code class="codeph">LineItems</code> elements and their descendants
                                 </p>
                              </li>
                              <li>
                                 <p>All <code class="codeph">Reference</code> elements
                                 </p>
                              </li>
                           </ul>
                           <p>It does that by including the specified paths, starting with an empty set of paths to be used for the index.</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__GUID-E04EB35A-D17B-498B-8017-D15482134C69">
                           <p class="titleinexample">Example 6-34 XMLIndex Path Subsetting with ALTER INDEX</p><pre class="pre codeblock"><code>ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS ('PATHS (INCLUDE ADD (/PurchaseOrder/Requestor 
                                   /PurchaseOrder/Actions/Action//*))');
</code></pre><p>This statement adds two more paths to those used for indexing. These paths index element <code class="codeph">Requestor</code> and descendants of element <code class="codeph">Action</code> (and their ancestors).
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-F5B41C22-4273-45A8-9BD5-32B7EE3773AC__CHDJEICC">
                           <p class="titleinexample">Example 6-35 XMLIndex Path Subsetting Using a Namespace Prefix</p>
                           <p>If an XPath expression to be used for <code class="codeph">XMLIndex</code> indexing uses namespace prefixes, you can use a <code class="codeph">NAMESPACE MAPPING</code> clause to the <code class="codeph">PATHS</code> list, to specify those prefixes. Here is an example:
                           </p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('PATHS (INCLUDE (/PurchaseOrder/LineItems//*   /PurchaseOrder/<span class="bold">ipo:</span>Reference)
                     NAMESPACE MAPPING (xmlns="http://xmlns.oracle.com"
                                        xmlns:<span class="bold">ipo</span>="http://xmlns.oracle.com/ipo"))');</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4385"></a><div class="props_rev_3"><a id="GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6" name="GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6"></a><h5 id="ADXDB-GUID-24CE95A6-9C40-4DC0-BE58-E2B33C996BC6" class="sect5"><span class="enumeration_section">6.3.10.2 </span>XMLIndex Path-Subsetting Rules
                     </h5>
                     <div>
                        <p>Rules that apply to <code class="codeph">XMLIndex</code> path subsetting are described.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The paths must reference only child and descendant axes, and they must test only element and attribute nodes or their names (possibly using wildcards). In particular, the paths must not involve predicates.</p>
                              </li>
                              <li>
                                 <p>You cannot specify both path exclusion and path inclusion; choose one or the other.</p>
                              </li>
                              <li>
                                 <p>If an index was created using path exclusion (inclusion), then you can modify it using only path exclusion (inclusion)index modification must either further restrict or further extend the path subset. For example, you cannot create an index that includes certain paths and subsequently modify it to exclude certain paths.</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-9ADFFD10-BFF1-4807-9FF0-C323DC2A70D8" title="If you know which XPath expressions you are most likely to query then you can narrow the focus of XMLIndex indexing and thus improve performance.">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4386"></a><div class="props_rev_3"><a id="GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" name="GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF"></a><h4 id="ADXDB-GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF" class="sect4"><span class="enumeration_section">6.3.11 </span>Guidelines for Using XMLIndex with an Unstructured Component
                  </h4>
                  <div>
                     <p>There are several guidelines that can help you use <code class="codeph">XMLIndex</code> with an unstructured component.
                     </p>
                     <p>These guidelines are applicable only when the two alternatives discussed return the same result set.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Avoid prefixing <code class="codeph">//</code> with ancestor elements. For example, use <code class="codeph">//c</code>, <span class="italic">not</span> <span class="bold"><code class="codeph">/a/b</code></span><code class="codeph">//c</code>, provided these return the same result set.
                           </p>
                        </li>
                        <li>
                           <p>Avoid prefixing <code class="codeph">/*</code> with ancestor elements. For example, use <code class="codeph">/*/*/*</code>, <span class="italic">not</span> <span class="bold"><code class="codeph">/a</code></span><code class="codeph">/*/*</code>, provided these return the same result set.
                           </p>
                        </li>
                        <li>
                           <p>In a <code class="codeph">WHERE</code> clause, use <code class="codeph">XMLExists</code> rather than <code class="codeph">XMLCast</code> of <code class="codeph">XMLQuery</code>. This can allow optimization that, in effect, invokes a subquery against the path-table <code class="codeph">VALUE</code> column. For example, use this:
                           </p><pre class="pre codeblock"><code>SELECT count(*) FROM purchaseorder p 
  WHERE 
    XMLExists('$p/PurchaseOrder/LineItems/LineItem/Part[@Id="715515011020"]'
                  PASSING OBJECT_VALUE AS "p");
</code></pre><p>Do not use this:</p><pre class="pre codeblock"><code>SELECT count(*) FROM purchaseorder p
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem/Part/@Id'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                AS VARCHAR2(14))
        = "715515011020";
</code></pre></li>
                        <li>
                           <p>When possible, use <code class="codeph">count(*)</code>, <span class="italic">not</span> <code class="codeph">count(XMLCast(XMLQuery(...))</code>, in a <code class="codeph">SELECT</code> clause. For example, if you know that a <code class="codeph">LineItem</code> element in a purchase-order document has only one <code class="codeph">Description</code> child, use this:
                           </p><pre class="pre codeblock"><code>SELECT count(*) FROM po_binxml, XMLTable('//LineItem' PASSING OBJECT_VALUE);
</code></pre><p>Do not use this:</p><pre class="pre codeblock"><code>SELECT count(li.value)
 FROM po_binxml p, XMLTable('//LineItem' PASSING p.OBJECT_VALUE
                            COLUMNS value VARCHAR2(30) PATH 'Description') li;
</code></pre></li>
                        <li>
                           <p>Reduce the number of XPath expressions used in a query <code class="codeph">FROM</code> list as much as possible. For example, use this:
                           </p><pre class="pre codeblock"><code>SELECT li.description
  FROM po_binxml p,
       XMLTable('PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</code></pre><p>Do not use this:</p><pre class="pre codeblock"><code>SELECT li.description
  FROM po_binxml p,
       XMLTable('PurchaseOrder/LineItems' PASSING p.OBJECT_VALUE) ls,
       XMLTable('LineItems/LineItem'      PASSING ls.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</code></pre></li>
                        <li>
                           <p>If you use an XPath expression in a query to drill down inside a virtual table (created, for example, using SQL/XML function <code class="codeph">XMLTable</code>), then create a secondary index on the order key of the path table using Oracle SQL function <code class="codeph">sys_orderkey_depth</code>. Here is an example of such a query; the selection navigates to element <code class="codeph">Description</code> inside virtual line-item table <code class="codeph">li</code>. 
                           </p><pre class="pre codeblock"><code>SELECT li.description
  FROM po_binxml p,
       XMLTable('PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</code></pre><p>Such queries are evaluated using function <code class="codeph">sys_orderkey_depth</code>, which returns the depth of the order-key value. Because the order index uses two columns, the index needed is a <span class="italic">composite</span> index over columns <code class="codeph">ORDER_KEY</code> and <code class="codeph">RID</code>, as well as over function <code class="codeph">sys_orderkey_depth</code> applied to the <code class="codeph">ORDER_KEY</code> value. For example: 
                           </p><pre class="pre codeblock"><code>CREATE INDEX depth_ix ON my_path_table
  (RID, sys_orderkey_depth(ORDER_KEY), ORDER_KEY);</code></pre><div class="infoboxnotealso" id="GUID-B8CF16F3-CA51-40A0-B654-82BFA54C85EF__GUID-66114AB1-EC95-4DAF-89AF-B96B17694886">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-54B95128-EFC2-4EA5-9E05-753DC572BF52__CHDIEGBF">Example 6-29</a> for an example that shows the use of <code class="codeph">sys_orderkey_depth</code></p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6001"></a><div class="props_rev_3"><a id="GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821" name="GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821"></a><h4 id="ADXDB-GUID-B8FCC742-EE57-4B86-8B61-17CC780A5821" class="sect4"><span class="enumeration_section">6.3.12 </span>Guidelines for Using XMLIndex with a Structured Component
                  </h4>
                  <div>
                     <p>There are several guidelines that can help you use <code class="codeph">XMLIndex</code> with a structured component.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use <code class="codeph">XMLIndex</code> with a structured component to project and index XML data as relational columns. Do not use function-based indexes; they are deprecated for use with XML. See <a href="indexes-for-XMLType-data.html#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a>.
                           </p>
                        </li>
                        <li>
                           <p>Ensure data type correspondence between a query and an <code class="codeph">XMLIndex</code> index that has a structured component. See <a href="indexes-for-XMLType-data.html#GUID-E6F787DD-ED63-41FE-ADB4-7FA8F646B254" title="The relational tables that are used for an XMLIndex structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).">Data Type Considerations for XMLIndex Structured Component</a>.
                           </p>
                        </li>
                        <li>
                           <p>If you create a relational view over <code class="codeph">XMLType</code> data (for example, using SQL function <code class="codeph">XMLTable</code>), then consider also creating an <code class="codeph">XMLIndex</code> index with a structured component that targets the same relational columns. See <a href="relational-views-over-XML-data.html#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="Relational database views over XML data provide conventional, relational access to XML content.">Relational Views over XML Data</a>.
                           </p>
                        </li>
                        <li>
                           <p>Instead of using a single XQuery expression for both fragment extraction and value filtering (search), use SQL/XML function <code class="codeph">XMLQuery</code> in the <code class="codeph">SELECT</code> clause to extract fragments and <code class="codeph">XMLExists</code> in the <code class="codeph">WHERE</code> clause to filter values. 
                           </p>
                           <p>This lets Oracle XML DB evaluate fragment extraction functionally or by using streaming evaluation. For value filtering, this lets Oracle XML&nbsp;DB pick up an <code class="codeph">XMLIndex</code> index that has a relevant structured component. 
                           </p>
                        </li>
                        <li>
                           <p>To order query results, use a SQL <code class="codeph">ORDER BY</code> clause, together with SQL/XML function <code class="codeph">XMLTable</code>. Avoid using the XQuery <code class="codeph">order by</code> clause. This is particularly pertinent if you use an <code class="codeph">XMLIndex</code> index with a structured component.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4398"></a><a id="ADXDB4399"></a><a id="ADXDB4397"></a><div class="props_rev_3"><a id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" name="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652"></a><h4 id="ADXDB-GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" class="sect4"><span class="enumeration_section">6.3.13 </span>XMLIndex Partitioning and Parallelism
                  </h4>
                  <div>
                     <p>If you partition an <code class="codeph">XMLType</code> table, or a table with an <code class="codeph">XMLType</code> column, using range, list, or hash partitioning, you can also create an <code class="codeph">XMLIndex</code> index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.
                     </p>
                     <div class="section">
                        <p>To ensure parallel index creation and maintenance, you  use a <code class="codeph">PARALLEL</code> clause (with optional degree) when creating or altering an <code class="codeph">XMLIndex</code> index.
                        </p>
                        <p>If you use the keyword <code class="codeph">LOCAL</code> when you create the <code class="codeph">XMLIndex</code> index, then the index and all of its storage tables are locally equipartitioned with respect to the base table. 
                        </p>
                        <p>If you do not use the keyword <code class="codeph">LOCAL</code> then you cannot create an <code class="codeph">XMLIndex</code> index on a partitioned table. Also, if you composite-partition a table, then you cannot create an <code class="codeph">XMLIndex</code> index on it. 
                        </p>
                        <p>If you use a <code class="codeph">PARALLEL</code> clause and the base table is partitioned or enabled for parallelism, then this can improve the performance for both DML operations (<code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>) and index DDL operations (<code class="codeph">CREATE</code>, <code class="codeph">ALTER</code>, <code class="codeph">REBUILD</code>).
                        </p>
                        <p>Specifying parallelism for an index can also consume more storage, because storage parameters apply separately to each query server process. For example, an index created with an <code class="codeph">INITIAL</code> value of 5M and a parallelism degree of 12 consumes at least 60M of storage during index creation.
                        </p>
                        <p>The syntax for the parallelism clause for <code class="codeph">CREATE INDEX</code> and <code class="codeph">ALTER INDEX</code> is the same as for other domain indexes:
                        </p><pre class="oac_no_warn" dir="ltr">{ NOPARALLEL | PARALLEL [ integer ] }
</pre><p><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-36</a> creates an <code class="codeph">XMLIndex</code> index with a parallelism degree of 10. If the base table is partitioned, then this index is equipartitioned.
                        </p>
                        <p>In <a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">Example 6-36</a>, the path table and the secondary indexes are created with the same parallelism degree as the <code class="codeph">XMLIndex</code> index itself, 10, by inheritance. You can specify different parallelism degrees for these by using separate <code class="codeph">PARALLEL</code> clauses. <a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-37</a> demonstrates this. Again, because of keyword <code class="codeph">LOCAL</code>, if the base table is partitioned, then this index is equipartitioned.
                        </p>
                        <p>In <a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">Example 6-37</a>, the <code class="codeph">XMLIndex</code> index itself is created serially, because of <code class="codeph">NOPARALLEL</code>. The secondary index <code class="codeph">po_pikey_ix</code> is also populated serially, because no parallelism is specified explicitly for it; it inherits the parallelism of the <code class="codeph">XMLIndex</code> index. The path table itself is created with a parallelism degree of 10, and the secondary index value column, <code class="codeph">po_value_ix</code>, is populated with a degree of 5, due to their explicit parallelism specifications.
                        </p>
                        <p>Any parallelism you specify for an <code class="codeph">XMLIndex</code> index, its path table, or its secondary indexes is exploited during subsequent DML operations and queries.
                        </p>
                        <p>There are two places where you can specify parallelism for <code class="codeph">XMLIndex</code>: within the <code class="codeph">PARAMETERS</code> clause parenthetical expression and after it.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__GUID-434DFE6A-FEF3-4AFA-A30F-A53567954909">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information on the <code class="codeph">CREATE INDEX</code> parallel clause
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDGDGFA">
                        <p class="titleinexample">Example 6-36 Creating an XMLIndex Index in Parallel</p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
 <span class="bold"> LOCAL PARALLEL 10</span>;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652__CHDFFICC">
                        <p class="titleinexample">Example 6-37 Using Different PARALLEL Degrees for XMLIndex Internal Objects</p><pre class="pre codeblock"><code>CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
  LOCAL <span class="bold">NOPARALLEL</span> PARAMETERS ('PATH TABLE po_path_table <span class="bold">(PARALLEL 10)</span>
                                PIKEY INDEX po_pikey_ix
                                VALUE INDEX po_value_ix <span class="bold">(PARALLEL 5)</span>');
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" title="The syntax for the PARAMETERS clause for CREATE INDEX and ALTER INDEX is defined.">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a></li>
                           <li><a href="indexes-for-XMLType-data.html#GUID-8153B166-9E19-4A4D-967A-5902ECEB4FA9" title="XMLIndex is used to index XML data that is unstructured or semi-structured, that is, data that generally has little or no fixed structure. It applies to XMLType data that is stored as binary XML.">Structured and Unstructured XMLIndex Components</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4401"></a><a id="ADXDB4402"></a><a id="ADXDB4403"></a><a id="ADXDB4400"></a><div class="props_rev_3"><a id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" name="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940"></a><h4 id="ADXDB-GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" class="sect4"><span class="enumeration_section">6.3.14 </span>Asynchronous (Deferred) Maintenance of XMLIndex Indexes
                  </h4>
                  <div>
                     <p>You can defer the cost of maintaining an <code class="codeph">XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.
                     </p>
                     <p>This feature applies to an <code class="codeph">XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify asynchronous maintenance for an <code class="codeph">XMLIndex</code> index that has a <span class="italic">structured</span> component (even if it also has an unstructured component), then an error is raised.
                     </p>
                     <p>By default, <code class="codeph">XMLIndex</code> indexing is updated (maintained) at each DML operation, so that it remains in sync with the base table. In some situations, you might not require this, and using possibly stale indexes might be acceptable. In that use case, you can decide to defer the cost of index maintenance, performing at commit time only or at some time when database load is reduced. This can improve DML performance. It can also improve index maintenance performance by enabling bulk loading of unsynchronized index rows when an index is synchronized. 
                     </p>
                     <p>Using a stale index has no effect, other than performance, on DML operations. It can have an effect on query results, however: If the index is not up-to-date at query time, then the query results might not be up-to-date either. Even if only one column of a base table is of data type <code class="codeph">XMLType</code>, all queries on that table reflect the database data as of the last synchronization of the <code class="codeph">XMLIndex</code> index on the <code class="codeph">XMLType</code> column.
                     </p>
                     <p>You can specify index maintenance deferment using the parameters clause of a <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code> statement.
                     </p>
                     <p>Be aware that even if you defer synchronization for an <code class="codeph">XMLIndex</code> index, the following database operations automatically synchronize the index:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Any DDL operation on the index &#x2013; <code class="codeph">ALTER INDEX</code> or creation of secondary indexes
                           </p>
                        </li>
                        <li>
                           <p>Any DDL operation on the base table &#x2013; <code class="codeph">ALTER TABLE</code> or creation of another index
                           </p>
                        </li>
                     </ul>
                     <p><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBEJGA" title="This table lists the synchronization options and the ASYNC clause syntax you use to specify them.">Table 6-7</a> lists the synchronization options and the <code class="codeph">ASYNC</code> clause syntax you use to specify them. The <code class="codeph">ASYNC</code> clause is used in the <code class="codeph">PARAMETERS</code> clause of a <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code> statement for <code class="codeph">XMLIndex</code>.
                     </p>
                     <div class="tblformal" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBEJGA">
                        <p class="titleintable">Table 6-7 Index Synchronization</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Index Synchronization" summary="This table lists the synchronization options and the ASYNC clause syntax you use to specify them." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d34642e7587">When to Synchronize</th>
                                 <th align="left" valign="bottom" width="75%" id="d34642e7590">ASYNC Clause Syntax</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d34642e7595" headers="d34642e7587 ">
                                    <p>Always</p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d34642e7595 d34642e7590 ">
                                    <p><code class="codeph">ASYNC (SYNC ALWAYS)</code></p>
                                    <p>This is the default behavior. You can specify it explicitly, to cancel a previous <code class="codeph">ASYNC</code> specification.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d34642e7608" headers="d34642e7587 ">
                                    <p>Upon commit</p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d34642e7608 d34642e7590 ">
                                    <p><code class="codeph">ASYNC (SYNC ON COMMIT)</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d34642e7616" headers="d34642e7587 ">
                                    <p>Periodically</p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d34642e7616 d34642e7590 ">
                                    <p><code class="codeph">ASYNC (SYNC EVERY "</code><span class="italic"><code class="codeph">repeat_interval</code></span><code class="codeph">")</code></p>
                                    <p><span class="italic"><code class="codeph">repeat_interval</code></span> is the same as for the calendaring syntax of <code class="codeph">DBMS_SCHEDULER</code></p>
                                    <p>To use <code class="codeph">EVERY</code>, you must have the <code class="codeph">CREATE JOB</code> privilege.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d34642e7644" headers="d34642e7587 ">
                                    <p>Manually, on demand</p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d34642e7644 d34642e7590 ">
                                    <p><code class="codeph">ASYNC (SYNC MANUAL)</code></p>
                                    <p>You can manually synchronize the index using PL/SQL procedure <code class="codeph">DBMS_XMLINDEX.syncIndex</code>.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Optional <code class="codeph">ASYNC</code> syntax parameter <code class="codeph">STALE</code> is intended for possible future use; you need never specify it explicitly. It has value <code class="codeph">FALSE</code> whenever <code class="codeph">ALWAYS</code> is used; otherwise it has value <code class="codeph">TRUE</code>. Specifying an explicit <code class="codeph">STALE</code> value that contradicts this rule raises an error. 
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-38</a> creates an XMLIndex index that is synchronized every Monday at 3:00 pm, starting tomorrow.
                     </p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">Example 6-39</a> manually synchronizes the index created in <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">Example 6-38</a>. 
                     </p>
                     <p>When <code class="codeph">XMLIndex</code> index synchronization is deferred, all DML changes (inserts, updates, and deletions) made to the base table since the last index synchronization are recorded in a pending table, one row per DML operation. The name of this table is the value of column <code class="codeph">PEND_TABLE_NAME</code> of static public views <code class="codeph">USER_XML_INDEXES</code>, <code class="codeph">ALL_XML_INDEXES</code>, and <code class="codeph">DBA_XML_INDEXES</code>.
                     </p>
                     <p>You can examine this table to determine when synchronization might be appropriate for a given <code class="codeph">XMLIndex</code> index. The more rows there are in the pending table, the more the index is likely to be in need of synchronization.
                     </p>
                     <p>If the pending table is large, then setting parameter <code class="codeph">REINDEX</code> to <code class="codeph">TRUE</code> when calling <code class="codeph">syncIndex</code>, as in <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">Example 6-39</a>, can improve performance. When <code class="codeph">REINDEX</code> is <code class="codeph">TRUE</code>, all of the secondary indexes are dropped and then re-created after the pending table data is bulk-loaded.
                     </p>
                     <div class="infoboxnotealso" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__GUID-7C45F753-2BB1-4B19-9213-0ED93CA2A212">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../arpls/DBMS_SCHEDULER.html#ARPLS72263" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a>, section "Calendaring Syntax", for the syntax of <span class="italic"><code class="codeph">repeat_interval</code></span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_XMLINDEX.html#ARPLS212" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for information on PL/SQL procedure <code class="codeph">DBMS_XMLINDEX.syncIndex</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDBCDJD">
                        <p class="titleinexample">Example 6-38 Specifying Deferred Synchronization for XMLIndex</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_xmlindex_ix ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('<span class="bold">ASYNC (SYNC EVERY "FREQ=HOURLY; INTERVAL = 1")</span>');
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940__CHDHIGIA">
                        <p class="titleinexample">Example 6-39 Manually Synchronizing an XMLIndex Index Using SYNCINDEX</p><pre class="oac_no_warn" dir="ltr">EXEC DBMS_XMLINDEX.syncIndex('OE', 'PO_XMLINDEX_IX', REINDEX =&gt; TRUE);
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36">Syncing an XMLIndex Index in Case of Error ORA-08181</a><br>If a query raises error ORA-08181, check whether the base <code class="codeph">XMLType</code> table of the query has an <code class="codeph">XMLIndex</code> index with an unstructured component. If so, then manually synchronize the <code class="codeph">XMLIndex</code> index using <code class="codeph">DBMS_XMLINDEX.syncIndex</code>.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6145"></a><div class="props_rev_3"><a id="GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36" name="GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36"></a><h5 id="ADXDB-GUID-1D3627B8-0738-450D-8C6A-BB64F4207A36" class="sect5"><span class="enumeration_section">6.3.14.1 </span>Syncing an XMLIndex Index in Case of Error ORA-08181
                     </h5>
                     <div>
                        <p>If a query raises error ORA-08181, check whether the base <code class="codeph">XMLType</code> table of the query has an <code class="codeph">XMLIndex</code> index with an unstructured component. If so, then manually synchronize the <code class="codeph">XMLIndex</code> index using <code class="codeph">DBMS_XMLINDEX.syncIndex</code>.
                        </p>
                        <div class="section">
                           <p>This applies only if error ORA-08181 is raised in the following situation:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>In a pluggable database, <span class="italic"><code class="codeph">PDB1</code></span>, you created an <code class="codeph">XMLType</code> table or column <span class="italic"><code class="codeph">XTABCOL</code></span>, which you indexed using an <code class="codeph">XMLIndex</code> index that has an unstructured component.</span></li>
                           <li><span>You plugged <span class="italic"><code class="codeph">PDB1</code></span> into a container database.</span></li>
                           <li><span>You cloned <span class="italic"><code class="codeph">PDB1</code></span> to a new pluggable database, <span class="italic"><code class="codeph">PDB2</code></span>.</span></li>
                           <li><span>Error ORA-08181 is raised when you query <span class="italic"><code class="codeph">XTABCOL</code></span> in <span class="italic"><code class="codeph">PDB2</code></span>.</span></li>
                        </ol>
                        <div class="section">
                           <p>If the error is raised even after synchronizing then seek another cause. Error ORA-08181 is a general error that can be raised in various situations, of which this is only one.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="administration-of-XML-DB.html#GUID-C6C0EC34-29F6-47F5-B7A7-88F315403DC9" title="Each pluggable database has its own Oracle XML&nbsp;DB Repository, and its own Oracle XML&nbsp;DB configuration file, xdbconfig.xml.">Oracle XML&nbsp;DB and Database Consolidation</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4405"></a><a id="ADXDB4404"></a><div class="props_rev_3"><a id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" name="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC"></a><h4 id="ADXDB-GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC" class="sect4"><span class="enumeration_section">6.3.15 </span>Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer
                  </h4>
                  <div>
                     <p>The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects. </p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__GUID-94855574-E935-4AB8-86C9-2404F19971CA">
                           <p class="notep1">Note:</p>
                           <p>The following applies only to procedures in package <code class="codeph">DBMS_STATS</code>; it does not apply to <code class="codeph">ANALYZE INDEX</code>.
                           </p>
                        </div>
                        <p>For <code class="codeph">XMLIndex</code>, you normally need to collect statistics on only the base table on which the <code class="codeph">XMLIndex</code> index is defined (using, for example, procedure <code class="codeph">DBMS_STATS.gather_table_stats</code>). This automatically collects statistics for the <code class="codeph">XMLIndex</code> index itself, as well as the path table, its secondary indexes, and any structured component content tables and their secondary indexes. 
                        </p>
                        <p>If you delete statistics on the base table (using procedure <code class="codeph">DBMS_STATS.delete_table_stats</code>), then statistics on the other objects are also deleted. Similarly, if you collect statistics on the <code class="codeph">XMLIndex</code> index (using procedure <code class="codeph">DBMS_STATS.gather_index_stats</code>), then statistics are also collected on the path table, its secondary indexes, and any structured component content tables and their secondary indexes.
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">Example 6-40</a> collects statistics on the base table <code class="codeph">po_binxml</code>. Statistics are automatically collected on the <code class="codeph">XMLIndex</code> index, its path table, and the secondary path-table indexes.
                        </p>
                        <div class="infoboxnotealso" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__GUID-1CD47A36-B877-42DF-A8CA-3A96DE8B0D67">
                           <p class="notep1">See Also:</p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-486E91AE-9FE0-489A-A035-AF320D04350B" title="Information about the standard database indexes is available in static public views USER_INDEXES, ALL_INDEXES, and DBA_INDEXES. Similar information about XMLIndex indexes is available in static public views USER_XML_INDEXES, ALL_XML_INDEXES, and DBA_XML_INDEXES.">Data Dictionary Static Public Views Related to XMLIndex</a> for information about database views that record statistics information for an <code class="codeph">XMLIndex</code> index
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C936D15C-5F86-4EAE-8552-3890ACD819BC__CHDEHFDF">
                        <p class="titleinexample">Example 6-40 Automatic Collection of Statistics on XMLIndex Objects</p><pre class="oac_no_warn" dir="ltr">CALL DBMS_STATS.gather_table_stats(USER, 'PO_BINXML', ESTIMATE_PERCENT =&gt; NULL);</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4335"></a><a id="ADXDB4334"></a><div class="props_rev_3"><a id="GUID-486E91AE-9FE0-489A-A035-AF320D04350B" name="GUID-486E91AE-9FE0-489A-A035-AF320D04350B"></a><h4 id="ADXDB-GUID-486E91AE-9FE0-489A-A035-AF320D04350B" class="sect4"><span class="enumeration_section">6.3.16 </span>Data Dictionary Static Public Views Related to XMLIndex
                  </h4>
                  <div>
                     <p>Information about the standard database indexes is available in static public views <code class="codeph">USER_INDEXES</code>, <code class="codeph">ALL_INDEXES</code>, and <code class="codeph">DBA_INDEXES</code>. Similar information about <code class="codeph">XMLIndex</code> indexes is available in static public views <code class="codeph">USER_XML_INDEXES</code>, <code class="codeph">ALL_XML_INDEXES</code>, and <code class="codeph">DBA_XML_INDEXES</code>.
                     </p>
                     <div class="section">
                        <p><a href="indexes-for-XMLType-data.html#GUID-486E91AE-9FE0-489A-A035-AF320D04350B__CHDGHHAB" title="This table describes the columns in the XMLIndex Public Views.">Table 6-8</a> describes the columns in each of these views. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-486E91AE-9FE0-489A-A035-AF320D04350B__CHDGHHAB">
                        <p class="titleintable">Table 6-8 XMLIndex Static Public Views</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="XMLIndex Static Public Views" summary="This table describes the columns in the XMLIndex Public Views." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d34642e8102">Column Name</th>
                                 <th align="left" valign="bottom" id="d34642e8105">Type</th>
                                 <th align="left" valign="bottom" id="d34642e8108">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8113" headers="d34642e8102 ">
                                    <p><code class="codeph">ASYNC</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8113 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8113 d34642e8108 ">
                                    <p>Asynchronous index updating specification. See <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8140" headers="d34642e8102 ">
                                    <p><code class="codeph">EX_OR_INCLUDE</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8140 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8140 d34642e8108 ">
                                    <p>Path subsetting:</p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p><code class="codeph">FULLY_IX</code> &#x2013; The index uses no path subsetting.
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">EXCLUDE</code> &#x2013; The index uses only exclusion subsetting.
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">INCLUDE</code> &#x2013; The index uses only inclusion subsetting.
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8169" headers="d34642e8102 ">
                                    <p><code class="codeph">INDEX_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8169 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8169 d34642e8108 ">
                                    <p>Name of the <code class="codeph">XMLIndex</code> index.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8184" headers="d34642e8102 ">
                                    <p><code class="codeph">INDEX_OWNER</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8184 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8184 d34642e8108 ">
                                    <p>Owner of the index. Not available for <code class="codeph">USER_XML_INDEXES</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8199" headers="d34642e8102 ">
                                    <p><code class="codeph">INDEX_TYPE</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8199 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8199 d34642e8108 ">
                                    <p>The types of components the index is composed of: <code class="codeph">STRUCTURED</code>, <code class="codeph">UNSTRUCTURED</code>, or <code class="codeph">STRUCTURED AND UNSTRUCTURED</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8220" headers="d34642e8102 ">
                                    <p><code class="codeph">PARAMETERS</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8220 d34642e8105 ">
                                    <p><code class="codeph">XMLType</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8220 d34642e8108 ">
                                    <p>Information from the <code class="codeph">PARAMETERS</code> clause that was used to create the index. 
                                    </p>
                                    <p>If an unstructured <code class="codeph">XMLIndex</code> component is present, the <code class="codeph">PARAMETERS</code> clause can include the set of XPath paths defining path-subsetting and the name of a scheduler job for synchronization. 
                                    </p>
                                    <p>If a structured component is present, the <code class="codeph">PARAMETERS</code> clause includes the name of the structure group and the table definitions provided by <code class="codeph">XMLTable</code>, including the XQuery expressions that define the columns.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8251" headers="d34642e8102 ">
                                    <p><code class="codeph">PATH_TABLE_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8251 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8251 d34642e8108 ">
                                    <p>Name of the <code class="codeph">XMLIndex</code> path table.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8266" headers="d34642e8102 ">
                                    <p><code class="codeph">PEND_TABLE_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8266 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8266 d34642e8108 ">
                                    <p>Name of the table that records base-table DML operations since the last index synchronization. See <a href="indexes-for-XMLType-data.html#GUID-DCEA65A9-BE27-4291-A2EF-2AA8E9740940" title="You can defer the cost of maintaining an XMLIndex index that has only an unstructured component, performing maintenance only at commit time or when database load is reduced. This can improve DML performance, and it can enable bulk loading of unsynchronized index rows when an index is synchronized.">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8293" headers="d34642e8102 ">
                                    <p><code class="codeph">TABLE_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8293 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8293 d34642e8108 ">
                                    <p>Name of the base table on which the index is defined.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d34642e8305" headers="d34642e8102 ">
                                    <p><code class="codeph">TABLE_OWNER</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8305 d34642e8105 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d34642e8305 d34642e8108 ">
                                    <p>Owner of the base table on which the index is defined.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>These views provide information about an <code class="codeph">XMLIndex</code> index, but there is no single static data dictionary view that provides information about the statistics gathered for an <code class="codeph">XMLIndex</code> index. This statistics information is distributed among the following views:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">USER_INDEXES</code>, <code class="codeph">ALL_INDEXES</code>, <code class="codeph">DBA_INDEXES</code> &#x2013; Column <code class="codeph">LAST_ANALYZED</code> provides the date when the <code class="codeph">XMLIndex</code> index was last analyzed.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">USER_TAB_STATISTICS</code>, <code class="codeph">ALL_TAB_STATISTICS</code>, <code class="codeph">DBA_TAB_STATISTICS</code> &#x2013; Column <code class="codeph">TABLE_NAME</code> provides information about the structured and unstructured components of an <code class="codeph">XMLIndex</code> index. For information about the structured or unstructured component, query using the name of the path table or the <code class="codeph">XMLTable</code> table as <code class="codeph">TABLE_NAME</code>, respectively.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">USER_IND_STATISTICS</code>, <code class="codeph">ALL_IND_STATISTICS</code>, <code class="codeph">DBA_IND_STATISTICS</code> &#x2013; Column <code class="codeph">INDEX_NAME</code> provides information about each of the secondary indexes for an <code class="codeph">XMLIndex</code> index. for information about a given secondary index, query using the name of that secondary index as <code class="codeph">INDEX_NAME</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4406"></a><div class="props_rev_3"><a id="GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" name="GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC"></a><h4 id="ADXDB-GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" class="sect4"><span class="enumeration_section">6.3.17 </span>PARAMETERS Clause for CREATE INDEX and ALTER INDEX
                  </h4>
                  <div>
                     <p>Creation or modification of an <code class="codeph">XMLIndex</code> index often involves the use of a <code class="codeph">PARAMETERS</code> clause with SQL statement <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code>. You can use it to specify index characteristics in detail.
                     </p>
                     <div class="section">
                        <p>You can use PL/SQL procedures <code class="codeph">registerParameter</code> and <code class="codeph">modifyParameter</code> in package <code class="codeph">DBMS_XMLINDEX</code> to bypass the 1000-character <code class="codeph">PARAMETERS</code> clause limit.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-C04D8939-4A3C-4C54-8399-109AC4914D03">Using a Registered PARAMETERS Clause for XMLIndex</a><br>The string value used for the <code class="codeph">PARAMETERS</code> clause of a <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code> statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures <code class="codeph">registerParameter</code> and <code class="codeph">modifyParameter</code> in package <code class="codeph">DBMS_XMLINDEX</code>.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</a><br>The syntax for the <code class="codeph">PARAMETERS</code> clause for <code class="codeph">CREATE INDEX</code> and <code class="codeph">ALTER INDEX</code> is defined.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C">Usage of XMLIndex_parameters_clause</a><br>When you create an <code class="codeph">XMLIndex</code> index, if there is no <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span>, then the new index has only an unstructured component. If there is an <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span>, but the <code class="codeph">PARAMETERS</code> argument is empty (<code class="codeph">''</code>), then the result is the same: an index with only an unstructured component.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-0563D8B4-9C46-4620-B814-0D608B57F84C">Usage of XMLIndex_parameters</a><br>Certain considerations apply to using <span class="italic"><code class="codeph">XMLIndex_parameters</code></span>.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7">Usage of PATHS Clause</a><br>Certain considerations apply to using the <code class="codeph">PATHS</code> clause.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D">Usage of create_index_paths_clause and alter_index_paths_clause</a><br>Certain considerations apply to using <span class="italic"><code class="codeph">create_index_paths_clause</code></span> and <span class="italic"><code class="codeph">alter_index_paths_clause</code></span>.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-7B126CF1-5397-455C-B01D-696CF64B2001">Usage of pikey_clause, path_id_clause, and order_key_clause</a><br>Syntactically, each of the clauses <code class="codeph">pikey_clause</code>, <code class="codeph">path_id_clause</code>, and <code class="codeph">order_key_clause</code> is optional. A pikey index is created even if you do not specify a <code class="codeph">pikey_clause</code>. To create a path id index or an order-key index, you must specify a <code class="codeph">path_id_clause</code> or an <code class="codeph">order_key_clause</code>, respectively.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-3D908187-37BE-48DB-88A3-285442FB3DE1">Usage of value_clause</a><br>Certain considerations apply to using <span class="italic"><code class="codeph">value_clause</code></span>.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1">Usage of async_clause</a><br>Certain considerations apply to using the <code class="codeph">ASYNC</code> clause.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D">Usage of groups_clause and alter_index_group_clause</a><br>Clause <span class="italic"><code class="codeph">groups_clause</code></span> is used only with <code class="codeph">CREATE INDEX</code> (or following <code class="codeph">ADD GROUP</code> in clause  <span class="italic"><code class="codeph">alter_index_group_clause</code></span>). Clause <span class="italic"><code class="codeph">alter_index_group_clause</code></span> is used only with <code class="codeph">ALTER INDEX</code>. 
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42">Usage of XMLIndex_xmltable_clause</a><br>Certain considerations apply to using <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span>.
                        </li>
                        <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-D4474161-F125-4703-98D2-7C609F8806E7">Usage of column_clause</a><br>Certain considerations apply to using <span class="italic"><code class="codeph">column_clause</code></span>.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC__GUID-6298526F-A48D-4A8A-B298-9C82DB28E283">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF20021" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax of <span class="italic"><code class="codeph">index_attributes</code></span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF20022" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax of <span class="italic"><code class="codeph">segment_attributes_clause</code></span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF20023" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax of <span class="italic"><code class="codeph">table_properties</code></span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/parallel_clause.html#SQLRF20024" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax of <span class="italic"><code class="codeph">parallel_clause</code></span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for additional information about the syntax and semantics of <code class="codeph">CREATE INDEX</code></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/ALTER-INDEX.html#SQLRF00805" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for additional information about the syntax and semantics of <code class="codeph">ALTER INDEX</code></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SCHEDULER.html#ARPLS72263" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a>, section "Calendaring Syntax", for the syntax of <span class="italic"><code class="codeph">repeat_interval</code></span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">XMLIndex</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4407"></a><div class="props_rev_3"><a id="GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" name="GUID-C04D8939-4A3C-4C54-8399-109AC4914D03"></a><h5 id="ADXDB-GUID-C04D8939-4A3C-4C54-8399-109AC4914D03" class="sect5"><span class="enumeration_section">6.3.17.1 </span>Using a Registered PARAMETERS Clause for XMLIndex
                     </h5>
                     <div>
                        <p>The string value used for the <code class="codeph">PARAMETERS</code> clause of a <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code> statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures <code class="codeph">registerParameter</code> and <code class="codeph">modifyParameter</code> in package <code class="codeph">DBMS_XMLINDEX</code>.
                        </p>
                        <div class="section">
                           <p>For each of these procedures, you provide a string of parameters (unlimited in length) and an identifier under which the string is registered. Then, in the index <code class="codeph">PARAMETERS</code> clause, you provide the identifier preceded by the keyword <code class="codeph">PARAM</code>, instead of a literal string.
                           </p>
                           <p>The identifier must already have been registered before you can use it in a <code class="codeph">CREATE INDEX</code> or <code class="codeph">ALTER INDEX</code> statement.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C04D8939-4A3C-4C54-8399-109AC4914D03__GUID-6CB729AD-0B47-4BD2-9036-C402C71194B6">
                           <p class="notep1">See Also:</p>
                           <p><a href="indexes-for-XMLType-data.html#GUID-0BE986CC-BEAE-4F6E-95C9-7DA51D9E0CE0__BCGJCEAF">Example 6-23</a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4409"></a><a id="ADXDB4410"></a><a id="ADXDB4411"></a><a id="ADXDB5832"></a><a id="ADXDB4412"></a><a id="ADXDB4413"></a><a id="ADXDB4414"></a><a id="ADXDB4415"></a><a id="ADXDB5833"></a><a id="ADXDB4416"></a><a id="ADXDB4417"></a><a id="ADXDB4418"></a><a id="ADXDB5834"></a><a id="ADXDB4419"></a><a id="ADXDB4420"></a><a id="ADXDB5835"></a><a id="ADXDB4421"></a><a id="ADXDB4422"></a><a id="ADXDB4423"></a><a id="ADXDB4424"></a><a id="ADXDB4425"></a><a id="ADXDB4426"></a><a id="ADXDB4427"></a><a id="ADXDB4428"></a><a id="ADXDB4429"></a><a id="ADXDB6106"></a><a id="ADXDB6107"></a><a id="ADXDB4408"></a><div class="props_rev_3"><a id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" name="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393"></a><h5 id="ADXDB-GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393" class="sect5"><span class="enumeration_section">6.3.17.2 </span>PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX
                     </h5>
                     <div>
                        <p>The syntax for the <code class="codeph">PARAMETERS</code> clause for <code class="codeph">CREATE INDEX</code> and <code class="codeph">ALTER INDEX</code> is defined.
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-EEBA83C3-9AE1-4D7E-AD69-0A38F7A2E421"><span class="italic">XMLIndex_parameters_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-22945D8D-CE93-4FED-A2B9-79DFD2D6230C"><img src="img/xmlindex_parameters_clause.gif" width="318" alt="Description of xmlindex_parameters_clause.eps follows" title="Description of xmlindex_parameters_clause.eps follows" longdesc="img_text/xmlindex_parameters_clause.html"><br><a href="img_text/xmlindex_parameters_clause.html">Description of the illustration xmlindex_parameters_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C98E9FB9-BC89-4BDD-AC08-8FA6A168457C">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C" title="When you create an XMLIndex index, if there is no XMLIndex_parameters_clause, then the new index has only an unstructured component. If there is an XMLIndex_parameters_clause, but the PARAMETERS argument is empty (''), then the result is the same: an index with only an unstructured component.">Usage of XMLIndex_parameters_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-538B98D3-6B79-4023-BE4D-4FCCE45513A6"><span class="italic">XMLIndex_parameters ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-46FCC879-D90B-4132-9DFE-982F5387C8BE"><img src="img/xmlindex_parameters.gif" width="376" alt="Description of xmlindex_parameters.eps follows" title="Description of xmlindex_parameters.eps follows" longdesc="img_text/xmlindex_parameters.html"><br><a href="img_text/xmlindex_parameters.html">Description of the illustration xmlindex_parameters.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BB050FB2-8EDE-4DDD-8112-3669936667F6">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-0563D8B4-9C46-4620-B814-0D608B57F84C" title="Certain considerations apply to using XMLIndex_parameters.">Usage of XMLIndex_parameters</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-09A963C1-F003-469B-96D8-2EF903AE2063"><span class="italic">XMLIndex_parameter_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-752DCF5B-17A6-44B0-8885-322075A7ACCE"><img src="img/xmlindex_parameter_clause.gif" width="138" alt="Description of xmlindex_parameter_clause.eps follows" title="Description of xmlindex_parameter_clause.eps follows" longdesc="img_text/xmlindex_parameter_clause.html"><br><a href="img_text/xmlindex_parameter_clause.html">Description of the illustration xmlindex_parameter_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-8DC6B2EB-2119-46A9-BCD2-9A9D600F9DA6"><span class="italic">unstructured_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-9BACE068-2AB2-44A0-A5E3-CB6B6740F318"><img src="img/unstructured_clause.gif" width="291" alt="Description of unstructured_clause.eps follows" title="Description of unstructured_clause.eps follows" longdesc="img_text/unstructured_clause.html"><br><a href="img_text/unstructured_clause.html">Description of the illustration unstructured_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-51CFCD6F-51B6-43F0-8C98-F568F1498D4B"><span class="italic">create_index_paths_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-B52C3262-79E0-431F-936F-97FA7A79F32F"><img src="img/create_index_paths_clause.gif" width="427" alt="Description of create_index_paths_clause.eps follows" title="Description of create_index_paths_clause.eps follows" longdesc="img_text/create_index_paths_clause.html"><br><a href="img_text/create_index_paths_clause.html">Description of the illustration create_index_paths_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-13860D3C-FD4D-41F2-9A98-9E2F8B083DE4">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" title="Certain considerations apply to using the PATHS clause.">Usage of PATHS Clause</a></p>
                                 </li>
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" title="Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.">Usage of create_index_paths_clause and alter_index_paths_clause</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFAECD">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-4891C26C-75B7-4AC5-929D-23E4C134318D"><span class="italic">alter_index_paths_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-837A5031-6A94-4CB2-B88A-E51B066B6F7C"><img src="img/alter_index_paths_clause.gif" width="532" alt="Description of alter_index_paths_clause.eps follows" title="Description of alter_index_paths_clause.eps follows" longdesc="img_text/alter_index_paths_clause.html"><br><a href="img_text/alter_index_paths_clause.html">Description of the illustration alter_index_paths_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-36FC14F5-F78F-49FA-B4A6-86B6534A81BA">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" title="Certain considerations apply to using the PATHS clause.">Usage of PATHS Clause</a></p>
                                 </li>
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" title="Certain considerations apply to using create_index_paths_clause and alter_index_paths_clause.">Usage of create_index_paths_clause and alter_index_paths_clause</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-4895ADE6-2260-419F-B56B-E1D125BDB91A"><span class="italic">namespace_mapping_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-756E1FE2-AD89-41D7-A809-3394D9DAB955"><img src="img/namespace_mapping_clause.gif" width="287" alt="Description of namespace_mapping_clause.eps follows" title="Description of namespace_mapping_clause.eps follows" longdesc="img_text/namespace_mapping_clause.html"><br><a href="img_text/namespace_mapping_clause.html">Description of the illustration namespace_mapping_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAGCI">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5A96E21F-14E4-47D3-9760-889D6C454E46"><span class="italic">path_table_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-A2B60DE1-4E71-4CB6-A765-D1C590484CD5"><img src="img/path_table_clause.gif" width="485" alt="Description of path_table_clause.eps follows" title="Description of path_table_clause.eps follows" longdesc="img_text/path_table_clause.html"><br><a href="img_text/path_table_clause.html">Description of the illustration path_table_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-67FC14D7-1897-4DAC-9FB3-26812FDBE8FF"><span class="italic">pikey_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5B98FFF2-2F94-4AF2-A00D-65A91F83F6C9"><img src="img/pikey_clause.gif" width="396" alt="Description of pikey_clause.eps follows" title="Description of pikey_clause.eps follows" longdesc="img_text/pikey_clause.html"><br><a href="img_text/pikey_clause.html">Description of the illustration pikey_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-32EA0C93-902C-4EBE-807C-67E3D7654855">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause, path_id_clause, and order_key_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D2073083-C361-43F3-973A-2AAA2ECDCE3A"><span class="italic">path_id_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-35BEC568-0DDA-4075-8EA1-4AD94B0150EB"><img src="img/path_id_clause.gif" width="423" alt="Description of path_id_clause.eps follows" title="Description of path_id_clause.eps follows" longdesc="img_text/path_id_clause.html"><br><a href="img_text/path_id_clause.html">Description of the illustration path_id_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-FD260B24-0AC2-4313-AB34-BE5ED10D33F8">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause, path_id_clause, and order_key_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-0629A118-3653-4F0F-8E18-6639DB18DD0F"><span class="italic">order_key_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-692BD0F4-CE28-4763-BDEC-B8A8ED83F52E"><img src="img/order_key_clause.gif" width="440" alt="Description of order_key_clause.eps follows" title="Description of order_key_clause.eps follows" longdesc="img_text/order_key_clause.html"><br><a href="img_text/order_key_clause.html">Description of the illustration order_key_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C0017A22-39D4-4D44-8329-5CCD7D9902FB">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-7B126CF1-5397-455C-B01D-696CF64B2001" title="Syntactically, each of the clauses pikey_clause, path_id_clause, and order_key_clause is optional. A pikey index is created even if you do not specify a pikey_clause. To create a path id index or an order-key index, you must specify a path_id_clause or an order_key_clause, respectively.">Usage of pikey_clause, path_id_clause, and order_key_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-45622D2D-1BF3-462C-8075-475DCF288E86"><span class="italic">value_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-303056F8-EFBF-465C-A46C-7F646276D8F9"><img src="img/value_clause.gif" width="399" alt="Description of value_clause.eps follows" title="Description of value_clause.eps follows" longdesc="img_text/value_clause.html"><br><a href="img_text/value_clause.html">Description of the illustration value_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-63D45313-916C-422B-80A0-2BF695779730">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-3D908187-37BE-48DB-88A3-285442FB3DE1" title="Certain considerations apply to using value_clause.">Usage of value_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGGGBCB">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D38DA6DA-21EB-4D89-9E76-8A49C09270FA"><span class="italic">drop_path_table_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BE350CDB-9167-47CF-8D9E-FF1733D810A9"><img src="img/drop_path_table_clause.gif" width="151" alt="Description of drop_path_table_clause.eps follows" title="Description of drop_path_table_clause.eps follows" longdesc="img_text/drop_path_table_clause.html"><br><a href="img_text/drop_path_table_clause.html">Description of the illustration drop_path_table_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-4D549AFC-1C79-464A-8DF2-C7D6FB162379"><span class="italic">parallel_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-0F378CCC-7B45-4DA9-852D-6B36658731A9"><img src="img/parallel_clause.gif" width="186" alt="Description of parallel_clause.eps follows" title="Description of parallel_clause.eps follows" longdesc="img_text/parallel_clause.html"><br><a href="img_text/parallel_clause.html">Description of the illustration parallel_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGFGBEB">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-DD4CCBE6-6A54-4568-987C-A4708C0BE822"><span class="italic">structured_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C3D9026F-D932-48D1-A249-B9E0E91EF357"><img src="img/structured_clause.gif" width="159" alt="Description of structured_clause.eps follows" title="Description of structured_clause.eps follows" longdesc="img_text/structured_clause.html"><br><a href="img_text/structured_clause.html">Description of the illustration structured_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5093170E-E559-4919-A53B-16225E7BD5A0">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-7C5A4C06-458B-4268-94C1-EAF87B4CA203"><span class="italic">async_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-BE6C1E4E-6CC6-4064-A9FB-3F3FB31C3AA7"><img src="img/async_clause.gif" width="508" alt="Description of async_clause.eps follows" title="Description of async_clause.eps follows" longdesc="img_text/async_clause.html"><br><a href="img_text/async_clause.html">Description of the illustration async_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-558C4F03-A725-4A11-8744-0FF8DCAA0389">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1" title="Certain considerations apply to using the ASYNC clause.">Usage of async_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-1558A55A-590F-44D7-99C6-38B9C5992494"><span class="italic">groups_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-77B8AFED-CF5F-4351-B1A0-78C986DD12D1"><img src="img/groups_clause.gif" width="112" alt="Description of groups_clause.eps follows" title="Description of groups_clause.eps follows" longdesc="img_text/groups_clause.html"><br><a href="img_text/groups_clause.html">Description of the illustration groups_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2E78604E-3FF6-4347-A5B4-DB7E543C5A42">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-9E03CA27-77FC-4A08-B904-9694DDCEDFD5"><span class="italic">group_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2808C9B7-D93C-4D3F-9BD9-B7AEBAE67970"><img src="img/group_clause.gif" width="283" alt="Description of group_clause.eps follows" title="Description of group_clause.eps follows" longdesc="img_text/group_clause.html"><br><a href="img_text/group_clause.html">Description of the illustration group_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-F1D62A14-E1C7-48C3-9559-B17D7AF0849E">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-3692A828-7BD4-433C-8986-9F683070F958"><span class="italic">XMLIndex_xmltable_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-C1E9E927-A73C-4E2A-92B9-31FBD1EBFCFB"><img src="img/xmlindex_xmltable_clause.gif" alt="Description of xmlindex_xmltable_clause.eps follows" title="Description of xmlindex_xmltable_clause.eps follows" longdesc="img_text/xmlindex_xmltable_clause.html"><br><a href="img_text/xmlindex_xmltable_clause.html">Description of the illustration xmlindex_xmltable_clause.eps</a></div>
                           <!-- class="figure" -->
                           <p>Syntax elements <tt>XML_namespaces_clause</tt> and <tt>XQuery_string</tt> are the same as for SQL/XML function <code class="codeph">XMLTable</code>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-51982120-529B-4D7F-A337-1C31C3C44219">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" title="Certain considerations apply to using XMLIndex_xmltable_clause.">Usage of XMLIndex_xmltable_clause</a></p>
                                 </li>
                                 <li>
                                    <p><a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL  in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-A4AD5B4E-24B5-4CE5-B3AB-F324F72D3469"><span class="italic">column_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D5D4C8BB-669E-4DF1-B77D-85669BC13CAC"><img src="img/column_clause.gif" width="319" alt="Description of column_clause.eps follows" title="Description of column_clause.eps follows" longdesc="img_text/column_clause.html"><br><a href="img_text/column_clause.html">Description of the illustration column_clause.eps</a></div>
                           <!-- class="figure" -->
                           <p>Syntax element <tt>column_clause</tt> is similar, but not identical, to <tt>XML_table_column</tt> in SQL/XML function <code class="codeph">XMLTable</code>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-B6BCE32F-DAA8-4D15-A626-DCA778AE095E">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="indexes-for-XMLType-data.html#GUID-D4474161-F125-4703-98D2-7C609F8806E7" title="Certain considerations apply to using column_clause.">Usage of column_clause</a></p>
                                 </li>
                                 <li>
                                    <p><a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL  in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__BCGJAAGH">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-0B6D7002-7E3F-461B-AA59-481D4E8E2391"><span class="italic">alter_index_group_clause ::=</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5155A7FD-7F88-44A2-BD04-3C0B76C845F1"><img src="img/alter_index_group_clause.gif" width="312" alt="Description of alter_index_group_clause.eps follows" title="Description of alter_index_group_clause.eps follows" longdesc="img_text/alter_index_group_clause.html"><br><a href="img_text/alter_index_group_clause.html">Description of the illustration alter_index_group_clause.eps</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-AD9466C7-72BE-440C-B2BA-0839E6B9A542">
                              <p class="notep1">See Also:</p>
                              <p><a href="indexes-for-XMLType-data.html#GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" title="Clause groups_clause is used only with CREATE INDEX (or following ADD GROUP in clause alter_index_group_clause). Clause alter_index_group_clause is used only with ALTER INDEX.">Usage of groups_clause and alter_index_group_clause</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-53DE24F4-A33F-4990-B8A9-10BCE12E94D4"><span class="italic">add_column_clause :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-E7E8C533-E0A1-444B-BC9F-B578554B55D1"><img src="img/add_column_clause.gif" width="197" alt="Description of add_column_clause.eps follows" title="Description of add_column_clause.eps follows" longdesc="img_text/add_column_clause.html"><br><a href="img_text/add_column_clause.html">Description of the illustration add_column_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-5DD7D1A6-9773-4C52-8F0B-F0980F82C4F3"><span class="italic">add_column_options :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-4B191901-116A-4AE8-92F6-537A0875E7A0"><img src="img/add_column_options.gif" width="618" alt="Description of add_column_options.eps follows" title="Description of add_column_options.eps follows" longdesc="img_text/add_column_options.html"><br><a href="img_text/add_column_options.html">Description of the illustration add_column_options.eps</a></div>
                           <!-- class="figure" -->
                           <p>Syntax element <tt>XML_namespaces_clause</tt> is the same as for SQL/XML function <code class="codeph">XMLTable</code>. See <a href="xquery-and-XML-DB.html#GUID-F4508470-D420-4B5A-B5DF-59A424887F10" title="You use SQL/XML function XMLTable to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can insert this data into a pre-existing database table, or you can query it using SQL  in a join expression, for example.">XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-311A2292-A400-4F15-A4F7-AF49D33A0040"><span class="italic">drop_column_clause :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-2A4C62C6-0E3C-47E6-AAC3-C29EE8E559C7"><img src="img/drop_column_clause.gif" width="207" alt="Description of drop_column_clause.eps follows" title="Description of drop_column_clause.eps follows" longdesc="img_text/drop_column_clause.html"><br><a href="img_text/drop_column_clause.html">Description of the illustration drop_column_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-60C5CB8D-1E18-403D-999E-1437AC652E80"><span class="italic">drop_column_options :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-05DA1B85-9822-422B-A78C-AA294CEC46DC"><img src="img/drop_column_options.gif" width="416" alt="Description of drop_column_options.eps follows" title="Description of drop_column_options.eps follows" longdesc="img_text/drop_column_options.html"><br><a href="img_text/drop_column_options.html">Description of the illustration drop_column_options.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__CEGEABGE">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-7E148DC5-F82D-4E13-B9B1-03A90D794A14"><span class="italic">modify_column_type_clause :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-D6F2F095-EBB0-46F8-B064-C37E35F90C23"><img src="img/modify_column_type_clause.gif" width="273" alt="Description of modify_column_type_clause.eps follows" title="Description of modify_column_type_clause.eps follows" longdesc="img_text/modify_column_type_clause.html"><br><a href="img_text/modify_column_type_clause.html">Description of the illustration modify_column_type_clause.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-F5B7CB26-2D8E-4E08-89DD-96245D1381CC"><span class="italic">modify_column_type_options :==</span></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="figure" id="GUID-24AAD47C-7D5C-4A61-B1F4-DD1F27D8A393__GUID-08F4FF1D-308D-4B5B-851D-85307945AE0C"><img src="img/modify_column_type_options.gif" width="469" alt="Description of modify_column_type_options.eps follows" title="Description of modify_column_type_options.eps follows" longdesc="img_text/modify_column_type_options.html"><br><a href="img_text/modify_column_type_options.html">Description of the illustration modify_column_type_options.eps</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4430"></a><div class="props_rev_3"><a id="GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C" name="GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C"></a><h5 id="ADXDB-GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C" class="sect5"><span class="enumeration_section">6.3.17.3 </span>Usage of XMLIndex_parameters_clause
                     </h5>
                     <div>
                        <p>When you create an <code class="codeph">XMLIndex</code> index, if there is no <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span>, then the new index has only an unstructured component. If there is an <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span>, but the <code class="codeph">PARAMETERS</code> argument is empty (<code class="codeph">''</code>), then the result is the same: an index with only an unstructured component.
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-CF497695-F726-4C7D-B8D8-3B27D18FD56C__GUID-A4B03CC0-4E7E-4488-B0C5-D05D98817C40">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF54032" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about the use context for <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span> in <code class="codeph">CREATE INDEX</code></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/ALTER-INDEX.html#SQLRF52771" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about the use context for <span class="italic"><code class="codeph">XMLIndex_parameters_clause</code></span> in <code class="codeph">ALTER INDEX</code></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4431"></a><div class="props_rev_3"><a id="GUID-0563D8B4-9C46-4620-B814-0D608B57F84C" name="GUID-0563D8B4-9C46-4620-B814-0D608B57F84C"></a><h5 id="ADXDB-GUID-0563D8B4-9C46-4620-B814-0D608B57F84C" class="sect5"><span class="enumeration_section">6.3.17.4 </span>Usage of XMLIndex_parameters
                     </h5>
                     <div>
                        <p>Certain considerations apply to using <span class="italic"><code class="codeph">XMLIndex_parameters</code></span>.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>There can be at most one <span class="italic"><code class="codeph">XMLIndex_parameter_clause</code></span> of each type in <span class="italic"><code class="codeph">XMLIndex_parameters</code></span>. For example, there can be at most one <code class="codeph">PATHS</code> clause, at most one <span class="italic"><code class="codeph">path_table_clause</code></span>, and so on.
                                 </p>
                              </li>
                              <li>
                                 <p>If there is no <span class="italic"><code class="codeph">structured_clause</code></span> when you create an <code class="codeph">XMLIndex</code> index, then the new index has only an unstructured component. If there is only a <span class="italic"><code class="codeph">structured_clause</code></span>, then the new index has only a structured component.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4433"></a><div class="props_rev_3"><a id="GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" name="GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7"></a><h5 id="ADXDB-GUID-602801B1-9A89-4ADE-B3C5-DABDFBB331A7" class="sect5"><span class="enumeration_section">6.3.17.5 </span>Usage of PATHS Clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using the <code class="codeph">PATHS</code> clause.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>There can be at most one <code class="codeph">PATHS</code> clause in a <code class="codeph">CREATE INDEX</code> statement. That is, there can be at most one occurrence of <code class="codeph">PATHS</code> followed by <span class="italic"><code class="codeph">create_index_paths_clause</code></span>.
                                 </p>
                              </li>
                              <li>
                                 <p>Clause <span class="italic"><code class="codeph">create_index_paths_clause</code></span> is used only with <code class="codeph">CREATE INDEX</code>; <span class="italic"><code class="codeph">alter_index_paths_clause</code></span> is used only with <code class="codeph">ALTER INDEX</code>. 
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4434"></a><div class="props_rev_3"><a id="GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" name="GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D"></a><h5 id="ADXDB-GUID-D452BE20-A1BC-4672-B3E0-A09C07BA327D" class="sect5"><span class="enumeration_section">6.3.17.6 </span>Usage of create_index_paths_clause and alter_index_paths_clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using <span class="italic"><code class="codeph">create_index_paths_clause</code></span> and <span class="italic"><code class="codeph">alter_index_paths_clause</code></span>.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">INDEX_ALL_PATHS</code> keyword rebuilds the index to include all paths. This keyword is available only for <span class="italic"><code class="codeph">alter_index_paths_clause</code></span>, not <span class="italic"><code class="codeph">create_index_paths_clause</code></span>.
                                 </p>
                              </li>
                              <li>
                                 <p>An explicit list of paths to index can include wildcards and <code class="codeph">//</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">XPaths_list</code></span> is a list of one or more XPath expressions, each of which includes only child axis, descendant axis, name test, and wildcard (<code class="codeph">*</code>) constructs.
                                 </p>
                              </li>
                              <li>
                                 <p>If <span class="italic"><code class="codeph">XPaths_list</code></span> is omitted from <span class="italic"><code class="codeph">create_index_paths_clause</code></span>, all paths are indexed.
                                 </p>
                              </li>
                              <li>
                                 <p>For each unique namespace prefix that is used in an XPath expression in <span class="italic"><code class="codeph">XPaths_list</code></span>, a standard XML <span class="italic"><code class="codeph">namespace</code></span> declaration is needed, to provide the corresponding namespace information.
                                 </p>
                              </li>
                              <li>
                                 <p>You can change an index in ways that are not reflected directly in the syntax by dropping it and then creating it again as needed. For example, to change an index that was defined by including paths to one that is defined by excluding paths, drop it and then create it using <code class="codeph">EXCLUDE</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5939"></a><div class="props_rev_3"><a id="GUID-7B126CF1-5397-455C-B01D-696CF64B2001" name="GUID-7B126CF1-5397-455C-B01D-696CF64B2001"></a><h5 id="ADXDB-GUID-7B126CF1-5397-455C-B01D-696CF64B2001" class="sect5"><span class="enumeration_section">6.3.17.7 </span>Usage of pikey_clause, path_id_clause, and order_key_clause
                     </h5>
                     <div>
                        <p>Syntactically, each of the clauses <code class="codeph">pikey_clause</code>, <code class="codeph">path_id_clause</code>, and <code class="codeph">order_key_clause</code> is optional. A pikey index is created even if you do not specify a <code class="codeph">pikey_clause</code>. To create a path id index or an order-key index, you must specify a <code class="codeph">path_id_clause</code> or an <code class="codeph">order_key_clause</code>, respectively.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4435"></a><div class="props_rev_3"><a id="GUID-3D908187-37BE-48DB-88A3-285442FB3DE1" name="GUID-3D908187-37BE-48DB-88A3-285442FB3DE1"></a><h5 id="ADXDB-GUID-3D908187-37BE-48DB-88A3-285442FB3DE1" class="sect5"><span class="enumeration_section">6.3.17.8 </span>Usage of value_clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using <span class="italic"><code class="codeph">value_clause</code></span>.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Column <code class="codeph">VALUE</code> is created as <code class="codeph">VARCHAR2(4000)</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>If clause <span class="italic"><code class="codeph">value_clause</code></span> consists only of the keyword <code class="codeph">VALUE</code>, then the value index is created with the usual default attributes.
                                 </p>
                              </li>
                              <li>
                                 <p>If clause <span class="italic"><code class="codeph">path_id_clause</code></span> consists only of the keywords <code class="codeph">PATH ID</code>, then the path-id index is created with the usual default attributes.
                                 </p>
                              </li>
                              <li>
                                 <p>If clause <span class="italic"><code class="codeph">order_key_clause</code></span> consists only of the keywords <code class="codeph">ORDER KEY</code>, then the order-key index is created with the usual default attributes.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4436"></a><div class="props_rev_3"><a id="GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1" name="GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1"></a><h5 id="ADXDB-GUID-F12AB99C-F7B1-428F-A008-D096B126E8C1" class="sect5"><span class="enumeration_section">6.3.17.9 </span>Usage of async_clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using the <code class="codeph">ASYNC</code> clause.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Use this feature only with an <code class="codeph">XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify an <code class="codeph">ASYNC</code> clause for an <code class="codeph">XMLIndex</code> index that has a <span class="italic">structured</span> component, then an error is raised. 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALWAYS</code> means automatic synchronization occurs for each DML statement.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">MANUAL</code> means no automatic synchronization occurs. You must manually synchronize the index using <code class="codeph">DBMS_XMLINDEX.syncIndex</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">EVERY</code> <span class="italic"><code class="codeph">repeat_interval</code></span> means automatically synchronize the index at interval <span class="italic"><code class="codeph">repeat_interval</code></span>. The syntax of <span class="italic"><code class="codeph">repeat_interval</code></span> is the same as that for PL/SQL package <code class="codeph">DBMS_SCHEDULER</code>, and it must be enclosed in double quotation marks (<span class="bold"><code class="codeph">"</code></span>). To use <code class="codeph">EVERY</code> you must have the <code class="codeph">CREATE JOB</code> privilege.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ON COMMIT</code> means synchronize the index immediately after a commit operation. The commit does not return until the synchronization is complete. Since the synchronization is performed as a separate transaction, there can be a short period when the data is committed but index changes are not yet committed.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">STALE</code> is optional. A value of <code class="codeph">TRUE</code> means that query results might be stale; a value of <code class="codeph">FALSE</code> means that query results are always up-to-date. The default value, and the only permitted explicitly specified value, is as follows.
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>For <code class="codeph">ALWAYS</code>, <code class="codeph">STALE</code> is <code class="codeph">FALSE</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>For any other <code class="codeph">ASYNC</code> option besides <code class="codeph">ALWAYS</code>, <code class="codeph">STALE</code> is <code class="codeph">TRUE</code>.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4437"></a><div class="props_rev_3"><a id="GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" name="GUID-35B0101C-DB6B-460B-9587-D7254DD1079D"></a><h5 id="ADXDB-GUID-35B0101C-DB6B-460B-9587-D7254DD1079D" class="sect5"><span class="enumeration_section">6.3.17.10 </span>Usage of groups_clause and alter_index_group_clause
                     </h5>
                     <div>
                        <p>Clause <span class="italic"><code class="codeph">groups_clause</code></span> is used only with <code class="codeph">CREATE INDEX</code> (or following <code class="codeph">ADD GROUP</code> in clause  <span class="italic"><code class="codeph">alter_index_group_clause</code></span>). Clause <span class="italic"><code class="codeph">alter_index_group_clause</code></span> is used only with <code class="codeph">ALTER INDEX</code>. 
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4438"></a><div class="props_rev_3"><a id="GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" name="GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42"></a><h5 id="ADXDB-GUID-A4FD18EE-D43B-44B0-86CE-27D4CE995E42" class="sect5"><span class="enumeration_section">6.3.17.11 </span>Usage of XMLIndex_xmltable_clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span>.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <span class="italic"><code class="codeph">XQuery_string</code></span> expression in <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span> must not use the XQuery functions <code class="codeph">ora:view</code> (<span class="italic">desupported</span>), <code class="codeph">fn:doc</code>, or <code class="codeph">fn:collection</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Oracle XML&nbsp;DB raises an error if a given <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span> contains more than one <span class="italic"><code class="codeph">column_clause</code></span> of data type <code class="codeph">XMLType</code>. To achieve the effect of defining two such virtual columns, you must instead add a separate <span class="italic"><code class="codeph">group_clause</code></span>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">PASSING</code> clause in <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span> is optional. If not present, then an <code class="codeph">XMLType</code> column is passed implicitly, as follows:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>For the first <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span> in a parameters clause, the <code class="codeph">XMLType</code> column being indexed is passed implicitly. (When indexing an <code class="codeph">XMLType</code> table, pseudocolumn <code class="codeph">OBJECT_VALUE</code> is passed.)
                                       </p>
                                    </li>
                                    <li>
                                       <p>For each subsequent <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span>, the <code class="codeph">VIRTUAL</code> <code class="codeph">XMLType</code> column of the preceding <span class="italic"><code class="codeph">XMLIndex_xmltable_clause</code></span> is passed implicitly.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4439"></a><div class="props_rev_3"><a id="GUID-D4474161-F125-4703-98D2-7C609F8806E7" name="GUID-D4474161-F125-4703-98D2-7C609F8806E7"></a><h5 id="ADXDB-GUID-D4474161-F125-4703-98D2-7C609F8806E7" class="sect5"><span class="enumeration_section">6.3.17.12 </span>Usage of column_clause
                     </h5>
                     <div>
                        <p>Certain considerations apply to using <span class="italic"><code class="codeph">column_clause</code></span>.
                        </p>
                        <div class="section">
                           <p>When you use multilevel chaining of <code class="codeph">XMLTable</code> in an <code class="codeph">XMLIndex</code> index, the <code class="codeph">XMLTable</code> table at one level corresponds to an <code class="codeph">XMLType</code> column at the previous level. The syntax description shows keyword <code class="codeph">VIRTUAL</code> as optional. In fact, it is used only for such an <code class="codeph">XMLType</code> column, in which case it is <span class="italic">required</span>. It is an error to use it for a non-<code class="codeph">XMLType</code> column. <code class="codeph">VIRTUAL</code> specifies that the <code class="codeph">XMLType</code> column itself is not materialized, meaning that its data is stored in the index only in the form of the relational columns specified by its corresponding <code class="codeph">XMLTable</code> table.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BCC7D521-E6B9-4636-98E1-25628BA0FEFC" title="Creation or modification of an XMLIndex index often involves the use of a PARAMETERS clause with SQL statement CREATE INDEX or ALTER INDEX. You can use it to specify index characteristics in detail.">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4442"></a><div class="props_rev_3"><a id="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" name="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C"></a><h3 id="ADXDB-GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" class="sect3"><span class="enumeration_section">6.4 </span>Indexing XML Data for Full-Text Queries
               </h3>
               <div>
                  <p>When you need full-text search over XML data, Oracle recommends that you store your <code class="codeph">XMLType</code> data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.
                  </p>
                  <p>If portability and standardized code are not a concern, or if your <code class="codeph">XMLType</code> data is stored object-relationally, then you can alternatively use the Oracle-specific full-text constructs and syntax provided by Oracle Text, specifically Oracle SQL function <code class="codeph">contains</code> or Oracle XPath function <code class="codeph">ora:contains</code> (<span class="italic">deprecated</span>).
                  </p>
                  <p>You can perform XQuery Full Text (XQFT) queries on <code class="codeph">XMLType</code> data that is stored as binary XML. If you use an XQFT full-text predicate in an <code class="codeph">XMLExists</code> expression within a SQL <code class="codeph">WHERE</code> clause, then you must create an <strong class="term">XML search index</strong>. This section describes the creation and use of such an index.
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55">Creating and Using an XML Search Index</a><br>An XQuery Full Text query can use an XML search index to improve performance.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-BB2425FE-DD0F-414B-8166-906C77F824FD">What To Do If an XML Search Index Is Not Picked Up</a><br>You can modify your query to ensure that certain conditions are satisfied, so its evaluation picks up an XML search index.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2">Pragma ora:no_schema: Using XML Schema-Based Data with XQuery Full Text</a><br>Oracle recommends in general that you use <span class="italic">non</span> XML Schema-based <code class="codeph">XMLType</code> data when you use XQuery Full Text and an XML search index. But you can in some circumstances use XML Schema-based <code class="codeph">XMLType</code> data that is stored as binary XML. Oracle XQuery pragma <code class="codeph">ora:no_schema</code> can be useful in this context.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9">Pragma ora:use_xmltext_idx: Forcing the Use of an XML Search Index</a><br>You can use XQuery pragma <code class="codeph">ora:use_xmltext_idx</code> to force the use of an XML search index.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-85F61312-2713-416F-B741-85C2E2D4A13E">Migrating from Using Oracle Text Index to XML Search Index</a><br>If you have legacy queries for <code class="codeph">XMLType</code> data stored as binary XML that use SQL function <code class="codeph">CONTAINS</code> or  <span class="italic">deprecated</span> XPath function <code class="codeph">ora:contains</code> and an Oracle Text index that is not XML-enabled, then consider using XQuery Full Text constructs instead.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML&nbsp;DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">Support for XQuery Full Text</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C__GUID-3CBA64CD-769A-4B77-8E13-C01737583C86">
                     <p class="notep1">See Also:</p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-46</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6148"></a><a id="ADXDB6149"></a><a id="ADXDB6150"></a><a id="ADXDB6147"></a><div class="props_rev_3"><a id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55" name="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55"></a><h4 id="ADXDB-GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55" class="sect4"><span class="enumeration_section">6.4.1 </span>Creating and Using an XML Search Index
                  </h4>
                  <div>
                     <p>An XQuery Full Text query can use an XML search index to improve performance.</p>
                     <div class="section">
                        <p>To create an XML search index you must be granted database role <a id="d34642e10726" class="indexterm-anchor"></a><a id="d34642e10728" class="indexterm-anchor"></a><code class="codeph">CTXAPP</code>. More generally, this role is needed to create Oracle Text indexes, to set Oracle Text index preferences, or to use Oracle Text PL/SQL packages.
                        </p>
                        <p>Before creating the index, you must create an Oracle Text path section group and set its <a id="d34642e10737" class="indexterm-anchor"></a><code class="codeph">XML_ENABLE</code> attribute to <code class="codeph">t</code>. This makes the path section group XML-aware. 
                        </p>
                        <p>For best performance, create an index preference of type <code class="codeph">BASIC_STORAGE</code> in the Oracle Text data dictionary, specifying the following attributes:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">D_TABLE_CLAUSE</code> &#x2013; Specify <code class="codeph">SECUREFILE</code> storage for column <code class="codeph">DOC</code> of index data table <code class="codeph">$D</code>, which contains information about the structure of your XML documents. Specify <span class="italic">caching</span> and medium <span class="italic">compression</span>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">I_TABLE_CLAUSE</code> &#x2013; Specify <code class="codeph">SECUREFILE</code> storage for column <code class="codeph">TOKEN_INFO</code> of index data table <code class="codeph">$I</code>, which contains information about full-text tokens and their occurrences in the indexed documents. Specify <span class="italic">caching</span> (but not compression).
                              </p>
                           </li>
                        </ul>
                        <p>This is illustrated in <a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-41</a>, which uses a non XML-schema-based <code class="codeph">XMLType</code> table, <code class="codeph">po_binxml</code> (which has the same data as table <code class="codeph">purchaseorder</code> in standard database schema <code class="codeph">OE</code>).
                        </p>
                        <p>Index preference <code class="codeph">BASIC_STORAGE</code> specifies the tablespace and creation parameters for the database tables and indexes that constitute an Oracle Text index.
                        </p>
                        <div class="infoboxnotealso" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__GUID-DD6B5E3A-7690-475E-AFEB-72D64801F97A">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0234" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about section groups
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../ccref/CTX_DDL-package.html#CCREF24098" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about procedure <code class="codeph">CTX_DDL.set_sec_grp_attr</code></p>
                              </li>
                              <li>
                                 <p><a href="../ccref/CTX_DDL-package.html#CCREF0624" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about procedure <code class="codeph">CTX_DDL.create_preference</code></p>
                              </li>
                              <li>
                                 <p><a href="../ccref/CTX_DDL-package.html#CCREF0650" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about procedure <code class="codeph">CTX_DDL.set_attribute</code></p>
                              </li>
                              <li>
                                 <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF2028" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> for information about preference <code class="codeph">BASIC_STORAGE</code>, <code class="codeph">D_TABLE_CLAUSE</code>, and <code class="codeph">I_TABLE_CLAUSE</code></p>
                              </li>
                           </ul>
                        </div>
                        <p><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">Example 6-42</a> queries the data to retrieve the <code class="codeph">Description</code> elements whose text contains both <code class="codeph">Big</code> and <code class="codeph">Street</code>, in that order.
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">Example 6-43</a> shows the execution plan for the query, which indicates that index <code class="codeph">po_ctx_idx</code> is picked up.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">
                        <p class="titleinexample">Example 6-41 Creating an XML Search Index</p><pre class="oac_no_warn" dir="ltr">BEGIN
  CTX_DDL.<span class="bold">create_section_group</span>('mysecgroup', '<span class="bold">PATH_SECTION_GROUP</span>');
  CTX_DDL.<span class="bold">set_sec_grp_attr</span>('mysecgroup', '<span class="bold">XML_ENABLE</span>', '<span class="bold">T</span>');

  CTX_DDL.<span class="bold">create_preference</span>('mypref', '<span class="bold">BASIC_STORAGE</span>');
  CTX_DDL.<span class="bold">set_attribute</span>('mypref',
                        '<span class="bold">D_TABLE_CLAUSE</span>',
                        'TABLESPACE my_ts
                         <span class="bold">LOB(DOC)</span> <span class="bold">STORE AS SECUREFILE</span> 
                         <span class="bold">(TABLESPACE</span> my_ts <span class="bold">COMPRESS MEDIUM CACHE)</span>');
  CTX_DDL.<span class="bold">set_attribute</span>('mypref',
                        '<span class="bold">I_TABLE_CLAUSE</span>',
                        'TABLESPACE my_ts
                         <span class="bold">LOB(TOKEN_INFO)</span> <span class="bold">STORE AS SECUREFILE</span>
                         <span class="bold">(TABLESPACE</span> my_ts <span class="bold">NOCOMPRESS CACHE)</span>');
END;
/

CREATE INDEX po_ctx_idx ON po_binxml(OBJECT_VALUE)
  INDEXTYPE IS <span class="bold">CTXSYS.CONTEXT</span>
  PARAMETERS('<span class="bold">storage</span> mypref <span class="bold">section group</span> mysecgroup');
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGJABCA">
                        <p class="titleinexample">Example 6-42 XQuery Full Text Query</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery('for $i in /PurchaseOrder/LineItems/LineItem/Description
                   where $i[<span class="bold">. contains text "Big" ftand "Street"</span>]
               return &lt;Title&gt;{$i}&lt;/Title&gt;'
               PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM po_binxml
  WHERE XMLExists('/PurchaseOrder/LineItems/LineItem/Description
                   [<span class="bold">. contains text "Big" ftand "Street"</span>]'
                  PASSING OBJECT_VALUE);
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGCHDFB">
                        <p class="titleinexample">Example 6-43 Execution Plan for XQuery Full Text Query</p><pre class="oac_no_warn" dir="ltr">------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |  2014 |     4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| PO_BINXML  |     1 |  2014 |     4   (0)| 00:00:01 |
|*  2 |   DOMAIN INDEX              | <span class="bold">PO_CTX_IDX</span> |       |       |     4   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("CTXSYS"."CONTAINS"(SYS_MAKEXML(0,"XMLDATA"),'&lt;query&gt;&lt;textquery
              grammar="CONTEXT" lang="english"&gt; <span class="bold">( ( {Big} ) and ( {Street} ) )</span>  INPATH
              (/PurchaseOrder/LineItems/LineItem/<span class="bold">Description</span>)&lt;/textquery&gt;&lt;/query&gt;')&gt;0)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
   - Unoptimized XML construct detected (enable XMLOptimizationCheck for more information)
 
21 rows selected.
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6151"></a><div class="props_rev_3"><a id="GUID-BB2425FE-DD0F-414B-8166-906C77F824FD" name="GUID-BB2425FE-DD0F-414B-8166-906C77F824FD"></a><h4 id="ADXDB-GUID-BB2425FE-DD0F-414B-8166-906C77F824FD" class="sect4"><span class="enumeration_section">6.4.2 </span>What To Do If an XML Search Index Is Not Picked Up
                  </h4>
                  <div>
                     <p>You can modify your query to ensure that certain conditions are satisfied, so its evaluation picks up an XML search index.</p>
                     <div class="section">
                        <p>If you use an XQuery full-text predicate in an <code class="codeph">XMLExists</code> expression within a SQL <code class="codeph">WHERE</code> clause, but you do not create an XML search index or the index cannot be used for some reason, then compile-time error ORA-18177 is raised.
                        </p>
                        <p>If this error is raised then your execution plan does <span class="italic">not</span> indicate that the index is picked up. In the plan you do not see operation <code class="codeph">DOMAIN INDEX</code> followed by the name of the index.
                        </p>
                        <p>In that case, try to change your query to enable the index to be used. The following conditions must both apply for the index to be picked up:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The expression that computes the XML nodes for the search context must be an XPath expression whose steps are only along <span class="italic">forward</span> and <span class="italic">descendent axes</span>.
                              </p>
                           </li>
                           <li>
                              <p>You can pass only one <code class="codeph">XMLType</code> instance as a SQL expression in the <code class="codeph">PASSING</code> clause of SQL/XML function <code class="codeph">XMLExists</code>, and each of the other, non-<code class="codeph">XMLType</code> SQL expressions in that clause must be either a <span class="italic">compile-time constant</span> of a SQL built-in data type or a <span class="italic">bind variable</span> that is bound to an instance of such a data type.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6153"></a><a id="ADXDB6154"></a><a id="ADXDB6152"></a><div class="props_rev_3"><a id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2" name="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2"></a><h4 id="ADXDB-GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2" class="sect4"><span class="enumeration_section">6.4.3 </span>Pragma ora:no_schema: Using XML Schema-Based Data with XQuery Full Text
                  </h4>
                  <div>
                     <p>Oracle recommends in general that you use <span class="italic">non</span> XML Schema-based <code class="codeph">XMLType</code> data when you use XQuery Full Text and an XML search index. But you can in some circumstances use XML Schema-based <code class="codeph">XMLType</code> data that is stored as binary XML. Oracle XQuery pragma <code class="codeph">ora:no_schema</code> can be useful in this context.
                     </p>
                     <p>By default, when an XML search index is used to evaluate XML Schema-based data, compile-time error ORA-18177 is raised. This is because the full-text indexing itself makes no use of the associated XML schema: it is not type-aware. It treats all of the text that it applies to as untyped. This error is raised even if you type-cast data appropriately and thus do not depend on the XML schema to cast types implicitly. <a href="indexes-for-XMLType-data.html#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGIEJJA">Example 6-44</a> illustrates this.
                     </p>
                     <p>The error raised draws this to your attention, in case you might be expecting a full-text condition in your query to depend on XML Schema types and typed operations.</p>
                     <p>In order to use a condition that depends on types you must explicitly cast the relevant XQuery expressions to the appropriate types. Do not expect Oracle XML&nbsp;DB to use the XML schema to perform implicit type casting. Failure to type-cast appropriately can lead to results that you might not expect.</p>
                     <p><a href="indexes-for-XMLType-data.html#GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGBHDEE">Example 6-45</a> shows a query of XML Schema-based data that uses explicit type-casting to ensure that the proper condition is evaluated.
                     </p>
                     <p>However, most uses of XQuery Full Text expressions, even with XML Schema-based data, do not involve data that is typed. Just remember that if you do use a condition that makes use of typed data then you must cast to the proper type.</p>
                     <p>In sum, if you are sure that your query does not involve typed data, or if you judge that it is all right to treat particular typed data as if it were untyped, or if you explicitly type-cast any data that needs to be typed, then you can use Oracle XQuery pragma <code class="codeph">ora:no_schema</code> in your query to inhibit raising the error and allow evaluation of the query using an XML search index.
                     </p>
                     <div class="example" id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGIEJJA">
                        <p class="titleinexample">Example 6-44 XQuery Full Text Query with XML Schema-Based Data: Error ORA-18177</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM oe.purchaseorder
  WHERE XMLExists('/PurchaseOrder
                   [LineItems/LineItem/@ItemNumber &gt; xs:integer("20")
                    and Actions/Action/User contains text "KPARTNER"]'
                  PASSING OBJECT_VALUE);
  FROM oe.purchaseorder
          *
ERROR at line 3:
<span class="bold">ORA-18177</span>: XQuery full text expression '/PurchaseOrder
[LineItems/LineItem/@ItemNumber &gt; xs:integer("20")
and Actions/Action/User contains text "KPARTNER"]'
<span class="bold">cannot be evaluated using XML text index</span>
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E53BBE3C-CDFB-4A64-96E0-C16497D060C2__CEGBHDEE">
                        <p class="titleinexample">Example 6-45 Using XQuery Pragma ora:no_schema with XML Schema-Based Data</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM oe.purchaseorder
  WHERE XMLExists('<span class="bold">(# ora:no_schema #)</span>
                   {/PurchaseOrder
                    [LineItems/LineItem/@ItemNumber &gt; <span class="bold">xs:integer</span>("20")
                     and Actions/Action/User contains text "KPARTNER"]}'
                  PASSING OBJECT_VALUE);
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5830"></a><a id="ADXDB6155"></a><div class="props_rev_3"><a id="GUID-748DD8D4-2311-4D02-B050-A5940204A2A9" name="GUID-748DD8D4-2311-4D02-B050-A5940204A2A9"></a><h4 id="ADXDB-GUID-748DD8D4-2311-4D02-B050-A5940204A2A9" class="sect4"><span class="enumeration_section">6.4.4 </span>Pragma ora:use_xmltext_idx: Forcing the Use of an XML Search Index
                  </h4>
                  <div>
                     <p>You can use XQuery pragma <code class="codeph">ora:use_xmltext_idx</code> to force the use of an XML search index.
                     </p>
                     <p>A given query involving XML data can be evaluated in various ways, depending on the existence of different indexes and other factors. Sometimes the default evaluation method is not the most performant and it would be more efficient to force the use of an existing XML search index. You can use XQuery pragma <code class="codeph">ora:use_xmltext_idx</code> to do this. (An XML search index applies only to <code class="codeph">XMLType</code> data stored as binary XML.)
                     </p>
                     <p>For example, a <code class="codeph">WHERE</code> clause might include two <code class="codeph">XMLExists</code> expressions, only one of which involves an XQuery full-text condition, and you might have an <code class="codeph">XMLIndex</code> index that applies to the <code class="codeph">XMLExists</code> expression that has no full-text condition. With such a query it is typically more efficient to use an XML search index to evaluate the entire <code class="codeph">WHERE</code> clause.
                     </p>
                     <p>Even in some cases where there is no full-text condition in the query, the use of an XML search index can provide the most efficient query evaluation.</p>
                     <p>The query in <a href="indexes-for-XMLType-data.html#GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">Example 6-46</a> illustrates the use of pragma <code class="codeph">ora:use_xmltext_idx</code>. Only the first of the <code class="codeph">XMLExists</code> clauses uses a full-text condition. Because of the pragma, the full-text index (<code class="codeph">po_ctx_idx</code>, created in <a href="indexes-for-XMLType-data.html#GUID-A48B77D9-A4C1-47B9-9664-D921D070AF55__CEGIAAGI">Example 6-41</a>) is used for both <code class="codeph">XMLExists</code> clauses.
                     </p>
                     <div class="example" id="GUID-748DD8D4-2311-4D02-B050-A5940204A2A9__BCGDEHEA">
                        <p class="titleinexample">Example 6-46 Full-Text Query with XQuery Pragma ora:use_xmltext_idx</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM po_binxml
  WHERE XMLExists('/PurchaseOrder/LineItems/LineItem
                   [Description contains text "Picnic"]' PASSING OBJECT_VALUE)
    AND XMLExists('<span class="bold">(# ora:use_xmltext_idx #)</span> {/PurchaseOrder[User="SBELL"]}'
                  PASSING OBJECT_VALUE);</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6157"></a><a id="ADXDB6156"></a><div class="props_rev_3"><a id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E" name="GUID-85F61312-2713-416F-B741-85C2E2D4A13E"></a><h4 id="ADXDB-GUID-85F61312-2713-416F-B741-85C2E2D4A13E" class="sect4"><span class="enumeration_section">6.4.5 </span>Migrating from Using Oracle Text Index to XML Search Index
                  </h4>
                  <div>
                     <p>If you have legacy queries for <code class="codeph">XMLType</code> data stored as binary XML that use SQL function <code class="codeph">CONTAINS</code> or  <span class="italic">deprecated</span> XPath function <code class="codeph">ora:contains</code> and an Oracle Text index that is not XML-enabled, then consider using XQuery Full Text constructs instead.
                     </p>
                     <div class="section">
                        <p>The XQuery and XPath Full Text (XQFT) standard is supported by Oracle XML&nbsp;DB starting with Oracle Database&nbsp;12c Release 1 (12.1). This support applies only to <code class="codeph">XMLType</code> data stored as binary XML. Prior to that release, for full-text querying of XML data you could use only an Oracle Text index that was not XML-enabled (not an XML search index), and your full-text queries necessarily used Oracle-specific constructs: SQL function <code class="codeph">CONTAINS</code> or XPath function <code class="codeph">ora:contains</code> (<span class="italic">deprecated</span>).
                        </p>
                        <p>If you have legacy code that does this, Oracle recommends that you migrate that code to use XQFT. This section provides information about which XQFT constructs you can use to replace the use of <code class="codeph">CONTAINS</code> and <code class="codeph">ora:contains</code> in queries.
                        </p>
                        <p>This use of an Oracle Text index can also be replaced by the use of an XML search index. To replace a query that uses <code class="codeph">HASPATH</code> by one that uses a simple XQuery expression, you use Oracle XQuery pragma <code class="codeph">ora:use_xmltext_idx</code> to specify that the XML search index is to be picked up. This section also illustrates this.
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGECFIA" title="This table provides a mapping from typical queries that use Oracle-specific constructs to queries that use XQuery.">Table 6-9</a> provides a mapping from typical queries that use Oracle-specific constructs to queries that use XQuery Full Text.
                        </p>
                        <div class="tblformalwide" id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGECFIA">
                           <p class="titleintable">Table 6-9 Migrating Oracle-Specific XML Queries to XQuery Full Text</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Migrating Oracle-Specific XML Queries to XQuery Full Text" summary="This table provides a mapping from typical queries that use Oracle-specific constructs to queries that use XQuery." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d34642e11379">Original Example</th>
                                    <th align="left" valign="bottom" width="50%" id="d34642e11382">Replacement Example</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11387" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '<span class="bold">HASPATH</span> (/P/LIs/LI/Description<a id="GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGBBCGC" name="GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGBBCGC" href="#GUID-85F61312-2713-416F-B741-85C2E2D4A13E__CEGBBCGC" onclick="footdisplay(3, "The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id < \"31415927\"].")"><sup>Foot&nbsp;3</sup></a>)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11387 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('<span class="bold">(# ora:use_xmltext_idx #)</span> 
           {$d/P/LIs/LI/Description<a id="fnsrc_d34642e11409" name="fnsrc_d34642e11409" href="#fnsrc_d34642e11409" onclick="footdisplay(3, "The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id < \"31415927\"].")"><sup>Footref&nbsp;3</sup></a>}'
          PASSING t.x AS "d")</code></pre><p>Or if the data is XML Schema-based:</p><pre class="pre codeblock"><code>XMLExists('<span class="bold">(# ora:use_xmltext_idx #)</span>
           {<span class="bold">(# ora:no_schema #)</span> 
            {$d/P/LIs/LI/Description<a id="fnsrc_d34642e11422" name="fnsrc_d34642e11422" href="#fnsrc_d34642e11422" onclick="footdisplay(3, "The path test can contain a predicate expression, which is the same for both the original query (with HASPATH) and its replacement. For example: /PurchaseOrder/LineItems/LineItem/Part[@Id < \"31415927\"].")"><sup>Footref&nbsp;3</sup></a>}}'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11426" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, 'Big INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11426 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text "Big"]'
          PASSING t.x AS "d")</code></pre><p>Or if the data is XML Schema-based:</p><pre class="pre codeblock"><code>XMLExists('<span class="bold">(# ora:no_schema #)</span>
           {$d/P/LIs/LI/Description
           [. contains text "Big"]}'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11440" headers="d34642e11379 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [<span class="bold">ora:contains</span>(., "Big <span class="bold">AND</span> Street") &gt; 0]'
          PASSING t.x AS "d")</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11440 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text "Big" <span class="bold">ftand</span> "Street"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11456" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '(Big) <span class="bold">AND</span> (Street) INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11456 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text "Big" <span class="bold">ftand</span> "Street"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11469" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '(Big) <span class="bold">OR</span> (Street) INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11469 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text "Big" <span class="bold">ftor</span> "Street"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11482" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '({Big}) <span class="bold">NOT</span> ({Street}) INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11482 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text
            "Big" <span class="bold">ftand</span> <span class="bold">ftnot</span> "Street"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11498" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '({Street}) <span class="bold">MNOT</span> ({Big Street}) INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11498 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text
            "Street" <span class="bold">not in</span> "Big Street"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11511" headers="d34642e11379 "><pre class="pre codeblock"><code>CONTAINS(t.x, '(<span class="bold">NEAR</span> (({Big}, {Street}), <span class="bold">3</span>) INPATH
               (/P/LIs/LI/Description)') &gt; 0</code></pre></td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11511 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('$d/P/LIs/LI/Description
           [. contains text
            "Big" <span class="bold">ftand</span> "Street" <span class="bold">window 3 words</span>]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d34642e11530" headers="d34642e11379 ">
                                       <p>(Not applicable &#x2013; Oracle Text queries are not XML namespace aware.)</p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d34642e11530 d34642e11382 "><pre class="pre codeblock"><code>XMLExists('<span class="bold">declare namespace</span>
           <span class="bold">ipo="http://www.example.com/IPO";</span>
           /<span class="bold">ipo:</span>P/<span class="bold">ipo:</span>LIs/<span class="bold">ipo:</span>LI/<span class="bold">ipo:</span>Description
           [. contains text "Big"]'
          PASSING t.x AS "d")</code></pre></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3 </sup></p><p>The path test can contain a predicate expression, which is the same for both the original query (with <code class="codeph">HASPATH</code>) and its replacement. For example: <code class="codeph">/PurchaseOrder/LineItems/LineItem/Part[@Id &lt; "31415927"]</code>.
                           </p>
                        <p></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FAB7C619-902A-40CF-98B7-6D358E1AD49C" title="When you need full-text search over XML data, Oracle recommends that you store your XMLType data as binary XML and you use XQuery Full Text (XQFT). You use an XML search index for this. This is the topic of this section.">Indexing XML Data for Full-Text Queries</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4320"></a><div class="props_rev_3"><a id="GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" name="GUID-BF638421-9D6E-4D72-8371-79D084A04BCA"></a><h3 id="ADXDB-GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" class="sect3"><span class="enumeration_section">6.5 </span>Indexing XMLType Data Stored Object-Relationally
               </h3>
               <div>
                  <p>You can effectively index <code class="codeph">XMLType</code> data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.
                  </p>
                  <div class="section">
                     <p>If the data to be indexed is a <span class="italic">singleton</span>, that is, if it can occur only once in any XML instance document, then you can use a <span class="italic">shortcut</span> of ostensibly creating a function-based index, where the expression defining the index is a functional application, with an XPath-expression argument that targets the singleton data. A shortcut is defined for <code class="codeph">XMLCast</code> applied to <code class="codeph">XMLQuery</code>, and another shortcut is defined for (deprecated) Oracle SQL function <code class="codeph">extractValue</code>.
                     </p>
                     <p>In many cases, Oracle XML&nbsp;DB then automatically creates appropriate indexes on the underlying object-relational tables or columns; it does <span class="italic">not</span> create a function-based index on the targeted <code class="codeph">XMLType</code> data as the <code class="codeph">CREATE INDEX</code> statement would suggest.
                     </p>
                     <p>In the case of the <code class="codeph">extractValue</code> shortcut, the index created is a B-tree index. In the case of <code class="codeph">XMLCast</code> applied to <code class="codeph">XMLQuery</code>, the index created is a function-based index on the scalar value resulting from the functional expression. 
                     </p>
                     <p>If the data to be indexed is a <span class="italic">collection</span>, then you cannot use such a shortcut; you must create the B-tree indexes manually. 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E">Indexing Non-Repeating Text Nodes or Attribute Values</a><br>Table <code class="codeph">purchaseorder</code> in sample database schema <code class="codeph">OE</code> is stored object-relationally. Each purchase-order document has a single <code class="codeph">Reference</code> element; this element is a singleton. You can thus use a shortcut to create an index on the underlying object-relational data.
                     </li>
                     <li class="ulchildlink"><a href="indexes-for-XMLType-data.html#GUID-8B74D3E8-506C-450E-882A-77F71C051F93">Indexing Repeating (Collection) Elements</a><br>In <code class="codeph">XMLType</code> data stored object-relationally, a collection is stored as an ordered collection table (OCT) of an <code class="codeph">XMLType</code> instance, which means that you can directly access its members. Because object-relational storage directly reflects the fine-grained structure of the XML data, you can create indexes that target individual collection members. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4326"></a><a id="ADXDB5818"></a><a id="ADXDB4325"></a><div class="props_rev_3"><a id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E" name="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E"></a><h4 id="ADXDB-GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E" class="sect4"><span class="enumeration_section">6.5.1 </span>Indexing Non-Repeating Text Nodes or Attribute Values
                  </h4>
                  <div>
                     <p>Table <code class="codeph">purchaseorder</code> in sample database schema <code class="codeph">OE</code> is stored object-relationally. Each purchase-order document has a single <code class="codeph">Reference</code> element; this element is a singleton. You can thus use a shortcut to create an index on the underlying object-relational data.
                     </p>
                     <div class="section">
                        <p><a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">Example 6-47</a> shows a <code class="codeph">CREATE INDEX</code> statement that ostensibly tries to create a function-based index using <code class="codeph">XMLCast</code> applied to <code class="codeph">XMLQuery</code>, targeting the text content of element <code class="codeph">Reference</code>. (The content of this element is only text, so targeting the element is the same as targeting its text node using XPath node test <code class="codeph">text()</code>.)
                        </p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">Example 6-48</a> ostensibly tries to create a function-based index using (deprecated) Oracle SQL function <code class="codeph">extractValue</code>, targeting the same data.
                        </p>
                        <p>In reality, in both <a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">Example 6-47</a> and <a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">Example 6-48</a> no function-based index is created on the targeted <code class="codeph">XMLType</code> data. Instead, Oracle XML&nbsp;DB rewrites the <code class="codeph">CREATE INDEX</code> statements to create indexes on the underlying scalar data.
                        </p>
                        <div class="infoboxnotealso" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__GUID-51DD6FB9-02E9-44BD-A1E5-714F71CE3BFE">
                           <p class="notep1">See Also:</p>
                           <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACDBHCJ">Example 19-7</a> and <a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">Example 19-8</a> for information about XPath rewrite as it applies to such <code class="codeph">CREATE INDEX</code> statements
                           </p>
                        </div>
                        <p>In some cases when you use either of these shortcuts, the <code class="codeph">CREATE INDEX</code> statement is not able to create an index on the underlying scalar data as described, and it instead actually does create a function-based index on the referenced <code class="codeph">XMLType</code> data. (This is so, even if the <span class="italic">value</span> of the index might be a scalar.)
                        </p>
                        <p>If this happens, drop the index, and create instead an <code class="codeph">XMLIndex</code> index with a structured component that targets the same XPath. As a general rule, Oracle recommends against using a function-based index on <code class="codeph">XMLType</code> data. 
                        </p>
                        <p>This is an instance of a general rule for <code class="codeph">XMLType</code> data, regardless of the storage method used: Use an <code class="codeph">XMLIndex</code> with a structured component instead of a function-based index. This rule applies starting with Oracle Database&nbsp;11g Release&nbsp;2 (11.2). Respecting this rule obviates the overhead associated with maintenance operations on function-based indexes, and it can increase the number of situations in which the optimizer can correctly select the index.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__CHDBJCCI">
                        <p class="titleinexample">Example 6-47 CREATE INDEX Using XMLCAST and XMLQUERY on a Singleton Element</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_reference_ix ON purchaseorder
  (XMLCast(XMLQuery ('$p/PurchaseOrder/Reference' PASSING po.OBJECT_VALUE AS "p"
                                                  RETURNING CONTENT)
              AS VARCHAR2(128)));</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E__BCGFIDAE">
                        <p class="titleinexample">Example 6-48 CREATE INDEX Using EXTRACTVALUE on a Singleton Element</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX po_reference_ix ON purchaseorder
  (extractValue(OBJECT_VALUE, '/PurchaseOrder/Reference'));
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="indexes-for-XMLType-data.html#GUID-48E55F3F-A918-4C85-A6B0-0287611C21E1" title="In releases prior to Oracle Database&nbsp;11g Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with XMLType data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of XMLIndex instead.">Function-Based Indexes Are Deprecated for XMLType</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4328"></a><div class="props_rev_3"><a id="GUID-8B74D3E8-506C-450E-882A-77F71C051F93" name="GUID-8B74D3E8-506C-450E-882A-77F71C051F93"></a><h4 id="ADXDB-GUID-8B74D3E8-506C-450E-882A-77F71C051F93" class="sect4"><span class="enumeration_section">6.5.2 </span>Indexing Repeating (Collection) Elements
                  </h4>
                  <div>
                     <p>In <code class="codeph">XMLType</code> data stored object-relationally, a collection is stored as an ordered collection table (OCT) of an <code class="codeph">XMLType</code> instance, which means that you can directly access its members. Because object-relational storage directly reflects the fine-grained structure of the XML data, you can create indexes that target individual collection members. 
                     </p>
                     <div class="section">
                        <p>You must create such indexes manually. The special feature of automatically creating B-tree indexes when you ostensibly create a function-based index for (deprecated) Oracle SQL function <code class="codeph">extractValue</code> does <span class="italic">not</span> apply to collections (the XPath expression passed to <code class="codeph">extractValue</code> must target a singleton).
                        </p>
                        <p>To create B-tree indexes for a collection, you must understand the structure of the SQL object that is used to manage the collection. Given this information, you can use conventional object-relational SQL code to created the indexes directly on the appropriate SQL-object attributes. Refer to <a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" title="If a collection is stored as an ordered collection table (OCT) or as an XMLType instance, then you can directly access members of the collection. Each member becomes a table row, so you can access it directly with SQL. You can often improve performance by indexing such collection members.">Guideline: Create indexes on ordered collection tables</a> for an example of how to do this.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">Footnote Legend</p>Footnote&nbsp;1: 
            <p>For <code class="codeph">XMLType</code> data stored object-relationally, see <a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="You can effectively index XMLType data that is stored object-relationally by creating B-tree indexes on the underlying database columns that correspond to XML nodes.">Indexing XMLType Data Stored Object-Relationally</a>. If your data is highly structured throughout, or your queries are not known at index creation time, then this approach might be appropriate.
            </p><br>Footnote&nbsp;2: 
            <p>The actual path table implementation may be slightly different.</p><br></div>
      </article>
   </body>
</html>