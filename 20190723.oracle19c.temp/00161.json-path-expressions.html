<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <meta name="description" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <title>SQL/JSON Path Expressions</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JSON Developer's Guide">
      <meta property="og:description" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JSON Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="json-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-22T10:58:31-08:00">
      <meta name="dcterms.title" content="JSON Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96227-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="simple-dot-notation-access-to-json-data.html" title="Previous" type="text/html">
      <link rel="next" href="clauses-used-in-functions-and-conditions-for-json.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADJSN">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="simple-dot-notation-access-to-json-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="clauses-used-in-functions-and-conditions-for-json.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JSON Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-json-data.html" property="item" typeof="WebPage"><span property="name">Query JSON Data</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL/JSON Path Expressions</li>
            </ol>
            <a id="GUID-2DC05D71-3D62-4A14-855F-76E054032494" name="GUID-2DC05D71-3D62-4A14-855F-76E054032494"></a>
            
            <h2 id="ADJSN-GUID-2DC05D71-3D62-4A14-855F-76E054032494" class="sect2"><span class="enumeration_chapter">13 </span>SQL/JSON Path Expressions
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='json-path-expressions'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
               <div class="section"></div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F">Overview of SQL/JSON Path Expressions</a><br>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.
                  </li>
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879">SQL/JSON Path Expression Syntax</a><br>SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.
                  </li>
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13">SQL/JSON Path Expression Item Methods</a><br>The Oracle item methods available for a SQL/JSON path expression are         described.
                  </li>
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-20DC09A8-98DF-4473-8077-913D490A969C">ISO 8601 Date and Time Support</a><br>International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. Oracle Database supports many of the ISO 8601 date and time formats.
                  </li>
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-D951D27D-6918-40E8-8A0D-8D60AB83FD4A">Types in Comparisons</a><br>Comparisons in SQL/JSON path-expression filter conditions are statically typed at compile time. If the effective types of the operands of a comparison are not known to be the same then an attempt is sometimes made to reconcile them by type-casting.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="query-json-data.html#GUID-119E5069-77F2-45DC-B6F0-A1B312945590" title="You can query JSON data using a simple dot notation or, for more functionality, using SQL/JSON functions and conditions. You can create and query a data guide that summarizes the structure and type information of a set of JSON documents.">Query JSON Data</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB6254"></a><div class="props_rev_3"><a id="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" name="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F"></a><h3 id="ADJSN-GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" class="sect3"><span class="enumeration_section">13.1 </span>Overview of SQL/JSON Path Expressions
               </h3>
               <div>
                  <p>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
                  <p>JSON is a notation for JavaScript values. When JSON data is stored in the database you can query it using path expressions that are somewhat analogous to XQuery or XPath expressions for XML data. Similar to the way that SQL/XML allows SQL access to XML data using XQuery expressions, Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
                  <p>SQL/JSON path expressions have a simple syntax. A path expression selects zero or more JSON values that match, or satisfy, it.</p>
                  <p>SQL/JSON condition <code class="codeph">json_exists</code> returns true if at least one value matches, and false if no value matches. If a single value matches, then SQL/JSON function <code class="codeph">json_value</code> returns that value if it is scalar and raises an error if it is non-scalar. If no value matches the path expression then <code class="codeph">json_value</code> returns SQL <code class="codeph">NULL</code>.
                  </p>
                  <p>SQL/JSON function <code class="codeph">json_query</code> returns all of the matching values, that is, it can return multiple values. You can think of this behavior as returning a sequence of values, as in XQuery, or you can think of it as returning multiple values. (No user-visible sequence is manifested.)
                  </p>
                  <p>In all cases, path-expression matching attempts to match each <span class="italic">step</span> of the path expression, in turn. If matching any step fails then no attempt is made to match the subsequent steps, and matching of the path expression fails. If matching each step succeeds then matching of the path expression succeeds.
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879" title="SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.">SQL/JSON Path Expression Syntax</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">SQL/JSON Path Expressions</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6255"></a><div class="props_rev_3"><a id="GUID-7B610884-39CD-4910-85E7-C251D342D879" name="GUID-7B610884-39CD-4910-85E7-C251D342D879"></a><h3 id="ADJSN-GUID-7B610884-39CD-4910-85E7-C251D342D879" class="sect3"><span class="enumeration_section">13.2 </span>SQL/JSON Path Expression Syntax
               </h3>
               <div>
                  <p>SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.</p>
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>You pass a SQL/JSON path expression and some JSON data to a SQL/JSON function or condition. The path expression is matched against the data, and the matching data is processed by the particular SQL/JSON function or condition. You can think of this matching process in terms of the path expression <span class="italic">returning</span> the matched data to the function or condition.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618">Basic SQL/JSON Path Expression Syntax</a><br>The basic syntax of a SQL/JSON path expression is presented. It is         composed of a context-item symbol (<code class="codeph">$</code>) followed by zero or more object,         array, and descendant steps, each of which can be followed by a filter expression, followed         optionally by a function step. Examples are provided.
                     </li>
                     <li class="ulchildlink"><a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77">SQL/JSON Path Expression Syntax Relaxation</a><br>The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="conditions-is-json-and-is-not-json.html#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a></li>
                        <li><a href="diagrams-basic-sql-json-path-expression-syntax.html" title="Syntax diagrams and corresponding Backus-Naur Form (BNF) syntax descriptions are presented for the basic SQL/JSON path expression syntax.">Diagrams for Basic SQL/JSON Path Expression Syntax</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">SQL/JSON Path Expressions</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6372"></a><div class="props_rev_3"><a id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" name="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618"></a><h4 id="ADJSN-GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" class="sect4"><span class="enumeration_section">13.2.1 </span>Basic SQL/JSON Path Expression
        Syntax
                  </h4>
                  <div>
                     <p>The basic syntax of a SQL/JSON path expression is presented. It is
        composed of a context-item symbol (<code class="codeph">$</code>) followed by zero or more object,
        array, and descendant steps, each of which can be followed by a filter expression, followed
        optionally by a function step. Examples are provided.
                     </p>
                     <div class="section">
                        <p>However, this basic syntax is extended by relaxing the matching of
                arrays and non-arrays against non-array and array patterns, respectively — see <a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">SQL/JSON Path Expression Syntax Relaxation</a>.
                        </p>
                        <p>Matching of data against SQL/JSON path expressions is
                case-sensitive.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A SQL/JSON <span class="bold"><strong class="term">basic path
                                expression</strong></span> (also called just a <span class="italic">path expression</span>
                        here) is an <span class="italic">absolute path expression</span> or a <span class="italic">relative path
                            expression</span>.
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">absolute path
                                expression</strong></span> begins with a dollar sign
                            (<code class="codeph"><span class="bold">$</span></code>), which represents the path-expression
                                <span class="bold"><strong class="term">context item</strong></span>, that is, the JSON data
                        to be matched. That data is the result of evaluating a SQL expression that
                        is passed as argument to the SQL/JSON function. The dollar sign is followed
                        by zero or more <span class="italic">nonfunction steps</span>, followed by an optional
                            <span class="italic">function step</span>.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">relative path
                                expression</strong></span> is an at sign (<code class="codeph"><span class="bold">@</span></code>)
                        followed by zero or more <span class="italic">nonfunction steps</span>, followed by an optional
                            <span class="italic">function step</span>. It has the same syntax as an <span class="italic">absolute path
                            expression</span>, except that it uses an at sign instead of a dollar sign
                            (<code class="codeph">$</code>).
                              </p>
                              <p>A relative path expression is
                        used inside a <span class="italic">filter expression</span> (<span class="italic">filter</span>, for short). The at
                        sign represents the path-expression <span class="bold"><strong class="term">current filter
                                item</strong></span>, that is, the JSON data that matches the part of the
                        (surrounding) path expression that precedes the filter containing the
                        relative path expression. A relative path expression is matched against the
                        current filter item in the same way that an absolute path expression is
                        matched against the context item.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">nonfunction step</strong></span>
                        is an <span class="italic">object step</span>, an <span class="italic">array step</span>, or a <span class="italic">descendant step</span>,
                        followed by an optional <span class="italic">filter expression</span>. 
                              </p>
                           </li>
                           <li>
                              <p>A single <span class="bold"><strong class="term">function
                            step</strong></span> is <span class="italic">optional</span> in a <span class="italic">basic path expression</span>
                        (absolute or a relative). If present, it is the last step of the path
                        expression. It is a period (<code class="codeph"><span class="bold">.</span></code>), sometimes read as
                        "dot", followed by a SQL/JSON <span class="bold"><strong class="term">item method</strong></span>,
                        followed by a left parenthesis (<code class="codeph"><span class="bold">(</span></code>) and then a right
                        parenthesis (<code class="codeph"><span class="bold">)</span></code>). The parentheses can have whitespace
                        between them (such whitespace is insignificant). 
                              </p>
                              <p>The
                        item method is applied to the data that is targeted by the rest of the same
                        path expression, which <span class="italic">precedes</span> the function step. The item method is
                        used to transform that data. The SQL function or condition that is passed
                        the path expression as argument uses the transformed data in place of the
                        targeted data.
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">object step</strong></span> is
                        a period (<code class="codeph"><span class="bold">.</span></code>), followed by an object field name or an
                        asterisk (<span class="bold"><code class="codeph">*</code></span>) wildcard, which stands for (the values
                        of) <span class="italic">all</span> fields. A field name can be <span class="italic">empty</span>, in which case it
                            <span class="italic">must</span> be written as <code class="codeph"><span class="bold">""</span></code> (no intervening
                        whitespace). A nonempty field name must start with an uppercase or lowercase
                        letter A to Z and contain only such letters or decimal digits (0-9), or else
                        it must be enclosed in double quotation marks (<span class="bold"><code class="codeph">"</code></span>).
                        
                              </p>
                              <p>An object step returns the <span class="italic">value</span> of the field
                        that is specified. If a wildcard is used for the field then the step returns
                        the values of <span class="italic">all</span> fields, in no special order.
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">array step</strong></span> is a
                        left bracket (<span class="bold"><code class="codeph">[</code></span>) followed by <span class="italic">either</span> an
                        asterisk (<span class="bold"><code class="codeph">*</code></span>) wildcard, which stands for <span class="italic">all</span>
                        array elements, <span class="italic">or</span> one or more specific array indexes or range
                        specifications separated by commas (<code class="codeph"><span class="bold">,</span></code>), followed by
                        a right bracket (<span class="bold"><code class="codeph">]</code></span>). An error is raised if you use
                        both an asterisk and either an array index or a range specification.
                              </p>
                              <p>In a path expression, <span class="bold"><strong class="term">array
                                indexing</strong></span> is zero-based (0, 1, 2,...), as in the
                        JavaScript convention for arrays. A <span class="bold"><strong class="term">range
                                specification</strong></span> has the form <span class="italic"><code class="codeph">N</code></span> to
                                <span class="italic"><code class="codeph">M</code></span>, where <span class="italic"><code class="codeph">N</code></span> and
                                <span class="italic"><code class="codeph">M</code></span> are array indexes and
                                <span class="italic"><code class="codeph">N</code></span> is strictly less than
                                <span class="italic"><code class="codeph">M</code></span>.<a id="fn_1" name="fn_1" href="#fn_1" onclick="footdisplay(1, "The to in a range specification is sometimes informally called the array slice operator.")"><sup>Foot&nbsp;1</sup></a> An error is raised at query compilation
                        time if <span class="italic"><code class="codeph">N</code></span> is not less than
                        <span class="italic"><code class="codeph">M</code></span>.
                              </p>
                              <p>When indexes or range specifications are used, the array
                        elements they collectively specify must be specified in ascending order,
                        without repetitions, or else a compile-time error is raised. For example, an
                        error is raised for each of <code class="codeph">[3, 1 to 4]</code>, <code class="codeph">[4,
                            2]</code>, <code class="codeph">[2, 3 to 3]</code>, and <code class="codeph">[2, 3,
                            3]</code>. Errors are raised on the first two because the order is not
                        ascending, Errors are raised on the last two because of the repetition of
                        array index <code class="codeph">3</code> (which indexes the fourth array element,
                        because of zero-based indexing).
                              </p>
                              <p>Similarly, the elements
                        in the array value that results from matching are in ascending order, with
                        no repetitions. If an asterisk is used in the path expression then all of
                        the array elements are returned, in array order. </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">descendant</strong></span> step
                        is two consecutive periods (<span class="bold"><code class="codeph">..</code></span>), sometimes read as
                        "dot dot", followed by a field name (which has the same syntax as for an
                            <span class="italic">object step</span>). 
                              </p>
                              <p>It <span class="italic">descends recursively</span>
                        into the objects or arrays that match the step immediately preceding it (or
                        into the context item if there is no preceding step). 
                              </p>
                              <p>At
                        each descendant level, for each object and for each array element that is an
                        object, it gathers the values of all fields that have the specified name. It
                        returns all of the gathered field values.</p>
                              <p>For example,
                        consider this query and
                        data:</p><pre class="pre codeblock"><code>json_query(some_json_column, '$.<span class="bold">a..z</span>' WITH ARRAY WRAPPER)</code></pre><pre class="pre codeblock"><code>{ "<span class="bold">a</span>" : { "b" : { "<span class="bold">z</span>" : <span class="bold">1</span> },
          "c" : [ 5, { "<span class="bold">z</span>" : <span class="bold">2</span> } ],
          "<span class="bold">z</span>" : <span class="bold">3</span> }
  "z" : 4 }</code></pre><p>The query returns an array, such as <code class="codeph">[1,2,3]</code>,
                        whose elements are <code class="codeph">1</code>, <code class="codeph">2</code>, and
                            <code class="codeph">3</code>. It gathers the value of each field
                            <code class="codeph">z</code> within the step that immediately precedes the dot dot
                            (<code class="codeph">..</code>), which is field <code class="codeph"><span class="bold">a</span></code>. The
                        topmost field <code class="codeph">z</code>, with value 4, is <span class="italic">not</span> matched
                        because it is not within the value of field <code class="codeph">a</code>.
                              </p>
                              <p>The value of field <code class="codeph">a</code> is an object, which is
                        descended into.
                              </p>
                              <ul style="list-style-type: disc;" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__UL_JY1_QWZ_RFB">
                                 <li>
                                    <p>It has a field <code class="codeph">z</code>, whose value
                                        (<code class="codeph"><span class="bold">3</span></code>) is gathered. It also has a field
                                    <code class="codeph">b</code> whose value is an object, which is descended
                                into to gather the value of its field <code class="codeph">z</code>, which is
                                        <code class="codeph"><span class="bold">1</span></code>. 
                                    </p>
                                 </li>
                                 <li>
                                    <p>It also has a field <code class="codeph">c</code>
                                whose value is an array, which has an element that is an object with
                                a field <code class="codeph">z</code>, whose value (<code class="codeph"><span class="bold">2</span></code>)
                                is gathered.
                                    </p>
                                 </li>
                              </ul>
                              <p>The JSON values gathered are thus <code class="codeph">3</code>,
                            <code class="codeph">1</code>, and <code class="codeph">2</code>. They are wrapped in an
                        array, in an undefined order. One of the possible return values is
                            <code class="codeph">[1,2,3]</code>.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">filter expression</strong></span>
                                (<span class="bold"><strong class="term">filter</strong></span>, for short) is a question
                        mark (<code class="codeph"><span class="bold">?</span></code>) followed by a <span class="italic">filter condition</span>
                        enclosed in parentheses (<code class="codeph"><span class="bold">()</span></code>). A filter is satisfied
                        if its condition is satisfied, that is, returns true.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">filter condition</strong></span> applies a predicate (Boolean function) to its arguments and is one of the following, where each of <code class="codeph"><span class="codeinlineitalic">cond</span></code>, <code class="codeph"><span class="codeinlineitalic">cond1</span></code>, and <code class="codeph"><span class="codeinlineitalic">cond2</span></code> stands for a filter condition.
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph"><span class="bold">(</span> <span class="codeinlineitalic">cond</span> <span class="bold">)</span></code>: Parentheses are used for <span class="italic">grouping</span>, separating filter condition <code class="codeph"><span class="codeinlineitalic">cond</span></code> as a unit from other filter conditions that may precede or follow it.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="codeinlineitalic">cond1</span> <span class="bold">&amp;&amp;</span> <span class="codeinlineitalic">cond2</span></code>: The <span class="italic">conjunction</span> (<span class="italic">and</span>) of <code class="codeph"><span class="codeinlineitalic">cond1</span></code> and <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, requiring that both be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="codeinlineitalic">cond1</span> <span class="bold">||</span> <span class="codeinlineitalic">cond2</span></code>: The inclusive <span class="italic">disjunction</span> (<span class="italic">or</span>) of <code class="codeph"><span class="codeinlineitalic">cond1</span></code> and <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, requiring that <code class="codeph"><span class="codeinlineitalic">cond1</span></code>, <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, or both, be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="bold">! (</span> <span class="codeinlineitalic">cond</span> <span class="bold">)</span></code>: The <span class="italic">negation</span> of <code class="codeph"><span class="codeinlineitalic">cond</span></code>, meaning that <code class="codeph"><span class="codeinlineitalic">cond</span></code> must <span class="italic">not</span> be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="bold">exists (</span></code>, followed by a <span class="italic">relative path expression</span>, followed by <code class="codeph"><span class="bold">)</span></code>: The condition that the targeted data <span class="italic">exists</span> (is present).
                                    </p>
                                 </li>
                                 <li>
                                    <p>A <span class="bold"><strong class="term">comparison</strong></span>, which is one of the following: 
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>A <span class="italic">relative path expression</span>, followed by a <span class="italic">comparison predicate</span>, followed by either a JSON scalar value or a <span class="italic">SQL/JSON variable</span>.
                                          </p>
                                       </li>
                                       <li>
                                          <p>Either a JSON scalar value or a <span class="italic">SQL/JSON variable</span>, followed by a <span class="italic">comparison predicate</span>, followed by a <span class="italic">relative path expression</span>.
                                          </p>
                                       </li>
                                       <li>
                                          <p>A JSON scalar value, followed by a <span class="italic">comparison predicate</span>, followed by another JSON scalar value.
                                          </p>
                                       </li>
                                       <li>
                                          <p>A <span class="italic">relative path expression</span>, followed by <code class="codeph">has substring</code>, <code class="codeph">starts with</code>, <code class="codeph">like</code>, <code class="codeph">like_regex</code>, or <code class="codeph">eq_regex</code>, followed by either a JSON string or a <span class="italic">SQL/JSON variable</span> that is bound to a SQL string (which is automatically converted from the database character set to UTF8). 
                                          </p>
                                          <ul style="list-style-type: disc;" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__UL_KKR_2RY_XFB">
                                             <li>
                                                <p><code class="codeph"><span class="bold">has substring</span></code> means that the matching data value has the specified string as a <span class="italic">substring</span>.
                                                </p>
                                             </li>
                                             <li>
                                                <p><code class="codeph"><span class="bold">starts with</span></code> means that the matching data value has the specified string as a <span class="italic">prefix</span>.
                                                </p>
                                             </li>
                                             <li>
                                                <p><code class="codeph"><span class="bold">like</span></code> means that the JSON string data value matches the specified string, which is interpreted as a SQL <code class="codeph">LIKE</code> pattern that uses SQL <code class="codeph">LIKE4</code> character-set semantics. A percent sign (<code class="codeph"><span class="bold">%</span></code>) in the pattern matches zero or more characters. An underscore (<code class="codeph"><span class="bold">_</span></code>) matches a single character.
                                                </p>
                                                <div class="infoboxnote" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-25A8E2C1-8944-4040-BA8A-EF691FA1B9D9">
                                                   <p class="notep1">Note:</p>
                                                   <p>Unlike the case for SQL <code class="codeph">LIKE</code>, there is <span class="italic">no escape character</span> for path-expression predicate <code class="codeph">like</code>. Also, Oracle recommends that you avoid using character <code class="codeph"><span class="bold">`</span></code>, GRAVE ACCENT (U+0060), in your <code class="codeph">like</code> patterns — that character, also known sometimes as backquote or backtick, is <span class="italic">reserved for future use</span>.
                                                   </p>
                                                </div>
                                             </li>
                                             <li>
                                                <p><code class="codeph"><span class="bold">like_regex</span></code> means that the JSON string data value matches the specified string, which is interpreted as a SQL <code class="codeph">REGEXP LIKE</code> <span class="italic">regular expression</span> pattern that uses SQL <code class="codeph">LIKE4</code> character-set semantics. 
                                                </p>
                                                <p> <code class="codeph">like_regex</code> is <span class="italic">exceptional</span> among the pattern-matching comparisons, in that its pattern matches the empty JSON string (<code class="codeph"><span class="bold">""</span></code>). 
                                                </p>
                                             </li>
                                             <li>
                                                <p><code class="codeph"><span class="bold">eq_regex</span></code> is just like <code class="codeph">like_regex</code>, except for these two differences: 
                                                </p>
                                                <ul style="list-style-type: disc;" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__UL_JZ1_XLQ_CGB">
                                                   <li>
                                                      <p><code class="codeph">eq_regex</code> matches its regular expression pattern against the entire JSON string data value — <span class="italic">the full string must match</span> the pattern for the comparison to be satisfied. <code class="codeph">like_regex</code> is satisfied if any portion of the JSON string matches the pattern.
                                                      </p>
                                                   </li>
                                                   <li>
                                                      <p>The <code class="codeph">eq_regex</code> pattern does not match the empty JSON string (<code class="codeph"><span class="bold">""</span></code>). 
                                                      </p>
                                                   </li>
                                                </ul>
                                             </li>
                                          </ul>
                                          <p>For all of these predicates, a pattern that is the empty string (<code class="codeph">""</code>) matches data that is the empty string. And for all except <code class="codeph">like_regex</code>, a pattern that is a nonempty string does <span class="italic">not</span> match data that is the empty string. For <code class="codeph">like_regex</code> a nonempty pattern does match empty-string data.
                                          </p>
                                       </li>
                                       <li>
                                          <p>A <span class="italic">relative path expression</span>, followed by <code class="codeph"><span class="bold">in</span></code>, followed by a <span class="italic">value list</span>, meaning that the value is one of those in the <span class="italic">value list</span>.
                                          </p>
                                       </li>
                                    </ul>
                                    <p>A <span class="bold"><strong class="term">comparison predicate</strong></span> is <code class="codeph"><span class="bold">==</span></code>, <code class="codeph"><span class="bold">&lt;&gt;</span></code>, <code class="codeph"><span class="bold">!=</span></code><a id="fn_2" name="fn_2" href="#fn_2" onclick="footdisplay(2, "!= is an Oracle alias for the SQL/JSON standard comparison predicate <&gt;.")"><sup>Foot&nbsp;2</sup></a>, <code class="codeph"><span class="bold">&lt;</span></code>, <code class="codeph"><span class="bold">&lt;=</span></code>, <code class="codeph"><span class="bold">&gt;=</span></code>, or <code class="codeph"><span class="bold">&gt;</span></code>, meaning equals, does not equal, is less than, is less than or equal to, is greater than or equal to, and is greater than, respectively. 
                                    </p>
                                    <p>A <span class="bold"><strong class="term">SQL/JSON variable</strong></span> is a dollar sign (<code class="codeph"><span class="bold">$</span></code>) followed by the name of a SQL identifier that is bound in a <code class="codeph">PASSING</code> clause for <code class="codeph">json_exists</code>.
                                    </p>
                                 </li>
                                 <li>A <span class="bold"><strong class="term">value list</strong></span> is <code class="codeph"><span class="bold">(</span></code>, followed by a list of one or more scalar values and <span class="italic">SQL/JSON variables</span> separated by commas (<code class="codeph"><span class="bold">,</span></code>), followed by <code class="codeph"><span class="bold">)</span></code>.
                                 </li>
                              </ul>
                              <p>The predicates that you can use in filter conditions are thus <code class="codeph">&amp;&amp;</code>, <code class="codeph">||</code>, <code class="codeph">!</code>, <code class="codeph">exists</code>, <code class="codeph">==</code>, <code class="codeph">&lt;&gt;</code>, <code class="codeph">!=</code>, <code class="codeph">&lt;</code>, <code class="codeph">&lt;=</code>,<code class="codeph"> &gt;=</code>, <code class="codeph">&gt;</code>, and <code class="codeph">in</code>.
                              </p>
                              <p>As an example, the filter condition <code class="codeph">(a || b) &amp;&amp; (!(c) || d &lt; 42)</code> is satisfied if both of the following criteria are met:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>At least one of the filter conditions <code class="codeph">a</code> and <code class="codeph">b</code> is satisfied: <code class="codeph">(a || b)</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Filter condition <code class="codeph">c</code> is <span class="italic">not</span> satisfied or the number <code class="codeph">d</code> is less than or equal to 42, or both are true: <code class="codeph">(!(c) || d &lt; 42)</code>.
                                    </p>
                                 </li>
                              </ul>
                              <p>Comparison predicate <code class="codeph">!</code> has precedence over <code class="codeph">&amp;&amp;</code>, which has precedence over <code class="codeph">||</code>. You can always use parentheses to control grouping.
                              </p>
                              <p>Without parentheses for grouping, the preceding example would be <code class="codeph">a || b &amp;&amp; !(c) || d &lt; 42</code>, which would be satisfied if at least one of the following criteria is met:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Condition <code class="codeph">b &amp;&amp; !(c)</code> is satisfied, which means that each of the conditions <code class="codeph">b</code> and <code class="codeph">!(c)</code> is satisfied (which in turn means that condition <code class="codeph">c</code> is not satisfied).
                                    </p>
                                 </li>
                                 <li>
                                    <p>Condition <code class="codeph">a</code> is satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Condition <code class="codeph">d &lt; 42</code> is satisfied.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>At least one side of a comparison  must <span class="italic">not</span> be a SQL/JSON variable. The default <span class="italic">type</span> for a comparison is defined at compile time, based on the type(s) for the non-variable side(s). You can use a type-specifying <span class="italic">item method</span> to override this default with a different type. The type of your matching data is automatically converted, for the comparison, to fit the determined type (default or specified by item method). For example, <code class="codeph">$.a &gt; 5</code> imposes numerical comparison because <code class="codeph">5</code> is a number, <code class="codeph">$.a &gt; "5"</code> imposes string comparison because <code class="codeph">"5"</code> is a string.
                        </p>
                        <div class="infoboxnote" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-D32D9BC0-4147-4F93-9AB8-C6A25A653FD6">
                           <p class="notep1">Note:</p>
                           <p>For powerful full-text search, use Oracle SQL function <code class="codeph">json_textcontains</code>, which requires that you create a JSON search index. As a less-powerful alternative, if you do not create a JSON search index, and you just want simple string pattern-matching in a filter condition, you can use any of the pattern-matching comparisons: <code class="codeph">has substring</code>, <code class="codeph">starts with</code>, <code class="codeph">like</code>, <code class="codeph">like_regex</code>, or <code class="codeph">eq_regex</code>.
                           </p>
                        </div>
                        <p>Here are some examples of path expressions, with their meanings spelled
                out in detail.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">$</code> &#x2013; The context item.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends</code> &#x2013; The value of field
                            <code class="codeph">friends</code> of a context-item object. The dot
                                (<code class="codeph"><span class="bold">.</span></code>) immediately after the dollar sign
                                (<code class="codeph"><span class="bold">$</span></code>) indicates that the context item is a
                        JSON <span class="italic">object</span>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[0]</code> &#x2013; An object that is
                        the first element of an array that is the value of field
                            <code class="codeph">friends</code> of a context-item object. The bracket notation
                        indicates that the value of field <code class="codeph">friends</code> is an
                            <span class="italic">array</span>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[0].name</code> &#x2013; Value of field
                            <code class="codeph">name</code> of an object that is the first element of an array
                        that is the value of field <code class="codeph">friends</code> of a context-item
                        object. The second dot (<code class="codeph"><span class="bold">.</span></code>) indicates that the first
                        element of array <code class="codeph">friends</code> is an object (with a
                            <code class="codeph">name</code> field).
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[*].name</code> &#x2013; Value of field
                            <code class="codeph">name</code> of <span class="italic">each</span> object in an array that is the
                        value of field <code class="codeph">friends</code> of a context-item object.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.*[*].name</code> &#x2013; Field
                            <code class="codeph">name</code> values for each object in an array value of a
                        field of a context-item object.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3, 8 to 10, 12]</code> &#x2013; The
                        fourth, ninth through eleventh, and thirteenth elements of an array
                            <code class="codeph">friends</code> (field of a context-item object). The elements
                        must be specified in <span class="italic">ascending order</span>, and they are returned in that
                        order: fourth, ninth, tenth, eleventh, thirteenth.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars</code> &#x2013; The value of
                        field <code class="codeph">cars</code> of an object that is the fourth element of an
                        array <code class="codeph">friends</code>. The dot (<code class="codeph"><span class="bold">.</span></code>)
                        indicates that the fourth element is an object (with a <code class="codeph">cars</code>
                        field).
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].*</code> &#x2013; The values of
                            <span class="italic">all</span> of the fields of an object that is the fourth element of an
                        array <code class="codeph">friends</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0].year</code> &#x2013; The
                        value of field <code class="codeph">year</code> of an object that is the first element
                        of an array that is the value of field <code class="codeph">cars</code> of an object
                        that is the fourth element of an array <code class="codeph">friends</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0]?(@.year &gt;
                            2016)</code> &#x2013; The first object of an array <code class="codeph">cars</code>
                        (field of an object that is the fourth element of an array
                            <code class="codeph">friends</code>), <span class="italic">provided that</span> the value of its field
                            <code class="codeph">year</code> is, or can be converted to, a number greater than
                        2016. A <code class="codeph">year</code> value such as <code class="codeph">"2017"</code> is
                        converted to the number <code class="codeph">2017</code>, which satisfies the test. A
                            <code class="codeph">year</code> value such as <code class="codeph">"recent"</code> fails the
                        test — no match. 
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0]?(@.year.number() &gt;
                            2016)</code> &#x2013; Same as the previous. Item method
                            <code class="codeph">number()</code> allows only a number or a string value that
                        can be converted to a number, and that behavior is already provided by
                        numeric comparison predicate <code class="codeph">&gt;</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0]?(@.year.numberOnly()
                            &gt; 2016)</code> &#x2013; Same as the previous, but only if the
                            <code class="codeph">year</code> value is a number. Item method
                            <code class="codeph">numberOnly()</code> excludes a car with a
                            <code class="codeph">year</code> value that is a string numeral, such as
                            <code class="codeph">"2017"</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3]?(@.addresses.city == "San
                            Francisco")</code> &#x2013; An object that is the fourth element of an array
                            <code class="codeph">friends</code>, provided that it has an
                            <code class="codeph">addresses</code> field whose value is an object with a field
                            <code class="codeph">city</code> whose value is the string <code class="codeph">"San
                            Francisco"</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[*].addresses?(@city starts with
                            "San ").zip</code> &#x2013; Zip codes of all <code class="codeph">addresses</code> of
                            <code class="codeph">friends</code>, where the name of the address
                            <code class="codeph">city</code> starts with "San ". (In this case the filter is
                        not the last path step.)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$..zip</code> &#x2013; All values of a
                            <code class="codeph">zip</code> field, anywhere, at any level.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3]?(@.addresses.city == "San
                            Francisco" &amp;&amp; @.addresses.state == "Nevada")</code> &#x2013; Objects
                        that are the fourth element of an array <code class="codeph">friends</code>, provided
                        that there is a match for an address with a <code class="codeph">city</code> of
                            <code class="codeph">"San Francisco"</code> and there is a match for an address
                        with a <code class="codeph">state</code> of <code class="codeph">"Nevada"</code>. 
                              </p>
                              <p>Note: The filter conditions in the conjunction do <span class="italic">not</span>
                        necessarily apply to the same object — the filter tests for the existence of
                        an object with city San Francisco and for the existence of an object with
                        state Nevada. It does <span class="italic">not</span> test for the existence of an object with
                        both city San Francisco and state Nevada. See <a href="condition-JSON_EXISTS.html#GUID-8A0043D5-95F8-4918-9126-F86FB0E203F0" title="You can use SQL/JSON condition json_exists with a path expression that has one or more filter expressions, to select documents that contain matching data. Filters let you test for the existence of documents that have particular fields that satisfy various conditions.">Using Filters with JSON_EXISTS</a>. 
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].addresses?(@.city == "San
                            Francisco" &amp;&amp; @.state == "Nevada")</code> &#x2013; An object that is
                        the fourth element of array <code class="codeph">friends</code>, provided that object
                        has a match for <code class="codeph">city</code> of <code class="codeph">"San Francisco"</code>
                        and a match for <code class="codeph">state</code> of <code class="codeph">"Nevada"</code>. 
                              </p>
                              <p>Unlike the preceding example, in this case the filter conditions
                        in the conjunction, for fields <code class="codeph">city</code> and
                            <code class="codeph">state</code>, apply to the <span class="italic">same</span>
                                 <code class="codeph">addresses</code> object. The filter applies to a given
                            <code class="codeph">addresses</code> object, which is outside it.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="condition-JSON_EXISTS.html#GUID-8A0043D5-95F8-4918-9126-F86FB0E203F0" title="You can use SQL/JSON condition json_exists with a path expression that has one or more filter expressions, to select documents that contain matching data. Filters let you test for the existence of documents that have particular fields that satisfy various conditions.">Using Filters with JSON_EXISTS</a></li>
                           <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="SQL functions json_value, json_query, json_serialize, and json_mergepatch accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for SQL Query Functions</a></li>
                           <li><a href="json-path-expressions.html#GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13" title="The Oracle item methods available for a SQL/JSON path expression are described.">SQL/JSON Path Expression Item Methods</a></li>
                           <li><a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">SQL/JSON Path Expression Syntax Relaxation</a></li>
                           <li><a href="diagrams-basic-sql-json-path-expression-syntax.html" title="Syntax diagrams and corresponding Backus-Naur Form (BNF) syntax descriptions are presented for the basic SQL/JSON path expression syntax.">Diagrams for Basic SQL/JSON Path Expression Syntax</a></li>
                           <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="SQL/JSON query functions json_query and json_table accept an optional wrapper clause, which specifies the form of the value returned by json_query or used for the data in a json_table column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.">Wrapper Clause for SQL/JSON Query Functions JSON_QUERY and JSON_TABLE</a></li>
                           <li><a href="json-path-expressions.html#GUID-20DC09A8-98DF-4473-8077-913D490A969C" title="International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. Oracle Database supports many of the ISO 8601 date and time formats.">ISO 8601 Date and Time Support</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-F6FF8FF6-3773-4E1A-BDEA-6DAE47639138">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__UL_SHL_FSY_XFB">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adjsn&amp;id=wikipedia_iso8601" target="_blank">ISO 8601</a>
                            for information about the ISO date formats
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Pattern-matching-Conditions.html#SQLRF-GUID-D2124F3A-C6E4-4CCA-A40E-2FFCABFD8E19" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for
                            information about SQL condition <code class="codeph">REGEXP LIKE</code></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Pattern-matching-Conditions.html#SQLRF-GUID-0779657B-06A8-441F-90C5-044B47862A0A" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for
                            information about SQL condition <code class="codeph">LIKE</code> and
                                <code class="codeph">LIKE4</code> character-set semantics
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879" title="SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.">SQL/JSON Path Expression Syntax</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6373"></a><div class="props_rev_3"><a id="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" name="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77"></a><h4 id="ADJSN-GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" class="sect4"><span class="enumeration_section">13.2.2 </span>SQL/JSON Path Expression Syntax Relaxation
                  </h4>
                  <div>
                     <p>The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.</p>
                     <p><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context-item symbol ($) followed by zero or more object, array, and descendant steps, each of which can be followed by a filter expression, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a> defines the basic SQL/JSON path-expression syntax. The actual path expression syntax supported relaxes that definition as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If a path-expression step targets (expects) an array but the actual data presents no array then the data is implicitly wrapped in an array.</p>
                        </li>
                        <li>
                           <p>If a path-expression step targets (expects) a non-array but the actual data presents an array then the array is implicitly unwrapped.</p>
                        </li>
                     </ul>
                     <p>This relaxation allows for the following abbreviation: <span class="bold"><code class="codeph">[*]</code></span> can be elided whenever it precedes the object accessor, <span class="bold"><code class="codeph">.</code></span>, followed by an object field name, with no change in effect. The reverse is also true: <span class="bold"><code class="codeph">[*]</code></span> can always be inserted in front of the object accessor,<span class="bold"><code class="codeph"> .</code></span>, with no change in effect.
                     </p>
                     <p>This means that the object step <code class="codeph">[*].</code><span class="italic"><code class="codeph">prop</code></span>, which stands for the value of field <span class="italic"><code class="codeph">prop</code></span> of each element of a given array of objects, can be abbreviated as <span class="italic"><code class="codeph">.prop</code></span>, and the object step <span class="italic"><code class="codeph">.prop</code></span>, which looks as though it stands for the <span class="italic"><code class="codeph">prop</code></span> value of a single object, stands also for the <span class="italic"><code class="codeph">prop</code></span> value of each element of an array to which the object accessor is applied.
                     </p>
                     <p>This is an important feature, because it means that you need not change a path expression in your code if your data evolves to replace a given JSON value with an array of such values, or vice versa.</p>
                     <p>For example, if your data originally contains objects that have field <code class="codeph">Phone</code> whose value is a single object with fields <code class="codeph">type</code> and <code class="codeph">number</code>, the path expression <code class="codeph">$.Phone.number</code>, which matches a single phone number, can still be used if the data evolves to represent an array of phones. Path expression <code class="codeph">$.Phone.number</code> matches either a single phone object, selecting its number, or an array of phone objects, selecting the number of each.
                     </p>
                     <p>Similarly, if your data mixes both kinds of representation — there are some data entries that use a single phone object and some that use an array of phone objects, or even some entries that use both — you can use the same path expression to access the phone information from these different kinds of entry.</p>
                     <p>Here are some example path expressions from section <a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context-item symbol ($) followed by zero or more object, array, and descendant steps, each of which can be followed by a filter expression, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a>, together with an explanation of equivalences.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">$.friends</code> &#x2013; The value of field <code class="codeph">friends</code> of <span class="italic">either</span>:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The (single) context-item object.</p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends</code>) Each object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">$.friends[0].name</code> &#x2013; Value of field <code class="codeph">name</code> for <span class="italic">any</span> of these objects:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p> The first element of the array that is the value of field <code class="codeph">friends</code> of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$.friends.name</code>) The value of field <code class="codeph">friends</code> of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends.name</code>) The value of field <code class="codeph">friends</code> of each object in the context-item array.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends[0].name</code>) The first element of each array that is the value of field <code class="codeph">friends</code> of each object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                           <p>The context item can be an object or an array of objects. In the latter case, each object in the array is matched for a field <code class="codeph">friends</code>.
                           </p>
                           <p>The value of field <code class="codeph">friends</code> can be an object or an array of objects. In the latter case, the first object in the array is used.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">$.*[*].name</code> &#x2013; Value of field <code class="codeph">name</code> for <span class="italic">any</span> of these objects:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>An element of an array value of a field of the context-item object.</p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$.*.name</code>) The value of a field of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$[*].*.name</code>) The value of a field of an object in the context-item array.
                                 </p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$[*].*[*].name</code>) Each object in an array value of a field of an object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context-item symbol ($) followed by zero or more object, array, and descendant steps, each of which can be followed by a filter expression, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879" title="SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.">SQL/JSON Path Expression Syntax</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13" name="GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13"></a><h3 id="ADJSN-GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13" class="sect3"><span class="enumeration_section">13.3 </span>SQL/JSON Path Expression Item
        Methods
               </h3>
               <div>
                  <p>The Oracle item methods available for a SQL/JSON path expression are
        described.</p>
                  <div class="section">
                     <p> An item method is applied to the JSON data that is targeted by (the
                rest of) the path expression terminated by that method. The method is used to
                transform that data. The SQL function or condition that is passed the path
                expression uses the transformed data in place of the targeted data. In some cases
                the application of an item method acts as a filter, removing the targeted data from
                the result set.</p>
                     <p>If an item-method conversion fails for any reason,
                such as its argument being of the wrong type, then the path cannot be matched (it
                refers to no data), and <span class="italic">no error is raised</span>. In particular, this means that
                such an error is <span class="italic">not</span> handled by an error clause in the SQL/JSON function or
                condition to which the path expression is passed.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13__GUID-841B3AAD-C23F-403C-8FE2-AB8DBF7F3543">Application of an
                Item Method to an Array</p>
                     <p>With the exception of item methods
                    <code class="codeph">size()</code> and <code class="codeph">type()</code>, if an array is targeted by
                an item method then the method is <span class="italic">applied to each of the array elements</span>, not
                to the array itself. For example, <code class="codeph">$.a.<span class="codeinlineitalic">method</span>()</code> applies
                item-method <code class="codeph"><span class="codeinlineitalic">method()</span></code> to each element of array
                    <code class="codeph">a</code>, to convert it and use it in place of the array. (This is
                similar, in effect, to the implied unwrapping of an array when a non-array is
                expected for an object step.) The resulting set of matches includes the converted
                array elements, not the targeted array.
                     </p>
                     <p>For
                    <code class="codeph">json_query</code> or a <code class="codeph">json_table</code> column expression
                with <code class="codeph">json_query</code> semantics you can use a wrapper clause to capture
                all of the converted array-element values as an array. For example, this
                query:
                     </p><pre class="pre codeblock"><code>SELECT json_query('["alpha", 42, "10.4"]', '$[*].stringOnly()' <span class="bold">WITH ARRAY WRAPPER</span>) FROM dual;</code></pre><p>returns this array (as a <code class="codeph">VARCHAR2</code> value):
                    <code class="codeph">["alpha", "10.4"]</code>.
                     </p>
                     <p>Item methods
                    <code class="codeph">size()</code> and <code class="codeph">type()</code> are <span class="italic">exceptional</span> in
                this regard. When applied to an array they treat it as such, instead of acting on
                its elements. For
                example:
                     </p><pre class="pre codeblock"><code>SELECT json_value('[19, "Oracle", {"a":1},[1,2,3]]', '$.type()') FROM dual;</code></pre><p>returns the single <code class="codeph">VARCHAR2</code> value
                    <code class="codeph">'array'</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13__GUID-2458E67B-7753-4B38-9FC2-2EDA4658F3BC">Item-Method
                Descriptions</p>
                     <p>In the item-method descriptions here, in some
                cases a targeted JSON value is said to be <span class="italic">interpreted as a value of a given SQL
                    data type</span>. This means that it is handled as if it were controlled by a
                    <code class="codeph">json_value</code>
                        <code class="codeph">RETURNING</code> clause with that SQL data type.
                     </p>
                     <p>For example,
                item-method <code class="codeph">string()</code> interprets its target as would
                    <code class="codeph">json_value</code> with clause <code class="codeph">RETURNING
                    VARCHAR2(4000)</code>. A Boolean value is thus treated by
                    <code class="codeph">string()</code> as <code class="codeph">"true"</code> or
                <code class="codeph">"false"</code>; a <code class="codeph">null</code> value is treated as
                    <code class="codeph">"null"</code>; and a number is represented in a canonical string
                form.
                     </p>
                     <p>Because some item methods interpret the targeted JSON data
                as if it were of a SQL data type, they can be used with <code class="codeph">json_value</code>
                in place of a <code class="codeph">RETURNING</code> clause, and they can be used with
                    <code class="codeph">json_table</code> in place of a column type specification. That is,
                the <span class="italic">item methods can be used to specify the SQL data type</span> for the extracted
                JSON data.
                
                     </p>
                     <p>You can also use such item methods <span class="italic">together with</span> a
                    <code class="codeph">json_value</code>
                        <code class="codeph">RETURNING</code> clause or a <code class="codeph">json_table</code> column type
                specification. What happens if the SQL data type to use for extracted JSON data is
                controlled by <span class="italic">both</span> an item method and either a <code class="codeph">json_value</code>
                        <code class="codeph">RETURNING</code> clause or a <code class="codeph">json_table</code> column
                type?
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If the two data types are compatible then the data
                        type for the <code class="codeph">RETURNING</code> clause or the column is used. For
                        these purposes, <code class="codeph">VARCHAR2</code> is compatible with both
                            <code class="codeph">VARCHAR2</code> and <code class="codeph">CLOB</code>.
                           </p>
                        </li>
                        <li>
                           <p>If the data types are incompatible then a static,
                        compile-time <span class="italic">error</span> is raised.
                           </p>
                        </li>
                     </ul>
                     <div class="tblformal" id="GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13__TABLE_AN1_Y5C_TFB">
                        <p class="titleintable">Table 13-1 Compatibility of
                    Type-Conversion Item Methods and RETURNING Types</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Compatibility of&#xA;                    Type-Conversion Item Methods and RETURNING Types" summary="Describes the compatible combinations of an item method with a&#xA;                    RETURNING clause. The columns are Item Method and Compatible RETURNING Clause&#xA;                    Data Types" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d11088e2401">Item Method</th>
                                 <th align="left" valign="bottom" id="d11088e2403">Compatible RETURNING Clause Data Types</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d11088e2407" headers="d11088e2401 "><code class="codeph">string()</code> or
                                    <code class="codeph">stringOnly()</code></td>
                                 <td align="left" valign="top" headers="d11088e2407 d11088e2403 "><code class="codeph">VARCHAR2</code> or <code class="codeph">CLOB</code>,
                                except that <code class="codeph">string()</code> returns SQL
                                    <code class="codeph">NULL</code> for a JSON <code class="codeph">null</code>
                                value
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d11088e2430" headers="d11088e2401 "><code class="codeph">number()</code> or
                                    <code class="codeph">numberOnly()</code></td>
                                 <td align="left" valign="top" headers="d11088e2430 d11088e2403 "><code class="codeph">NUMBER</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d11088e2440" headers="d11088e2401 "><code class="codeph">date()</code></td>
                                 <td align="left" valign="top" headers="d11088e2440 d11088e2403 "><code class="codeph">DATE</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d11088e2447" headers="d11088e2401 "><code class="codeph">timestamp()</code></td>
                                 <td align="left" valign="top" headers="d11088e2447 d11088e2403 "><code class="codeph">TIMESTAMP</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d11088e2454" headers="d11088e2401 "><code class="codeph">boolean()</code> or
                                    <code class="codeph">booleanOnly()</code></td>
                                 <td align="left" valign="top" headers="d11088e2454 d11088e2403 "><code class="codeph">VARCHAR2</code></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Using a <code class="codeph">RETURNING</code> clause or a column
                specification, you can specify a length for character data and a precision and scale
                for numerical data. This lets you assign a more precise SQL data type for extraction
                than what is provided by an item method for target-data comparison purposes.
                     </p>
                     <p>For example, if you use item method <code class="codeph">string()</code> and
                    <code class="codeph">RETURNING VARCHAR2(150)</code> then the data type of the returned data
                is <code class="codeph">VARCHAR2(150)</code>, not
                <code class="codeph">VARCHAR2(4000)</code>.
                     </p>
                     <p>The data-type conversion methods with “only” in their name are the same as the
                corresponding methods with names without “only”, except that the former convert
                    <span class="italic">only </span>JSON values that are of the given type (e.g.,
                    <code class="codeph">number</code>) to the related SQL data type (e.g.
                    <code class="codeph">NUMBER</code>). The methods without “only” in the name allow
                conversion, when possible, of <span class="italic">any </span>JSON value to the given SQL data type.
                (When an “only” method targets an array, the conversion applies to each array
                element, as
                usual.)
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold"><code class="codeph">abs()</code></span>: The absolute value of the targeted JSON number. Corresponds to the use of SQL function <code class="codeph">ABS</code>.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">boolean()</code></span>: A SQL <code class="codeph">VARCHAR2(20)</code> interpretation of the targeted JSON value.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">booleanOnly()</code></span>: A SQL <code class="codeph">VARCHAR2(20)</code> interpretation of the targeted JSON data, but only if it is a JSON Boolean value; otherwise, there is no match. Acts as a filter, allowing matches only for JSON Boolean values.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">ceiling()</code></span>: The targeted JSON number, rounded up to the nearest integer. Corresponds to the use of SQL function <code class="codeph">CEIL</code>.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">date()</code></span>: A SQL date interpretation of the targeted JSON string. The targeted string data must be in one of the supported ISO 8601 formats; otherwise, there is no match.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">double()</code></span>: A SQL <code class="codeph">BINARY_DOUBLE</code> interpretation of the targeted JSON string or number.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">floor()</code></span>: The targeted JSON number, rounded down to the nearest integer. Corresponds to the use of SQL function <code class="codeph">FLOOR</code>.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">length()</code></span>: The number of characters in the targeted JSON string, interpreted as a SQL <code class="codeph">NUMBER</code>.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">lower()</code></span>: The lowercase string that corresponds to the characters in the targeted JSON string.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">number()</code></span>: A SQL <code class="codeph">NUMBER</code> interpretation of the targeted JSON string or number.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">numberOnly()</code></span>: A SQL <code class="codeph">NUMBER</code> interpretation of the targeted JSON data, but only if it is a JSON number; otherwise, there is no match. Acts as a filter, allowing matches only for JSON numbers.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">size()</code></span>: The number of elements in an array, or 1 for a scalar or an object. This item method can be used with <code class="codeph">json_query</code>, in addition to <code class="codeph">json_value</code> and <code class="codeph">json_table</code>. If applied to data that is an array, no implicit iteration over the array elements occurs: the resulting value is just the number of array elements. (This is an exception to the rule of implicit iteration.)
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">string()</code></span>: A SQL <code class="codeph">VARCHAR2(4000)</code> interpretation of the targeted scalar JSON value.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">stringOnly()</code></span>: A SQL <code class="codeph">VARCHAR2(4000)</code> interpretation of the targeted scalar JSON value, but only if it is a JSON string; otherwise, there is no match. Acts as a filter, allowing matches only for JSON strings.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">timestamp()</code></span>: A SQL <code class="codeph">TIMESTAMP</code> interpretation of the targeted JSON string. The targeted string data must be in one of the supported ISO 8601 formats; otherwise, there is no match. <a id="fn_3" name="fn_3" href="#fn_3" onclick="footdisplay(3, "Applying item method timestamp() to a supported ISO 8601 string <ISO-STRING&gt; has the effect of SQL sys_extract_utc(to_utc_timestamp_tz(<ISO-STRING&gt;).")"><sup>Foot&nbsp;3</sup></a></p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">type()</code></span>: The name of the JSON data type of the targeted data, interpreted as a SQL <code class="codeph">VARCHAR2(20)</code> value. This item method can be used with <code class="codeph">json_query</code>, in addition to <code class="codeph">json_value</code> and <code class="codeph">json_table</code>. If applied to data that is an array, no implicit iteration over the array elements occurs: the resulting value is <code class="codeph">"array"</code>. (This is an exception to the rule of implicit iteration.)
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">"null"</code> for a value of
                                    <code class="codeph">null</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">"boolean"</code> for a value of
                                    <code class="codeph">true</code> or <code class="codeph">false</code>.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">"number"</code> for a
                            number.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">"string"</code> for a
                            string.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">"array"</code> for an
                            array.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">"object"</code> for an
                            object.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">upper()</code></span>: The uppercase string that corresponds to the characters in the targeted JSON string.
                           </p>
                        </li>
                     </ul>
                     <p>Item methods <code class="codeph">boolean()</code>, <code class="codeph">booleanOnly()</code>,
                    <code class="codeph">date()</code>, <code class="codeph">length()</code>, <code class="codeph">lower()</code>,
                    <code class="codeph">number()</code>, <code class="codeph">numberOnly()</code>,
                    <code class="codeph">string()</code>, <code class="codeph">stringOnly()</code>,
                    <code class="codeph">timestamp()</code>, and <code class="codeph">upper()</code> are Oracle extensions
                to the SQL/JSON standard. The other item methods, <code class="codeph">abs()</code>,
                    <code class="codeph">ceiling()</code>, <code class="codeph">double()</code>, <code class="codeph">floor()</code>,
                    <code class="codeph">size()</code>, and <code class="codeph">type()</code> are part of the
                standard.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context-item symbol ($) followed by zero or more object, array, and descendant steps, each of which can be followed by a filter expression, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a></li>
                        <li><a href="json-path-expressions.html#GUID-20DC09A8-98DF-4473-8077-913D490A969C" title="International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. Oracle Database supports many of the ISO 8601 date and time formats.">ISO 8601 Date and Time Support</a></li>
                        <li><a href="json-path-expressions.html#GUID-D951D27D-6918-40E8-8A0D-8D60AB83FD4A" title="Comparisons in SQL/JSON path-expression filter conditions are statically typed at compile time. If the effective types of the operands of a comparison are not known to be the same then an attempt is sometimes made to reconcile them by type-casting.">Types in Comparisons</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="SQL functions json_value, json_query, json_serialize, and json_mergepatch accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for SQL Query Functions</a></li>
                        <li><a href="function-JSON_VALUE.html#GUID-0565F0EE-5F13-44DD-8321-2AC142959215" title="SQL/JSON function json_value selects JSON data and returns a SQL scalar or an instance of a user-defined SQL object type or SQL collection type (varray, nested table).">SQL/JSON Function JSON_VALUE</a></li>
                        <li><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view.">SQL/JSON Function JSON_TABLE</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="SQL/JSON query functions json_query and json_table accept an optional wrapper clause, which specifies the form of the value returned by json_query or used for the data in a json_table column. This clause and the default behavior (no wrapper clause) are described here. Examples are provided.">Wrapper Clause for SQL/JSON Query Functions JSON_QUERY and JSON_TABLE</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">SQL/JSON Path Expressions</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-20DC09A8-98DF-4473-8077-913D490A969C" name="GUID-20DC09A8-98DF-4473-8077-913D490A969C"></a><h3 id="ADJSN-GUID-20DC09A8-98DF-4473-8077-913D490A969C" class="sect3"><span class="enumeration_section">13.4 </span>ISO 8601 Date and Time Support
               </h3>
               <div>
                  <p>International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. Oracle Database supports many of the ISO 8601 date and time formats.</p>
                  <div class="section">
                     <p>International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. You can manipulate strings that are in the most common ISO 8601 date and time formats as proper Oracle Database date and time values. The ISO 8601 formats that are supported are essentially those that are numeric-only, language-neutral, and unambiguous.</p>
                     <p>This is the allowed syntax for dates and times:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Date (only): <code class="codeph"><span class="codeinlineitalic">YYYY</span>-<span class="codeinlineitalic">MM</span>-<span class="codeinlineitalic">DD</span></code></p>
                        </li>
                        <li>
                           <p>Date with time: <code class="codeph"><span class="codeinlineitalic">YYYY</span><span class="bold">-</span><span class="codeinlineitalic">MM</span><span class="bold">-</span><span class="codeinlineitalic">DD</span><span class="bold">T</span><span class="codeinlineitalic">hh</span><span class="bold">:</span><span class="codeinlineitalic">mm</span><span class="bold">:</span><span class="codeinlineitalic">ss</span>[<span class="bold">.</span><span class="codeinlineitalic">s</span>[<span class="codeinlineitalic">s</span>[<span class="codeinlineitalic">s</span>[<span class="codeinlineitalic">s</span>[<span class="codeinlineitalic">s</span>[<span class="codeinlineitalic">s</span>]]]]][<span class="bold">Z</span>|(<span class="bold">+</span>|<span class="bold">-</span>)<span class="codeinlineitalic">hh</span><span class="bold">:</span><span class="codeinlineitalic">mm</span>]</code></p>
                        </li>
                     </ul>
                     <p>where:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph"><span class="codeinlineitalic"><span class="bold">YYYY</span></span></code> specifies the <span class="italic">year</span>, as four decimal digits.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="codeinlineitalic"><span class="bold">MM</span></span></code> specifies the <span class="italic">month</span>, as two decimal digits, <code class="codeph">00</code> to <code class="codeph">12</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="codeinlineitalic"><span class="bold">DD</span></span></code> specifies the <span class="italic">day</span>, as two decimal digits, <code class="codeph">00</code> to <code class="codeph">31</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="codeinlineitalic"><span class="bold">hh</span></span></code> specifies the <span class="italic">hour</span>, as two decimal digits, <code class="codeph">00</code> to <code class="codeph">23</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="codeinlineitalic"><span class="bold">mm</span></span></code> specifies the <span class="italic">minutes</span>, as two decimal digits, <code class="codeph">00</code> to <code class="codeph">59</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="bold"><span class="italic">ss</span></span>[<span class="bold">.<span class="italic">s</span></span>[<span class="bold"><span class="italic">s</span></span>[<span class="bold"><span class="italic">s</span></span>[<span class="bold"><span class="italic">s</span></span>[<span class="bold"><span class="italic">s</span></span>]]]]]</code> specifies the <span class="italic">seconds</span>, as two decimal digits, <code class="codeph">00</code> to <code class="codeph">59</code>, optionally followed by a decimal point and 1 to 6 decimal digits (representing the fractional part of a second).
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="bold">Z</span></code> specifies <span class="italic">UTC</span> time (time zone 0). (It can also be specified by <code class="codeph">+00:00</code>, but not by <code class="codeph">&#x2013;00:00</code>.)
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">(<span class="bold">+</span>|<span class="bold">-</span>)hh<span class="bold">:</span>mm</code> specifies the time-zone as <span class="italic">difference from UTC</span>. (One of <code class="codeph">+</code> or <code class="codeph">&#x2013;</code> is required.)
                           </p>
                        </li>
                     </ul>
                     <p>For a time value, the time-zone part is optional. If it is absent then UTC time is assumed.</p>
                     <p>No other ISO 8601 date-time syntax is supported. In particular:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Negative dates (dates prior to year 1 BCE), which begin with a hyphen (e.g. <code class="codeph"><span class="bold">&#x2013;</span>2018&#x2013;10&#x2013;26T21:32:52</code>), are not supported.
                           </p>
                        </li>
                        <li>
                           <p>Hyphen and colon separators are required: so-called “basic” format, <code class="codeph">YYYYMMDDThhmmss</code>, is not supported.
                           </p>
                        </li>
                        <li>
                           <p>Ordinal dates (year plus day of year, calendar week plus day number) are not supported.</p>
                        </li>
                        <li>
                           <p>Using more than four digits for the year is not supported.</p>
                        </li>
                     </ul>
                     <p>Supported dates and times include the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">2018&#x2013;10&#x2013;26T21:32:52</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">2018-10-26T21:32:52+02:00</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">2018-10-26T19:32:52Z</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">2018-10-26T19:32:52+00:00</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">2018-10-26T21:32:52.12679</code></p>
                        </li>
                     </ul>
                     <p>Unsupported dates and times include the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">2018-10-26T21:32</code> (if a time is specified then all of its parts must be present)
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">2018-10-26T<span class="bold">25</span>:32:52+02:00</code> (the hours part, 25, is out of range)
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">18-10-26T21:32</code> (the year is not specified fully)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-20DC09A8-98DF-4473-8077-913D490A969C__GUID-8D7C5414-865C-4ABD-8EC8-D248FD291A5C">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adjsn&amp;id=iso-8601" target="_blank">ISO 8601 standard</a></p>
                        </li>
                        <li>
                           <p><a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 at Wikipedia</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">SQL/JSON Path Expressions</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-D951D27D-6918-40E8-8A0D-8D60AB83FD4A" name="GUID-D951D27D-6918-40E8-8A0D-8D60AB83FD4A"></a><h3 id="ADJSN-GUID-D951D27D-6918-40E8-8A0D-8D60AB83FD4A" class="sect3"><span class="enumeration_section">13.5 </span>Types in Comparisons
               </h3>
               <div>
                  <p>Comparisons in SQL/JSON path-expression filter conditions are statically typed at compile time. If the effective types of the operands of a comparison are not known to be the same then an attempt is sometimes made to reconcile them by type-casting.</p>
                  <p>A SQL/JSON path expression targets JSON data, so the operands of a comparison are JSON values. Type comparison of JSON values is straightforward: JSON data types string, number, null, object, and array are mutually exclusive and incomparable.</p>
                  <p>But comparison operands are sometimes <span class="italic">interpreted</span> (essentially cast) as values of SQL data types. This is the case, for example, when some item methods, such as <code class="codeph">number()</code>, are used. This section addresses the type-checking of such effective values. 
                  </p>
                  <p>You can prevent such type-casting by explicitly using one of the “only” item methods. For example, applying method <code class="codeph">numberOnly()</code> prevents implicit type-casting to a number.
                  </p>
                  <p>SQL is a statically typed language; types are determined at compile time. The same applies to SQL/JSON path expressions, and in particular to comparisons in filter conditions. This means that you get the same result for a query regardless of how it is evaluated — whether functionally or using features such as indexes, materialized views, and In-Memory scans.</p>
                  <p>To realize this:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>If the types of both operands are <span class="italic">known</span> and they are the <span class="italic">same</span> then type-checking is satisfied.
                        </p>
                     </li>
                     <li>
                        <p>If the types of both operands are <span class="italic">unknown</span> then a compile-time error is raised.
                        </p>
                     </li>
                     <li>
                        <p>If the type of one operand is known and the other is unknown then the latter operand is cast to the type of the former. </p>
                        <p>For example, in <code class="codeph">$.a?(@.b.c == 3)</code> the type of <code class="codeph">$a.b.c</code> is unknown at compile time. The path expression is compiled as <code class="codeph">$.a?(@.b.c.<span class="bold">number()</span> == 3)</code>. At runtime an attempt is thus made to cast the data that matches <code class="codeph">$a.b.c</code> to a number. A string value <code class="codeph">"3"</code> would be cast to the number <code class="codeph">3</code>, satisfying the comparison.<a id="fn_4" name="fn_4" href="#fn_4" onclick="footdisplay(4, "To prevent such casting here, you can explicitly apply item method numberOnly(): $.a?(@.b.c.numberOnly() == 3). Data with a string value \"3\" would simply not match; it would be filtered out.")"><sup>Foot&nbsp;4</sup></a></p>
                     </li>
                     <li>
                        <p>If the types of both operands are <span class="italic">known</span> and they are <span class="italic">not</span> the same then an attempt is made to cast the type of one to the type of the other. Details are presented below.
                        </p>
                     </li>
                  </ul>
                  <p>Comparison operands used in the following combinations are <span class="italic">not</span> reconciled; a <span class="italic">compile-time error</span> is raised.
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Number compared with any non-number type other than double.</p>
                     </li>
                     <li>
                        <p>Double compared with any non-double type other than number.</p>
                     </li>
                     <li>
                        <p>String compared with double.</p>
                     </li>
                     <li>
                        <p>Boolean compared with any non-Boolean type, except for comparison with a string value of <code class="codeph">'true'</code> or <code class="codeph">'false'</code> (or any letter-case variants, such as <code class="codeph">'tRUe'</code>).
                        </p>
                     </li>
                     <li>
                        <p>Date or timestamp compared with string, unless the string has a supported ISO 8601 format.</p>
                     </li>
                     <li>
                        <p>Date compared with any non-date type other than string.</p>
                     </li>
                     <li>
                        <p>Timestamp (with or without time zone) compared with any non-timestamp type other than string.</p>
                     </li>
                     <li>
                        <p>JSON <code class="codeph">null</code> compared with any type other than JSON <code class="codeph">null</code>.
                        </p>
                     </li>
                  </ul>
                  <p>An attempt is made to reconcile comparison operands used in the following combinations, by type-casting. You can think of a type-casting item method being implicitly applied to one of the operands in order to make it type-compatible with the other operand.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Number compared with double — <code class="codeph">double()</code> is implicitly applied to the number to make it a double value.
                        </p>
                     </li>
                     <li>
                        <p>String value of <code class="codeph">'true'</code> or <code class="codeph">'false'</code> (or any letter-case variants, such as <code class="codeph">'tRUe'</code>) compared with Boolean — <code class="codeph">boolean()</code> is implicitly applied to the string to make it a Boolean value.
                        </p>
                     </li>
                     <li>
                        <p>String in a supported ISO 8601 format compared with date — <code class="codeph">date()</code> is implicitly applied to the string to make it a date value. (Any time-zone component present is removed.)
                        </p>
                     </li>
                     <li>
                        <p>String in a supported ISO 8601 format compared with timestamp (with or without) time zone — <code class="codeph">timestamp()</code>  is implicitly applied to the string to make it a timestamp value. For this, the UTC time zone (Coordinated Universal Time, zero offset) is used as the default, taking into account any time zone specified in the string.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="json-path-expressions.html#GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13" title="The Oracle item methods available for a SQL/JSON path expression are described.">SQL/JSON Path Expression Item Methods</a></li>
                        <li><a href="json-path-expressions.html#GUID-20DC09A8-98DF-4473-8077-913D490A969C" title="International Standards Organization (ISO) standard 8601 describes an internationally accepted way to represent dates and times. Oracle Database supports many of the ISO 8601 date and time formats.">ISO 8601 Date and Time Support</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">SQL/JSON Path Expressions</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">Footnote Legend</p>Footnote&nbsp;1: The <code class="codeph">to</code> in
                            a range specification is sometimes informally called the array
                                <span class="italic">slice</span> operator.<br>Footnote&nbsp;2: <code class="codeph">!=</code> is an Oracle alias for the SQL/JSON standard comparison predicate <code class="codeph">&lt;&gt;</code>.<br>Footnote&nbsp;3: Applying item method <code class="codeph">timestamp()</code> to a supported ISO 8601 string <code class="codeph"><span class="codeinlineitalic">&lt;ISO-STRING&gt;</span></code> has the effect of SQL <code class="codeph">sys_extract_utc(to_utc_timestamp_tz(<span class="codeinlineitalic">&lt;ISO-STRING&gt;</span>)</code>.<br>Footnote&nbsp;4: To prevent such casting here, you can explicitly apply item method <code class="codeph">numberOnly()</code>: <code class="codeph">$.a?(@.b.c.<span class="bold">numberOnly()</span> == 3)</code>. Data with a string value <code class="codeph">"3"</code> would simply not match; it would be filtered out.<br></div>
      </article>
   </body>
</html>