<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="These scenarios present different situations you might encounter while administering your Oracle Data Guard configuration. Each of them can be adapted to your specific environment.">
      <meta name="description" content="These scenarios present different situations you might encounter while administering your Oracle Data Guard configuration. Each of them can be adapted to your specific environment.">
      <title>Oracle Data Guard Scenarios</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Concepts and Administration ">
      <meta property="og:description" content="These scenarios present different situations you might encounter while administering your Oracle Data Guard configuration. Each of them can be adapted to your specific environment.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Concepts and Administration">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="data-guard-concepts-and-administration.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T10:50:21-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96244-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="using-DBMS_ROLLING-to-perform-rolling-upgrade.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-data-guard-parameters-views.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Data Guard Concepts and Administration">
    <meta name="dcterms.isVersionOf" content="SBYDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-DBMS_ROLLING-to-perform-rolling-upgrade.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-data-guard-parameters-views.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Concepts and Administration </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-data-guard-concepts.html" property="item" typeof="WebPage"><span property="name">  Concepts and Administration </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Oracle Data Guard Scenarios</li>
            </ol>
            <a id="GUID-07C5867F-C55F-4B5B-804F-1800CE9985EF" name="GUID-07C5867F-C55F-4B5B-804F-1800CE9985EF"></a><a id="SBYDB5073"></a><a id="SBYDB00900"></a>
            
            <h2 id="SBYDB-GUID-07C5867F-C55F-4B5B-804F-1800CE9985EF" class="sect2"><span class="enumeration_chapter">15 </span> Oracle Data Guard Scenarios
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>These scenarios present different situations you might encounter while administering your Oracle Data Guard configuration. Each of them can be adapted to your specific environment.</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-CBC9D920-C2D0-4342-ACEF-C16289D1774A" title="These are the steps required on a logical standby database after the primary database has failed over to another standby database.">Configuring Logical Standby Databases After a Failover</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB" title="After a failover occurs, the original primary database can no longer participate in the Oracle Data Guard configuration until it is repaired and established as a standby database in the new configuration.">Converting a Failed Primary Into a Standby Database Using Flashback Database</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-BAA5ED38-29A0-4E8D-8435-AA083D19C13E" title="If an error occurrs on the primary database in an Oracle Data Guard configuration in which the standby database is using real-time apply, then the same error is applied on the standby database. if Flashback Database is enabled, you can revert the primary and standby databases back to their pre-error condition.">Using Flashback Database After Issuing an Open Resetlogs Statement</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-BD9E85AB-D812-4659-9C85-26CDFF115A8A" title="Some SQL statements allow you to specify a NOLOGGING clause so that the operation is not logged in the online redo log file.">Recovering After the NOLOGGING Clause Is Specified</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540" title="When you create standby databases, there are additional steps that must be performed if the primary database uses Oracle Managed Files (OMF) or Oracle Automatic Storage Management (Oracle ASM).">Creating a Standby Database That Uses OMF or Oracle ASM</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-8F4E7807-6013-480F-8780-088F5639732F" title="During media recovery in an Oracle Data Guard configuration, a physical standby database can be used to detect lost-write data corruption errors on the primary database.">Recovering From Lost-Write Errors on a Primary Database</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3" title="You can use the PL/SQL procedure, DBMS_DBCOMP.DBCOMP, to detect lost writes and also to detect inconsistencies between a primary database and physical standby databases.">Using the DBCOMP Procedure to Detect Lost Writes and Other Inconsistencies</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-B734C79F-A2BB-43A5-89D7-7733089FB577" title="To convert a failed primary database, Oracle recommends that you enable the Flashback Database feature on the primary and follow one of these procedures, as appropriate.">Converting a Failed Primary into a Standby Database Using RMAN Backups</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-FCDB44CE-FBFE-43BB-88E3-74267B38FE70" title="Oracle Data Guard allows you to change both the database character set and the national character set of a primary database without requiring you to recreate any physical standby databases in the configuration.">Changing the Character Set of a Primary Without Re-Creating Physical Standbys</a></p>
                  </li>
                  <li>
                     <p><a href="examples-of-using-oracle-data-guard.html#GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF" title="After you perform a PDB PITR or PDB Flashback on a primary, you can either restore the PDB or flashback the PDB on the standby to let the standby follow the primary.">Actions Needed On a Standby After a PDB PITR or PDB Flashback On a Primary</a></p>
                  </li>
               </ul>
            </div><a id="SBYDB4885"></a><div class="props_rev_3"><a id="GUID-CBC9D920-C2D0-4342-ACEF-C16289D1774A" name="GUID-CBC9D920-C2D0-4342-ACEF-C16289D1774A"></a><h3 id="SBYDB-GUID-CBC9D920-C2D0-4342-ACEF-C16289D1774A" class="sect3"><span class="enumeration_section">15.1 </span>Configuring Logical Standby Databases After a Failover
               </h3>
               <div>
                  <p>These are the steps required on a logical standby database after the primary database has failed over to another standby database.</p>
                  <p>After a failover has occurred, a logical standby database cannot act as a standby database for the new primary database until it has applied the final redo from the original primary database. This is similar to the way the new primary database applied the final redo during the failover. The steps you must perform depend on whether the new primary database was a physical standby or a logical standby database prior to the failover:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-C058F492-C55E-4EF4-929C-CA8AF206F349" title="These steps demonstrate how to configure a logical standby database to support a new primary database that was a physical standby database before it assumed the primary role.">When the New Primary Database Was Formerly a Physical Standby Database</a></p>
                     </li>
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-424FC856-08A5-4F68-9EEC-93F0EF575A3A" title="These steps demonstrate how to configure a logical standby database to support a new primary database that was a logical standby database before it assumed the primary role.">When the New Primary Database Was Formerly a Logical Standby Database</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4886"></a><div class="props_rev_3"><a id="GUID-C058F492-C55E-4EF4-929C-CA8AF206F349" name="GUID-C058F492-C55E-4EF4-929C-CA8AF206F349"></a><h4 id="SBYDB-GUID-C058F492-C55E-4EF4-929C-CA8AF206F349" class="sect4"><span class="enumeration_section">15.1.1 </span>When the New Primary Database Was Formerly a Physical Standby Database
                  </h4>
                  <div>
                     <p>These steps demonstrate how to configure a logical standby database to support a new primary database that was a physical standby database before it assumed the primary role. </p>
                     <div class="section">
                        <p>In this scenario, SAT is the logical standby database and NYC is the primary database.</p>
                        <ol>
                           <li>
                              <p>On the SAT database, issue the following statement to configure the FAL_SERVER parameter to enable automatic recovery of log files.</p>
                              <p></p><pre class="pre codeblock"><code>SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
SQL&gt; ALTER SYSTEM SET FAL_CLIENT='&lt;tns_name_to_local_database&gt;';
</code></pre></li>
                           <li>
                              <p>Call the PREPARE_FOR_NEW_PRIMARY routine to verify that the logical standby database is capable of serving as a standby database to the new primary database. During this step, local copies of log files that pose a risk for data divergence are deleted from the local database. These log files are then requested for re-archival directly from the new primary database.</p>
                              <p>On the SAT database, issue the following statement:</p><pre class="pre codeblock"><code>SQL&gt; EXECUTE DBMS_LOGSTDBY.PREPARE_FOR_NEW_PRIMARY( -
&gt;  former_standby_type =&gt; 'PHYSICAL' -
&gt;  dblink =&gt; 'nyc_link');
</code></pre><div class="infoboxnote" id="GUID-C058F492-C55E-4EF4-929C-CA8AF206F349__GUID-0690661F-5155-4D13-BB14-7DE18F7CAA9C">
                                 <p class="notep1">Note:</p>
                                 <p>If the <code class="codeph">ORA-16109</code> message is returned and the 'LOGSTDBY: prepare_for_new_primary failure -- applied too far, flashback required.' warning is written in the alert.log, perform the following steps:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>Flash back the database to the SCN as stated in the warning and then </p>
                                    </li>
                                    <li>
                                       <p>Repeat this step before continuing.</p>
                                    </li>
                                 </ol>
                                 <p>See <a href="examples-of-using-oracle-data-guard.html#GUID-A6260CFC-7ABA-4478-9211-BC665077725B" title="These steps describe how to use Flashback Database and SQL Apply to recover to a known applied SCN.">Flashing Back a Logical Standby Database to a Specific Applied SCN</a> for an example of how to flash back a logical standby database to an Apply SCN.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>On the SAT database, issue the following statement to start SQL Apply:</p>
                              <p></p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4887"></a><div class="props_rev_3"><a id="GUID-424FC856-08A5-4F68-9EEC-93F0EF575A3A" name="GUID-424FC856-08A5-4F68-9EEC-93F0EF575A3A"></a><h4 id="SBYDB-GUID-424FC856-08A5-4F68-9EEC-93F0EF575A3A" class="sect4"><span class="enumeration_section">15.1.2 </span>When the New Primary Database Was Formerly a Logical Standby Database
                  </h4>
                  <div>
                     <p>These steps demonstrate how to configure a logical standby database to support a new primary database that was a logical standby database before it assumed the primary role. </p>
                     <div class="section">
                        <p>In this scenario, SAT is the logical standby database and NYC is the primary database.</p>
                        <ol>
                           <li>
                              <p>Ensure the new primary database is ready to support logical standby databases. On the NYC database, ensure the following query returns a value of <code class="codeph">NONE</code>. Otherwise the new primary database has not completed the work required to enable support for logical standby databases. For example:
                              </p><pre class="pre codeblock"><code>SQL&gt; SELECT PENDING_ROLE_CHANGE_TASKS FROM V$DATABASE;
</code></pre><p>A value of <code class="codeph">NONE</code> must be returned before you attempt to reinstate an old primary database.
                              </p>
                           </li>
                           <li>
                              <p>On the SAT database, issue the following statement to configure the FAL_SERVER parameter to enable automatic recover of log files:</p>
                              <p></p><pre class="pre codeblock"><code>SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
SQL&gt; ALTER SYSTEM SET FAL_CLIENT='&lt;tns_name_to_local_database&gt;';
</code></pre></li>
                           <li>
                              <p>Call the <code class="codeph">PREPARE_FOR_NEW_PRIMARY</code> routine to verify the logical standby database is capable of being a standby to the new primary. During this step, local copies of log files which pose a risk for data divergence are deleted from the local database. These log files are then requested for re-archival directly from the new primary database.
                              </p>
                              <p>On the SAT database, issue the following statement:</p><pre class="pre codeblock"><code>SQL&gt; EXECUTE DBMS_LOGSTDBY.PREPARE_FOR_NEW_PRIMARY( -
&gt; former_standby_type =&gt; 'LOGICAL' -
&gt; dblink =&gt; 'nyc_link');
</code></pre><div class="infoboxnote" id="GUID-424FC856-08A5-4F68-9EEC-93F0EF575A3A__GUID-B2DCBE47-118C-43B0-9F3A-F74D37E2E39F">
                                 <p class="notep1">Note:</p>
                                 <p>If the <code class="codeph">ORA-16109</code> message is returned and the <code class="codeph">LOGSTDBY: prepare_for_new_primary failure -- applied too far, flashback required</code> warning is written in the alert.log file, perform the following steps:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>Flash back the database to the SCN as stated in the warning and then </p>
                                    </li>
                                    <li>
                                       <p>Repeat this step before continuing.</p>
                                    </li>
                                 </ol>
                                 <p>See <a href="examples-of-using-oracle-data-guard.html#GUID-A6260CFC-7ABA-4478-9211-BC665077725B" title="These steps describe how to use Flashback Database and SQL Apply to recover to a known applied SCN.">Flashing Back a Logical Standby Database to a Specific Applied SCN</a> for an example of how to flash back a logical standby database to an Apply SCN.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>On the SAT database, issue the following statements to start SQL Apply:</p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY nyc_link;
</code></pre><p>This statement must always be issued without the real-time apply option enabled. To enable real-time apply on the logical standby database, wait for the above statement to complete successfully, and then issue the following statements:</p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="SBYDB00910"></a><div class="props_rev_3"><a id="GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB" name="GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB"></a><h3 id="SBYDB-GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB" class="sect3"><span class="enumeration_section">15.2 </span>Converting a Failed Primary Into a Standby Database Using Flashback Database
               </h3>
               <div>
                  <p>After a failover occurs, the original primary database can no longer participate in the Oracle Data Guard configuration until it is repaired and established as a standby database in the new configuration. </p>
                  <p>To do this, you can use the Flashback Database feature to recover the failed primary database to a point in time before the failover occurred, and then convert it into a physical or logical standby database in the new configuration. The following sections describe:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-C7C39BEC-A841-48D1-BE4B-9BB49C65B9C9" title="These steps bring the old primary database back into the Oracle Data Guard configuration as a physical standby database.">Flashing Back a Failed Primary Database into a Physical Standby Database </a></p>
                     </li>
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-324EBFC6-5358-419A-AD4A-E457273E6560" title="These steps bring the old primary database back into the Oracle Data Guard configuration as a new logical standby database without having to formally instantiate it from the new primary database.">Flashing Back a Failed Primary Database into a Logical Standby Database</a> 
                        </p>
                        <div class="infoboxnote" id="GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB__GUID-66988666-621E-4102-805D-1A0A1695E456">
                           <p class="notep1">Note:</p>
                           <p>You must have already enabled Flashback Database on the original primary database before the failover. See <a href="../bradv/using-flasback-database-restore-points.html#BRADV71000" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-A6260CFC-7ABA-4478-9211-BC665077725B" title="These steps describe how to use Flashback Database and SQL Apply to recover to a known applied SCN.">Flashing Back a Logical Standby Database to a Specific Applied SCN</a></p>
                        <div class="infoboxnotealso" id="GUID-1163448F-6B18-4A44-AA8D-7CDF0D1360FB__GUID-53149AF4-B728-4706-B16C-9205D8089915">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=DGBKR3438" target="_blank"><span class="italic">Oracle Data Guard Broker</span></a> for information about automatic reinstatement of the failed primary database as a new standby database (as an alternative to using Flashback Database)
                           </p>
                        </div>
                     </li>
                  </ul>
               </div><a id="SBYDB4888"></a><div class="props_rev_3"><a id="GUID-C7C39BEC-A841-48D1-BE4B-9BB49C65B9C9" name="GUID-C7C39BEC-A841-48D1-BE4B-9BB49C65B9C9"></a><h4 id="SBYDB-GUID-C7C39BEC-A841-48D1-BE4B-9BB49C65B9C9" class="sect4"><span class="enumeration_section">15.2.1 </span>Flashing Back a Failed Primary Database into a Physical Standby Database
                  </h4>
                  <div>
                     <p>These steps bring the old primary database back into the Oracle Data Guard configuration as a physical standby database.</p>
                     <div class="section">
                        <p>The following steps assume that a failover has been performed to a physical standby database and that Flashback Database was enabled on the old primary database at the time of the failover. </p>
                        <ol>
                           <li>
                              <p>On the new primary database, issue the following query to determine the SCN at which the old standby database became the new primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TO_CHAR(STANDBY_BECAME_PRIMARY_SCN) FROM V$DATABASE;
</pre></li>
                           <li>
                              <p>Shut down the old primary database (if necessary), mount it, and flash it back to the value for <code class="codeph">STANDBY_BECAME_PRIMARY_SCN</code> that was determined in the previous step.
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
SQL&gt; FLASHBACK DATABASE TO SCN <span class="variable" translate="no">standby_became_primary_scn</span>;
</pre></li>
                           <li>
                              <p>To convert the database to a physical standby database, issue the following statement on the old primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
</pre></li>
                           <li>
                              <p>To start transporting redo to the new physical standby database, perform the following steps on the new primary database:</p>
                              <ol type="a">
                                 <li>
                                    <p>Issue the following query to see the current state of the archive destinations:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;</pre><pre class="oac_no_warn" dir="ltr"></pre></li>
                                 <li>
                                    <p>If necessary, enable the destination:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_<span class="variable" translate="no">n</span>=ENABLE;
</pre></li>
                                 <li>
                                    <p>Perform a log switch to ensure the standby database begins receiving redo data from the new primary database, and verify it was sent successfully. Issue the following SQL statements on the new primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SWITCH LOGFILE;
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION,- 
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre><p>On the new standby database, you may also need to change the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> initialization parameters so that redo transport services do not transmit redo data to other databases.
                                    </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>Start Redo Apply on the new physical standby database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</pre><p>Redo Apply automatically stops each time it encounters a redo record that is generated as the result of a role transition, so Redo Apply needs to be restarted one or more times until it has applied beyond the SCN at which the new primary database became the primary database. Once the failed primary database is restored and is running in the standby role, you can optionally perform a switchover to transition the databases to their original (pre-failure) roles. See <span class="q">"<a href="managing-oracle-data-guard-role-transitions.html#GUID-AAD70601-D248-4309-B8DD-F461EE31A5FF" title="These steps describe how to perform a switchover to a physical standby database.">Performing a Switchover to a Physical Standby Database</a>"</span> for more information.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4889"></a><div class="props_rev_3"><a id="GUID-324EBFC6-5358-419A-AD4A-E457273E6560" name="GUID-324EBFC6-5358-419A-AD4A-E457273E6560"></a><h4 id="SBYDB-GUID-324EBFC6-5358-419A-AD4A-E457273E6560" class="sect4"><span class="enumeration_section">15.2.2 </span>Flashing Back a Failed Primary Database into a Logical Standby Database
                  </h4>
                  <div>
                     <p>These steps bring the old primary database back into the Oracle Data Guard configuration as a new logical standby database without having to formally instantiate it from the new primary database.</p>
                     <div class="section">
                        <p>These steps assume that the Oracle Data Guard configuration has already completed a failover involving a logical standby database and that Flashback Database has been enabled on the old primary database.</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Determine the flashback SCN and the recovery SCN. The flashback SCN is the SCN to which the failed primary database is flashed back. The recovery SCN is the SCN to which the failed primary database is recovered. Issue the following query on the new primary to identify these SCNs:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT merge_change# AS FLASHBACK_SCN, processed_change# AS RECOVERY_SCN -
&gt; FROM DBA_LOGSTDBY_HISTORY -
&gt; WHERE stream_sequence# = (SELECT MAX(stream_sequence#)-1 -
&gt; FROM DBA_LOGSTDBY_HISTORY);
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Flash back the failed primary database to the flashback SCN identified in the previous step:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; FLASHBACK DATABASE TO SCN <span class="italic">flashback_scn</span>;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Convert the failed primary into a physical standby, and remount the standby database in preparation for recovery:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Configure the <code class="codeph">FAL_SERVER</code> parameter to enable automatic recovery of log files. Issue the following statement on the physical standby (failed primary):</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET FAL_SERVER='&lt;tns_name_to_new_primary&gt;';
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Remove any archive logs created at the time of or, after the failover operation, from the failed primary database. If the failed primary database was isolated from the standby, it could have divergent archive logs that are not consistent with the current primary database. To ensure these divergent archive logs are never applied, they must be deleted from backups and the fast recovery area. You can use the following RMAN command to delete the relevant archive logs from the fast recovery area:</span><div><pre class="oac_no_warn" dir="ltr">RMAN&gt; DELETE FORCE ARCHIVELOG FROM SCN FLASHBACK_SCN;
</pre><p>Once deleted, these divergent logs and subsequent transactions can never be recovered.</p>
                              <p></p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Recover until the recovery SCN identified in Step 1:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; RECOVER MANAGED STANDBY DATABASE UNTIL CHANGE <span class="italic">recovery_scn</span>;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Enable the database guard:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD ALL;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Activate the physical standby to become a primary database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE ACTIVATE STANDBY DATABASE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Open the database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE OPEN;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Create a database link to the new primary, and start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC DATABASE LINK <span class="italic">mylink</span> -
&gt; CONNECT TO <span class="italic">system</span> IDENTIFIED BY <span class="italic">password</span> -
&gt; USING '<span class="italic">service_name_of_new_primary_database</span>';

SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY <span class="italic">mylink</span>;
</pre><p>The role reversal is now complete.</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4890"></a><div class="props_rev_3"><a id="GUID-A6260CFC-7ABA-4478-9211-BC665077725B" name="GUID-A6260CFC-7ABA-4478-9211-BC665077725B"></a><h4 id="SBYDB-GUID-A6260CFC-7ABA-4478-9211-BC665077725B" class="sect4"><span class="enumeration_section">15.2.3 </span>Flashing Back a Logical Standby Database to a Specific Applied SCN
                  </h4>
                  <div>
                     <div>One of the benefits of a standby database is that Flashback Database can be performed on the standby database without affecting the primary database service. Flashing back a database to a specific point in time is a straightforward task, however on a logical standby database, you may want to flash back to a time just before a known transaction was committed. Such a need can arise when configuring a logical standby database with a new primary database after a failover.  <span>These steps describe how to use Flashback Database and SQL Apply to recover to a known applied SCN.</span></div>
                     <ol>
                        <li class="stepexpand"><span>Once you have determined the known SCN at the primary (APPLIED_SCN), issue the following query to determine the corresponding SCN at the logical standby database, to use for the flashback operation:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DBMS_LOGSTDBY.MAP_PRIMARY_SCN (PRIMARY_SCN =&gt; APPLIED_SCN) -
&gt; AS TARGET_SCN FROM DUAL;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Issue the following SQL statements to flash back the logical standby database to the specified SCN, and open the logical standby database with the RESETLOGS option:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN;
SQL&gt; STARTUP MOUNT EXCLUSIVE;
SQL&gt; FLASHBACK DATABASE TO SCN &lt;TARGET_SCN&gt;;
SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Issue the following query to confirm SQL Apply has applied less than or up to the <code class="codeph">APPLIED_SCN</code>.</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN FROM V$LOGSTDBY_PROGRESS;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4891"></a><div class="props_rev_3"><a id="GUID-BAA5ED38-29A0-4E8D-8435-AA083D19C13E" name="GUID-BAA5ED38-29A0-4E8D-8435-AA083D19C13E"></a><h3 id="SBYDB-GUID-BAA5ED38-29A0-4E8D-8435-AA083D19C13E" class="sect3"><span class="enumeration_section">15.3 </span>Using Flashback Database After Issuing an Open Resetlogs Statement
               </h3>
               <div>
                  <p>If an error occurrs on the primary database in an Oracle Data Guard configuration in which the standby database is using real-time apply, then the same error is applied on the standby database.  if Flashback Database is enabled, you can revert the primary and standby databases back to their pre-error condition.</p>
                  <p></p>
                  <p>To do so, issue the <code class="codeph">FLASHBACK DATABASE</code> and <code class="codeph">OPEN RESETLOGS</code> statements on the primary database, and then issuing a similar <code class="codeph">FLASHBACK STANDBY DATABASE</code> statement on the standby database before restarting apply services. (If Flashback Database is not enabled, you need to re-create the standby database, as described in <a href="creating-oracle-data-guard-physical-standby.html#GUID-B511FB6E-E3E7-436D-94B5-071C37550170" title="You can manually create a physical standby database in maximum performance mode using asynchronous redo transport and real-time apply, the default Oracle Data Guard configuration."> Creating a Physical Standby Database </a> and <a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="There are a number of steps involved in creating a logical standby database, including prerequisites and post-creation tasks."> Creating a Logical Standby Database </a>, after the point-in-time recovery was performed on the primary database.)
                  </p>
               </div><a id="SBYDB4892"></a><div class="props_rev_3"><a id="GUID-09129494-CD98-44B6-821F-A4C2CB5AEE08" name="GUID-09129494-CD98-44B6-821F-A4C2CB5AEE08"></a><h4 id="SBYDB-GUID-09129494-CD98-44B6-821F-A4C2CB5AEE08" class="sect4"><span class="enumeration_section">15.3.1 </span>Flashing Back a Physical Standby Database to a Specific Point-in-Time
                  </h4>
                  <div>
                     <p>These steps describe how to avoid re-creating a physical standby database after you issue the <code class="codeph">OPEN RESETLOGS</code> statement on the primary database.
                     </p>
                     <div class="section">
                        <p></p>
                        <p>With Oracle Database Release 19c, if the standby is in mount mode and flashback database is enabled, you may not need to do anything. In the common case, if there is sufficient flashback data available, the standby is automatically flashed back so that the standby continues to follow the primary.</p>
                        <p>If the standby is open and flashback database is enabled, you can place the standby in mount mode and then start standby recovery. The MRP, in an attempt to let the standby follow the primary, triggers an automatic flashback of the standby. If this operation succeeds, as reported in the alert log, you need to follow up with opening the Active Data Guard instance.</p>
                        <p>If automatic flashback is not triggered, or automatic flashback did not result in the standby following the primary, you can perform the steps described in this section.</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Determine the SCN before the RESETLOGS operation occurred. For example, on the primary database, use the following query to obtain the value of the system change number (SCN) that is 2 SCNs before the <code class="codeph">RESETLOGS</code> operation occurred on the primary database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TO_CHAR(RESETLOGS_CHANGE# - 2) FROM V$DATABASE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>On the standby database, obtain the current SCN with the following query:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TO_CHAR(CURRENT_SCN) FROM V$DATABASE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If the value of <code class="codeph">CURRENT_SCN</code> is larger than the value of resetlogs_change# - 2, issue the following statement to flash back the standby database.</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; FLASHBACK STANDBY DATABASE TO SCN resetlogs_change# -2;
</pre><ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the value of <code class="codeph">CURRENT_SCN</code> is less than the value of the resetlogs_change# - 2, skip to Step 4.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If the standby database's SCN is far enough behind the primary database's SCN, and the new branch of redo from the <code class="codeph">OPEN RESETLOGS</code> statement has been registered at the standby, then apply services can continue through the <code class="codeph">OPEN RESETLOGS</code> statement without stopping. In this case, flashing back the database is unnecessary because apply services do not stop upon reaching the <code class="codeph">OPEN RESETLOGS</code> statement in the redo data.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>To start Redo Apply on the physical standby database, issue the following statement: </span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</pre><p>The standby database is now ready to receive and apply redo from the primary database.</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4893"></a><div class="props_rev_3"><a id="GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465" name="GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465"></a><h4 id="SBYDB-GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465" class="sect4"><span class="enumeration_section">15.3.2 </span>Flashing Back a Logical Standby Database to a Specific Point-in-Time
                  </h4>
                  <div>
                     <p>These steps describe how to avoid re-creating a logical standby database after you have flashed back the primary database and opened it by issuing an <code class="codeph">OPEN RESETLOGS</code> statement.
                     </p>
                     <div class="section">
                        <p></p>
                        <div class="infoboxnote" id="GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465__GUID-D3616975-2A5C-469E-8433-25CC18CEF600">
                           <p class="notep1">Note:</p>
                           <p>If SQL Apply detects the occurrence of a resetlogs operation at the primary database, it automatically mines the correct branch of redo, if it is possible to do so without having to flashback the logical standby database. Otherwise, SQL Apply stops with an error <code class="codeph">ORA-1346: LogMiner processed redo beyond specified reset log scn</code>. In this section, it is assumed that SQL Apply has already stopped with such an error.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>On the primary database, use the following query to obtain the value of the system change number (SCN) that is 2 SCNs before the <code class="codeph">RESETLOGS</code> operation occurred on the primary database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TO_CHAR(RESETLOGS_CHANGE# - 2) AS FLASHBACK_SCN FROM V$DATABASE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Determine the target SCN for flashback operation at the logical standby. </span><div>
                              <p>In this step, the <code class="codeph">FLASHBACK_SCN</code> value for <code class="codeph">PRIMARY_SCN</code> is from Step 1.
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DBMS_LOGSTDBY.MAP_PRIMARY_SCN (PRIMARY_SCN =&gt; FLASHBACK_SCN) -
&gt; AS TARGET_SCN FROM DUAL;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Issue the following SQL statements to flash back the logical standby database to the specified SCN, and open the logical standby database with the <code class="codeph">RESETLOGS</code> option:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN;
SQL&gt; STARTUP MOUNT EXCLUSIVE;
SQL&gt; FLASHBACK DATABASE TO SCN &lt;TARGET_SCN&gt;;
SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></div>
                        </li>
                        <li class="stepexpand"><span> Confirm that a log file from the primary's new branch is registered before SQL apply is started. Issue the following query on the primary database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT resetlogs_id FROM V$DATABASE_INCARNATION WHERE status = 'CURRENT';
</pre><p>Issue the following query on the standby database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGSTDBY_LOG WHERE resetlogs_id = <span class="italic">resetlogs_id_at_primary</span>;
</pre><p>If one or more rows are returned, it confirms that there are registered logfiles from the primary's new branch.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB00920"></a><div class="props_rev_3"><a id="GUID-BD9E85AB-D812-4659-9C85-26CDFF115A8A" name="GUID-BD9E85AB-D812-4659-9C85-26CDFF115A8A"></a><h3 id="SBYDB-GUID-BD9E85AB-D812-4659-9C85-26CDFF115A8A" class="sect3"><span class="enumeration_section">15.4 </span>Recovering After the NOLOGGING Clause Is Specified
               </h3>
               <div>
                  <p>Some SQL statements allow you to specify a <code class="codeph">NOLOGGING</code> clause so that the operation is not logged in the online redo log file.
                  </p>
                  <p> In actuality, a redo record is still written to the online redo log file, but there is no data associated with the record. This can result in log application or data access errors at the standby site and manual recovery might be required to resume applying log files. Depending on whether you have a logical standby or physical standby, you can avoid these errors by doing the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Logical standbys — specify the <code class="codeph">FORCE LOGGING</code> clause in the <code class="codeph">CREATE DATABASE</code> or <code class="codeph">ALTER DATABASE</code> statements.
                        </p>
                     </li>
                     <li>
                        <p>Physical standbys — specify a logging mode that is appropriate to the way in which you plan to use your Data Guard configuration, as described in <a href="creating-oracle-data-guard-physical-standby.html#GUID-AE2B1237-57A1-4745-A04C-4246A831A963" title="As part of preparing the primary database for standby database creation, you must enable a logging mode appropriate to the way you plan to use the Data Guard configuration.">Enable an Appropriate Logging Mode</a>.
                        </p>
                     </li>
                  </ul>
                  <p>You can see the current logging mode in the <code class="codeph">V$DATABASE.FORCE_LOGGING</code> column (for CDBs) or the <code class="codeph">DBA_PDBS.FORCE_LOGGING</code> column (for PDBs).
                  </p>
               </div><a id="SBYDB4894"></a><div class="props_rev_3"><a id="GUID-BB804A80-7F19-4087-BAFA-97552C1DAAEF" name="GUID-BB804A80-7F19-4087-BAFA-97552C1DAAEF"></a><h4 id="SBYDB-GUID-BB804A80-7F19-4087-BAFA-97552C1DAAEF" class="sect4"><span class="enumeration_section">15.4.1 </span>Recovery Steps for Logical Standby Databases
                  </h4>
                  <div>
                     <div class="section"> 
                        <p>On logical standby databases, when SQL Apply encounters a redo record for an operation performed with the <code class="codeph">NOLOGGING</code> clause on a table that is not being skipped, it stops with the following error:
                        </p><pre class="pre codeblock"><code>ORA-16211 unsupported record found in the archived redo log</code></pre><p>To recover after the <code class="codeph">NOLOGGING</code> clause is specified, re-create one or more tables from the primary database, as described in <a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" title="Typically, you use the DBMS_LOGSTDBY.INSTANTIATE_TABLE procedure to re-create a table after an unrecoverable operation.">Adding or Re-Creating Tables On a Logical Standby Database</a>.
                        </p>
                        <div class="infoboxnote" id="GUID-BB804A80-7F19-4087-BAFA-97552C1DAAEF__GUID-E53772FF-F49B-4C21-B51B-93C133344020">
                           <p class="notep1">Note:</p>
                           <p>In general, use of the <code class="codeph">NOLOGGING</code> clause is not recommended. Therefore, if you know in advance that operations using the <code class="codeph">NOLOGGING</code> clause will be performed on certain tables in the primary database, then you might want to prevent the application of SQL statements associated with these tables to the logical standby database. You can do this by using the <code class="codeph">DBMS_LOGSTDBY.SKIP</code> procedure.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4895"></a><div class="props_rev_3"><a id="GUID-DDCEF91D-3D6A-45EC-B0ED-8BEBC32FC18B" name="GUID-DDCEF91D-3D6A-45EC-B0ED-8BEBC32FC18B"></a><h4 id="SBYDB-GUID-DDCEF91D-3D6A-45EC-B0ED-8BEBC32FC18B" class="sect4"><span class="enumeration_section">15.4.2 </span>Recovery Steps for Physical Standby Databases
                  </h4>
                  <div>
                     <div class="section">
                        <p>When the redo is applied to the physical standby database, a portion of the data file is marked as being unrecoverable. When you either fail over to the physical standby database, or open the standby database for read-only access, and attempt to read the range of blocks that are marked as <code class="codeph">UNRECOVERABLE</code>, you see error messages similar to the following:
                        </p><pre class="oac_no_warn" dir="ltr">ORA-01578: ORACLE data block corrupted (file # 1, block # 2521)
ORA-01110: data file 1: '/oracle/dbs/stdby/tbs_1.dbf'
ORA-26040: Data block was loaded using the NOLOGGING option
</pre><p>When you use <code class="codeph">STANDBY NOLOGGING FOR LOAD PERFORMANCE</code> mode it is still possible for a query executed on a physical standby to report a corrupt block due to a nologging operation. However, when managed recovery is running on that standby as part of an Active Data Guard configuration, it automatically fetches a replacement block from the primary. (Managed recovery is started with the <code class="codeph">ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT</code> statement.) Managed recovery attempts to fetch all such blocks shortly after they are first created and continues attempting to fix them until it succeeds. Whenever managed recovery is started, it again begins fixing any outstanding blocks from earlier recovery sessions. This automatic recovery applies only to corrupt blocks caused by redo generated with the <code class="codeph">STANDBY NOLOGGING FOR LOAD PERFORMANCE</code> mode enabled.  Blocks corrupted due to conventional nonlogged operations must use the following procedure. These steps describe a simple approach that recovers all nonlogged blocks. (See follow-on sections for other approaches such as determining whether a backup is required after unrecoverable operations, and recovering parts of a physical standby database.)
                        </p>
                        <ol>
                           <li>
                              <p>Stop recovery on the standby:</p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;</code></pre></li>
                           <li>
                              <p>Recover the nonlogged blocks by connecting RMAN to the standby and issue the following command:</p><pre class="pre codeblock"><code>RMAN&gt; RECOVER DATABASE NONLOGGED BLOCK;</code></pre><p>If the presence of unrecoverable blocks is only found after a switchover, then you can use these same two steps, but the primary database must be just mounted ( not open) and, RMAN must be connected to the primary.</p>
                              <p>It is possible that the RMAN <code class="codeph">RECOVER</code> command may not be able to recover all the nonlogged blocks. The reasons that this might happen are detailed in the alert log of the database from which the RMAN command was executed. The most common reason is that a block has been modified recently at the primary and not yet written to its corresponding data file. This may mean that the block sent to the standby is too old to replace the unrecoverable block on the standby.&nbsp;To resolve this, issue the <code class="codeph">RECOVER</code> command again at a later time after the block has been written out to the data file.
                              </p>
                           </li>
                        </ol>
                        <p>The following is an example of an alert log entry for an execution of the <code class="codeph">RECOVER</code> command which left some blocks unrecovered:
                        </p><pre class="pre codeblock"><code>Started Nonlogged Block Replacement recovery on file 7 (ospid 13005 rcvid 11319003446180375696)
Finished Nonlogged Block Replacement recovery on file 7. 5 blocks remain
  Statistics for replacement block source database (service=dg3tns)
  (Use of it stopped due to error 12942 received from it)
  Blocks requested 5, blocks received 0.

  Reason replacement blocks accepted or rejected               Blocks Last block
  -------------------------------------------------------- ---------- ----------
  Not received: Rejected by sender. Wrong state or SCN              5         21 </code></pre><p>In this case, the command was run on a standby and the primary did not send any blocks but instead reported the following Oracle error: .</p><pre class="pre codeblock"><code>ORA-12942: database incarnation at source does not match</code></pre><p>An examination of the alert logs would reveal that the primary had performed <code class="codeph">FLASHBACK DATABASE</code> and <code class="codeph">OPEN RESETLOGS</code> commands, but the standby had not been flashed back. This means the standby would now be on an orphaned branch of redo and therefore the primary could not supply data blocks that would be known to be the correct version.
                        </p>
                        <div class="infoboxnote" id="GUID-DDCEF91D-3D6A-45EC-B0ED-8BEBC32FC18B__GUID-899F6B7B-3810-4060-9C51-0BA78F92C036">
                           <p class="notep1">Note:</p>When a Data Guard configuration has more than one standby, an RMAN <code class="codeph">RECOVER</code> command that is run at a standby attempts to fetch blocks from the primary only. When the <code class="codeph">RECOVER</code> command is run at the primary it attempts to fetch blocks from only the one standby that it determines to be most likely to yield good blocks, which typically means the standby that is closest to being in synch with the primary.
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4896"></a><div class="props_rev_3"><a id="GUID-55881B7E-55C1-4342-94DA-A75739504980" name="GUID-55881B7E-55C1-4342-94DA-A75739504980"></a><h4 id="SBYDB-GUID-55881B7E-55C1-4342-94DA-A75739504980" class="sect4"><span class="enumeration_section">15.4.3 </span>Determining If a Backup Is Required After Unrecoverable Operations
                  </h4>
                  <div>
                     <p>If you performed unrecoverable operations on your primary database, then you need to determine if a new backup operation is required.</p>
                     <div class="section">
                        <p>To do so, take the following steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Query the <code class="codeph">V$DATAFILE</code> view on the primary database to determine the <span class="bold">system change number (SCN)</span> or the time at which the Oracle database generated the most recent invalidated redo data.</span></li>
                        <li class="stepexpand"><span>Issue the following SQL statement on the primary database to determine if you need to perform another backup:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT UNRECOVERABLE_CHANGE#,-
&gt; TO_CHAR(UNRECOVERABLE_TIME, 'mm-dd-yyyy hh:mi:ss') -
&gt; FROM V$DATAFILE;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If the query in the previous step reports an unrecoverable time for a data file that is more recent than the time when the data file was last backed up, then make another backup of the data file in question.</span></li>
                     </ol>
                     <div class="section">
                        <p>See <a href="../refrn/V-DATAFILE.html#REFRN30050" target="_blank"><span class="italic">Oracle Database Reference</span></a> for more information about the <code class="codeph">V$DATAFILE</code> view.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C342EF3D-EAB7-4B2D-A638-903345C6A3EC" name="GUID-C342EF3D-EAB7-4B2D-A638-903345C6A3EC"></a><h4 id="SBYDB-GUID-C342EF3D-EAB7-4B2D-A638-903345C6A3EC" class="sect4"><span class="enumeration_section">15.4.4 </span>Recovery Steps for Part of a Physical Standby Database
                  </h4>
                  <div>
                     <p>The RMAN <code class="codeph">RECOVER ... NONLOGGED BLOCK</code> command can be used to recover blocks that belong to a set of data files or a set of tablespaces or just a single pluggable database (PDB) as well as the multitenant container database (CDB).
                     </p>
                     <p>This ability may be useful if it is acceptable to have nonlogged blocks remain in some data files, for example because it is explicitly known that the nonlogged blocks were created as a result of loading rows into an object that has now been dropped.</p>
                     <p>The view <code class="codeph">V$NONLOGGED_BLOCK</code> usually lists the ranges of known invalid blocks for each data file and the entries are maintained as part of media recovery. However, there are times when the information is not complete. Typically this is after upgrading from a release prior to Oracle Database 12<span class="italic">c</span> Release 1 (12.1) or after restoring an operating system backup of a data file. The next time media recovery is run, the stale entries are removed and any newly invalidated blocks are recorded but any prior invalid blocks do not have entries in <code class="codeph">V$NONLOGGED_BLOCK</code>.&nbsp; The <code class="codeph">FIRST_NONLOGGED_SCN</code> column in the <code class="codeph">V$DATAFILE</code> view can still be used to see that there is at least one invalid block in a data file even when there are no <code class="codeph">V$NONLOGGED_BLOCK</code> entries for a data file.
                     </p>
                     <p>The RMAN command <code class="codeph">VALIDATE ... NONLOGGED BLOCK</code> can be used to bring the entries in <code class="codeph">V$NONLOGGED_BLOCK</code> back into synchronization with the data files. It does this by determining if the existing ranges are complete and if not, it scans the necessary data files to identify any invalid blocks and make sure they are captured by an entry in <code class="codeph">V$NONLOGGED_BLOCK</code>.&nbsp; The <code class="codeph">VALIDATE ... NONLOGGED BLOCK</code> command has the same options as the <code class="codeph">RECOVER ... NONLOGGED BLOCK</code> command to validate just a set of data files or a set of tablespaces or a PDB, as well as the CDB.
                     </p>
                     <div class="infoboxnote" id="GUID-C342EF3D-EAB7-4B2D-A638-903345C6A3EC__GUID-555EF595-2ECF-46B4-B788-7474DDEB0B90">
                        <p class="notep1">Note:</p>Entries in the <code class="codeph">V$NONLOGGED_BLOCK</code> view represent a superset of the invalid blocks, and some normal blocks that are close to an invalid block may be included.&nbsp; For example, if there is an entry for file 7 that starts at block 100 and has 50 blocks in it, then none, some, or all of those 50 blocks are invalid.&nbsp; After the <code class="codeph">VALIDATE</code> command is run, there are no ranges that have no invalid blocks in them and the first and last block of a range are also be invalid blocks.&nbsp; However, there are limits to the total number of ranges that can be held in the control file so sometimes it may be necessary to merge ranges for the same file, causing regular blocks to be included in a range.
                     </div>
                     <p>If only offline data files are to be validated or recovered then the database to which they belong can be open at the time the RMAN command is run.</p>
                  </div>
               </div>
            </div><a id="SBYDB4897"></a><div class="props_rev_3"><a id="GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540" name="GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540"></a><h3 id="SBYDB-GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540" class="sect3"><span class="enumeration_section">15.5 </span>Creating a Standby Database That Uses OMF or Oracle ASM
               </h3>
               <div>
                  <p>When you create standby databases, there are additional steps that must be performed if the primary database uses Oracle Managed Files (OMF) or Oracle Automatic Storage Management (Oracle ASM).</p>
                  <div class="section">
                     <p>The discussion in this section is presented at a level of detail that assumes you already know how to create a physical standby database and are an experienced user of the RMAN, OMF, and Oracle ASM features.</p>
                     <p>Perform the following tasks to prepare for standby database creation:</p>
                     <ol>
                        <li>
                           <p>Enable forced logging on the primary database.</p>
                        </li>
                        <li>
                           <p>Enable archiving on the primary database.</p>
                        </li>
                        <li>
                           <p>Set all necessary initialization parameters on the primary database.</p>
                        </li>
                        <li>
                           <p>Create an initialization parameter file for the standby database.</p>
                        </li>
                        <li>
                           <p>If the primary database is configured to use OMF, then Oracle recommends that the standby database be configured to use OMF, too. To do this, set the <code class="codeph">DB_CREATE_FILE_DEST</code> and <code class="codeph">DB_CREATE_ONLINE_LOG_DEST_</code><span class="italic"><code class="codeph">n</code></span> initialization parameters to appropriate values. Maintenance and future role transitions are simplified if the same disk group names are used for both the primary and standby databases.
                           </p>
                           <div class="infoboxnote" id="GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540__GUID-C66C9A8E-0ED7-451F-90BE-7DE0925F7DE4">
                              <p class="notep1">Note:</p>
                              <p>If OMF parameters are set on the standby, then new files on that standby are always created as OMF, regardless of how they were created on the primary. Therefore, if both the <code class="codeph">DB_FILE_NAME_CONVERT</code> and <code class="codeph">DB_CREATE_FILE_DEST</code> parameters are set on the standby, the <code class="codeph">DB_CREATE_FILE_DEST</code> parameter takes precedence.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>Set the <code class="codeph">STANDBY_FILE_MANAGEMENT</code> initialization parameter to <code class="codeph">AUTO</code>.
                           </p>
                        </li>
                        <li>
                           <p>Configure Oracle Net, as required, to allow connections to the standby database.</p>
                        </li>
                        <li>
                           <p>Configure redo transport authentication as described in <a href="creating-oracle-data-guard-physical-standby.html#GUID-0DC30726-3471-4588-BFE0-9CA0736328E2" title="Oracle Data Guard uses Oracle Net sessions to transport redo data and control messages between the members of an Oracle Data Guard configuration.">Configure Redo Transport Authentication</a>.
                           </p>
                        </li>
                        <li>
                           <p>Start the standby database instance without mounting the control file.</p>
                        </li>
                     </ol>
                     <p>Perform the following tasks to create the standby database:</p>
                     <ol>
                        <li>
                           <p>If the standby database is going to use Oracle ASM, create an Oracle ASM instance if one does not already exist on the standby database system.</p>
                        </li>
                        <li>
                           <p>Use the RMAN <code class="codeph">BACKUP</code> command to create a backup set that contains a copy of the primary database's data files, archived log files, and a standby control file.
                           </p>
                        </li>
                        <li>
                           <p>Use the RMAN <code class="codeph">DUPLICATE FOR STANDBY</code> command to copy the data files, archived redo log files and standby control file in the backup set to the standby database's storage area.
                           </p>
                           <p>The <code class="codeph">DUPLICATE FOR STANDBY</code> command performs the actual data movement at the standby instance. If the backup set is on tape, the media manager must be configured so that the standby instance can read the backup set. If the backup set is on disk, the backup pieces must be readable by the standby instance, either by making their primary path names available through Network File Storage (NFS), or by copying them to the standby system and using RMAN <code class="codeph">CATALOG BACKUPPIECE</code> command to catalog the backup pieces before restoring them.
                           </p>
                        </li>
                     </ol>
                     <p>After you successfully complete these steps, continue with the steps in <a href="creating-oracle-data-guard-physical-standby.html#GUID-AAA6D97B-A345-4825-A320-B662BB16E2ED" title="After you create the physical standby database and set up redo transport services, you may want to verify database modifications are being successfully transmitted from the primary database to the standby database.">Verify the Physical Standby Database Is Performing Properly</a>, to verify the configuration of the physical standby database.
                     </p>
                     <p>To create a logical standby database, continue with the standby database creation process described in <a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="There are a number of steps involved in creating a logical standby database, including prerequisites and post-creation tasks."> Creating a Logical Standby Database </a>, but with the following modifications:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>For a logical standby database, setting the <code class="codeph">DB_CREATE_FILE_DEST</code> parameter does not force the creation of OMF filenames. However, if this parameter was set on the primary database, it must also be set on the standby database.</span></li>
                     <li class="stepexpand"><span>After creating a logical standby control file on the primary system, do not use an operating system command to copy this file to the standby system. Instead, use the RMAN <code class="codeph">RESTORE CONTROLFILE</code> command to restore a copy of the logical standby control file to the standby system.</span></li>
                     <li class="stepexpand"><span>If the primary database uses OMF files, use RMAN to update the standby database control file to use the new OMF files created on the standby database. To perform this operation, connect only to the standby database, as shown in the following example:</span><div><pre class="oac_no_warn" dir="ltr">&gt; RMAN TARGET sys@lstdby

target database Password: <span class="italic">password</span>

RMAN&gt; CATALOG START WITH '+stby_diskgroup';
RMAN&gt; SWITCH DATABASE TO COPY;
</pre></div>
                     </li>
                  </ol>
                  <div class="section">
                     <p>After you successfully complete these steps, continue with the steps in <a href="creating-oracle-data-guard-logical-standby.html#GUID-68777C01-83F6-4CCF-9BA2-547ED180138D" title="Use an ALTER DATABASE SQL statement to open the newly created logical standby.">Open the Logical Standby Database</a> to start, recover, and verify the logical standby database.
                     </p>
                     <div class="infoboxnotealso" id="GUID-6FB574E5-2F3A-4C9E-A3F0-7C9154B0F540__GUID-B73E1555-4AE7-45CA-B5FA-6A4F1C9FD3BA">
                        <p class="notep1">See Also:</p>
                     </div>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="creating-oracle-data-guard-physical-standby.html#GUID-B511FB6E-E3E7-436D-94B5-071C37550170" title="You can manually create a physical standby database in maximum performance mode using asynchronous redo transport and real-time apply, the default Oracle Data Guard configuration."> Creating a Physical Standby Database </a></p>
                        </li>
                        <li>
                           <p><a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="There are a number of steps involved in creating a logical standby database, including prerequisites and post-creation tasks."> Creating a Logical Standby Database </a></p>
                        </li>
                        <li>
                           <p><a href="creating-data-guard-standby-database-using-RMAN.html#GUID-82731D59-A20F-45DD-A235-267B3B0E38C5" title="These topics describe how to use Oracle Recovery Manager to create a standby database."> Creating a Standby Database with Recovery Manager</a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ADMIN003" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about OMF
                           </p>
                        </li>
                        <li>
                           <p><a href="../ostmg/asm-intro.html#OSTMG036" target="_blank"><span class="italic">Oracle Automatic Storage Management Administrator's Guide</span></a> for more information about Oracle ASM
                           </p>
                        </li>
                        <li>
                           <p><a href="../bradv/getting-started-rman.html#BRADV89346" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for information about RMAN
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="SBYDB00930"></a><div class="props_rev_3"><a id="GUID-8F4E7807-6013-480F-8780-088F5639732F" name="GUID-8F4E7807-6013-480F-8780-088F5639732F"></a><h3 id="SBYDB-GUID-8F4E7807-6013-480F-8780-088F5639732F" class="sect3"><span class="enumeration_section">15.6 </span>Recovering From Lost-Write Errors on a Primary Database
               </h3>
               <div>
                  <p>During media recovery in an Oracle Data Guard configuration, a physical standby database can be used to detect lost-write data corruption errors on the primary database.</p>
                  <div class="section">
                     <p>This is done by comparing SCNs of blocks stored in the redo log on the primary database to SCNs of blocks on the physical standby database. If the SCN of the block on the primary database is lower than the SCN on the standby database, then there was a lost-write error on the primary database.</p>
                     <p>In such a situation, if lost write detection (set with the <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=REFRN10268" target="_blank"><code class="codeph">DB_LOST_WRITE_PROTECT</code></a> initialization parameter) is enabled at both the primary and standby, then a recovery attempt at the standby results in an <code class="codeph">ORA-752</code> error. If lost write detection is not enabled, then a recovery attempt results in an <code class="codeph">ORA-600</code> <code class="codeph">[3020]</code> error. However, not all <code class="codeph">ORA-600</code> <code class="codeph">[3020]</code> errors are due to lost writes at the primary. Therefore, before following the guidelines given in this section, work with your Oracle Support representative to determine whether the root cause for the <code class="codeph">ORA-600</code> <code class="codeph">[3020]</code> error was indeed a lost write that occurred on the primary. Also see "Resolving ORA-752 or ORA-600 [3020] During Standby Recovery" in the My Oracle Support Note 1265884.1 at <a href="http://support.oracle.com" target="_blank"><code class="codeph">http://support.oracle.com</code></a>.
                     </p>
                     <div class="infoboxnote" id="GUID-8F4E7807-6013-480F-8780-088F5639732F__GUID-BE3D28CD-A912-4D5E-B4A8-43DD627E4E3D">
                        <p class="notep1">Note:</p>
                        <p>Because lost-write errors are detected only when a block is read into the cache by a primary and the corresponding redo is later compared to the block on the standby, there may be undetected stale blocks on both the primary and the standby that have not yet been read and verified. These stale blocks do not affect operation of the current database because until those blocks are read, all blocks that have been used up to the SCN of the currently applied redo on the standby to do queries or updates were verified by the standby.</p>
                     </div>
                     <p>When a primary lost-write error is detected on the standby, one or more block error messages similar to the following for each stale block are printed in the alert file of the standby database:</p><pre class="oac_no_warn" dir="ltr">Tue Dec 12 19:09:48 2006
STANDBY REDO APPLICATION HAS DETECTED THAT THE PRIMARY DATABASE
LOST A DISK WRITE OF BLOCK 26, FILE 7
NO REDO AT OR AFTER SCN 389667 CAN BE USED FOR RECOVERY.
.
.
.
</pre><p>The alert file then shows that an <code class="codeph">ORA-00752</code> error is raised on the standby database and the managed recovery is cancelled:
                     </p><pre class="oac_no_warn" dir="ltr">Slave exiting with ORA-752 exception
Errors in file /oracle/log/diag/rdbms/dgstwrite2/stwrite2/trace/stwrite2_pr00_23532.trc:
ORA-00752: recovery detected a lost write of a data block
ORA-10567: Redo is inconsistent with data block (file# 7, block# 26)
ORA-10564: tablespace TBS_2
ORA-01110: data file 7: '/oracle/dbs/btbs_21.f'
ORA-10561: block type 'TRANSACTION MANAGED DATA BLOCK', data object# 57503
.
.
.
</pre><p>The standby database is then recovered to a consistent state, without any corruption to its data files caused by this error, at the SCN printed in the alert file:</p><pre class="oac_no_warn" dir="ltr">Recovery interrupted!
Recovered data files to a consistent state at change 389569
</pre><p>This last message may appear significantly later in the alert file and it may have a lower SCN than the block error messages. Also, the primary database may operate without visible errors even though its data files may already be corrupted.</p>
                     <p>The recommended procedure to recover from such errors is a failover to the physical standby, as described in the following steps.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8F4E7807-6013-480F-8780-088F5639732F__GUID-F119048D-05BF-4EB5-A15E-10B99381F092">Steps to Failover to a Physical Standby After Lost-Writes Are Detected on the Primary</p>
                     <ol>
                        <li>
                           <p>Shut down the primary database. All data at or after the SCN printed in the block error messages is lost.</p>
                        </li>
                        <li>
                           <p>Issue the following SQL statement on the standby database to convert it to a primary:</p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE ACTIVATE STANDBY DATABASE;

Database altered.

Tue Dec 12 19:15:23 2006
alter database activate standby database
ALTER DATABASE ACTIVATE [PHYSICAL] STANDBY DATABASE (stwrite2)
RESETLOGS after incomplete recovery UNTIL CHANGE 389569
Resetting resetlogs activation ID 612657558 (0x24846996)
Online log /oracle/dbs/bt_log1.f: Thread 1 Group 1 was previously cleared
Online log /oracle/dbs/bt_log2.f: Thread 1 Group 2 was previously cleared
Standby became primary SCN: 389567
Tue Dec 12 19:15:23 2006
Setting recovery target incarnation to 3
Converting standby mount to primary mount.
ACTIVATE STANDBY: Complete - Database mounted as primary (stwrite2)
Completed: alter database activate standby database
</code></pre></li>
                        <li>
                           <p>Back up the new primary. Performing a backup immediately is a necessary safety measure, because you cannot recover changes made after the failover without a complete backup copy of the database. As a result of the failover, the original primary database can no longer participate in the Oracle Data Guard configuration, and all other standby databases now receive and apply redo data from the new primary database.</p>
                        </li>
                        <li>
                           <p>Open the new primary database.</p>
                        </li>
                        <li>
                           <p>An optional step is to recreate the failed primary as a physical standby. You can do this using the database backup taken at the new primary in step 3. (You cannot use flashback database or the Oracle Data Guard broker to reinstantiate the old primary database in this situation.) Be aware that a physical standby created using the backup taken from the new primary has the same data files as the old standby. Therefore, any undetected lost writes that the old standby had before it was activated are not detected by the new standby, since the new standby compares the same blocks. Any new lost writes that happen on either the primary or the standby are detected.</p>
                        </li>
                     </ol>
                     <div class="infoboxnotealso" id="GUID-8F4E7807-6013-480F-8780-088F5639732F__GUID-41AAD1E5-3136-42B0-9410-F339D21EAEBE">
                        <p class="notep1">See Also:</p>
                        <p><a href="../bradv/configuring-rman-client-advanced.html#BRADV89476" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about enabling lost-write detection
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3" name="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3"></a><h3 id="SBYDB-GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3" class="sect3"><span class="enumeration_section">15.7 </span>Using the DBCOMP Procedure to Detect Lost Writes and Other Inconsistencies
               </h3>
               <div>
                  <p>You can use the PL/SQL procedure, <code class="codeph">DBMS_DBCOMP.DBCOMP</code>, to detect lost writes and also to detect inconsistencies between a primary database and physical standby databases.
                  </p>
                  <div class="section">The <code class="codeph">DBMS_DBCOMP.DBCOMP</code> procedure compares the same data blocks on the primary and physical standby databases. The procedure can be executed at any time. (It does not require that the <code class="codeph">DB_LOST_WRITE_PROTECT</code> initialization parameter be enabled.)
                     <p>You can monitor the progress of an on-going block comparison operation by querying the <code class="codeph">V$SESSION_LONGOPS</code> view.
                     </p>
                     <div class="infoboxnote" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-1BB21F67-337B-48B0-8381-21D01498C7B4">
                        <p class="notep1">Note:</p>Logical standby databases, far sync instances, and cascaded standbys cannot be the target database for the <code class="codeph">DBMS_DBCOMP.DBCOMP</code> procedure.
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="p">The <code class="codeph">DBMS_DBCOMP.DBCOMP</code> procedure assumes that there is one primary database and one or more physical standby databases. The databases should be at least mounted before block comparison.
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p> In the following example situations, assume that there is a primary database with a unique name of <code class="codeph">dgmain</code>, and that physical standby databases are named <code class="codeph">dgmainb</code>, <code class="codeph">dgmainc</code>, <code class="codeph">dgmaind</code>, and so on.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-8A2CA33C-6955-43AB-B9C7-F36A21E831E7">
                     <p class="titleinexample">Example 15-1 Primary and All Standbys Are Mounted or Open and DBCOMP Is Executed From the Primary</p>
                     <p>In this situation, when the <code class="codeph">DBCOMP</code> procedure is executed from the primary database, the specified data files are compared block by block between the primary and every physical standby database. For example, suppose that you perform the following query:
                     </p><pre class="pre codeblock"><code>SQL&gt; exec sys.dbms_dbcomp.dbcomp(‘1’,’BlockCompare’,:retval);</code></pre><p>The generated output files are <code class="codeph">BlockCompare_dgmainb_1</code> and <code class="codeph">BlockCompare_dgmainc_d_1</code>.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-E66C45D6-7FDB-442F-BA1A-546F272C8535">
                     <p class="titleinexample">Example 15-2 Primary and All Standbys Are Mounted or Open and DBCOMP Is Executed From a Standby</p>
                     <p>In this situation, when the <code class="codeph">DBCOMP</code> procedure is executed from one of the standby databases (for example, <code class="codeph">dgmainb</code>), the specified data files are compared only between the primary and that particular standby database. Other standby databases are not considered. For example, suppose that you perform the following query:
                     </p><pre class="pre codeblock"><code>SQL&gt; exec sys.dbms_dbcomp.dbcomp(‘1’,’BlockCompare’,:retval);</code></pre><p>The generated output file is <code class="codeph">BlockCompare_dgmain_1</code>.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-1B692FED-1FF2-43D5-868A-FF75307AF422">
                     <p class="titleinexample">Example 15-3 Primary Is Mounted or Open, But Not All Standbys Are, and DBCOMP is Executed From the Primary</p>
                     <p>In this situation, when the<code class="codeph">DBCOMP</code> procedure is executed on the primary, the specified data files are compared between the primary database and the mounted or open physical standby databases. For those standby databases that are neither mounted nor open, no action is taken.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-1CAF3913-A155-41F5-B801-98BC69EC9EAF">
                     <p class="titleinexample">Example 15-4 Primary Is Mounted or Open, But Not All Standbys Are, and DBCOMP is Executed From a Standby</p>
                     <p>In this situation, the specified data files are compared between the primary and the standby from which the <code class="codeph">DBCOMP</code> procedure is executed.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-0D5CDFBC-A91E-4266-B3CA-DDC9D9F03391">
                     <p class="titleinexample">Example 15-5 Primary is Not Mounted, But Multiple Standbys Are Mounted or Open</p>
                     <p>Because the primary database is neither mounted nor open, the<code class="codeph">DBCOMP</code> procedure cannot find an appropriate pair of primary and physical standby databases to compare. An <code class="codeph">ORA</code> error message is not returned, but a message similar to the following is printed out in the corresponding output file: <code class="codeph">Remote database is not in the primary role</code>.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A2FA9BA2-07F9-492E-8113-3FE8521EB3E3__GUID-445042B3-54E6-41E4-8BED-30914286675D">
                     <p class="titleinexample">Example 15-6 Primary Is Mounted or Open, But No Standbys Are Mounted or Open</p>
                     <p>Because no appropriate pair of primary and physical standby databases are found, a message is printed out in the corresponding output file, but no <code class="codeph">ORA</code> error is returned.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="../arpls/DBMS_DBCOMP.html#ARPLS-GUID-4A248C6E-F52E-4841-B26B-139DD33012B1" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="SBYDB4898"></a><div class="props_rev_3"><a id="GUID-B734C79F-A2BB-43A5-89D7-7733089FB577" name="GUID-B734C79F-A2BB-43A5-89D7-7733089FB577"></a><h3 id="SBYDB-GUID-B734C79F-A2BB-43A5-89D7-7733089FB577" class="sect3"><span class="enumeration_section">15.8 </span>Converting a Failed Primary into a Standby Database Using RMAN Backups
               </h3>
               <div>
                  <p>To convert a failed primary database, Oracle recommends that you enable the Flashback Database feature on the primary and follow one of these procedures, as appropriate.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-C7C39BEC-A841-48D1-BE4B-9BB49C65B9C9" title="These steps bring the old primary database back into the Oracle Data Guard configuration as a physical standby database.">Flashing Back a Failed Primary Database into a Physical Standby Database </a></p>
                     </li>
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-324EBFC6-5358-419A-AD4A-E457273E6560" title="These steps bring the old primary database back into the Oracle Data Guard configuration as a new logical standby database without having to formally instantiate it from the new primary database.">Flashing Back a Failed Primary Database into a Logical Standby Database</a></p>
                     </li>
                  </ul>
                  <p>The procedures in these sections describe the fastest ways to convert a failed primary into either a physical or logical standby. However, if Flashback Database was not enabled on the failed primary, you can still convert the failed primary into either a physical or logical standby using a local backup of the failed primary, as described in the following topics: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-433907DE-DF34-4CE6-989F-8F32F983FD99" title="These steps describe how to convert a failed primary into a physical standby by using RMAN backups.">Converting a Failed Primary into a Physical Standby Using RMAN Backups</a></p>
                     </li>
                     <li>
                        <p><a href="examples-of-using-oracle-data-guard.html#GUID-D93BA2CD-A50B-43A5-91C7-A719998057FC" title="These steps describe how to convert a failed primary into a logical standby using RMAN backups.">Converting a Failed Primary into a Logical Standby Using RMAN Backups</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4899"></a><div class="props_rev_3"><a id="GUID-433907DE-DF34-4CE6-989F-8F32F983FD99" name="GUID-433907DE-DF34-4CE6-989F-8F32F983FD99"></a><h4 id="SBYDB-GUID-433907DE-DF34-4CE6-989F-8F32F983FD99" class="sect4"><span class="enumeration_section">15.8.1 </span>Converting a Failed Primary into a Physical Standby Using RMAN Backups
                  </h4>
                  <div>
                     <p>These steps describe how to convert a failed primary into a physical standby by using RMAN backups. </p>
                     <div class="section">
                        <p>This procedure requires that the <code class="codeph">COMPATIBLE</code> initialization parameter of the old primary be set to at least 11.0.0. 
                        </p>
                        <ol>
                           <li>
                              <p>On the new primary database, issue the following query to determine the SCN at which the old standby database became the new primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TO_CHAR(STANDBY_BECAME_PRIMARY_SCN) FROM V$DATABASE;
</pre></li>
                           <li>
                              <p>Restore the database with a backup taken before the old primary had reached the SCN at which the standby became the new primary (<code class="codeph">standby_became_primary_scn)</code>. Then, perform a point-in-time recovery to recover the old primary to that same point.
                              </p>
                              <p>Issue the following RMAN commands:</p><pre class="oac_no_warn" dir="ltr">RMAN&gt; RUN
    {
      SET UNTIL SCN &lt;standby_became_primary_scn + 1&gt;;
      RESTORE DATABASE;
      RECOVER DATABASE;
     }
</pre><p>With user-managed recovery, you can first restore the database manually. Typically, a backup taken a couple of hours before the failover would be old enough. You can then recover the failed primary using the following command:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; RECOVER DATABASE USING BACKUP CONTROLFILE UNTIL CHANGE -
&gt;  &lt;standby_became_primary_scn + 1&gt;;
</pre><p>Unlike a reinstantiation that uses Flashback Database, this procedure adds one to <code class="codeph">standby_became_primary_scn</code>. For data files, flashing back to an SCN is equivalent to recovering up until that SCN plus one.
                              </p>
                           </li>
                           <li>
                              <p>Perform the following steps on the old primary database:</p>
                              <ol type="a">
                                 <li>
                                    <p>Issue the following statement on the old primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE CONVERT TO PHYSICAL STANDBY;
</pre></li>
                                 <li>
                                    <p>Shut down and restart the database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>Issue the following command:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE OPEN READ ONLY;
</pre><p>The goal of this step is to synchronize the control file with the database by using a dictionary check. After this command, check the alert log for any actions suggested by the dictionary check. Typically, no user action is needed if the old primary was not in the middle of adding or dropping data files during the failover.</p>
                           </li>
                           <li>
                              <p>If you have purchased a license for the Oracle Active Data Guard option and would like to operate your physical standby database in active query mode, skip this step. Otherwise, bring your standby database to the mount state.</p>
                              <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SHUTDOWN IMMEDIATE;
SQL&gt; STARTUP MOUNT;
</pre></li>
                           <li>
                              <p>Before the new standby database was created, the new primary database probably stopped transmitting redo to the remote destination. To restart redo transport services, perform the following steps on the new primary database:</p>
                              <ol type="a">
                                 <li>
                                    <p>Issue the following query to see the current state of the archive destinations:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;</pre><pre class="oac_no_warn" dir="ltr"></pre></li>
                                 <li>
                                    <p>If necessary, enable the destination:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_<span class="variable" translate="no">n</span>=ENABLE;
</pre></li>
                                 <li>
                                    <p>Perform a log switch to ensure the standby database begins receiving redo data from the new primary database, and verify it was sent successfully. </p>
                                    <div class="infoboxnote" id="GUID-433907DE-DF34-4CE6-989F-8F32F983FD99__GUID-D6298422-A64D-451F-887B-595FF2F7BEAC">
                                       <p class="notep1">Note:</p>
                                       <p>This is an important step in order for the old primary to become a new standby following the new primary. If this step is not done, the old primary may recover to an incorrect database branch. The only way to correct the problem then is to convert the old primary again.</p>
                                    </div>
                                    <p>At the SQL prompt, enter the following statements:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SWITCH LOGFILE;
SQL&gt; SELECT DEST_ID, DEST_NAME, STATUS, PROTECTION_MODE, DESTINATION, -
&gt; ERROR,SRL FROM V$ARCHIVE_DEST_STATUS;
</pre><p>On the new standby database, you may also need to change the <code class="codeph">LOG_ARCHIVE_DEST_</code><span class="italic"><code class="codeph">n</code></span> initialization parameters so that redo transport services do not transmit redo data to other databases. This step can be skipped if both the primary and standby database roles were set up with the <code class="codeph">VALID_FOR</code> attribute in one server parameter file (SPFILE). By doing this, the Oracle Data Guard configuration operates properly after a role transition.
                                    </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>Start Redo Apply on the new physical standby database, as follows:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</pre><p>Once the failed primary database is restored and is running in the standby role, you can optionally perform a switchover to transition the databases to their original (pre-failure) roles. See <span class="q">"<a href="managing-oracle-data-guard-role-transitions.html#GUID-AAD70601-D248-4309-B8DD-F461EE31A5FF" title="These steps describe how to perform a switchover to a physical standby database.">Performing a Switchover to a Physical Standby Database</a>"</span> for more information.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4900"></a><div class="props_rev_3"><a id="GUID-D93BA2CD-A50B-43A5-91C7-A719998057FC" name="GUID-D93BA2CD-A50B-43A5-91C7-A719998057FC"></a><h4 id="SBYDB-GUID-D93BA2CD-A50B-43A5-91C7-A719998057FC" class="sect4"><span class="enumeration_section">15.8.2 </span>Converting a Failed Primary into a Logical Standby Using RMAN Backups
                  </h4>
                  <div>
                     <p>These steps describe how to convert a failed primary into a logical standby using RMAN backups. </p>
                     <div class="section">
                        <ol>
                           <li>
                              <p>On the new primary database, issue the following query to determine the SCN to which you want to recover the failed primary database:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN RECOVERY_SCN FROM V$LOGSTDBY_PROGRESS;
</pre><p>Also on the new primary database, determine the SCN to use in dealing with archive logs, as follows:</p>
                              <ol type="a">
                                 <li>
                                    <p>Ensure all standby redo logs have been archived. Issue the following query, looking for a value of <code class="codeph">NONE</code> to be returned. Depending on the size of the database and the number of logs needing to be archived, it could take some time before a status of <code class="codeph">NONE</code> is returned.
                                    </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT PENDING_ROLE_CHANGE_TASKS FROM V$DATABASE;
</pre></li>
                                 <li>
                                    <p>After a status of <code class="codeph">NONE</code> has been returned, run the following query to retrieve the SCN for dealing with archive logs as part of this recovery:
                                    </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT VALUE ARCHIVE_SCN FROM SYSTEM.LOGSTDBY$PARAMETERS -
&gt; WHERE NAME='STANDBY_BECAME_PRIMARY_SCN';
</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>Remove any archive logs created at the time of, or after the failover operation, from the failed primary database. If the failed primary database was isolated from the standby, it could have divergent archive logs that are not consistent with the current primary database. To ensure these divergent archive logs are never applied, they must be deleted from backups and the fast recovery area. You can use the following RMAN command to delete the relevant archive logs from the fast recovery area:</p><pre class="oac_no_warn" dir="ltr">RMAN&gt; DELETE FORCE ARCHIVELOG FROM SCN ARCHIVE_SCN;
</pre><p>Once deleted, these divergent logs and subsequent transactions can never be recovered.</p>
                              <p></p>
                           </li>
                           <li>
                              <p>On the new primary database, issue the following query to determine the minimum set of log files that must be copied to the failed primary database before recovering from a backup:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT file_name FROM DBA_LOGSTDBY_LOG WHERE next_change# &gt; ARCHIVE_SCN;
</pre><p>Retrieve the required standby logs, copy the backup set to the new standby and restore it to the new standby fast recovery area. Because these logs are coming from standby redo logs, they are not part of the standby's standard archives. The RMAN utility is able to use a partial file name to retrieve the files from the correct location.</p>
                              <p>The following is a sample use of the RMAN <code class="codeph">BACKUP</code> command:
                              </p><pre class="oac_no_warn" dir="ltr">RMAN&gt; BACKUP AS COPY DEVICE TYPE DISK FORMAT '/tmp/test/%U'
&gt; ARCHIVELOG LIKE '&lt;partial file names from above&gt;%';
</pre><p>The following is a sample use of the RMAN <code class="codeph">RESTORE</code> command:
                              </p><pre class="oac_no_warn" dir="ltr">RMAN&gt; CATALOG START WITH '/tmp/test';
RMAN&gt; RESTORE ARCHIVELOG FROM SEQUENCE 33 UNTIL SEQUENCE 35;
</pre></li>
                           <li>
                              <p>Restore a backup of all the original primary's data files and recover to <code class="codeph">RECOVERY_SCN + 1</code>. Oracle recommends that you leverage the current control file.
                              </p>
                              <ol type="a">
                                 <li>
                                    <p>Start up the database in restricted mode to protect it from rogue transactions until the <code class="codeph">GUARD ALL</code> command can be issued after the database has been opened.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Use the backup to restore the data files of the failed primary database.</p>
                                 </li>
                                 <li>
                                    <p>Turn off flashback database, if it is enabled (necessary for the <code class="codeph">USING BACKUP CONTROLFILE</code> clause).
                                    </p>
                                 </li>
                                 <li>
                                    <p>Perform point-in-time recovery to <code class="codeph">RECOVERY_SCN +1</code> in SQL*Plus.
                                    </p>
                                 </li>
                              </ol>
                              <p>Whether you are using a current control file or a backup control file, you must specify the <code class="codeph">USING BACKUP CONTROLFILE </code>clause to allow you to point to the archive logs being restored. Otherwise, the recovery process could attempt to access online redo logs instead of the logs retrieved in Step 3. When prompted for the sequences retrieved in Step 3, ensure you specify the file names of the restored archive log copies, as follows:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; RECOVER DATABASE UNTIL CHANGE RECOVERY_SCN + 1 USING BACKUP CONTROLFILE;
</pre></li>
                           <li>
                              <p>Open the database with the RESETLOGS option:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE OPEN RESETLOGS;
</pre></li>
                           <li>
                              <p>Enable Database Guard</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD ALL;
</pre></li>
                           <li>
                              <p>Create a database link to the new primary database and start SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC DATABASE LINK <span class="italic">myLink</span> -
&gt; CONNECT TO SYSTEM IDENTIFIED BY <span class="italic">password</span> -
&gt; USING '<span class="italic">service name of new primary database</span>';
</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY NEW PRIMARY <span class="italic">myLink</span>;
</pre><p>At this point, you can disable restricted session (<code class="codeph">ALTER SYSTEM DISABLE RESTRICTED SESSION</code>) or, if you need to restart the database to re-enable Flashback from Step 4c, let this restart turn off <code class="codeph">RESTRICTED SESSION</code>.
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="SBYDB5134"></a><div class="props_rev_3"><a id="GUID-FCDB44CE-FBFE-43BB-88E3-74267B38FE70" name="GUID-FCDB44CE-FBFE-43BB-88E3-74267B38FE70"></a><h3 id="SBYDB-GUID-FCDB44CE-FBFE-43BB-88E3-74267B38FE70" class="sect3"><span class="enumeration_section">15.9 </span>Changing the Character Set of a Primary Without Re-Creating Physical Standbys
               </h3>
               <div>
                  <p>Oracle Data Guard allows you to change both the database character set and the national character set of a primary database without requiring you to recreate any physical standby databases in the configuration. </p>
                  <p>You can continue to use your physical standby database with minimal disruption while performing character set conversion of a primary database.</p>
                  <p>The character set migration process consists of preparatory steps such as scanning for possible issues and identifying methods to solve them. During the execution of these preparatory steps the Oracle Data Guard configuration can operate unchanged and no extra steps are required to maintain the physical standby. After the preparatory steps are completed, the actual conversion is performed which may involve changes to both system data (metadata) and user data. Several procedures specific to Oracle Data Guard must be run as part of the conversion. The steps to run these procedures are interspersed with the steps performed by the Database Migration Assistant for Unicode (DMU) or other appropriate character set migration tool.</p>
                  <p>For a detailed description of the steps involved in this process, see My Oracle Support note 1124165.1 at <a href="http://support.oracle.com" target="_blank"><code class="codeph">http://support.oracle.com</code></a>. 
                  </p>
               </div>
            </div><a id="SBYDB5448"></a><div class="props_rev_3"><a id="GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF" name="GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF"></a><h3 id="SBYDB-GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF" class="sect3"><span class="enumeration_section">15.10 </span>Actions Needed On a Standby After a PDB PITR or PDB Flashback On a Primary
               </h3>
               <div>
                  <p>After you perform a PDB PITR or PDB Flashback on a primary, you can either restore the PDB or flashback the PDB on the standby to let the standby follow the primary.</p>
                  <div class="section">
                     <p></p>
                     <p>With Oracle Database Release 19c, if the standby is in mount mode and flashback database is enabled, you may not need to do anything. In the common case, if there is sufficient flashback data, the standby is automatically flashed back so that the standby continues to follow the primary.</p>
                     <p>In all other cases, when a PDB PITR or PDB flashback is performed on the primary, and redo for the start of the operation is encountered for the first time, the MRP at the standby terminates with error <code class="codeph">ORA-39874</code>, followed by the supplemental error <code class="codeph">ORA-39873</code>. The following is an example of the messages that may appear in the alert log:
                     </p><pre class="oac_no_warn" dir="ltr">Recovery of pluggable database PDB1 aborted due to pluggable database open
resetlog marker. 
To continue recovery, restore all data files for this PDB to
checkpoint SCN lower than 1437261, or timestamp before 11/15/2012 16:38:49,
and restart recovery 
MRP0: Background Media Recovery terminated with error 39874
 
ORA-39874: Pluggable Database PDB1 recovery halted
ORA-39873: Restore all data files to a checkpoint SCN lower than 1437261.
</pre><p></p>
                     <p>With Oracle Database Release 19c, if the standby is open and flashback database is enabled, you can place the standby in mount mode and start standby recovery. The MRP, in an attempt to allow the standby to follow the primary, triggers an automatic flashback of the standby. If this succeeds, as reported in the alert log, you need to just follow up with opening the Active Data Guard instance. If automatic flashback is not triggered, or automatic flashback did not result in the standby following the primary, then you can perform the manual steps described in this section.</p>
                     <p>Before media recovery on the standby can continue any further, you must restore all data files for that PDB. You can do this in two ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If flashback is enabled on the standby, then you can use PDB flashback on the standby and then restart standby managed recover. See “Performing Recovery When Flashback is Enabled” below.</p>
                        </li>
                        <li>
                           <p>If flashback in not enabled on the standby, then recovery can be done from a backup taken at a time prior to the point-in-time the PDB was recovered on the primary. See “Performing Recovery When Flashback is Not Enabled” below.</p>
                        </li>
                     </ul>
                     <p>With either method, a PDB that has undergone PDB PITR or flashback on the primary cannot be opened on a standby until it has caught up with the rest of the standby.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF__GUID-0BC694A6-E1E8-417C-88EE-4C284A864EE3">Performing Recovery When Flashback Is Enabled</p>
                     <p>If flashback is enabled on the standby, you can flashback the PDB on the standby and then restart standby managed recovery.</p>
                     <ol>
                        <li>
                           <p>Determine the affected PDB and PITR SCN.</p>
                           <p>The name of the PDB for which recovery was halted is shown in the <code class="codeph">ORA-39874</code> message and the PITR SCN is shown in the <code class="codeph">ORA-39873</code> message.
                           </p>
                        </li>
                        <li>
                           <p>Close the standby database, if it is still open:</p><pre class="pre codeblock"><code>SQL&gt; ALTER DATABASE CLOSE;</code></pre></li>
                        <li>
                           <p>Flashback the pluggable database on the standby:</p><pre class="pre codeblock"><code>SQL&gt; FLASHBACK PLUGGABLE DATABASE pdb1 TO SCN 1437260;</code></pre><p>The SCN for the<code class="codeph"> FLASHBACK PLUGGABLE DATABASE</code> command is <code class="codeph">1437260</code>, not <code class="codeph">1437261</code> as in the following example, because <code class="codeph">TO SCN</code> and <code class="codeph">UNTIL SCN</code> have different semantics.
                           </p>
                        </li>
                        <li>
                           <p>Restart media recovery on the standby:</p><pre class="pre codeblock"><code>SQL&gt; RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</code></pre></li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF__GUID-92326390-DCFC-482A-B254-03E7B9B56BC9">Performing Recovery When Flashback Is Not Enabled</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>Determine the affected PDB and PITR SCN. </span><div>
                           <p>The name of the PDB for which recovery was halted is shown in the <code class="codeph">ORA-39874</code> message and the PITR SCN is shown in the <code class="codeph">ORA-39873</code> message.
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>Close the standby database, if it is still open:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE CLOSE;
</pre></div>
                     </li>
                     <li class="stepexpand"><span>Restore the PDB data files:</span><div><pre class="oac_no_warn" dir="ltr">RMAN&gt; RESTORE PLUGGABLE DATABASE pdb1 UNTIL SCN 1437261;
</pre><p>The <code class="codeph">UNTIL</code> <code class="codeph">SCN</code> syntax allows RMAN to automatically choose a suitable backup to restore from. After the data files have been restored at the standby, restart MRP to continue applying the redo logs.
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>Restart media recovery on the standby:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; RECOVER MANAGED STANDBY DATABASE DISCONNECT;
</pre></div>
                     </li>
                  </ol>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-8D948A24-A3B7-4E4F-917A-00B047CF3CAF__GUID-8119C250-5269-41DF-8163-BF40F3E3AD7C">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../bradv/rman-performing-flashback-dbpitr.html#BRADV640" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about performing point-in-time recovery of PDBs
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>