<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Objects, Collections, and OPAQUE Types</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQLJ Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQLJ Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96458-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="type-support.html" title="Previous" type="text/html">
      <link rel="next" href="advanced-language-features.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JSQLJ">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="type-support.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="advanced-language-features.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Objects, Collections, and OPAQUE Types</li>
            </ol>
            <a id="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" name="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF"></a><a id="JSQLJ409"></a>
            
            <h2 id="JSQLJ-GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" class="sect2"><span class="enumeration_chapter">7 </span> Objects, Collections, and OPAQUE Types
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses how the Oracle SQLJ implementation supports user-defined SQL types. There is also a small section at the end regarding Oracle OPAQUE types.</p>
               <p>The chapter consists of the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-83FAE830-C137-413B-8654-5378A60A2E03">Oracle Objects and Collections</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E">Custom Java Classes</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B">User-Defined Types</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810">Strongly Typed Objects and References in SQLJ Executable Statements</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD">Strongly Typed Collections in SQLJ Executable Statements</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">Serialized Java Objects</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55">Weakly Typed Objects_ References_ and Collections</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4">Oracle OPAQUE Types</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ410"></a><div class="props_rev_3"><a id="GUID-83FAE830-C137-413B-8654-5378A60A2E03" name="GUID-83FAE830-C137-413B-8654-5378A60A2E03"></a><h3 id="JSQLJ-GUID-83FAE830-C137-413B-8654-5378A60A2E03" class="sect3">Oracle Objects and Collections</h3>
               <div>
                  <p>This section provides some background conceptual information about Oracle Database 12<span class="italic">c </span>Release 2 (12.2) objects and collections.
                  </p>
                  <div class="infoboxnotealso" id="GUID-83FAE830-C137-413B-8654-5378A60A2E03__GUID-31E81DE6-4FD3-495F-8C99-47989088638D">
                     <p class="notep1">See Also:</p>
                     <p><a href="../sqlrf/Database-Objects.html#SQLRF-GUID-31BE00A7-7FF9-41CB-852A-F1416912CA9E" target="_blank"><span class="italic">Oracle Database SQL Language Reference </span></a>and <a href="../adfns/sql-data-types.html#ADFNS-GUID-CCC643C7-88E1-421C-87DC-4353899FFB9E" target="_blank"><span class="italic">Oracle Database Development Guide</span></a>.
                     </p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-535092B2-B9CA-4978-A01E-6209609B579D">Overview of Objects and Collections</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7">Oracle Object Fundamentals</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300">Oracle Collection Fundamentals</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591">Object and Collection Data Types</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ412"></a><a id="JSQLJ413"></a><a id="JSQLJ411"></a><div class="props_rev_3"><a id="GUID-535092B2-B9CA-4978-A01E-6209609B579D" name="GUID-535092B2-B9CA-4978-A01E-6209609B579D"></a><h4 id="JSQLJ-GUID-535092B2-B9CA-4978-A01E-6209609B579D" class="sect4">Overview of Objects and Collections</h4>
                  <div>
                     <p>The Oracle SQLJ implementation supports user-defined SQL object types, which are composite data structures, related SQL object reference types, and user-defined SQL collection types. Oracle objects and collections are composite data structures consisting of individual data elements.</p>
                     <p>The Oracle SQLJ implementation supports either strongly typed or weakly typed Java representations of object types, reference types, and collection types to use in iterators or host expressions. Strongly typed representations use a custom Java class that maps to a particular object type, reference type, or collection type and must implement either the Java Database Connectivity (JDBC) 2.0 standard <code class="codeph">java.sql.SQLData</code> interface, for object types only, or the Oracle <code class="codeph">oracle.sql.ORAData</code> interface.
                     </p>
                     <p>The term stron<a id="d32224e172" class="indexterm-anchor"></a><a id="d32224e176" class="indexterm-anchor"></a>gly typed is used where a particular Java type is associated with a particular SQL named type or user-defined type. For example, if there is a <code class="codeph">PERSON</code> type, then a corresponding <code class="codeph">Person</code> Java class will be associated with it.
                     </p>
                     <p>Weakly typed representations use <code class="codeph">oracle.sql.STRUCT</code> for objects, <code class="codeph">oracle.sql.REF</code> for object references, or <code class="codeph">oracle.sql.ARRAY</code> for collections. Alternatively, you can use standard <code class="codeph">java.sql.Struct</code>, <code class="codeph">java.sql.Ref</code>, or <code class="codeph">java.sql.Array</code> objects in a weakly typed scenario.
                     </p>
                     <p>The term wea<a id="d32224e208" class="indexterm-anchor"></a><a id="d32224e212" class="indexterm-anchor"></a>kly typed is used where a Java type is used in a generic way and can map to multiple SQL named types. The Java class or interface has no special information particular to any SQL type. This is the case for the <code class="codeph">oracle.sql.STRUCT</code>, <code class="codeph">oracle.sql.REF</code>, and <code class="codeph">oracle.sql.ARRAY</code> types and the <code class="codeph">java.sql.Struct</code>, <code class="codeph">java.sql.Ref</code>, and <code class="codeph">java.sql.Array</code> types.
                     </p>
                     <p>Note that using Oracle extensions in your code requires the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use one of Oracle JDBC drivers.</p>
                        </li>
                        <li>
                           <p>Use default Oracle-specific code generation or, for ISO code generation, customize the profiles appropriately. For Oracle-specific generated code, no profiles are produced so customization is not applicable. Oracle JDBC application programming interfaces (APIs) are called directly through the generated Java code.</p>
                           <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C9E90461-A7B3-4278-A8AD-B2FE60B33C61">
                              <p class="notep1">Note:</p>
                              <p>Oracle recommends the use of the default customizer, <code class="codeph">oracle.sqlj.runtime.util.OraCustomizer</code>.
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>Use Oracle SQLJ run time when your application runs. Oracle SQLJ run time and an Oracle JDBC driver are required whenever you use Oracle customizer, even if you do not actually use Oracle extensions in your code.</p>
                        </li>
                     </ul>
                     <p>For Oracle-specific semantics-checking, you must use an appropriate checker. The default checker, <code class="codeph">oracle.sqlj.checker.OracleChecker</code>, acts as a front end and will run the appropriate checker based on your environment. This will be one of the Oracle specific checkers if you are using an Oracle JDBC driver.
                     </p>
                     <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C034D024-E023-4F6E-B390-2E5FB82C96A3">
                        <p class="notep1">Note:</p>
                        <p>Oracle-specific types for Oracle objects and collections are included in the <code class="codeph">oracle.sql</code> package.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-3CF36A38-7E2C-4A91-A180-87CD56E3DA39">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">Connection Options</a>"</span> and <span class="q">"<a href="translator-command-line-and-options.html#GUID-ED7DD3DE-CA91-4085-82B2-D07EC9B15FB6">Semantics-Checking and Offline-Parsing Options</a>"</span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-E505B2A1-D691-4E7A-9D48-BE09505E01FE">Custom Java Class Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>This chapter primarily discusses the use of custom Java classes with user-defined types. However, classes implementing <code class="codeph">ORAData</code> can be used for other Oracle SQL types as well. A class implementing <code class="codeph">ORAData</code> can be used to perform any kind of desired processing or conversion in the course of transferring data between SQL and Java.
                              </p>
                              <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-F5985ACE-4494-448B-9928-9B5E963A902A">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">Additional Uses for ORAData Implementations</a>"</span></p>
                              </div>
                           </li>
                           <li>
                              <p>The <code class="codeph">SQLData</code> interface is intended only for custom object classes. The <code class="codeph">ORAData</code> interface can be used for any custom Java class.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-D84FE6D8-6B4A-4ABF-9A2A-F16EF64ED31F">Terminology Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>User-defined SQL object types and user-defined SQL collection types are referred to as user-defined types (UDTs).</p>
                           </li>
                           <li>
                              <p>Custom Java classes for objects, references, and collections are referred to as custom object classes, custom reference classes, and custom collection classes, respectively.</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-AC170A44-CEEC-40FA-8CB0-A0CB783A1A1D">
                           <p class="notep1">See Also:</p>
                           <p><a href="../adobj/introduction-to-oracle-objects.html#ADOBJ-GUID-7667A5B4-22E3-465F-9F7B-7043A9525DD2" target="_blank"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for general information about Oracle object features and functionality
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ414"></a><div class="props_rev_3"><a id="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" name="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7"></a><h4 id="JSQLJ-GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" class="sect4">Oracle Object Fundamentals</h4>
                  <div>
                     <p>The Oracle SQL objects are composite data structures that group related data items, such as facts about each employee, into a single data unit. An object type is functionally similar to a Java class. You can populate and use any number of individual objects of a given object type, just as you can instantiate and use individual objects of a Java class.</p>
                     <p>For example, you can define an object type <code class="codeph">EMPLOYEE</code> that has the attributes <code class="codeph">name</code> of type <code class="codeph">CHAR</code>, <code class="codeph">address</code> of type <code class="codeph">CHAR</code>, <code class="codeph">phonenumber</code> of type <code class="codeph">CHAR</code>, and <code class="codeph">employeenumber</code> of type <code class="codeph">NUMBER</code>. 
                     </p>
                     <p>Oracle objects can also have methods, or stored procedures, associated with the object type. These methods can be either static methods or instance methods and can be implemented either in PL/SQL or Java. Their signatures can include any number of input, output, or input-output parameters. All this depends on how they are initially defined</p>
                  </div>
               </div><a id="JSQLJ415"></a><div class="props_rev_3"><a id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" name="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300"></a><h4 id="JSQLJ-GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" class="sect4">Oracle Collection Fundamentals</h4>
                  <div>
                     <p>There are two categories of Oracle SQL collections:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a id="d32224e422" class="indexterm-anchor"></a>Variable-length arrays (VARRAY types)
                           </p>
                        </li>
                        <li>
                           <p><a id="d32224e429" class="indexterm-anchor"></a>Nested tables (TABLE types)
                           </p>
                        </li>
                     </ul>
                     <p>Both categories are one-dimensional, although the elements can be complex object types. VARRAY types are used for one-dimensional arrays, and nested table types are used for single-column tables within an outer table. A variable of any VARRAY type can be referred to as a VARRAY. A variable of any nested table type can be referred to as a nested table.</p>
                     <p>A VARRAY, as with any array, is an ordered set of data elements, with each element having an index and all elements being of the same data type. The size of a VARRAY refers to the maximum number of elements. Oracle VARRAYs, as indicated by their name, are of variable size, but the maximum size of any particular VARRAY type must be specified when the VARRAY type is declared.</p>
                     <p>A nested table is an unordered set of elements. Nested table elements within a table can themselves be queried in SQL. A nested table, as with any table, is not created with any particular number of rows. This is determined dynamically.</p>
                     <div class="infoboxnote" id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300__GUID-B67BEE30-0D52-4C1C-BD8E-7008B83D1D4E">
                        <p class="notep1">Note:</p>
                        <p>The elements in a VARRAY or the rows in a nested table can be of a user-defined object type, and VARRAY and nested table types can be used for attributes in a user-defined object type. Oracle Database 12<span class="italic">c </span>Release 2 (12.2) supports nesting of collection types. The elements of a VARRAY or rows of a nested table can be of another VARRAY or nested table type, or these elements can be of a user-defined object type that has VARRAY or nested table attributes.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ416"></a><div class="props_rev_3"><a id="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" name="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591"></a><h4 id="JSQLJ-GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" class="sect4">Object and Collection Data Types</h4>
                  <div>
                     <p>In Oracle Database 12<span class="italic">c </span>Release 2 (12.2), user-defined object and collection definitions function as SQL data type definitions. You can use these data types, as with any other data type, in defining table columns, SQL object attributes, and stored procedure or function parameters. In addition, once you have defined an object type, the related object reference type can be used as any other SQL reference type.
                     </p>
                     <p>For example, consider the <code class="codeph">EMPLOYEE</code> Oracle object described in the preceding section. Once you have defined this object, it becomes an Oracle data type. You can have a table column of type <code class="codeph">EMPLOYEE</code> just as you can have a table column of type <code class="codeph">NUMBER</code>. Each row in an <code class="codeph">EMPLOYEE</code> column contains a complete <code class="codeph">EMPLOYEE</code> object. You can also have a column type of <code class="codeph">REF EMPLOYEE</code>, consisting of references to <code class="codeph">EMPLOYEE</code> objects.
                     </p>
                     <p>Similarly, you can define a variable-length array <code class="codeph">MYVARR</code> as <code class="codeph">VARRAY(10)</code> of <code class="codeph">NUMBER</code> and a nested table <code class="codeph">NTBL</code> of <code class="codeph">CHAR(20)</code>. The <code class="codeph">MYVARR</code> and <code class="codeph">NTBL</code> collection types become Oracle data types, and you can have table columns of either type. Each row of a <code class="codeph">MYVARR</code> column consists of an array of up to 10 numbers. Each row of an <code class="codeph">NTBL</code> column consists of 20 characters.
                     </p>
                  </div>
               </div>
            </div><a id="JSQLJ417"></a><div class="props_rev_3"><a id="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" name="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E"></a><h3 id="JSQLJ-GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" class="sect3">Custom Java Classes</h3>
               <div>
                  <p>Custom Java classes are first-class types that you can use to read from and write to user-defined SQL types transparently. The purpose of custom Java classes is to provide a way to convert data between SQL and Java and make the data accessible, particularly in supporting objects and collections or if you want to perform custom data conversions.</p>
                  <p>It is generally advisable to provide custom Java classes for all user-defined types that you use in a SQLJ application. Oracle JDBC driver will use instances of these classes in converting data, which is more convenient and less error-prone than using the weakly typed <code class="codeph">oracle.sql.STRUCT</code>, <code class="codeph">oracle.sql.REF</code>, and <code class="codeph">oracle.sql.ARRAY</code> classes.
                  </p>
                  <p>To be used in SQLJ iterators or host expressions, a custom Java class must implement either the <code class="codeph">oracle.sql.ORAData</code> and <code class="codeph">oracle.sql.ORADataFactory</code> interfaces or the standard <code class="codeph">java.sql.SQLData</code> interface. This section provides an overview of these interfaces and custom Java class functionality, covering the following topics:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F">Custom Java Class Interface Specifications</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80">Custom Java Class Support for Object Methods</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D">Custom Java Class Requirements</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-700E14BF-E4F8-4A36-9092-05000452C60B">Compiling Custom Java Classes</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7">Reading and Writing Custom Data</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">Additional Uses for ORAData Implementations</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ419"></a><a id="JSQLJ421"></a><a id="JSQLJ418"></a><div class="props_rev_3"><a id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" name="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F"></a><h4 id="JSQLJ-GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" class="sect4">Custom Java Class Interface Specifications</h4>
                  <div>
                     <div class="section">
                        <p>This section discusses specifications of the <code class="codeph">ORAData</code> and <code class="codeph">ORADataFactory</code> interfaces and the standard <code class="codeph">SQLData</code> interface. 
                        </p>
                        <p>Oracle Database 12<span class="italic">c </span>Release 2 (12.2) includes a set of APIs for Oracle-specific custom Java class functionality for user-defined types: <code class="codeph">oracle.sql.ORAData</code> and <code class="codeph">oracle.sql.ORADataFactory</code>. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-755AD7E5-59DF-4D06-BA3B-81EED07E7AD6">ORAData and ORADataFactory Specifications</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle provides the <code class="codeph">oracle.sql.ORAData</code> interface and the related <code class="codeph">oracle.sql.ORADataFactory</code> interface to use in mapping and converting Oracle object types, reference types, and collection types to custom Java classes.
                        </p>
                        <p>Data is sent or retrieved in the form of an <code class="codeph">oracle.sql.Datum</code> object, with the underlying data being in the format of the appropriate <code class="codeph">oracle.sql.Datum</code> subclass, such as <code class="codeph">oracle.sql.STRUCT</code>. This data is still in its SQL format. The <code class="codeph">oracle.sql.Datum</code> object is just a wrapper.
                        </p>
                        <div class="infoboxnotealso" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-1198871C-6658-4BEC-AA49-199C99152250">
                           <p class="notep1">See Also:</p>
                           <p><a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-5905674A-A045-40B1-96DE-726761517D50" target="_blank"><span><cite>Oracle Database JDBC Developerâ€™s Guide</cite></span></a></p>
                        </div>
                        <p>The <code class="codeph">ORAData</code> interface specifies a <code class="codeph">toDatum()</code> method for data conversion from Java format to SQL format. This method takes as input your connection object and converts data to the appropriate <code class="codeph">oracle.sql.*</code> representation. The connection object is necessary so that the JDBC driver can perform appropriate type checking and type conversions at run time. The <code class="codeph">ORAData</code> and <code class="codeph">toDatum()</code> specification is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">interface oracle.sql.ORAData
{
   oracle.sql.Datum toDatum(java.sql.Connection c) throws SQLException;
}
</pre><p>The <code class="codeph">ORADataFactory</code> interface specifies a <code class="codeph">create()</code> method that constructs instances of your custom Java class, converting from SQL format to Java format. This method takes as input a <code class="codeph">Datum</code> object containing the data and a type code, such as <code class="codeph">OracleTypes.RAW</code>, indicating the SQL type of the underlying data. It returns an object of your custom Java class, which implements the <code class="codeph">ORAData</code> interface. This object receives its data from the <code class="codeph">Datum</code> object that was input. The <code class="codeph">ORADataFactory</code> and <code class="codeph">create()</code> specification is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">interface oracle.sql.ORADataFactory
{
   oracle.sql.ORAData create(oracle.sql.Datum d, int sqlType) 
                      throws SQLException;
}
</pre><p>To complete the relationship between the <code class="codeph">ORAData</code> and <code class="codeph">ORADataFactory</code> interfaces, you must implement a static <code class="codeph">getORADataFactory()</code> method in any custom Java class that implements the <code class="codeph">ORAData</code> interface. This method returns an object that implements the <code class="codeph">ORADataFactory</code> interface and that, therefore, can be used to create instances of your custom Java class. This returned object can itself be an instance of your custom Java class, and its <code class="codeph">create()</code> method is used by Oracle JDBC driver to produce further instances of your custom Java class, as necessary. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-AB441F71-EEC4-404E-8AA6-FA0399EDF7E4">SQLData Specification</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Standard JDBC 2.0 supplies the <code class="codeph">java.sql.SQLData</code> interface to use in mapping and converting structured object types to Java classes. This interface is intended for mapping structured object types only, not object references, collections or arrays, or other SQL types.
                        </p>
                        <p>The <code class="codeph">SQLData</code> interface is a JDBC 2.0 standard, specifying a <code class="codeph">readSQL()</code> method to read data into a Java object and a <code class="codeph">writeSQL()</code> method to write to the database from a Java object.
                        </p>
                        <p>For additional information about standard <code class="codeph">SQLData</code> functionality, refer to the Sun Microsystems JDBC 2.0 or later API specification.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ422"></a><div class="props_rev_3"><a id="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" name="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80"></a><h4 id="JSQLJ-GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" class="sect4">Custom Java Class Support for Object Methods</h4>
                  <div>
                     <p>Methods of Oracle objects can be invoked from custom Java class wrappers. Whether the underlying stored procedure is written in PL/SQL or is written in Java and published to SQL is invisible to the user.</p>
                     <p>A Java wrapper method used to invoke a server method requires a connection to communicate with the server. The connection object can be provided as an explicit parameter or can be associated in some other way. For example, as an attribute of your custom Java class. If the connection object used by the wrapper method is a nonstatic attribute, then the wrapper method must be an instance method of the custom Java class in order to have access to the connection.</p>
                     <p>There are also issues regarding output and input-output parameters in methods of Oracle objects. If a stored procedure, that is, a SQL object method, modifies the internal state of one of its arguments, then the actual argument passed to the stored procedure is modified. In Java this is not possible. When a JDBC output parameter is returned from a stored procedure call, it must be stored in a newly created object. The original object identity is lost.</p>
                     <p>One way to return an output or input-output parameter to the caller is to pass the parameter as an element of an array. If the parameter is input-output, then the wrapper method takes the array element as input. After processing, the wrapper assigns the output to the array element.</p>
                  </div>
               </div><a id="JSQLJ424"></a><a id="JSQLJ425"></a><a id="JSQLJ426"></a><a id="JSQLJ427"></a><a id="JSQLJ423"></a><div class="props_rev_3"><a id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" name="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D"></a><h4 id="JSQLJ-GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" class="sect4">Custom Java Class Requirements</h4>
                  <div>
                     <div class="section">
                        <p>Custom Java classes must satisfy certain requirements to be recognized by Oracle SQLJ translator as valid host variable types and to enable type-checking by the translator.</p>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-11C55F73-1AA9-4697-8B54-BDA0EA01B7A5">
                           <p class="notep1">Note:</p>
                           <p>Custom Java classes for user-defined types are often referred to in this manual as "wrapper classes".</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005846">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-6F102C1C-7597-47AE-96DB-651AD0D4E593">Oracle Requirements for Classes Implementing ORAData</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle requirements for <code class="codeph">ORAData</code> implementations are primarily the same for any kind of custom Java class, but vary slightly depending on whether the class is for mapping to objects, object references, collections, or some other SQL type.
                        </p>
                        <p>These requirements are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The class implements the <code class="codeph">oracle.sql.ORAData</code> interface.
                              </p>
                           </li>
                           <li>
                              <p>The class implements the <code class="codeph">getORADataFactory()</code> method that returns an <code class="codeph">oracle.sql.ORADataFactory</code> object. The method signature is as follows:
                              </p><pre class="oac_no_warn" dir="ltr">public static oracle.sql.ORADataFactory getORADataFactory();
</pre></li>
                           <li>
                              <p>The class has a <code class="codeph">String</code> constant, <code class="codeph">_SQL_TYPECODE</code>, initialized to the <code class="codeph">oracle.jdbc.OracleTypes</code> type code of the <code class="codeph">Datum</code> subclass instance that <code class="codeph">toDatum()</code> returns. The type code is:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>For custom object classes:</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes.STRUCT;
</pre></li>
                                 <li>
                                    <p>For custom reference classes:</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes.REF;
</pre></li>
                                 <li>
                                    <p>For custom collection classes:</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes.ARRAY;
</pre></li>
                              </ul>
                              <p>For other uses, some other type code might be appropriate. For example, for using a custom Java class to serialize and deserialize Java objects into or out of <code class="codeph">RAW</code> fields, a <code class="codeph">_SQL_TYPECODE</code> of <code class="codeph">OracleTypes.RAW</code> is used.
                              </p>
                              <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-4E064F67-09E6-4981-A253-435722E9E50E">
                                 <p class="notep1">Note:</p>
                                 <p>The <code class="codeph">OracleTypes</code> class simply defines a type code, which is an integer constant, for each Oracle data type. For standard SQL types, the <code class="codeph">OracleTypes</code> entry is identical to the entry in the standard <code class="codeph">java.sql.Types</code> type definitions class.
                                 </p>
                              </div>
                              <div class="infoboxnotealso" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-0CCC42C7-3E76-4C14-8B6E-ED26B8E63F89">
                                 <p class="notep1">See Also:</p>
                                 <p><span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">Serialized Java Objects</a>"</span></p>
                              </div>
                           </li>
                           <li>
                              <p>For custom Java classes with <code class="codeph">_SQL_TYPECODE</code> of <code class="codeph">STRUCT</code>, <code class="codeph">REF</code>, or <code class="codeph">ARRAY</code>, that is, for custom Java classes that represent objects, object references, or collections, the class has a constant that indicates the relevant user-defined type name. This is as follows:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Custom object classes and custom collection classes must have a <code class="codeph">String</code> constant, <code class="codeph">_SQL_NAME</code>, initialized to the SQL name you declared for the user-defined type, as follows:
                                    </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = <span class="italic">UDT name</span>;
</pre><p>For example, the custom object class for a user-defined <code class="codeph">PERSON</code> object will have the constant:
                                    </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = "PERSON";
</pre><p>The same can be specified along with the schema, if appropriate, as follows:</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = "HR.PERSON";
</pre><p>The custom collection class for a collection of <code class="codeph">PERSON</code> objects, which you have declared as <code class="codeph">PERSON_ARRAY</code>, will have the constant:
                                    </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = "PERSON_ARRAY";
</pre></li>
                                 <li>
                                    <p>Custom reference classes must have a <code class="codeph">String</code> constant, <code class="codeph">_SQL_BASETYPE</code>, initialized to the SQL name you declared for the user-defined type being referenced, as follows:
                                    </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE = <span class="italic">UDT name</span>;
</pre><p>The custom reference class for <code class="codeph">PERSON</code> references will have the constant:
                                    </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE = "PERSON";
</pre><p>For other <code class="codeph">ORAData</code> uses, specifying a UDT name is not applicable.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>Keep in mind the following usage notes:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A collection type name reflects the collection type, not the base type. For example, if you have declared a VARRAY or nested table type, <code class="codeph">PERSON_ARRAY</code>, for <code class="codeph">PERSON</code> objects, then the name of the collection type that you specify for the <code class="codeph">_SQL_NAME</code> entry is <code class="codeph">PERSON_ARRAY</code>, not <code class="codeph">PERSON</code>.
                              </p>
                           </li>
                           <li>
                              <p>When specifying the SQL type in a <code class="codeph">_SQL_NAME</code> field, if the SQL type was declared in a case-se<a id="d32224e1101" class="indexterm-anchor"></a>nsitive way (in quotes), then you must specify the SQL name exactly as it was declared, such as <code class="codeph">CaseSensitive</code> or <code class="codeph">HR.CaseSensitive</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005901">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-066060FB-A06B-4EBB-9A1C-72989676D075">Requirements for Classes Implementing SQLData</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The ISO SQLJ standard outlines requirements for type map definitions for classes implementing the <code class="codeph">SQLData</code> interface. Alternatively, <code class="codeph">SQLData</code> wrapper classes can identify associated SQL object types through the <code class="codeph">public static final</code> fields.
                        </p>
                        <p>Be aware of the following important points:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Whether you use a type map or use alternative (nonstandard) <code class="codeph">public static final</code> fields to specify mappings, you must be consistent in your approach. Either use a type map that specifies all relevant mappings so that you do not require the <code class="codeph">public static final</code> fields, or do not use a type map at all and specify all mappings through the <code class="codeph">public static final</code> fields.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code>, unlike <code class="codeph">ORAData</code>, is for mapping structured object types only. It is not for object references, collections or arrays, or any other SQL types. If you are not using <code class="codeph">ORAData</code>, then your only choices for mapping object references and collections are the weak <code class="codeph">java.sql.Ref</code> and <code class="codeph">java.sql.Array</code> types, respectively, or <code class="codeph">oracle.sql.REF</code> and <code class="codeph">oracle.sql.ARRAY</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code> implementations require a Java Development Kit (JDK) 1.4.x or 1.5.x environment.
                              </p>
                           </li>
                           <li>
                              <p>When specifying the mapping from a SQL type to a Java type, if the SQL type was declared in a case-se<a id="d32224e1172" class="indexterm-anchor"></a>nsitive way, then you must specify the SQL name exactly as it was declared, such as <code class="codeph">CaseSensitive</code> or <code class="codeph">HR.CaseSensitive</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-43CB770B-3D70-4FF9-9429-F42104B9B158">Mapping Specified in Type Map Resource</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>First, consider the mapping representation according to the ISO SQLJ standard. Assume that <code class="codeph">Address</code>, <code class="codeph">pack.Person</code>, and <code class="codeph">pack.Manager.InnerPM</code>, where <code class="codeph">InnerPM</code> is an inner class of <code class="codeph">Manager</code>, are three wrapper classes that implement <code class="codeph">java.sql.SQLData</code>.
                        </p>
                        <p>Then, you need to consider the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must use these classes only in statements that use explicit connection context instances of a declared connection context type. For example, assuming that this type is called <code class="codeph">SDContext</code>:
                              </p><pre class="oac_no_warn" dir="ltr">Address               a =...;
pack.Person           p =...;
pack.Manager.InnerPM pm =...;
SDContext ctx = new SDContext(url,user,pwd,false);
#sql [ctx] { ... :a ... :p ... :pm ... };
</pre></li>
                           <li>
                              <p>The connection context type must have been declared using the <code class="codeph">with</code> attribute <code class="codeph">typeMap</code> that specifies an associated class implementing <code class="codeph">java.util.PropertyResourceBundle</code>. In the preceding example, <code class="codeph">SDContext</code> may be declared as follows:
                              </p><pre class="oac_no_warn" dir="ltr">#sql public static context SDContext with (typeMap="SDMap");
</pre></li>
                           <li>
                              <p>The type map resource must provide the mapping from SQL object types to corresponding Java classes that implement the <code class="codeph">java.sql.SQLData</code> interface. This mapping is specified with entries of the following form:
                              </p><pre class="oac_no_warn" dir="ltr">class.java_class_name=STRUCT sql_type_name
</pre><p>The <code class="codeph">STRUCT</code> keyword can also be omitted. In the example, the <code class="codeph">SDMap.properties</code> resource file may contain the following entries:
                              </p><pre class="oac_no_warn" dir="ltr">class.Address=STRUCT HR.ADDRESS
class.pack.Person=PERSON
class.pack.Manager$InnerPM=STRUCT PRODUCT_MANAGER
</pre><p>Although the period (.) separates package and class name, you <span class="italic">must</span> use the dollar sign ($) to separate an inner class name.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-E739A417-D3D5-4D36-9A46-3C5EA7BE37CE">
                           <p class="notep1">Note:</p>
                           <p>If you used the default Oracle-specific code generation in this example, then any iterator that is used for a statement whose context type is <code class="codeph">SDContext</code> must also have been declared with the same associated type map, <code class="codeph">SDMap</code>, such as in the following example:
                           </p><pre class="oac_no_warn" dir="ltr">#sql public static iterator SDIter with (typeMap="SDMap");
...
SDContext sdctx = ...
SDIter sditer;
#sql [sdctx] sditer = { SELECT ...};
</pre><p>This is to ensure that proper code is generated for the iterator class.</p>
                        </div>
                        <p>This mechanism of specifying mappings in a type map resource is more complicated than the nonstandard alternative. Also, it is not possible to associate a type map resource with the default connection context. The advantage is that all the mapping information is placed in a single location, the type map resource. This means that the type mapping in an already compiled application can be easily adjusted at a later time, for example, to accommodate new SQL types and Java wrappers in an expanding SQL-Java type hierarchy.</p>
                        <p>Be aware of the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must employ the SQLJ <code class="codeph">runtime12</code> or <code class="codeph">runtime12ee</code> library to use this feature. Type maps are represented as <code class="codeph">java.util.Map</code> objects. These are exposed in the SQLJ run-time API and, therefore, <span class="italic">cannot</span> be supported by the generic run-time library.
                              </p>
                           </li>
                           <li>
                              <p>You must use Oracle SQLJ run time and Oracle-specific code generation or profile customization if your <code class="codeph">SQLData</code> wrapper classes occur as <code class="codeph">OUT</code> or <code class="codeph">INOUT</code> parameters in SQLJ statements. This is because the SQL type of such parameters is required for <code class="codeph">registerOutParameter()</code> by Oracle JDBC driver. Also, for <code class="codeph">OUT</code> parameter type registration, the SQL type is "frozen in" by the type map in effect during translation.
                              </p>
                           </li>
                           <li>
                              <p>The SQLJ type map is independent of any JDBC type map you may be using on the underlying connection. Thus, you must be careful when you are mixing SQLJ and JDBC code if both use <code class="codeph">SQLData</code> wrappers. However, you can easily extract the type map in effect on a given SQLJ connection context:
                              </p><pre class="oac_no_warn" dir="ltr">ctx.getTypeMap();</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-FEAB3CB0-F57A-4DD3-B257-42E3D6810583">Mapping Specified in Static Field of Wrapper Class</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>A class that implements <code class="codeph">SQLData</code> can satisfy the following nonstandard requirement:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The Java class declares the <code class="codeph">String</code> constant <code class="codeph">_SQL_NAME</code>, which defines the name of the SQL type that is being wrapped by the Java class. In the example, the <code class="codeph">Address</code> class would have the following field declaration:
                              </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME="HR.ADDRESS";
</pre><p>The following declaration would be in <code class="codeph">pack.Person</code>:
                              </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME="PERSON";
</pre><p>And the <code class="codeph">pack.Manager.InnerPM</code> class would have the following:
                              </p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME="PRODUCT_MANAGER";
</pre></li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-30647C5B-96B2-47B1-BEDF-6A9FC67D9CD9">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If a class that implements the <code class="codeph">_SQL_NAME</code> field is used in a SQLJ statement with an explicit connection context type and associated type map, then that type map is used and the <code class="codeph">_SQL_NAME</code> field is ignored. This simplifies migration of existing SQLJ programs to the ISO SQLJ standard.
                                 </p>
                              </li>
                              <li>
                                 <p>The static SQL-Java type correspondence specified in the <code class="codeph">_SQL_NAME</code> field is independent from any JDBC type map you may be using on the underlying connection. Thus, you must be careful when you are mixing SQLJ and JDBC code if both use <code class="codeph">SQLData</code> wrappers.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ428"></a><div class="props_rev_3"><a id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B" name="GUID-700E14BF-E4F8-4A36-9092-05000452C60B"></a><h4 id="JSQLJ-GUID-700E14BF-E4F8-4A36-9092-05000452C60B" class="sect4">Compiling Custom Java Classes</h4>
                  <div>
                     <div class="section">
                        <p>You can include any <code class="codeph">.java</code> files for your custom Java classes, whether <code class="codeph">ORAData</code> or <code class="codeph">SQLData</code> implementations, on the SQLJ command line together with the <code class="codeph">.sqlj</code> files for your application. However, this is not necessary if the SQLJ <code class="codeph">-checksource</code> flag is set to <code class="codeph">true</code>, which is the default, and your classpath includes the directory where the custom Java source is located.
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-D2BCD3EE-5E8D-49F0-9698-BDDA15D07FFA">
                           <p class="notep1">Note:</p>
                           <p>This discussion assumes you are creating <code class="codeph">.java</code> files for your custom objects and collections, not <code class="codeph">.sqlj</code> files. Any <code class="codeph">.sqlj</code> files must be included in the SQLJ command line.
                           </p>
                        </div>
                        <p>For example, if <code class="codeph">ObjectDemo.sqlj</code> uses the <code class="codeph">ADDRESS</code> and <code class="codeph">PERSON</code> Oracle object types and you have produced custom Java classes for these objects, then you can run SQLJ as follows.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If <code class="codeph">-checksource=true</code> and the classpath includes the custom Java source location:
                              </p><pre class="oac_no_warn" dir="ltr">% sqlj ObjectDemo.sqlj
</pre></li>
                           <li>
                              <p>If <code class="codeph">-checksource=false</code> (this is a single wraparound line):
                              </p><pre class="oac_no_warn" dir="ltr">% sqlj ObjectDemo.sqlj Address.java AddressRef.java Person.java PersonRef.java
</pre></li>
                        </ul>
                        <p>You also have the choice of using your Java compiler to compile custom <code class="codeph">.java</code> source files directly. If you do this, then you must do it prior to translating <code class="codeph">.sqlj</code> files.
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-03FD8712-CC7C-4A68-B275-EE9BB22F03B5">
                           <p class="notep1">Note:</p>
                           <p>Because <code class="codeph">ORAData</code> implementations rely on Oracle-specific features, SQLJ will report numerous portability warnings if you do not use the <code class="codeph">-warn=noportable</code> translator portability setting, which is the default.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ429"></a><div class="props_rev_3"><a id="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" name="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7"></a><h4 id="JSQLJ-GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" class="sect4">Reading and Writing Custom Data</h4>
                  <div>
                     <div class="section">
                        <p>Through the use of custom Java class instances, the Oracle SQLJ and JDBC implementations allow you to read and write user-defined types as though they are built-in types. Exactly how this is accomplished is transparent to the user.</p>
                        <p>For the mechanics of how data is read and written, for both <code class="codeph">ORAData</code> implementations and <code class="codeph">SQLData</code> implementations, refer to the<a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" target="_blank"><span class="italic"> Oracle Database JDBC Developer's Guide</span></a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ431"></a><a id="JSQLJ430"></a><div class="props_rev_3"><a id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" name="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3"></a><h4 id="JSQLJ-GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" class="sect4">Additional Uses for ORAData Implementations</h4>
                  <div>
                     <div class="section">
                        <p>To this point, discussion of custom Java classes has been for use as one of the following.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Wrappers for SQL objects: custom object classes, for use with <code class="codeph">oracle.sql.STRUCT</code> instances
                              </p>
                           </li>
                           <li>
                              <p>Wrappers for SQL references: custom reference classes, for use with <code class="codeph">oracle.sql.REF</code> instances
                              </p>
                           </li>
                           <li>
                              <p>Wrappers for SQL collections: custom collection classes, for use with <code class="codeph">oracle.sql.ARRAY</code> instances
                              </p>
                           </li>
                        </ul>
                        <p>It might be useful, however, to provide custom Java classes to wrap other <code class="codeph">oracle.sql.*</code> types as well, for customized conversions or processing. You can accomplish this with classes that implement <code class="codeph">ORAData</code>, but not <code class="codeph">SQLData</code>, as in the following examples:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Perform encryption and decryption or validation of data.</p>
                           </li>
                           <li>
                              <p>Perform logging of values that have been read or are being written.</p>
                           </li>
                           <li>
                              <p>Parse character columns, such as character fields containing URL information, into smaller components.</p>
                           </li>
                           <li>
                              <p>Map character strings into numeric constants.</p>
                           </li>
                           <li>
                              <p>Map data into more desirable Java formats, such as mapping a <code class="codeph">DATE</code> field to <code class="codeph">java.util.Date</code> format.
                              </p>
                           </li>
                           <li>
                              <p>Customize data representation, for example, data in a table column is in feet, but you want it represented in meters after it is selected.</p>
                           </li>
                           <li>
                              <p>Serialize and deserialize Java objects, for example, into or out of <code class="codeph">RAW</code> fields.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D6E68D4B-71B8-4068-BAE0-1BBBB741C629">
                           <p class="notep1">Note:</p>
                           <p>This sort of functionality is not possible through the <code class="codeph">SQLData</code> interface, as <code class="codeph">SQLData</code> implementations can wrap only structured object types.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-02339C2A-8772-490B-9FCC-DBD04CE1050D">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">Serialized Java Objects</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D49D802B-B373-4078-8EB6-1EB63B54EDD0">General Use of ORAData: BetterDate.java</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example shows a class that implements the <code class="codeph">ORAData</code> interface to provide a customized representation of Java dates and can be used instead of <code class="codeph">java.sql.Date</code>.
                        </p>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-9395F43C-FEE6-4060-A640-D4D3FC5EE3AC">
                           <p class="notep1">Note:</p>
                           <p>This is not a complete application. There is no <code class="codeph">main()</code> method.
                           </p>
                        </div><pre class="oac_no_warn" dir="ltr">import java.util.Date;
import oracle.sql.ORAData;
import oracle.sql.DATE;
import oracle.sql.ORADataFactory;
import oracle.jdbc.OracleTypes;

// a Date class customized for user's preferences:
//      - months are numbers 1..12, not 0..11
//      - years are referred to through four-digit numbers, not two.

public class BetterDate extends java.util.Date
             implements ORAData, ORADataFactory {
  public static final int _SQL_TYPECODE = OracleTypes.DATE;
  
  String[]monthNames={"JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                      "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
  String[]toDigit={"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};

  static final BetterDate _BetterDateFactory = new BetterDate();

  public static ORADataFactory getORADataFactory() { return _BetterDateFactory;}

  // the current time...
  public BetterDate() {
    super();
  }

  public oracle.sql.Datum toDatum(java.sql.Connection conn) {
    return new DATE(toSQLDate());
  }

  public oracle.sql.ORAData create(oracle.sql.Datum dat, int intx) {
    if (dat==null) return null;
    DATE DAT = ((DATE)dat);
    java.sql.Date jsd = DAT.dateValue();
    return new BetterDate(jsd);
  }
   
  public java.sql.Date toSQLDate() {
    java.sql.Date retval;
    retval = new java.sql.Date(this.getYear()-1900, this.getMonth()-1,
             this.getDate());
    return retval;
  }
  public BetterDate(java.sql.Date d) {
    this(d.getYear()+1900, d.getMonth()+1, d.getDate());
  }
  private static int [] deconstructString(String s) {
    int [] retval = new int[3];
    int y,m,d; char temp; int offset;
    StringBuffer sb = new StringBuffer(s);
    temp=sb.charAt(1);
    // figure the day of month
    if (temp &lt; '0' || temp &gt; '9') {
      m = sb.charAt(0)-'0';
      offset=2;
    } else {
      m = (sb.charAt(0)-'0')*10 + (temp-'0');
      offset=3;
    }

    // figure the month
    temp = sb.charAt(offset+1);
    if (temp &lt; '0' || temp &gt; '9') {
      d = sb.charAt(offset)-'0';
      offset+=2;
    } else {
      d = (sb.charAt(offset)-'0')*10 + (temp-'0');
      offset+=3;
    }

    // figure the year, which is either in the format "yy" or "yyyy"
    // (the former assumes the current century)
    if (sb.length() &lt;= (offset+2)) {
      y = (((new BetterDate()).getYear())/100)*100 +
          (sb.charAt(offset)- '0') * 10 +
          (sb.charAt(offset+1)- '0');
    } else {
      y = (sb.charAt(offset)- '0') * 1000 +
          (sb.charAt(offset+1)- '0') * 100 +
          (sb.charAt(offset+2)- '0') * 10 +
          (sb.charAt(offset+3)- '0');
    }
    retval[0]=y;
    retval[1]=m;
    retval[2]=d;
//    System.out.println("Constructing date from string as: "+d+"/"+m+"/"+y);
    return retval;
  }
  private BetterDate(int [] stuff) {
    this(stuff[0], stuff[1], stuff[2]);
  }
  // takes a string in the format: "mm-dd-yyyy" or "mm/dd/yyyy" or
  // "mm-dd-yy" or "mm/dd/yy" (which assumes the current century)
  public BetterDate(String s) {
    this(BetterDate.deconstructString(s));
  }

  // years are as '1990', months from 1..12 (unlike java.util.Date!), date
  // as '1' to '31' 
  public BetterDate(int year, int months, int date) {
    super(year-1900,months-1,date);
  }
  // returns "Date: dd-mon-yyyy"
  public String toString() { 
    int yr = getYear();
    return getDate()+"-"+monthNames[getMonth()-1]+"-"+
      toDigit[(yr/1000)%10] + 
      toDigit[(yr/100)%10] + 
      toDigit[(yr/10)%10] + 
      toDigit[yr%10];
//    return "Date: " + getDate() + "-"+getMonth()+"-"+(getYear()%100);
  }
  public BetterDate addDays(int i) {
    if (i==0) return this;
    return new BetterDate(getYear(), getMonth(), getDate()+i);
  }
  public BetterDate addMonths(int i) {
    if (i==0) return this;
    int yr=getYear();
    int mon=getMonth()+i;
    int dat=getDate();
    while(mon&lt;1) { 
      --yr;mon+=12;
    }
    return new BetterDate(yr, mon,dat);
  }
  // returns year as in 1996, 2007
  public int getYear() {
    return super.getYear()+1900;
  }
  // returns month as 1..12
  public int getMonth() {
    return super.getMonth()+1;
  }
  public boolean equals(BetterDate sd) {
    return (sd.getDate() == this.getDate() &amp;&amp;
            sd.getMonth() == this.getMonth() &amp;&amp;
            sd.getYear() == this.getYear());
  }
  // subtract the two dates; return the answer in whole years
  // uses the average length of a year, which is 365 days plus
  // a leap year every 4, except 100, except 400 years =
  // = 365 97/400 = 365.2425 days = 31,556,952 seconds
  public double minusInYears(BetterDate sd) {
    // the year (as defined in the preceding text) in milliseconds
    long yearInMillis = 31556952L;
    long diff = myUTC()-sd.myUTC();
    return (((double)diff/(double)yearInMillis)/1000.0);
  }
  public long myUTC() {
    return Date.UTC(getYear()-1900, getMonth()-1, getDate(),0,0,0);
  }
  
  // returns &lt;0 if this is earlier than sd
  // returns = if this == sd
  // else returns &gt;0
  public int compare(BetterDate sd) {
    if (getYear()!=sd.getYear()) {return getYear()-sd.getYear();}
    if (getMonth()!=sd.getMonth()) {return getMonth()-sd.getMonth();}
    return getDate()-sd.getDate();
  }
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ433"></a><a id="JSQLJ434"></a><a id="JSQLJ432"></a><div class="props_rev_3"><a id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" name="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B"></a><h3 id="JSQLJ-GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" class="sect3">User-Defined Types</h3>
               <div>
                  <div class="section">
                     <p>This section contains examples of creating and using user-defined object types and collection types in Oracle Database 12<span class="italic">c </span>Release 2 (12.2).
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006222">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-0999BCAD-A95F-4507-B369-D93708A039AD">Creating Object Types</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>SQL commands to create object types are of the following form:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS OBJECT
( 
  <span class="italic">attrname1    datatype1</span>,
  <span class="italic">attrname2    datatype2</span>,
  ...         ...
  <span class="italic">attrnameN    datatypeN</span>
);
</pre><p>Where <span class="italic"><code class="codeph">typename</code></span> is the desired name of your object type, <span class="italic"><code class="codeph">attrname1</code></span> through <span class="italic"><code class="codeph">attrnameN</code></span> are the desired attribute names, and <span class="italic"><code class="codeph">datatype1</code></span> through <span class="italic"><code class="codeph">datatypeN</code></span> are the attribute data types. 
                     </p>
                     <p>The remainder of this section provides an example of creating user-defined object types in Oracle Database 12<span class="italic">c </span>Release 1 (12.1). 
                     </p>
                     <p>In this example, the following items are created using SQL:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Two object types, <code class="codeph">PERSON</code> and <code class="codeph">ADDRESS</code></p>
                        </li>
                        <li>
                           <p>A typed table for <code class="codeph">PERSON</code> objects
                           </p>
                        </li>
                        <li>
                           <p>An <code class="codeph">EMPLOYEES</code> table that includes an <code class="codeph">ADDRESS</code> column and two columns of <code class="codeph">PERSON</code> references
                           </p>
                        </li>
                     </ul>
                     <p>The script for creating these items is as follows:</p><pre class="oac_no_warn" dir="ltr">/*** Using user-defined types (UDTs) in SQLJ ***/
/
/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/
/*** Create a typed table for PERSON objects ***/
CREATE TABLE persons OF PERSON
/
/*** Create a relational table with two columns that are REFs 
     to PERSON objects, as well as a column which is an Address ADT. ***/
CREATE TABLE  employees
( 
  empnumber            INTEGER PRIMARY KEY,
  person_data     REF  PERSON,
  manager         REF  PERSON,
  office_addr          ADDRESS,
  salary               NUMBER
)
/*** Insert some data--2 objects into the persons typed table ***/
INSERT INTO persons VALUES (
            PERSON('Wolfgang Amadeus Mozart', 123456,
               ADDRESS('Am Berg 100', 'Salzburg', 'AT','10424')))
/
INSERT INTO persons VALUES (
            PERSON('Ludwig van Beethoven', 234567,
               ADDRESS('Rheinallee', 'Bonn', 'DE', '69234')))
/
/** Put a row in the employees table **/
INSERT INTO employees (empnumber, office_addr, salary) VALUES (
            1001,
            ADDRESS('500 Oracle Parkway', 'Redwood Shores', 'CA', '94065'),
            50000)
/
/** Set the manager and PERSON REFs for the employee **/
UPDATE employees 
   SET manager =  
       (SELECT REF(p) FROM persons p WHERE p.name = 'Wolfgang Amadeus Mozart')
/
UPDATE employees 
   SET person_data =  
       (SELECT REF(p) FROM persons p WHERE p.name = 'Ludwig van Beethoven')
</pre><div class="infoboxnote" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-8AB87128-031C-4267-9A11-6945A39C8326">
                        <p class="notep1">Note:</p>
                        <p>Use of a table alias, such as <code class="codeph">p</code> in the example, is a recommended general practice in the Oracle SQL implementation, especially in accessing tables with user-defined types. It is required syntax in some cases where object attributes are accessed. Even when not required, it helps in avoiding ambiguities. Refer to the<a href="../sqlrf/Data-Types.html#SQLRF-GUID-7CF27C66-9908-4C02-9401-06C2F2C4021C" target="_blank"><span class="italic"> Oracle Database SQL Language Reference </span></a>for more information about table aliases.
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006305">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-C5274E1D-36DB-4983-9C7E-BA6135481AF5">Creating Collection Types</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>There are two categories of collections</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Variable-length arrays (VARRAYs)</p>
                        </li>
                        <li>
                           <p>Nested tables</p>
                        </li>
                     </ul>
                     <p>SQL commands to create VARRAY types are of the following form:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> IS VARRAY(<span class="italic">n</span>) OF <span class="italic">datatype</span>;
</pre><p>The <span class="italic"><code class="codeph">typename</code></span> designation is the desired name of your VARRAY type, <span class="italic"><code class="codeph">n</code></span> is the desired maximum number of elements in the array, and <span class="italic"><code class="codeph">datatype</code></span> is the data type of the array elements. For example:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE myvarr IS VARRAY(10) OF INTEGER;
</pre><p>SQL commands to create nested table types are of the following form:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS TABLE OF <span class="italic">datatype</span>;
</pre><p>The <span class="italic"><code class="codeph">typename</code></span> designation is the desired name of your nested table type and <span class="italic"><code class="codeph">datatype</code></span> is the data type of the table elements. This can be a user-defined type as well as a standard data type. A nested table is limited to one column, although that one column type can be a complex object with multiple attributes. The nested table, as with any database table, can have any number of rows. For example:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_array AS TABLE OF person;
</pre><p>This command creates a nested table where each row consists of a <code class="codeph">PERSON</code> object.
                     </p>
                     <p>The rest of this section provides an example of creating a user-defined collection type, as well as object types, in Oracle Database 12<span class="italic">c </span>Release 2 (12.2). 
                     </p>
                     <p>The following items are created and populated using SQL:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Two object types, <code class="codeph">PARTICIPANT_T</code> and <code class="codeph">MODULE_T</code></p>
                        </li>
                        <li>
                           <p>A collection type, <code class="codeph">MODULETBL_T</code>, which is a nested table of <code class="codeph">MODULE_T</code> objects
                           </p>
                        </li>
                        <li>
                           <p>A <code class="codeph">PROJECTS</code> table that includes a column of <code class="codeph">PARTICIPANT_T</code> references and a column of <code class="codeph">MODULETBL_T</code> nested tables
                           </p>
                        </li>
                        <li>
                           <p>A collection type <code class="codeph">PHONE_ARRAY</code>, which is a VARRAY of <code class="codeph">VARCHAR2(30)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PERSON</code> and <code class="codeph">ADDRESS</code> objects (repeating the same definitions used earlier)
                           </p>
                        </li>
                        <li>
                           <p>An <code class="codeph">EMPLOYEES</code> table, which includes a <code class="codeph">PHONE_ARRAY</code> column
                           </p>
                        </li>
                     </ul>
                     <p>The script for creating these items is as follows:</p><pre class="oac_no_warn" dir="ltr">Rem This is a SQL*Plus script used to create schema to demonstrate collection 
Rem manipulation in SQLJ 

CREATE TYPE PARTICIPANT_T AS OBJECT (
  empno   NUMBER(4),
  ename   VARCHAR2(20),
  job     VARCHAR2(12),
  mgr     NUMBER(4),
  hiredate DATE,
  sal      NUMBER(7,2),
  deptno   NUMBER(2)) 
/
SHOW ERRORS 
CREATE TYPE MODULE_T  AS OBJECT (
  module_id  NUMBER(4),
  module_name VARCHAR2(20), 
  module_owner REF PARTICIPANT_T, 
  module_start_date DATE, 
  module_duration NUMBER )
/
SHOW ERRORS
CREATE TYPE MODULETBL_T AS TABLE OF MODULE_T;
/
SHOW ERRORS
CREATE TABLE projects (
  id NUMBER(4),
  name VARCHAR(30),
  owner REF PARTICIPANT_T,
  start_date DATE,
  duration NUMBER(3),
  modules  MODULETBL_T  ) NESTED TABLE modules STORE AS modules_tab;

SHOW ERRORS
CREATE TYPE PHONE_ARRAY IS VARRAY (10) OF varchar2(30)
/

/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/
CREATE TABLE  employees
( empnumber            INTEGER PRIMARY KEY,
  person_data     REF  person,
  manager         REF  person,
  office_addr          address,
  salary               NUMBER,
  phone_nums           phone_array
)
/
</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSQLJ467"></a><div class="props_rev_3"><a id="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" name="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810"></a><h3 id="JSQLJ-GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" class="sect3">Strongly Typed Objects and References in SQLJ Executable Statements</h3>
               <div>
                  <p>The Oracle SQLJ implementation is flexible in how it enables you to use host expressions and iterators in reading or writing object data through strongly typed objects or references.</p>
                  <p>For iterators, you can use custom object classes as iterator column types. Alternatively, you can have iterator columns that correspond to individual object attributes, similar to extent tables, using column types that appropriately map to the SQL data types of the attributes.</p>
                  <p>For host expressions, you can use host variables of your custom object class type or custom reference class type. Alternatively, you can use host variables that correspond to object attributes, using variable types that appropriately map to the SQL data types of the attributes.</p>
                  <p>The remainder of this section provides examples of how to manipulate Oracle objects using custom object classes, custom object class attributes, and custom reference classes for host variables and iterator columns in SQLJ executable statements. </p>
                  <p>The following two examples operate at the object level:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84">Selecting Objects and Object References into Iterator Columns</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B">Updating an Object</a></p>
                     </li>
                  </ul>
                  <p>The <a href="objects-collections-and-OPAQUE-types.html#GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013">Inserting an Object Created from Individual Object Attributes</a> example operates at the scalar-attribute level.
                  </p>
                  <p>The <a href="objects-collections-and-OPAQUE-types.html#GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51">Updating an Object Reference</a> example operates through a reference.
                  </p>
               </div><a id="JSQLJ468"></a><div class="props_rev_3"><a id="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" name="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84"></a><h4 id="JSQLJ-GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" class="sect4">Selecting Objects and Object References into Iterator Columns</h4>
                  <div>
                     <div class="section">
                        <p>This example uses a custom Java class and a custom reference class as iterator column types. Presume the following definition of the <code class="codeph">ADDRESS</code> Oracle object type:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE ADDRESS AS OBJECT
(  street VARCHAR(40),
   zip NUMBER );
</pre><p>And the following definition of the <code class="codeph">EMPADDRS</code> table, which includes an <code class="codeph">ADDRESS</code> column and an <code class="codeph">ADDRESS</code> reference column:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE empaddrs
(  name VARCHAR(60),
   home ADDRESS,
   loc REF ADDRESS );
</pre><p>Once you create a custom Java class, <code class="codeph">Address</code>, and custom reference class, <code class="codeph">AddressRef</code>, corresponding to the <code class="codeph">ADDRESS</code> Oracle object type, you can use <code class="codeph">Address</code> and <code class="codeph">AddressRef</code> in a named iterator as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter (String name, Address home, AddressRef loc);

...
EmpIter ecur;
#sql ecur = { SELECT name, home, loc FROM empaddrs };
while (ecur.next()) {
   Address homeAddr = ecur.home();
   // Print out the home address.
   System.out.println ("Name: " + ecur.name() + "\n" +
                       "Home address: " + homeAddr.getStreet() + "   " +
                       homeAddr.getZip());
   // Now update the loc address zip code through the address reference.
   AddressRef homeRef = ecur.loc();
   Address location = homeRef.getValue();
   location.setZip(new BigDecimal(98765));
   homeRef.setValue(location);
   }
...
</pre><p>The <code class="codeph">ecur.home()</code> method call extracts an <code class="codeph">Address</code> object from the <code class="codeph">home</code> column of the iterator and assigns it to the <code class="codeph">homeAddr</code> local variable (for efficiency). The attributes of that object can then be accessed using standard Java dot syntax:
                        </p><pre class="oac_no_warn" dir="ltr">homeAddr.getStreet()
</pre><p>Use the <code class="codeph">getValue()</code> and <code class="codeph">setValue()</code> methods to manipulate the location address (in this case its zip code).
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ469"></a><div class="props_rev_3"><a id="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" name="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B"></a><h4 id="JSQLJ-GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" class="sect4">Updating an Object</h4>
                  <div>
                     <div class="section">
                        <p>This example declares and sets an input host variable of the <code class="codeph">Address</code> Java type to update an <code class="codeph">ADDRESS</code> object in a column of the <code class="codeph">employees</code> table. Both before and after the update, the address is selected into an output host variable of the <code class="codeph">Address</code> type and printed for verification.
                        </p><pre class="oac_no_warn" dir="ltr">...
// Updating an object 

static void updateObject() 
{

   Address addr;
   Address new_addr;
   int empnum = 1001;

   try {
      #sql {
         SELECT office_addr
         INTO :addr
         FROM employees
         WHERE empnumber = :empnum };
      System.out.println("Current office address of employee 1001:");

      printAddressDetails(addr);

      /* Now update the street of address */

      String street ="100 Oracle Parkway";
      addr.setStreet(street);

      /* Put updated object back into the database */

      try {
         #sql {
            UPDATE employees
            SET office_addr = :addr
            WHERE empnumber = :empnum };
         System.out.println
            ("Updated employee 1001 to new address at Oracle Parkway.");

         /* Select new address to verify update */
      
         try {
            #sql {
               SELECT office_addr
               INTO :new_addr
               FROM employees
               WHERE empnumber = :empnum };
      
            System.out.println("New office address of employee 1001:");
            printAddressDetails(new_addr);

         } catch (SQLException exn) {
         System.out.println("Verification SELECT failed with "+exn); }
      
      } catch (SQLException exn) {
      System.out.println("UPDATE failed with "+exn); }

   } catch (SQLException exn) {
   System.out.println("SELECT failed with "+exn); }
}
...
</pre><p>Note the use of the <code class="codeph">setStreet()</code> accessor method of the <code class="codeph">Address</code> object.
                        </p>
                        <p>This example uses the <code class="codeph">printAddressDetails()</code> utility. The source code for this method is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">static void printAddressDetails(Address a) throws SQLException
{

  if (a == null)  {
    System.out.println("No Address available.");
    return;
   }

   String street = ((a.getStreet()==null) ? "NULL street" : a.getStreet()) ;
   String city = (a.getCity()==null) ? "NULL city" : a.getCity();
   String state = (a.getState()==null) ? "NULL state" : a.getState();
   String zip_code = (a.getZipCode()==null) ? "NULL zip" : a.getZipCode();

   System.out.println("Street: '" + street + "'");
   System.out.println("City:   '" + city   + "'");
   System.out.println("State:  '" + state  + "'");
   System.out.println("Zip:    '" + zip_code + "'" );
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ470"></a><div class="props_rev_3"><a id="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" name="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013"></a><h4 id="JSQLJ-GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" class="sect4">Inserting an Object Created from Individual Object Attributes</h4>
                  <div>
                     <div class="section">
                        <p>This example declares and sets input host variables corresponding to attributes of <code class="codeph">PERSON</code> and nested <code class="codeph">ADDRESS</code> objects, then uses these values to insert a new <code class="codeph">PERSON</code> object into the <code class="codeph">persons</code> table in the database.
                        </p><pre class="oac_no_warn" dir="ltr">...
// Inserting an object

static void insertObject() 
{
   String new_name   = "NEW PERSON";
   int    new_ssn    = 987654;
   String new_street = "NEW STREET";
   String new_city   = "NEW CITY";
   String new_state  = "NS";
   String new_zip    = "NZIP";
  /*
   * Insert a new PERSON object into the persons table
   */
   try {
      #sql {
         INSERT INTO persons
         VALUES (PERSON(:new_name, :new_ssn,
         ADDRESS(:new_street, :new_city, :new_state, :new_zip))) };

      System.out.println("Inserted PERSON object NEW PERSON."); 

   } catch (SQLException exn) { System.out.println("INSERT failed with "+exn); }
}
...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ471"></a><div class="props_rev_3"><a id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" name="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51"></a><h4 id="JSQLJ-GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" class="sect4">Updating an Object Reference</h4>
                  <div>
                     <div class="section">
                        <p>This example selects a <code class="codeph">PERSON</code> reference from the <code class="codeph">persons</code> table and uses it to update a <code class="codeph">PERSON</code> reference in the <code class="codeph">employees</code> table. It uses simple input host variables to check attribute value criteria. The newly updated reference is then used in selecting the <code class="codeph">PERSON</code> object to which it refers, so that information can be output to the user to verify the change.
                        </p><pre class="oac_no_warn" dir="ltr">...
// Updating a REF to an object

static void updateRef()
{
   int empnum = 1001;
   String new_manager = "NEW PERSON";

   System.out.println("Updating manager REF.");
   try {
      #sql {
         UPDATE employees
         SET manager = 
            (SELECT REF(p) FROM persons p WHERE p.name = :new_manager)
         WHERE empnumber = :empnum };

      System.out.println("Updated manager of employee 1001. Selecting back");

   } catch (SQLException exn) {
   System.out.println("UPDATE REF failed with "+exn); }

   /* Select manager back to verify the update */
   Person manager;

   try { 
      #sql {
         SELECT deref(manager)
         INTO :manager
         FROM employees e
         WHERE empnumber = :empnum };

      System.out.println("Current manager of "+empnum+":");
      printPersonDetails(manager);

   } catch (SQLException exn) {
   System.out.println("SELECT REF failed with "+exn); }

}
...
</pre><div class="infoboxnote" id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51__GUID-5E9841E5-65A2-4F61-8D59-A299294C1B22">
                           <p class="notep1">Note:</p>
                           <p>This example uses table alias syntax (<code class="codeph">p</code>) as discussed previously. Also, the <code class="codeph">REF</code> syntax is required in selecting a reference through the object to which it refers, and the <code class="codeph">DEREF</code> syntax is required in selecting an object through a reference. Refer to the<a href="../sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#SQLRF-GUID-08B73ED6-2ABA-4737-B8A1-F7BD0456AEDB" target="_blank"><span class="italic"> Oracle Database SQL Language Reference </span></a>for more information about table aliases, <code class="codeph">REF</code>, and <code class="codeph">DEREF</code>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ472"></a><div class="props_rev_3"><a id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" name="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD"></a><h3 id="JSQLJ-GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" class="sect3">Strongly Typed Collections in SQLJ Executable Statements</h3>
               <div>
                  <p>As with strongly typed objects and references, the Oracle SQLJ implementation supports different scenarios for reading and writing data through strongly typed collections, using either iterators or host expressions.</p>
                  <p>From the perspective of a SQLJ developer, both categories of collections, VARRAY and nested table, are treated essentially the same, but there are some differences in implementation and performance.</p>
                  <p>The Oracle SQLJ implementation supports syntax choices so that nested tables can be accessed and manipulated either apart from or together with their outer tables. In this section, manipulation of a nested table by itself will be referred to as detail-level manipulation and manipulation of a nested table together with its outer table will be referred to as master-level manipulation.</p>
                  <p>Most of this section, after a brief discussion of some syntax, focuses on examples of manipulating nested tables, given that their use is somewhat more complicated than that of VARRAYs.</p>
                  <div class="infoboxnote" id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD__GUID-D0E7C0F8-8F58-41EF-B4AE-90B046B25F07">
                     <p class="notep1">Note:</p>
                     <p>In the Oracle SQLJ implementation, VARRAY types and nested table types can be retrieved only in their entirety. This is as opposed to the Oracle SQL implementation, where nested tables can be selectively queried.</p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF">Accessing Nested Tables: TABLE syntax and CURSOR syntax</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-2CDD8601-C214-4895-96D3-35585F3D5796">Inserting a Row that Includes a Nested Table</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521">Selecting a Nested Table into a Host Expression</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8">Manipulating a Nested Table Using TABLE Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">Selecting Data from a Nested Table Using a Nested Iterator</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB">Selecting a VARRAY into a Host Expression</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36">Inserting a Row that Includes a VARRAY</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ473"></a><div class="props_rev_3"><a id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" name="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF"></a><h4 id="JSQLJ-GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" class="sect4">Accessing Nested Tables: TABLE syntax and CURSOR syntax</h4>
                  <div>
                     <div class="section">
                        <p>The Oracle SQLJ implementation supports the use of nested iterators to access data in nested tables. Use the <code class="codeph">CURSOR</code> keyword in the outer <code class="codeph">SELECT</code> statement to encapsulate the inner <code class="codeph">SELECT</code> statement. This is shown in <span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">Selecting Data from a Nested Table Using a Nested Iterator</a>"</span>.
                        </p>
                        <p>Oracle also supports use of the <code class="codeph">TABLE</code> keyword to manipulate the individual rows of a nested table. This keyword informs Oracle that the column value returned by a subquery is a nested table, as opposed to a scalar value. You must prefix the <code class="codeph">TABLE</code> keyword to a subquery that returns a single column value or an expression that yields a nested table.
                        </p>
                        <p>The following example shows the use of the <code class="codeph">TABLE</code> syntax:
                        </p><pre class="oac_no_warn" dir="ltr">UPDATE TABLE(SELECT a.modules FROM projects a WHERE a.id=555) b
       SET module_owner= 
       (SELECT ref(p) FROM employees p WHERE p.ename= 'Smith') 
       WHERE b.module_name = 'Zebra';
</pre><p>When you see <code class="codeph">TABLE</code> used as it is here, realize that it is referring to a single nested table that has been selected from a column of an outer table.
                        </p>
                        <div class="infoboxnote" id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF__GUID-78769A8D-4B7E-4487-ABF6-B993D472C1C9">
                           <p class="notep1">Note:</p>
                           <p>This example uses table alias syntax (<code class="codeph">a</code> for <code class="codeph">projects</code>, <code class="codeph">b</code> for the nested table, and <code class="codeph">p</code> for <code class="codeph">employees</code>) as discussed previously.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ474"></a><div class="props_rev_3"><a id="GUID-2CDD8601-C214-4895-96D3-35585F3D5796" name="GUID-2CDD8601-C214-4895-96D3-35585F3D5796"></a><h4 id="JSQLJ-GUID-2CDD8601-C214-4895-96D3-35585F3D5796" class="sect4">Inserting a Row that Includes a Nested Table</h4>
                  <div>
                     <div class="section">
                        <p>This example shows an operation that manipulates the master level (outer table) and detail level (nested tables) simultaneously and explicitly. This inserts a row in the <code class="codeph">projects</code> table, where each row includes a nested table of the <code class="codeph">MODULETBL_T</code> type, which contains rows of <code class="codeph">MODULE_T</code> objects.
                        </p>
                        <p>First, the scalar values are set (<code class="codeph">id</code>, <code class="codeph">name</code>, <code class="codeph">start_date</code>, <code class="codeph">duration</code>), then the nested table values are set. This involves an extra level of abstraction, because the nested table elements are objects with multiple attributes. In setting the nested table values, each attribute value must be set for each <code class="codeph">MODULE_T</code> object in the nested table. Finally, the <code class="codeph">owner</code> values, initially set to <code class="codeph">null</code>, are set in a separate statement.
                        </p><pre class="oac_no_warn" dir="ltr">// Insert Nested table details along with master details 

  public static void insertProject2(int id)  throws Exception 
  {
    System.out.println("Inserting Project with Nested Table details..");
    try {
      #sql { INSERT INTO Projects(id,name,owner,start_date,duration, modules) 
             VALUES ( 600, 'Ruby', null, '10-MAY-98',  300, 
             moduletbl_t(module_t(6001, 'Setup ', null, '01-JAN-98', 100),
                        module_t(6002, 'BenchMark', null, '05-FEB-98',20) ,
                        module_t(6003, 'Purchase', null, '15-MAR-98', 50),
                        module_t(6004, 'Install', null, '15-MAR-98',44),
                        module_t(6005, 'Launch', null,'12-MAY-98',34))) };
    } catch ( Exception e) {
      System.out.println("Error:insertProject2");
      e.printStackTrace();
    }

    // Assign project owner to this project 

    try {
      #sql { UPDATE Projects pr
          SET owner=(SELECT ref(pa) FROM participants pa WHERE pa.empno = 7698)
         WHERE pr.id=600 };
    } catch ( Exception e) {
      System.out.println("Error:insertProject2:update");
      e.printStackTrace();
    }
  }
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ475"></a><div class="props_rev_3"><a id="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" name="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521"></a><h4 id="JSQLJ-GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" class="sect4">Selecting a Nested Table into a Host Expression</h4>
                  <div>
                     <div class="section">
                        <p>This example presents an operation that works directly at the detail level of the nested table.</p><pre class="oac_no_warn" dir="ltr">  static ModuletblT mymodules=null;
  ...

  public static void getModules2(int projId)
  throws Exception 
  {
    System.out.println("Display modules for project " + projId );

    try {
      #sql {SELECT modules INTO :mymodules 
                           FROM projects  WHERE id=:projId };
      showArray(mymodules);
    } catch(Exception e) {
      System.out.println("Error:getModules2");
      e.printStackTrace();
    }
  }

  public static void showArray(ModuletblT a) 
  {
    try {
      if ( a == null )
        System.out.println( "The array is null" );
      else {
        System.out.println( "printing ModuleTable array object of size "
                             +a.length());
        ModuleT[] modules = a.getArray();

        for (int i=0;i&lt;modules.length; i++) {
          ModuleT module = modules[i];
          System.out.println("module "+module.getModuleId()+
                ", "+module.getModuleName()+
                ", "+module.getModuleStartDate()+
                ", "+module.getModuleDuration());
        }
      }
    }
    catch( Exception e ) {
      System.out.println("Show Array");
      e.printStackTrace();
    }
  }
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ476"></a><div class="props_rev_3"><a id="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" name="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8"></a><h4 id="JSQLJ-GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" class="sect4">Manipulating a Nested Table Using TABLE Syntax</h4>
                  <div>
                     <div class="section">
                        <p>This example uses <code class="codeph">TABLE</code> syntax to work at the detail level to access and update nested table elements directly, based on master-level criteria.
                        </p>
                        <p>The <code class="codeph">assignModule()</code> method selects a nested table of <code class="codeph">MODULE_T</code> objects from the <code class="codeph">MODULES</code> column of the <code class="codeph">PROJECTS</code> table, then updates <code class="codeph">MODULE_NAME</code> for a particular row of the nested table. Similarly, the <code class="codeph">deleteUnownedModules()</code> method selects a nested table of <code class="codeph">MODULE_T</code> objects, then deletes any unowned modules in the nested table, where <code class="codeph">MODULE_OWNER</code> is <code class="codeph">null</code>.
                        </p>
                        <p>These methods use table alias syntax, as discussed previously. In this case, <code class="codeph">m</code> is used for the nested table, and <code class="codeph">p</code> is used for the <code class="codeph">participants</code> table.
                        </p><pre class="oac_no_warn" dir="ltr">  /* assignModule 
     Illustrates accessing the nested table using the TABLE construct 
     and updating the nested table row 
  */
  public static void assignModule(int projId, String moduleName, 
                                  String modOwner) throws Exception 
  {
    System.out.println("Update:Assign '"+moduleName+"' to '"+ modOwner+"'");

    try {
      #sql {UPDATE TABLE(SELECT modules FROM projects WHERE id=:projId) m
            SET m.module_owner=
           (SELECT ref(p) FROM participants p WHERE p.ename= :modOwner) 
            WHERE m.module_name = :moduleName };
    } catch(Exception e) {
      System.out.println("Error:insertModules");
      e.printStackTrace();
    }
  }

  /* deleteUnownedModules 
  // Demonstrates deletion of the Nested table element 
  */

  public static void deleteUnownedModules(int projId)
  throws Exception 
  {
    System.out.println("Deleting Unowned Modules for Project " + projId);
    try {
      #sql { DELETE TABLE(SELECT modules FROM projects WHERE id=:projId) m
             WHERE m.module_owner IS NULL };
    } catch(Exception e) {
      System.out.println("Error:deleteUnownedModules");
      e.printStackTrace();
    }
  }
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ477"></a><div class="props_rev_3"><a id="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" name="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E"></a><h4 id="JSQLJ-GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" class="sect4">Selecting Data from a Nested Table Using a Nested Iterator</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ supports the use of nested iterators as a way of accessing nested tables. This requires <code class="codeph">CURSOR</code> syntax, as used in the following example. The code defines a named iterator class, <code class="codeph">ModuleIter</code>, then uses that class as the type for a <code class="codeph">modules</code> column in another named iterator class, <code class="codeph">ProjIter</code>. Inside a populated <code class="codeph">ProjIter</code> instance, each <code class="codeph">modules</code> item is a nested table rendered as a nested iterator.
                        </p>
                        <p>The <code class="codeph">CURSOR</code> syntax is part of the nested <code class="codeph">SELECT</code> statement that populates the nested iterators. Once the data has been selected, it is output to the user through the iterator accessor methods.
                        </p>
                        <p>This example uses required table alias syntax, as discussed previously. In this case, <code class="codeph">a</code> for the <code class="codeph">projects</code> table and <code class="codeph">b</code> for the nested table.
                        </p><pre class="oac_no_warn" dir="ltr">...

//  The Nested Table is accessed using the ModuleIter 
//  The ModuleIter is defined as Named Iterator 

#sql public static iterator ModuleIter(int moduleId , 
                                       String moduleName , 
                                       String moduleOwner);

// Get the Project Details using the ProjIter defined as 
// Named Iterator. Notice the use of ModuleIter:

#sql public static iterator ProjIter(int id, 
                                     String name, 
                                     String owner, 
                                     Date start_date, 
                                     ModuleIter modules);

...

public static void listAllProjects() throws SQLException
{
  System.out.println("Listing projects...");

   // Instantiate and initialize the iterators 

   ProjIter projs = null;
   ModuleIter  mods = null;
   #sql projs = {SELECT a.id, 
                        a.name, 
                        initcap(a.owner.ename) as "owner", 
                        a.start_date,
                        CURSOR (
                        SELECT b.module_id AS "moduleId",
                               b.module_name AS "moduleName",
                                 initcap(b.module_owner.ename) AS "moduleOwner"
                        FROM TABLE(a.modules) b) AS "modules"  
                 FROM projects a };
  
  // Display Project Details
  
  while (projs.next()) {
    System.out.println( "\n'" + projs.name() + "' Project Id:" 
                + projs.id() + " is owned by " +"'"+ projs.owner() +"'"
                + " start on "  
                + projs.start_date());
              
    // Notice the modules from the ProjIter are assigned to the module
    // iterator variable 

    mods = projs.modules();
    System.out.println ("Modules in this Project are : ");

    // Display Module details 

    while(mods.next()) { 
      System.out.println ("  "+ mods.moduleId() + " '"+ 
                                mods.moduleName() + "' owner is '" +
                                mods.moduleOwner()+"'" );
    }                    // end of modules 
    mods.close();
  }                      // end of projects 
  projs.close();
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ478"></a><div class="props_rev_3"><a id="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" name="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB"></a><h4 id="JSQLJ-GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" class="sect4">Selecting a VARRAY into a Host Expression</h4>
                  <div>
                     <div class="section">
                        <p>This section provides an example of selecting a VARRAY into a host expression. Presume the following SQL definitions:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE PHONE_ARRAY IS VARRAY (10) OF varchar2(30)
/
/*** Create ADDRESS UDT ***/
CREATE TYPE ADDRESS AS OBJECT
( 
  street        VARCHAR(60),
  city          VARCHAR(30),
  state         CHAR(2),
  zip_code      CHAR(5)
)
/
/*** Create PERSON UDT containing an embedded ADDRESS UDT ***/
CREATE TYPE PERSON AS OBJECT
( 
  name    VARCHAR(30),
  ssn     NUMBER,
  addr    ADDRESS
)
/

CREATE TABLE  employees
( empnumber            INTEGER PRIMARY KEY,
  person_data     REF  person,
  manager         REF  person,
  office_addr          address,
  salary               NUMBER,
  phone_nums           phone_array
)
/
</pre><p>And presume that you created a <code class="codeph">PhoneArray</code> custom collection class to map from the <code class="codeph">PHONE_ARRAY</code> SQL type.
                        </p>
                        <p>The following method selects a row from this table, placing the data into a host variable of the <code class="codeph">PhoneArray</code> type:
                        </p><pre class="oac_no_warn" dir="ltr">private static void selectVarray() throws SQLException
{
  PhoneArray ph;
  #sql {select phone_nums into :ph from employees where empnumber=2001};
  System.out.println(
    "there are "+ph.length()+" phone numbers in the PhoneArray.  They are:");

  String [] pharr = ph.getArray();
  for (int i=0;i&lt;pharr.length;++i) 
    System.out.println(pharr[i]);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ479"></a><div class="props_rev_3"><a id="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" name="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36"></a><h4 id="JSQLJ-GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" class="sect4">Inserting a Row that Includes a VARRAY</h4>
                  <div>
                     <div class="section">
                        <p>This section provides an example of inserting data from a host expression into a VARRAY, using the same SQL definitions and custom collection class (<code class="codeph">PhoneArray</code>) as in the previous section.
                        </p>
                        <p>The following methods populate a <code class="codeph">PhoneArray</code> instance and use it as a host variable, inserting its data into a VARRAY in the database:
                        </p><pre class="oac_no_warn" dir="ltr">// creates a varray object of PhoneArray and inserts it into a new row
private static void insertVarray() throws SQLException
{
  PhoneArray phForInsert = consUpPhoneArray();
  // clean up from previous demo runs
  #sql {delete from employees where empnumber=2001};
  // insert the PhoneArray object
  #sql {insert into employees (empnumber, phone_nums)
        values(2001, :phForInsert)};
}

private static PhoneArray consUpPhoneArray()
{
  String [] strarr = new String[3];
  strarr[0] = "(510) 555.1111";
  strarr[1] = "(617) 555.2222";
  strarr[2] = "(650) 555.3333";
  return new PhoneArray(strarr);
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ480"></a><div class="props_rev_3"><a id="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" name="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A"></a><h3 id="JSQLJ-GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" class="sect3">Serialized Java Objects</h3>
               <div>
                  <p>When writing and reading instances of Java objects to or from the database, it is sometimes advantageous to define a SQL object type that corresponds to your Java class and use the mechanisms of mapping custom Java classes described previously. This fully permits SQL queries on your Java objects.</p>
                  <p>In some cases, however, you may want to store Java objects "as-is" and retrieve them later, using database columns of the <code class="codeph">RAW</code> or <code class="codeph">BLOB</code> type. There are different ways to accomplish this:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You can map a serializable Java class to <code class="codeph">RAW</code> or <code class="codeph">BLOB</code> columns by using a nonstandard extension to the type map facility or by adding a type code field to the serializable class, so that instances of the serializable class can be stored as <code class="codeph">RAW</code> or <code class="codeph">BLOB</code>.
                        </p>
                     </li>
                     <li>
                        <p>You can use the <code class="codeph">ORAData</code> facility to define a serializable wrapper class whose instances can be stored in <code class="codeph">RAW</code> or <code class="codeph">BLOB</code> columns.
                        </p>
                     </li>
                  </ul>
                  <p>Serializing in any of these ways works for any Oracle SQLJ run-time library.</p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C">Serializing Java Classes to RAW and BLOB Columns</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-57A81264-D048-417F-8097-FDB9842DFAF0">SerializableDatum: an ORAData Implementation</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-13212854-72AA-451F-8F85-CD8602AAB6DB">SerializableDatum in SQLJ Applications</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4">SerializableDatum (Complete Class)</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ482"></a><a id="JSQLJ483"></a><a id="JSQLJ484"></a><a id="JSQLJ481"></a><div class="props_rev_3"><a id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" name="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C"></a><h4 id="JSQLJ-GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" class="sect4">Serializing Java Classes to RAW and BLOB Columns</h4>
                  <div>
                     <p>If you want to store instances of Java classes directly in <code class="codeph">RAW</code> or <code class="codeph">BLOB</code> columns, then you must meet certain nonstandard requirements to specify the desired SQL-Java mapping. Note that in SQLJ statements the serializable Java objects can be transparently read and written as if they were built-in types.
                     </p>
                     <p>You have two options in specifying the SQL-Java type mapping:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Declare a type map in the connection context declaration and use this type map to specify mappings.</p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">public static final</code> field <code class="codeph">_SQL_TYPECODE</code> to specify the mapping.
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-13105C6E-E3BC-4DDA-B83F-924EF821467F">Defining a Type Map for Serializable Classes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Consider an example where <code class="codeph">SAddress</code>, <code class="codeph">pack.SPerson</code>, and <code class="codeph">pack.Manager.InnerSPM</code>, where <code class="codeph">InnerSPM</code> is an inner class of <code class="codeph">Manager</code>, are serializable Java classes. In other words, these classes implement the <code class="codeph">java.io.Serializable</code> interface.
                        </p>
                        <p>You must use the classes only in statements that use explicit connection context instances of a declared connection context type, such as <code class="codeph">SerContext</code> in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">SAddress               a =...;
pack.SPerson           p =...;
pack.Manager.InnerSPM pm =...;
SerContext ctx = new SerContext(url,user,pwd,false);
#sql [ctx] { ... :a ... :OUT p ... :INOUT pm ... };
</pre><p>The following is required:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The connection context type must have been declared using the <code class="codeph">typeMap</code> attribute of a <code class="codeph">with</code> clause to specify an associated class implementing <code class="codeph">java.util.PropertyResourceBundle</code>. In the example, <code class="codeph">SerContext</code> may be declared as follows.
                              </p><pre class="oac_no_warn" dir="ltr">#sql public static context SerContext with (typeMap="SerMap");
</pre></li>
                           <li>
                              <p>The type map resource must provide nonstandard mappings from <code class="codeph">RAW</code> or <code class="codeph">BLOB</code> columns to the serializable Java classes. This mapping is specified with entries of the following form, depending on whether the Java class is mapped to a <code class="codeph">RAW</code> or a <code class="codeph">BLOB</code> column:
                              </p><pre class="oac_no_warn" dir="ltr">oracle-class.<span class="variable" translate="no">java_class_name</span>=JAVA_OBJECT RAW
oracle-class.<span class="variable" translate="no">java_class_name</span>=JAVA_OBJECT BLOB
</pre><p>The keyword <code class="codeph">oracle-class</code> marks this as an Oracle-specific extension. In the example, the <code class="codeph">SerMap.properties</code> resource file may contain the following entries:
                              </p><pre class="oac_no_warn" dir="ltr">oracle-class.SAddress=JAVA_OBJECT RAW
oracle-class.pack.SPerson=JAVA_OBJECT BLOB
oracle-class.packManager$InnerSPM=JAVA_OBJECT RAW
</pre><p>Although the period (.) separates package and class names, you <span class="italic">must</span> use the dollar sign ($) to separate an inner class name.
                              </p>
                           </li>
                        </ul>
                        <p>Note that this Oracle-specific extension can be placed in the same type map resource as standard <code class="codeph">SQLData</code> type map entries.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-7F86B2A1-EBF8-4CC2-AB63-3D5F3845993F">Using Fields to Determine Mapping for Serializable Classes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>As an alternative to using a type map for a serializable class, you can use static fields in the serializable class to determine type mapping. You can add either of the following fields to a class that implements the <code class="codeph">java.io.Serializable</code> interface, such as the <code class="codeph">SAddress</code> and <code class="codeph">SPerson</code> classes from the preceding example:
                        </p><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc.OracleTypes.RAW;
</pre><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc.OracleTypes.BLOB;
</pre><div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-288B229B-EA5B-49BE-82EE-710F3E70AF45">
                           <p class="notep1">Note:</p>
                           <p>Using the type map facility supersedes manually adding the <code class="codeph">_SQL_TYPECODE</code> field to the class.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-CAD8FCC7-B322-484C-9DBA-6305A3982F2F">Limitations on Serializing Java Objects</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>You should be aware of the effect of serialization. If two objects, A and B, share the same object, C, then upon serialization and subsequent deserialization of A and B, each will point to its own clone of the object C. Sharing is broken.</p>
                        <p>In addition, note that for a given Java class, you can declare only one kind of serialization: either into <code class="codeph">RAW</code> or into <code class="codeph">BLOB</code>. The SQLJ translator can check only that the actual usage conforms to either <code class="codeph">RAW</code> or <code class="codeph">BLOB</code>.
                        </p>
                        <p><code class="codeph">RAW</code> columns are limited in size. You might experience run-time errors if the actual size of the serialized Java object exceeds the size of the column.
                        </p>
                        <p>Column size is much less restrictive for <code class="codeph">BLOB</code> columns. Writing a serialized Java object to a <code class="codeph">BLOB</code> column is supported by Oracle JDBC Oracle Call Interface (OCI) driver and Oracle JDBC Thin driver. Retrieving a serialized object from a <code class="codeph">BLOB</code> column is supported by all Oracle JDBC drivers since Oracle9<span class="italic">i</span>.
                        </p>
                        <p>Finally, treating serialized Java objects this way is an Oracle-specific extension and requires Oracle SQLJ run time as well as either the default Oracle-specific code generation (<code class="codeph">-codegen=oracle</code> during translation) or, for ISO standard code generation (<code class="codeph">-codegen=iso</code>), Oracle-specific profile customization. 
                        </p>
                        <p>10iProd: Note that future versions of Oracle might support SQL types that directly encapsulate Java serialized objects. These are described as JAVA_OBJECT SQL types in JDBC 2.0. At that point, you can replace each of the BLOB and RAW designations by the names of their corresponding JAVA_OBJECT SQL types, and you can drop the oracle- prefix on the entries.</p>
                        <div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-427AA3C2-4FF2-4001-939B-DA07D0969E16">
                           <p class="notep1">Note:</p>
                           <p>The implementation of this particular serialization mechanism does not use JDBC type maps. The map (to <code class="codeph">BLOB</code> or to <code class="codeph">RAW</code>) is hardcoded in the Oracle profile customization at translation time, or is generated directly into Java code.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ485"></a><div class="props_rev_3"><a id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0" name="GUID-57A81264-D048-417F-8097-FDB9842DFAF0"></a><h4 id="JSQLJ-GUID-57A81264-D048-417F-8097-FDB9842DFAF0" class="sect4">SerializableDatum: an ORAData Implementation</h4>
                  <div>
                     <div class="section">
                        <p><span class="q">"<a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">Additional Uses for ORAData Implementations</a>"</span> includes examples of situations where you might want to define a custom Java class that maps to some <code class="codeph">oracle.sql.*</code> type other than <code class="codeph">oracle.sql.STRUCT</code>, <code class="codeph">oracle.sql.REF</code>, or <code class="codeph">oracle.sql.ARRAY</code>.
                        </p>
                        <p>An example of such a situation is if you want to serialize and deserialize Java objects into and out of <code class="codeph">RAW</code> fields, with a custom Java class that maps to the <code class="codeph">oracle.sql.RAW</code> type. This could apply equally to <code class="codeph">BLOB</code> fields, with a custom Java class that maps to the <code class="codeph">oracle.sql.BLOB</code> type.
                        </p>
                        <p>This section presents an example of such an application, creating a class, <code class="codeph">SerializableDatum</code>, that implements the <code class="codeph">ORAData</code> interface and follows the general form of custom Java classes. The example starts with a step-by-step approach to the development of <code class="codeph">SerializableDatum</code>, followed by the complete sample code.
                        </p>
                        <div class="infoboxnote" id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0__GUID-5AC9D3E6-9A06-4C30-93D6-E3E04AEE81BE">
                           <p class="notep1">Note:</p>
                           <p>This application uses classes from the <code class="codeph">java.io</code>, <code class="codeph">java.sql</code>, <code class="codeph">oracle.sql</code>, and <code class="codeph">oracle.jdbc</code> packages. The import statements are not shown here.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Begin with a skeleton of the class.</span><div><pre class="oac_no_warn" dir="ltr">public class SerializableDatum implements ORAData
{
   // <span class="italic">Client methods for constructing and accessing the Java object</span>

   public Datum toDatum(java.sql.Connection c) throws SQLException
   {
      // <span class="italic">Implementation of toDatum()</span>
   }

   public static ORADataFactory getORADataFactory()
   {
      return FACTORY;
   }

   private static final ORADataFactory FACTORY =
           // <span class="italic">Implementation of an ORADataFactory for SerializableDatum</span>

   // <span class="italic">Construction of SerializableDatum from oracle.sql.RAW</span>

   public static final int _SQL_TYPECODE = OracleTypes.RAW;
}
</pre><p><code class="codeph">SerializableDatum</code> does not implement the <code class="codeph">ORADataFactory</code> interface, but its <code class="codeph">getORADataFactory()</code> method returns a static member that implements this interface.
                              </p>
                              <p>The <code class="codeph">_SQL_TYPECODE</code> is set to <code class="codeph">OracleTypes.RAW</code> because this is the data type being read from and written to the database. The SQLJ translator needs this type code information in performing online type-checking to verify compatibility between the user-defined Java type and the SQL type.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Define client methods that perform the following:</span><div>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Create a <code class="codeph">SerializableDatum</code> object.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Populate a <code class="codeph">SerializableDatum</code> object.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Retrieve data from a <code class="codeph">SerializableDatum</code> object.
                                    </p>
                                 </li>
                              </ul><pre class="oac_no_warn" dir="ltr">// Client methods for constructing and accessing a SerializableDatum

private Object m_data;
public SerializableDatum()
{
   m_data = null;
}
public void setData(Object data)
{
   m_data = data;
}
public Object getData()
{
   return m_data;
}
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Implement a <code class="codeph">toDatum()</code> method that serializes data from a <code class="codeph">SerializableDatum</code> object to an <code class="codeph">oracle.sql.RAW</code> object. The implementation of <code class="codeph">toDatum()</code> must return a serialized representation of the object in the <code class="codeph">m_data</code> field as an <code class="codeph">oracle.sql.RAW</code> instance.</span><div><pre class="oac_no_warn" dir="ltr">// Implementation of toDatum()

try {
   ByteArrayOutputStream os = new ByteArrayOutputStream();
   ObjectOutputStream oos = new ObjectOutputStream(os);
   oos.writeObject(m_data);
   oos.close();
   return new RAW(os.toByteArray());
} catch (Exception e) {
  throw new SQLException("SerializableDatum.toDatum: "+e.toString()); }
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Implement data conversion from an <code class="codeph">oracle.sql.RAW</code> object to a <code class="codeph">SerializableDatum</code> object. This step deserializes the data.</span><div><pre class="oac_no_warn" dir="ltr">// Constructing SerializableDatum from oracle.sql.RAW

private SerializableDatum(RAW raw) throws SQLException
{
   try {
      InputStream rawStream = new ByteArrayInputStream(raw.getBytes());
      ObjectInputStream is = new ObjectInputStream(rawStream);
      m_data = is.readObject();
      is.close();
   } catch (Exception e) {
     throw new SQLException("SerializableDatum.create: "+e.toString()); }
}
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Implement an <code class="codeph">ORADataFactory</code>. In this case, it is implemented as an anonymous class.</span><div><pre class="oac_no_warn" dir="ltr">// Implementation of an ORADataFactory for SerializableDatum

new ORADataFactory()
{
   public ORAData create(Datum d, int sqlCode) throws SQLException
   {
      if (sqlCode != _SQL_TYPECODE)
      {
         throw new SQLException
                   ("SerializableDatum: invalid SQL type "+sqlCode);
      }
      return (d==null) ? null : new SerializableDatum((RAW)d);
   }
};
</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSQLJ487"></a><a id="JSQLJ488"></a><a id="JSQLJ486"></a><div class="props_rev_3"><a id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" name="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB"></a><h4 id="JSQLJ-GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" class="sect4">SerializableDatum in SQLJ Applications</h4>
                  <div>
                     <p>Given the <code class="codeph">SerializableDatum</code> class created in the preceding section, this section shows how to use an instance of it in a SQLJ application, both as a host variable and as an iterator column.
                     </p>
                     <p>Presume the following table definition:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE PERSONDATA (NAME VARCHAR2(20) NOT NULL, INFO RAW(2000));</pre><div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-D7DFEB61-72D8-4391-BC8B-0D678CB18099">SerializableDatum as Host Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following uses a <code class="codeph">SerializableDatum</code> instance as a host variable:
                        </p><pre class="oac_no_warn" dir="ltr">...
SerializableDatum pinfo = new SerializableDatum();
pinfo.setData (
   new Object[] {"Some objects", new Integer(51), new Double(1234.27) } );
String pname = "MILLER";
#sql { INSERT INTO persondata VALUES(:pname, :pinfo) };
...
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-7D5AB996-FA5A-460A-9DC8-90FDEB946214">SerializableDatum in Iterator Column</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Following is an example of using <code class="codeph">SerializableDatum</code> as a named iterator column:
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator PersonIter (SerializableDatum info, String name);

...
PersonIter pcur;
#sql pcur = { SELECT * FROM persondata WHERE info IS NOT NULL };
while (pcur.next())
{
   System.out.println("Name:" + pcur.name() + " Info:" + pcur.info());
}
pcur.close();
...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ489"></a><div class="props_rev_3"><a id="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" name="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4"></a><h4 id="JSQLJ-GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" class="sect4">SerializableDatum (Complete Class)</h4>
                  <div>
                     <p>The following is complete code for the <code class="codeph">SerializableDatum</code> class, which was developed in step-by-step fashion in the preceding sections.
                     </p><pre class="oac_no_warn" dir="ltr">import java.io.*;
import java.sql.*;
import oracle.sql.*;
import oracle.jdbc.*;

public class SerializableDatum implements ORAData
{
// Client methods for constructing and accessing a SerializableDatum

   private Object m_data;
   public SerializableDatum()
   {
      m_data = null;
   }
   public void setData(Object data)
   {
      m_data = data;
   }
   public Object getData()
   {
      return m_data;
   }

// Implementation of toDatum()

   public Datum toDatum(Connection c) throws SQLException
   {

      try {
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(os);
         oos.writeObject(m_data);
         oos.close();
         return new RAW(os.toByteArray());
      } catch (Exception e) {
        throw new SQLException("SerializableDatum.toDatum: "+e.toString()); }
   }

   public static ORADataFactory getORADataFactory()
   {
      return FACTORY;
   }

// Implementation of an ORADataFactory for SerializableDatum

   private static final ORADataFactory FACTORY =
   
      new ORADataFactory()
      {
         public ORAData create(Datum d, int sqlCode) throws SQLException
         {
            if (sqlCode != _SQL_TYPECODE)
            {
               throw new SQLException(
                  "SerializableDatum: invalid SQL type "+sqlCode);
            }
            return (d==null) ? null : new SerializableDatum((RAW)d);
         }
      };

// Constructing SerializableDatum from oracle.sql.RAW

   private SerializableDatum(RAW raw) throws SQLException
   {
      try {
         InputStream rawStream = new ByteArrayInputStream(raw.getBytes());
         ObjectInputStream is = new ObjectInputStream(rawStream);
         m_data = is.readObject();
         is.close();
      } catch (Exception e) {
        throw new SQLException("SerializableDatum.create: "+e.toString()); }
   }

   public static final int _SQL_TYPECODE = OracleTypes.RAW;
}
</pre></div>
               </div>
            </div><a id="JSQLJ490"></a><div class="props_rev_3"><a id="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" name="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55"></a><h3 id="JSQLJ-GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" class="sect3">Weakly Typed Objects, References, and Collections</h3>
               <div>
                  <p>Weakly typed objects, references, and collections are supported by SQLJ. Their use is not generally recommended, and there are some specific restrictions, but in some circumstances they can be useful. For example, you might have generic code that can use "any <code class="codeph">STRUCT</code>" or "any <code class="codeph">REF</code>".
                  </p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006">Support for Weakly Typed Objects_ References_ and Collections</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4EF76552-5997-4966-970E-1947416861D3">Restrictions on Weakly Typed Objects_ References_ and Collections</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ491"></a><div class="props_rev_3"><a id="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" name="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006"></a><h4 id="JSQLJ-GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" class="sect4">Support for Weakly Typed Objects, References, and Collections</h4>
                  <div>
                     <div class="section">
                        <p>In using Oracle objects, references, or collections in a SQLJ application, you have the option of using generic and weakly typed <code class="codeph">java.sql</code> or <code class="codeph">oracle.sql</code> instances instead of the strongly typed custom object, reference, and collection classes that implement the <code class="codeph">ORAData</code> interface or the strongly typed custom object classes that implement the <code class="codeph">SQLData</code> interface. Note that if you use <code class="codeph">SQLData</code> implementations for your custom object classes, then you will have no choice but to use weakly typed custom reference instances.
                        </p>
                        <p>The following weak types can be used for iterator columns or host expressions in the Oracle SQLJ implementation:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">java.sql.Struct</code> or <code class="codeph">oracle.sql.STRUCT</code> for objects
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql.Ref</code> or <code class="codeph">oracle.sql.REF</code> for object references
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql.Array</code> or <code class="codeph">oracle.sql.ARRAY</code> for collections
                              </p>
                           </li>
                        </ul>
                        <p>In host expressions, they are supported as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>As input host expressions</p>
                           </li>
                           <li>
                              <p>As output host expressions in an <code class="codeph">INTO</code>-list
                              </p>
                           </li>
                        </ul>
                        <p>Using these weak types is not generally recommended, however, as you would lose all the advantages of the strongly typed paradigm that SQLJ offers.</p>
                        <p>Each attribute in a <code class="codeph">STRUCT</code> object or each element in an <code class="codeph">ARRAY</code> object is stored in an <code class="codeph">oracle.sql.Datum</code> object, with the underlying data being in the form of the appropriate <code class="codeph">oracle.sql.*</code> subtype of <code class="codeph">Datum</code>, such as <code class="codeph">oracle.sql.NUMBER</code> or <code class="codeph">oracle.sql.CHAR</code>. Attributes in a <code class="codeph">STRUCT</code> object are nameless. Because of the generic nature of the <code class="codeph">STRUCT</code> and <code class="codeph">ARRAY</code> classes, SQLJ cannot perform type checking where objects or collections are written to or read from instances of these classes.
                        </p>
                        <p>It is generally recommended that you use custom Java classes for objects, references, and collections.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ492"></a><div class="props_rev_3"><a id="GUID-4EF76552-5997-4966-970E-1947416861D3" name="GUID-4EF76552-5997-4966-970E-1947416861D3"></a><h4 id="JSQLJ-GUID-4EF76552-5997-4966-970E-1947416861D3" class="sect4">Restrictions on Weakly Typed Objects, References, and Collections</h4>
                  <div>
                     <div class="section">
                        <p>A weakly typed object (<code class="codeph">Struct</code> or <code class="codeph">STRUCT</code> instance), reference (<code class="codeph">Ref</code> or <code class="codeph">REF</code> instance), or collection (<code class="codeph">Array</code> or <code class="codeph">ARRAY</code> instance) <span class="italic">cannot</span> be used in host expressions in the following circumstances:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">IN</code> parameter if null
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OUT</code> or <code class="codeph">INOUT</code> parameter in a stored procedure or function call
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OUT</code> parameter in a stored function result expression
                              </p>
                           </li>
                        </ul>
                        <p>They cannot be used in these ways, because there is no way to know the underlying SQL type name, such as <code class="codeph">Person</code>, which is required by Oracle JDBC driver to materialize an instance of a user-defined type in Java.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ493"></a><div class="props_rev_3"><a id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" name="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4"></a><h3 id="JSQLJ-GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" class="sect3">Oracle OPAQUE Types</h3>
               <div>
                  <p>Oracle OPAQUE types are abstract data types. With data implemented as simply a series of bytes, the internal representation is not exposed. Typically an OPAQUE type will be provided by Oracle, not implemented by a customer.</p>
                  <p>OPAQUE types are similar in some basic ways to object types, with similar concepts of static methods, instances, and instance methods. Typically, only the methods supplied with an OPAQUE type allow you to manipulate the state and internal byte representation. In Java, an OPAQUE type can be represented as <code class="codeph">oracle.sql.OPAQUE</code> or as a custom class implementing the <code class="codeph">oracle.sql.ORAData</code> interface. On the client-side, Java code can be implemented to manipulate the bytes, assuming the byte pattern is known.
                  </p>
                  <p>A key example of an OPAQUE type is <code class="codeph">XMLType</code>, provided with Oracle Database 12<span class="italic">c </span>Release 2 (12.2). This Oracle-provided type facilitates handling XML data natively in the database.
                  </p>
                  <p><code class="codeph">SYS.XMLType</code> offers the following features, exposed through the Java <code class="codeph">oracle.xdb.XMLType</code> class:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>It can be used as the data type of a column in a table or view. <code class="codeph">XMLType</code> can store any content but is designed to optimally store XML content. An instance of it can represent an XML document in SQL.
                        </p>
                     </li>
                     <li>
                        <p>It has a SQL API with built-in member functions that operate on XML content. For example, you can use <code class="codeph">XMLType</code> functions to create, query, extract, and index XML data stored in an Oracle Database 12<span class="italic">c </span>Release 1 (12.1) instance.
                        </p>
                     </li>
                     <li>
                        <p>It can be used in stored procedures for parameters, return values, and variables.</p>
                     </li>
                     <li>
                        <p>Its functionality is also available through APIs provided in PL/SQL, Java, and C (OCI).</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4__GUID-F648856C-579D-4A37-A61E-A85176A1790F">
                     <p class="notep1">See Also:</p>
                     <p><a href="../adxdb/XML-DB-basics.html#ADXDB-GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" target="_blank"><span class="italic">Oracle XML DB Developer's Guide</span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>