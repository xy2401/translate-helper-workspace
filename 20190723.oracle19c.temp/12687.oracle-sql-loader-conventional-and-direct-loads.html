<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="SQL*Loader provides a conventional path load method and a direct path load method.">
      <meta name="description" content="SQL*Loader provides a conventional path load method and a direct path load method.">
      <title>Conventional and Direct Path Loads</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Utilities ">
      <meta property="og:description" content="SQL*Loader provides a conventional path load method and a direct path load method.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Utilities">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96081-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="loading-objects-oracle-sql-loader.html" title="Previous" type="text/html">
      <link rel="next" href="oracle-sql-loader-express-mode.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities">
    <meta name="dcterms.isVersionOf" content="SUTIL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="loading-objects-oracle-sql-loader.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="oracle-sql-loader-express-mode.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Utilities </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-sql-loader.html" property="item" typeof="WebPage"><span property="name"> SQL*Loader</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Conventional and Direct Path Loads</li>
            </ol>
            <a id="GUID-321928FB-C86C-4F1F-9250-05111A988B7B" name="GUID-321928FB-C86C-4F1F-9250-05111A988B7B"></a><a id="SUTIL009"></a>
            
            <h2 id="SUTIL-GUID-321928FB-C86C-4F1F-9250-05111A988B7B" class="sect2"><span class="enumeration_chapter">12 </span> Conventional and Direct Path Loads
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>SQL*Loader provides a conventional path load method and a direct path load method. </p>
               <p>Further information about each method is provided in the following topics:</p>
               <p>For an example of using the direct path load method, see case study 6, Loading Data Using the Direct Path Load Method. The other cases use the conventional path load method. (See <a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL*Loader features are illustrated in a variety of case studies.">SQL*Loader Case Studies</a> for information on how to access case studies.)
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-9787AA3E-1640-4039-BB98-8374BE3553A2">Data Loading Methods</a><br>SQL*Loader can load data using either a convention path load or a direct path load.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C">Conventional Path Load</a><br>Conventional path load (the default) uses the SQL <code class="codeph">INSERT</code> statement and a bind array buffer to load data into database tables.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552">Direct Path Load</a><br>A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2">Using Direct Path Load</a><br>This section explains how to use the SQL*Loader direct path load method. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF">Optimizing Performance of Direct Path Loads</a><br>You can control the time and temporary storage used during direct path loads.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF">Optimizing Direct Path Loads on Multiple-CPU Systems</a><br>If you are performing direct path loads on a multiple-CPU system, then SQL*Loader uses multithreading by default. A multiple-CPU system in this case is defined as a single system that has two or more CPUs.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418">Avoiding Index Maintenance</a><br>For both the conventional path and the direct path, SQL*Loader maintains all existing indexes for a table.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE">Direct Path Loads, Integrity Constraints, and Triggers</a><br>With the conventional path load method, arrays of rows are inserted with standard SQL <code class="codeph">INSERT</code> statements; integrity constraints and insert triggers are automatically applied. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887">Parallel Data Loading Models</a><br>This topic describes parallel data loading models.
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C">General Performance Improvement Hints</a><br>This topic describes hints for general performance improvements.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="oracle-sql-loader.html#GUID-8D037494-07FA-4226-B507-E1B2ED10C144">SQL*Loader</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL3404"></a><a id="SUTIL1283"></a><div class="props_rev_3"><a id="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" name="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2"></a><h3 id="SUTIL-GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" class="sect3"><span class="enumeration_section">12.1 </span>Data Loading Methods
               </h3>
               <div>
                  <p>SQL*Loader can load data using either a convention path load or a direct path load.</p>
                  <p>A conventional path load executes SQL <code class="codeph">INSERT</code> statements to populate tables in an Oracle database. A direct path load eliminates much of the Oracle database overhead by formatting Oracle data blocks and writing the data blocks directly to the database files. A direct load does not compete with other users for database resources, so it can usually load data at near disk speed.
                  </p>
                  <p>The tables to be loaded must already exist in the database. SQL*Loader never creates tables. It loads existing tables that either already contain data or are empty.</p>
                  <p>The following privileges are required for a load:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You must have <code class="codeph">INSERT</code> privileges on the table to be loaded.
                        </p>
                     </li>
                     <li>
                        <p>You must have <code class="codeph">DELETE</code> privileges on the table to be loaded, when using the <code class="codeph">REPLACE</code> or <code class="codeph">TRUNCATE</code> option to empty old data from the table before loading the new data in its place.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-628A6D43-DA99-4677-9B88-445928933246">Loading ROWID Columns</a><br>In both conventional path and direct path, you can specify a text value for a <code class="codeph">ROWID</code> column.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2__GUID-E702EDA9-D948-4E03-BE20-AA052B1B312D">
                     <p class="notep1">See Also:</p>
                     <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="Conventional path load (the default) uses the SQL INSERT statement and a bind array buffer to load data into database tables.">Conventional Path Load</a></p>
                     <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1284"></a><div class="props_rev_3"><a id="GUID-628A6D43-DA99-4677-9B88-445928933246" name="GUID-628A6D43-DA99-4677-9B88-445928933246"></a><h4 id="SUTIL-GUID-628A6D43-DA99-4677-9B88-445928933246" class="sect4"><span class="enumeration_section">12.1.1 </span>Loading ROWID Columns
                  </h4>
                  <div>
                     <p>In both conventional path and direct path, you can specify a text value for a <code class="codeph">ROWID</code> column.
                     </p>
                     <p>This is the same text you get when you perform a <code class="codeph">SELECT</code> <code class="codeph">ROWID</code> <code class="codeph">FROM</code> <code class="codeph">table_name</code> operation. The character string interpretation of the <code class="codeph">ROWID</code> is converted into the <code class="codeph">ROWID</code> type for a column in a table.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" title="SQL*Loader can load data using either a convention path load or a direct path load.">Data Loading Methods</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1285"></a><div class="props_rev_3"><a id="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" name="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C"></a><h3 id="SUTIL-GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" class="sect3"><span class="enumeration_section">12.2 </span>Conventional Path Load
               </h3>
               <div>
                  <p>Conventional path load (the default) uses the SQL <code class="codeph">INSERT</code> statement and a bind array buffer to load data into database tables.
                  </p>
                  <p>When SQL*Loader performs a conventional path load, it competes equally with all other processes for buffer resources. This can slow the load significantly. Extra overhead is added as SQL statements are generated, passed to Oracle Database, and executed.</p>
                  <p>Oracle Database looks for partially filled blocks and attempts to fill them on each insert. Although appropriate during normal use, this can slow bulk loads dramatically.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B">Conventional Path Load of a Single Partition</a><br>SQL*Loader uses the partition-extended syntax of the <code class="codeph">INSERT</code> statement.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A8911483-65C5-4348-886C-1C607CACA486">When to Use a Conventional Path Load</a><br>How to determine when you should use conventional path load instead of direct path load.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C__GUID-217E8FAE-0918-4C27-8FF8-EABC6C77FC37">
                     <p class="notep1">See Also:</p>
                     <p><a href="oracle-sql-loader-control-file-contents.html#GUID-80B5F24F-9FCE-4502-B8BD-2260F25036F0" title="In a conventional path load, data is committed after all data in the bind array is loaded into all tables.">Discontinued Conventional Path Loads</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1286"></a><div class="props_rev_3"><a id="GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B" name="GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B"></a><h4 id="SUTIL-GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B" class="sect4"><span class="enumeration_section">12.2.1 </span>Conventional Path Load of a Single Partition
                  </h4>
                  <div>
                     <p>SQL*Loader uses the partition-extended syntax of the <code class="codeph">INSERT</code> statement.
                     </p>
                     <p>By definition, a conventional path load uses SQL <code class="codeph">INSERT</code> statements. During a conventional path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code class="codeph">INSERT</code> statement, which has the following form: 
                     </p><pre class="oac_no_warn" dir="ltr">INSERT INTO TABLE T PARTITION (P) VALUES ... </pre><p>The SQL layer of the Oracle kernel determines if the row being inserted maps to the specified partition. If the row does not map to the partition, then the row is rejected, and the SQL*Loader log file records an appropriate error message. </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="Conventional path load (the default) uses the SQL INSERT statement and a bind array buffer to load data into database tables.">Conventional Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1287"></a><div class="props_rev_3"><a id="GUID-A8911483-65C5-4348-886C-1C607CACA486" name="GUID-A8911483-65C5-4348-886C-1C607CACA486"></a><h4 id="SUTIL-GUID-A8911483-65C5-4348-886C-1C607CACA486" class="sect4"><span class="enumeration_section">12.2.2 </span>When to Use a Conventional Path Load
                  </h4>
                  <div>
                     <p>How to determine when you should use conventional path load instead of direct path load.</p>
                     <p>If load speed is most important to you, then you should use direct path load because it is faster than conventional path load. However, certain restrictions on direct path loads may require you to use a conventional path load. You should use a conventional path load in the following situations:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>When accessing an indexed table concurrently with the load, or when applying inserts or updates to a nonindexed table concurrently with the load</p>
                           <p>To use a direct path load (except for parallel loads), SQL*Loader must have exclusive write access to the table and exclusive read/write access to any indexes.</p>
                        </li>
                        <li>
                           <p>When loading data into a clustered table</p>
                           <p>A direct path load does not support loading of clustered tables.</p>
                        </li>
                        <li>
                           <p>When loading a relatively small number of rows into a large indexed table</p>
                           <p>During a direct path load, the existing index is copied when it is merged with the new index keys. If the existing index is very large and the number of new keys is very small, then the index copy time can offset the time saved by a direct path load.</p>
                        </li>
                        <li>
                           <p>When loading a relatively small number of rows into a large table with referential and column-check integrity constraints</p>
                           <p>Because these constraints cannot be applied to rows loaded on the direct path, they are disabled for the duration of the load. Then they are applied to the whole table when the load completes. The costs could outweigh the savings for a very large table and a small number of new rows. </p>
                        </li>
                        <li>
                           <p>When loading records and you want to ensure that a record is rejected under any of the following circumstances:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If the record, upon insertion, causes an Oracle error</p>
                              </li>
                              <li>
                                 <p>If the record is formatted incorrectly, so that SQL*Loader cannot find field boundaries</p>
                              </li>
                              <li>
                                 <p>If the record violates a constraint or tries to make a unique index non-unique</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="Conventional path load (the default) uses the SQL INSERT statement and a bind array buffer to load data into database tables.">Conventional Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1288"></a><div class="props_rev_3"><a id="GUID-26686C49-D768-4F55-8AED-771B9A8C6552" name="GUID-26686C49-D768-4F55-8AED-771B9A8C6552"></a><h3 id="SUTIL-GUID-26686C49-D768-4F55-8AED-771B9A8C6552" class="sect3"><span class="enumeration_section">12.3 </span>Direct Path Load
               </h3>
               <div>
                  <p>A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.</p>
                  <p>Instead of filling a bind array buffer and passing it to the Oracle database with a SQL <code class="codeph">INSERT </code>statement, a direct path load uses the direct path API to pass the data to be loaded to the load engine in the server. The load engine builds a column array structure from the data passed to it. 
                  </p>
                  <p>The direct path load engine uses the column array structure to format Oracle data blocks and build index keys. The newly formatted database blocks are written directly to the database (multiple blocks per I/O request using asynchronous writes if the host platform supports asynchronous I/O).</p>
                  <p>Internally, multiple buffers are used for the formatted blocks. While one buffer is being filled, one or more buffers are being written if asynchronous I/O is available on the host platform. Overlapping computation with I/O increases load performance.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9">Data Conversion During Direct Path Loads</a><br>During a direct path load, data conversion occurs on the client side rather than on the server side. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9">Direct Path Load of a Partitioned or Subpartitioned Table</a><br>When loading a partitioned or subpartitioned table, SQL*Loader partitions the rows and maintains indexes (which can also be partitioned). 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9">Direct Path Load of a Single Partition or Subpartition</a><br>During a direct path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code class="codeph">LOAD</code> statement.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5">Advantages of a Direct Path Load</a><br>This topic describes the advantages of using a direct path load.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-993D209A-23CC-466D-B8C7-D508C17C921A">Restrictions on Using Direct Path Loads</a><br>There are restrictions on using direct path loads.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703">Restrictions on a Direct Path Load of a Single Partition</a><br>There are restrictions on a direct path load of a single partition.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB">When to Use a Direct Path Load</a><br>How to determine if you should use direct path load.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447">Integrity Constraints</a><br>All integrity constraints are enforced during direct path loads, although not necessarily at the same time. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B">Field Defaults on the Direct Path</a><br>Default column specifications defined in the database are not available when you use direct path loading. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08">Loading into Synonyms</a><br>You can load data into a synonym for a table during a direct path load, but the synonym must point directly to either a table or a view on a simple table. 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-26686C49-D768-4F55-8AED-771B9A8C6552__GUID-8AF64859-21A2-4C25-9269-D38C287D47C2">
                     <p class="notep1">See Also:</p>
                     <p><a href="oracle-sql-loader-control-file-contents.html#GUID-7A1B84EC-5BCD-4601-9C4A-654F1987D94F" title="In a direct path load, the behavior of a discontinued load varies depending on the reason the load was discontinued.">Discontinued Direct Path Loads</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3405"></a><a id="SUTIL3406"></a><a id="SUTIL1289"></a><div class="props_rev_3"><a id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9" name="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9"></a><h4 id="SUTIL-GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9" class="sect4"><span class="enumeration_section">12.3.1 </span>Data Conversion During Direct Path Loads
                  </h4>
                  <div>
                     <p>During a direct path load, data conversion occurs on the client side rather than on the server side. </p>
                     <p>This means that NLS parameters in the initialization parameter file (server-side language handle) will not be used. To override this behavior, you can specify a format mask in the SQL*Loader control file that is equivalent to the setting of the NLS parameter in the initialization parameter file, or set the appropriate environment variable. For example, to specify a date format for a field, you can either set the date format in the SQL*Loader control file as shown in <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011154">Example 12-1</a> or set an <code class="codeph">NLS_DATE_FORMAT</code> environment variable as shown in <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011158">Example 12-2</a>.
                     </p>
                     <div class="example" id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011154">
                        <p class="titleinexample">Example 12-1 Setting the Date Format in the SQL*Loader Control File</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'data.dat'
INSERT INTO TABLE emp
FIELDS TERMINATED BY "|"
(
EMPNO NUMBER(4) NOT NULL,
ENAME CHAR(10),
JOB CHAR(9),
MGR NUMBER(4),
HIREDATE DATE 'YYYYMMDD',
SAL NUMBER(7,2),
COMM NUMBER(7,2),
DEPTNO NUMBER(2)
)</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011158">
                        <p class="titleinexample">Example 12-2 Setting an NLS_DATE_FORMAT Environment Variable</p>
                        <p>On UNIX Bourne or Korn shell:</p><pre class="oac_no_warn" dir="ltr">% NLS_DATE_FORMAT='YYYYMMDD'
% export NLS_DATE_FORMAT
</pre><p>On UNIX csh:</p><pre class="oac_no_warn" dir="ltr">%setenv NLS_DATE_FORMAT='YYYYMMDD'</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1290"></a><div class="props_rev_3"><a id="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9" name="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9"></a><h4 id="SUTIL-GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9" class="sect4"><span class="enumeration_section">12.3.2 </span>Direct Path Load of a Partitioned or Subpartitioned Table
                  </h4>
                  <div>
                     <p>When loading a partitioned or subpartitioned table, SQL*Loader partitions the rows and maintains indexes (which can also be partitioned). </p>
                     <p>Note that a direct path load of a partitioned or subpartitioned table can be quite resource-intensive for tables with many partitions or subpartitions.</p>
                     <div class="infoboxnote" id="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9__GUID-0E01F7EC-7E2F-4869-A7DA-8DD6EFEBE2CB">
                        <p class="notep1">Note:</p>
                        <p>If you are performing a direct path load into multiple partitions and a space error occurs, then the load is rolled back to the last commit point. If there was no commit point, then the entire load is rolled back. This ensures that no data encountered after the space error is written out to a different partition.</p>
                        <p>You can use the <code class="codeph">ROWS</code> parameter to specify the frequency of the commit points. If the <code class="codeph">ROWS</code> parameter is not specified, then the entire load is rolled back.
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1291"></a><div class="props_rev_3"><a id="GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9" name="GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9"></a><h4 id="SUTIL-GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9" class="sect4"><span class="enumeration_section">12.3.3 </span>Direct Path Load of a Single Partition or Subpartition
                  </h4>
                  <div>
                     <p>During a direct path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code class="codeph">LOAD</code> statement.
                     </p>
                     <p>When loading a single partition of a partitioned or subpartitioned table, SQL*Loader partitions the rows and rejects any rows that do not map to the partition or subpartition specified in the SQL*Loader control file. Local index partitions that correspond to the data partition or subpartition being loaded are maintained by SQL*Loader. Global indexes are not maintained on single partition or subpartition direct path loads. During a direct path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code class="codeph">LOAD</code> statement, which has either of the following forms: 
                     </p><pre class="oac_no_warn" dir="ltr">LOAD INTO TABLE T PARTITION (P) VALUES ... 

LOAD INTO TABLE T SUBPARTITION (P) VALUES ... 
</pre><p>While you are loading a partition of a partitioned or subpartitioned table, you are also allowed to perform DML operations on, and direct path loads of, other partitions in the table.</p>
                     <p>Although a direct path load minimizes database processing, several calls to the Oracle database are required at the beginning and end of the load to initialize and finish the load, respectively. Also, certain DML locks are required during load initialization and are released when the load completes. The following operations occur during the load: index keys are built and put into a sort, and space management routines are used to get new extents when needed and to adjust the upper boundary (high-water mark)<span class="italic"> </span>for a data savepoint. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="You can use data saves to protect against loss of data due to instance failure.">Using Data Saves to Protect Against Data Loss</a> for information about adjusting the upper boundary.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1292"></a><div class="props_rev_3"><a id="GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5" name="GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5"></a><h4 id="SUTIL-GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5" class="sect4"><span class="enumeration_section">12.3.4 </span>Advantages of a Direct Path Load
                  </h4>
                  <div>
                     <p>This topic describes the advantages of using a direct path load.</p>
                     <p>A direct path load is faster than the conventional path for the following reasons:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Partial blocks are not used, so no reads are needed to find them, and fewer writes are performed.</p>
                        </li>
                        <li>
                           <p>SQL*Loader need not execute any SQL <code class="codeph">INSERT</code> statements; therefore, the processing load on the Oracle database is reduced.
                           </p>
                        </li>
                        <li>
                           <p>A direct path load calls on Oracle to lock tables and indexes at the start of the load and releases them when the load is finished. A conventional path load calls Oracle once for each array of rows to process a SQL <code class="codeph">INSERT</code> statement.
                           </p>
                        </li>
                        <li>
                           <p>A direct path load uses multiblock asynchronous I/O for writes to the database files.</p>
                        </li>
                        <li>
                           <p>During a direct path load, processes perform their own write I/O, instead of using Oracle's buffer cache. This minimizes contention with other Oracle users. </p>
                        </li>
                        <li>
                           <p>The sorted indexes option available during direct path loads enables you to presort data using high-performance sort routines that are native to your system or installation.</p>
                        </li>
                        <li>
                           <p>When a table to be loaded is empty, the presorting option eliminates the sort and merge phases of index-building. The index is filled in as data arrives.</p>
                        </li>
                        <li>
                           <p>Protection against instance failure does not require redo log file entries during direct path loads. Therefore, no time is required to log the load when:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The Oracle database has the SQL <code class="codeph">NOARCHIVELOG</code> parameter enabled
                                 </p>
                              </li>
                              <li>
                                 <p>The SQL*Loader <code class="codeph">UNRECOVERABLE</code> clause is enabled
                                 </p>
                              </li>
                              <li>
                                 <p>The object being loaded has the SQL <code class="codeph">NOLOGGING</code> parameter set
                                 </p>
                              </li>
                           </ul>
                           <p>See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" title="Because SQL*Loader writes directly to the database files, all rows inserted up to the last data save will automatically be present in the database files if the instance is restarted.">Instance Recovery and Direct Path Loads</a>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1293"></a><div class="props_rev_3"><a id="GUID-993D209A-23CC-466D-B8C7-D508C17C921A" name="GUID-993D209A-23CC-466D-B8C7-D508C17C921A"></a><h4 id="SUTIL-GUID-993D209A-23CC-466D-B8C7-D508C17C921A" class="sect4"><span class="enumeration_section">12.3.5 </span>Restrictions on Using Direct Path Loads
                  </h4>
                  <div>
                     <p>There are restrictions on using direct path loads.</p>
                     <div class="section">
                        <p>The following conditions must be satisfied for you to use the direct path load method:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Tables to be loaded cannot be clustered.</p>
                           </li>
                           <li>
                              <p>Tables to be loaded cannot have Oracle Virtual Private Database (VPD) policies active on INSERT.</p>
                           </li>
                           <li>
                              <p>Segments to be loaded cannot have any active transactions pending.</p>
                              <p>To check for this condition, use the Oracle Enterprise Manager command <code class="codeph">MONITOR</code> <code class="codeph">TABLE</code> to find the object ID for the tables you want to load. Then use the command <code class="codeph">MONITOR</code> <code class="codeph">LOCK</code> to see if there are any locks on the tables.
                              </p>
                           </li>
                           <li>
                              <p>For releases of the database earlier than Oracle9<span class="italic">i</span>, you can perform a SQL*Loader direct path load only when the client and server are the same release. This also means that you cannot perform a direct path load of Oracle9<span class="italic">i</span> data into a database of an earlier release. For example, you cannot use direct path load to load data from a release 9.0.1 database into a release 8.1.7 database.
                              </p>
                              <p>Beginning with Oracle9<span class="italic">i</span>, you can perform a SQL*Loader direct path load when the client and server are different releases. However, both releases must be at least release 9.0.1 and the client release must be the same as or lower than the server release. For example, you can perform a direct path load from a release 9.0.1 database into a release 9.2 database. However, you cannot use direct path load to load data from a release 10.0.0 database into a release 9.2 database.
                              </p>
                           </li>
                        </ul>
                        <p>The following features are not available with direct path load:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Loading <code class="codeph">BFILE</code> columns
                              </p>
                           </li>
                           <li>
                              <p>Use of <code class="codeph">CREATE SEQUENCE</code> during the load. This is because in direct path loads there is no SQL being generated to fetch the next value since direct path does not generate <code class="codeph">INSERT</code> statements.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1294"></a><div class="props_rev_3"><a id="GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703" name="GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703"></a><h4 id="SUTIL-GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703" class="sect4"><span class="enumeration_section">12.3.6 </span>Restrictions on a Direct Path Load of a Single Partition
                  </h4>
                  <div>
                     <p>There are restrictions on a direct path load of a single partition.</p>
                     <div class="section">
                        <p>In addition to the previously listed restrictions, loading a single partition has the following restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The table that the partition is a member of cannot have any global indexes defined on it.</p>
                           </li>
                           <li>
                              <p>Enabled referential and check constraints on the table that the partition is a member of are not allowed. </p>
                           </li>
                           <li>
                              <p>Enabled triggers are not allowed. </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1295"></a><div class="props_rev_3"><a id="GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB" name="GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB"></a><h4 id="SUTIL-GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB" class="sect4"><span class="enumeration_section">12.3.7 </span>When to Use a Direct Path Load
                  </h4>
                  <div>
                     <p>How to determine if you should use direct path load.</p>
                     <p>If none of the previous restrictions apply, then you should use a direct path load when:<span class="bold"></span></p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You have a large amount of data to load quickly. A direct path load can quickly load and index large amounts of data. It can also load data into either an empty or nonempty table.</p>
                        </li>
                        <li>
                           <p>You want to load data in parallel for maximum performance. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1296"></a><div class="props_rev_3"><a id="GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447" name="GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447"></a><h4 id="SUTIL-GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447" class="sect4"><span class="enumeration_section">12.3.8 </span>Integrity Constraints
                  </h4>
                  <div>
                     <p>All integrity constraints are enforced during direct path loads, although not necessarily at the same time. </p>
                     <p><code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints are enforced during the load. Records that fail these constraints are rejected.
                     </p>
                     <p><code class="codeph">UNIQUE</code> constraints are enforced both during and after the load. A record that violates a <code class="codeph">UNIQUE</code> constraint is not rejected (the record is not available in memory when the constraint violation is detected).
                     </p>
                     <p>Integrity constraints that depend on other rows or tables, such as referential constraints, are disabled before the direct path load and must be reenabled afterwards. If <code class="codeph">REENABLE</code> is specified, then SQL*Loader can reenable them automatically at the end of the load. When the constraints are reenabled, the entire table is checked. Any rows that fail this check are reported in the specified error log. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="With the conventional path load method, arrays of rows are inserted with standard SQL INSERT statements; integrity constraints and insert triggers are automatically applied.">Direct Path Loads_ Integrity Constraints_ and Triggers</a>.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1297"></a><div class="props_rev_3"><a id="GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B" name="GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B"></a><h4 id="SUTIL-GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B" class="sect4"><span class="enumeration_section">12.3.9 </span>Field Defaults on the Direct Path
                  </h4>
                  <div>
                     <p>Default column specifications defined in the database are not available when you use direct path loading. </p>
                     <p>Fields for which default values are desired must be specified with the <code class="codeph">DEFAULTIF</code> clause. If a <code class="codeph">DEFAULTIF</code> clause is not specified and the field is <code class="codeph">NULL</code>, then a null value is inserted into the database.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1298"></a><div class="props_rev_3"><a id="GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08" name="GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08"></a><h4 id="SUTIL-GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08" class="sect4"><span class="enumeration_section">12.3.10 </span>Loading into Synonyms
                  </h4>
                  <div>
                     <p>You can load data into a synonym for a table during a direct path load, but the synonym must point directly to either a table or a view on a simple table. </p>
                     <div class="section">
                        <p>Note the following restrictions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Direct path mode cannot be used if the view is on a table that has user-defined types or XML data.</p>
                           </li>
                           <li>
                              <p>In direct path mode, a view cannot be loaded using a SQL*Loader control file that contains SQL expressions.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="A direct path load uses the direct path API to pass the data to be loaded to the load engine in the server.">Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1299"></a><div class="props_rev_3"><a id="GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" name="GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2"></a><h3 id="SUTIL-GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" class="sect3"><span class="enumeration_section">12.4 </span>Using Direct Path Load
               </h3>
               <div>
                  <p>This section explains how to use the SQL*Loader direct path load method. </p>
                  <p>It contains the following sections:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1">Setting Up for Direct Path Loads</a><br>To prepare the database for direct path loads, you must run the setup script, <code class="codeph">catldr</code>.<code class="codeph">sql</code>, to create the necessary views. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A491440D-63A4-4781-9292-B822DDDF9BF3">Specifying a Direct Path Load</a><br>To start SQL*Loader in direct path load mode, set the <code class="codeph">DIRECT</code> parameter to <code class="codeph">TRUE</code> on the command line or in the parameter file.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF">Building Indexes</a><br>You can improve performance of direct path loads by using temporary storage. After each block is formatted, the new index keys are put in a sort (temporary) segment. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB">Indexes Left in an Unusable State</a><br>SQL*Loader leaves indexes in an Index Unusable state when the data segment being loaded becomes more up-to-date than the index segments that index it.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0">Using Data Saves to Protect Against Data Loss</a><br>You can use data saves to protect against loss of data due to instance failure. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42">Data Recovery During Direct Path Loads</a><br>SQL*Loader provides full support for data recovery when using the direct path load method. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-88000EF3-410E-49BC-931B-690B3444610A">Loading Long Data Fields</a><br>Data that is longer than SQL*Loader's maximum buffer size can be loaded on the direct path by using LOBs. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF">Auditing SQL*Loader Operations That Use Direct Path Mode</a><br>You can perform auditing on SQL*Loader direct path loads to monitor and record selected user database actions. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1300"></a><div class="props_rev_3"><a id="GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1" name="GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1"></a><h4 id="SUTIL-GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1" class="sect4"><span class="enumeration_section">12.4.1 </span>Setting Up for Direct Path Loads
                  </h4>
                  <div>
                     <p>To prepare the database for direct path loads, you must run the setup script, <code class="codeph">catldr</code>.<code class="codeph">sql</code>, to create the necessary views. 
                     </p>
                     <div class="section">
                        <p>You need only run this script once for each database you plan to do direct loads to. You can run this script during database installation if you know then that you will be doing direct loads.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1301"></a><div class="props_rev_3"><a id="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3" name="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3"></a><h4 id="SUTIL-GUID-A491440D-63A4-4781-9292-B822DDDF9BF3" class="sect4"><span class="enumeration_section">12.4.2 </span>Specifying a Direct Path Load
                  </h4>
                  <div>
                     <p>To start SQL*Loader in direct path load mode, set the <code class="codeph">DIRECT</code> parameter to <code class="codeph">TRUE</code> on the command line or in the parameter file.
                     </p>
                     <div class="section">
                        <p>For example, in the format:</p><pre class="oac_no_warn" dir="ltr">DIRECT=TRUE</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3__GUID-97AA6BE3-D7A4-4247-99BD-AEDBA2212DC4">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a> for information about parameters you can use to optimize performance of direct path loads
                              </p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" title="If you are performing direct path loads on a multiple-CPU system, then SQL*Loader uses multithreading by default. A multiple-CPU system in this case is defined as a single system that has two or more CPUs.">Optimizing Direct Path Loads on Multiple-CPU Systems</a> if you are doing a direct path load on a multiple-CPU system or across systems
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1302"></a><div class="props_rev_3"><a id="GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" name="GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF"></a><h4 id="SUTIL-GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" class="sect4"><span class="enumeration_section">12.4.3 </span>Building Indexes
                  </h4>
                  <div>
                     <p>You can improve performance of direct path loads by using temporary storage. After each block is formatted, the new index keys are put in a sort (temporary) segment. </p>
                     <p>The old index and the new keys are merged at load finish time to create the new index. The old index, sort (temporary) segment, and new index segment all require storage until the merge is complete. Then the old index and temporary segment are removed.</p>
                     <p>During a conventional path load, every time a row is inserted the index is updated. This method does not require temporary storage space, but it does add processing time.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685">Improving Performance</a><br>To improve performance on systems with limited memory, use the <code class="codeph">SINGLEROW</code> parameter. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CD74D1FF-E22E-4158-B10D-A06B01018488">Temporary Segment Storage Requirements</a><br>Estimating the amount of temporary segment storage requirements.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1303"></a><div class="props_rev_3"><a id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685" name="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685"></a><h5 id="SUTIL-GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685" class="sect5"><span class="enumeration_section">12.4.3.1 </span>Improving Performance
                     </h5>
                     <div>
                        <p>To improve performance on systems with limited memory, use the <code class="codeph">SINGLEROW</code> parameter. 
                        </p>
                        <p>For more information, see <a href="oracle-sql-loader-control-file-contents.html#GUID-95669C8F-F9A1-4CE4-A83E-DE636E12AE37">SINGLEROW Option</a>.
                        </p>
                        <div class="infoboxnote" id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685__GUID-B4E6339E-56DD-4679-875A-F31F4E9C515D">
                           <p class="notep1">Note:</p>
                           <p>If, during a direct load, you have specified that the data is to be presorted and the existing index is empty, then a temporary segment is not required, and no merge occursthe keys are put directly into the index. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a> for more information.
                           </p>
                        </div>
                        <p>When multiple indexes are built, the temporary segments corresponding to each index exist simultaneously, in addition to the old indexes. The new keys are then merged with the old indexes, one index at a time. As each new index is created, the old index and the corresponding temporary segment are removed.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685__GUID-61EFF2A1-51AD-4102-821E-1A2AD28C77D8">
                           <p class="notep1">See Also:</p>
                           <p><a href="../admin/managing-indexes.html#ADMIN11716" target="_blank"><span class="italic"> Oracle Database Administrator's Guide </span></a>for information about how to estimate index size and set storage parameters
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" title="You can improve performance of direct path loads by using temporary storage. After each block is formatted, the new index keys are put in a sort (temporary) segment.">Building Indexes</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1304"></a><div class="props_rev_3"><a id="GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" name="GUID-CD74D1FF-E22E-4158-B10D-A06B01018488"></a><h5 id="SUTIL-GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" class="sect5"><span class="enumeration_section">12.4.3.2 </span>Temporary Segment Storage Requirements
                     </h5>
                     <div>
                        <p>Estimating the amount of temporary segment storage requirements.</p>
                        <div class="section">
                           <p>To estimate the amount of temporary segment space needed for storing the new index keys (in bytes), use the following formula:</p><pre class="oac_no_warn" dir="ltr">1.3 * key_storage
</pre><p>In this formula, key storage is defined as follows:</p><pre class="oac_no_warn" dir="ltr">key_storage = (number_of_rows) *
     ( 10 + sum_of_column_sizes + number_of_columns )
</pre><p>The columns included in this formula are the columns in the index. There is one length byte per column, and 10 bytes per row are used for a <code class="codeph">ROWID</code> and additional overhead.
                           </p>
                           <p>The constant 1.3 reflects the average amount of extra space needed for sorting. This value is appropriate for most randomly ordered data. If the data arrives in exactly opposite order, then twice the key-storage space is required for sorting, and the value of this constant would be 2.0. That is the worst case. </p>
                           <p>If the data is fully sorted, then only enough space to store the index entries is required, and the value of this constant would be 1.0. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="You can improve the performance of direct path loads by presorting your data on indexed columns.">Presorting Data for Faster Indexing</a> for more information.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" title="You can improve performance of direct path loads by using temporary storage. After each block is formatted, the new index keys are put in a sort (temporary) segment.">Building Indexes</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1305"></a><div class="props_rev_3"><a id="GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" name="GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB"></a><h4 id="SUTIL-GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" class="sect4"><span class="enumeration_section">12.4.4 </span>Indexes Left in an Unusable State
                  </h4>
                  <div>
                     <p>SQL*Loader leaves indexes in an Index Unusable state when the data segment being loaded becomes more up-to-date than the index segments that index it.</p>
                     <p>Any SQL statement that tries to use an index that is in an Index Unusable state returns an error. The following conditions cause a direct path load to leave an index or a partition of a partitioned index in an Index Unusable state:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>SQL*Loader runs out of space for the index and cannot update the index.</p>
                        </li>
                        <li>
                           <p>The data is not in the order specified by the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause.
                           </p>
                        </li>
                        <li>
                           <p>There is an instance failure, or the Oracle shadow process fails while building the index.</p>
                        </li>
                        <li>
                           <p>There are duplicate keys in a unique index.</p>
                        </li>
                        <li>
                           <p>Data savepoints are being used, and the load fails or is terminated by a keyboard interrupt after a data savepoint occurred.</p>
                        </li>
                     </ul>
                     <p>To determine if an index is in an Index Unusable state, you can execute a simple query:</p><pre class="oac_no_warn" dir="ltr">SELECT INDEX_NAME, STATUS
   FROM USER_INDEXES 
   WHERE TABLE_NAME = 'tablename';
</pre><p>If you are not the owner of the table, then search <code class="codeph">ALL_INDEXES</code> or <code class="codeph">DBA_INDEXES</code> instead of <code class="codeph">USER_INDEXES</code>.
                     </p>
                     <p>To determine if an index partition is in an unusable state, you can execute the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT INDEX_NAME, 
       PARTITION_NAME,
       STATUS FROM USER_IND_PARTITIONS
       WHERE STATUS != 'VALID';
</pre><p>If you are not the owner of the table, then search <code class="codeph">ALL_IND_PARTITIONS</code> and <code class="codeph">DBA_IND_PARTITIONS</code> instead of <code class="codeph">USER_IND_PARTITIONS</code>.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1306"></a><div class="props_rev_3"><a id="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" name="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0"></a><h4 id="SUTIL-GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" class="sect4"><span class="enumeration_section">12.4.5 </span>Using Data Saves to Protect Against Data Loss
                  </h4>
                  <div>
                     <p>You can use data saves to protect against loss of data due to instance failure. </p>
                     <div class="section">
                        <p>All data loaded up to the last savepoint is protected against instance failure. To continue the load after an instance failure, determine how many rows from the input file were processed before the failure, then use the <code class="codeph">SKIP</code> parameter to skip those processed rows. 
                        </p>
                        <p>If there are any indexes on the table, drop them before continuing the load, and then re-create them after the load. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="SQL*Loader provides full support for data recovery when using the direct path load method.">Data Recovery During Direct Path Loads</a> for more information about media and instance recovery.
                        </p>
                        <div class="infoboxnote" id="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0__GUID-B3827D27-45C5-45E8-890D-E910D44DB78A">
                           <p class="notep1">Note:</p>
                           <p>Indexes are not protected by a data save, because SQL*Loader does not build indexes until after data loading completes. (The only time indexes are built during the load is when presorted data is loaded into an empty table, but these indexes are also unprotected.)</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6">Using the ROWS Parameter</a><br>The <code class="codeph">ROWS</code> parameter determines when data saves occur during a direct path load. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2562DE31-8745-40B0-AF3B-90048E5146A8">Data Save Versus Commit</a><br>In a conventional load, <code class="codeph">ROWS</code> is the number of rows to read before a commit operation. A direct load data save is similar to a conventional load commit, but it is not identical. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1307"></a><div class="props_rev_3"><a id="GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6" name="GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6"></a><h5 id="SUTIL-GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6" class="sect5"><span class="enumeration_section">12.4.5.1 </span>Using the ROWS Parameter
                     </h5>
                     <div>
                        <p>The <code class="codeph">ROWS</code> parameter determines when data saves occur during a direct path load. 
                        </p>
                        <p>The value you specify for <code class="codeph">ROWS</code> is the number of rows you want SQL*Loader to read from the input file before saving inserts in the database.
                        </p>
                        <p>A data save is an expensive operation. The value for <code class="codeph">ROWS</code> should be set high enough so that a data save occurs once every 15 minutes or longer. The intent is to provide an upper boundary (high-water mark) on the amount of work that is lost when an instance failure occurs during a long-running direct path load. Setting the value of <code class="codeph">ROWS</code> to a small number adversely affects performance and data block space utilization.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="You can use data saves to protect against loss of data due to instance failure.">Using Data Saves to Protect Against Data Loss</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1308"></a><div class="props_rev_3"><a id="GUID-2562DE31-8745-40B0-AF3B-90048E5146A8" name="GUID-2562DE31-8745-40B0-AF3B-90048E5146A8"></a><h5 id="SUTIL-GUID-2562DE31-8745-40B0-AF3B-90048E5146A8" class="sect5"><span class="enumeration_section">12.4.5.2 </span>Data Save Versus Commit
                     </h5>
                     <div>
                        <p>In a conventional load, <code class="codeph">ROWS</code> is the number of rows to read before a commit operation. A direct load data save is similar to a conventional load commit, but it is not identical. 
                        </p>
                        <p>The similarities are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A data save will make the rows visible to other users.</p>
                           </li>
                           <li>
                              <p>Rows cannot be rolled back after a data save.</p>
                           </li>
                        </ul>
                        <p>The major difference is that in a direct path load data save, the indexes will be unusable (in Index Unusable state) until the load completes.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="You can use data saves to protect against loss of data due to instance failure.">Using Data Saves to Protect Against Data Loss</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1309"></a><div class="props_rev_3"><a id="GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" name="GUID-4DB99887-0E58-476A-9A81-4E865DF62C42"></a><h4 id="SUTIL-GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" class="sect4"><span class="enumeration_section">12.4.6 </span>Data Recovery During Direct Path Loads
                  </h4>
                  <div>
                     <p>SQL*Loader provides full support for data recovery when using the direct path load method. </p>
                     <p>There are two main types of recovery:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Media - recovery from the loss of a database file. You must be operating in <code class="codeph">ARCHIVELOG</code> mode to recover after you lose a database file.
                           </p>
                        </li>
                        <li>
                           <p>Instance - recovery from a system failure in which in-memory data was changed but lost due to the failure before it was written to disk. The Oracle database can always recover from instance failures, even when redo logs are not archived.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB">Media Recovery and Direct Path Loads</a><br>If redo log file archiving is enabled (you are operating in <code class="codeph">ARCHIVELOG</code> mode), then SQL*Loader logs loaded data when using the direct path, making media recovery possible. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C">Instance Recovery and Direct Path Loads</a><br>Because SQL*Loader writes directly to the database files, all rows inserted up to the last data save will automatically be present in the database files if the instance is restarted. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1310"></a><div class="props_rev_3"><a id="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB" name="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB"></a><h5 id="SUTIL-GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB" class="sect5"><span class="enumeration_section">12.4.6.1 </span>Media Recovery and Direct Path Loads
                     </h5>
                     <div>
                        <p>If redo log file archiving is enabled (you are operating in <code class="codeph">ARCHIVELOG</code> mode), then SQL*Loader logs loaded data when using the direct path, making media recovery possible. 
                        </p>
                        <div class="section">
                           <p>If redo log archiving is not enabled (you are operating in <code class="codeph">NOARCHIVELOG</code> mode), then media recovery is not possible.
                           </p>
                           <p>To recover a database file that was lost while it was being loaded, use the same method that you use to recover data loaded with the conventional path:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Restore the most recent backup of the affected database file.</span></li>
                           <li class="stepexpand"><span>Recover the tablespace using the RMAN <code class="codeph">RECOVER</code> command.</span><div>
                                 <div class="infoboxnotealso" id="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB__GUID-E282037F-0970-4F72-9132-41C4DFDFC905">
                                    <p class="notep1">See Also:</p>
                                    <p><a href="../bradv/rman-complete-database-recovery.html#BRADV89773" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide </span></a>for more information about using RMAN to recover a tablespace
                                    </p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="SQL*Loader provides full support for data recovery when using the direct path load method.">Data Recovery During Direct Path Loads</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1311"></a><div class="props_rev_3"><a id="GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" name="GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C"></a><h5 id="SUTIL-GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" class="sect5"><span class="enumeration_section">12.4.6.2 </span>Instance Recovery and Direct Path Loads
                     </h5>
                     <div>
                        <p>Because SQL*Loader writes directly to the database files, all rows inserted up to the last data save will automatically be present in the database files if the instance is restarted. </p>
                        <p>Changes do not need to be recorded in the redo log file to make instance recovery possible.</p>
                        <p>If an instance failure occurs, then the indexes being built may be left in an Index Unusable state. Indexes that are Unusable must be rebuilt before you can use the table or partition. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" title="SQL*Loader leaves indexes in an Index Unusable state when the data segment being loaded becomes more up-to-date than the index segments that index it.">Indexes Left in an Unusable State</a> for information about how to determine if an index has been left in Index Unusable state.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="SQL*Loader provides full support for data recovery when using the direct path load method.">Data Recovery During Direct Path Loads</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1312"></a><div class="props_rev_3"><a id="GUID-88000EF3-410E-49BC-931B-690B3444610A" name="GUID-88000EF3-410E-49BC-931B-690B3444610A"></a><h4 id="SUTIL-GUID-88000EF3-410E-49BC-931B-690B3444610A" class="sect4"><span class="enumeration_section">12.4.7 </span>Loading Long Data Fields
                  </h4>
                  <div>
                     <p>Data that is longer than SQL*Loader's maximum buffer size can be loaded on the direct path by using LOBs. </p>
                     <p>You can improve performance when doing this by using a large <code class="codeph">STREAMSIZE</code> value. 
                     </p>
                     <div class="infoboxnotealso" id="GUID-88000EF3-410E-49BC-931B-690B3444610A__GUID-A98737A3-F239-4D42-97C9-E3ADEDBDC616">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="The section describes loading LOBs.">Loading LOBs</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" title="The number of column array rows determines the number of rows loaded before the stream buffer is built. T">Specifying the Number of Column Array Rows and Size of Stream Buffers</a></p>
                           </li>
                        </ul>
                     </div>
                     <p>You could also load data that is longer than the maximum buffer size by using the <code class="codeph">PIECED</code> parameter, as described in the next section, but Oracle highly recommends that you use LOBs instead.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE">Loading Data As PIECED</a><br>The <code class="codeph">PIECED</code> parameter can be used to load data in sections, if the data is in the last column of the logical record. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1313"></a><div class="props_rev_3"><a id="GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE" name="GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE"></a><h5 id="SUTIL-GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE" class="sect5"><span class="enumeration_section">12.4.7.1 </span>Loading Data As PIECED
                     </h5>
                     <div>
                        <p>The <code class="codeph">PIECED</code> parameter can be used to load data in sections, if the data is in the last column of the logical record. 
                        </p>
                        <p>Declaring a column as <code class="codeph">PIECED</code> informs the direct path loader that a <code class="codeph">LONG</code> field might be split across multiple physical records (pieces). In such cases, SQL*Loader processes each piece of the <code class="codeph">LONG</code> field as it is found in the physical record. All the pieces are read before the record is processed. SQL*Loader makes no attempt to materialize the <code class="codeph">LONG</code> field before storing it; however, all the pieces are read before the record is processed.
                        </p>
                        <p>The following restrictions apply when you declare a column as <code class="codeph">PIECED</code>:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>This option is only valid on the direct path.</p>
                           </li>
                           <li>
                              <p>Only one field per table may be <code class="codeph">PIECED</code>.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">PIECED</code> field must be the last field in the logical record.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">PIECED</code> field may not be used in any <code class="codeph">WHEN</code>, <code class="codeph">NULLIF</code>, or <code class="codeph">DEFAULTIF</code> clauses.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">PIECED</code> field's region in the logical record must not overlap with any other field's region.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">PIECED</code> corresponding database column may not be part of the index.
                              </p>
                           </li>
                           <li>
                              <p>It may not be possible to load a rejected record from the bad file if it contains a <code class="codeph">PIECED</code> field.
                              </p>
                              <p>For example, a <code class="codeph">PIECED</code> field could span three records. SQL*Loader loads the piece from the first record and then reuses the buffer for the second buffer. After loading the second piece, the buffer is reused for the third record. If an error is discovered, then only the third record is placed in the bad file because the first two records no longer exist in the buffer. As a result, the record in the bad file would not be valid.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-88000EF3-410E-49BC-931B-690B3444610A" title="Data that is longer than SQL*Loader's maximum buffer size can be loaded on the direct path by using LOBs.">Loading Long Data Fields</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL3947"></a><div class="props_rev_3"><a id="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF" name="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF"></a><h4 id="SUTIL-GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF" class="sect4"><span class="enumeration_section">12.4.8 </span>Auditing SQL*Loader Operations That Use Direct Path Mode
                  </h4>
                  <div>
                     <p>You can perform auditing on SQL*Loader direct path loads to monitor and record selected user database actions. </p>
                     <div class="section">
                        <p>SQL*Loader uses unified auditing, in which all audit records are centralized in one place.</p>
                        <p>To set up unified auditing you create a unified audit policy or alter an existing policy. An audit policy is a named group of audit settings that enable you to audit a particular aspect of user behavior in the database. To create the policy, use the SQL <code class="codeph">CREATE AUDIT POLICY</code> statement.
                        </p>
                        <p>After creating the audit policy, use the <code class="codeph">AUDIT</code> and <code class="codeph">NOAUDIT</code> SQL statements to, respectively, enable and disable the policy.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF__GUID-321AE549-3D5C-482F-8582-A20DC43AC52F">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/CREATE-AUDIT-POLICY-Unified-Auditing.html#SQLRF56055" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the SQL <code class="codeph">CREATE AUDIT POLICY, ALTER AUDIT POLICY,AUDIT,</code> and <code class="codeph">NOAUDIT</code> statements
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=DBSEG120" target="_blank"><span class="italic">Oracle Database Security Guide</span></a> for more information about using auditing in an Oracle database
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="This section explains how to use the SQL*Loader direct path load method.">Using Direct Path Load</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1314"></a><div class="props_rev_3"><a id="GUID-C9F61197-5786-402B-A592-02515AA30FFF" name="GUID-C9F61197-5786-402B-A592-02515AA30FFF"></a><h3 id="SUTIL-GUID-C9F61197-5786-402B-A592-02515AA30FFF" class="sect3"><span class="enumeration_section">12.5 </span>Optimizing Performance of Direct Path Loads
               </h3>
               <div>
                  <p>You can control the time and temporary storage used during direct path loads.</p>
                  <p>To minimize time:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Preallocate storage space</p>
                     </li>
                     <li>
                        <p>Presort the data</p>
                     </li>
                     <li>
                        <p>Perform infrequent data saves</p>
                     </li>
                     <li>
                        <p>Minimize use of the redo log</p>
                     </li>
                     <li>
                        <p>Specify the number of column array rows and the size of the stream buffer</p>
                     </li>
                     <li>
                        <p>Specify a date cache value</p>
                     </li>
                     <li>
                        <p>Set <code class="codeph">DB_UNRECOVERABLE_SCN_TRACKING=FALSE</code>. Unrecoverable (nologging) direct writes are tracked in the control file by periodically storing the SCN and Time of the last direct write. If these updates to the control file are adversely affecting performance, then setting the <code class="codeph">DB_UNRECOVERABLE_SCN_TRACKING</code> parameter to <code class="codeph">FALSE</code> may improve performance.
                        </p>
                     </li>
                  </ul>
                  <p>To minimize space:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>When sorting data before the load, sort data on the index that requires the most temporary storage space</p>
                     </li>
                     <li>
                        <p>Avoid index maintenance during the load</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2">Preallocating Storage for Faster Loading</a><br>SQL*Loader automatically adds extents to the table if necessary, but this process takes time. For faster loads into a new table, allocate the required extents when the table is created.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64">Presorting Data for Faster Indexing</a><br>You can improve the performance of direct path loads by presorting your data on indexed columns. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE">Infrequent Data Saves</a><br>Frequent data saves resulting from a small <code class="codeph">ROWS</code> value adversely affect the performance of a direct path load. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A">Minimizing Use of the Redo Log</a><br>One way to speed a direct load dramatically is to minimize use of the redo log. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741">Specifying the Number of Column Array Rows and Size of Stream Buffers</a><br>The number of column array rows determines the number of rows loaded before the stream buffer is built. T
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F">Specifying a Value for DATE_CACHE</a><br>If you are performing a direct path load in which the same date or timestamp values are loaded many times, then a large percentage of total load time can end up being used for converting date and timestamp data. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1315"></a><div class="props_rev_3"><a id="GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2" name="GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2"></a><h4 id="SUTIL-GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2" class="sect4"><span class="enumeration_section">12.5.1 </span>Preallocating Storage for Faster Loading
                  </h4>
                  <div>
                     <p>SQL*Loader automatically adds extents to the table if necessary, but this process takes time. For faster loads into a new table, allocate the required extents when the table is created.</p>
                     <div class="section">
                        <p>To calculate the space required by a table, see the information about managing database files in the<a href="../admin/managing-tables.html#ADMIN11631" target="_blank"><span class="italic"> Oracle Database Administrator's Guide.</span></a> Then use the <code class="codeph">INITIAL</code> or <code class="codeph">MINEXTENTS</code> clause in the SQL <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> statement to allocate the required space.
                        </p>
                        <p>Another approach is to size extents large enough so that extent allocation is infrequent.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1316"></a><div class="props_rev_3"><a id="GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" name="GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64"></a><h4 id="SUTIL-GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" class="sect4"><span class="enumeration_section">12.5.2 </span>Presorting Data for Faster Indexing
                  </h4>
                  <div>
                     <p>You can improve the performance of direct path loads by presorting your data on indexed columns. </p>
                     <p>Presorting minimizes temporary storage requirements during the load. Presorting also enables you to take advantage of high-performance sorting routines that are optimized for your operating system or application.<span class="bold"></span></p>
                     <p>If the data is presorted and the existing index is not empty, then presorting minimizes the amount of temporary segment space needed for the new keys. The sort routine appends each new key to the key list. </p>
                     <p>Instead of requiring extra space for sorting, only space for the keys is needed. To calculate the amount of storage needed, use a sort factor of 1.0 instead of 1.3. For more information about estimating storage requirements, see <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" title="Estimating the amount of temporary segment storage requirements.">Temporary Segment Storage Requirements</a>.
                     </p>
                     <p>If presorting is specified and the existing index is empty, then maximum efficiency is achieved. The new keys are simply inserted into the index. Instead of having a temporary segment and new index existing simultaneously with the empty, old index, only the new index exists. So, temporary storage is not required, and time is saved.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5">SORTED INDEXES Clause</a><br>The <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause identifies the indexes on which the data is presorted. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B1099A14-206F-4667-A451-1E030B21C288">Unsorted Data</a><br>If you specify an index in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause, and the data is not sorted for that index, then the index is left in an Index Unusable state at the end of the load. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6">Multiple-Column Indexes</a><br>If you specify a multiple-column index in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause, then the data should be sorted so that it is ordered first on the first column in the index, next on the second column in the index, and so on.
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25">Choosing the Best Sort Order</a><br>For the best overall performance of direct path loads, you should presort the data based on the index that requires the most temporary segment space. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1317"></a><div class="props_rev_3"><a id="GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5" name="GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5"></a><h5 id="SUTIL-GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5" class="sect5"><span class="enumeration_section">12.5.2.1 </span>SORTED INDEXES Clause
                     </h5>
                     <div>
                        <p>The <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause identifies the indexes on which the data is presorted. 
                        </p>
                        <p>This clause is allowed only for direct path loads. See case study 6, Loading Data Using the Direct Path Load Method, for an example. (See <a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL*Loader features are illustrated in a variety of case studies.">SQL*Loader Case Studies</a> for information on how to access case studies.)
                        </p>
                        <p>Generally, you specify only one index in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause, because data that is sorted for one index is not usually in the right order for another index. When the data is in the same order for multiple indexes, however, all indexes can be specified at once.
                        </p>
                        <p>All indexes listed in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause must be created before you start the direct path load.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="You can improve the performance of direct path loads by presorting your data on indexed columns.">Presorting Data for Faster Indexing</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1318"></a><div class="props_rev_3"><a id="GUID-B1099A14-206F-4667-A451-1E030B21C288" name="GUID-B1099A14-206F-4667-A451-1E030B21C288"></a><h5 id="SUTIL-GUID-B1099A14-206F-4667-A451-1E030B21C288" class="sect5"><span class="enumeration_section">12.5.2.2 </span>Unsorted Data
                     </h5>
                     <div>
                        <p>If you specify an index in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause, and the data is not sorted for that index, then the index is left in an Index Unusable state at the end of the load. 
                        </p>
                        <p>The data is present, but any attempt to use the index results in an error. Any index that is left in an Index Unusable state must be rebuilt after the load.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="You can improve the performance of direct path loads by presorting your data on indexed columns.">Presorting Data for Faster Indexing</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1319"></a><div class="props_rev_3"><a id="GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6" name="GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6"></a><h5 id="SUTIL-GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6" class="sect5"><span class="enumeration_section">12.5.2.3 </span>Multiple-Column Indexes
                     </h5>
                     <div>
                        <p>If you specify a multiple-column index in the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause, then the data should be sorted so that it is ordered first on the first column in the index, next on the second column in the index, and so on.
                        </p>
                        <p>For example, if the first column of the index is city, and the second column is last name; then the data should be ordered by name within each city, as in the following list:</p><pre class="oac_no_warn" dir="ltr">Albuquerque      Adams
Albuquerque      Hartstein
Albuquerque      Klein
...         ...
Boston           Andrews
Boston           Bobrowski
Boston           Heigham
...              ...</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="You can improve the performance of direct path loads by presorting your data on indexed columns.">Presorting Data for Faster Indexing</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1320"></a><div class="props_rev_3"><a id="GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25" name="GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25"></a><h5 id="SUTIL-GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25" class="sect5"><span class="enumeration_section">12.5.2.4 </span>Choosing the Best Sort Order
                     </h5>
                     <div>
                        <p>For the best overall performance of direct path loads, you should presort the data based on the index that requires the most temporary segment space. </p>
                        <div class="section">
                           <p>For example, if the primary key is one numeric column, and the secondary key consists of three text columns, then you can minimize both sort time and storage requirements by presorting on the secondary key.</p>
                           <p>To determine the index that requires the most storage space, use the following procedure:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>For each index, add up the widths of all columns in that index.</span></li>
                           <li><span>For a single-table load, pick the index with the largest overall width.</span></li>
                           <li><span>For each table in a multiple-table load, identify the index with the largest overall width. If the same number of rows are to be loaded into each table, then again pick the index with the largest overall width. Usually, the same number of rows are loaded into each table.</span></li>
                           <li><span>If a different number of rows are to be loaded into the indexed tables in a multiple-table load, then multiply the width of each index identified in Step 3 by the number of rows that are to be loaded into that index, and pick the index with the largest result.</span></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="You can improve the performance of direct path loads by presorting your data on indexed columns.">Presorting Data for Faster Indexing</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1321"></a><div class="props_rev_3"><a id="GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE" name="GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE"></a><h4 id="SUTIL-GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE" class="sect4"><span class="enumeration_section">12.5.3 </span>Infrequent Data Saves
                  </h4>
                  <div>
                     <p>Frequent data saves resulting from a small <code class="codeph">ROWS</code> value adversely affect the performance of a direct path load. 
                     </p>
                     <p>A small <code class="codeph">ROWS</code> value can also result in wasted data block space because the last data block is not written to after a save, even if the data block is not full. 
                     </p>
                     <p>Because direct path loads can be many times faster than conventional loads, the value of <code class="codeph">ROWS</code> should be considerably higher for a direct load than it would be for a conventional load.
                     </p>
                     <p>During a data save, loading stops until all of SQL*Loader's buffers are successfully written. You should select the largest value for <code class="codeph">ROWS</code> that is consistent with safety. It is a good idea to determine the average time to load a row by loading a few thousand rows. Then you can use that value to select a good value for <code class="codeph">ROWS</code>.
                     </p>
                     <p>For example, if you can load 20,000 rows per minute, and you do not want to repeat more than 10 minutes of work after an interruption, then set <code class="codeph">ROWS</code> to be 200,000 (20,000 rows/minute * 10 minutes). 
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1322"></a><div class="props_rev_3"><a id="GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" name="GUID-4F224723-D836-4713-9BEE-E7B88424EB8A"></a><h4 id="SUTIL-GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" class="sect4"><span class="enumeration_section">12.5.4 </span>Minimizing Use of the Redo Log
                  </h4>
                  <div>
                     <p>One way to speed a direct load dramatically is to minimize use of the redo log. </p>
                     <p>There are three ways to do this. You can disable archiving, you can specify that the load is unrecoverable, or you can set the SQL <code class="codeph">NOLOGGING</code> parameter for the objects being loaded. This section discusses all methods.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3">Disabling Archiving</a><br>If archiving is disabled, then direct path loads do not generate full image redo. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B">Specifying the SQL*Loader UNRECOVERABLE Clause</a><br>To save time and space in the redo log file, use the SQL*Loader <code class="codeph">UNRECOVERABLE</code> clause in the control file when you load data. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0">Setting the SQL NOLOGGING Parameter</a><br>If a data or index segment has the SQL <code class="codeph">NOLOGGING</code> parameter set, then full image redo logging is disabled for that segment (invalidation redo is generated). 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1323"></a><div class="props_rev_3"><a id="GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3" name="GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3"></a><h5 id="SUTIL-GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3" class="sect5"><span class="enumeration_section">12.5.4.1 </span>Disabling Archiving
                     </h5>
                     <div>
                        <p>If archiving is disabled, then direct path loads do not generate full image redo. </p>
                        <div class="section">
                           <p>Use the SQL <code class="codeph">ARCHIVELOG</code> and <code class="codeph">NOARCHIVELOG</code> parameters to set the archiving mode. See the <a href="../admin/managing-archived-redo-log-files.html#ADMIN008" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about archiving.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="One way to speed a direct load dramatically is to minimize use of the redo log.">Minimizing Use of the Redo Log</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1324"></a><div class="props_rev_3"><a id="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B" name="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B"></a><h5 id="SUTIL-GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B" class="sect5"><span class="enumeration_section">12.5.4.2 </span>Specifying the SQL*Loader UNRECOVERABLE Clause
                     </h5>
                     <div>
                        <p>To save time and space in the redo log file, use the SQL*Loader <code class="codeph">UNRECOVERABLE</code> clause in the control file when you load data. 
                        </p>
                        <p>An unrecoverable load does not record loaded data in the redo log file; instead, it generates invalidation redo. </p>
                        <p>The <code class="codeph">UNRECOVERABLE</code> clause applies to all objects loaded during the load session (both data and index segments). Therefore, media recovery is disabled for the loaded table, although database changes by other users may continue to be logged.
                        </p>
                        <div class="infoboxnote" id="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B__GUID-2BF5E01B-6E3D-418E-875F-A6829FE89791">
                           <p class="notep1">Note:</p>
                           <p>Because the data load is not logged, you may want to make a backup of the data after loading.</p>
                        </div>
                        <p>If media recovery becomes necessary on data that was loaded with the <code class="codeph">UNRECOVERABLE</code> clause, then the data blocks that were loaded are marked as logically corrupted. 
                        </p>
                        <p>To recover the data, drop and re-create the data. It is a good idea to do backups immediately after the load to preserve the otherwise unrecoverable data.</p>
                        <p>By default, a direct path load is <code class="codeph">RECOVERABLE</code>. 
                        </p>
                        <p>The following is an example of specifying the <code class="codeph">UNRECOVERABLE</code> clause in the control file:
                        </p><pre class="oac_no_warn" dir="ltr">UNRECOVERABLE
LOAD DATA
INFILE 'sample.dat'
INTO TABLE emp
(ename VARCHAR2(10), empno NUMBER(4));</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="One way to speed a direct load dramatically is to minimize use of the redo log.">Minimizing Use of the Redo Log</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1325"></a><div class="props_rev_3"><a id="GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0" name="GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0"></a><h5 id="SUTIL-GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0" class="sect5"><span class="enumeration_section">12.5.4.3 </span>Setting the SQL NOLOGGING Parameter
                     </h5>
                     <div>
                        <p>If a data or index segment has the SQL <code class="codeph">NOLOGGING</code> parameter set, then full image redo logging is disabled for that segment (invalidation redo is generated). 
                        </p>
                        <p>Use of the <code class="codeph">NOLOGGING</code> parameter allows a finer degree of control over the objects that are not logged.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="One way to speed a direct load dramatically is to minimize use of the redo log.">Minimizing Use of the Redo Log</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1326"></a><div class="props_rev_3"><a id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" name="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741"></a><h4 id="SUTIL-GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" class="sect4"><span class="enumeration_section">12.5.5 </span>Specifying the Number of Column Array Rows and Size of Stream Buffers
                  </h4>
                  <div>
                     <p>The number of column array rows determines the number of rows loaded before the stream buffer is built. T</p>
                     <div class="section">
                        <p>he <code class="codeph">STREAMSIZE</code> parameter specifies the size (in bytes) of the data stream sent from the client to the server.
                        </p>
                        <p>Use the <code class="codeph">COLUMNARRAYROWS</code> parameter to specify a value for the number of column array rows. Note that when <code class="codeph">VARRAY</code>s are loaded using direct path, the <code class="codeph">COLUMNARRAYROWS</code> parameter defaults to 100 to avoid client object cache thrashing.
                        </p>
                        <p>Use the <code class="codeph">STREAMSIZE</code> parameter to specify the size for direct path stream buffers.
                        </p>
                        <p>The optimal values for these parameters vary, depending on the system, input data types, and Oracle column data types used. When you are using optimal values for your particular configuration, the elapsed time in the SQL*Loader log file should go down.</p>
                        <div class="infoboxnote" id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741__GUID-F15FC938-E4DF-437C-ABC4-5F92A6448D25">
                           <p class="notep1">Note:</p>
                           <p>You should monitor process paging activity, because if paging becomes excessive, then performance can be significantly degraded. You may need to lower the values for <code class="codeph">READSIZE</code>, <code class="codeph">STREAMSIZE</code>, and <code class="codeph">COLUMNARRAYROWS</code> to avoid excessive paging.
                           </p>
                        </div>
                        <p>It can be particularly useful to specify the number of column array rows and size of the stream buffer when you perform direct path loads on multiple-CPU systems.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741__GUID-D91A4DAE-6CA5-47D4-8014-C3FBC94C4638">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" title="If you are performing direct path loads on a multiple-CPU system, then SQL*Loader uses multithreading by default. A multiple-CPU system in this case is defined as a single system that has two or more CPUs.">Optimizing Direct Path Loads on Multiple-CPU Systems</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-commands.html#GUID-7FD5293A-B69A-4873-A030-694B7C36C3B2" title="The COLUMNARRAYROWS command-line parameter for SQL*Loader specifies the number of rows to allocate for direct path column arrays.">COLUMNARRAYROWS</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-commands.html#GUID-20075E73-BF09-4740-BFEC-24A051FEF9F2" title="The STREAMSIZE SQL*Loader command-line parameter specifies the size (in bytes) of the data stream sent from the client to the server.">STREAMSIZE</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1327"></a><div class="props_rev_3"><a id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F" name="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F"></a><h4 id="SUTIL-GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F" class="sect4"><span class="enumeration_section">12.5.6 </span>Specifying a Value for DATE_CACHE
                  </h4>
                  <div>
                     <p>If you are performing a direct path load in which the same date or timestamp values are loaded many times, then a large percentage of total load time can end up being used for converting date and timestamp data. </p>
                     <p>This is especially true if multiple date columns are being loaded. In such a case, it may be possible to improve performance by using the SQL*Loader date cache. </p>
                     <p>The date cache reduces the number of date conversions done when many duplicate values are present in the input data. It enables you to specify the number of unique dates anticipated during the load. </p>
                     <p>The date cache is enabled by default. To completely disable the date cache, set it to 0.</p>
                     <p>The default date cache size is 1000 elements. If the default is used and the number of unique input values loaded exceeds 1000, then the date cache is automatically disabled for that table. This prevents excessive and unnecessary lookup times that could affect performance. However, if instead of using the default, you specify a nonzero value for the date cache and it is exceeded, then the date cache is <span class="italic">not</span> disabled. Instead, any input data that exceeded the maximum is explicitly converted using the appropriate conversion routines. 
                     </p>
                     <p>The date cache can be associated with only one table. No date cache sharing can take place across tables. A date cache is created for a table only if all of the following conditions are true:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">DATE_CACHE</code> parameter is not set to 0
                           </p>
                        </li>
                        <li>
                           <p>One or more date values, timestamp values, or both are being loaded that require data type conversion in order to be stored in the table</p>
                        </li>
                        <li>
                           <p>The load is a direct path load</p>
                        </li>
                     </ul>
                     <p>Date cache statistics are written to the log file. You can use those statistics to improve direct path load performance as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If the number of cache entries is less than the cache size and there are no cache misses, then the cache size could safely be set to a smaller value.</p>
                        </li>
                        <li>
                           <p>If the number of cache hits (entries for which there are duplicate values) is small and the number of cache misses is large, then the cache size should be increased. Be aware that if the cache size is increased too much, then it may cause other problems, such as excessive paging or too much memory usage. </p>
                        </li>
                        <li>
                           <p>If most of the input date values are unique, then the date cache will not enhance performance and therefore should not be used. </p>
                           <div class="infoboxnote" id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F__GUID-79158801-E9E7-403B-9F65-448A65BD6D24">
                              <p class="notep1">Note:</p>
                              <p>Date cache statistics are <span class="italic">not</span> written to the SQL*Loader log file if the cache was active by default and disabled because the maximum was exceeded.
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>If increasing the cache size does not improve performance, then revert to the default behavior or set the cache size to 0. The overall performance improvement also depends on the data types of the other columns being loaded. Improvement will be greater for cases in which the total number of date columns loaded is large compared to other types of data loaded.</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F__GUID-1D7E1515-96EA-4D36-82BC-F17233A7D990">
                        <p class="notep1">See Also:</p>
                        <p><a href="oracle-sql-loader-commands.html#GUID-4EB08318-8317-476C-B03E-7D6F64922663" title="The DATE_CACHE command-line parameter for SQL*Loader specifies the date cache size (in entries).">DATE_CACHE</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="You can control the time and temporary storage used during direct path loads.">Optimizing Performance of Direct Path Loads</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1328"></a><div class="props_rev_3"><a id="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" name="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF"></a><h3 id="SUTIL-GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" class="sect3"><span class="enumeration_section">12.6 </span>Optimizing Direct Path Loads on Multiple-CPU Systems
               </h3>
               <div>
                  <p>If you are performing direct path loads on a multiple-CPU system, then SQL*Loader uses multithreading by default. A multiple-CPU system in this case is defined as a single system that has two or more CPUs.</p>
                  <p>Multithreaded loading means that, when possible, conversion of the column arrays to stream buffers and stream buffer loading are performed in parallel. This optimization works best when:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Column arrays are large enough to generate multiple direct path stream buffers for loads</p>
                     </li>
                     <li>
                        <p>Data conversions are required from input field data types to Oracle column data types</p>
                        <p>The conversions are performed in parallel with stream buffer loading.</p>
                     </li>
                  </ul>
                  <p>The status of this process is recorded in the SQL*Loader log file, as shown in the following sample portion of a log: </p><pre class="oac_no_warn" dir="ltr">Total stream buffers loaded by SQL*Loader main thread:         47
Total stream buffers loaded by SQL*Loader load thread:        180
Column array rows:                                           1000
Stream buffer bytes:                                       256000
</pre><p>In this example, the SQL*Loader load thread has offloaded the SQL*Loader main thread, allowing the main thread to build the next stream buffer while the load thread loads the current stream on the server.</p>
                  <p>The goal is to have the load thread perform as many stream buffer loads as possible. This can be accomplished by increasing the number of column array rows, decreasing the stream buffer size, or both. You can monitor the elapsed time in the SQL*Loader log file to determine whether your changes are having the desired effect. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" title="The number of column array rows determines the number of rows loaded before the stream buffer is built. T">Specifying the Number of Column Array Rows and Size of Stream Buffers</a> for more information.
                  </p>
                  <p>On single-CPU systems, optimization is turned off by default. When the server is on another system, performance may improve if you manually turn on multithreading. </p>
                  <p>To turn the multithreading option on or off, use the <code class="codeph">MULTITHREADING</code> parameter at the SQL*Loader command line or specify it in your SQL*Loader control file.
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF__GUID-EE0D340E-0017-48FA-A4EC-F842CCD67F74">
                     <p class="notep1">See Also:</p>
                     <p><a href="../lnoci/direct-path-load-interface.html#LNOCI16907" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide </span></a>for more information about the concepts of direct path loading
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1329"></a><div class="props_rev_3"><a id="GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418" name="GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418"></a><h3 id="SUTIL-GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418" class="sect3"><span class="enumeration_section">12.7 </span>Avoiding Index Maintenance
               </h3>
               <div>
                  <p>For both the conventional path and the direct path, SQL*Loader maintains all existing indexes for a table.</p>
                  <div class="section">
                     <p>To avoid index maintenance, use one of the following methods:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Drop the indexes before beginning of the load.</p>
                        </li>
                        <li>
                           <p>Mark selected indexes or index partitions as Index Unusable before beginning the load and use the <code class="codeph">SKIP_UNUSABLE_INDEXES</code> parameter.
                           </p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">SKIP_INDEX_MAINTENANCE</code> parameter (direct path only, use with caution).
                           </p>
                        </li>
                     </ul>
                     <p>By avoiding index maintenance, you minimize the amount of space required during a direct path load, in the following ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You can build indexes one at a time, reducing the amount of sort (temporary) segment space that would otherwise be needed for each index.</p>
                        </li>
                        <li>
                           <p>Only one index segment exists when an index is built, instead of the three segments that temporarily exist when the new keys are merged into the old index to make the new index.</p>
                        </li>
                     </ul>
                     <p>Avoiding index maintenance is quite reasonable when the number of rows to be loaded is large compared to the size of the table. But if relatively few rows are added to a large table, then the time required to resort the indexes may be excessive. In such cases, it is usually better to use the conventional path load method, or to use the <code class="codeph">SINGLEROW</code> parameter of SQL*Loader. For more information, see <a href="oracle-sql-loader-control-file-contents.html#GUID-95669C8F-F9A1-4CE4-A83E-DE636E12AE37">SINGLEROW Option</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1330"></a><div class="props_rev_3"><a id="GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" name="GUID-973925DA-8F86-49C1-A707-4564DC3B57AE"></a><h3 id="SUTIL-GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" class="sect3"><span class="enumeration_section">12.8 </span>Direct Path Loads, Integrity Constraints, and Triggers
               </h3>
               <div>
                  <p>With the conventional path load method, arrays of rows are inserted with standard SQL <code class="codeph">INSERT</code> statements; integrity constraints and insert triggers are automatically applied. 
                  </p>
                  <p>But when you load data with the direct path, SQL*Loader disables some integrity constraints and all database triggers. This section discusses the implications of using direct path loads with respect to these features.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100">Integrity Constraints</a><br>During a direct path load, some integrity constraints are automatically disabled. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87">Database Insert Triggers</a><br>Table insert triggers are also disabled when a direct path load begins. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F">Permanently Disabled Triggers and Constraints</a><br>SQL*Loader needs to acquire several locks on the table to be loaded to disable triggers and constraints. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4686510F-DDCB-472D-BBDE-E8248452F46C">Increasing Performance with Concurrent Conventional Path Loads</a><br>If triggers or integrity constraints pose a problem, but you want faster loading, then you should consider using concurrent conventional path loads. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1331"></a><div class="props_rev_3"><a id="GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" name="GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100"></a><h4 id="SUTIL-GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" class="sect4"><span class="enumeration_section">12.8.1 </span>Integrity Constraints
                  </h4>
                  <div>
                     <p>During a direct path load, some integrity constraints are automatically disabled. </p>
                     <p>Others are not. For a description of the constraints, see the information about maintaining data integrity in the<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=ADFNS004" target="_blank"><span class="italic"> Oracle Database Development Guide.</span></a></p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24">Enabled Constraints</a><br>During direct path load, some constraints remain enabled.
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-20F804EE-5015-4899-9A64-64254BC9FDC1">Disabled Constraints</a><br>During a direct path load, some constraints are disabled.
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074">Reenable Constraints</a><br>When the load completes, the integrity constraints will be reenabled automatically if the <code class="codeph">REENABLE</code> clause is specified. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="With the conventional path load method, arrays of rows are inserted with standard SQL INSERT statements; integrity constraints and insert triggers are automatically applied.">Direct Path Loads, Integrity Constraints, and Triggers</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1332"></a><div class="props_rev_3"><a id="GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24" name="GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24"></a><h5 id="SUTIL-GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24" class="sect5"><span class="enumeration_section">12.8.1.1 </span>Enabled Constraints
                     </h5>
                     <div>
                        <p>During direct path load, some constraints remain enabled.</p>
                        <p>During a direct path load, the constraints that remain enabled are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">NOT</code> <code class="codeph">NULL</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">UNIQUE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> (unique-constraints on not-null columns)
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints are checked at column array build time. Any row that violates the <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint is rejected. 
                        </p>
                        <p>Even though <code class="codeph">UNIQUE</code> constraints remain enabled during direct path loads, any rows that violate those constraints are loaded anyway (this is different than in conventional path in which such rows would be rejected). When indexes are rebuilt at the end of the direct path load, <code class="codeph">UNIQUE</code> constraints are verified and if a violation is detected, then the index will be left in an Index Unusable state. See <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" title="SQL*Loader leaves indexes in an Index Unusable state when the data segment being loaded becomes more up-to-date than the index segments that index it.">Indexes Left in an Unusable State</a>.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="During a direct path load, some integrity constraints are automatically disabled.">Integrity Constraints</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1333"></a><div class="props_rev_3"><a id="GUID-20F804EE-5015-4899-9A64-64254BC9FDC1" name="GUID-20F804EE-5015-4899-9A64-64254BC9FDC1"></a><h5 id="SUTIL-GUID-20F804EE-5015-4899-9A64-64254BC9FDC1" class="sect5"><span class="enumeration_section">12.8.1.2 </span>Disabled Constraints 
                     </h5>
                     <div>
                        <p>During a direct path load, some constraints are disabled.</p>
                        <p>During a direct path load, the following constraints are automatically disabled by default: </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">CHECK</code> constraints 
                              </p>
                           </li>
                           <li>
                              <p>Referential constraints (<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>) 
                              </p>
                           </li>
                        </ul>
                        <p>You can override the automatic disabling of <code class="codeph">CHECK</code> constraints by specifying the <code class="codeph">EVALUATE CHECK_CONSTRAINTS</code> clause. SQL*Loader will then evaluate <code class="codeph">CHECK</code> constraints during a direct path load. Any row that violates the <code class="codeph">CHECK</code> constraint is rejected. The following example shows the use of the <code class="codeph">EVALUATE</code> <code class="codeph">CHECK_CONSTRAINTS</code> clause in a SQL*Loader control file:
                        </p><pre class="oac_no_warn" dir="ltr">LOAD DATA 
INFILE * 
APPEND 
INTO TABLE emp 
EVALUATE CHECK_CONSTRAINTS 
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' 
(c1 CHAR(10) ,c2) 
BEGINDATA 
Jones,10
Smith,20 
Brown,30
Taylor,40</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="During a direct path load, some integrity constraints are automatically disabled.">Integrity Constraints</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1334"></a><div class="props_rev_3"><a id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074" name="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074"></a><h5 id="SUTIL-GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074" class="sect5"><span class="enumeration_section">12.8.1.3 </span>Reenable Constraints 
                     </h5>
                     <div>
                        <p>When the load completes, the integrity constraints will be reenabled automatically if the <code class="codeph">REENABLE</code> clause is specified. 
                        </p>
                        <p>The syntax for the <code class="codeph">REENABLE</code> clause is as follows: 
                        </p>
                        <div class="figure" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-8490F2F8-7131-4060-9251-F0DD82E46CBA"><img src="img/into_table4.gif" width="555" alt="Description of into_table4.eps follows" title="Description of into_table4.eps follows" longdesc="img_text/into_table4.html"><br><a href="img_text/into_table4.html">Description of the illustration into_table4.eps</a></div>
                        <!-- class="figure" -->
                        <div class="figure" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-19A2BEA2-9C32-42C9-88FC-FD637C7C066D"><img src="img/into_table5.gif" width="340" alt="Description of into_table5.eps follows" title="Description of into_table5.eps follows" longdesc="img_text/into_table5.html"><br><a href="img_text/into_table5.html">Description of the illustration into_table5.eps</a></div>
                        <!-- class="figure" -->
                        <p>The optional parameter <code class="codeph">DISABLED_CONSTRAINTS</code> is provided for readability. If the <code class="codeph">EXCEPTIONS</code> clause is included, then the table must already exist and you must be able to insert into it. This table contains the <code class="codeph">ROWID</code>s of all rows that violated one of the integrity constraints. It also contains the name of the constraint that was violated. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF52228" target="_blank"><span class="italic">Oracle Database SQL Language Reference </span></a>for instructions on how to create an exceptions table. 
                        </p>
                        <p>The SQL*Loader log file describes the constraints that were disabled, the ones that were reenabled, and what error, if any, prevented reenabling or validating of each constraint. It also contains the name of the exceptions table specified for each loaded table.</p>
                        <p>If the <code class="codeph">REENABLE</code> clause is not used, then the constraints must be reenabled manually, at which time all rows in the table are verified. If the Oracle database finds any errors in the new data, then error messages are produced. The names of violated constraints and the ROWIDs of the bad data are placed in an exceptions table, if one is specified.
                        </p>
                        <p>If the <code class="codeph">REENABLE</code> clause is used, then SQL*Loader automatically reenables the constraint and verifies all new rows. If no errors are found in the new data, then SQL*Loader automatically marks the constraint as validated. If any errors <span class="italic">are</span> found in the new data, then error messages are written to the log file and SQL*Loader marks the status of the constraint as <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code>. The names of violated constraints and the ROWIDs of the bad data are placed in an exceptions table, if one is specified. 
                        </p>
                        <div class="infoboxnote" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-9D991006-93D7-4122-B7A9-718F40F2962C">
                           <p class="notep1">Note:</p>
                           <p>Normally, when a table constraint is left in an <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> state, new data can be inserted into the table but no new invalid data may be inserted. However, SQL*Loader direct path load does not enforce this rule. Thus, if subsequent direct path loads are performed with invalid data, then the invalid data will be inserted but the same error reporting and exception table processing as described previously will take place. In this scenario the exception table may contain duplicate entries if it is not cleared out before each load. Duplicate entries can easily be filtered out by performing a query such as the following:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT UNIQUE * FROM exceptions_table; </pre></div>
                        <div class="infoboxnote" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-4085A320-8151-462F-A35E-3BC71FBE0B5B">
                           <p class="notep1">Note:</p>
                           <p>Because referential integrity must be reverified for the entire table, performance may be improved by using the conventional path, instead of the direct path, when a small number of rows are to be loaded into a very large table.</p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="During a direct path load, some integrity constraints are automatically disabled.">Integrity Constraints</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1335"></a><div class="props_rev_3"><a id="GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" name="GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87"></a><h4 id="SUTIL-GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" class="sect4"><span class="enumeration_section">12.8.2 </span>Database Insert Triggers
                  </h4>
                  <div>
                     <p>Table insert triggers are also disabled when a direct path load begins. </p>
                     <p>After the rows are loaded and indexes rebuilt, any triggers that were disabled are automatically reenabled. The log file lists all triggers that were disabled for the load. There should not be any errors reenabling triggers.</p>
                     <p>Unlike integrity constraints, insert triggers are not reapplied to the whole table when they are enabled. As a result, insert triggers do <span class="italic">not</span> fire for any rows loaded on the direct path. When using the direct path, the application must ensure that any behavior associated with insert triggers is carried out for the new rows.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D">Replacing Insert Triggers with Integrity Constraints</a><br>Applications commonly use insert triggers to implement integrity constraints. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-86536F29-ECAF-4E2A-B298-4047B7F99743">When Automatic Constraints Cannot Be Used</a><br>Sometimes an insert trigger cannot be replaced with Oracle's automatic integrity constraints. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-554DE348-8135-4E16-B483-111323535BC7">Preparation</a><br>Before either method can be used, the table must be prepared. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612">Using an Update Trigger</a><br>Generally, you can use a database update trigger to duplicate the effects of an insert trigger. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-98C5B698-141D-449B-9938-CAA935D8B7EC">Duplicating the Effects of Exception Conditions</a><br>If the insert trigger can raise an exception, then more work is required to duplicate its effects. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D9C8570B-CB5D-4566-A016-48256BE904CC">Using a Stored Procedure</a><br>This topic describes using a stored procedure.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="With the conventional path load method, arrays of rows are inserted with standard SQL INSERT statements; integrity constraints and insert triggers are automatically applied.">Direct Path Loads, Integrity Constraints, and Triggers</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1336"></a><div class="props_rev_3"><a id="GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D" name="GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D"></a><h5 id="SUTIL-GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D" class="sect5"><span class="enumeration_section">12.8.2.1 </span>Replacing Insert Triggers with Integrity Constraints
                     </h5>
                     <div>
                        <p>Applications commonly use insert triggers to implement integrity constraints. </p>
                        <div class="section">
                           <p>Most of the triggers that these application insert are simple enough that they can be replaced with Oracle's automatic integrity constraints.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1337"></a><div class="props_rev_3"><a id="GUID-86536F29-ECAF-4E2A-B298-4047B7F99743" name="GUID-86536F29-ECAF-4E2A-B298-4047B7F99743"></a><h5 id="SUTIL-GUID-86536F29-ECAF-4E2A-B298-4047B7F99743" class="sect5"><span class="enumeration_section">12.8.2.2 </span>When Automatic Constraints Cannot Be Used
                     </h5>
                     <div>
                        <p>Sometimes an insert trigger cannot be replaced with Oracle's automatic integrity constraints. </p>
                        <p>For example, if an integrity check is implemented with a table lookup in an insert trigger, then automatic check constraints cannot be used, because the automatic constraints can only reference constants and columns in the current row. This section describes two methods for duplicating the effects of such a trigger.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1338"></a><div class="props_rev_3"><a id="GUID-554DE348-8135-4E16-B483-111323535BC7" name="GUID-554DE348-8135-4E16-B483-111323535BC7"></a><h5 id="SUTIL-GUID-554DE348-8135-4E16-B483-111323535BC7" class="sect5"><span class="enumeration_section">12.8.2.3 </span>Preparation
                     </h5>
                     <div>
                        <p>Before either method can be used, the table must be prepared. </p>
                        <div class="section">
                           <p>Use the following general guidelines to prepare the table:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>Before the load, add a 1-byte or 1-character column to the table that marks rows as "old data" or "new data."</span></li>
                           <li><span>Let the value of null for this column signify "old data" because null columns do not take up space.</span></li>
                           <li><span>When loading, flag all loaded rows as "new data" with SQL*Loader's <code class="codeph">CONSTANT</code> parameter.</span></li>
                        </ol>
                        <div class="section">
                           <p>After following this procedure, all newly loaded rows are identified, making it possible to operate on the new data without affecting the old rows.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1339"></a><div class="props_rev_3"><a id="GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612" name="GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612"></a><h5 id="SUTIL-GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612" class="sect5"><span class="enumeration_section">12.8.2.4 </span>Using an Update Trigger
                     </h5>
                     <div>
                        <p>Generally, you can use a database update trigger to duplicate the effects of an insert trigger. </p>
                        <div class="section">
                           <p>This method is the simplest. It can be used whenever the insert trigger does not raise any exceptions.</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Create an update trigger that duplicates the effects of the insert trigger.</span><div>
                                 <p>Copy the trigger. Change all occurrences of <code class="codeph">"</code><span class="italic"><code class="codeph">new</code></span><code class="codeph">.column_name"</code> to <code class="codeph">"</code><span class="italic"><code class="codeph">old</code></span><code class="codeph">.column_name"</code>.
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>Replace the current update trigger, if it exists, with the new one.</span></li>
                           <li class="stepexpand"><span>Update the table, changing the "new data" flag to null, thereby firing the update trigger.</span></li>
                           <li class="stepexpand"><span>Restore the original update trigger, if there was one.</span></li>
                        </ol>
                        <div class="section">
                           <p>Depending on the behavior of the trigger, it may be necessary to have exclusive update access to the table during this operation, so that other users do not inadvertently apply the trigger to rows they modify.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1340"></a><div class="props_rev_3"><a id="GUID-98C5B698-141D-449B-9938-CAA935D8B7EC" name="GUID-98C5B698-141D-449B-9938-CAA935D8B7EC"></a><h5 id="SUTIL-GUID-98C5B698-141D-449B-9938-CAA935D8B7EC" class="sect5"><span class="enumeration_section">12.8.2.5 </span>Duplicating the Effects of Exception Conditions
                     </h5>
                     <div>
                        <p>If the insert trigger can raise an exception, then more work is required to duplicate its effects. </p>
                        <p>Raising an exception would prevent the row from being inserted into the table. To duplicate that effect with an update trigger, it is necessary to mark the loaded row for deletion.</p>
                        <p>The "new data" column cannot be used as a delete flag, because an update trigger cannot modify the columns that caused it to fire. So another column must be added to the table. This column marks the row for deletion. A null value means the row is valid. Whenever the insert trigger would raise an exception, the update trigger can mark the row as invalid by setting a flag in the additional column.</p>
                        <p>In summary, when an insert trigger can raise an exception condition, its effects can be duplicated by an update trigger, provided:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Two columns (which are usually null) are added to the table</p>
                           </li>
                           <li>
                              <p>The table can be updated exclusively (if necessary)</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1341"></a><div class="props_rev_3"><a id="GUID-D9C8570B-CB5D-4566-A016-48256BE904CC" name="GUID-D9C8570B-CB5D-4566-A016-48256BE904CC"></a><h5 id="SUTIL-GUID-D9C8570B-CB5D-4566-A016-48256BE904CC" class="sect5"><span class="enumeration_section">12.8.2.6 </span>Using a Stored Procedure
                     </h5>
                     <div>
                        <p>This topic describes using a stored procedure.</p>
                        <div class="section">
                           <p>The following procedure always works, but it is more complex to implement. It can be used when the insert trigger raises exceptions. It does not require a second additional column; and, because it does not replace the update trigger, it can be used without exclusive access to the table.</p>
                           <ol>
                              <li>
                                 <p>Do the following to create a stored procedure that duplicates the effects of the insert trigger:</p>
                                 <ol type="a">
                                    <li>
                                       <p>Declare a cursor for the table, selecting all new rows.</p>
                                    </li>
                                    <li>
                                       <p>Open the cursor and fetch rows, one at a time, in a processing loop.</p>
                                    </li>
                                    <li>
                                       <p>Perform the operations contained in the insert trigger.</p>
                                    </li>
                                    <li>
                                       <p>If the operations succeed, then change the "new data" flag to null.</p>
                                    </li>
                                    <li>
                                       <p>If the operations fail, then change the "new data" flag to "bad data."</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>Execute the stored procedure using an administration tool such as SQL*Plus. </p>
                              </li>
                              <li>
                                 <p>After running the procedure, check the table for any rows marked "bad data."</p>
                              </li>
                              <li>
                                 <p>Update or remove the bad rows.</p>
                              </li>
                              <li>
                                 <p>Reenable the insert trigger.</p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="Table insert triggers are also disabled when a direct path load begins.">Database Insert Triggers</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1342"></a><div class="props_rev_3"><a id="GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F" name="GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F"></a><h4 id="SUTIL-GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F" class="sect4"><span class="enumeration_section">12.8.3 </span>Permanently Disabled Triggers and Constraints
                  </h4>
                  <div>
                     <p>SQL*Loader needs to acquire several locks on the table to be loaded to disable triggers and constraints. </p>
                     <p>If a competing process is enabling triggers or constraints at the same time that SQL*Loader is trying to disable them for that table, then SQL*Loader may not be able to acquire exclusive access to the table.</p>
                     <p>SQL*Loader attempts to handle this situation as gracefully as possible. It attempts to reenable disabled triggers and constraints before exiting. However, the same table-locking problem that made it impossible for SQL*Loader to continue may also have made it impossible for SQL*Loader to finish enabling triggers and constraints. In such cases, triggers and constraints will remain disabled until they are manually enabled.</p>
                     <p>Although such a situation is unlikely, it is possible. The best way to prevent it is to ensure that no applications are running that could enable triggers or constraints for the table while the direct load is in progress.</p>
                     <p>If a direct load is terminated due to failure to acquire the proper locks, then carefully check the log. It will show every trigger and constraint that was disabled, and each attempt to reenable them. Any triggers or constraints that were not reenabled by SQL*Loader should be manually enabled with the <code class="codeph">ENABLE</code> clause of the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement described in<a href="../sqlrf/ALTER-TABLE.html#SQLRF53523" target="_blank"><span class="italic"> Oracle Database SQL Language Reference</span></a><span class="italic">.</span></p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="With the conventional path load method, arrays of rows are inserted with standard SQL INSERT statements; integrity constraints and insert triggers are automatically applied.">Direct Path Loads, Integrity Constraints, and Triggers</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1343"></a><div class="props_rev_3"><a id="GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" name="GUID-4686510F-DDCB-472D-BBDE-E8248452F46C"></a><h4 id="SUTIL-GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" class="sect4"><span class="enumeration_section">12.8.4 </span>Increasing Performance with Concurrent Conventional Path Loads
                  </h4>
                  <div>
                     <p>If triggers or integrity constraints pose a problem, but you want faster loading, then you should consider using concurrent conventional path loads. </p>
                     <p>That is, use multiple load sessions executing concurrently on a multiple-CPU system. Split the input data files into separate files on logical record boundaries, and then load each such input data file with a conventional path load session. The resulting load has the following attributes: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It is faster than a single conventional load on a multiple-CPU system, but probably not as fast as a direct load. </p>
                        </li>
                        <li>
                           <p>Triggers fire, integrity constraints are applied to the loaded rows, and indexes are maintained using the standard DML execution logic.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="With the conventional path load method, arrays of rows are inserted with standard SQL INSERT statements; integrity constraints and insert triggers are automatically applied.">Direct Path Loads, Integrity Constraints, and Triggers</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1344"></a><div class="props_rev_3"><a id="GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" name="GUID-ECBC6D01-4273-4102-983A-2139C5FB2887"></a><h3 id="SUTIL-GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" class="sect3"><span class="enumeration_section">12.9 </span>Parallel Data Loading Models
               </h3>
               <div>
                  <p>This topic describes parallel data loading models.</p>
                  <p>This section discusses three basic models of concurrency that you can use to minimize the elapsed time required for data loading:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Concurrent conventional path loads</p>
                     </li>
                     <li>
                        <p>Intersegment concurrency with the direct path load method</p>
                     </li>
                     <li>
                        <p>Intrasegment concurrency with the direct path load method</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC">Concurrent Conventional Path Loads</a><br>This topic describes using concurrent conventional path loads.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D">Intersegment Concurrency with Direct Path</a><br>Intersegment concurrency can be used for concurrent loading of different objects. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669">Intrasegment Concurrency with Direct Path</a><br>SQL*Loader permits multiple, concurrent sessions to perform a direct path load into the same table, or into the same partition of a partitioned table. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B">Restrictions on Parallel Direct Path Loads</a><br>Restrictions are enforced on parallel direct path loads.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B">Initiating Multiple SQL*Loader Sessions</a><br>Each SQL*Loader session takes a different data file as input. In all sessions executing a direct load on the same table, you must set <code class="codeph">PARALLEL</code> to <code class="codeph">TRUE</code>. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-077F71AE-FB17-4233-B35F-ED611930C9BD">Parameters for Parallel Direct Path Loads</a><br>When you perform parallel direct path loads, there are options available for specifying attributes of the temporary segment to be allocated by the loader. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C">Enabling Constraints After a Parallel Direct Path Load</a><br>Constraints and triggers must be enabled manually after all data loading is complete.
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD">PRIMARY KEY and UNIQUE KEY Constraints</a><br>This topic describes using the PRIMARY KEY and UNIQUE KEY constraints.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1345"></a><div class="props_rev_3"><a id="GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC" name="GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC"></a><h4 id="SUTIL-GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC" class="sect4"><span class="enumeration_section">12.9.1 </span>Concurrent Conventional Path Loads
                  </h4>
                  <div>
                     <p>This topic describes using concurrent conventional path loads.</p>
                     <p>Using multiple conventional path load sessions executing concurrently is discussed in <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" title="If triggers or integrity constraints pose a problem, but you want faster loading, then you should consider using concurrent conventional path loads.">Increasing Performance with Concurrent Conventional Path Loads</a>, you can use this technique to load the same or different objects concurrently with no restrictions.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1346"></a><div class="props_rev_3"><a id="GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D" name="GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D"></a><h4 id="SUTIL-GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D" class="sect4"><span class="enumeration_section">12.9.2 </span>Intersegment Concurrency with Direct Path
                  </h4>
                  <div>
                     <p>Intersegment concurrency can be used for concurrent loading of different objects. </p>
                     <div class="section">
                        <p>You can apply this technique to concurrent direct path loading of different tables, or to concurrent direct path loading of different partitions of the same table.</p>
                        <p>When you direct path load a single partition, consider the following items:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Local indexes can be maintained by the load.</p>
                           </li>
                           <li>
                              <p>Global indexes cannot be maintained by the load.</p>
                           </li>
                           <li>
                              <p>Referential integrity and <code class="codeph">CHECK</code> constraints must be disabled.
                              </p>
                           </li>
                           <li>
                              <p>Triggers must be disabled.</p>
                           </li>
                           <li>
                              <p>The input data should be partitioned (otherwise many records will be rejected, which adversely affects performance).</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1347"></a><div class="props_rev_3"><a id="GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669" name="GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669"></a><h4 id="SUTIL-GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669" class="sect4"><span class="enumeration_section">12.9.3 </span>Intrasegment Concurrency with Direct Path
                  </h4>
                  <div>
                     <p>SQL*Loader permits multiple, concurrent sessions to perform a direct path load into the same table, or into the same partition of a partitioned table. </p>
                     <div class="section">
                        <p>Multiple SQL*Loader sessions improve the performance of a direct path load given the available resources on your system.</p>
                        <p>This method of data loading is enabled by setting both the <code class="codeph">DIRECT</code> and the <code class="codeph">PARALLEL</code> parameters to <code class="codeph">TRUE</code>, and is often referred to as a parallel direct path load.<span class="italic"></span> 
                        </p>
                        <p>It is important to realize that parallelism is user managed. Setting the <code class="codeph">PARALLEL</code> parameter to <code class="codeph">TRUE</code> only allows multiple concurrent direct path load sessions.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1348"></a><div class="props_rev_3"><a id="GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B" name="GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B"></a><h4 id="SUTIL-GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B" class="sect4"><span class="enumeration_section">12.9.4 </span>Restrictions on Parallel Direct Path Loads
                  </h4>
                  <div>
                     <p>Restrictions are enforced on parallel direct path loads.</p>
                     <div class="section">
                        <p>The following restrictions are enforced on parallel direct path loads:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Neither local nor global indexes can be maintained by the load.</p>
                           </li>
                           <li>
                              <p>Rows can only be appended. <code class="codeph">REPLACE</code>, <code class="codeph">TRUNCATE</code>, and <code class="codeph">INSERT</code> cannot be used (this is due to the individual loads not being coordinated). If you must truncate a table before a parallel load, then you must do it manually. 
                              </p>
                           </li>
                        </ul>
                        <p>Additionally, the following objects must be disabled on parallel direct path loads. You do not have to take any action to disable them. SQL*Loader disables them before the load begins and re-enables them after the load completes:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Referential integrity constraints</p>
                           </li>
                           <li>
                              <p>Triggers</p>
                           </li>
                           <li>
                              <p>CHECK constraints, unless the <code class="codeph">ENABLE_CHECK_CONSTRAINTS</code> control file option is used
                              </p>
                           </li>
                        </ul>
                        <p>If a parallel direct path load is being applied to a single partition, then you should partition the data first (otherwise, the overhead of record rejection due to a partition mismatch slows down the load).</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1349"></a><div class="props_rev_3"><a id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B" name="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B"></a><h4 id="SUTIL-GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B" class="sect4"><span class="enumeration_section">12.9.5 </span>Initiating Multiple SQL*Loader Sessions
                  </h4>
                  <div>
                     <p>Each SQL*Loader session takes a different data file as input. In all sessions executing a direct load on the same table, you must set <code class="codeph">PARALLEL</code> to <code class="codeph">TRUE</code>. 
                     </p>
                     <div class="section">
                        <p>The syntax is:</p>
                        <div class="figure" id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B__GUID-8E81E515-708B-457D-A9DC-E0D44073B2A2"><img src="img/parallel.gif" width="191" alt="Description of parallel.eps follows" title="Description of parallel.eps follows" longdesc="img_text/parallel.html"><br><a href="img_text/parallel.html">Description of the illustration parallel.eps</a></div>
                        <!-- class="figure" -->
                        <p><code class="codeph">PARALLEL</code> can be specified on the command line or in a parameter file. It can also be specified in the control file with the <code class="codeph">OPTIONS</code> clause.
                        </p>
                        <p>For example, to start three SQL*Loader direct path load sessions on the same table, you would execute each of the following commands at the operating system prompt. After entering each command, you will be prompted for a password.</p><pre class="oac_no_warn" dir="ltr">sqlldr USERID=scott CONTROL=load1.ctl DIRECT=TRUE PARALLEL=TRUE
sqlldr USERID=scott CONTROL=load2.ctl DIRECT=TRUE PARALLEL=TRUE
sqlldr USERID=scott CONTROL=load3.ctl DIRECT=TRUE PARALLEL=TRUE
</pre><p>The previous commands must be executed in separate sessions, or if permitted on your operating system, as separate background jobs. Note the use of multiple control files. This enables you to be flexible in specifying the files to use for the direct path load.</p>
                        <div class="infoboxnote" id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B__GUID-71DD4120-C95E-4F36-88C6-221D27476BCF">
                           <p class="notep1">Note:</p>
                           <p>Indexes are not maintained during a parallel load. Any indexes must be created or re-created manually after the load completes. You can use the parallel index creation or parallel index rebuild feature to speed the building of large indexes after a parallel load.</p>
                        </div>
                        <p>When you perform a parallel load, SQL*Loader creates temporary segments for each concurrent session and then merges the segments upon completion. The segment created from the merge is then added to the existing segment in the database above the segment's high-water mark. The last extent used of each segment for each loader session is trimmed of any free space before being combined with the other extents of the SQL*Loader session.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1350"></a><div class="props_rev_3"><a id="GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" name="GUID-077F71AE-FB17-4233-B35F-ED611930C9BD"></a><h4 id="SUTIL-GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" class="sect4"><span class="enumeration_section">12.9.6 </span>Parameters for Parallel Direct Path Loads
                  </h4>
                  <div>
                     <p>When you perform parallel direct path loads, there are options available for specifying attributes of the temporary segment to be allocated by the loader. </p>
                     <p>These options are specified with the <code class="codeph">FILE</code> and <code class="codeph">STORAGE</code> parameters. These parameters are valid only for parallel loads.
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64">Using the FILE Parameter to Specify Temporary Segments</a><br>To allow for maximum I/O throughput, Oracle recommends that each concurrent direct path load session use files located on different disks. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1351"></a><div class="props_rev_3"><a id="GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" name="GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64"></a><h5 id="SUTIL-GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" class="sect5"><span class="enumeration_section">12.9.6.1 </span>Using the FILE Parameter to Specify Temporary Segments
                     </h5>
                     <div>
                        <p>To allow for maximum I/O throughput, Oracle recommends that each concurrent direct path load session use files located on different disks. </p>
                        <div class="section">
                           <p>In the SQL*Loader control file, use the <code class="codeph">FILE</code> parameter of the <code class="codeph">OPTIONS</code> clause to specify the file name of any valid data file in the tablespace of the object (table or partition) being loaded. 
                           </p>
                           <p>For example:</p><pre class="oac_no_warn" dir="ltr">LOAD DATA
INFILE 'load1.dat'
INSERT INTO TABLE emp
OPTIONS(FILE='/dat/data1.dat')
(empno POSITION(01:04) INTEGER EXTERNAL NULLIF empno=BLANKS
...
</pre><p>You could also specify the <code class="codeph">FILE</code> parameter on the command line of each concurrent SQL*Loader session, but then it would apply globally to all objects being loaded with that session.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33">Using the FILE Parameter</a><br>This topic describes using the FILE parameter.
                           </li>
                           <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA">Using the STORAGE Parameter</a><br>You can use the <code class="codeph">STORAGE</code> parameter to specify the storage attributes of the temporary segments allocated for a parallel direct path load. 
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" title="When you perform parallel direct path loads, there are options available for specifying attributes of the temporary segment to be allocated by the loader.">Parameters for Parallel Direct Path Loads</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="SUTIL1352"></a><div class="props_rev_3"><a id="GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33" name="GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33"></a><h6 id="SUTIL-GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33" class="sect6"><span class="enumeration_section">12.9.6.1.1 </span>Using the FILE Parameter
                        </h6>
                        <div>
                           <p>This topic describes using the FILE parameter.</p>
                           <div class="section">
                              <p>The <code class="codeph">FILE</code> parameter in the Oracle database has the following restrictions for parallel direct path loads:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="bold">For nonpartitioned tables:</span> The specified file must be in the tablespace of the table being loaded.
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="bold">For partitioned tables, single-partition load:</span> The specified file must be in the tablespace of the partition being loaded.
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="bold">For partitioned tables, full-table load:</span> The specified file must be in the tablespace of all partitions being loaded; that is, all partitions must be in the same tablespace.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" title="To allow for maximum I/O throughput, Oracle recommends that each concurrent direct path load session use files located on different disks.">Using the FILE Parameter to Specify Temporary Segments</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL1353"></a><div class="props_rev_3"><a id="GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA" name="GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA"></a><h6 id="SUTIL-GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA" class="sect6"><span class="enumeration_section">12.9.6.1.2 </span>Using the STORAGE Parameter
                        </h6>
                        <div>
                           <p>You can use the <code class="codeph">STORAGE</code> parameter to specify the storage attributes of the temporary segments allocated for a parallel direct path load. 
                           </p>
                           <p>If the <code class="codeph">STORAGE</code> parameter is not used, then the storage attributes of the segment containing the object (table, partition) being loaded are used. Also, when the <code class="codeph">STORAGE</code> parameter is not specified, SQL*Loader uses a default of 2 KB for <code class="codeph">EXTENTS</code>.
                           </p>
                           <p>For example, the following <code class="codeph">OPTIONS</code> clause could be used to specify <code class="codeph">STORAGE</code> parameters:
                           </p><pre class="oac_no_warn" dir="ltr">OPTIONS (STORAGE=(INITIAL 100M NEXT 100M PCTINCREASE 0))
</pre><p>You can use the <code class="codeph">STORAGE</code> parameter only in the SQL*Loader control file, and not on the command line. Use of the <code class="codeph">STORAGE</code> parameter to specify anything other than <code class="codeph">PCTINCREASE</code> of 0, and <code class="codeph">INITIAL</code> or <code class="codeph">NEXT</code> values is strongly discouraged and may be silently ignored.
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" title="To allow for maximum I/O throughput, Oracle recommends that each concurrent direct path load session use files located on different disks.">Using the FILE Parameter to Specify Temporary Segments</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="SUTIL1354"></a><div class="props_rev_3"><a id="GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C" name="GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C"></a><h4 id="SUTIL-GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C" class="sect4"><span class="enumeration_section">12.9.7 </span>Enabling Constraints After a Parallel Direct Path Load
                  </h4>
                  <div>
                     <p>Constraints and triggers must be enabled manually after all data loading is complete.</p>
                     <p>Because each SQL*Loader session can attempt to reenable constraints on a table after a direct path load, there is a danger that one session may attempt to reenable a constraint before another session is finished loading data. In this case, the first session to complete the load will be unable to enable the constraint because the remaining sessions possess share locks on the table.</p>
                     <p>Because there is a danger that some constraints might not be reenabled after a direct path load, you should check the status of the constraint after completing the load to ensure that it was enabled properly.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1355"></a><div class="props_rev_3"><a id="GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD" name="GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD"></a><h4 id="SUTIL-GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD" class="sect4"><span class="enumeration_section">12.9.8 </span>PRIMARY KEY and UNIQUE KEY Constraints
                  </h4>
                  <div>
                     <p>This topic describes using the PRIMARY KEY and UNIQUE KEY constraints.</p>
                     <p><code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> and <code class="codeph">UNIQUE</code> <code class="codeph">KEY</code> constraints create indexes on a table when they are enabled, and subsequently can take a significantly long time to enable after a direct path loading session if the table is very large. You should consider enabling these constraints manually after a load (and not specifying the automatic enable feature). This enables you to manually create the required indexes in parallel to save time before enabling the constraint.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="This topic describes parallel data loading models.">Parallel Data Loading Models</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1356"></a><div class="props_rev_3"><a id="GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C" name="GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C"></a><h3 id="SUTIL-GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C" class="sect3"><span class="enumeration_section">12.10 </span>General Performance Improvement Hints
               </h3>
               <div>
                  <p>This topic describes hints for general performance improvements.</p>
                  <div class="section">
                     <p>If you have control over the format of the data to be loaded, then you can use the following hints to improve load performance:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Make logical record processing efficient.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Use one-to-one mapping of physical records to logical records (avoid using <code class="codeph">CONTINUEIF</code> and <code class="codeph">CONCATENATE</code>).
                                 </p>
                              </li>
                              <li>
                                 <p>Make it easy for the software to identify physical record boundaries. Use the file processing option string <code class="codeph">"FIX nnn"</code> or <code class="codeph">"VAR"</code>. If you use the default (stream mode), then on most platforms (for example, UNIX and NT) the loader must scan each physical record for the record terminator (newline character).
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Make field setting efficient. Field setting is the process of mapping fields in the data file to their corresponding columns in the table being loaded. The mapping function is controlled by the description of the fields in the control file. Field setting (along with data conversion) is the biggest consumer of CPU cycles for most loads.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Avoid delimited fields; use positional fields. If you use delimited fields, then the loader must scan the input data to find the delimiters. If you use positional fields, then field setting becomes simple pointer arithmetic (very fast).</p>
                              </li>
                              <li>
                                 <p>Do not trim whitespace if you do not need to (use <code class="codeph">PRESERVE</code> <code class="codeph">BLANKS</code>).
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Make conversions efficient. SQL*Loader performs character set conversion and data type conversion for you. Of course, the quickest conversion is no conversion.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Use single-byte character sets if you can.</p>
                              </li>
                              <li>
                                 <p>Avoid character set conversions if you can. SQL*Loader supports four character sets: </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Client character set (<code class="codeph">NLS_LANG</code> of the client <code class="codeph">sqlldr</code> process)
                                       </p>
                                    </li>
                                    <li>
                                       <p>Data file character set (usually the same as the client character set)</p>
                                    </li>
                                    <li>
                                       <p>Database character set</p>
                                    </li>
                                    <li>
                                       <p>Database national character set</p>
                                    </li>
                                 </ul>
                                 <p>Performance is optimized if all character sets are the same. For direct path loads, it is best if the data file character set and the database character set are the same. If the character sets are the same, then character set conversion buffers are not allocated.</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Use direct path loads.</p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">SORTED</code> <code class="codeph">INDEXES</code> clause.
                           </p>
                        </li>
                        <li>
                           <p>Avoid unnecessary <code class="codeph">NULLIF</code> and <code class="codeph">DEFAULTIF</code> clauses. Each clause must be evaluated on each column that has a clause associated with it for every row loaded.
                           </p>
                        </li>
                        <li>
                           <p>Use parallel direct path loads and parallel index creation when you can.</p>
                        </li>
                        <li>
                           <p>Be aware of the effect on performance when you have large values for both the <code class="codeph">CONCATENATE</code> clause and the <code class="codeph">COLUMNARRAYROWS</code> clause. See <a href="oracle-sql-loader-control-file-contents.html#GUID-2F2DCBD4-CEEB-4479-AF6E-38F0BAF4499E" title="Use CONCATENATE when you want SQL*Loader to always combine the same number of physical records to form one logical record.">Using CONCATENATE to Assemble Logical Records</a>. 
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL*Loader provides a conventional path load method and a direct path load method.">Conventional and Direct Path Loads</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>