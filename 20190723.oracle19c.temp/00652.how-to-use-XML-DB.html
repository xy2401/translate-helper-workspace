<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">
      <meta name="description" content="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">
      <title>Overview of How To Use Oracle XML&nbsp;DB</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Developer's Guide ">
      <meta property="og:description" content="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96222-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="getting-started-with-XML-DB.html" title="Previous" type="text/html">
      <link rel="next" href="manipulation-of-XML-in-XML-DB.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer's Guide">
    <meta name="dcterms.isVersionOf" content="ADXDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="getting-started-with-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="manipulation-of-XML-in-XML-DB.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-DB-basics.html" property="item" typeof="WebPage"><span property="name"> Oracle XML&nbsp;DB Basics</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Overview of How To Use Oracle XML&nbsp;DB</li>
            </ol>
            <a id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398" name="GUID-757B4470-851B-47B7-AB78-81F47ECE5398"></a><a id="ADXDB0300"></a>
            
            <h2 id="ADXDB-GUID-757B4470-851B-47B7-AB78-81F47ECE5398" class="sect2"><span class="enumeration_chapter">3 </span> Overview of How To Use Oracle XML&nbsp;DB
            </h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='how-to-use-XML-DB'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
            </noscript>
            <div>
               <p>An overview of the various ways of using Oracle XML&nbsp;DB is presented.</p>
               <p>This overview illustrates how to do the following: create and partition <code class="codeph">XMLType</code> tables and columns; enforce data integrity, load, query, and update database XML content; and generate XML data from relational data. It also explains how Oracle XML&nbsp;DB determines which character sets are used for XML documents. 
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398__GUID-3110B980-4BC0-4DA8-B5FE-4CE8010C1B95">Purchase Order Documents Illustrate Key XML Schema Features</p>
                  <p>Many of the examples presented in this chapter illustrate techniques for accessing and managing XML content in purchase-order documents. Purchase orders are highly structured documents, but you can also use the techniques shown here to work with XML documents that have little structure. </p>
                  <p>The purchase-order documents used for the examples here conform to a purchase-order XML schema that demonstrates some key features of a typical XML document:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Global element <code class="codeph">PurchaseOrder</code> is an instance of the <code class="codeph">complexType</code> <code class="codeph">PurchaseOrderType</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">PurchaseOrderType</code> defines the set of nodes that make up a <code class="codeph">PurchaseOrder</code> element
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">LineItems</code> element consists of a collection of <code class="codeph">LineItem</code> elements
                        </p>
                     </li>
                     <li>
                        <p>Each <code class="codeph">LineItem</code> element consists of two elements: <code class="codeph">Description</code> and <code class="codeph">Part</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">Part</code> element has attributes <code class="codeph">Id</code>, <code class="codeph">Quantity</code>, and <code class="codeph">UnitPrice</code></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B">Creating XMLType Tables and Columns</a><br>Creating a table or column of <code class="codeph">XMLType</code> is straightforward because it is an abstract data type.
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242">Creating Virtual Columns on XMLType Data Stored as Binary XML</a><br>You can create virtual columns only for <code class="codeph">XMLType</code> data that is stored as binary XML. Such columns are useful for partitioning or constraining the data.
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5">Partitioning Tables That Contain XMLType Data Stored as Binary XML</a><br>You can partition a table that contains <code class="codeph">XMLType</code> data stored as binary XML. 
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596">Enforcing XML Data Integrity Using the Database</a><br>You can combine the power of SQL and XML with the ability of the database to enforce rules.
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B">Loading XML Content into Oracle XML&nbsp;DB</a><br>There are several ways to load XML content into Oracle XML&nbsp;DB.
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75">Querying XML Content Stored in Oracle XML&nbsp;DB</a><br>There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it. 
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8">Updating XML Content Stored in Oracle XML&nbsp;DB</a><br>You can update XML content, replacing either the entire contents of a     document or only particular parts of a document. 
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B">Generating XML Data from Relational Data</a><br>You can use Oracle XML&nbsp;DB to generate XML data from relational data.
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D">Character Sets of XML Documents</a><br>There are a few ways in which Oracle XML&nbsp;DB determines which character sets are used for XML documents
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398__GUID-6E7C00BE-B33D-4314-BB86-CE698C0D0877">
                  <p class="notep1">See Also:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="getting-started-with-XML-DB.html#GUID-39A9B429-EFD9-4FC0-AB93-35324AF6D6AE" title="When planning an Oracle XML&nbsp;DB application it can be worthwhile to consider some preliminary design criteria.">Application Design Considerations for Oracle XML&nbsp;DB</a> for recommended Oracle XML&nbsp;DB features for most uses
                        </p>
                     </li>
                     <li>
                        <p><a href="XMLType-APIs.html#GUID-6209297F-DBE4-4F31-85F1-4083BF5BDE01" title="You can use Oracle XML&nbsp;DB XMLType PL/SQL, Java, C APIs, and Oracle Data Provider for .NET (ODP.NET) to access and manipulate XML data.">XMLType APIs</a>, <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="The use of XML Schema and object-relational storage of XMLType data is covered.">XML Schema and Object-Relational XMLType</a>, and <a href="XML-DB-repository.html#GUID-840EBE35-8FC8-4150-9FC8-78442FD1B12B" title="Oracle XML&nbsp;DB Repository lets you version your data, implement and manage security, and use APIs to access and manipulate repository resources.">Oracle XML&nbsp;DB Repository</a> for information about more advanced Oracle XML&nbsp;DB features
                        </p>
                     </li>
                     <li>
                        <p><a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD" title="The full listings of purchase-order XML schemas that are used in various examples are presented.">Purchase-Order XML Schemas</a> for the purchase-order XML schemas used for examples in this chapter 
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="XML-DB-basics.html#GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" title="The basics of Oracle XML&nbsp;DB are introduced.">Oracle XML&nbsp;DB Basics</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5801"></a><a id="ADXDB5802"></a><a id="ADXDB4044"></a><div class="props_rev_3"><a id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B" name="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B"></a><h3 id="ADXDB-GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B" class="sect3"><span class="enumeration_section">3.1 </span>Creating XMLType Tables and Columns
               </h3>
               <div>
                  <p>Creating a table or column of <code class="codeph">XMLType</code> is straightforward because it is an abstract data type.
                  </p>
                  <div class="section">
                     <p>The basic <code class="codeph">CREATE TABLE</code> statement, specifying no storage options and no XML schema, stores <code class="codeph">XMLType</code> data as binary XML.<a id="fn_1" name="fn_1" href="#fn_1" onclick="footdisplay(1, "The XMLType storage model for XML schema-based data is whatever was specified during registration of the referenced XML schema. If no storage model was specified during registration, then object-relational storage is used.")"><sup>Foot&nbsp;1</sup></a></p>
                     <p><a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFCFCDG">Example 3-1</a> creates an <code class="codeph">XMLType</code> column, and <a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFJACCB">Example 3-2</a> creates an <code class="codeph">XMLType</code> table. 
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFCFCDG">
                     <p class="titleinexample">Example 3-1 Creating a Table with an XMLType Column</p><pre class="pre codeblock"><code>CREATE TABLE mytable1 (key_column VARCHAR2(10) PRIMARY KEY, xml_column <span class="bold">XMLType</span>);</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFJACCB">
                     <p class="titleinexample">Example 3-2 Creating a Table of XMLType</p><pre class="pre codeblock"><code>CREATE TABLE mytable2 OF <span class="bold">XMLType</span>;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5" title="You can create XMLType tables and columns that are constrained to a global element defined by an XML schema. After an XMLType column has been constrained to a particular element and a particular schema, it can only contain documents that are compliant with the schema definition of that element.">Creation of XMLType Tables and Columns Based on XML Schemas</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6339"></a><a id="ADXDB6340"></a><a id="ADXDB6338"></a><div class="props_rev_3"><a id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" name="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242"></a><h3 id="ADXDB-GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" class="sect3"><span class="enumeration_section">3.2 </span>Creating Virtual Columns on XMLType Data Stored as Binary XML
               </h3>
               <div>
                  <p>You can create virtual columns only for <code class="codeph">XMLType</code> data that is stored as binary XML. Such columns are useful for partitioning or constraining the data.
                  </p>
                  <div class="section">
                     <p>You create virtual columns for XML data the same way you create them for other data types, but you use a slightly different syntax. (In particular, you cannot specify constraints in association with the column definition.)</p>
                     <p>You create a virtual column based on an XML element or attribute by defining it in terms of a SQL expression that involves that element or attribute. The column is thus function-based. </p>
                     <p>You use SQL/XML functions <code class="codeph">XMLCast</code> and <code class="codeph">XMLQuery</code> to do this, as shown in <a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">Example 3-3</a> and <a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">Example 3-4</a>. The XQuery expression argument to function <code class="codeph">XMLQuery</code> must be a simple XPath expression that uses only the child and attribute axes.
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">Example 3-3</a> creates <code class="codeph">XMLType</code> table <code class="codeph">po_binaryxml</code>, stored as binary XML. It creates virtual column <code class="codeph">date_col</code>, which represents the XML data in attribute <code class="codeph">/PurchaseOrder/@orderDate</code>.
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">Example 3-4</a> creates relational table <code class="codeph">rel_tab</code>, which has two columns: <code class="codeph">VARCHAR2</code> column <code class="codeph">key_col</code> for the primary key, and <code class="codeph">XMLType</code> column <code class="codeph">xml_col</code> for the XML data.
                     </p>
                     <p>Because <code class="codeph">XMLType</code> is an abstract data type, if you create virtual columns on an <code class="codeph">XMLType</code> table or column then those columns are <span class="italic">hidden</span>. They do not show up in <code class="codeph">DESCRIBE</code> statements, for example. This hiding enables tools that use operations such as <code class="codeph">DESCRIBE</code> to function normally and not be misled by the virtual columns.
                     </p>
                     <div class="infoboxnote" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__GUID-A0DFADB0-98D4-4242-BEFA-11783DCB7600">
                        <p class="notep1">Note:</p>
                        <p>If you use a virtual column for interval partitioning then it <span class="italic">must</span> have data type <code class="codeph">NUMBER</code> or <code class="codeph">DATE</code>, otherwise an error is raised. Use SQL/XML functions <code class="codeph">XMLCast</code> and <code class="codeph">XMLQuery</code> to cast to the proper data type.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__GUID-B28290E4-574E-45AB-A7E4-712A0D37729F">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for information about creating tables with virtual columns
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">
                     <p class="titleinexample">Example 3-3 Creating a Virtual Column for an XML Attribute in an XMLType Table</p><pre class="pre codeblock"><code>CREATE TABLE po_binaryxml OF XMLType
  XMLTYPE STORE AS BINARY XML
  <span class="bold">VIRTUAL COLUMNS</span>
    (date_col AS (XMLCast(XMLQuery('/PurchaseOrder/@orderDate'
                                   PASSING OBJECT_VALUE RETURNING CONTENT)
                          AS DATE)));
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">
                     <p class="titleinexample">Example 3-4 Creating a Virtual Column for an XML Attribute in an XMLType Column</p><pre class="pre codeblock"><code>CREATE TABLE reltab (key_col VARCHAR2(10) PRIMARY KEY,
                     xml_col XMLType)
  XMLTYPE xml_col STORE AS BINARY XML
  <span class="bold">VIRTUAL COLUMNS</span>
    (date_col AS (XMLCast(XMLQuery('/PurchaseOrder/@orderDate'
                                   PASSING xml_col RETURNING CONTENT)
                          AS DATE)));
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" title="You can partition a table that contains XMLType data stored as binary XML.">Partitioning Tables That Contain XMLType Data Stored as Binary XML</a></li>
                        <li><a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" title="You can use SQL constraints and database triggers to ensure data-integrity properties such as uniqueness and foreign-key relations.">Enforcing Referential Integrity Using SQL Constraints</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6342"></a><a id="ADXDB6343"></a><a id="ADXDB6341"></a><div class="props_rev_3"><a id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" name="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5"></a><h3 id="ADXDB-GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" class="sect3"><span class="enumeration_section">3.3 </span>Partitioning Tables That Contain XMLType Data Stored as Binary XML
               </h3>
               <div>
                  <p>You can partition a table that contains <code class="codeph">XMLType</code> data stored as binary XML. 
                  </p>
                  <div class="section">
                     <p>There are two possibilities:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The table is relational, with an <code class="codeph">XMLType</code> column and a non-<code class="codeph">XMLType</code> column.
                           </p>
                        </li>
                        <li>
                           <p>The table is of data type <code class="codeph">XMLType</code>. 
                           </p>
                        </li>
                     </ul>
                     <p>In the case of an <code class="codeph">XMLType</code> column, you use the non-<code class="codeph">XMLType</code> column as the partitioning key. This is illustrated in <a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCHHDE">Example 3-5</a>.
                     </p>
                     <p>This case presents nothing new or specific with respect to XML data. The fact that one of the columns contains <code class="codeph">XMLType</code> data is irrelevant. Things are different for the other case: partitioning an <code class="codeph">XMLType</code> table.
                     </p>
                     <p>XML data has its own structure, which (except for object-relational storage of <code class="codeph">XMLType</code>) is not reflected directly in database data structure. For <code class="codeph">XMLType</code> data stored as binary XML, individual XML elements and attributes are not mapped to individual database columns or tables.
                     </p>
                     <p>Therefore, to partition binary XML data according to the values of individual elements or attributes, the standard approach for relational data does not apply. Instead, you must create <span class="italic">virtual columns</span> that represent the XML data of interest, and then use those virtual columns to define the constraints or partitions that you need.
                     </p>
                     <p>The technique is as follows: </p>
                     <ol>
                        <li>
                           <p>Define virtual columns that correspond to the XML elements or attributes that you are interested in.</p>
                        </li>
                        <li>
                           <p>Use those columns to partition the <code class="codeph">XMLType</code> data as a whole.
                           </p>
                        </li>
                     </ol>
                     <p>This is illustrated in <a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCIJEF">Example 3-6</a>: virtual column <code class="codeph">date_col</code> targets the <code class="codeph">orderDate</code> attribute of element <code class="codeph">PurchaseOrder</code> in a purchase-order document. This column is used as the partitioning key.
                     </p>
                     <p>For best performance using a partitioned table containing XML data, Oracle recommends that you use an <code class="codeph">XMLType</code> column rather than an <code class="codeph">XMLType</code> table, and you therefore partition using a non-<code class="codeph">XMLType</code> column.
                     </p>
                     <div class="infoboxnote" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__GUID-4D49DA2D-CDB6-4130-8B35-13F90D076A20">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can partition an <code class="codeph">XMLType</code> table using a virtual column only if the storage model is binary XML. Range, hash, and list partitioning are supported.
                              </p>
                           </li>
                           <li>
                              <p>Partitioning of <code class="codeph">XMLType</code> tables stored as XML is supported starting with 11g Release 2 (11.2). It is supported only if the database compatibility (parameter <code class="codeph">compatible</code> in file <code class="codeph">init.ora</code>) is 11.2 or higher.
                              </p>
                           </li>
                           <li>
                              <p>If a relational table has an <code class="codeph">XMLType</code> <span class="italic">column</span>, you cannot partition the table using that column to define virtual columns of XML data.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCHHDE">
                     <p class="titleinexample">Example 3-5 Partitioning a Relational Table That Has an XMLType Column </p><pre class="pre codeblock"><code>CREATE TABLE reltab (key_col VARCHAR2(10) PRIMARY KEY,
                     xml_col XMLType)
  XMLTYPE xml_col STORE AS BINARY XML
  <span class="bold">PARTITION BY RANGE (key_col)</span>
    <span class="bold">(PARTITION P1 VALUES LESS THAN ('abc'),</span>
     <span class="bold">PARTITION P2 VALUES LESS THAN (MAXVALUE))</span>;
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCIJEF">
                     <p class="titleinexample">Example 3-6 Partitioning an XMLType Table</p><pre class="pre codeblock"><code>CREATE TABLE po_binaryxml OF XMLType
  XMLTYPE STORE AS BINARY XML
  <span class="bold">VIRTUAL COLUMNS</span>
    (date_col AS (XMLCast(XMLQuery('/PurchaseOrder/@orderDate'
                                   PASSING OBJECT_VALUE RETURNING CONTENT)
                          AS DATE)))
  <span class="bold">PARTITION BY RANGE (date_col)</span>
    <span class="bold">(PARTITION orders2001 VALUES LESS THAN (to_date('01-JAN-2002')),</span>
     <span class="bold">PARTITION orders2002 VALUES LESS THAN (MAXVALUE))</span>;
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="If you partition an XMLType table, or a table with an XMLType column, using range, list, or hash partitioning, you can also create an XMLIndex index on the table. You can optionally ensure that index creation and maintenance are carried out in parallel.">XMLIndex Partitioning and Parallelism</a></li>
                        <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" title="When you partition an object-relational XMLType table or a table with an XMLType column that is stored object-relationally and you use list, range, or hash partitioning, any ordered collection tables (OCTs) or out-of-line tables within the data are automatically partitioned accordingly, by default.">Overview of Partitioning XMLType Tables and Columns Stored Object-Relationally</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4101"></a><a id="ADXDB0345"></a><div class="props_rev_3"><a id="GUID-8320CE79-5536-4252-BAF4-746692EBA596" name="GUID-8320CE79-5536-4252-BAF4-746692EBA596"></a><h3 id="ADXDB-GUID-8320CE79-5536-4252-BAF4-746692EBA596" class="sect3"><span class="enumeration_section">3.4 </span>Enforcing XML Data Integrity Using the Database
               </h3>
               <div>
                  <p>You can combine the power of SQL and XML with the ability of the database to enforce rules.</p>
                  <div class="section">
                     <p>You can use SQL to supplement the functionality provided by XML schema. Only well-formed XML documents can be stored in <code class="codeph">XMLType</code> tables or columns. A <strong class="term">well-formed</strong> XML document is one that conforms to the syntax of the XML version declared in its XML declaration. This includes having a single root element, properly nested tags, and so forth. Additionally, if the <code class="codeph">XMLType</code> table or column is constrained to an XML schema then only documents that conform to that XML schema can be stored in that table or column. Any attempt to store or insert any other kind of XML document in an XML schema-based <code class="codeph">XMLType</code> raises an error. <a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596__BABCBCJJ">Example 3-7</a> illustrates this.
                     </p>
                     <p>Such an error occurs only when content is inserted directly into an <code class="codeph">XMLType</code> table. It indicates that Oracle XML&nbsp;DB did not recognize the document as a member of the class defined by the XML schema. For a document to be recognized as a member of the class defined by the schema, the following conditions must be true:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The name of the XML document root element must match the name of global element used to define the <code class="codeph">XMLType</code> table or column.
                           </p>
                        </li>
                        <li>
                           <p>The XML document must include the appropriate attributes from the <code class="codeph">XMLSchema-instance</code> namespace, or the XML document must be explicitly associated with the XML schema using the <code class="codeph">XMLType</code> constructor or <code class="codeph">XMLType</code> method <code class="codeph">createSchemaBasedXML()</code>.
                           </p>
                        </li>
                     </ul>
                     <p>If the constraining XML schema declares a <code class="codeph">targetNamespace</code>, then the instance documents must contain the appropriate namespace declarations to place the root element of the document in the <code class="codeph">targetNamespace</code> defined by the XML schema.
                     </p>
                     <div class="infoboxnote" id="GUID-8320CE79-5536-4252-BAF4-746692EBA596__GUID-9A41BA8D-9224-4712-BB73-3D695C950734">
                        <p class="notep1">Note:</p>
                        <p>XML constraints are enforced only within individual XML documents. Database (SQL) constraints are enforced across sets of XML documents.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-8320CE79-5536-4252-BAF4-746692EBA596__BABCBCJJ">
                     <p class="titleinexample">Example 3-7 Error From Attempting to Insert an Incorrect XML Document</p><pre class="pre codeblock"><code>INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'Invoice.xml'), nls_charset_id('AL32UTF8')))
  VALUES (XMLType(bfilename('XMLDIR', 'Invoice.xml'), nls_charset_id('AL32UTF8')))
          *
ERROR at line 2:
ORA-19007: Schema - does not match expected
http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd.
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1">Enforcing Referential Integrity Using SQL Constraints</a><br>You can use SQL constraints and database triggers to ensure data-integrity properties such as uniqueness and foreign-key relations.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="transformation-and-validation-of-XMLType-data.html#GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" title="When you insert XML Schema-based documents into the database they can be validated partially or fully.">Partial and Full XML Schema Validation</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4110"></a><a id="ADXDB6344"></a><a id="ADXDB6345"></a><a id="ADXDB4112"></a><a id="ADXDB4109"></a><div class="props_rev_3"><a id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" name="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1"></a><h4 id="ADXDB-GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" class="sect4"><span class="enumeration_section">3.4.1 </span>Enforcing Referential Integrity Using SQL Constraints
                  </h4>
                  <div>
                     <p>You can use SQL constraints and database triggers to ensure data-integrity properties such as uniqueness and foreign-key relations.</p>
                     <div class="section">
                        <p>The W3C XML Schema Recommendation defines a powerful language for defining the contents of an XML document. However, there are some simple data management concepts that are not currently addressed by the W3C XML Schema Recommendation. These include the ability to ensure that the value of an element or attribute has either of these properties:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It is unique across a set of XML documents (a <code class="codeph">UNIQUE</code> constraint).
                              </p>
                           </li>
                           <li>
                              <p>It exists in a particular data source that is outside of the current document (<code class="codeph">FOREIGN KEY</code> constraint).
                              </p>
                           </li>
                        </ul>
                        <p>With Oracle XML DB, however, you can enforce such constraints. The mechanisms that you use to enforce integrity on XML data are the same as those you use to enforce integrity on relational data. Simple rules, such as uniqueness and foreign-key relationships, can be enforced by specifying SQL constraints. More complex rules can be enforced by specifying database triggers. </p>
                        <p>Oracle XML DB lets you use the database to enforce business rules on XML content, in addition to enforcing rules that can be specified using XML Schema constructs. The database enforces these business rules regardless of whether XML is inserted directly into a table or uploaded using one of the protocols supported by Oracle XML DB Repository.</p>
                        <p>XML data has its own structure, which (except for object-relational storage of <code class="codeph">XMLType</code>) is not reflected directly in database data structure. For <code class="codeph">XMLType</code> data stored as binary XML, individual XML elements and attributes are not mapped to individual database columns or tables.
                        </p>
                        <p>Therefore, to constrain binary XML data according to the values of individual elements or attributes, the standard approach for relational data does not apply. Instead, you must create <span class="italic">virtual columns</span> that represent the XML data of interest, and then use those virtual columns to define the constraints that you need.
                        </p>
                        <p>The technique is as follows: </p>
                        <ol>
                           <li>
                              <p>Define virtual columns that correspond to the XML elements or attributes that you are interested in.</p>
                           </li>
                           <li>
                              <p>Use those columns to constrain the <code class="codeph">XMLType</code> data as a whole.
                              </p>
                           </li>
                        </ol>
                        <p>The binary XML data can be in an <code class="codeph">XMLType</code> table or an <code class="codeph">XMLType</code> column of a relational table. In the former case, you can include creation of the constraint as part of the <code class="codeph">CREATE TABLE</code> statement, if you like. For the latter case, you must create the constraint using an <code class="codeph">ALTER TABLE</code> statement, after the relational table has been created.
                        </p>
                        <div class="infoboxnote" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__GUID-86132A6B-687F-46B6-981D-3A338085F5CD">
                           <p class="notep1">See also:</p>
                           <p><a href="../errmg/index.html" target="_blank"><span><cite>Oracle Database Error Messages Reference</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">
                        <p class="titleinexample">Example 3-8 Constraining a Binary XML Table Using a Virtual Column</p>
                        <p>This example illustrates the technique for an <code class="codeph">XMLType</code> table. It defines virtual column <code class="codeph">c_xtabref</code> using the <code class="codeph">Reference</code> element in a purchase-order document. It defines uniqueness constraint <code class="codeph">reference_is_unique</code> on that column, which ensures that the value of node <code class="codeph">/PurchaseOrder/Reference/text()</code> is unique across all documents that are stored in the table. It fills the table with the data from <code class="codeph">OE.purchaseorder</code>. It then tries to insert a duplicate document, <code class="codeph">DuplicateReference.xml</code>, which violates the uniqueness constraint, raising an error.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_binaryxml OF XMLType
  (<span class="bold">CONSTRAINT</span> reference_is_unique <span class="bold">UNIQUE</span> (<span class="bold">c_xtabref</span>))
  XMLTYPE STORE AS BINARY XML
  <span class="bold">VIRTUAL COLUMNS</span>
    (<span class="bold">c_xtabref</span> AS (XMLCast(XMLQuery('/PurchaseOrder/Reference'
                                      PASSING OBJECT_VALUE RETURNING CONTENT)
                             AS VARCHAR2(32))));
 
INSERT INTO po_binaryxml SELECT OBJECT_VALUE FROM OE.purchaseorder;

132 rows created.
 
INSERT INTO po_binaryxml
  VALUES (XMLType(bfilename('XMLDIR', 'DuplicateReference.xml'),
                  nls_charset_id('AL32UTF8')));
INSERT INTO po_binaryxml
*
ERROR at line 1:
<span class="bold">ORA-00001: unique constraint (OE.REFERENCE_IS_UNIQUE) violated</span>
 </pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGHCEDI">
                        <p class="titleinexample">Example 3-9 Constraining a Binary XML Column Using a Virtual Column: Uniqueness</p>
                        <p>This example illustrates the technique for an <code class="codeph">XMLType</code> column of a relational table. It defines virtual column <code class="codeph">c_xcolref</code> and uniqueness constraint <code class="codeph">fk_ref</code>, which references the uniqueness constraint defined in <a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">Example 3-8</a>. As in <a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">Example 3-8</a>, this ensures that the value of node <code class="codeph">/PurchaseOrder/Reference/text()</code> is unique across all documents that are stored in <code class="codeph">XMLType</code> column <code class="codeph">po_binxml_col</code>. 
                        </p>
                        <p>The example fills the <code class="codeph">XMLType</code> column with the same data from <code class="codeph">OE.purchaseorder</code>. It then tries to insert duplicate document, <code class="codeph">DuplicateReference.xml</code>, which violates the uniqueness constraint, raising an error.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_reltab (po_binxml_col XMLType)
  XMLTYPE po_binxml_col STORE AS BINARY XML
  VIRTUAL COLUMNS
    (<span class="bold">c_xcolref</span> AS (XMLCast (XMLQuery('/PurchaseOrder/Reference'
                                    PASSING po_binxml_col RETURNING CONTENT)
                           AS VARCHAR2(32))));

ALTER TABLE po_reltab <span class="bold">ADD CONSTRAINT</span> reference_is_unique <span class="bold">UNIQUE</span> (<span class="bold">c_xcolref</span>));

INSERT INTO po_reltab SELECT OBJECT_VALUE FROM OE.purchaseorder;
INSERT INTO po_reltab
  VALUES (XMLType(bfilename('XMLDIR', 'DuplicateReference.xml'),
                  nls_charset_id('AL32UTF8')));
INSERT INTO po_reltab
*
ERROR at line 1:
<span class="bold">ORA-00001: unique constraint (OE.REFERENCE_IS_UNIQUE) violated</span>
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGDJJFJ">
                        <p class="titleinexample">Example 3-10 Constraining a Binary XML Column Using a Virtual Column: Foreign Key</p>
                        <p>This example is similar to <a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGHCEDI">Example 3-9</a>, but it uses a foreign-key constraint, <code class="codeph">fk_ref</code>,  which references the column with the uniqueness constraint defined in <a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">Example 3-8</a>. Insertion of the document in file <code class="codeph">DuplicateReference.xml</code> succeeds here, since that document is in (virtual) column <code class="codeph">c_tabref</code> of table <code class="codeph">po_binaryxml</code>. Insertion of a document that does not match any document in table <code class="codeph">po_binaryxml</code>.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_reltab (po_binxml_col XMLType)
  XMLTYPE po_binxml_col STORE AS BINARY XML
  VIRTUAL COLUMNS
    (<span class="bold">c_xcolref</span> AS (XMLCast (XMLQuery('/PurchaseOrder/Reference'
                                    PASSING po_binxml_col RETURNING CONTENT)
                           AS VARCHAR2(32))));

ALTER TABLE po_reltab <span class="bold">ADD CONSTRAINT fk_ref FOREIGN KEY (c_xcolref)</span>
                                            <span class="bold">REFERENCES po_binaryxml(c_xtabref);</span>

INSERT INTO po_reltab
  VALUES (XMLType(bfilename('XMLDIR', 'DuplicateReference.xml'),
                  nls_charset_id('AL32UTF8')));

INSERT INTO po_reltab
  VALUES ('<span class="bold">&lt;PurchaseOrder&gt;&lt;Reference&gt;Not Compliant&lt;/Reference&gt;&lt;/PurchaseOrder&gt;</span>');
INSERT INTO po_reltab VALUES ('&lt;PurchaseOrder&gt;&lt;Reference&gt;Not Compliant
&lt;/Reference&gt;&lt;/PurchaseOrder&gt;')
*
ERROR at line 1:
<span class="bold">ORA-02291: integrity constraint (OE.FK_REF) violated - parent key not found</span>
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__BABHEHEG">
                        <p class="titleinexample">Example 3-11 Enforcing Database Integrity When Loading XML Using FTP</p>
                        <p>Integrity rules defined using constraints and triggers are also enforced when XML schema-based XML content is loaded into Oracle XML DB Repository. This example shows that database integrity is also enforced when a protocol, such as FTP, is used to upload XML schema-based XML content into Oracle XML DB Repository. In this case, additional constraints, besides uniqueness, were also violated.</p><pre class="oac_no_warn" dir="ltr">$ ftp localhost 2100
Connected to localhost.
220 mdrake-sun FTP Server (Oracle XML DB/Oracle Database 10g Enterprise Edition
Release 10.1.0.0.0 - Beta) ready.
Name (localhost:oracle10): QUINE
331 Password required for QUINE
Password: <span class="italic">password</span>
230 QUINE logged in
ftp&gt; cd /source/schemas
250 CWD Command successful
ftp&gt; put InvalidReference.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-31154: invalid XML document
ORA-19202: Error occurred in XML processing
LSX-00221: "SBELL-20021009" is too short (minimum length is 18)
ORA-06512: at "SYS.XMLTYPE", line 333
ORA-06512: at "QUINE.VALIDATE_PURCHASEORDER", line 3
ORA-04088: error during execution of trigger 'QUINE.VALIDATE_PURCHASEORDER'
550 End Error Response
ftp&gt; put InvalidElement.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-30937: No schema definition for 'UserName' (namespace '##local') in parent
'PurchaseOrder'
550 End Error Response
ftp&gt; put DuplicateReference.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-00001: unique constraint (QUINE.REFERENCE_IS_UNIQUE) violated
550 End Error Response
ftp&gt; put InvalidUser.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-02291: integrity constraint (QUINE.USER_IS_VALID) violated - parent key not
 found
550 End Error Response
</pre><p>When an error occurs while a document is being uploaded using a protocol, Oracle XML DB provides the client with the full SQL error trace. How the error is interpreted and reported to you is determined by the error-handling built into the client application. Some clients, such as a command line FTP tool, report the error returned by Oracle XML DB, while others, such as Microsoft Windows Explorer, report a generic error message.</p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA" title="For XMLType data stored object-relationally, you can specify typical relational constraints for elements and attributes that occur only once in an XML document.">Specification of Relational Constraints on XMLType Tables and Columns</a></li>
                           <li><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" title="You can create virtual columns only for XMLType data that is stored as binary XML. Such columns are useful for partitioning or constraining the data.">Creating Virtual Columns on XMLType Data Stored as Binary XML</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596" title="You can combine the power of SQL and XML with the ability of the database to enforce rules.">Enforcing XML Data Integrity Using the Database</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4048"></a><div class="props_rev_3"><a id="GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" name="GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B"></a><h3 id="ADXDB-GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" class="sect3"><span class="enumeration_section">3.5 </span>Loading XML Content into Oracle XML&nbsp;DB
               </h3>
               <div>
                  <p>There are several ways to load XML content into Oracle XML&nbsp;DB.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-23956CE8-C61D-4178-968E-5686CAD80C08">Loading XML Content Using SQL or PL/SQL</a><br></li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE">Loading XML Content Using Java</a><br>With a DOM you can use Java to load a <code class="codeph">SQLXML</code> instance.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-23802182-8EF2-46C5-966B-03D9F11A258D">Loading XML Content Using C</a><br>With a DOM you can use C code to load an <code class="codeph">XMLType</code> instance.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-B271C430-A1FB-4818-A3F4-056C59CC5553">Loading Large XML Files that Contain Small XML Documents</a><br>When loading large XML files consisting of a collection of smaller XML documents, it is often more efficient to use Simple API for XML (SAX) parsing to break the file into a set of smaller documents, and then insert those documents. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-157EE50B-6004-4B30-BC85-AC60581C930E">Loading Large XML Files Using SQL*Loader</a><br>You can use  SQL*Loader to load large amounts of XML data into Oracle Database.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B">Loading XML Documents into the Repository Using DBMS_XDB_REPOS</a><br>You can use PL/SQL package <code class="codeph">DBMS_XDB_REPOS</code> to load XML documents into Oracle XML&nbsp;DB Repository. You can access repository documents (resources) using path-based rather than table-based techniques. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C4D83D80-7B69-4C57-B817-2699722D28A3">Loading Documents into the Repository Using Protocols</a><br>You can load documents, including XML documents, from a local file system into Oracle XML&nbsp;DB Repository using popular protocols.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5988"></a><a id="ADXDB4051"></a><a id="ADXDB4049"></a><div class="props_rev_3"><a id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08" name="GUID-23956CE8-C61D-4178-968E-5686CAD80C08"></a><h4 id="ADXDB-GUID-23956CE8-C61D-4178-968E-5686CAD80C08" class="sect4"><span class="enumeration_section">3.5.1 </span>Loading XML Content Using SQL or PL/SQL
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can use a simple <code class="codeph">INSERT</code> operation in SQL or PL/SQL to load an XML document into the database. 
                        </p>
                        <p>Before the document can be stored as an <code class="codeph">XMLType</code> column or table, you must convert it into an <code class="codeph">XMLType</code> instance using one of the <code class="codeph">XMLType</code> constructors.
                        </p>
                        <p><code class="codeph">XMLType</code> <strong class="term">constructors</strong> allow an <code class="codeph">XMLType</code> instance to be created from different sources, including <code class="codeph">VARCHAR</code>, <code class="codeph">CLOB</code>, and <code class="codeph">BFILE</code> values. The constructors accept additional arguments that reduce the amount of processing associated with <code class="codeph">XMLType</code> creation. For example, if you are sure that a given source XML document is valid, you can provide an argument to the constructor that disables the type-checking that is otherwise performed. 
                        </p>
                        <p>In addition, if the source data is not encoded in the database character set, an <code class="codeph">XMLType</code> instance can be constructed using a <code class="codeph">BFILE</code> or <code class="codeph">BLOB</code> value. The encoding of the source data is specified through the character set id (<code class="codeph">csid</code>) argument of the constructor.
                        </p>
                        <p>When you use SQL <code class="codeph">INSERT</code> to insert a large document containing collections into <code class="codeph">XMLType</code> tables (but not into <code class="codeph">XMLType</code> columns), Oracle XML&nbsp;DB optimizes load time and memory usage.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-23956CE8-C61D-4178-968E-5686CAD80C08__BABBBGBB">Example 3-13</a> shows how to insert XML content into an <code class="codeph">XMLType</code> table. Before making this insertion, you must create a database directory object that points to the directory containing the file to be processed. To do this, you must have the <code class="codeph">CREATE ANY DIRECTORY</code> privilege.
                        </p>
                        <div class="infoboxnotealso" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__GUID-D6EE23F5-FEB6-4D98-B918-7C02B67091E3">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../arpls/XMLTYPE.html#ARPLS369" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for a description of the <code class="codeph">XMLType</code> constructors
                                 </p>
                              </li>
                              <li>
                                 <p> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=SQLRF01603" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a>, under <code class="codeph">GRANT</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__GUID-76473048-4E3F-4B67-9223-3F92341984AE">
                        <p class="titleinexample">Example 3-12 Creating a Database Directory</p><pre class="oac_no_warn" dir="ltr">CREATE DIRECTORY xmldir AS <span class="italic">path_to_folder_containing_XML_file</span>;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__BABBBGBB">
                        <p class="titleinexample">Example 3-13 Inserting XML Content into an XMLType Table</p><pre class="oac_no_warn" dir="ltr">INSERT INTO mytable2 VALUES (XMLType(bfilename('XMLDIR', 'purchaseOrder.xml'),
                                     nls_charset_id('AL32UTF8')));
</pre><p>The value passed to <code class="codeph">nls_charset_id</code> indicates that the encoding for the file to be read is UTF-8.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based.">Query and Update of XML Data</a></li>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39" title="The PL/SQL Application Programming Interfaces (APIs) for XMLType are described.">PL/SQL APIs for XMLType: References</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D" title="Oracle XML&nbsp;DB configuration file xdbconfig.xml has parameters that control the amount of memory used by the loading operation: xdbcore-loadableunit-size and xdbcore-xobmem-bound.">Considerations for Loading and Retrieving Large Documents with Collections</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4053"></a><a id="ADXDB4052"></a><div class="props_rev_3"><a id="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE" name="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE"></a><h4 id="ADXDB-GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE" class="sect4"><span class="enumeration_section">3.5.2 </span>Loading XML Content Using Java
                  </h4>
                  <div>
                     <p>With a DOM you can use Java to load a <code class="codeph">SQLXML</code> instance.
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE__BABIEIAD">Example 3-14</a> shows how to load XML content into Oracle XML&nbsp;DB by first creating a <code class="codeph">SQLXML</code> instance in Java, given a Document Object Model (<a href="../adxdk/glossary.html#ADXDK9548" target="_blank">DOM</a>).
                        </p>
                        <p>A simple bulk loader application is available at <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">Oracle XML DB on OTN</a>. It shows how to load a directory of XML files into Oracle XML&nbsp;DB using Java Database Connectivity (JDBC). JDBC is a set of Java interfaces to Oracle Database. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE__BABIEIAD">
                        <p class="titleinexample">Example 3-14 Inserting Content into an XMLType Table Using Java</p><pre class="pre codeblock"><code>public void doInsert(Connection conn, Document doc)
throws Exception
{
  String query = "<span class="bold">INSERT INTO purchaseorder VALUES (?)</span>";
  SQLXML sx = conn.<span class="bold">createSQLXML</span>();
  DOMResult dom = sx.setResult(DOMResult.class);
  dom.setNode(doc);
  PreparedStatement statement = conn.prepareStatement(query);
  statement.<span class="bold">setSQLXML</span>(1, sx);
  statement.execute();
}</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4055"></a><a id="ADXDB4054"></a><div class="props_rev_3"><a id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D" name="GUID-23802182-8EF2-46C5-966B-03D9F11A258D"></a><h4 id="ADXDB-GUID-23802182-8EF2-46C5-966B-03D9F11A258D" class="sect4"><span class="enumeration_section">3.5.3 </span>Loading XML Content Using C
                  </h4>
                  <div>
                     <p>With a DOM you can use C code to load an <code class="codeph">XMLType</code> instance.
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-23802182-8EF2-46C5-966B-03D9F11A258D__BJFGHJDC">Example 3-15</a> shows how to insert XML content into an <code class="codeph">XMLType</code> table using C code, by creating an <code class="codeph">XMLType</code> instance given a DOM (see <a href="../adxdk/glossary.html#ADXDK9548" target="_blank"><span><cite>Oracle XML Developer's Kit Programmer's Guide</cite></span></a>). See <a href="oracle-supplied-XML-schemas-and-examples.html#GUID-E357126F-BFCE-4A51-A559-520FE64DA756" title="A full listing of a C program that inserts XML data into an XMLType table is presented.">Loading XML Data Using C (OCI)</a> for a complete listing of this example.
                        </p>
                        <div class="infoboxnote" id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D__GUID-594E0B44-DB29-4055-B4D4-4A241248D56B">
                           <p class="notep1">Note:</p>
                           <p>For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span><cite>Oracle Database Security Guide</cite></span></a> for password management guidelines and other security recommendations.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D__BJFGHJDC">
                        <p class="titleinexample">Example 3-15 Inserting Content into an XMLType Table Using C</p><pre class="pre codeblock"><code><span class="bold">. . .</span>
void main()
{
  OCIType *xmltdo;
  xmldocnode  *doc;
  ocixmldbparam params[1];
  xmlerr       err;
  xmlctx  *xctx;
  oratext *ins_stmt;
  sword    status;
  xmlnode *root;
  oratext buf[10000];
 
  /* Initialize envhp, svchp, errhp, dur, stmthp */
  init_oci_connect();
 
  /* Get an XML context */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;dur;
  xctx = <span class="bold">OCIXmlDbInitXmlCtx</span>(envhp, svchp, errhp, params, 1);
  if (!(doc = XmlLoadDom(xctx, &amp;err, "file", filename,
                         "schema_location", schemaloc, NULL)))
    {
      printf("Parse failed.\n");
      return;
    }
  else
    printf("Parse succeeded.\n");
  root = <span class="bold">XmlDomGetDocElem</span>(xctx, doc);
  printf("The xml document is :\n");
  XmlSaveDom(xctx, &amp;err, (xmlnode *)doc, "buffer", buf, "buffer_length", 10000, NULL);
  printf("%s\n", buf);
 
  /* Insert the document into my_table */
  ins_stmt = (oratext *)"insert into purchaseorder values (:1)";
  status = OCITypeByName(envhp, errhp, svchp, (const text *) "SYS",
                         (ub4) strlen((const char *)"SYS"), (const text *) "XMLTYPE",
                         (ub4) strlen((const char *)"XMLTYPE"), (CONST text *) 0,
                         (ub4) 0, OCI_DURATION_SESSION, OCI_TYPEGET_HEADER,
                         (OCIType **) &amp;xmltdo);
  if (status == OCI_SUCCESS)
    {
      status = exec_bind_xml(svchp, errhp, stmthp, (void *)doc,
                             xmltdo, ins_stmt);
    }
  if (status == OCI_SUCCESS)
    printf ("Insert successful\n");
  else
    printf ("Insert failed\n");
 
  /* Free XML instances */
  if (doc)
    XmlFreeDocument((xmlctx *)xctx, (xmldocnode *)doc);
  /* Free XML CTX */
  <span class="bold">OCIXmlDbFreeXmlCtx</span>(xctx);
  free_oci();
}</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4056"></a><div class="props_rev_3"><a id="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553" name="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553"></a><h4 id="ADXDB-GUID-B271C430-A1FB-4818-A3F4-056C59CC5553" class="sect4"><span class="enumeration_section">3.5.4 </span>Loading Large XML Files that Contain Small XML Documents
                  </h4>
                  <div>
                     <p>When loading large XML files consisting of a collection of smaller XML documents, it is often more efficient to use Simple API for XML (SAX) parsing to break the file into a set of smaller documents, and then insert those documents. </p>
                     <div class="section">
                        <p>SAX is an XML standard interface provided by XML parsers for event-based applications. You can use SAX to load a database table from very large XML files in the order of 30 MB or larger, by creating individual documents from a collection of nodes. You can also bulk load XML files.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553__GUID-9F5AF3AE-1805-4D38-9F83-B6B3F8803B42">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=sax_project_org" target="_blank">SAX Project</a> for information about SAX
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">Oracle XML DB on OTN</a>, for an application example that loads large files using SAX
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4058"></a><a id="ADXDB4057"></a><div class="props_rev_3"><a id="GUID-157EE50B-6004-4B30-BC85-AC60581C930E" name="GUID-157EE50B-6004-4B30-BC85-AC60581C930E"></a><h4 id="ADXDB-GUID-157EE50B-6004-4B30-BC85-AC60581C930E" class="sect4"><span class="enumeration_section">3.5.5 </span>Loading Large XML Files Using SQL*Loader
                  </h4>
                  <div>
                     <p>You can use  SQL*Loader to load large amounts of XML data into Oracle Database.</p>
                     <div class="section">
                        <p>SQL*Loader loads in one of two modes, conventional or direct path. <a href="how-to-use-XML-DB.html#GUID-157EE50B-6004-4B30-BC85-AC60581C930E__BJFJFHIF" title="This tables compares SQL*Loader Conventional and Direct Load Modes.">Table 3-1</a> compares these modes.
                        </p>
                        <div class="tblformal" id="GUID-157EE50B-6004-4B30-BC85-AC60581C930E__BJFJFHIF">
                           <p class="titleintable">Table 3-1 SQL*Loader &#x2013; Conventional and Direct-Path Load Modes</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SQL*Loader &#x2013; Conventional and Direct-Path Load Modes" summary="This tables compares SQL*Loader Conventional and Direct Load Modes." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="53%" id="d14886e1654">Conventional Load Mode</th>
                                    <th align="left" valign="bottom" width="47%" id="d14886e1657">Direct-Path Load Mode</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1662" headers="d14886e1654 ">
                                       <p>Uses SQL to load data into Oracle Database. This is the <span class="italic">default</span> mode.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1662 d14886e1657 ">
                                       <p>Bypasses SQL and streams the data directly into Oracle Database.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1672" headers="d14886e1654 ">
                                       <p><span class="italic">Advantage:</span> Follows SQL semantics. For example triggers are fired and constraints are checked.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1672 d14886e1657 ">
                                       <p><span class="italic">Advantage:</span> This loads data much faster than the conventional load mode.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1683" headers="d14886e1654 ">
                                       <p><span class="italic">Disadvantage:</span> This loads data slower than with the direct load mode.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1683 d14886e1657 ">
                                       <p><span class="italic">Disadvantage:</span> SQL semantics is not obeyed. For example triggers are not fired and constraints are not checked.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>When loading LOBs with SQL*Loader direct-path load, much memory can be used. If the message <code class="codeph">SQL*Loader 700 (out of memory)</code> appears, then it is likely that more rows are being included in each load call than can be handled by your operating system and process memory. <span class="italic">Workaround:</span> use the <code class="codeph">ROWS</code> option to read a smaller number of rows in each data save.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="how-to-load-XML-data.html#GUID-B94D42C1-A20A-457A-8427-C01E39788EA1" title="The main way to load XML data into Oracle XML&nbsp;DB is to use SQL*Loader.">How to Load XML Data</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4060"></a><a id="ADXDB4059"></a><div class="props_rev_3"><a id="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B" name="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B"></a><h4 id="ADXDB-GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B" class="sect4"><span class="enumeration_section">3.5.6 </span>Loading XML Documents into the Repository Using DBMS_XDB_REPOS
                  </h4>
                  <div>
                     <p>You can use PL/SQL package <code class="codeph">DBMS_XDB_REPOS</code> to load XML documents into Oracle XML&nbsp;DB Repository. You can access repository documents (resources) using path-based rather than table-based techniques. 
                     </p>
                     <div class="section">
                        <p>To load an XML document into the repository under a given path, use PL/SQL function <code class="codeph">DBMS_XDB_REPOS.createResource</code>. <a href="how-to-use-XML-DB.html#GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B__BJFICDCH">Example 3-16</a> illustrates this.
                        </p>
                        <p>Many operations for configuring and using Oracle XML&nbsp;DB are based on processing one or more XML documents. Examples include registering an XML schema and performing an XSL transformation. The easiest way to make these XML documents available to Oracle Database is to load them into Oracle XML&nbsp;DB Repository.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B__BJFICDCH">
                        <p class="titleinexample">Example 3-16 Inserting XML Content into the Repository Using CREATERESOURCE</p><pre class="pre codeblock"><code>DECLARE
  res BOOLEAN;
BEGIN
  res := DBMS_XDB_REPOS.createResource('/home/QUINE/purchaseOrder.xml',
                                       bfilename('XMLDIR', 'purchaseOrder.xml'),
                                       nls_charset_id('AL32UTF8'));
END;/
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4062"></a><a id="ADXDB4061"></a><div class="props_rev_3"><a id="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3" name="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3"></a><h4 id="ADXDB-GUID-C4D83D80-7B69-4C57-B817-2699722D28A3" class="sect4"><span class="enumeration_section">3.5.7 </span>Loading Documents into the Repository Using Protocols
                  </h4>
                  <div>
                     <p>You can load documents, including XML documents, from a local file system into Oracle XML&nbsp;DB Repository using popular protocols.</p>
                     <div class="section">
                        <p>Oracle XML&nbsp;DB Repository can store XML documents that are either XML schema-based or non-schema-based. It can also store content that is not XML data, such as HTML files, image files, and Microsoft Word documents.</p>
                        <p>You can load XML documents from a local file system into Oracle XML&nbsp;DB Repository using protocols such as WebDAV, from Windows Explorer or other tools that support WebDAV. <a href="how-to-use-XML-DB.html#GUID-C4D83D80-7B69-4C57-B817-2699722D28A3__CHDHJDAE">Figure 3-1</a> shows a simple drag and drop operation for copying the contents of the <code class="codeph">SCOTT</code> folder from the local hard drive to folder <code class="codeph">poSource</code> in Oracle XML&nbsp;DB Repository.
                        </p>
                        <div class="figure" id="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3__CHDHJDAE">
                           <p class="titleinfigure">Figure 3-1 Loading Content into the Repository Using Windows Explorer</p><img src="img/repo_load.gif" width="478" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" longdesc="img_text/repo_load.html"><br><a href="img_text/repo_load.html">Description of "Figure 3-1 Loading Content into the Repository Using Windows Explorer"</a></div>
                        <!-- class="figure" -->
                        <p>The copied folder might contain, for example, an XML schema document, an HTML page, and some XSLT stylesheets.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="There are several ways to load XML content into Oracle XML&nbsp;DB.">Loading XML Content into Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4116"></a><div class="props_rev_3"><a id="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" name="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75"></a><h3 id="ADXDB-GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" class="sect3"><span class="enumeration_section">3.6 </span>Querying XML Content Stored in Oracle XML&nbsp;DB
               </h3>
               <div>
                  <p>There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it. </p>
                  <div class="infoboxnote" id="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75__GUID-EBDA1BAC-73E1-44E9-AE6B-5DBC5D5855FD">
                     <p class="notep1">Note:</p>
                     <p>For efficient query performance you typically need to create indexes. For information about indexing XML data, see <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">Indexes for XMLType Data</a>.
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C">PurchaseOrder XML Document Used in Examples</a><br>An XML schema defines the purchase-order documents used in examples.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-42EDC657-C53B-441F-96E3-31E755A7A30E">Retrieving the Content of an XML Document Using Pseudocolumn OBJECT_VALUE</a><br>Pseudocolumn <code class="codeph">OBJECT_VALUE</code> can be used as an alias for the value of an object table. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C">Accessing Fragments or Nodes of an XML Document Using XMLQUERY</a><br>You can use SQL/XML function <code class="codeph">XMLQuery</code> to extract the nodes that match an XQuery expression. The result is returned as an instance of <code class="codeph">XMLType</code>. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3">Accessing Text Nodes and Attribute Values Using XMLCAST and XMLQUERY</a><br>You can access text node and attribute values using SQL/XML standard functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code>. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F">Searching an XML Document Using XMLEXISTS, XMLCAST, and XMLQUERY</a><br>You can use SQL/XML standard functions <code class="codeph">XMLExists</code>, <code class="codeph">XMLCast</code>, and <code class="codeph">XMLQuery</code> in a SQL <code class="codeph">WHERE</code> clause to limit query results.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532">Performing SQL Operations on XMLType Fragments Using XMLTABLE</a><br>You can use SQL/XML function <code class="codeph">XMLTable</code> to perform SQL operations on a set of nodes that match an XQuery expression.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4118"></a><a id="ADXDB4117"></a><div class="props_rev_3"><a id="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C" name="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C"></a><h4 id="ADXDB-GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C" class="sect4"><span class="enumeration_section">3.6.1 </span>PurchaseOrder XML Document Used in Examples
                  </h4>
                  <div>
                     <p>An XML schema defines the purchase-order documents used in examples.</p>
                     <div class="section">
                        <p>Examples presented here are based on the <code class="codeph">PurchaseOrder</code> XML document shown in <a href="how-to-use-XML-DB.html#GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C__BJFDAFHE">Example 3-17</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C__BJFDAFHE">
                        <p class="titleinexample">Example 3-17 PurchaseOrder XML Instance Document</p><pre class="pre codeblock"><code>&lt;PurchaseOrder 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation=
    "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
  &lt;Actions&gt;
    &lt;Action&gt;
      &lt;User&gt;SVOLLMAN&lt;/User&gt;
    &lt;/Action&gt;
  &lt;/Actions&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
  &lt;User&gt;SBELL&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions&gt;
    &lt;name&gt;Sarah J. Bell&lt;/name&gt;
    &lt;address&gt;400 Oracle Parkway
      Redwood Shores
      CA
      94065
      USA&lt;/address&gt;
    &lt;telephone&gt;650 506 7400&lt;/telephone&gt;
  &lt;/ShippingInstructions&gt;
  &lt;SpecialInstructions&gt;Air Mail&lt;/SpecialInstructions&gt;
  &lt;LineItems&gt;
    &lt;LineItem ItemNumber="1"&gt;
      &lt;Description&gt;A Night to Remember&lt;/Description&gt;
      &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="2"&gt;
      &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
      &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="3"&gt;
      &lt;Description&gt;Sisters&lt;/Description&gt;
      &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
    &lt;/LineItem&gt;
  &lt;/LineItems&gt;
&lt;/PurchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4120"></a><a id="ADXDB4119"></a><div class="props_rev_3"><a id="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E" name="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E"></a><h4 id="ADXDB-GUID-42EDC657-C53B-441F-96E3-31E755A7A30E" class="sect4"><span class="enumeration_section">3.6.2 </span>Retrieving the Content of an XML Document Using Pseudocolumn OBJECT_VALUE
                  </h4>
                  <div>
                     <p>Pseudocolumn <code class="codeph">OBJECT_VALUE</code> can be used as an alias for the value of an object table. 
                     </p>
                     <div class="section">
                        <p>For an <code class="codeph">XMLType</code> table that consists of a single column of <code class="codeph">XMLType</code>, the entire XML document is retrieved. (<code class="codeph">OBJECT_VALUE</code> replaces the <code class="codeph">value(x)</code> and <code class="codeph">SYS_NC_ROWINFO$</code> aliases used in releases prior to Oracle Database 10g Release 1.) 
                        </p>
                        <p>In <a href="how-to-use-XML-DB.html#GUID-42EDC657-C53B-441F-96E3-31E755A7A30E__BJFCECGJ">Example 3-18</a>, the SQL*Plus settings <code class="codeph">PAGESIZE</code> and <code class="codeph">LONG</code> are used to ensure that the entire document is printed correctly, without line breaks. (The output has been formatted for readability.)
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E__BJFCECGJ">
                        <p class="titleinexample">Example 3-18 Retrieving an Entire XML Document Using OBJECT_VALUE</p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM purchaseorder;
 
OBJECT_VALUE
-----------------------------------------------------------------------
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="http://localhost:8080/source/schemas
/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
  &lt;Actions&gt;
    &lt;Action&gt;
      &lt;User&gt;SVOLLMAN&lt;/User&gt;
    &lt;/Action&gt;
  &lt;/Actions&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
  &lt;User&gt;SBELL&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions&gt;
    &lt;name&gt;Sarah J. Bell&lt;/name&gt;
    &lt;address&gt;400 Oracle Parkway
Redwood Shores
CA
94065
USA&lt;/address&gt;
    &lt;telephone&gt;650 506 7400&lt;/telephone&gt;
  &lt;/ShippingInstructions&gt;
  &lt;SpecialInstructions&gt;Air Mail&lt;/SpecialInstructions&gt;
  &lt;LineItems&gt;
    &lt;LineItem ItemNumber="1"&gt;
      &lt;Description&gt;A Night to Remember&lt;/Description&gt;
      &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="2"&gt;
      &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
      &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="3"&gt;
      &lt;Description&gt;Sisters&lt;/Description&gt;
      &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
    &lt;/LineItem&gt;
  &lt;/LineItems&gt;
&lt;/PurchaseOrder&gt;
 
1 row selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4122"></a><a id="ADXDB4121"></a><div class="props_rev_3"><a id="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C" name="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C"></a><h4 id="ADXDB-GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C" class="sect4"><span class="enumeration_section">3.6.3 </span>Accessing Fragments or Nodes of an XML Document Using XMLQUERY
                  </h4>
                  <div>
                     <p>You can use SQL/XML function <code class="codeph">XMLQuery</code> to extract the nodes that match an XQuery expression. The result is returned as an instance of <code class="codeph">XMLType</code>. 
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">Example 3-19</a> illustrates this with several queries.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">
                        <p class="titleinexample">Example 3-19 Accessing XML Fragments Using XMLQUERY</p>
                        <p>The following query returns an <code class="codeph">XMLType</code> instance containing the <code class="codeph">Reference</code> element that matches the XPath expression. 
                        </p><pre class="pre codeblock"><code>SELECT XMLQuery('/PurchaseOrder/Reference' PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/REFERENCE'PASSINGOBJECT_
-------------------------------------------------
&lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
 
1 row selected.
</code></pre><p>The following query returns an <code class="codeph">XMLType</code> instance containing the first <code class="codeph">LineItem</code> element in the <code class="codeph">LineItems</code> collection:
                        </p><pre class="pre codeblock"><code>SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/LINEITEMS/LINEITEM[1]'PASSINGOBJECT_
-------------------------------------------------------------
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;A Night to Remember&lt;/Description&gt;
  &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;
 
1 row selected.
</code></pre><p>The following query returns an <code class="codeph">XMLType</code> instance that contains the three <code class="codeph">Description</code> elements that match the XPath expression. These elements are returned as nodes in a single <code class="codeph">XMLType</code> instance. The <code class="codeph">XMLType</code> instance does not have a single root node; it is an XML <span class="italic">fragment</span>.
                        </p><pre class="pre codeblock"><code>SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/LINEITEMS/LINEITEM/DESCRIPTION'PASSINGOBJECT_
----------------------------------------------------------------------
&lt;Description&gt;A Night to Remember&lt;/Description&gt;
&lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
&lt;Description&gt;Sisters&lt;/Description&gt;
 
1 row selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532" title="You can use SQL/XML function XMLTable to perform SQL operations on a set of nodes that match an XQuery expression.">Performing SQL Operations on XMLType Fragments Using XMLTABLE</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4124"></a><a id="ADXDB4123"></a><div class="props_rev_3"><a id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3" name="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3"></a><h4 id="ADXDB-GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3" class="sect4"><span class="enumeration_section">3.6.4 </span>Accessing Text Nodes and Attribute Values Using XMLCAST and XMLQUERY
                  </h4>
                  <div>
                     <p>You can access text node and attribute values using SQL/XML standard functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code>. 
                     </p>
                     <div class="section">
                        <p>To do this, the XQuery expression passed to <code class="codeph">XMLQuery</code> must uniquely identify a <span class="italic">single</span> text node or attribute value within the document &#x2013; that is, a <span class="italic">leaf</span> node. <a href="how-to-use-XML-DB.html#GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__BJFCGHGB">Example 3-20</a> illustrates this using several queries.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__GUID-B49CF969-0A4E-4FF3-8DA9-7E3E36261A03">
                           <p class="notep1">See Also:</p>
                           <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information on SQL/XML functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLCast</code></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__BJFCGHGB">
                        <p class="titleinexample">Example 3-20 Accessing a Text Node Value Using XMLCAST and XMLQuery</p>
                        <p>The following query returns the value of the text node associated with the <code class="codeph">Reference</code> element that matches the target XPath expression. The value is returned as a <code class="codeph">VARCHAR2</code> value.
                        </p><pre class="pre codeblock"><code>SELECT  XMLCast(XMLQuery('$p/PurchaseOrder/Reference/text()'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                AS VARCHAR2(30))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
SBELL-2002100912333601PDT
 
1 row selected.
</code></pre><p>The following query returns the value of the text node associated with a <code class="codeph">Description</code> element contained in a <code class="codeph">LineItem</code> element. The particular <code class="codeph">LineItem</code> element is specified by its <code class="codeph">Id</code> attribute value. The predicate that identifies the <code class="codeph">LineItem</code> element is <code class="codeph">[Part/@Id="715515011020"]</code>. The at-sign character (<code class="codeph">@</code>) specifies that <code class="codeph">Id</code> is an attribute rather than an element. The value is returned as a <code class="codeph">VARCHAR2</code> value.
                        </p><pre class="pre codeblock"><code>SELECT XMLCast(
         XMLQuery('$p/PurchaseOrder/LineItems/LineItem[Part/@Id="715515011020"]/Description/text()'
                  PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
Sisters
 
1 row selected.
</code></pre><p>The following query returns the value of the text node associated with the <code class="codeph">Description</code> element contained in the first <code class="codeph">LineItem</code> element. The first <code class="codeph">LineItem</code> element is indicated by the position predicate<code class="codeph">[1]</code>.
                        </p><pre class="pre codeblock"><code>SELECT XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]/Description'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4000))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[1]/DESCRIPTION'PASSINGOBJECT_VALUEAS"P"
---------------------------------------------------------------------------------------------
A Night to Remember
 
1 row selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4126"></a><a id="ADXDB6413"></a><a id="ADXDB4125"></a><div class="props_rev_3"><a id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F" name="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F"></a><h4 id="ADXDB-GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F" class="sect4"><span class="enumeration_section">3.6.5 </span>Searching an XML Document Using XMLEXISTS, XMLCAST, and XMLQUERY
                  </h4>
                  <div>
                     <p>You can use SQL/XML standard functions <code class="codeph">XMLExists</code>, <code class="codeph">XMLCast</code>, and <code class="codeph">XMLQuery</code> in a SQL <code class="codeph">WHERE</code> clause to limit query results.
                     </p>
                     <div class="section">
                        <p>SQL/XML standard function <code class="codeph">XMLExists</code> evaluates whether or not a given document contains a node that matches a W3C XPath expression. It returns a Boolean value of <code class="codeph">true</code> if the document contains the node specified by the XPath expression supplied to the function and a value of <code class="codeph">false</code> if it does not. Since XPath expressions can contain predicates, <code class="codeph">XMLExists</code> can determine whether or not a given node exists in the document, and whether or not a node with the specified value exists in the document.
                        </p>
                        <p>Similarly, functions <code class="codeph">XMLCast</code> and <code class="codeph">XMLQuery</code> let you limit query results to documents that satisfy some property. <a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__BJFJHBAE">Example 3-21</a> illustrates the use of <code class="codeph">XMLExists</code>, <code class="codeph">XMLCast</code>, and <code class="codeph">XMLQuery</code> to search for documents.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__CEGIICDB">Example 3-22</a> performs a join based on the values of a node in an XML document and data in another, relational table. 
                        </p>
                        <div class="infoboxnotealso" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__GUID-B7C2D0CC-D99A-49E4-8981-86FBDBC54410">
                           <p class="notep1">See Also:</p>
                           <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for information about SQL/XML functions <code class="codeph">XMLQuery</code>, <code class="codeph">XMLExists</code>, and <code class="codeph">XMLCast</code></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__BJFJHBAE">
                        <p class="titleinexample">Example 3-21 Searching XML Content Using XMLExists, XMLCast, and XMLQuery</p>
                        <p>The following query uses <code class="codeph">XMLExists</code> to check if the XML document contains an element named <code class="codeph">Reference</code> that is a child of the root element <code class="codeph">PurchaseOrder</code>:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
       132

1 row selected.
</pre><p>The following query checks if the value of the text node associated with the <code class="codeph">Reference</code> element is <code class="codeph">SBELL-2002100912333601PDT</code>:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder<span class="bold">[Reference="SBELL-2002100912333601PDT"]</span>'
                  PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
         1
1 row selected.
</pre><p>This query checks whether the XML document contains a root element <code class="codeph">PurchaseOrder</code> that contains a <code class="codeph">LineItems</code> element that contains a <code class="codeph">LineItem</code> element that contains a <code class="codeph">Part</code> element with an <code class="codeph">Id</code> attribute.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/LineItem/Part/<span class="bold">@Id</span>'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
       132
 
1 row selected.
</pre><p>The following query checks whether the XML document contains a root element <code class="codeph">PurchaseOrder</code> that contains a <code class="codeph">LineItems</code> element that contains a <code class="codeph">LineItem</code> element that contains a <code class="codeph">Part</code> element with <code class="codeph">Id</code> attribute value <code class="codeph">715515009058</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/<span class="bold">LineItem/Part[@Id="715515009058"]</span>'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
        21
</pre><p>The following query checks whether the XML document contains a root element <code class="codeph">PurchaseOrder</code> that contains a <code class="codeph">LineItems</code> element whose <span class="italic">third</span> <code class="codeph">LineItem</code> element contains a <code class="codeph">Part</code> element with <code class="codeph">Id</code> attribute value <code class="codeph">715515009058</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count(*) FROM purchaseorder
  WHERE XMLExists(
          '$p/PurchaseOrder/LineItems/LineItem<span class="bold">[3]</span>/Part[@Id="715515009058"]'
          PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
         1
1 row selected.
</pre><p>The following query limits the results of the <code class="codeph">SELECT</code> statement to rows where the text node associated with element <code class="codeph">User</code> starts with the letter <code class="codeph">S</code>. XQuery does not include support for <code class="codeph">LIKE</code>-based queries.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/<span class="bold">User</span>' PASSING OBJECT_VALUE AS "p"
                         RETURNING CONTENT)
                AS VARCHAR2(30))
        <span class="bold">LIKE 'S%'</span>;
 
XMLCAST(XMLQUERY('$P/PURCHASEORDER
----------------------------------
SBELL-20021009123336231PDT
SBELL-20021009123336331PDT
SKING-20021009123336321PDT
...
36 rows selected.
</pre><p>The following query uses <code class="codeph">XMLExists</code> to limit the results of a <code class="codeph">SELECT</code> statement to rows where the text node of element <code class="codeph">User</code> contains the value <code class="codeph">SBELL</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30)) "Reference"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[User="<span class="bold">SBELL</span>"]' PASSING OBJECT_VALUE AS "p");

Reference
------------------------------
SBELL-20021009123336231PDT
SBELL-20021009123336331PDT
SBELL-20021009123337353PDT
SBELL-20021009123338304PDT
SBELL-20021009123338505PDT
SBELL-20021009123335771PDT
SBELL-20021009123335280PDT
SBELL-2002100912333763PDT
SBELL-2002100912333601PDT
SBELL-20021009123336362PDT
SBELL-20021009123336532PDT
SBELL-20021009123338204PDT
SBELL-20021009123337673PDT
 
13 rows selected.
</pre><p>The following query uses SQL/XML functions <code class="codeph">XMLQuery</code> and <code class="codeph">XMLExists</code> to find the <code class="codeph">Reference</code> element for any <code class="codeph">PurchaseOrder</code> element whose first <code class="codeph">LineItem</code> element contains an order for the item with <code class="codeph">Id</code> <code class="codeph">715515009058</code>. Function <code class="codeph">XMLExists</code> is used in the <code class="codeph">WHERE</code> clause to determine which rows are selected, and <code class="codeph">XMLQuery</code> is used in the <code class="codeph">SELECT</code> list to control which part of the selected documents appears in the result.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30)) "Reference"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/LineItem[1]/Part[@Id="715515009058"]'
                  PASSING OBJECT_VALUE AS "p");

Reference
-------------------------
SBELL-2002100912333601PDT
 
1 row selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__CEGIICDB">
                        <p class="titleinexample">Example 3-22 Joining Data from an XMLType Table and a Relational Table</p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder p, hr.employees e
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/<span class="bold">User</span>' PASSING OBJECT_VALUE AS "p"
                         RETURNING CONTENT)
                AS VARCHAR2(30)) = <span class="bold">e.email</span>
    AND e.employee_id = 100;
 
XMLCAST(XMLQUERY('$P/PURCHASEOREDER
-----------------------------------
SKING-20021009123336321PDT
SKING-20021009123337153PDT
SKING-20021009123335560PDT
SKING-20021009123336952PDT
SKING-20021009123336622PDT
SKING-20021009123336822PDT
SKING-20021009123336131PDT
SKING-20021009123336392PDT
SKING-20021009123337974PDT
SKING-20021009123338294PDT
SKING-20021009123337703PDT
SKING-20021009123337383PDT
SKING-20021009123337503PDT
 
13 rows selected.
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4131"></a><a id="ADXDB4132"></a><a id="ADXDB4133"></a><a id="ADXDB4130"></a><div class="props_rev_3"><a id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532" name="GUID-1F02303F-041C-42BF-9AE5-CE978496A532"></a><h4 id="ADXDB-GUID-1F02303F-041C-42BF-9AE5-CE978496A532" class="sect4"><span class="enumeration_section">3.6.6 </span>Performing SQL Operations on XMLType Fragments Using XMLTABLE
                  </h4>
                  <div>
                     <p>You can use SQL/XML function <code class="codeph">XMLTable</code> to perform SQL operations on a set of nodes that match an XQuery expression.
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">Example 3-19</a> demonstrates how to extract an <code class="codeph">XMLType</code> instance that contains the node or nodes that match an XPath expression. When the document contains <span class="italic">multiple</span> nodes that match the supplied XPath expression, such a query returns an XML <span class="italic">fragment</span> that contains all of the matching nodes. Unlike an XML document, an XML <strong class="term">fragment</strong> has no single element that is the <span class="italic">root</span> element.
                        </p>
                        <p>This kind of result is common in these cases:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>When you retrieve the set of elements contained in a <span class="italic">collection</span>, in which case all nodes in the fragment are of the same type &#x2013; see <a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">Example 3-23</a></p>
                           </li>
                           <li>
                              <p>When the target XPath expression ends in a <span class="italic">wildcard</span>, in which case the nodes in the fragment can be of different types &#x2013; see <a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">Example 3-25</a></p>
                           </li>
                        </ul>
                        <p>You can use SQL/XML function <code class="codeph">XMLTable</code> to break up an XML fragment contained in an <code class="codeph">XMLType</code> instance, inserting the collection-element data into a new, virtual table, which you can then query using SQL — in a join expression, for example. In particular, converting an XML fragment into a virtual table makes it easier to process the result of evaluating an <code class="codeph">XMLQuery</code> expression that returns multiple nodes.
                        </p>
                        <div class="infoboxnotealso" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__GUID-AB568350-31DF-484C-BA1B-23BAC08E1BBE">
                           <p class="notep1">See Also:</p>
                           <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a> for more information about SQL/XML function <code class="codeph">XMLTable</code></p>
                        </div>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">Example 3-23</a> shows how to access the text nodes for each <code class="codeph">Description</code> element in the <code class="codeph">PurchaseOrder</code> document. It breaks up the single XML Fragment output from <a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">Example 3-19</a> into multiple text nodes.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__BJFIDFFJ">Example 3-24</a> counts the number of elements in a collection. It also shows how SQL keywords such as <code class="codeph">ORDER BY</code> and <code class="codeph">GROUP BY</code> can be applied to the virtual table data created by SQL/XML function <code class="codeph">XMLTable</code>.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">Example 3-25</a> shows how to use SQL/XML function <code class="codeph">XMLTable</code> to count the number of <span class="italic">child</span> elements of a given element. The XPath expression passed to <code class="codeph">XMLTable</code> contains a wildcard (<code class="codeph">*</code>) that matches all elements that are direct descendants of a <code class="codeph">PurchaseOrder</code> element. Each row of the virtual table created by <code class="codeph">XMLTable</code> contains a node that matches the XPath expression. Counting the number of rows in the virtual table provides the number of element children of element <code class="codeph">PurchaseOrder</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">
                        <p class="titleinexample">Example 3-23 Accessing Description Nodes Using XMLTABLE</p><pre class="oac_no_warn" dir="ltr">SELECT des.COLUMN_VALUE
  FROM purchaseorder p,
       XMLTable('/PurchaseOrder/LineItems/LineItem/Description'
                PASSING p.OBJECT_VALUE) des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
COLUMN_VALUE
------------
&lt;Description&gt;A Night to Remember&lt;/Description&gt;
&lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
&lt;Description&gt;Sisters&lt;/Description&gt;

<span class="bold">3 rows selected.</span>
</pre><p>To use SQL to process the contents of the text nodes, the example converts the collection of <code class="codeph">Description</code> nodes into a <span class="italic">virtual table</span>, using SQL/XML function <code class="codeph">XMLTable</code>. The virtual table has three rows, each of which contains a single <code class="codeph">XMLType</code> instance with a single <code class="codeph">Description</code> element.
                        </p>
                        <p>The XPath expression targets the <code class="codeph">Description</code> elements. The <code class="codeph">PASSING</code> clause says to use the contents (<code class="codeph">OBJECT_VALUE</code>) of <code class="codeph">XMLType</code> table <code class="codeph">purchaseorder</code> as the context for evaluating the XPath expression.
                        </p>
                        <p>The <code class="codeph">XMLTable</code> expression thus <span class="italic">depends</span> on the <code class="codeph">purchaseorder</code> table. This is a <span class="italic">left lateral join</span>. This correlated join ensures a one-to-many (1:N) relationship between the <code class="codeph">purchaseorder</code> row accessed and the rows generated from it by <code class="codeph">XMLTable</code>. Because of this correlated join, the <code class="codeph">purchaseorder</code> table <span class="italic">must appear before</span> the <code class="codeph">XMLTable</code> expression in the <code class="codeph">FROM</code> list. This is a general requirement in any situation where the <code class="codeph">PASSING</code> clause refers to a column of the table.
                        </p>
                        <p>Each <code class="codeph">XMLType</code> instance in the virtual table contains a single <code class="codeph">Description</code> element. You can use the <code class="codeph">COLUMNS</code> clause of <code class="codeph">XMLTable</code> to break up the data targeted by the XPath expression <code class="codeph">'Description'</code> into a column named <code class="codeph">description</code> of SQL data type <code class="codeph">VARCHAR2(256)</code>. The <code class="codeph">'Description'</code> expression that defines this column is <span class="italic">relative</span> to the <span class="italic">context</span> XPath expression, <code class="codeph">'/PurchaseOrder/LineItems/LineItem'</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT des.<span class="bold">description</span>
  FROM purchaseorder p,
       XMLTable('/PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                <span class="bold">COLUMNS description VARCHAR2(256) PATH 'Description'</span>) des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

DESCRIPTION
---------------------------------
A Night to Remember
The Unbearable Lightness Of Being
Sisters
 
3 rows selected.
</pre><p>The <code class="codeph">COLUMNS</code> clause lets you specify precise SQL data types, which can make static type-checking more helpful. This example uses only a single column (<code class="codeph">description</code>). To expose data that is contained at multiple levels in an <code class="codeph">XMLType</code> table as individual rows in a relational view, apply <code class="codeph">XMLTable</code> to each document level to be broken up and stored in relational columns. See <a href="relational-views-over-XML-data.html#GUID-E550E7D4-0D19-47CA-B86F-76825EE54CE1__CHDEEIFD">Example 9-2</a> for an example.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__BJFIDFFJ">
                        <p class="titleinexample">Example 3-24 Counting the Number of Elements in a Collection Using XMLTABLE</p><pre class="oac_no_warn" dir="ltr">SELECT reference, count(*)
  FROM purchaseorder,
       XMLTable('/PurchaseOrder' PASSING OBJECT_VALUE
                COLUMNS <span class="bold">reference</span> VARCHAR2(32) PATH 'Reference',
                        <span class="bold">lineitem</span>  XMLType      PATH 'LineItems/LineItem'),
       XMLTable('LineItem' PASSING lineitem)
  WHERE XMLExists('$p/PurchaseOrder[User="SBELL"]'
                  PASSING OBJECT_VALUE AS "p")
  <span class="bold">GROUP BY</span> reference
  <span class="bold">ORDER BY</span> reference;

REFERENCE                    COUNT(*)
--------------------------   --------
SBELL-20021009123335280PDT         20
SBELL-20021009123335771PDT         21
SBELL-2002100912333601PDT           3
SBELL-20021009123336231PDT         25
SBELL-20021009123336331PDT         10
SBELL-20021009123336362PDT         15
SBELL-20021009123336532PDT         14
SBELL-20021009123337353PDT         10
SBELL-2002100912333763PDT          21
SBELL-20021009123337673PDT         10
SBELL-20021009123338204PDT         14
SBELL-20021009123338304PDT         24
SBELL-20021009123338505PDT         20

13 rows selected.
</pre><p>The query in this example locates the set of XML documents that match the XPath expression to SQL/XML function <code class="codeph">XMLExists</code>. It generates a virtual table with two columns:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">reference</code>, containing the <code class="codeph">Reference</code> node for each document selected
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">lineitem</code>, containing the set of <code class="codeph">LineItem</code> nodes for each document selected
                              </p>
                           </li>
                        </ul>
                        <p>It counts the number of <code class="codeph">LineItem</code> nodes for each document. A correlated join ensures that the <code class="codeph">GROUP BY</code> correctly determines which <code class="codeph">LineItem</code> elements belong to which <code class="codeph">PurchaseOrder</code> element.
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">
                        <p class="titleinexample">Example 3-25 Counting the Number of Child Elements in an Element Using XMLTABLE</p><pre class="oac_no_warn" dir="ltr">SELECT count(*)
  FROM purchaseorder p, XMLTable('/PurchaseOrder/<span class="bold">*</span>' PASSING p.OBJECT_VALUE)
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
         9

1 row selected.</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="There are many ways to query XML content in Oracle XML&nbsp;DB and retrieve it.">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4143"></a><a id="ADXDB4144"></a><a id="ADXDB4147"></a><a id="ADXDB4142"></a><div class="props_rev_3"><a id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8" name="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8"></a><h3 id="ADXDB-GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8" class="sect3"><span class="enumeration_section">3.7 </span>Updating XML Content Stored in Oracle
    XML&nbsp;DB
               </h3>
               <div>
                  <p>You can update XML content, replacing either the entire contents of a
    document or only particular parts of a document. </p>
                  <div class="section">
                     <p>The ability to perform partial updates on XML documents is very powerful,
        particularly when you make small changes to large documents, as it can significantly reduce
        the amount of network traffic and disk input-output required to perform the update.</p>
                     <p>You can make multiple changes to a document in a single operation. Each change
        uses an XQuery expression to identify a node to be updated, and specifies the new value for
        that node. </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__CHDBGCBG">Example 3-26</a> updates the text node associated with element
          <code class="codeph">User</code>.
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFGFDGD">Example 3-27</a> replaces an entire element within an XML document. The
        XQuery expression references the element, and the replacement value is passed as an
          <code class="codeph">XMLType</code> object.
        
                     </p>
                     <p>You can make multiple changes to a document in one statement. <a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFJGJAB">Example 3-28</a> changes the values of text nodes belonging to elements
          <code class="codeph">CostCenter</code> and <code class="codeph">SpecialInstructions</code> in a single SQL
          <code class="codeph">UPDATE</code>
        statement.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__CHDBGCBG">
                     <p class="titleinexample">Example 3-26 Updating a Text
        Node</p><pre class="pre codeblock"><code>SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User' PASSING OBJECT_VALUE AS "p"
                                                RETURNING CONTENT)
               AS VARCHAR2(60))
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHAS
----------------------------
SBELL
 
1 row selected.

UPDATE purchaseorder
SET OBJECT_VALUE =
    XMLQuery('copy $i := $p1 modify
                (for $j in $i/PurchaseOrder/User
                 return replace value of node $j with $p2)
              return $i'
             PASSING OBJECT_VALUE AS "p1", '<span class="bold">SKING</span>' AS "p2" RETURNING CONTENT)
    WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                    PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User' PASSING OBJECT_VALUE AS "p"
                                                RETURNING CONTENT)
               AS VARCHAR2(60))
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHAS
----------------------------
<span class="bold">SKING</span>

1 row selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFGFDGD">
                     <p class="titleinexample">Example 3-27 Replacing an Entire
        Element Using XQuery
        Update</p><pre class="pre codeblock"><code>SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLQUERY('$P/PURCHAS
--------------------
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;A Night to Remember&lt;/Description&gt;
  &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;
 
1 row selected.

UPDATE purchaseorder
  SET OBJECT_VALUE =
        XMLQuery('copy $i := $p1 modify
                    (for $j in $i/PurchaseOrder/LineItems/LineItem[1]
                     return replace node $j with $p2)
                  return $i'
                 PASSING OBJECT_VALUE AS "p1",
                         <span class="bold">XMLType('&lt;LineItem ItemNumber="1"&gt;</span>
                                    <span class="bold">&lt;Description&gt;The Lady Vanishes&lt;/Description&gt;</span>
                                    <span class="bold">&lt;Part Id="37429122129" UnitPrice="39.95"</span>
                                          <span class="bold">Quantity="1"/&gt;</span>
                                  <span class="bold">&lt;/LineItem&gt;')</span> AS "p2"
                 RETURNING CONTENT)
        WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                        PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHAS
--------------------
<span class="bold">&lt;LineItem ItemNumber="1"&gt;</span>
  <span class="bold">&lt;Description&gt;The Lady Vanishes&lt;/Description&gt;</span>
  <span class="bold">&lt;Part Id="37429122129" UnitPrice="39.95" Quantity="1"/&gt;</span>
<span class="bold">&lt;/LineItem&gt;</span>
 
1 row selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFJGJAB">
                     <p class="titleinexample">Example 3-28 Changing Text Node
        Values Using XQuery
      Update</p><pre class="pre codeblock"><code>SELECT XMLCast(XMLQuery('$p/PurchaseOrder/CostCenter'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4)) "Cost Center",
       XMLCast(XMLQuery('$p/PurchaseOrder/SpecialInstructions'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(2048)) "Instructions"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

Cost Center  Instructions
------------ ------------
S30          Air Mail
 
1 row selected.

UPDATE purchaseorder
  SET OBJECT_VALUE =
        XMLQuery('copy $i := $p1 modify
                    ((for $j in $i/PurchaseOrder/<span class="bold">CostCenter</span>
                      return <span class="bold">replace value of node</span> $j <span class="bold">with</span> $p2),
                     (for $j in $i/PurchaseOrder/<span class="bold">SpecialInstructions</span>
                      return <span class="bold">replace value of node</span> $j <span class="bold">with</span> $p3))
                 return $i'
                 PASSING OBJECT_VALUE AS "p1",
                         <span class="bold">'B40'</span> AS "p2",
                         <span class="bold">'Priority Overnight Service'</span> AS "p3"
                 RETURNING CONTENT)
        WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                        PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/CostCenter'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4)) "Cost Center",
       XMLCast(XMLQuery('$p/PurchaseOrder/SpecialInstructions'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(2048)) "Instructions"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
Cost Center  Instructions
------------ --------------------------
<span class="bold">B40</span>          <span class="bold">Priority Overnight Service</span>
 
1 row selected.</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4163"></a><div class="props_rev_3"><a id="GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" name="GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B"></a><h3 id="ADXDB-GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" class="sect3"><span class="enumeration_section">3.8 </span>Generating XML Data from Relational Data
               </h3>
               <div>
                  <p>You can use Oracle XML&nbsp;DB to generate XML data from relational data.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7">Generating XML Data from Relational Data Using SQL/XML Functions</a><br>You can use standard SQL/XML functions to generate one or more XML documents. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3">Generating XML Data from Relational Data Using DBURITYPE</a><br>You can generate XML data from relational data using SQL function <code class="codeph">DBURIType</code>. 
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="The XQuery language is one of the main ways that you interact with XML data in Oracle XML&nbsp;DB. Support for the language includes SQL*Plus commandXQUERY and SQL/XML functions XMLQuery, XMLTable, XMLExists, and XMLCast.">XQuery and Oracle XML&nbsp;DB</a></li>
                        <li><a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML&nbsp;DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content.">Generation of XML Data from Relational Data</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4164"></a><a id="ADXDB4166"></a><a id="ADXDB4167"></a><a id="ADXDB5803"></a><div class="props_rev_3"><a id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7" name="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7"></a><h4 id="ADXDB-GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7" class="sect4"><span class="enumeration_section">3.8.1 </span>Generating XML Data from Relational Data Using SQL/XML Functions
                  </h4>
                  <div>
                     <p>You can use standard SQL/XML functions to generate one or more XML documents. </p>
                     <div class="section">
                        <p>SQL/XML function <code class="codeph">XMLQuery</code> is the most general way to do this. Other SQL/XML functions that you can use for this are the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">XMLElement</code> creates a element 
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLAttributes</code> adds attributes to an element
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLForest</code> creates forest of elements
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLAgg</code> creates a single element from a collection of elements
                              </p>
                           </li>
                        </ul>
                        <p>The query in <a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BJFJCFHF">Example 3-29</a> uses these functions to generate an XML document that contains information from the tables <code class="codeph">departments</code>, <code class="codeph">locations</code>, <code class="codeph">countries</code>, <code class="codeph">employees</code>, and <code class="codeph">jobs</code>.
                        </p>
                        <p>This query generates element <code class="codeph">Department</code> for each row in the <code class="codeph">departments</code> table. 
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Each <code class="codeph">Department</code> element contains attribute <code class="codeph">DepartmentID</code>. The value of <code class="codeph">DepartmentID</code> comes from the <code class="codeph">department_id</code> column. The <code class="codeph">Department</code> element contains sub-elements <code class="codeph">Name</code>, <code class="codeph">Location</code>, and <code class="codeph">EmployeeList</code>.
                              </p>
                           </li>
                           <li>
                              <p>The text node associated with the <code class="codeph">Name</code> element comes from the <code class="codeph">name</code> column in the <code class="codeph">departments</code> table.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">Location</code> element has child elements <code class="codeph">Address</code>, <code class="codeph">City</code>, <code class="codeph">State</code>, <code class="codeph">Zip</code>, and <code class="codeph">Country</code>. These elements are constructed by creating a forest of named elements from columns in the <code class="codeph">locations</code> and <code class="codeph">countries</code> tables. The values in the columns become the text node for the named element.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">EmployeeList</code> element contains an aggregation of <code class="codeph">Employee</code> Elements. The content of the <code class="codeph">EmployeeList</code> element is created by a subquery that returns the set of rows in the <code class="codeph">employees</code> table that correspond to the current department. Each <code class="codeph">Employee</code> element contains information about the employee. The contents of the elements and attributes for each <code class="codeph">Employee</code> element is taken from tables <code class="codeph">employees</code> and <code class="codeph">jobs</code>.
                              </p>
                           </li>
                        </ul>
                        <p>The output generated by SQL/XML functions is generally <span class="italic">not</span> pretty-printed. The only exception is function <code class="codeph">XMLSerialize</code> — use <code class="codeph">XMLSerialize</code> to pretty-print. This lets the other SQL/XML functions (1) avoid creating a full DOM when generating the required output, and (2) reduce the size of the generated document. This lack of pretty-printing by most SQL/XML functions does not matter to most applications. However, it makes verifying the generated output manually more difficult. 
                        </p>
                        <p>You can also create and query an <code class="codeph">XMLType</code> view that is built using the SQL/XML generation functions. <a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABGGAIA">Example 3-30</a> and <a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">Example 3-31</a> illustrate this. Such an <code class="codeph">XMLType</code> view has the effect of persisting relational data as XML content. Rows in <code class="codeph">XMLType</code> views can also be persisted as documents in Oracle XML&nbsp;DB Repository. 
                        </p>
                        <p>In <a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">Example 3-31</a>, the XPath expression passed to SQL/XML function <code class="codeph">XMLExists</code> restricts the query result set to the node that contains the <code class="codeph">Executive</code> department information. The result is shown pretty-printed here for clarity.
                        </p>
                        <div class="infoboxnote" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__GUID-C34EF579-9CFB-4ECC-AC17-C88A41DCA1AD">
                           <p class="notep1">Note:</p>
                           <p>XPath rewrite on XML expressions that operate on <code class="codeph">XMLType</code> views is only supported when nodes referenced in the XPath expression are <span class="italic">not</span> descendants of an element created using SQL function <code class="codeph">XMLAgg</code>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BJFJCFHF">
                        <p class="titleinexample">Example 3-29 Generating XML Data Using SQL/XML Functions</p><pre class="pre codeblock"><code>SELECT XMLElement(
         "Department",
         XMLAttributes(d.Department_id AS "DepartmentId"),
         XMLForest(d.department_name AS "Name"),
         XMLElement(
           "Location",
           XMLForest(street_address AS "Address",
                     city AS "City",
                     state_province AS "State",
                     postal_code AS "Zip",
                     country_name AS "Country")),
           XMLElement(
             "EmployeeList",
             (SELECT XMLAgg(
                       XMLElement(
                         "Employee",
                         XMLAttributes(e.employee_id AS "employeeNumber"),
                         XMLForest(
                           e.first_name AS "FirstName", 
                           e.last_name AS "LastName",
                           e.email AS "EmailAddress",
                           e.phone_number AS "PHONE_NUMBER",
                           e.hire_date AS "StartDate",
                           j.job_title AS "JobTitle",
                           e.salary AS "Salary",
                           m.first_name || ' ' || m.last_name AS "Manager"),
                         XMLElement("Commission", e.commission_pct)))
                FROM hr.employees e, hr.employees m, hr.jobs j
                WHERE e.department_id = d.department_id
                  AND j.job_id = e.job_id
                  AND m.employee_id = e.manager_id)))
  AS XML
  FROM hr.departments d, hr.countries c, hr.locations l
  WHERE department_name = 'Executive'
    AND d.location_id = l.location_id
    AND l.country_id  = c.country_id;
</code></pre><p>The query returns the following XML:</p><pre class="pre codeblock"><code>XML
--------------------------------------------------------------------------------
&lt;Department DepartmentId="90"&gt;&lt;Name&gt;Executive&lt;/Name&gt;&lt;Location&gt;&lt;Address&gt;2004
 Charade Rd&lt;/Address&gt;&lt;City&gt;Seattle&lt;/City&gt;&lt;State&gt;Washingto
n&lt;/State&gt;&lt;Zip&gt;98199&lt;/Zip&gt;&lt;Country&gt;United States of
 America&lt;/Country&gt;&lt;/Location&gt;&lt;EmployeeList&gt;&lt;Employee
 employeeNumber="101"&gt;&lt;FirstNa
me&gt;Neena&lt;/FirstName&gt;&lt;LastName&gt;Kochhar&lt;/LastName&gt;&lt;EmailAddress&gt;NKOCHHAR&lt;/EmailAdd
ess&gt;&lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;&lt;Start
Date&gt;2005-09-21&lt;/StartDate&gt;&lt;JobTitle&gt;Administration Vice
 President&lt;/JobTitle&gt;&lt;Salary&gt;17000&lt;/Salary&gt;&lt;Manager&gt;Steven King&lt;/Manager&gt;&lt;Com
mission&gt;&lt;/Commission&gt;&lt;/Employee&gt;&lt;Employee
 employeeNumber="102"&gt;&lt;FirstName&gt;Lex&lt;/FirstName&gt;&lt;LastName&gt;De
 Haan&lt;/LastName&gt;&lt;EmailAddress&gt;L
DEHAAN&lt;/EmailAddress&gt;&lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE
NUMBER&gt;&lt;StartDate&gt;2001-01-13&lt;/StartDate&gt;&lt;JobTitle&gt;Administration Vice Presiden
t&lt;/JobTitle&gt;&lt;Salary&gt;17000&lt;/Salary&gt;&lt;Manager&gt;Steven
 King&lt;/Manager&gt;&lt;Commission&gt;&lt;/Commission&gt;&lt;/Employee&gt;&lt;/EmployeeList&gt;&lt;/Department&gt;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABGGAIA">
                        <p class="titleinexample">Example 3-30 Creating XMLType Views Over Conventional Relational Tables</p><pre class="pre codeblock"><code>CREATE OR REPLACE VIEW department_xml OF XMLType
  <span class="bold">WITH OBJECT ID (substr(</span>
                    <span class="bold">XMLCast(</span>
                      <span class="bold">XMLQuery('$p/Department/Name'</span>
                               <span class="bold">PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)</span>
                      <span class="bold">AS VARCHAR2(30)),</span>
                    <span class="bold">1,</span>
                    <span class="bold">128))</span>
  AS
  SELECT XMLElement(
           "Department",
           XMLAttributes(d.department_id AS "DepartmentId"),
           XMLForest(d.department_name AS "Name"),
           XMLElement("Location", XMLForest(street_address AS "Address",
                                            city AS "City",
                                            state_province AS "State",
                                            postal_code AS "Zip",
                                            country_name AS "Country")),
           XMLElement(
             "EmployeeList",
             (SELECT XMLAgg(
                       XMLElement(
                          "Employee",
                          XMLAttributes(e.employee_id AS "employeeNumber"),
                          XMLForest(e.first_name AS "FirstName",
                                    e.last_name AS "LastName",
                                    e.email AS "EmailAddress",
                                    e.phone_number AS "PHONE_NUMBER",
                                    e.hire_date AS "StartDate",
                                    j.job_title AS "JobTitle",
                                    e.salary AS "Salary",
                                    m.first_name || ' ' ||
                                    m.last_name AS "Manager"),
                          XMLElement("Commission", e.commission_pct)))
                FROM hr.employees e, hr.employees m, hr.jobs j
                WHERE e.department_id = d.department_id
                  AND j.job_id = e.job_id
                  AND m.employee_id = e.manager_id))).extract('/*')
    AS XML
    FROM hr.departments d, hr.countries c, hr.locations l
    WHERE d.location_id = l.location_id
      AND l.country_id  = c.country_id;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">
                        <p class="titleinexample">Example 3-31 Querying XMLType Views</p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM department_xml
  WHERE XMLExists('$p/Department[Name="Executive"]' PASSING OBJECT_VALUE AS "p");
 
OBJECT_VALUE
------------------------------------------------
&lt;Department DepartmentId="90"&gt;
  &lt;Name&gt;Executive&lt;/Name&gt;
  &lt;Location&gt;
    &lt;Address&gt;2004 Charade Rd&lt;/Address&gt;
    &lt;City&gt;Seattle&lt;/City&gt;
    &lt;State&gt;Washington&lt;/State&gt;
    &lt;Zip&gt;98199&lt;/Zip&gt;
    &lt;Country&gt;United States of America&lt;/Country&gt;
  &lt;/Location&gt;
  &lt;EmployeeList&gt;
    &lt;Employee employeeNumber="101"&gt;
      &lt;FirstName&gt;Neena&lt;/FirstName&gt;
      &lt;LastName&gt;Kochhar&lt;/LastName&gt;
      &lt;EmailAddress&gt;NKOCHHAR&lt;/EmailAddress&gt;
      &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
      &lt;StartDate&gt;2005-09-21&lt;/StartDate&gt;
      &lt;JobTitle&gt;Administration Vice President&lt;/JobTitle&gt;
      &lt;Salary&gt;17000&lt;/Salary&gt;
      &lt;Manager&gt;Steven King&lt;/Manager&gt;
      &lt;Commission/&gt;
    &lt;/Employee&gt;
    &lt;Employee employeeNumber="102"&gt;
      &lt;FirstName&gt;Lex&lt;/FirstName&gt;
      &lt;LastName&gt;De Haan&lt;/LastName&gt;
      &lt;EmailAddress&gt;LDEHAAN&lt;/EmailAddress&gt;
      &lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE_NUMBER&gt;
      &lt;StartDate&gt;2001-01-13&lt;/StartDate&gt;
      &lt;JobTitle&gt;Administration Vice President&lt;/JobTitle&gt;
      &lt;Salary&gt;17000&lt;/Salary&gt;
      &lt;Manager&gt;Steven King&lt;/Manager&gt;
      &lt;Commission/&gt;
    &lt;/Employee&gt;
  &lt;/EmployeeList&gt;
&lt;/Department&gt;
 
1 row selected.
</code></pre><p>As can be seen from the following execution plan output, Oracle XML&nbsp;DB is able to correctly rewrite the XPath-expression argument in the <code class="codeph">XMLExists</code> expression into a <code class="codeph">SELECT</code> statement on the underlying relational tables.
                        </p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM department_xml
  WHERE XMLExists('$p/Department[Name="Executive"]' PASSING OBJECT_VALUE AS "p");

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------
Plan hash value: 2414180351

------------------------------------------------------------------------------------------------------------
| Id  | Operation                              | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                       |                   |     1 |    80 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE                        |                   |     1 |   115 |            |          |
|*  2 |   HASH JOIN                            |                   |    10 |  1150 |     7  (15)| 00:00:01 |
|*  3 |    HASH JOIN                           |                   |    10 |   960 |     5  (20)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES         |    10 |   690 |     2   (0)| 00:00:01 |
|*  5 |      INDEX RANGE SCAN                  | EMP_DEPARTMENT_IX |    10 |       |     1   (0)| 00:00:01 |
|   6 |     TABLE ACCESS FULL                  | JOBS              |    19 |   513 |     2   (0)| 00:00:01 |
|   7 |    TABLE ACCESS FULL                   | EMPLOYEES         |   107 |  2033 |     2   (0)| 00:00:01 |
|   8 |  NESTED LOOPS                          |                   |     1 |    80 |     3   (0)| 00:00:01 |
|   9 |   NESTED LOOPS                         |                   |     1 |    68 |     3   (0)| 00:00:01 |
|* 10 |    TABLE ACCESS FULL                   | DEPARTMENTS       |     1 |    19 |     2   (0)| 00:00:01 |
|  11 |    TABLE ACCESS BY INDEX ROWID         | LOCATIONS         |     1 |    49 |     1   (0)| 00:00:01 |
|* 12 |     INDEX UNIQUE SCAN                  | LOC_ID_PK         |     1 |       |     0   (0)| 00:00:01 |
|* 13 |   INDEX UNIQUE SCAN                    | COUNTRY_C_ID_PK   |     1 |    12 |     0   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("M"."EMPLOYEE_ID"="E"."MANAGER_ID")
   3 - access("J"."JOB_ID"="E"."JOB_ID")
   5 - access("E"."DEPARTMENT_ID"=:B1)
  10 - filter("D"."DEPARTMENT_NAME"='Executive')
  12 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  13 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
 
30 rows selected.</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" title="You can use Oracle XML&nbsp;DB to generate XML data from relational data.">Generating XML Data from Relational Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4169"></a><a id="ADXDB4170"></a><a id="ADXDB5804"></a><a id="ADXDB4168"></a><div class="props_rev_3"><a id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3" name="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3"></a><h4 id="ADXDB-GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3" class="sect4"><span class="enumeration_section">3.8.2 </span>Generating XML Data from Relational Data Using DBURITYPE
                  </h4>
                  <div>
                     <p>You can generate XML data from relational data using SQL function <code class="codeph">DBURIType</code>. 
                     </p>
                     <div class="section">
                        <p>Function <code class="codeph">DBURIType</code> exposes one or more rows in a given table or view as a single XML document. The name of the root element is derived from the name of the table or view. The root element contains a set of <code class="codeph">ROW</code> elements. There is one <code class="codeph">ROW</code> element for each row in the table or view. The children of each <code class="codeph">ROW</code> element are derived from the columns in the table or view. Each child element contains a text node with the value of the column for the given row.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BABCGFBC">Example 3-32</a> shows how to use SQL function <code class="codeph">DBURIType</code> to access the contents of table <code class="codeph">departments</code> in database schema <code class="codeph">HR</code>. It uses method <code class="codeph">getXML()</code> to return the resulting document as an <code class="codeph">XMLType</code> instance.
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFIFCCF">Example 3-33</a> shows how to use an XPath predicate to restrict the rows that are included in an XML document generated using <code class="codeph">DBURIType</code>. The XPath expression in the example restricts the XML document to <code class="codeph">DEPARTMENT_ID</code> columns with value <code class="codeph">10</code>.
                        </p>
                        <p>SQL function <code class="codeph">DBURIType</code> provides a simple way to expose some or all rows in a relational table as one or more XML documents. The URL passed to function <code class="codeph">DBURIType</code> can be extended to return a single column from the view or table, but in that case the URL must also include predicates that identify a single row in the target table or view. 
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFDCFGG">Example 3-34</a> illustrates this. The predicate <code class="codeph">[DEPARTMENT_ID="10"]</code> causes the query to return the value of column <code class="codeph">department_name</code> for the <code class="codeph">departments</code> row where column <code class="codeph">department_id</code> has the value <code class="codeph">10</code>.
                        </p>
                        <p>SQL function <code class="codeph">DBURIType</code> is less flexible than the SQL/XML functions:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It provides no way to control the shape of the generated document.</p>
                           </li>
                           <li>
                              <p>The data can come only from a single table or view.</p>
                           </li>
                           <li>
                              <p>The generated document consists of one or more <code class="codeph">ROW</code> elements. Each <code class="codeph">ROW</code> element contains a child for each column in the target table.
                              </p>
                           </li>
                           <li>
                              <p>The names of the child elements are derived from the column names.</p>
                           </li>
                        </ul>
                        <p>To control the names of the XML elements, to include columns from more than one table, or to control which columns from a table appear in the generated document, create a relational view that exposes the desired set of columns as a single row, and then use function <code class="codeph">DBURIType</code> to generate an XML document from the contents of that view. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BABCGFBC">
                        <p class="titleinexample">Example 3-32 Generating XML Data from a Relational Table Using DBURIType and getXML()</p><pre class="pre codeblock"><code>SELECT DBURIType('/HR/DEPARTMENTS').getXML() FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS').GETXML()
------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;DEPARTMENTS&gt;
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;10&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;200&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;
<span class="bold">...</span>
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;20&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Marketing&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;201&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1800&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;
&lt;/DEPARTMENTS&gt;
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFIFCCF">
                        <p class="titleinexample">Example 3-33 Restricting Rows Using an XPath Predicate</p><pre class="pre codeblock"><code>SELECT DBURIType('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]').getXML()
  FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]').GETXML()
------------------------------------------------------------------
&lt;?xml version="1.0"?&gt;
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;10&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;200&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;

1 row selected.
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFDCFGG">
                        <p class="titleinexample">Example 3-34 Restricting Rows and Columns Using an XPath Predicate</p><pre class="pre codeblock"><code>SELECT DBURIType(
         '/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]/<span class="bold">DEPARTMENT_NAME</span>').getXML()
  FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]/DEPARTMENT_NAME').GETXML()
-----------------------------------------------------------------------------
&lt;?xml version="1.0"?&gt;
 &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
 
1 row selected.
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" title="You can use Oracle XML&nbsp;DB to generate XML data from relational data.">Generating XML Data from Relational Data</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4063"></a><div class="props_rev_3"><a id="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" name="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D"></a><h3 id="ADXDB-GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" class="sect3"><span class="enumeration_section">3.9 </span>Character Sets of XML Documents
               </h3>
               <div>
                  <p>There are a few ways in which Oracle XML&nbsp;DB determines which character sets are used for XML documents</p>
                  <div class="infoboxnote" id="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D__GUID-B9D7A6D2-33CB-459A-88D1-96CE08DEC78C">
                     <p class="notep1">Caution:</p>
                     <p> <span class="italic">AL32UTF8</span> is the Oracle Database character set that is appropriate for <code class="codeph">XMLType</code> data. It is equivalent to the IANA registered standard UTF-8 encoding, which supports all valid XML characters.
                     </p>
                     <p>Do not confuse Oracle Database database character set UTF8 (no hyphen) with database character set AL32UTF8 or with character <span class="italic">encoding</span> UTF-8. Database character set UTF8 has been <span class="italic">superseded</span> by AL32UTF8. Do <span class="italic">not</span> use UTF8 for XML data. Character set UTF8 supports only Unicode version 3.1 and earlier. It does not support all valid XML characters. AL32UTF8 has no such limitation.
                     </p>
                     <p>Using database character set UTF8 for XML data could potentially <span class="italic">stop a system or affect security negatively</span>. If a character that is not supported by the database character set appears in an input-document element name, a replacement character (usually "<code class="codeph">?</code>") is substituted for it. This terminates parsing and raises an exception. It can cause an irrecoverable error.
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-0AC0E511-7648-4B6B-A340-319D04EFD973">XML Encoding Declaration</a><br>You can use an XML encoding declaration to explicitly specify the character encoding to use for a given XML entity.
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1">Character-Set Determination When Loading XML Documents into the Database</a><br>Except for XML data obtained from a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR</code> value, character encoding is determined by an encoding declaration when a document is loaded into the database. 
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-EED59501-929C-495A-B00F-6A9794ABF840">Character-Set Determination When Retrieving XML Documents from the Database</a><br>Except for XML data stored in a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR</code> value, you can specify the encoding to be used when it is retrieved from Oracle XML&nbsp;DB using a SQL client, programmatic APIs, or transfer protocols. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML&nbsp;DB is presented.">Overview of How To Use Oracle XML&nbsp;DB</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4064"></a><div class="props_rev_3"><a id="GUID-0AC0E511-7648-4B6B-A340-319D04EFD973" name="GUID-0AC0E511-7648-4B6B-A340-319D04EFD973"></a><h4 id="ADXDB-GUID-0AC0E511-7648-4B6B-A340-319D04EFD973" class="sect4"><span class="enumeration_section">3.9.1 </span>XML Encoding Declaration
                  </h4>
                  <div>
                     <p>You can use an XML encoding declaration to explicitly specify the character encoding to use for a given XML entity.</p>
                     <p>Each XML document is composed of units called entities. Each entity in an XML document can use a different encoding for its characters. Entities that are stored in an encoding other than UTF-8 or UTF-16 must begin with an XML declaration containing an encoding specification indicating the character encoding in use. For example: </p><pre class="pre codeblock"><code>&lt;?xml version='1.0' encoding='EUC-JP' ?&gt;
</code></pre><p>Entities encoded in UTF-16 must begin with the Byte Order Mark (BOM), as described in Appendix F of the XML 1.0 Reference. For example, on big-endian platforms, the BOM required of a UTF-16 data stream is <code class="codeph">#xFEFF</code>.
                     </p>
                     <p>In the absence of both the encoding declaration and the BOM, the XML entity is assumed to be encoded in UTF-8. Because ASCII is a subset of UTF-8, ASCII entities do not require an encoding declaration.</p>
                     <p>In many cases, external sources of information are available, besides the XML data, to provide the character encoding in use. For example, the encoding of the data can be obtained from the <code class="codeph">charset</code> parameter of the <code class="codeph">Content-Type</code> field in an HTTP(S) request as follows:
                     </p><pre class="pre codeblock"><code>Content-Type: text/xml; charset=ISO-8859-4</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="There are a few ways in which Oracle XML&nbsp;DB determines which character sets are used for XML documents">Character Sets of XML Documents</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4065"></a><div class="props_rev_3"><a id="GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1" name="GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1"></a><h4 id="ADXDB-GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1" class="sect4"><span class="enumeration_section">3.9.2 </span>Character-Set Determination When Loading XML Documents into the Database
                  </h4>
                  <div>
                     <p>Except for XML data obtained from a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR</code> value, character encoding is determined by an encoding declaration when a document is loaded into the database. 
                     </p>
                     <p>For XML data obtained from a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR</code> value, any encoding declaration present is <span class="italic">ignored,</span>, because these two data types are <span class="italic">always encoded in the database character set</span>. 
                     </p>
                     <p>In addition, when loading data into Oracle XML&nbsp;DB, either through programmatic APIs or transfer protocols, you can provide external encoding to override the document encoding declaration. An error is raised if you try to load a schema-based XML document that contains characters that are not legal in the determined encoding.</p>
                     <p>The following examples show different ways to specify external encoding: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Using PL/SQL function <code class="codeph">DBMS_XDB_REPOS.createResource</code> to create a file resource from a <code class="codeph">BFILE</code>, you can specify the file encoding with the <span class="italic"><code class="codeph">CSID</code></span> argument. If a zero <span class="italic"><code class="codeph">CSID</code></span> is specified then the file encoding is auto-detected from the document encoding declaration. 
                           </p><pre class="pre codeblock"><code>CREATE DIRECTORY xmldir AS '/private/xmldir';
CREATE OR REPLACE PROCEDURE loadXML(filename VARCHAR2, file_csid NUMBER) IS
  xbfile  BFILE;
  RET     BOOLEAN;
BEGIN
  xbfile := bfilename('XMLDIR', filename);
  ret := DBMS_XDB_REPOS.createResource('/public/mypurchaseorder.xml', 
                                       xbfile,
                                       file_csid);
END;/
</code></pre></li>
                        <li>
                           <p>Use the FTP protocol to load documents into Oracle XML&nbsp;DB. Use the <code class="codeph">quote set_charset</code> FTP command to indicate the encoding of the files to be loaded. 
                           </p><pre class="pre codeblock"><code>ftp&gt; quote set_charset Shift_JIS  
ftp&gt; put mypurchaseorder.xml
</code></pre></li>
                        <li>
                           <p>Use the HTTP(S) protocol to load documents into Oracle XML&nbsp;DB. Specify the encoding of the data to be transmitted to Oracle XML&nbsp;DB in the request header.</p><pre class="pre codeblock"><code>Content-Type: text/xml; charset= EUC-JP
</code></pre></li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="There are a few ways in which Oracle XML&nbsp;DB determines which character sets are used for XML documents">Character Sets of XML Documents</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4066"></a><div class="props_rev_3"><a id="GUID-EED59501-929C-495A-B00F-6A9794ABF840" name="GUID-EED59501-929C-495A-B00F-6A9794ABF840"></a><h4 id="ADXDB-GUID-EED59501-929C-495A-B00F-6A9794ABF840" class="sect4"><span class="enumeration_section">3.9.3 </span>Character-Set Determination When Retrieving XML Documents from the Database
                  </h4>
                  <div>
                     <p>Except for XML data stored in a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR</code> value, you can specify the encoding to be used when it is retrieved from Oracle XML&nbsp;DB using a SQL client, programmatic APIs, or transfer protocols. 
                     </p>
                     <p>When XML data is stored as a <code class="codeph">CLOB</code> or <code class="codeph">VARCHAR2</code> value, the encoding declaration, if present, is always <span class="italic">ignored</span> for retrieval, just as for storage. The encoding of a retrieved document can thus be different from the encoding explicitly declared in that document.
                     </p>
                     <p>The character set for an XML document retrieved from the database is determined in the following ways: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>SQL client &#x2013; If a SQL client (such as SQL*Plus) is used to retrieve XML data, then the character set is determined by the client-side environment variable <code class="codeph">NLS_LANG</code>. In particular, this setting overrides any explicit character-set declarations in the XML data itself. 
                           </p>
                           <p>For example, if you set the client side <code class="codeph">NLS_LANG</code> variable to <code class="codeph">AMERICAN_AMERICA.AL32UTF8</code> and then retrieve an XML document with encoding <code class="codeph">EUC_JP</code> provided by declaration <code class="codeph">&lt;?xml version="1.0" encoding="EUC-JP"?&gt;</code>, the character set of the retrieved document is <code class="codeph">AL32UTF8</code>, <span class="italic">not</span> <code class="codeph">EUC_JP</code>.
                           </p>
                        </li>
                        <li>
                           <p>PL/SQL and APIs &#x2013; Using PL/SQL or programmatic APIs, you can retrieve XML data into <code class="codeph">VARCHAR</code>, <code class="codeph">CLOB</code>, or <code class="codeph">XMLType</code> data types. As for SQL clients, you can control the encoding of the retrieved data by setting <code class="codeph">NLS_LANG</code>.
                           </p>
                           <p>You can also retrieve XML data into a <code class="codeph">BLOB</code> value using <code class="codeph">XMLType</code> and <code class="codeph">URIType</code> methods. These let you specify the character set of the returned <code class="codeph">BLOB</code> value. Here is an example:
                           </p><pre class="pre codeblock"><code>CREATE OR REPLACE FUNCTION getXML(pathname VARCHAR2, charset VARCHAR2) 
  RETURN BLOB IS
  xblob BLOB;
BEGIN
  SELECT XMLSERIALIZE(DOCUMENT e.RES AS BLOB ENCODING charset) INTO xblob
    FROM RESOURCE_VIEW e WHERE equals_path(e.RES, pathname) = 1;
  RETURN xblob;
END;
/
</code></pre></li>
                        <li>
                           <p>FTP &#x2013; You can use the FTP <code class="codeph">quote set_nls_locale</code> command to set the character set:
                           </p><pre class="pre codeblock"><code>ftp&gt; quote set_nls_locale EUC-JP
ftp&gt; get mypurchaseorder.xml
</code></pre></li>
                        <li>
                           <p>HTTP(S) &#x2013; You can use the <code class="codeph">Accept-Charset</code> parameter in an HTTP(S) request:
                           </p><pre class="pre codeblock"><code>/httptest/mypurchaseorder.xml  1.1 HTTP/Host: localhost:2345
Accept: text/*
Accept-Charset:  iso-8859-1, utf-8
</code></pre></li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="repository-access-using-protocols.html#GUID-79D2A8C3-3AD4-4479-847B-0F3771B322AE" title="Oracle Database supports several FTP quote methods, which provide information directly to Oracle XML&nbsp;DB.">FTP Quote Methods</a></li>
                           <li><a href="repository-access-using-protocols.html#GUID-3855422B-2846-40CB-9E49-298193DC333F" title="You can control the character sets used for data that is transferred using HTTP(S).">Character Sets for HTTP(S)</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-EED59501-929C-495A-B00F-6A9794ABF840__GUID-0F0FC6BB-FDEB-49D9-80ED-17CECF2ABEE7">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=NLSPG-GUID-D5C74C82-8622-46F4-8760-0F8ABA28A816" target="_blank"><span><cite>Oracle Database Globalization Support Guide</cite></span></a> for information about <code class="codeph">NLS_LANG</code></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="There are a few ways in which Oracle XML&nbsp;DB determines which character sets are used for XML documents">Character Sets of XML Documents</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">Footnote Legend</p>Footnote&nbsp;1: 
            <p>The <code class="codeph">XMLType</code> storage model for XML schema-based data is whatever was specified during registration of the referenced XML schema. If no storage model was specified during registration, then object-relational storage is used.
            </p><br></div>
      </article>
   </body>
</html>