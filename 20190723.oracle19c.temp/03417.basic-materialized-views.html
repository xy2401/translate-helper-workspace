<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Basic Materialized Views</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="part-optimizing-dw.html" title="Previous" type="text/html">
      <link rel="next" href="advanced-materialized-views.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="part-optimizing-dw.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="advanced-materialized-views.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">Optimizing Data Warehouses</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Basic Materialized Views</li>
            </ol>
            <a id="GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" name="GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF"></a>
            
            <h2 id="DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" class="sect2"><span class="enumeration_chapter">5 </span>Basic Materialized Views
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes the use of materialized views. It contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839">Overview of Data Warehousing with Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-63E162FE-8957-4C1D-9494-041A8B2B7917" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.">Types of Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52" title="A materialized view can be created with the CREATE MATERIALIZED VIEW statement or using Enterprise Manager.">Creating Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806">Creating Materialized View Logs</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-42B64F99-7391-48B8-B37D-1B486DC29645" title="A materialized view based on approximate queries uses SQL functions that return approximate functions in its defining query.">Creating Materialized Views Based on Approximate Queries</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-4DE39B8B-8452-4581-A841-6AF77019986D">Registering Existing Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83">Choosing Indexes for Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57">Dropping Materialized Views</a></p>
                  </li>
                  <li>
                     <p><a href="basic-materialized-views.html#GUID-651B08EB-4D32-4A93-A260-A965C40AE136">Analyzing Materialized View Capabilities</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG0081"></a><div class="props_rev_3"><a id="GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839" name="GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839"></a><h3 id="DWHSG-GUID-FC9E665B-8AB2-4B64-AB8A-FAA732511839" class="sect3"><span class="enumeration_section">5.1 </span>Overview of Data Warehousing with Materialized Views
               </h3>
               <div>
                  <p><a id="d15276e112" class="indexterm-anchor"></a><a id="d15276e114" class="indexterm-anchor"></a><a id="d15276e118" class="indexterm-anchor"></a>Typically, data flows from one or more online transaction processing (OLTP) database into a data warehouse on a monthly, weekly, or daily basis. The data is normally processed in a<a id="d15276e123" class="indexterm-anchor"></a> <a href="glossary.html#GUID-534190F8-A767-42E3-866C-3166B300D21B"><span class="xrefglossterm">staging file</span></a> before being added to the data warehouse. Data warehouses commonly range in size from hundreds of gigabytes to a few terabytes. Usually, the vast majority of the data is stored in a few very large <a href="glossary.html#GUID-5E1E8221-92AE-47F6-BB30-5F2D7BCD68F5"><span class="xrefglossterm">fact table</span></a>s.
                  </p>
                  <p>One technique employed in data warehouses to improve performance is the creation of summaries. Summaries are special types of aggregate views that improve query execution times by precalculating expensive joins and aggregation operations prior to execution and storing the results in a table in the database. For example, you can create a summary table to contain the sums of sales by region and by product.</p>
                  <p>The summaries or aggregates that are referred to in this book and in literature on data warehousing are created in Oracle Database using a schema object called<a id="d15276e140" class="indexterm-anchor"></a> a <a href="glossary.html#GUID-AC1E7D15-7178-4C7E-89CA-809D13AB2513"><span class="xrefglossterm">materialized view</span></a>. Materialized views can perform a number of roles, such as improving query performance or providing replicated data.
                  </p>
                  <p>The database administrator creates one or more materialized views, which are the equivalent of a summary. The end user queries the tables and views at the detail data level. The <a href="glossary.html#GUID-BD33929F-FA4E-4E15-BAA7-2E62E2CF6B7B"><span class="xrefglossterm">query rewrite</span></a> mechanism in the Oracle server automatically rewrites the SQL query to use the summary tables. This mechanism reduces response time for returning results from the query. Materialized views within the data warehouse are transparent to the end user or to the database application.
                  </p>
                  <p>Although materialized views are usually accessed through the query rewrite mechanism, an end user or database application can construct queries that directly access the materialized views. However, serious consideration should be given to whether users should be allowed to do this because any change to the materialized views affects the queries that reference them.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732">About Materialized Views for Data Warehouses</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-881E9280-3C16-4893-A5AE-7FAE20746664">About Materialized Views for Distributed Computing</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43">About Materialized Views for Mobile Computing</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-E4538195-1C38-429C-B10F-8722C6A8A06F">The Need for Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF">Components of Summary Management</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-543AB802-DA73-408B-9FE5-686E26D0F44B">Data Warehousing Terminology</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27">About Materialized View Schema Design</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05">About Loading Data into Data Warehouses</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46">Overview of Materialized View Management Tasks</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8161"></a><div class="props_rev_3"><a id="GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732" name="GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732"></a><h4 id="DWHSG-GUID-26AB0CB6-F8E5-41B8-B357-9B182597F732" class="sect4"><span class="enumeration_section">5.1.1 </span>About Materialized Views for Data Warehouses
                  </h4>
                  <div>
                     <p>In data warehouses, you can use materialized views to precompute and store aggregated data such as the sum of sales. Materialized views in these environments are often referred to as summaries, because they store summarized data. They can also be used to precompute joins with or without aggregations. A materialized view eliminates the overhead associated with expensive joins and aggregations for a large or important class of queries.</p>
                  </div>
               </div><a id="DWHSG8162"></a><div class="props_rev_3"><a id="GUID-881E9280-3C16-4893-A5AE-7FAE20746664" name="GUID-881E9280-3C16-4893-A5AE-7FAE20746664"></a><h4 id="DWHSG-GUID-881E9280-3C16-4893-A5AE-7FAE20746664" class="sect4"><span class="enumeration_section">5.1.2 </span>About Materialized Views for Distributed Computing
                  </h4>
                  <div>
                     <p>In distributed environments, you can use materialized views to replicate data at distributed sites and to synchronize updates done at those sites with conflict resolution methods. These replica materialized views provide local access to data that otherwise would have to be accessed from remote sites. Materialized views are also useful in remote data marts.</p>
                     <div class="infoboxnotealso" id="GUID-881E9280-3C16-4893-A5AE-7FAE20746664__GUID-018DF864-8DF8-458B-B100-4C97F497B920">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/dwhsg&amp;id=HETER006" target="_blank"><span class="italic">Oracle Database Heterogeneous Connectivity User's Guide</span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG8163"></a><div class="props_rev_3"><a id="GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43" name="GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43"></a><h4 id="DWHSG-GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43" class="sect4"><span class="enumeration_section">5.1.3 </span>About Materialized Views for Mobile Computing
                  </h4>
                  <div>
                     <p>You can also use materialized views to download a subset of data from central servers to mobile clients, with periodic refreshes and updates between clients and the central servers. This chapter focuses on the use of materialized views in data warehouses.</p>
                     <div class="infoboxnotealso" id="GUID-191A50DB-3BD3-4B64-B023-20A3E607EE43__GUID-5D8AB9FA-4BDA-4BA0-B927-14796765C28A">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/dwhsg&amp;id=HETER006" target="_blank"><span class="italic">Oracle Database Heterogeneous Connectivity User's Guide</span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG8165"></a><a id="DWHSG8164"></a><div class="props_rev_3"><a id="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F" name="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F"></a><h4 id="DWHSG-GUID-E4538195-1C38-429C-B10F-8722C6A8A06F" class="sect4"><span class="enumeration_section">5.1.4 </span>The Need for Materialized Views
                  </h4>
                  <div>
                     <p>You can use materialized views to increase the speed of queries on very large databases. Queries to large databases often involve joins between tables, aggregations such as <code class="codeph">SUM</code>, or both. These operations are expensive in terms of time and processing power. The type of materialized view you create determines how the materialized view is refreshed and used by query rewrite.
                     </p>
                     <p>Materialized views improve query performance by precalculating expensive join and aggregation operations on the database prior to execution and storing the results in the database. The query optimizer automatically recognizes when an existing materialized view can and should be used to satisfy a request. It then transparently rewrites the request to use the materialized view. Queries go directly to the materialized view and not to the underlying detail tables. In general, rewriting queries to use materialized views rather than detail tables improves response time. <a href="basic-materialized-views.html#GUID-E4538195-1C38-429C-B10F-8722C6A8A06F__CACGIDEI">Figure 5-1</a> illustrates how query rewrite works.
                     </p>
                     <div class="figure" id="GUID-E4538195-1C38-429C-B10F-8722C6A8A06F__CACGIDEI">
                        <p class="titleinfigure">Figure 5-1 Transparent Query Rewrite</p><img src="img/dwhsg027.gif" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows" longdesc="img_text/dwhsg027.html"><br><a href="img_text/dwhsg027.html">Description of "Figure 5-1 Transparent Query Rewrite"</a></div>
                     <!-- class="figure" -->
                     <p>When using query rewrite, create materialized views that satisfy the largest number of queries. For example, if you identify 20 queries that are commonly applied to the detail or fact tables, then you might be able to satisfy them with five or six well-written materialized views. A materialized view definition can include any number of aggregations (<code class="codeph">SUM</code>, <code class="codeph">COUNT(x)</code>, <code class="codeph">COUNT(*)</code>, <code class="codeph">COUNT(DISTINCT&nbsp;x)</code>, <code class="codeph">AVG</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">MIN</code>, and <code class="codeph">MAX</code>). It can also include any number of joins. If you are unsure of which materialized views to create, Oracle Database provides the SQL Access Advisor, which is a set of advisory procedure<a id="d15276e349" class="indexterm-anchor"></a>s in the <code class="codeph">DBMS_ADVISOR</code> package to help in designing and evaluating materialized views for query rewrite.
                     </p>
                     <p>If a materialized view is to be used by query rewrite, it must be stored in the same database as the detail tables on which it depends. A materialized view can be partitioned, and you can define a materialized view on a partitioned table. You can also define one or more indexes on the materialized view.</p>
                     <p>Unlike indexes, materialized views can be accessed directly using a <code class="codeph">SELECT</code> statement. However, it is recommended that you try to avoid writing SQL statements that directly reference the materialized view, because then it is difficult to change them without affecting the application. Instead, let query rewrite transparently rewrite your query to use the materialized view.
                     </p>
                     <p>Note that the techniques shown in this chapter illustrate how to use materialized views in data warehouses. Materialized views can also be used by Oracle Replication. </p>
                  </div>
               </div><a id="DWHSG8167"></a><a id="DWHSG8166"></a><div class="props_rev_3"><a id="GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF" name="GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF"></a><h4 id="DWHSG-GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF" class="sect4"><span class="enumeration_section">5.1.5 </span>Components of Summary Management
                  </h4>
                  <div>
                     <p>Summary <a id="d15276e389" class="indexterm-anchor"></a>management consists of:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Mechanisms to define <a href="glossary.html#GUID-AC1E7D15-7178-4C7E-89CA-809D13AB2513"><span class="xrefglossterm">materialized view</span></a>s and <a href="glossary.html#GUID-51168741-F40B-41B8-83DE-F159BEB2DE75"><span class="xrefglossterm">dimension</span></a>s.
                           </p>
                        </li>
                        <li>
                           <p>A <a href="glossary.html#GUID-649991BA-18DC-4416-9AB5-D7CF69E202F9"><span class="xrefglossterm">refresh</span></a> mechanism to ensure that all materialized views contain the latest data.
                           </p>
                        </li>
                        <li>
                           <p>A <a href="glossary.html#GUID-BD33929F-FA4E-4E15-BAA7-2E62E2CF6B7B"><span class="xrefglossterm">query rewrite</span></a> capability to transparently rewrite a query to use a materialized view.
                           </p>
                        </li>
                        <li>
                           <p>The <a href="glossary.html#GUID-5C0A9E85-E776-4D52-A9A0-C57198FE4165"><span class="xrefglossterm">SQL Access Advisor</span></a>, which recommends materialized views, partitions, and indexes to create.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">TUNE_MVIEW</code> package, which shows you how to make your materialized view fast refreshable and use general query rewrite.
                           </p>
                        </li>
                     </ul>
                     <p>The use of summary management features imposes no schema restrictions, and can enable some existing DSS database applications to improve performance without the need to redesign the database or the application.</p>
                     <p><a href="basic-materialized-views.html#GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF__I1012580">Figure 5-2</a> illustrates the use of summary management in the warehousing cycle. After the data has been transformed, staged, and loaded into the detail data in the warehouse, you can invoke the summary management process. First, use the SQL Access Advisor to plan how you will use materialized views. Then, create materialized views and design how queries will be rewritten. If you are having problems trying to get your materialized views to work then use <code class="codeph">TUNE_MVIEW</code> to obtain an optimized materialized view.
                     </p>
                     <div class="figure" id="GUID-51B55F3F-6ABC-4304-9573-BAB08E1E67FF__I1012580">
                        <p class="titleinfigure">Figure 5-2 Overview of Summary Management</p><img src="img/dwhsg071.gif" alt="Description of Figure 5-2 follows" title="Description of Figure 5-2 follows" longdesc="img_text/dwhsg071.html"><br><a href="img_text/dwhsg071.html">Description of "Figure 5-2 Overview of Summary Management"</a></div>
                     <!-- class="figure" -->
                     <p>Understanding the summary management process during the earliest stages of data warehouse design can yield large dividends later in the form of higher performance, lower summary administration costs, and reduced storage requirements.</p>
                  </div>
               </div><a id="DWHSG8168"></a><div class="props_rev_3"><a id="GUID-543AB802-DA73-408B-9FE5-686E26D0F44B" name="GUID-543AB802-DA73-408B-9FE5-686E26D0F44B"></a><h4 id="DWHSG-GUID-543AB802-DA73-408B-9FE5-686E26D0F44B" class="sect4"><span class="enumeration_section">5.1.6 </span>Data Warehousing Terminology
                  </h4>
                  <div>
                     <p>Some basic data warehousing terms are defined as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">Dimension</span> <span class="bold">tables</span> describe the business entities of an enterprise, represented as hierarchical, categorical information such as time, departments, locations, and products. Dimension tables are sometimes called<a id="d15276e510" class="indexterm-anchor"></a> lookup or <a id="d15276e515" class="indexterm-anchor"></a>reference tables.
                           </p>
                           <p>Dimension tables usually change slowly over time and are not modified on a periodic schedule. They are used in long-running decision support queries to aggregate the data returned from the query into appropriate levels of the dimension hierarchy.</p>
                        </li>
                        <li>
                           <p><span class="bold">Hierarchies</span> describe the business relationships and common access patterns in the database. An analysis of the dimensions, combined with an understanding of the typical work load, can be used to create materialized views. See <a href="dimensions.html#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">Dimensions</a> for more information.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Fact</span> <span class="bold">tables</span> describe the business transactions of an enterprise.
                           </p>
                           <p>The vast majority of data in a data warehouse is stored in a few very large fact tables that are updated periodically with data from one or more operational OLTP databases.</p>
                           <p>Fact tables includ<a id="d15276e543" class="indexterm-anchor"></a>e facts (also called measures) such as sales, units, and inventory.
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>A simple measure is a numeric or character column of one table such as <code class="codeph">fact.sales</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>A computed measure is an expression involving measures of one table, for example, <code class="codeph">fact.revenues</code> - <code class="codeph">fact.expenses</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>A multitable measure is a computed measure defined on multiple tables, for example, <code class="codeph">fact_a.revenues</code> - <code class="codeph">fact_b.expenses</code>.
                                 </p>
                              </li>
                           </ul>
                           <p>Fact tables also contain one or more foreign <a id="d15276e573" class="indexterm-anchor"></a>keys that organize the business transactions by the relevant business entities such as time, product, and market. In most cases, these foreign keys are non-null, form a unique compound key of the fact table, and each foreign key joins with exactly one row of a<a id="d15276e576" class="indexterm-anchor"></a> <a href="glossary.html#GUID-168122D2-C615-4834-BA3D-B578B3EDC4A4"><span class="xrefglossterm">dimension table</span></a>.
                           </p>
                        </li>
                        <li>
                           <p>A materialized view is a precomputed table comprising aggregated and joined data from fact and possibly from dimension tables.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8169"></a><div class="props_rev_3"><a id="GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27" name="GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27"></a><h4 id="DWHSG-GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27" class="sect4"><span class="enumeration_section">5.1.7 </span>About Materialized View Schema Design
                  </h4>
                  <div>
                     <p>Summary management<a id="d15276e618" class="indexterm-anchor"></a> can perform many useful functions, including query rewrite and materialized view refresh, even if your data warehouse design does not follow these guidelines. However, you realize significantly greater query execution performance and materialized view refresh performance benefits and you require fewer materialized views if your schema design complies with these guidelines.
                     </p>
                     <p>A materialized view definition includes any number of aggregates, as well as any number of joins. In several ways, a materialized view behaves like an index:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The purpose of a materialized view is to increase query execution performance.</p>
                        </li>
                        <li>
                           <p>The existence of a materialized view is transparent to SQL applications, so that a database administrator can create or drop materialized views at any time without affecting the validity of SQL applications.</p>
                        </li>
                        <li>
                           <p>A materialized view consumes storage space.</p>
                        </li>
                        <li>
                           <p>The contents of the materialized view must be updated when the underlying detail tables are modified.</p>
                        </li>
                     </ul>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23">Schemas and Dimension Tables</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4">Guidelines for Materialized View Schema Design</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8170"></a><div class="props_rev_3"><a id="GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23" name="GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23"></a><h5 id="DWHSG-GUID-0EB40435-5B01-4333-8C7F-CC3D6E73BF23" class="sect5"><span class="enumeration_section">5.1.7.1 </span>Schemas and Dimension Tables
                     </h5>
                     <div>
                        <p>In the case of normalized or partially normalized dimension tables (a dimension that is stored in multiple tables), identify how these tables are joined. Note whether the joins between the dimension tables can guarantee that each child-side row joins with one and only one parent-side row. In the case of denormalized dimensions, determine whether the child-side columns uniquely determine the parent-side (or attribute) columns. These relationships can be enabled with constraints, using the <code class="codeph">NOVALIDATE</code> and <code class="codeph">RELY</code> options if the relationships represented by the constraints are guaranteed by other means. Note that if the joins between fact and dimension tables do not support the parent-child relationship described previously, you still gain significant performance advantages from defining the dimension with the <code class="codeph">CREATE</code> <code class="codeph">DIMENSION</code> statement. Another alternative, subject to some restrictions, is to use outer joins in the materialized view definition (that is, in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement).
                        </p>
                        <p>You must not create dimensions in any schema that does not satisfy these relationships. Incorrect results can be returned from queries otherwise.</p>
                     </div>
                  </div><a id="DWHSG8171"></a><div class="props_rev_3"><a id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4" name="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4"></a><h5 id="DWHSG-GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4" class="sect5"><span class="enumeration_section">5.1.7.2 </span>Guidelines for Materialized View Schema Design
                     </h5>
                     <div>
                        <p>Before starting to define and use the various components of summary management, you should review your schema design to abide by the following guidelines wherever possible. Guidelines 1 and 2 are more important than guideline 3. If your schema design does not follow guidelines 1 and 2, it does not then matter whether it follows guideline 3. Guidelines 1, 2, and 3 affect both query rewrite performance and materialized view refresh performance.</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-310BAA25-5FEA-4A74-8387-CEBDE81E1521">Dimensions Guideline 1</p>
                           <p>Dimensions should either be denormalized (each dimension contained in one table) or the joins between tables in a normalized or partially normalized dimension should guarantee that each child-side row joins with exactly one parent-side row.</p>
                           <p>You can enforce this condition by adding <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> and <code class="codeph">NOT NULL</code> constraints on the child-side join keys and <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraints on the parent-side join keys.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-6E4CBE68-0C9F-4BAC-88E5-7F004CFC2523">Dimensions Guideline 2</p>
                           <p>If dimensions are denormalized or partially denormalized, hierarchical integrity must be maintained between the key columns of the dimension table. Each child key value must uniquely identify its parent key value, even if the dimension table is denormalized. Hierarchical integrity in a denormalized dimension can be verified by calling the <code class="codeph">VALIDATE_DIMENSION</code> procedure of the <code class="codeph">DBMS_DIMENSION</code> package.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-BA144B4F-D42F-4288-855C-FE5CA8B031C1">Dimensions Guideline 3</p>
                           <p>Fact and dimension tables should similarly guarantee that each fact table row joins with exactly one dimension table row. This condition must be declared, and optionally enforced, by adding <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> and <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints on the fact key column(s) and <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraints on the dimension key column(s), or by using outer joins. In a data warehouse, constraints are typically enabled with the <code class="codeph">NOVALIDATE</code> and <code class="codeph">RELY</code> clauses to avoid constraint enforcement performance overhead.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-AF7C8988-AA8A-493A-A82B-DFCABF00A96F">Dimensions Guideline 4</p>
                           <p>After each load and before refreshing your materialized view, use the <code class="codeph">VALIDATE_DIMENSION</code> procedure of the <code class="codeph">DBMS_DIMENSION</code> package to incrementally verify dimensional integrity.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-7562295B-1501-4C05-93F0-4C4F9C01F521">Incremental Loads Guideline</p>
                           <p>Incremental loads of your detail data should be done using the SQL*Loader direct-path option, or any bulk loader utility that uses Oracle's direct-path interface. This includes <code class="codeph">INSERT</code> ... <code class="codeph">AS SELECT</code> with the <code class="codeph">APPEND</code> or <code class="codeph">PARALLEL</code> hints, where the hints cause the direct loader log to be used during the insert. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-D5FC461B-223C-4F80-9B36-C944923EF7E7">Partitions Guideline</p>
                           <p>Range/composite partition your tables by a monotonically increasing time column if possible (preferably of type <code class="codeph">DATE</code>).
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-0F7C0117-933F-453C-9659-9B168F0AEA6B">Time Dimensions Guideline</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>If a time dimension appears in the materialized view as a time column, partition and index the materialized view in the same manner as you have the fact tables.</p>
                           <p>If you are concerned with the time required to enable constraints and whether any constraints might be violated, then use the <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> with the <code class="codeph">RELY</code> clause to turn on constraint checking without validating any of the existing constraints. The risk with this approach is that incorrect query results could occur if any constraints are broken. Therefore, as the designer, you must determine how clean the data is and whether the risk of incorrect results is too great.
                           </p>
                           <div class="infoboxnotealso" id="GUID-1BAEE838-C1E9-43ED-9441-6E969DB4EAB4__GUID-20A7AE13-61D9-4540-8FA7-0E4006EEBD4D">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><span class="q">"<a href="basic-materialized-views.html#GUID-63E162FE-8957-4C1D-9494-041A8B2B7917" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.">Types of Materialized Views</a>"</span></p>
                                 </li>
                                 <li>
                                    <p><span class="q">"<a href="dimensions.html#GUID-C924590B-C481-4202-9243-1EEB66560C6D">Creating Dimensions</a>"</span> for details on the benefits of maintaining a child-side row join with a parent-side row
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF01302" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8173"></a><div class="props_rev_3"><a id="GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05" name="GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05"></a><h4 id="DWHSG-GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05" class="sect4"><span class="enumeration_section">5.1.8 </span>About Loading Data into Data Warehouses
                  </h4>
                  <div>
                     <p>A popular and efficient way to load data into a data warehouse or data mart is to use SQL*Loader with the <code class="codeph">DIRECT</code> or <code class="codeph">PARALLEL</code> option, Data Pump, or to use another loader tool that uses the Oracle direct-path API.
                     </p>
                     <p>Loading strategies can be classified as one-phase or two-phase. In one-phase loading, data is loaded directly into the target table, quality assurance tests are performed, and errors are resolved by performing DML operations prior to refreshing materialized views. If a large number of deletions are possible, then storage utilization can be adversely affected, but temporary space requirements and load time are minimized.</p>
                     <p>In a two-phase loading process:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Data is first loaded into a temporary table in the warehouse.</p>
                        </li>
                        <li>
                           <p>Quality assurance procedures are applied to the data.</p>
                        </li>
                        <li>
                           <p>Referential integrity constraints on the target table are disabled, and the local index in the target partition is marked unusable.</p>
                        </li>
                        <li>
                           <p>The data is copied from the temporary area into the appropriate partition of the target table using <code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> with the <code class="codeph">PARALLEL</code> or <code class="codeph">APPEND</code> hint. The temporary table is then dropped. Alternatively, if the target table is partitioned, you can create a new (empty) partition in the target table and use <code class="codeph">ALTER TABLE ... EXCHANGE PARTITION</code> to incorporate the temporary table into the target table. See <a href="../sqlrf/ALTER-TABLE.html#SQLRF53492" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information.
                           </p>
                        </li>
                        <li>
                           <p>The constraints are enabled, usually with the <code class="codeph">NOVALIDATE</code> option.
                           </p>
                        </li>
                     </ul>
                     <p>Immediately after loading the detail data and updating the indexes on the detail data, the database can be opened for operation, if desired. You can disable query rewrite at the system level by issuing an <code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED </code>= <code class="codeph">FALSE</code> statement until all the materialized views are refreshed.
                     </p>
                     <p>If <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is set to <code class="codeph">STALE_TOLERATED</code>, access to the materialized view can be allowed at the session level to any users who do not require the materialized views to reflect the data from the latest load by issuing an <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED</code>  = <code class="codeph">TRUE</code> statement. This scenario does not apply when <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is either <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> because the system ensures in these modes that only materialized views with updated data participate in a query rewrite.
                     </p>
                     <div class="infoboxnotealso" id="GUID-EC6F077E-CA4F-44B0-8A1B-60B921488E05__GUID-15444819-88B8-4D39-81DE-51EAACBD0FE8">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sutil/oracle-sql-loader-concepts.html#SUTIL003" target="_blank"><span class="italic">Oracle Database Utilities</span></a> for the restrictions and considerations when using SQL*Loader with the <code class="codeph">DIRECT</code> or <code class="codeph">PARALLEL</code> keywords
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8174"></a><div class="props_rev_3"><a id="GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46" name="GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46"></a><h4 id="DWHSG-GUID-6D7B8BA6-9217-48B5-A6F9-87FF0834DA46" class="sect4"><span class="enumeration_section">5.1.9 </span>Overview of Materialized View Management Tasks
                  </h4>
                  <div>
                     <p>The motivation for using materialized views is to improve performance, but the overhead associated with materialized view management can become a significant system management problem. When reviewing or evaluating some of the necessary materialized view management activities, consider some of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Identifying what materialized views to create initially.</p>
                        </li>
                        <li>
                           <p>Indexing the materialized views.</p>
                        </li>
                        <li>
                           <p>Ensuring that all materialized views and materialized view indexes are refreshed properly each time the database is updated.</p>
                        </li>
                        <li>
                           <p>Checking which materialized views have been used.</p>
                        </li>
                        <li>
                           <p>Determining how effective each materialized view has been on workload performance.</p>
                        </li>
                        <li>
                           <p>Measuring the space being used by materialized views.</p>
                        </li>
                        <li>
                           <p>Determining which new materialized views should be created.</p>
                        </li>
                        <li>
                           <p>Determining which existing materialized views should be dropped.</p>
                        </li>
                        <li>
                           <p>Archiving old detail and materialized view data that is no longer useful.</p>
                        </li>
                     </ul>
                     <p>After the initial effort of creating and populating the data warehouse or data mart, the major administration overhead is the update process, which involves:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Periodic extraction of incremental changes from the operational systems.</p>
                        </li>
                        <li>
                           <p>Transforming the data.</p>
                        </li>
                        <li>
                           <p>Verifying that the incremental changes are correct, consistent, and complete.</p>
                        </li>
                        <li>
                           <p>Bulk-loading the data into the warehouse.</p>
                        </li>
                        <li>
                           <p>Refreshing indexes and materialized views so that they are consistent with the detail data.</p>
                        </li>
                     </ul>
                     <p>The update process must generally be performed within a limited period of time known as the <a id="d15276e1079" class="indexterm-anchor"></a><a href="glossary.html#GUID-3924FE75-A719-428A-B7AB-714D15A456A0"><span class="xrefglossterm">update window</span></a>. The update window depends on the <a id="d15276e1085" class="indexterm-anchor"></a><a href="glossary.html#GUID-6AEAFA62-131A-4B0B-990D-42DD06C68438"><span class="xrefglossterm">update frequency</span></a> (such as daily or weekly) and the nature of the business. For a daily update frequency, an update window of two to six hours might be typical.
                     </p>
                     <p>You need to know your update window for the following activities:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Loading the detail data</p>
                        </li>
                        <li>
                           <p>Updating or rebuilding the indexes on the detail data</p>
                        </li>
                        <li>
                           <p>Performing quality assurance tests on the data</p>
                        </li>
                        <li>
                           <p>Refreshing the materialized views</p>
                        </li>
                        <li>
                           <p>Updating the indexes on the materialized views</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG0082"></a><div class="props_rev_3"><a id="GUID-63E162FE-8957-4C1D-9494-041A8B2B7917" name="GUID-63E162FE-8957-4C1D-9494-041A8B2B7917"></a><h3 id="DWHSG-GUID-63E162FE-8957-4C1D-9494-041A8B2B7917" class="sect3"><span class="enumeration_section">5.2 </span>Types of Materialized Views
               </h3>
               <div>
                  <p><a id="d15276e1130" class="indexterm-anchor"></a>The <code class="codeph">SELECT</code> clause in the materialized view creation statement defines the data that the materialized view is to contain. Only a few restrictions limit what can be specified. Any number of tables can be joined together. Besides tables, other elements such as views, inline views (subqueries in the <code class="codeph">FROM</code> clause of a <code class="codeph">SELECT</code> statement), subqueries, and materialized views can all be joined or referenced in the <code class="codeph">SELECT</code> clause. You cannot, however, define a materialized view with a subquery in the <code class="codeph">SELECT</code> list of the defining query. You can, however, include subqueries elsewhere in the defining query, such as in the <code class="codeph">WHERE</code> clause.
                  </p>
                  <p>The types of materialized views are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E">About Materialized Views with Aggregates</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-3B903558-0C98-4033-9BCD-4A146220E868" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.">About Materialized Views Containing Only Joins</a></p>
                     </li>
                     <li>
                        <p><a href="basic-materialized-views.html#GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C">About Nested Materialized Views</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8176"></a><a id="DWHSG8177"></a><a id="DWHSG8178"></a><a id="DWHSG8175"></a><div class="props_rev_3"><a id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E" name="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E"></a><h4 id="DWHSG-GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E" class="sect4"><span class="enumeration_section">5.2.1 </span>About Materialized Views with Aggregates
                  </h4>
                  <div>
                     <p>In<a id="d15276e1215" class="indexterm-anchor"></a> data warehouses, materialized views normally contain aggregates as shown in <a href="basic-materialized-views.html#GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__I1006540">Example 5-1</a>. For <a href="glossary.html#GUID-4D70E5C0-17A2-4AD5-B75D-3C81B5110FBF"><span class="xrefglossterm">fast refresh</span></a> to be possible, the <code class="codeph">SELECT</code> list must contain all of the <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns (if present), and there must be a <code class="codeph">COUNT(*)</code> and a <code class="codeph">COUNT(column)</code> on any aggregated columns. Also, <a href="glossary.html#GUID-EDB1A012-531D-4BE8-8826-F6D3DC477E33"><span class="xrefglossterm">materialized view log</span></a>s must be present on all tables referenced in the query that defines the materialized view. The valid aggregate functions are: <code class="codeph">SUM</code>, <code class="codeph">COUNT(x)</code>, <code class="codeph">COUNT(*)</code>, <code class="codeph">AVG</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">MIN</code>, and <code class="codeph">MAX</code>, and the expression to be aggregated can be any SQL value expression. See <span class="q">"<a href="basic-materialized-views.html#GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024">Restrictions on Fast Refresh on Materialized Views with Aggregates</a>"</span>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-3BA10586-294C-478E-B949-016C50571746">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="basic-materialized-views.html#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE">Requirements for Using Materialized Views with Aggregates</a>"</span></p>
                     </div>
                     <p>Fast refresh for a materialized view containing joins and aggregates is possible after any type of DML to the base tables (direct load or conventional <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>). It can be defined to be refreshed <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. A <code class="codeph">REFRESH ON</code> <code class="codeph">COMMIT</code> materialized view is refreshed automatically when a transaction that does DML to one of the materialized view's detail tables commits. The time taken to complete the commit may be slightly longer than usual when this method is chosen. This is because the refresh operation is performed as part of the commit process. Therefore, this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.
                     </p>
                     <p>Here are some examples of materialized views with aggregates. Note that materialized view logs are only created because this materialized view is fast refreshed.</p>
                     <div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__I1006540">
                        <p class="titleinexample">Example 5-1 <span class="bold">Creating a Materialized View</span> (Total Number and Value of Sales)
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON products WITH SEQUENCE, ROWID
(prod_id, prod_name, prod_desc, prod_subcategory, prod_subcategory_desc, 
prod_category, prod_category_desc, prod_weight_class, prod_unit_of_measure,
 prod_pack_size, supplier_id, prod_status, prod_list_price, prod_min_price)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW LOG ON sales
WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD IMMEDIATE
REFRESH FAST
ENABLE QUERY REWRITE
AS SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales,
COUNT(*) AS cnt, COUNT(s.amount_sold) AS cnt_amt
FROM sales s, products p
WHERE s.prod_id = p.prod_id GROUP BY p.prod_name;
</pre><p>This example creates a materialized view <code class="codeph">product_sales_mv</code> that computes total number and value of sales for a product. It is derived by joining the tables <code class="codeph">sales</code> and <code class="codeph">products</code> on the column <code class="codeph">prod_id</code>. The materialized view is populated with data immediately because the build method is immediate and it is available for use by query rewrite. In this example, the default refresh method is <code class="codeph">FAST</code>, which is allowed because the appropriate materialized view logs have been created on tables <code class="codeph">products</code> and <code class="codeph">sales</code>.
                        </p>
                        <p>You can achieve better fast refresh performance for local materialized views if you use a materialized view log that contains a <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> clause. An example is the following:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID(prod_id, cust_id, time_id),
  COMMIT SCN INCLUDING NEW VALUES;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-6E37B03D-750D-4E30-9718-168EB4039E95">
                        <p class="titleinexample">Example 5-2 <span class="bold">Creating a Materialized View</span> (Computed Sum of Sales)
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW product_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
BUILD DEFERRED
REFRESH COMPLETE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_name;
</pre><p>This example creates a materialized view <code class="codeph">product_sales_mv</code> that computes the sum of sales by <code class="codeph">prod_name</code>. It is derived by joining the tables <code class="codeph">sales</code> and <code class="codeph">products</code> on the column <code class="codeph">prod_id</code>. The materialized view does not initially contain any data, because the build method is <code class="codeph">DEFERRED</code>. A complete refresh is required for the first refresh of a build deferred materialized view. When it is refreshed and once populated, this materialized view can be used by query rewrite. 
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-B6CFF335-0EC9-4EEC-9CD6-26F63B098D8E">
                        <p class="titleinexample">Example 5-3 <span class="bold">Creating a Materialized View</span> (Aggregates on a Single Table)
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW sum_sales
PARALLEL
BUILD IMMEDIATE  
REFRESH FAST ON COMMIT AS  
SELECT s.prod_id, s.time_id, COUNT(*) AS count_grp,
   SUM(s.amount_sold) AS sum_dollar_sales,
   COUNT(s.amount_sold) AS count_dollar_sales,
   SUM(s.quantity_sold) AS sum_quantity_sales,
   COUNT(s.quantity_sold) AS count_quantity_sales
FROM sales s
GROUP BY s.prod_id, s.time_id;
</pre><p>This example creates a materialized view that contains aggregates on a single table. Because the materialized view log has been created with all referenced columns in the materialized view's defining query, the materialized view is fast refreshable. If DML is applied against the <code class="codeph">sales</code> table, then the changes are reflected in the materialized view when the commit is issued.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E087FDD0-B08C-4878-BBA9-DE56A705835E__GUID-D57F74C8-777A-4FE1-B3CF-3CF52758DDCD">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF01302" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for syntax of the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> and <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statements
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8180"></a><a id="DWHSG8179"></a><div class="props_rev_3"><a id="GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE" name="GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE"></a><h5 id="DWHSG-GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE" class="sect5"><span class="enumeration_section">5.2.1.1 </span>Requirements for Using Materialized Views with Aggregates
                     </h5>
                     <div>
                        <p><a href="basic-materialized-views.html#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE__G1014280" title="Requirements for Materialized Views with Aggregates">Table 5-1</a> illustrates the aggregate requirements for materialized views. If aggregate <code class="codeph">X</code> is present, aggregate <code class="codeph">Y</code> is required and aggregate <code class="codeph">Z</code> is optional.
                        </p>
                        <div class="tblformal" id="GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE__G1014280">
                           <p class="titleintable">Table 5-1 Requirements for Materialized Views with Aggregates</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Requirements for Materialized Views with Aggregates" summary="Requirements for Materialized Views with Aggregates" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d15276e1474">X</th>
                                    <th align="left" valign="bottom" width="33%" id="d15276e1477">Y</th>
                                    <th align="left" valign="bottom" width="37%" id="d15276e1480">Z</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1485" headers="d15276e1474 ">
                                       <p><code class="codeph">COUNT(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1485 d15276e1477 ">
                                       <p><code class="codeph">-</code></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1485 d15276e1480 ">
                                       <p><code class="codeph">-</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1498" headers="d15276e1474 ">
                                       <p><code class="codeph">MIN(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1498 d15276e1477 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1498 d15276e1480 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1507" headers="d15276e1474 ">
                                       <p><code class="codeph">MAX(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1507 d15276e1477 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1507 d15276e1480 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1516" headers="d15276e1474 ">
                                       <p><code class="codeph">SUM(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1516 d15276e1477 ">
                                       <p><code class="codeph">COUNT(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1516 d15276e1480 ">
                                       <p><code class="codeph">-</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1529" headers="d15276e1474 ">
                                       <p><code class="codeph">SUM(col)</code>, <code class="codeph">col</code> has <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1529 d15276e1477 ">
                                       <p>-</p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1529 d15276e1480 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1549" headers="d15276e1474 ">
                                       <p><code class="codeph">AVG(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1549 d15276e1477 ">
                                       <p><code class="codeph">COUNT(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1549 d15276e1480 ">
                                       <p><code class="codeph">SUM(expr)</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1562" headers="d15276e1474 ">
                                       <p><code class="codeph">STDDEV(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1562 d15276e1477 ">
                                       <p><code class="codeph">COUNT(expr)  SUM(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1562 d15276e1480 ">
                                       <p><code class="codeph">SUM(expr * expr)</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d15276e1575" headers="d15276e1474 ">
                                       <p><code class="codeph">VARIANCE(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e1575 d15276e1477 ">
                                       <p><code class="codeph">COUNT(expr)  SUM(expr)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="37%" headers="d15276e1575 d15276e1480 ">
                                       <p><code class="codeph">SUM(expr * expr)</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Note that <code class="codeph">COUNT(*)</code> must always be present to guarantee all types of fast refresh. Otherwise, you may be limited to fast refresh after inserts only. Oracle recommends that you include the optional aggregates in column <code class="codeph">Z</code> in the materialized view in order to obtain the most efficient and accurate fast refresh of the aggregates.
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8181"></a><div class="props_rev_3"><a id="GUID-3B903558-0C98-4033-9BCD-4A146220E868" name="GUID-3B903558-0C98-4033-9BCD-4A146220E868"></a><h4 id="DWHSG-GUID-3B903558-0C98-4033-9BCD-4A146220E868" class="sect4"><span class="enumeration_section">5.2.2 </span>About Materialized Views Containing Only Joins
                  </h4>
                  <div>
                     <p>Some materialized views contain only joins and no aggregates , such as in <a href="basic-materialized-views.html#GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.">Materialized Join Views FROM Clause Considerations</a>, where a materialized view is created that joins the <code class="codeph">sales</code> table to the <code class="codeph">times</code> and <code class="codeph">customers</code> tables. The advantage of creating this type of materialized view is that expensive joins are precalculated.
                     </p>
                     <div class="infoboxnotealso" id="GUID-3B903558-0C98-4033-9BCD-4A146220E868__GUID-B5AA2F20-C6B7-4119-8F7F-E74702970FA8">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="basic-materialized-views.html#GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10" title="If the materialized view contains only joins, the ROWID columns for each table (and each instance of a table that occurs multiple times in the FROM list) must be present in the SELECT list of the materialized view.">Materialized Join Views FROM Clause Considerations</a>"</span></p>
                     </div>
                     <p>Fast refresh for a materialized view containing only joins is possible after any type of DML to the base tables (direct-path or conventional <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>).
                     </p>
                     <p>A materialized view containing only joins can be defined to be refreshed <code class="codeph">ON COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>. If it is <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, the refresh is performed at commit time of the transaction that does DML on the materialized view's detail table.
                     </p>
                     <p>If you specify <code class="codeph">REFRESH</code> <code class="codeph">FAST</code>, Oracle Database performs further verification of the query definition to ensure that fast refresh can be performed if any of the detail tables change. These additional checks are:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A materialized view log must be present for each detail table unless the table supports partition change tracking (PCT). Also, when a materialized view log is required, the <code class="codeph">ROWID</code> column must be present in each materialized view log.
                           </p>
                        </li>
                        <li>
                           <p>The rowids of all the detail tables must appear in the <code class="codeph">SELECT</code> list of the materialized view query definition.
                           </p>
                        </li>
                     </ul>
                     <p>If some of these restrictions are not met, you can create the materialized view as <code class="codeph">REFRESH</code> <code class="codeph">FORCE</code> to take advantage of fast refresh when it is possible. If one of the tables did not meet all of the criteria, but the other tables did, the materialized view would still be fast refreshable with respect to the other tables for which all the criteria are met.
                     </p>
                     <p>To achieve an optimally efficient refresh, you should ensure that the defining query does not use an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
                     <div class="infoboxnotealso" id="GUID-3B903558-0C98-4033-9BCD-4A146220E868__GUID-7DA8543B-D858-4D40-B02D-3CF4337E376C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="basic-materialized-views.html#GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1">Restrictions on Fast Refresh on Materialized Views with Joins Only</a>"</span> for more information regarding the conditions that cause refresh performance to degrade.
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="refreshing-materialized-views.html#GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD">About Partition Change Tracking (PCT) Refresh for Materialized Views</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8183"></a><a id="DWHSG8182"></a><div class="props_rev_3"><a id="GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10" name="GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10"></a><h5 id="DWHSG-GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10" class="sect5"><span class="enumeration_section">5.2.2.1 </span>Materialized Join Views FROM Clause Considerations
                     </h5>
                     <div>
                        <p>If the materialized view contains only joins, the <code class="codeph">ROWID</code> columns for each table (and each instance of a table that occurs multiple times in the <code class="codeph">FROM</code> list) must be present in the <code class="codeph">SELECT</code> list of the materialized view.
                        </p>
                        <p></p>
                        <p>If the materialized view has remote tables in the <code class="codeph">FROM</code> clause, all tables in the <code class="codeph">FROM</code> clause must be located on that same site in order to perform incremental (fast) refresh for the materialized view. Further, <code class="codeph">ON</code> <code class="codeph">COMMIT</code> refresh is not supported for materialized view with remote tables. Except for SCN-based materialized view logs, materialized view logs must be present on the remote site for each detail table of the materialized view and <code class="codeph">ROWID</code> columns must be present in the <code class="codeph">SELECT</code> list of the materialized view, as shown in the following example.
                        </p>
                        <div class="example" id="GUID-1F42F25D-739B-4FEE-BEBC-212869D5CD10__I1006694">
                           <p class="titleinexample">Example 5-4 Materialized View Containing Only Joins</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL BUILD IMMEDIATE
REFRESH FAST AS
SELECT s.rowid "sales_rid", t.rowid "times_rid", c.rowid "customers_rid",
       c.cust_id, c.cust_last_name, s.amount_sold, s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE  s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);
</pre><p>Alternatively, if the previous example did not include the columns <code class="codeph">times_rid</code> and <code class="codeph">customers_rid</code>, and if the refresh method was <code class="codeph">REFRESH</code> <code class="codeph">FORCE</code>, then this materialized view would be fast refreshable only if the sales table was updated but not if the tables <code class="codeph">times</code> or <code class="codeph">customers</code> were updated.
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW detail_sales_mv 
PARALLEL
BUILD IMMEDIATE
REFRESH FORCE AS
SELECT s.rowid "sales_rid", c.cust_id, c.cust_last_name, s.amount_sold,
   s.quantity_sold, s.time_id
FROM sales s, times t, customers c 
WHERE s.cust_id = c.cust_id(+) AND s.time_id = t.time_id(+);</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8184"></a><div class="props_rev_3"><a id="GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C" name="GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C"></a><h4 id="DWHSG-GUID-BA7DBCFF-67F2-44A6-BCE2-931A469F553C" class="sect4"><span class="enumeration_section">5.2.3 </span>About Nested Materialized Views
                  </h4>
                  <div>
                     <p><a id="d15276e1843" class="indexterm-anchor"></a><a id="d15276e1847" class="indexterm-anchor"></a>A nested materialized view is a materialized view whose definition is based on another materialized view. A nested materialized view can reference other relations in the database in addition to referencing materialized views.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-6516CC0D-1F11-4127-A497-114AD84128DF">Why Use Nested Materialized Views?</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-179C8C8A-585B-49E6-8970-09396DB53DE3">About Nesting Materialized Views with Joins and Aggregates</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D">Nested Materialized View Usage Guidelines</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA">Restrictions When Using Nested Materialized Views</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8186"></a><a id="DWHSG8185"></a><div class="props_rev_3"><a id="GUID-6516CC0D-1F11-4127-A497-114AD84128DF" name="GUID-6516CC0D-1F11-4127-A497-114AD84128DF"></a><h5 id="DWHSG-GUID-6516CC0D-1F11-4127-A497-114AD84128DF" class="sect5"><span class="enumeration_section">5.2.3.1 </span>Why Use Nested Materialized Views?
                     </h5>
                     <div>
                        <p>In a data warehouse, you typically create many aggregate views on a single join (for example, rollups along different dimensions). Incrementally maintaining these distinct materialized aggregate views can take a long time, because the underlying join has to be performed many times.</p>
                        <p>Using nested materialized views, you can create multiple single-table materialized views based on a joins-only materialized view and the join is performed just once. In addition, optimizations can be performed for this class of single-table aggregate materialized view and thus refresh is very efficient.</p>
                        <div class="example" id="GUID-6516CC0D-1F11-4127-A497-114AD84128DF__GUID-35F7AA61-B4A1-4620-B7AA-B7E120FC012B">
                           <p class="titleinexample">Example 5-5 Nested Materialized View</p>
                           <p>You can create a nested materialized view on materialized views, but all parent and base materialized views must contain joins or aggregates. If the defining queries for a materialized view do not contain joins or aggregates, it cannot be nested. All the underlying objects (materialized views or tables) on which the materialized view is defined must have a materialized view log. All the underlying objects are treated as if they were tables. In addition, you can use all the existing options for materialized views.</p>
                           <p>Using the tables and their columns from the <code class="codeph">sh</code> sample schema, the following materialized views illustrate how nested materialized views can be created.
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON customers WITH ROWID;
CREATE MATERIALIZED VIEW LOG ON times WITH ROWID;

/*create materialized view join_sales_cust_time as fast refreshable at
   COMMIT time */
CREATE MATERIALIZED VIEW join_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT c.cust_id, c.cust_last_name, s.amount_sold, t.time_id,
       t.day_number_in_week, s.rowid srid, t.rowid trid, c.rowid crid 
FROM sales s, customers c, times t
WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;
</pre><p>To create a nested materialized view on the table <code class="codeph">join_sales_cust_time</code><span class="italic">,</span> you would have to create a materialized view log on the table. Because this will be a single-table aggregate materialized view on <code class="codeph">join_sales_cust_time</code>, you must log all the necessary columns and use the <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code> clause.
                           </p><pre class="oac_no_warn" dir="ltr">/* create materialized view log on join_sales_cust_time */
CREATE MATERIALIZED VIEW LOG ON join_sales_cust_time 
WITH ROWID (cust_last_name, day_number_in_week, amount_sold)
INCLUDING NEW VALUES;

/* create the single-table aggregate materialized view sum_sales_cust_time 
on join_sales_cust_time as fast refreshable at COMMIT time */
CREATE MATERIALIZED VIEW sum_sales_cust_time 
REFRESH FAST ON COMMIT AS
SELECT COUNT(*) cnt_all, SUM(amount_sold) sum_sales, COUNT(amount_sold)
       cnt_sales, cust_last_name, day_number_in_week
FROM join_sales_cust_time
GROUP BY cust_last_name, day_number_in_week;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8187"></a><div class="props_rev_3"><a id="GUID-179C8C8A-585B-49E6-8970-09396DB53DE3" name="GUID-179C8C8A-585B-49E6-8970-09396DB53DE3"></a><h5 id="DWHSG-GUID-179C8C8A-585B-49E6-8970-09396DB53DE3" class="sect5"><span class="enumeration_section">5.2.3.2 </span>About Nesting Materialized Views with Joins and Aggregates
                     </h5>
                     <div>
                        <p>Some types of nested materialized views cannot be fast refreshed. Use <code class="codeph">EXPLAIN_MVIEW</code> to identify those types of materialized views. You can refresh a tree of nested materialized views in the appropriate dependency order by specifying the <code class="codeph">nested = TRUE</code> parameter with the <code class="codeph">DBMS_MVIEW.REFRESH</code> parameter. For example, if you call <code class="codeph">DBMS_MVIEW.REFRESH ('SUM_SALES_CUST_TIME', nested =&gt; TRUE)</code>, the <code class="codeph">REFRESH</code> procedure will first refresh the <code class="codeph">join_sales_cust_time</code> materialized view, and then refresh the <code class="codeph">sum_sales_cust_time</code> materialized view.
                        </p>
                     </div>
                  </div><a id="DWHSG8188"></a><div class="props_rev_3"><a id="GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D" name="GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D"></a><h5 id="DWHSG-GUID-8B2C0915-2FC8-4866-BDF7-7F74ABDC1D5D" class="sect5"><span class="enumeration_section">5.2.3.3 </span>Nested Materialized View Usage Guidelines
                     </h5>
                     <div>
                        <p>You should keep the following in mind when deciding whether to use nested materialized views:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If you want to use fast refresh, you should fast refresh all the materialized views along any chain.</p>
                           </li>
                           <li>
                              <p>If you want the highest level materialized view to be fresh with respect to the detail tables, you must ensure that all materialized views in a tree are refreshed in the correct dependency order before refreshing the highest-level. You can automatically refresh intermediate materialized views in a nested hierarchy using the <code class="codeph">nested = TRUE</code> parameter, as described in <span class="q">"<a href="basic-materialized-views.html#GUID-179C8C8A-585B-49E6-8970-09396DB53DE3">About Nesting Materialized Views with Joins and Aggregates</a>"</span>. If you do not specify <code class="codeph">nested = TRUE</code> and the materialized views under the highest-level materialized view are stale, refreshing only the highest-level will succeed, but makes it fresh only with respect to its underlying materialized view, not the detail tables at the base of the tree.
                              </p>
                           </li>
                           <li>
                              <p>When refreshing materialized views, you must ensure that all materialized views in a tree are refreshed. If you only refresh the highest-level materialized view, the materialized views under it will be stale and you must explicitly refresh them. If you use the <code class="codeph">REFRESH</code> procedure with the <code class="codeph">nested</code> parameter value set to <code class="codeph">TRUE</code>, only specified materialized views and their child materialized views in the tree are refreshed, and not their top-level materialized views. Use the <code class="codeph">REFRESH_DEPENDENT</code> procedure with the nested parameter value set to <code class="codeph">TRUE</code> if you want to ensure that all materialized views in a tree are refreshed.
                              </p>
                           </li>
                           <li>
                              <p>If complete refresh is the only refresh option supported for a particular nested materialized view, then a complete refresh is performed even when a fast refresh is specified.</p>
                           </li>
                           <li>
                              <p>Freshness of a materialized view is calculated relative to the objects directly referenced by the materialized view. When a materialized view references another materialized view, the freshness of the topmost materialized view is calculated relative to changes in the materialized view it directly references, not relative to changes in the tables referenced by the materialized view it references.</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8189"></a><div class="props_rev_3"><a id="GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA" name="GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA"></a><h5 id="DWHSG-GUID-6DABD06E-555C-4C39-9DA5-7601E2464FDA" class="sect5"><span class="enumeration_section">5.2.3.4 </span>Restrictions When Using Nested Materialized Views
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d15276e2061" class="indexterm-anchor"></a><a id="d15276e2065" class="indexterm-anchor"></a>You cannot create both a materialized view and a prebuilt materialized view on the same table. For example, If you have a table <code class="codeph">costs</code> with a materialized view <code class="codeph">cost_mv</code> based on it, you cannot then create a prebuilt materialized view on table <code class="codeph">costs</code>. The result would make <code class="codeph">cost_mv</code> a nested materialized view and this method of conversion is not supported.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8190"></a><a id="DWHSG0083"></a><div class="props_rev_3"><a id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52" name="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52"></a><h3 id="DWHSG-GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52" class="sect3"><span class="enumeration_section">5.3 </span>Creating Materialized Views
               </h3>
               <div>
                  <p>A materialized view can be created with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement or using Enterprise Manager.
                  </p>
                  <div class="section">
                     <p>It is not uncommon in a data warehouse to have already created summary or aggregation tables, and you might not wish to repeat this work by building a new materialized view. In this case, the table that already exists in the database can be registered as a<a id="d15276e2126" class="indexterm-anchor"></a><a id="d15276e2128" class="indexterm-anchor"></a> prebuilt materialized view. This technique is described in <span class="q">"<a href="basic-materialized-views.html#GUID-4DE39B8B-8452-4581-A841-6AF77019986D">Registering Existing Materialized Views</a>"</span>.
                     </p>
                     <p>Once you have selected the materialized views you want to create, follow these steps for each materialized view.</p>
                     <ol>
                        <li>
                           <p>Design the materialized view. Existing user-defined materialized views do not require this step.</p>
                           <p>If the materialized view contains many rows, then, if appropriate, the materialized view should be partitioned (if possible) and should match the partitioning of the largest or most frequently updated detail or fact table (if possible). Refresh performance benefits from partitioning, because it can take advantage of parallel DML capabilities and possible PCT-based refresh.</p>
                        </li>
                        <li>
                           <p>Use the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to create and, optionally, populate the materialized view.
                           </p>
                           <p>If a user-defined materialized view already exists, then use the <code class="codeph">ON</code> <code class="codeph">PREBUILT</code> <code class="codeph">TABLE</code> clause in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. Otherwise, use the <code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code> clause to populate the materialized view immediately, or the <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> clause to populate the materialized view later. A <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> materialized view is disabled for use by query rewrite until the first <code class="codeph">COMPLETE</code> <code class="codeph">REFRESH</code>, after which it is automatically enabled, provided the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause has been specified.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__I1006810">
                     <p class="titleinexample">Example 5-6 Creating a Materialized View</p>
                     <p>This example illustrates creating a materialized view called <code class="codeph">cust_sales_mv</code>.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_sales_mv
PCTFREE 0 TABLESPACE demo
STORAGE (INITIAL 8M)
PARALLEL
BUILD IMMEDIATE
REFRESH COMPLETE
ENABLE QUERY REWRITE AS
SELECT  c.cust_last_name, SUM(amount_sold) AS sum_amount_sold
FROM customers c, sales s WHERE s.cust_id = c.cust_id
GROUP BY c.cust_last_name;
</pre><div class="infoboxnotealso" id="GUID-2FA7BA5F-8222-4DEE-87B3-54352CE95F52__GUID-8A5A1CB4-A761-4E88-89DC-FA19D87F61CD">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF01302" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a>for descriptions of the SQL statements <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>, <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>, and <code class="codeph">DROP</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code></p>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div><a id="DWHSG00831"></a><div class="props_rev_3"><a id="GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B" name="GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B"></a><h4 id="DWHSG-GUID-701F4C59-4FA0-4CF4-B7B1-5AAA0A12515B" class="sect4"><span class="enumeration_section">5.3.1 </span>Creating Materialized Views with Column Alias Lists
                  </h4>
                  <div>
                     <div class="section">
                        <p>Currently, when a materialized view is created, if its defining query contains same-name columns in the <code class="codeph">SELECT</code> list, the name conflicts need to be resolved by specifying unique aliases for those columns. Otherwise, the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement fails with the error messages of columns ambiguously defined. However, the standard method of attaching aliases in the <code class="codeph">SELECT</code> clause for name resolution restricts the use of the full text match query rewrite and it will occur only when the text of the materialized view's defining query and the text of user input query are identical. Thus, if the user specifies select aliases in the materialized view's defining query while there is no alias in the query, the full text match comparison fails. This is particularly a problem for queries from Discoverer, which makes extensive use of column aliases.
                        </p>
                        <p>The following is an example of the problem. <code class="codeph">sales_mv</code> is created with column aliases in the <code class="codeph">SELECT</code> clause but the input query <code class="codeph">Q1</code> does not have the aliases. The full text match rewrite fails. The materialized view is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_mv
ENABLE QUERY REWRITE AS
SELECT s.time_id sales_tid, c.time_id costs_tid
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre><p>Input query statement <code class="codeph">Q1</code> is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, c1.time_id
FROM sales s, products p, costs c1
WHERE s.prod_id = p.prod_id AND c1.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre><p>Even though the materialized view's defining query is almost identical and logically equivalent to the user's input query, query rewrite does not happen because of the failure of full text match that is the only rewrite possibility for some queries (for example, a subquery in the <code class="codeph">WHERE</code> clause).
                        </p>
                        <p>You can add a column alias list to a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. The column alias list explicitly resolves any column name conflict without attaching aliases in the <code class="codeph">SELECT</code> clause of the materialized view. The syntax of the materialized view column alias list is illustrated in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_mv (sales_tid, costs_tid)
ENABLE QUERY REWRITE AS
SELECT s.time_id, c.time_id
FROM sales s, products p, costs c
WHERE s.prod_id = p.prod_id AND c.prod_id = p.prod_id AND
      p.prod_name IN (SELECT prod_name FROM products);
</pre><p>In this example, the defining query of <code class="codeph">sales_mv</code> now matches exactly with the user query <code class="codeph">Q1</code>, so full text match rewrite takes place.
                        </p>
                        <p>Note that when aliases are specified in both the <code class="codeph">SELECT</code> clause and the new alias list clause, the alias list clause supersedes the ones in the <code class="codeph">SELECT</code> clause.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BF609671-F8F4-48BE-A536-B50527C814F8" name="GUID-BF609671-F8F4-48BE-A536-B50527C814F8"></a><h4 id="DWHSG-GUID-BF609671-F8F4-48BE-A536-B50527C814F8" class="sect4"><span class="enumeration_section">5.3.2 </span>Creating Materialized Views Based on Hybird Partitioned Tables
                  </h4>
                  <div>
                     <p>Use the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement to create a materialized view that is based on a hybrid partitioned table.
                     </p>
                     <div class="section">
                        <p></p>
                        <p>In a hybrid partitioned table, some partitions are stored in database segments, whereas other partitions are stored externally. If a materialized view that is based on a hybrid partitioned table includes the partition key or partition marker in its <code class="codeph">SELECT</code> statement, it meets the requirements for PCT refresh.
                        </p>
                        <p>To create a materialized view based on a hybrid partitioned table:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Create a hybrid partitioned table.</span><div>
                              <p>The following command creates a hybrid partitioned table named <code class="codeph">hybrid_sales</code>.
                              </p><pre class="pre codeblock"><code>CREATE TABLE hybrid_sales(time_id date, customer number, price number, )

PARTITION BY RANGE (time_id)
(
   PARTITION century_19 VALUES LESS THAN (TO_DATE('01-01-1900', 'DD-MM-YYYY'))
       EXTERNAL LOCATION (data_dir1:'sales_1.csv'),
   PARTITION century_20 VALUES LESS THAN (TO_DATE('01-01-2000', 'DD-MM-YYYY'))
       EXTERNAL DEFAULT DIRECTORY data_dir2 LOCATION ('sales_2.csv'),
   PARTITION year_2000 VALUES LESS THAN (TO_DATE('01-01-2001', 'DD-MM-YYYY')),
   PARTITION year_2001 VALUES LESS THAN (TO_DATE('01-01-2002, 'DD-MM-YYYY'))
);
</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>Create a materialized view that is based on the hybrid partitioned table.</span><div> 
                              <p>The following command creates a materialized view named <code class="codeph">hypt_mv</code> that is based on the hybrid partitioned table <code class="codeph">hybrid_sales</code>:
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW HyPT_MV 
REFRESH FAST ON DEMAND AS
SELECT time_id, customer_no, sum(price) as total_price
FROM hybrid_sales
GROUP BY time_id, customer_no;
</code></pre><p>Assume that there is a corresponding materialized view log on the table <code class="codeph">hybrid_sales</code>.
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="DWHSG00832"></a><div class="props_rev_3"><a id="GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF" name="GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF"></a><h4 id="DWHSG-GUID-9C3332BB-53E2-4179-B05C-5C8D1E46EFDF" class="sect4"><span class="enumeration_section">5.3.3 </span>About Materialized Views Names
                  </h4>
                  <div>
                     <p><a id="d15276e2446" class="indexterm-anchor"></a>The name of a materialized view must conform to standard Oracle naming conventions. However, if the materialized view is based on a user-defined prebuilt table, then the name of the materialized view must exactly match that table name.
                     </p>
                     <p>If you already have a naming convention for tables and indexes, you might consider extending this naming scheme to the materialized views so that they are easily identifiable. For example, instead of naming the materialized view <code class="codeph">sum_of_sales</code>, it could be called <code class="codeph">sum_of_sales_mv</code> to denote that this is a materialized view and not a table or view.
                     </p>
                  </div>
               </div><a id="DWHSG00833"></a><div class="props_rev_3"><a id="GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266" name="GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266"></a><h4 id="DWHSG-GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266" class="sect4"><span class="enumeration_section">5.3.4 </span>About Storage And Table Compression for Materialized Views
                  </h4>
                  <div>
                     <p><a id="d15276e2480" class="indexterm-anchor"></a>Unless the materialized view is based on <a id="d15276e2485" class="indexterm-anchor"></a><a id="d15276e2489" class="indexterm-anchor"></a><a id="d15276e2493" class="indexterm-anchor"></a><a id="d15276e2497" class="indexterm-anchor"></a>a user-defined prebuilt table, it requires and occupies storage space inside the database. Therefore, the storage needs for the materialized view should be specified in terms of the tablespace where it is to reside and the size of the extents.
                     </p>
                     <p>If you do not know how much space the materialized view requires, then the <code class="codeph">DBMS_MVIEW.ESTIMATE_MVIEW_SIZE</code> package can estimate the number of bytes required to store this uncompressed materialized view. This information can then assist the design team in determining the tablespace in which the materialized view should reside.
                     </p>
                     <p>You should use table compression with highly redundant data, such as tables with many foreign keys. This is particularly useful for materialized views created with the <code class="codeph">ROLLUP</code> clause. Table compression reduces disk use and memory use (specifically, the buffer cache), often leading to a better scaleup for read-only operations. Table compression can also speed up query execution at the expense of update cost. 
                     </p>
                     <div class="infoboxnotealso" id="GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266__GUID-8064D264-5A74-4998-8014-2FA55C22CF2C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../vldbg/partition-availability.html#VLDBG004" target="_blank"><span><cite>Oracle Database VLDB and Partitioning Guide</cite></span></a> for more information about table compression
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-tables.html#ADMIN13948" target="_blank"><span><cite>Oracle Database Administrators Guide</cite></span></a> for more information about table compression
                              </p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/SQL-Statements-MERGE-to-UPDATE.html#SQLRF017" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for a complete description of <code class="codeph">STORAGE</code> semantics
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8192"></a><a id="DWHSG8191"></a><div class="props_rev_3"><a id="GUID-43C2E761-7188-43F6-9678-A80098C1D521" name="GUID-43C2E761-7188-43F6-9678-A80098C1D521"></a><h4 id="DWHSG-GUID-43C2E761-7188-43F6-9678-A80098C1D521" class="sect4"><span class="enumeration_section">5.3.5 </span>About Build Methods for Materialized Views
                  </h4>
                  <div>
                     <p><a id="d15276e2564" class="indexterm-anchor"></a><a id="d15276e2568" class="indexterm-anchor"></a>Two build methods are available for creating the materialized view, as shown in <a href="basic-materialized-views.html#GUID-43C2E761-7188-43F6-9678-A80098C1D521__G1014320" title="Build Methods">Table 5-2</a>. If you select <code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code>, the materialized view definition is added to the schema objects in the data dictionary, and then the fact or detail tables are scanned according to the <code class="codeph">SELECT</code> expression and the results are stored in the materialized view. Depending on the size of the tables to be scanned, this build process can take a considerable amount of time.
                     </p>
                     <p>An alternative approach is to use the <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> clause, which creates the materialized view without data, thereby enabling it to be populated at a later date using the <code class="codeph">DBMS_MVIEW.REFRESH</code> package.
                     </p>
                     <div class="infoboxnotealso" id="GUID-43C2E761-7188-43F6-9678-A80098C1D521__GUID-5E1CF3BB-027B-4851-BFB2-7B0223F2D0A5">
                        <p class="notep1">See Also:</p>
                        <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="A materialized view that uses the ON STATEMENT refresh mode is automatically refreshed every time a DML operation is performed on any of the materialized views base tables. Oracle Database performs fast refresh for materialized views that are defined using approximate queries.While redefining a table online using the DBMS_REDEFINITION package, you can perform incremental refresh of fast refreshable materialized views that are dependent on the table being redefined.You can use the complete, fast, or PCT refresh methods to refresh a materialized view that is based on a hybrid partitioned table.">Refreshing Materialized Views</a></p>
                     </div>
                     <div class="tblformal" id="GUID-43C2E761-7188-43F6-9678-A80098C1D521__G1014320">
                        <p class="titleintable">Table 5-2 Build Methods</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Build Methods" summary="Build Methods" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d15276e2620">Build Method</th>
                                 <th align="left" valign="bottom" width="77%" id="d15276e2623">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15276e2628" headers="d15276e2620 ">
                                    <p><code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d15276e2628 d15276e2623 ">
                                    <p>Create the materialized view and then populate it with data.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d15276e2639" headers="d15276e2620 ">
                                    <p><code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d15276e2639 d15276e2623 ">
                                    <p>Create the materialized view definition but do not populate it with data.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="DWHSG8193"></a><div class="props_rev_3"><a id="GUID-AC92B31A-C6B0-45AE-95A6-B1DE3630EB8A" name="GUID-AC92B31A-C6B0-45AE-95A6-B1DE3630EB8A"></a><h4 id="DWHSG-GUID-AC92B31A-C6B0-45AE-95A6-B1DE3630EB8A" class="sect4"><span class="enumeration_section">5.3.6 </span>About Enabling Query Rewrite for Materialized Views
                  </h4>
                  <div>
                     <p>Before <a id="d15276e2671" class="indexterm-anchor"></a>creating a materialized view, you can verify what types of query rewrite are possible by calling the procedure <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>, or use <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> to optimize the materialized view so that many types of query rewrite are possible. Once the materialized view has been created, you can use <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> to find out if (or why not) it will rewrite a specific query.
                     </p>
                     <p>Even though a materialized view is defined, it will not automatically be used by the query rewrite facility. Even though query rewrite is enabled by default, you also must specify the <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> clause if the materialized view is to be considered available for rewriting queries.
                     </p>
                     <p>If this clause is omitted or specified as <code class="codeph">DISABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> when the materialized view is created, the materialized view can subsequently be enabled for query rewrite with the <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.
                     </p>
                     <p>If you define a materialized view as <code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code>, it is not eligible for query rewrite until it is populated with data through a complete refresh.
                     </p>
                  </div>
               </div><a id="DWHSG8194"></a><div class="props_rev_3"><a id="GUID-580EF7BC-4C61-4030-B42D-BFF47469C1E6" name="GUID-580EF7BC-4C61-4030-B42D-BFF47469C1E6"></a><h4 id="DWHSG-GUID-580EF7BC-4C61-4030-B42D-BFF47469C1E6" class="sect4"><span class="enumeration_section">5.3.7 </span>About Query Rewrite Restrictions
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d15276e2747" class="indexterm-anchor"></a><a id="d15276e2751" class="indexterm-anchor"></a><a id="d15276e2757" class="indexterm-anchor"></a><a id="d15276e2763" class="indexterm-anchor"></a>Query rewrite is not possible with all materialized views. If query rewrite is not occurring when expected, <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> can help provide reasons why a specific query is not eligible for rewrite. If this shows that not all types of query rewrite are possible, use the procedure <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> to see if the materialized view can be defined differently so that query rewrite is possible. Also, check to see if your materialized view satisfies all of the following conditions:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-6A80266B-444E-4BB6-8A48-911E4619338B">About Materialized View Restrictions for Query Rewrite</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-A5409962-E85D-46DD-B34A-820074CA579C">General Query Rewrite Restrictions</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8195"></a><div class="props_rev_3"><a id="GUID-6A80266B-444E-4BB6-8A48-911E4619338B" name="GUID-6A80266B-444E-4BB6-8A48-911E4619338B"></a><h5 id="DWHSG-GUID-6A80266B-444E-4BB6-8A48-911E4619338B" class="sect5"><span class="enumeration_section">5.3.7.1 </span>About Materialized View Restrictions for Query Rewrite
                     </h5>
                     <div>
                        <div class="section">
                           <p>You should keep in mind the following restrictions:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The defining query of the materialized view cannot contain any non-repeatable expressions (<code class="codeph">ROWNUM</code>, <code class="codeph">SYSDATE</code>, non-repeatable PL/SQL functions, and so on).
                                 </p>
                              </li>
                              <li>
                                 <p>The query cannot contain any references to <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types or object <code class="codeph">REF</code>s.
                                 </p>
                              </li>
                              <li>
                                 <p>If the materialized view was registered as <code class="codeph">PREBUILT</code>, the precision of the columns must agree with the precision of the corresponding <code class="codeph">SELECT</code> expressions unless overridden by the <code class="codeph">WITH</code> <code class="codeph">REDUCED</code> <code class="codeph">PRECISION</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>The defining query cannot contain any references to objects or <code class="codeph">XMLTYPE</code>s.
                                 </p>
                              </li>
                              <li>
                                 <p>A materialized view is a noneditioned object and cannot depend on editioned objects unless it mentions an evaluation edition in which names of editioned objects are to be resolved.</p>
                              </li>
                              <li>
                                 <p>A materialized view may only be eligible for query rewrite in a specific range of editions. The <span class="italic"><code class="codeph">query_rewrite_clause</code></span> in the <code class="codeph">CREATE</code> or <code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement lets you specify the range of editions in which a materialized view is eligible for query rewrite.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-6A80266B-444E-4BB6-8A48-911E4619338B__GUID-322BC2A6-F960-45EF-80BC-5CD0DD7B7C41">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="advanced-query-rewrite-materialized-views.html#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" title="Query rewrite considers external partitions in a hybrid partitioned table to be of UNKNOWN freshness. Therefore, when a query requests data from one or more external partitions, it can only be rewritten under TRUSTED or STALE_TOLERATED integrity mode.Queries containing SQL functions that return approximate results are automatically rewritten to use a matching materialized view, if these queries can be answered using the materialized view.Queries that contain COUNT(DISTINCT) operations on integer columns can be rewritten to use materialized views that contain bitmap-based functions.">Advanced Query Rewrite for Materialized Views</a></p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF54175" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8196"></a><div class="props_rev_3"><a id="GUID-A5409962-E85D-46DD-B34A-820074CA579C" name="GUID-A5409962-E85D-46DD-B34A-820074CA579C"></a><h5 id="DWHSG-GUID-A5409962-E85D-46DD-B34A-820074CA579C" class="sect5"><span class="enumeration_section">5.3.7.2 </span>General Query Rewrite Restrictions
                     </h5>
                     <div>
                        <div class="section">
                           <p>You should keep in mind the following restrictions:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>A query can reference both local and remote tables. Such a query can be rewritten as long as an eligible materialized view referencing the same tables is available locally.</p>
                              </li>
                              <li>
                                 <p>Neither the detail tables nor the materialized view can be owned by <code class="codeph">SYS</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>If a column or expression is present in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view, it must also be present in the <code class="codeph">SELECT</code> list.
                                 </p>
                              </li>
                              <li>
                                 <p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code class="codeph">AVG(AVG(x))</code> or <code class="codeph">AVG(x)</code>+ <code class="codeph">AVG(x)</code> are not allowed.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">CONNECT</code> <code class="codeph">BY</code> clauses are not allowed.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-A5409962-E85D-46DD-B34A-820074CA579C__GUID-1AFBC5C0-2A4A-48AD-A8FB-90BEBE472A2E">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="advanced-query-rewrite-materialized-views.html#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" title="Query rewrite considers external partitions in a hybrid partitioned table to be of UNKNOWN freshness. Therefore, when a query requests data from one or more external partitions, it can only be rewritten under TRUSTED or STALE_TOLERATED integrity mode.Queries containing SQL functions that return approximate results are automatically rewritten to use a matching materialized view, if these queries can be answered using the materialized view.Queries that contain COUNT(DISTINCT) operations on integer columns can be rewritten to use materialized views that contain bitmap-based functions.">Advanced Query Rewrite for Materialized Views</a></p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF54175" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8197"></a><div class="props_rev_3"><a id="GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36" name="GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36"></a><h4 id="DWHSG-GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36" class="sect4"><span class="enumeration_section">5.3.8 </span>About Refresh Options for Materialized Views
                  </h4>
                  <div>
                     <p><a id="d15276e3035" class="indexterm-anchor"></a>When you define a materialized view, you can specify three refresh options: how to refresh, what type of refresh, and can trusted constraints be used. If unspecified, the defaults are assumed as <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, <code class="codeph">FORCE</code>, and <code class="codeph">ENFORCED</code> constraints respectively.
                     </p>
                     <div class="infoboxnotealso" id="GUID-11109A1B-1E8A-4F10-9BB3-DEB4D1AAEC36__GUID-4C2B1E31-6F24-46C2-A292-FB3ADBEB0CCE">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D">About Refresh Modes for Materialized Views</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5">About Types of Materialized View Refresh</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82">About Using Trusted Constraints and Materialized View Refresh</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8198"></a><div class="props_rev_3"><a id="GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D" name="GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D"></a><h5 id="DWHSG-GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D" class="sect5"><span class="enumeration_section">5.3.8.1 </span>About Refresh Modes for Materialized Views
                     </h5>
                     <div>
                        <p>The refresh execution modes are <code class="codeph">ON COMMIT</code> , <code class="codeph">ON DEMAND</code>, and <code class="codeph">ON STATEMENT</code>. Depending on the materialized view you create, some options may not be available. <a href="basic-materialized-views.html#GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D__G1014263" title="This table describes the refresh modes supported for materialized views.">Table 5-3</a> describes the refresh modes.
                        </p>
                        <p></p>
                        <div class="tblformal" id="GUID-6BE42145-3DD1-4F39-B417-E26C81F5682D__G1014263">
                           <p class="titleintable">Table 5-3 Refresh Modes</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Refresh Modes" summary="This table describes the refresh modes supported for materialized views." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d15276e3124">Refresh Mode</th>
                                    <th align="left" valign="bottom" width="80%" id="d15276e3127">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3132" headers="d15276e3124 ">
                                       <p><code class="codeph">ON COMMIT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3132 d15276e3127 ">
                                       <p>Refresh occurs automatically when a transaction that modified one of the materialized view's detail tables commits. This can be specified as long as the materialized view is fast refreshable (in other words, not complex). The <code class="codeph">ON</code> <code class="codeph">COMMIT</code> privilege is necessary to use this mode.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3146" headers="d15276e3124 ">
                                       <p><code class="codeph">ON DEMAND</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3146 d15276e3127 ">
                                       <p>Refresh occurs when a user manually executes one of the available refresh procedures contained in the <code class="codeph">DBMS_MVIEW</code> package (<code class="codeph">REFRESH</code>, <code class="codeph">REFRESH_ALL_MVIEWS</code>, <code class="codeph">REFRESH_DEPENDENT</code>).
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3166" headers="d15276e3124 ">
                                       <p><code class="codeph">ON STATEMENT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3166 d15276e3127 ">
                                       <p>Refresh occurs automatically, without the need to commit the transaction, when a DML operation is performed on any of the materialized views base tables. This method does not require the creation of materialized view logs on materialized views base tables. This mode can be used as long as the materialized view is fast refreshable.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>When using the <code class="codeph">ON STATEMENT</code> or <code class="codeph">ON COMMIT</code> method, the time to complete a DML or commit may be slightly longer than usual. This is because the refresh operation is performed as part of the DML (for <code class="codeph">ON STATEMENT</code> refresh) or as part of the commit (for <code class="codeph">ON COMMIT</code> refresh). Therefore, these methods may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.
                        </p>
                        <p>If you anticipate performing insert, update or delete operations on tables referenced by a materialized view concurrently with the refresh of that materialized view, and that materialized view includes joins and aggregation, Oracle recommends you use <code class="codeph">ON COMMIT</code> fast refresh rather than <code class="codeph">ON DEMAND</code> fast refresh.
                        </p>
                        <p>If you think the materialized view did not refresh, check the alert log or trace file.</p>
                        <p>If a materialized view fails during refresh at DML or commit time, you must explicitly invoke the refresh procedure using the <code class="codeph">DBMS_MVIEW</code> package after addressing the errors specified in the trace files. Until this is done, the materialized view will no longer be refreshed automatically at commit time.
                        </p>
                     </div>
                  </div><a id="DWHSG8199"></a><div class="props_rev_3"><a id="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5" name="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5"></a><h5 id="DWHSG-GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5" class="sect5"><span class="enumeration_section">5.3.8.2 </span>About Types of Materialized View Refresh
                     </h5>
                     <div>
                        <p>You can specify how you want your materialized views to be refreshed from the detail tables by selecting one of four options: <code class="codeph">COMPLETE</code>, <code class="codeph">FAST</code>, <code class="codeph">FORCE</code>, and <code class="codeph">NEVER</code>. <a href="basic-materialized-views.html#GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5__G1014333" title="This table describes the refresh options supported for materialized views.">Table 5-4</a> describes the refresh options.
                        </p>
                        <div class="tblformal" id="GUID-36A4A15D-4CAC-496C-95AD-EF36B9B645F5__G1014333">
                           <p class="titleintable">Table 5-4 Refresh Options</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Refresh Options" summary="This table describes the refresh options supported for materialized views." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d15276e3257">Refresh Option</th>
                                    <th align="left" valign="bottom" width="80%" id="d15276e3260">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3265" headers="d15276e3257 ">
                                       <p><code class="codeph">COMPLETE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3265 d15276e3260 ">
                                       <p>Refreshes by recalculating the materialized view's defining query.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3273" headers="d15276e3257 ">
                                       <p><code class="codeph">FAST</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3273 d15276e3260 ">
                                       <p>Applies incremental changes to refresh the materialized view using the information logged in the materialized view logs, or from a SQL*Loader direct-path or a partition maintenance operation.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3281" headers="d15276e3257 ">
                                       <p><code class="codeph">FORCE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3281 d15276e3260 ">
                                       <p>Applies <code class="codeph">FAST</code> refresh if possible; otherwise, it applies <code class="codeph">COMPLETE</code> refresh.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3295" headers="d15276e3257 ">
                                       <p><code class="codeph">NEVER</code></p>
                                    </td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3295 d15276e3260 ">
                                       <p>Indicates that the materialized view will not be refreshed with refresh mechanisms.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Whether the fast refresh option is available depends upon the type of materialized view. You can call the procedure <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> to determine whether fast refresh is possible.
                        </p>
                     </div>
                  </div><a id="DWHSG8200"></a><div class="props_rev_3"><a id="GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82" name="GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82"></a><h5 id="DWHSG-GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82" class="sect5"><span class="enumeration_section">5.3.8.3 </span>About Using Trusted Constraints and Materialized View Refresh
                     </h5>
                     <div>
                        <p>You can also specify if it is acceptable to use trusted constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY = TRUSTED</code> during refresh. Any nonvalidated <code class="codeph">RELY</code> constraint is a trusted constraint. For example, nonvalidated foreign key/primary key relationships, functional dependencies defined in dimensions or a materialized view in the <code class="codeph">UNKNOWN</code> state. If query rewrite is enabled during refresh, these can improve the performance of refresh by enabling more performant query rewrites. Any materialized view that can use <code class="codeph">TRUSTED</code> constraints for refresh is left in a state of trusted freshness (the <code class="codeph">UNKNOWN</code> state) after refresh.
                        </p>
                        <p>This is reflected in the column <code class="codeph">STALENESS</code> in the view <code class="codeph">USER_MVIEWS</code>. The column <code class="codeph">UNKNOWN_TRUSTED_FD</code> in the same view is also set to <code class="codeph">Y</code>, which means yes.
                        </p>
                        <p>You can define this property of the materialized view either during create time by specifying <code class="codeph">REFRESH USING TRUSTED [ENFORCED] CONSTRAINTS</code> or by using <code class="codeph">ALTER MATERIALIZED VIEW</code> DDL.
                        </p>
                        <div class="tblformal" id="GUID-B9F8853B-5C0B-4C7A-AB03-CE3D29814A82__GUID-5B66D2E9-33C3-44FF-A0AD-9821B1A82354">
                           <p class="titleintable">Table 5-5 Constraints</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Constraints" summary="This table describes the options for using constraints with materialized views." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d15276e3377">Constraints to Use</th>
                                    <th align="left" valign="bottom" width="80%" id="d15276e3380">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3385" headers="d15276e3377 "><pre class="oac_no_warn" dir="ltr">TRUSTED CONSTRAINTS</pre></td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3385 d15276e3380 ">
                                       <p>Refresh can use trusted constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY</code> <code class="codeph">= TRUSTED</code> during refresh.This allows use of non-validated <code class="codeph">RELY</code> constraints and rewrite against materialized views in <code class="codeph">UNKNOWN</code> or <code class="codeph">FRESH</code> state during refresh.
                                       </p>
                                       <p>The <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause enables you to create a materialized view on top of a table that has a non-NULL Virtual Private Database (VPD) policy on it. In this case, ensure that the materialized view behaves correctly. Materialized view results are computed based on the rows and columns filtered by VPD policy. Therefore, you must coordinate the materialized view definition with the VPD policy to ensure the correct results. Without the <code class="codeph">USING TRUSTED CONSTRAINTS</code> clause, any VPD policy on a base table will prevent a materialized view from being created.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d15276e3415" headers="d15276e3377 "><pre class="oac_no_warn" dir="ltr">ENFORCED CONSTRAINTS</pre></td>
                                    <td align="left" valign="top" width="80%" headers="d15276e3415 d15276e3380 ">
                                       <p>Refresh can use validated constraints and <code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code> during refresh. This allows use of only validated, enforced constraints and rewrite against materialized views in <code class="codeph">FRESH</code> state during refresh.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The fast refresh of a materialized view is optimized using the available primary and foreign key constraints on the join columns. This foreign key/primary key optimization can significantly improve refresh performance. For example, for a materialized view that contains a join between a fact table and a dimension table, if only new rows were inserted into the dimension table with no change to the fact table since the last refresh, then there will be nothing to refresh for this materialized view. The reason is that, because of the primary key constraint on the join column(s) of the dimension table and foreign key constraint on the join column(s) of the fact table, the new rows inserted into the dimension table will not join with any fact table rows, thus there is nothing to refresh. Another example of this refresh optimization is when both the fact and dimension tables have inserts since the last refresh. In this case, Oracle Database will only perform a join of delta fact table with the dimension table. Without the foreign key/primary key optimization, two joins during the refresh would be required, a join of delta fact with the dimension table, plus a join of delta dimension with an image of the fact table from before the inserts.</p>
                        <p>Note that this optimized fast refresh using primary and foreign key constraints on the join columns is available with and without constraint enforcement. In the first case, primary and foreign key constraints are enforced by the Oracle Database. This, however, incurs the cost of constraint maintenance. In the second case, the application guarantees primary and foreign key relationships so the constraints are declared <code class="codeph">RELY NOVALIDATE</code> and the materialized view is defined with the <code class="codeph">REFRESH FAST USING TRUSTED CONSTRAINTS</code> option.
                        </p>
                     </div>
                  </div><a id="DWHSG8201"></a><div class="props_rev_3"><a id="GUID-505C24CF-5D56-4820-88AA-2221410950E7" name="GUID-505C24CF-5D56-4820-88AA-2221410950E7"></a><h5 id="DWHSG-GUID-505C24CF-5D56-4820-88AA-2221410950E7" class="sect5"><span class="enumeration_section">5.3.8.4 </span>General Restrictions on Fast Refresh
                     </h5>
                     <div>
                        <div class="section">
                           <p>The defining query of the materialized view is restricted as follows:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The materialized view must not contain references to non-repeating expressions like <code class="codeph">SYSDATE</code> and <code class="codeph">ROWNUM</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The materialized view must not contain references to <code class="codeph">RAW</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data types.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain a <code class="codeph">SELECT</code> list subquery.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain analytic functions (for example, <code class="codeph">RANK</code>) in the <code class="codeph">SELECT</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot reference a table on which an <code class="codeph">XMLIndex</code> index is defined.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain a <code class="codeph">MODEL</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain a <code class="codeph">HAVING</code> clause with a subquery.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain nested queries that have <code class="codeph">ANY</code>, <code class="codeph">ALL</code>, or <code class="codeph">NOT</code> <code class="codeph">EXISTS</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain a <code class="codeph">[START WITH ] CONNECT BY</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>It cannot contain multiple detail tables at different sites.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">ON</code> <code class="codeph">COMMIT</code> materialized views cannot have remote detail tables.
                                 </p>
                              </li>
                              <li>
                                 <p>Nested materialized views must have a join or aggregate.</p>
                              </li>
                              <li>
                                 <p>Materialized join views and materialized aggregate views with a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause cannot select from an index-organized table.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8202"></a><div class="props_rev_3"><a id="GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1" name="GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1"></a><h5 id="DWHSG-GUID-D930288D-D242-4C27-B8D1-B01236F2E0B1" class="sect5"><span class="enumeration_section">5.3.8.5 </span>Restrictions on Fast Refresh on Materialized Views with Joins Only
                     </h5>
                     <div>
                        <div class="section">
                           <p>Defining queries for materialized views with joins only and no aggregates have the following restrictions on fast refresh:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All restrictions from <span class="q">"<a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>They cannot have <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses or aggregates.
                                 </p>
                              </li>
                              <li>
                                 <p>Rowids of all the tables in the <code class="codeph">FROM</code> list must appear in the <code class="codeph">SELECT</code> list of the query.
                                 </p>
                              </li>
                              <li>
                                 <p>Materialized view logs must exist with rowids for all the base tables in the <code class="codeph">FROM</code> list of the query.
                                 </p>
                              </li>
                              <li>
                                 <p>You cannot create a fast refreshable materialized view from multiple tables with simple joins that include an object type column in the <code class="codeph">SELECT</code> statement.
                                 </p>
                              </li>
                           </ul>
                           <p>Also, the refresh method you choose will not be optimally efficient if:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The defining query uses an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">SELECT</code> list of the materialized view contains expressions on columns from multiple tables.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8203"></a><div class="props_rev_3"><a id="GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024" name="GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024"></a><h5 id="DWHSG-GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024" class="sect5"><span class="enumeration_section">5.3.8.6 </span>Restrictions on Fast Refresh on Materialized Views with Aggregates
                     </h5>
                     <div>
                        <div class="section">
                           <p>Defining queries for materialized views with aggregates or joins have the following restrictions on fast refresh:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All restrictions from <span class="q">"<a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>"</span>.
                                 </p>
                              </li>
                           </ul>
                           <p>Fast refresh is supported for both <code class="codeph">ON</code> <code class="codeph">COMMIT</code> and <code class="codeph">ON</code> <code class="codeph">DEMAND</code> materialized views, however the following restrictions apply:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All tables in the materialized view must have materialized view logs, and the materialized view logs must:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Contain all columns from the table referenced in the materialized view. </p>
                                    </li>
                                    <li>
                                       <p>Specify with <code class="codeph">ROWID</code> and <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>Specify the <code class="codeph">SEQUENCE</code> clause if the table is expected to have a mix of inserts/direct-loads, deletes, and updates.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Only <code class="codeph">SUM</code>, <code class="codeph">COUNT</code>, <code class="codeph">AVG</code>, <code class="codeph">STDDEV</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">MIN</code> and <code class="codeph">MAX</code> are supported for fast refresh.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">COUNT(*)</code> must be specified.
                                 </p>
                              </li>
                              <li>
                                 <p>Aggregate functions must occur only as the outermost part of the expression. That is, aggregates such as <code class="codeph">AVG(AVG(x))</code> or <code class="codeph">AVG(x)</code>+ <code class="codeph">AVG(x)</code> are not allowed.
                                 </p>
                              </li>
                              <li>
                                 <p>For each aggregate such as <code class="codeph">AVG(expr)</code>, the corresponding <code class="codeph">COUNT(expr)</code> must be present. Oracle recommends that <code class="codeph">SUM(expr)</code> be specified.
                                 </p>
                              </li>
                              <li>
                                 <p>If <code class="codeph">VARIANCE(expr)</code> or <code class="codeph">STDDEV(expr</code>) is specified, <code class="codeph">COUNT(expr)</code> and <code class="codeph">SUM(expr)</code> must be specified. Oracle recommends that <code class="codeph">SUM(expr *expr)</code> be specified.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">SELECT</code> column in the defining query cannot be a complex expression with columns from multiple base tables. A possible workaround to this is to use a nested materialized view.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">SELECT</code> list must contain all <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns.
                                 </p>
                              </li>
                              <li>
                                 <p>The materialized view is not based on one or more remote tables.</p>
                              </li>
                              <li>
                                 <p>If you use a <code class="codeph">CHAR</code> data type in the filter columns of a materialized view log, the character sets of the master site and the materialized view must be the same.
                                 </p>
                              </li>
                              <li>
                                 <p>If the materialized view has one of the following, then fast refresh is supported only on conventional DML inserts and direct loads.</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Materialized views with <code class="codeph">MIN</code> or <code class="codeph">MAX</code> aggregates
                                       </p>
                                    </li>
                                    <li>
                                       <p>Materialized views which have <code class="codeph">SUM(expr)</code> but no <code class="codeph">COUNT(expr)</code></p>
                                    </li>
                                    <li>
                                       <p>Materialized views without <code class="codeph">COUNT(*)</code></p>
                                    </li>
                                 </ul>
                                 <p>Such a materialized view is called an insert-only materialized view.</p>
                              </li>
                              <li>
                                 <p>A materialized view with <code class="codeph">MAX</code> or <code class="codeph">MIN</code> is fast refreshable after delete or mixed DML statements if it does not have a <code class="codeph">WHERE</code> clause.
                                 </p>
                                 <p>The max/min fast refresh after delete or mixed DML does not have the same behavior as the insert-only case. It deletes and recomputes the max/min values for the affected groups. You need to be aware of its performance impact.</p>
                              </li>
                              <li>
                                 <p>Materialized views with named views or subqueries in the <code class="codeph">FROM</code> clause can be fast refreshed provided the views can be completely merged. For information on which views will merge, see <a href="../tgsql/introduction-to-sql-tuning.html#TGSQL591" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a>.
                                 </p>
                              </li>
                              <li>
                                 <p>If there are no outer joins, you may have arbitrary selections and joins in the <code class="codeph">WHERE</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>Materialized aggregate views with outer joins are fast refreshable after conventional DML and direct loads, provided only the outer table has been modified. Also, unique constraints must exist on the join columns of the inner join table. If there are outer joins, all the joins must be connected by <code class="codeph">AND</code>s and must use the equality (<code class="codeph">=</code>) operator.
                                 </p>
                              </li>
                              <li>
                                 <p>For materialized views with <code class="codeph">CUBE</code>, <code class="codeph">ROLLUP</code>, grouping sets, or concatenation of them, the following restrictions apply:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The <code class="codeph">SELECT</code> list should contain grouping distinguisher that can either be a <code class="codeph">GROUPING_ID</code> function on all <code class="codeph">GROUP</code> <code class="codeph">BY</code> expressions or <code class="codeph">GROUPING</code> functions one for each <code class="codeph">GROUP</code> <code class="codeph">BY</code> expression. For example, if the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view is "<code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">CUBE(a, b)</code>", then the <code class="codeph">SELECT</code> list should contain either "<code class="codeph">GROUPING_ID(a, b)</code>" or "<code class="codeph">GROUPING(a)</code> <code class="codeph">AND</code> <code class="codeph">GROUPING(b)</code>" for the materialized view to be fast refreshable.
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">GROUP</code> <code class="codeph">BY</code> should not result in any duplicate groupings. For example, "<code class="codeph">GROUP BY a, ROLLUP(a, b)</code>" is not fast refreshable because it results in duplicate groupings "<code class="codeph">(a), (a, b), AND (a)</code>".
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-932B8CD4-BF60-419A-9202-8A9FD5D24024__GUID-E825C5A7-6004-4F9F-BB9F-4C25ECDBA90B">
                              <p class="notep1">See Also:</p>
                              <p><a href="basic-materialized-views.html#GUID-8823A06E-853B-4876-AB9F-96D2D4E5A1DE">Requirements for Using Materialized Views with Aggregates</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8204"></a><div class="props_rev_3"><a id="GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6" name="GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6"></a><h5 id="DWHSG-GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6" class="sect5"><span class="enumeration_section">5.3.8.7 </span>Restrictions on Fast Refresh on Materialized Views with UNION ALL
                     </h5>
                     <div>
                        <div class="section">
                           <p>Materialized views with the <code class="codeph">UNION</code> <code class="codeph">ALL</code> set operator support the <code class="codeph">REFRESH</code> <code class="codeph">FAST</code> option if the following conditions are satisfied:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The defining query must have the <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator at the top level.
                                 </p>
                                 <p>The <code class="codeph">UNION</code> <code class="codeph">ALL</code> operator cannot be embedded inside a subquery, with one exception: The <code class="codeph">UNION</code> <code class="codeph">ALL</code> can be in a subquery in the <code class="codeph">FROM</code> clause provided the defining query is of the form <code class="codeph">SELECT * FROM</code> (view or subquery with <code class="codeph">UNION</code> <code class="codeph">ALL</code>) as in the following example:
                                 </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW view_with_unionall AS
(SELECT c.rowid crid, c.cust_id, 2 umarker
 FROM customers c WHERE c.cust_last_name = 'Smith'
 UNION ALL
 SELECT c.rowid crid, c.cust_id, 3 umarker
 FROM customers c WHERE c.cust_last_name = 'Jones');

CREATE MATERIALIZED VIEW unionall_inside_view_mv
REFRESH FAST ON DEMAND AS
SELECT * FROM view_with_unionall;
</pre><p>Note that the view <code class="codeph">view_with_unionall</code> satisfies the requirements for fast refresh.
                                 </p>
                              </li>
                              <li>
                                 <p>Each query block in the <code class="codeph">UNION</code> <code class="codeph">ALL</code> query must satisfy the requirements of a fast refreshable materialized view with aggregates or a fast refreshable materialized view with joins.
                                 </p>
                                 <p>The appropriate materialized view logs must be created on the tables as required for the corresponding type of fast refreshable materialized view.</p>
                                 <p>Note that the Oracle Database also allows the special case of a single table materialized view with joins only provided the <code class="codeph">ROWID</code> column has been included in the <code class="codeph">SELECT</code> list and in the materialized view log. This is shown in the defining query of the view <code class="codeph">view_with_unionall</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">SELECT</code> list of each query must include a <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker, and the <code class="codeph">UNION</code> <code class="codeph">ALL</code> column must have a distinct constant numeric or string value in each <code class="codeph">UNION</code> <code class="codeph">ALL</code> branch. Further, the marker column must appear in the same ordinal position in the <code class="codeph">SELECT</code> list of each query block. See <span class="q">"<a href="advanced-query-rewrite-materialized-views.html#GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6">UNION ALL Marker and Query Rewrite</a>"</span> for more information regarding <code class="codeph">UNION</code> <code class="codeph">ALL</code> markers.
                                 </p>
                              </li>
                              <li>
                                 <p>Some features such as outer joins, insert-only aggregate materialized view queries and remote tables are not supported for materialized views with <code class="codeph">UNION</code> <code class="codeph">ALL</code>. Note, however, that materialized views used in replication, which do not contain joins or aggregates, can be fast refreshed when <code class="codeph">UNION</code> <code class="codeph">ALL</code> or remote tables are used.
                                 </p>
                              </li>
                              <li>
                                 <p>The compatibility initialization parameter must be set to 9.2.0 or higher to create a fast refreshable materialized view with <code class="codeph">UNION</code> <code class="codeph">ALL</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8205"></a><div class="props_rev_3"><a id="GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD" name="GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD"></a><h5 id="DWHSG-GUID-00879D7D-D517-463F-9052-2FD8F9CE9EAD" class="sect5"><span class="enumeration_section">5.3.8.8 </span>About Achieving Refresh Goals
                     </h5>
                     <div>
                        <p>In addition to the <code class="codeph">EXPLAIN_MVIEW</code> procedure, which is discussed throughout this chapter, you can use the <code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code> procedure to optimize a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to achieve <code class="codeph">REFRESH</code> <code class="codeph">FAST</code> and <code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code> goals.
                        </p>
                        <p>See <a href="basic-materialized-views.html#GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52">Refreshing Materialized Views on Prebuilt Tables</a>.
                        </p>
                     </div><a id="DWHSG9298"></a><div class="props_rev_3"><a id="GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52" name="GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52"></a><h6 id="DWHSG-GUID-FE444279-E7A0-4BF4-B4CA-0F54CB0ACA52" class="sect6"><span class="enumeration_section">5.3.8.8.1 </span>Refreshing Materialized Views on Prebuilt Tables
                        </h6>
                        <div>
                           <div class="section">
                              <p>For materialized views created with the prebuilt option, the index <code class="codeph">I_snap$</code> is not created by default. This index helps fast refresh performance, and a description of how to create this index is illustrated in <span class="q">"<a href="basic-materialized-views.html#GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83">Choosing Indexes for Materialized Views</a>"</span>.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="DWHSG8207"></a><a id="DWHSG8206"></a><div class="props_rev_3"><a id="GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B" name="GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B"></a><h5 id="DWHSG-GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B" class="sect5"><span class="enumeration_section">5.3.8.9 </span>Refreshing Nested Materialized Views
                     </h5>
                     <div>
                        <div class="section">
                           <p>A nested materialized view is considered to be fresh as long as its data is synchronized with the data in its detail tables, even if some of its detail tables could be stale materialized views.</p>
                           <p>You can refresh nested materialized views in two ways: <code class="codeph">DBMS_MVIEW.REFRESH</code> with the <code class="codeph">nested</code> flag set to <code class="codeph">TRUE</code> and <code class="codeph">REFRESH_DEPENDENT</code> with the <code class="codeph">nested</code> flag set to <code class="codeph">TRUE</code> on the base tables. If you use <code class="codeph">DBMS_MVIEW.REFRESH</code>, the entire materialized view chain is refreshed and the coverage starting from the specified materialized view in top-down fashion. That is, the specified materialized view and all its child materialized views in the dependency hierarchy are refreshed in order. With <code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code>, the entire chain is refreshed from the bottom up. That is, all the parent materialized views in the dependency hierarchy starting from the specified table are refreshed in order.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-34A64C33-07E3-48BE-B6E5-48C9AE0BDB8B__GUID-1A319C2D-FBF7-4C68-879F-4EF313462D7A">
                           <p class="titleinexample">Example 5-7 Example of Refreshing a Nested Materialized View</p>
                           <p>The following statement shows an example of refreshing a nested materialized view:</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH('SALES_MV,COST_MV', nested =&gt; TRUE);
</pre><p>This statement will first refresh all child materialized views of <code class="codeph">sales_mv</code> and <code class="codeph">cost_mv</code> based on the dependency analysis and then refresh the two specified materialized views.
                           </p>
                           <p>You can query the <code class="codeph">STALE_SINCE</code> column in the <code class="codeph">*_MVIEWS</code> views to find out when a materialized view became stale.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8208"></a><div class="props_rev_3"><a id="GUID-CBE901D0-B358-4007-8B87-F18966F9A72E" name="GUID-CBE901D0-B358-4007-8B87-F18966F9A72E"></a><h4 id="DWHSG-GUID-CBE901D0-B358-4007-8B87-F18966F9A72E" class="sect4"><span class="enumeration_section">5.3.9 </span>ORDER BY Clause in Materialized Views
                  </h4>
                  <div>
                     <p><a id="d15276e4323" class="indexterm-anchor"></a>An <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is allowed in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. It is used only during the initial creation of the materialized view. It is not used during a full refresh or a fast refresh.
                     </p>
                     <p>To improve the performance of queries against large materialized views, store the rows in the materialized view in the order specified in the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. This initial ordering provides physical clustering of the data. If indexes are built on the columns by which the materialized view is ordered, accessing the rows of the materialized view using the index often reduces the time for disk I/O due to the physical clustering.
                     </p>
                     <p>The <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause is not considered part of the materialized view definition. As a result, there is no difference in the manner in which Oracle Database detects the various types of materialized views (for example, materialized join views with no aggregates). For the same reason, query rewrite is not affected by the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause. This feature is similar to the <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> ... <code class="codeph">ORDER</code> <code class="codeph">BY</code> capability.
                     </p>
                  </div>
               </div><a id="DWHSG8212"></a><div class="props_rev_3"><a id="GUID-EC2E9E41-9C37-44D5-BCE5-568BD5F6E792" name="GUID-EC2E9E41-9C37-44D5-BCE5-568BD5F6E792"></a><h4 id="DWHSG-GUID-EC2E9E41-9C37-44D5-BCE5-568BD5F6E792" class="sect4"><span class="enumeration_section">5.3.10 </span>Using Oracle Enterprise Manager to Create Materialized Views
                  </h4>
                  <div>
                     <p>A materialized view can also be created using Enterprise Manager by selecting the materialized view object type. There is no difference in the information required if this approach is used.</p>
                  </div>
               </div><a id="DWHSG8213"></a><div class="props_rev_3"><a id="GUID-4845AEBC-1AA9-4CD8-AE91-2E4379291FDE" name="GUID-4845AEBC-1AA9-4CD8-AE91-2E4379291FDE"></a><h4 id="DWHSG-GUID-4845AEBC-1AA9-4CD8-AE91-2E4379291FDE" class="sect4"><span class="enumeration_section">5.3.11 </span>Using Materialized Views with NLS Parameters
                  </h4>
                  <div>
                     <p>When using certain materialized views, you must ensure that your NLS parameters are the same as when you created the materialized view. Materialized views with this restriction are as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Expressions that may return different values, depending on NLS parameter settings. For example, (<code class="codeph">date &gt; "01/02/03"</code>) or (<code class="codeph">rate &lt;= "2.150"</code>) are NLS parameter dependent expressions.
                           </p>
                        </li>
                        <li>
                           <p>Equijoins where one side of the join is character data. The result of this equijoin depends on collation and this can change on a session basis, giving an incorrect result in the case of query rewrite or an inconsistent materialized view after a refresh operation.</p>
                        </li>
                        <li>
                           <p>Expressions that generate internal conversion to character data in the <code class="codeph">SELECT</code> list of a materialized view, or inside an aggregate of a materialized aggregate view. This restriction does not apply to expressions that involve only numeric data, for example, <code class="codeph">a+b</code> where <code class="codeph">a</code> and <code class="codeph">b</code> are numeric fields.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9299"></a><a id="DWHSG8214"></a><div class="props_rev_3"><a id="GUID-99476E65-CC39-49CF-A619-C4D947662040" name="GUID-99476E65-CC39-49CF-A619-C4D947662040"></a><h4 id="DWHSG-GUID-99476E65-CC39-49CF-A619-C4D947662040" class="sect4"><span class="enumeration_section">5.3.12 </span>Adding Comments to Materialized Views
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can add comments to materialized views.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-99476E65-CC39-49CF-A619-C4D947662040__GUID-B4EC61E0-B46F-41B7-82B9-089286223E92">Example: Adding Comments to a Materialized View</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following statement adds a comment to data dictionary views for an existing materialized view:</p><pre class="oac_no_warn" dir="ltr">COMMENT ON MATERIALIZED VIEW sales_mv IS 'sales materialized view';
</pre><p>To view the comment after the preceding statement execution, you can query the catalog views, <code class="codeph">{USER</code>, <code class="codeph">DBA}</code> <code class="codeph">ALL_MVIEW_COMMENTS</code>. For example, consider the following example:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MVIEW_NAME, COMMENTS
FROM USER_MVIEW_COMMENTS WHERE MVIEW_NAME = 'SALES_MV';
</pre><p>The output will resemble the following:</p><pre class="oac_no_warn" dir="ltr">MVIEW_NAME                      COMMENTS
-----------      -----------------------
SALES_MV         sales materialized view
</pre><p>Note: If the compatibility is set to 10.0.1 or higher, <code class="codeph">COMMENT</code> <code class="codeph">ON</code> <code class="codeph">TABLE</code> will not be allowed for the materialized view container table. The following error message will be thrown if it is issued.
                        </p><pre class="oac_no_warn" dir="ltr">ORA-12098: cannot comment on the materialized view.
</pre><p>In the case of a prebuilt table, if it has an existing comment, the comment will be inherited by the materialized view after it has been created. The existing comment will be prefixed with <code class="codeph">'(from table)'</code>. For example, table <code class="codeph">sales_summary</code> was created to contain sales summary information. An existing comment <code class="codeph">'Sales summary data'</code> was associated with the table. A materialized view of the same name is created to use the prebuilt table as its container table. After the materialized view creation, the comment becomes <code class="codeph">'(from table) Sales summary data'</code>.
                        </p>
                        <p>However, if the prebuilt table, <code class="codeph">sales_summary</code>, does not have any comment, the following comment is added: <code class="codeph">'Sales summary data'</code>. Then, if you drop the materialized view, the comment will be passed to the prebuilt table with the comment: <code class="codeph">'(from materialized view) Sales summary data'</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9300"></a><div class="props_rev_3"><a id="GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806" name="GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806"></a><h3 id="DWHSG-GUID-4BCA1300-C03E-4C24-AD19-50EB9BBA8806" class="sect3"><span class="enumeration_section">5.4 </span>Creating Materialized View Logs
               </h3>
               <div>
                  <div class="section">
                     <p>Materialized view<a id="d15276e4559" class="indexterm-anchor"></a><a id="d15276e4561" class="indexterm-anchor"></a> logs are required if you want to use fast refresh, with the exception of partition change tracking refresh. That is, if a detail table supports partition change tracking for a materialized view, the materialized view log on that detail table is not required in order to do fast refresh on that materialized view. As a general rule, though, you should create materialized view logs if you want to use fast refresh. Materialized view logs are defined using a <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> statement on the base table that is to be changed. They are not created on the materialized view unless there is another materialized view on top of that materialized view, which is the case with nested materialized views. For fast refresh of materialized views, the definition of the materialized view logs must normally specify the <code class="codeph">ROWID</code> clause. In addition, for aggregate materialized views, it must also contain every column in the table referenced in the materialized view, the <code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code> clause and the <code class="codeph">SEQUENCE</code> clause. You can typically achieve better fast refresh performance of local materialized views containing aggregates or joins by using a <code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code> clause.
                     </p>
                     <p>An example of a materialized view log is shown as follows where one is created on the table <code class="codeph">sales</code>:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre><p>Alternatively, you could create a commit SCN-based materialized view log as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold),
COMMIT SCN INCLUDING NEW VALUES;
</pre><p>Oracle recommends that the keyword <code class="codeph">SEQUENCE</code> be included in your materialized view log statement unless you are sure that you will never perform a mixed DML operation (a combination of <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> operations on multiple tables). The <code class="codeph">SEQUENCE</code> column is required in the materialized view log to support fast refresh with a combination of <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statements on multiple tables. You can, however, add the <code class="codeph">SEQUENCE</code> number to the materialized view log after it has been created.
                     </p>
                     <p>The boundary of a mixed DML operation is determined by whether the materialized view is <code class="codeph">ON</code> <code class="codeph">COMMIT</code> or <code class="codeph">ON</code> <code class="codeph">DEMAND</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For <code class="codeph">ON</code> <code class="codeph">COMMIT</code>, the mixed DML statements occur within the same transaction because the refresh of the materialized view will occur upon commit of this transaction.
                           </p>
                        </li>
                        <li>
                           <p>For <code class="codeph">ON</code> <code class="codeph">DEMAND</code>, the mixed DML statements occur between refreshes. The following example of a materialized view log illustrates where one is created on the table <code class="codeph">sales</code> that includes the <code class="codeph">SEQUENCE</code> keyword:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales WITH SEQUENCE, ROWID
(prod_id, cust_id, time_id, channel_id, promo_id, 
 quantity_sold, amount_sold) INCLUDING NEW VALUES;
</pre></li>
                     </ul>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916">Using the FORCE Option With Materialized View Logs</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED">Purging Materialized View Logs</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9301"></a><div class="props_rev_3"><a id="GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916" name="GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916"></a><h4 id="DWHSG-GUID-03F7FB6A-A806-4F8F-A3E8-5C4D7F06E916" class="sect4"><span class="enumeration_section">5.4.1 </span>Using the FORCE Option With Materialized View Logs
                  </h4>
                  <div>
                     <p>If you specify <code class="codeph">FORCE</code> and any items specified with the <code class="codeph">ADD</code> clause have already been specified for the materialized view log, Oracle does not return an error, but silently ignores the existing elements and adds to the materialized view log any items that do not already exist in the log. For example, if you used a filter column such as <code class="codeph">cust_id</code> and this column already existed, Oracle Database ignores the redundancy and does not return an error.
                     </p>
                  </div>
               </div><a id="DWHSG9302"></a><div class="props_rev_3"><a id="GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED" name="GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED"></a><h4 id="DWHSG-GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED" class="sect4"><span class="enumeration_section">5.4.2 </span>Purging Materialized View Logs
                  </h4>
                  <div>
                     <div class="section">
                        <p>Purging materialized view logs can be done during the materialized view refresh process or deferred until later, thus improving refresh performance time. You can choose different options for when the purge will occur, using a <code class="codeph">PURGE</code> clause, as in the following:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW LOG ON sales
PURGE START WITH sysdate NEXT sysdate+1
WITH ROWID
 (prod_id, cust_id, time_id, channel_id, promo_id, quantity_sold, amount_sold)
INCLUDING NEW VALUES;
</pre><p>You can also query <code class="codeph">USER_MVIEW_LOGS</code> for purge information, as in the following:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT PURGE_DEFERRED, PURGE_INTERVAL, LAST_PURGE_DATE, LAST_PURGE_STATUS
FROM USER_MVIEW_LOGS
WHERE LOG_OWNER "SH" AND MASTER = 'SALES';
</pre><p>In addition to setting the purge when creating a materialized view log, you can also modify an existing materialized view log by issuing a statement resembling the following:</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW LOG ON sales PURGE IMMEDIATE;
</pre><div class="infoboxnotealso" id="GUID-D88BCD87-B724-41F9-99DC-44B67E46B0ED__GUID-94DD02CD-2936-4AE5-A37F-81F872699936">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW-LOG.html#SQLRF01303" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for more information regarding materialized view log syntax
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-42B64F99-7391-48B8-B37D-1B486DC29645" name="GUID-42B64F99-7391-48B8-B37D-1B486DC29645"></a><h3 id="DWHSG-GUID-42B64F99-7391-48B8-B37D-1B486DC29645" class="sect3"><span class="enumeration_section">5.5 </span>Creating Materialized Views Based on Approximate Queries
               </h3>
               <div>
                  <p>A materialized view based on approximate queries uses SQL functions that return approximate functions in its defining query.</p>
                  <div class="section">
                     <p></p>
                     <p>You can compute summary and aggregate approximations and store these results in materialized views for further analysis or querying. The summary approximation, which computes approximate aggregates for all dimensions within a group of rows, can be used to perform detailed aggregation. You can further aggregate the summary data to obtain aggregate approximations that can be used for high-level analysis so that the Oracle Database does not scan the base tables again to compute higher-level aggregates. Oracle Database does not scan the base tables again to compute higher-level aggregates. It just uses the existing aggregated results to compute the higher-level aggregates. For example, you can create a summary approximation that stores the approximate number of products sold within each state and within each country. This aggregate approximation is then used to return the approximate distinct number of products within each country.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="p">
                     <p>To create a materialized view containing SQL functions that return approximate results:</p>
                  </div>
                  <!-- class="section" -->
                  <ul>
                     <li class="stepexpand"><span>Run the <code class="codeph">CREATE MATERIALIZED VIEW</code> statement, with the defining query containing the appropriate functions</span><div>
                           <p>For example, use the <code class="codeph">APPROX_PERCENTILE</code> function in the defining query of the materialized view.
                           </p>
                        </div>
                     </li>
                  </ul>
                  <div class="example" id="GUID-42B64F99-7391-48B8-B37D-1B486DC29645__GUID-DB6FA7AA-68EC-445D-B3AE-AE04025F3C36">
                     <p class="titleinexample">Example 5-8 <span class="bold">Creating a Materialized View Based on Approximate Queries </span></p>
                     <p>The following example creates a materialized view that stores the approximate number of distinct products that are sold on each day.</p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW approx_count_distinct_pdt_mv 
ENABLE QUERY REWRITE AS
SELECT t.calendar_year, t.calendar_month_number, t.day_number_in_month, approx_count_distinct(prod_id) daily_detail
FROM sales s, times t
WHERE s.time_id = t.time_id
GROUP BY t.calendar_year, t.calendar_month_number, t.day_number_in_month;
</code></pre><div class="infoboxnotealso" id="GUID-42B64F99-7391-48B8-B37D-1B486DC29645__GUID-9A25B83F-4BF7-435F-B25F-A4E8B2DE828B">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="refreshing-materialized-views.html#GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689" title="Oracle Database performs fast refresh for materialized views that are defined using approximate queries.">Refreshing Materialized Views Based on Approximate Queries</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E8AF7908-979A-49F2-B845-D9A5010BE863" title="Oracle Database provides a set of SQL functions that return approximate percentile results. These functions can be used to monitor quality, track social media activity, monitor performance, and search for outliers within a data set.">Using Percentile Functions that Return Approximate Results</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-03107B3C-72D3-4B6B-A922-F13FF0CF2B6D" name="GUID-03107B3C-72D3-4B6B-A922-F13FF0CF2B6D"></a><h3 id="DWHSG-GUID-03107B3C-72D3-4B6B-A922-F13FF0CF2B6D" class="sect3"><span class="enumeration_section">5.6 </span>Creating a Materialized View Containing Bitmap-based  COUNT(DISTINCT) Functions
               </h3>
               <div>
                  <p>Materialized views based on <code class="codeph">COUNT(DISTINCT)</code> functions can provide enhanced performance by using bitmap-based operations on integer columns. 
                  </p>
                  <div class="section">
                     <p></p>
                     <p>Starting with Oracle Database Release 19c, you can create materialized views based on SQL aggregate functions that use bitmap representation to express the computation of <code class="codeph">COUNT(DISTINCT)</code> operations.  These functions include <code class="codeph">BITMAP_BUCKET_NUMBER</code>, <code class="codeph">BITMAP_BIT_POSITION</code> and <code class="codeph">BITMAP_CONSTRUCT_AGG</code>.
                     </p>
                     <p>To create a materialized view based on bitmaps:</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>Ensure that materialized view logs exist for the tables on which the materialized view will be based. </span></li>
                     <li class="stepexpand"><span>Use the <code class="codeph">CREATE MATERIALIZED VIEW</code> command to create the materialized view.</span><div>
                           <p>The following example creates a materialized view based on the <code class="codeph">SH.SALES</code> table and containing non-additive facts.
                           </p><pre class="pre codeblock"><code>SQL&gt; create materialized view mv_sales as
  2  select PROMO_ID,
  3  BITMAP_BUCKET_NUMBER(PROD_ID) bm_bktno,
  4  BITMAP_CONSTRUCT_AGG(BITMAP_BIT_POSITION(PROD_ID),'RAW') bm_details
  5  from sales 
  6  group by PROMO_ID,BITMAP_BUCKET_NUMBER(PROD_ID);

Materialized view created.</code></pre></div>
                     </li>
                  </ol>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="advanced-query-rewrite-materialized-views.html#GUID-50F1CD49-F551-4443-96FD-6F8EDA694930" title="Queries that contain COUNT(DISTINCT) operations on integer columns can be rewritten to use materialized views that contain bitmap-based functions.">Query Rewrite and Materialized Views Based on Bitmap-based COUNT(DISTINCT) Functions</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8215"></a><div class="props_rev_3"><a id="GUID-4DE39B8B-8452-4581-A841-6AF77019986D" name="GUID-4DE39B8B-8452-4581-A841-6AF77019986D"></a><h3 id="DWHSG-GUID-4DE39B8B-8452-4581-A841-6AF77019986D" class="sect3"><span class="enumeration_section">5.7 </span>Registering Existing Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p><a id="d15276e4949" class="indexterm-anchor"></a>Some data warehouses have implemented materialized views in ordinary user tables. Although this solution provides the performance benefits of materialized views, it does not:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Provide query rewrite to all SQL applications.</p>
                        </li>
                        <li>
                           <p>Enable materialized views defined in one application to be transparently accessed in another application.</p>
                        </li>
                        <li>
                           <p>Generally support fast parallel or fast materialized view refresh.</p>
                        </li>
                     </ul>
                     <p>Because of these limitations, and because existing materialized views can be extremely large and expensive to rebuild, you should register your existing materialized view tables whenever possible. You can register a user-defined materialized view with the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ... <code class="codeph">ON</code> <code class="codeph">PREBUILT</code> <code class="codeph">TABLE</code> statement. Once registered, the materialized view can be used for query rewrites or maintained by one of the refresh methods, or both.
                     </p>
                     <p>The contents of the table must reflect the materialization of the defining query at the time you register it as a materialized view, and each column in the defining query must correspond to a column in the table that has a matching data type. However, you can specify <code class="codeph">WITH</code> <code class="codeph">REDUCED</code> <code class="codeph">PRECISION</code> to allow the precision of columns in the defining query to be different from that of the table columns.
                     </p>
                     <p>The table and the materialized view must have the same name, but the table retains its identity as a table and can contain columns that are not referenced in the defining query of the materialized view. These extra columns are known as unmanaged columns. If rows are inserted during a refresh operation, each unmanaged column of the row is set to its default value. Therefore, the unmanaged columns cannot have <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints unless they also have default values. 
                     </p>
                     <p>Materialized views based on prebuilt tables are eligible for selection by query rewrite provided the parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code> is set to <code class="codeph">STALE_TOLERATED</code> or <code class="codeph">TRUSTED</code>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-4DE39B8B-8452-4581-A841-6AF77019986D__GUID-C92605F2-CB73-4E1E-9E08-4FBAA9AEC4D0">
                        <p class="notep1">See Also:</p>
                        <p><a href="basic-query-rewrite-materialized-views.html#GUID-DB76286B-8557-446B-A6CC-BC987C378076" title="A query undergoes several checks to determine whether it is a candidate for query rewrite. If the query fails any check, then the query is applied to the detail tables rather than the materialized view. The inability to rewrite can be costly in terms of response time and processing power.Query rewrite behavior is controlled by certain database initialization parameters.Query rewrite offers three levels of rewrite integrity that are controlled by the initialization parameter QUERY_REWRITE_INTEGRITY.This example illustrates the power of query rewrite with materialized views.">Basic Query Rewrite for Materialized Views</a> for details about integrity levels
                        </p>
                     </div>
                     <p><a id="d15276e5029" class="indexterm-anchor"></a><a id="d15276e5033" class="indexterm-anchor"></a>When you drop a materialized view that was created on a prebuilt table, the table still existsonly the materialized view is dropped.
                     </p>
                     <p>The following example illustrates the two steps required to register a user-defined table. First, the table is created, then the materialized view is defined using exactly the same name as the table. This materialized view <code class="codeph">sum_sales_tab_mv</code> is eligible for use in query rewrite.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sum_sales_tab
PCTFREE 0  TABLESPACE demo
STORAGE (INITIAL 8M) AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
       SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;

CREATE MATERIALIZED VIEW sum_sales_tab_mv
ON PREBUILT TABLE WITHOUT REDUCED PRECISION
ENABLE QUERY REWRITE AS
SELECT s.prod_id, SUM(amount_sold) AS dollar_sales,
    SUM(quantity_sold) AS unit_sales
FROM sales s GROUP BY s.prod_id;
</pre><p>You could have compressed this table to save space.</p>
                     <p>In some cases, user-defined materialized views are refreshed on a schedule that is longer than the update cycle. For example, a monthly materialized view might be updated only at the end of each month, and the materialized view values always refer to complete time periods. Reports written directly against these materialized views implicitly select only data that is not in the current (incomplete) time period. If a user-defined materialized view already contains a time dimension:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It should be registered and then fast refreshed each update cycle.</p>
                        </li>
                        <li>
                           <p>You can create a view that selects the complete time period of interest.</p>
                        </li>
                        <li>
                           <p>The reports should be modified to refer to the view instead of referring directly to the user-defined materialized view.</p>
                        </li>
                     </ul>
                     <p>If the user-defined materialized view does not contain a time dimension, then you should create a new materialized view that does include the time dimension (if possible). Also, in this case, the view should aggregate over the time column in the new materialized view.</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8216"></a><div class="props_rev_3"><a id="GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83" name="GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83"></a><h3 id="DWHSG-GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83" class="sect3"><span class="enumeration_section">5.8 </span>Choosing Indexes for Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p>The two most common operations on a materialized view are query execution and fast refresh, and each operation has different performance requirements. Query execution might need to access any subset of the materialized view key columns, and might need to join and aggregate over a subset of those columns. Consequently, query execution usually performs best if a single-column bitmap index is defined on each materialized view key column.</p>
                     <p>In the case of materialized views containing only joins using fast refresh, Oracle recommends that indexes be created on the columns that contain the rowids to improve the performance of the refresh operation.</p>
                     <p>If a materialized view using aggregates is fast refreshable, then an index appropriate for the fast refresh procedure is created unless <code class="codeph">USING</code> <code class="codeph">NO</code> <code class="codeph">INDEX</code> is specified in the <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.
                     </p>
                     <p>If the materialized view is partitioned, then, after doing a partition maintenance operation on the materialized view, the indexes become unusable, and they need to be rebuilt for fast refresh to work.</p>
                     <p>If you create a materialized view with the prebuilt option, the <code class="codeph">I_snap$</code> index is not automatically created. This index significantly improves fast refresh performance, and you can create it manually by issuing a statement such as the following:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE UNIQUE INDEX &lt;OWNER&gt;."I_SNAP$_&lt;MVIEW_NAME&gt;" ON &lt;OWNER&gt;.&lt;MVIEW_NAME&gt;
 (SYS_OP_MAP_NONNULL("LOG_DATE"))
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DE
FAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE &lt;TABLESPACE_NAME&gt;;
</pre><div class="infoboxnotealso" id="GUID-681BB72C-13B2-42AF-BD59-F4DFE8685F83__GUID-B53F843C-E73E-4A7A-84DF-5F82CD036DA5">
                        <p class="notep1">See Also:</p>
                        <p><a href="../tgsql/introduction-to-sql-tuning.html#TGSQL591" target="_blank"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for information on using the SQL Access Advisor to determine what indexes are appropriate for your materialized view
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8217"></a><div class="props_rev_3"><a id="GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57" name="GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57"></a><h3 id="DWHSG-GUID-2932186A-CA03-47B7-A11A-FF30BD62AB57" class="sect3"><span class="enumeration_section">5.9 </span>Dropping Materialized Views
               </h3>
               <div>
                  <div class="section">
                     <p>Use the <code class="codeph">DROP</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement to drop a <a id="d15276e5157" class="indexterm-anchor"></a><a id="d15276e5161" class="indexterm-anchor"></a>materialized view. For example, consider the following statement:
                     </p><pre class="oac_no_warn" dir="ltr">DROP MATERIALIZED VIEW sales_sum_mv;
</pre><p>This statement drops the materialized view <code class="codeph">sales_sum_mv</code>. If the materialized view was prebuilt on a table, then the table is not dropped, but it can no longer be maintained with the refresh mechanism or used by query rewrite. Alternatively, you can drop a materialized view using Oracle Enterprise Manager.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8218"></a><div class="props_rev_3"><a id="GUID-651B08EB-4D32-4A93-A260-A965C40AE136" name="GUID-651B08EB-4D32-4A93-A260-A965C40AE136"></a><h3 id="DWHSG-GUID-651B08EB-4D32-4A93-A260-A965C40AE136" class="sect3"><span class="enumeration_section">5.10 </span>Analyzing Materialized View Capabilities
               </h3>
               <div>
                  <div class="section">
                     <p>You can use the <code class="codeph">DBMS_MVIEW</code>.<code class="codeph">EXPLAIN_MVIEW</code> procedure to learn what is possible with a materialized view or potential materialized view. In particular, this procedure enables you to determine:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If a materialized view is fast refreshable</p>
                        </li>
                        <li>
                           <p>What types of query rewrite you can perform with this materialized view</p>
                        </li>
                        <li>
                           <p>Whether partition change tracking refresh is possible</p>
                        </li>
                     </ul>
                     <p>Using this procedure is straightforward and described in <span class="q">"<a href="basic-materialized-views.html#GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0">Using the DBMS_MVIEW.EXPLAIN_MVIEW Procedure</a>"</span>. You simply call <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>, passing in as a single parameter the schema and materialized view name for an existing materialized view. Alternatively, you can specify the <code class="codeph">SELECT</code> string for a potential materialized view or the complete <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement. The materialized view or potential materialized view is then analyzed and the results are written into either a table called <code class="codeph">MV_CAPABILITIES_TABLE</code>, which is the default, or to an array called <code class="codeph">MSG_ARRAY</code>.
                     </p>
                     <p>Note that you must run the <code class="codeph">utlxmv.sql</code> script prior to calling <code class="codeph">EXPLAIN_MVIEW</code> except when you are placing the results in <code class="codeph">MSG_ARRAY</code>. The script is found in the <code class="codeph">admin</code> directory. It is to create the <code class="codeph">MV_CAPABILITIES_TABLE</code> in the current schema. An explanation of the various capabilities is in <a href="basic-materialized-views.html#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values of the CAPABILITY_NAME column.">Table 5-6</a>, and all the possible messages are listed in <a href="basic-materialized-views.html#GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409" title="This table describes the semantics of some columns in the MV_CAPABILITIES_TABLE table.">Table 5-7</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8219"></a><div class="props_rev_3"><a id="GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0" name="GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0"></a><h4 id="DWHSG-GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0" class="sect4"><span class="enumeration_section">5.10.1 </span>Using the DBMS_MVIEW.EXPLAIN_MVIEW Procedure
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">EXPLAIN_MVIEW</code> proc<a id="d15276e5296" class="indexterm-anchor"></a>edure has the following parameters:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">stmt_id</code></p>
                              <p>An optional parameter. A client-supplied unique identifier to associate output rows with specific invocations of <code class="codeph">EXPLAIN_MVIEW</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">mv</code></p>
                              <p>The name of an existing materialized view or the query definition or the entire <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement of a potential materialized view you want to analyze.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">msg-array</code></p>
                              <p>The PL/SQL <code class="codeph">VARRAY</code> that receives the output.
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">EXPLAIN_MVIEW</code> analyzes the specified materialized view in terms of its refresh and rewrite capabilities and inserts its results (in the form of multiple rows) into <code class="codeph">MV_CAPABILITIES_TABLE</code> or <code class="codeph">MSG_ARRAY</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-A5620B3E-42C2-48B8-AB24-85C83A6035C0__GUID-99980C82-522E-4E67-83A2-7F421CF3BD62">
                           <p class="notep1">See Also:</p>
                           <p><a href="../arpls/DBMS_MVIEW.html#ARPLS027" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for further information about the <code class="codeph">DBMS_MVIEW</code> package
                           </p>
                        </div>
                        <p>This section contains the following topics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188">DBMS_MVIEW.EXPLAIN_MVIEW Declarations</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B">Using MV_CAPABILITIES_TABLE</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-34046E83-7E73-495D-B071-30033E54C616">MV_CAPABILITIES_TABLE.CAPABILITY_NAME Details</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-382EA476-95A5-4B2C-B708-79849C37DC57">MV_CAPABILITIES_TABLE Column Details</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8220"></a><div class="props_rev_3"><a id="GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188" name="GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188"></a><h5 id="DWHSG-GUID-A3B09707-E5D5-4902-8181-B0D1FB2FC188" class="sect5"><span class="enumeration_section">5.10.1.1 </span>DBMS_MVIEW.EXPLAIN_MVIEW Declarations
                     </h5>
                     <div>
                        <div class="section">
                           <p>The following <a id="d15276e5402" class="indexterm-anchor"></a>PL/SQL declarations that are made for you in the <code class="codeph">DBMS_MVIEW</code> package show the order and data types of these parameters for explaining an existing materialized view and a potential materialized view with output to a table and to a <code class="codeph">VARRAY</code>.
                           </p>
                           <p>Explain an existing or potential materialized view with output to <code class="codeph">MV_CAPABILITIES_TABLE</code>:
                           </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_MVIEW (mv           IN VARCHAR2,
                          stmt_id IN VARCHAR2:= NULL);
</pre><p>Explain an existing or potential materialized view with output to a <code class="codeph">VARRAY</code>:
                           </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_MVIEW (mv          IN VARCHAR2,
                          msg_array   OUT SYS.ExplainMVArrayType);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8222"></a><a id="DWHSG8221"></a><div class="props_rev_3"><a id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B" name="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B"></a><h5 id="DWHSG-GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B" class="sect5"><span class="enumeration_section">5.10.1.2 </span>Using MV_CAPABILITIES_TABLE
                     </h5>
                     <div>
                        <div class="section">
                           <p>One of the simplest ways to use <code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code> is <a id="d15276e5454" class="indexterm-anchor"></a>with the <code class="codeph">MV_CAPABILITIES_TABLE</code>, which has the following structure:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE MV_CAPABILITIES_TABLE 
(STATEMENT_ID      VARCHAR(30),   -- Client-supplied unique statement identifier
 MVOWNER           VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 MVNAME            VARCHAR(30),   -- NULL for SELECT based EXPLAIN_MVIEW
 CAPABILITY_NAME   VARCHAR(30),   -- A descriptive name of the particular
                                  -- capability:
                                  -- REWRITE
                                  --   Can do at least full text match
                                  --   rewrite
                                  -- REWRITE_PARTIAL_TEXT_MATCH
                                  --   Can do at least full and partial
                                  --   text match rewrite
                                  -- REWRITE_GENERAL
                                  --   Can do all forms of rewrite
                                  -- REFRESH
                                  --   Can do at least complete refresh
                                  -- REFRESH_FROM_LOG_AFTER_INSERT
                                  --   Can do fast refresh from an mv log
                                  --   or change capture table at least
                                  --   when update operations are
                                  --   restricted to INSERT
                                  -- REFRESH_FROM_LOG_AFTER_ANY
                                  --   can do fast refresh from an mv log
                                  --   or change capture table after any
                                  --   combination of updates
                                  -- PCT
                                  --   Can do Enhanced Update Tracking on
                                  --   the table named in the RELATED_NAME
                                  --   column.  EUT is needed for fast
                                  --   refresh after partitioned
                                  --   maintenance operations on the table
                                  --   named in the RELATED_NAME column
                                  --   and to do non-stale tolerated
                                  --   rewrite when the mv is partially
                                  --   stale with respect to the table
                                  --   named in the RELATED_NAME column.
                                  --   EUT can also sometimes enable fast
                                  --   refresh of updates to the table
                                  --   named in the RELATED_NAME column
                                  --   when fast refresh from an mv log
                                  --   or change capture table is not
                                  --   possible.
                                  -- See <a href="basic-materialized-views.html#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values of the CAPABILITY_NAME column.">Table 5-6</a>
 POSSIBLE          CHARACTER(1),  -- T = capability is possible
                                  -- F = capability is not possible
 RELATED_TEXT      VARCHAR(2000), -- Owner.table.column, alias name, and so on
                                  -- related to this message. The specific 
                                  -- meaning of this column depends on the 
                                  -- NSGNO column. See the documentation for
                                  -- DBMS_MVIEW.EXPLAIN_MVIEW() for details.
 RELATED_NUM       NUMBER,        -- When there is a numeric value 
                                  -- associated with a row, it goes here.
 MSGNO             INTEGER,       -- When available, QSM message # explaining
                                  -- why disabled or more details when
                                  -- enabled.
 MSGTXT            VARCHAR(2000), -- Text associated with MSGNO.
 SEQ               NUMBER);       -- Useful in ORDER BY clause when 
                                  -- selecting from this table.
</pre><p>You can use the <code class="codeph">utlxmv.sql</code> script found in the <code class="codeph">admin</code> directory to create <code class="codeph">MV_CAPABILITIES_TABLE</code>.
                           </p>
                           <div class="infoboxnotealso" id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B__GUID-D88801AE-16D1-4C06-A2B5-0DA46017B6F8">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="A materialized view that uses the ON STATEMENT refresh mode is automatically refreshed every time a DML operation is performed on any of the materialized views base tables. Oracle Database performs fast refresh for materialized views that are defined using approximate queries.While redefining a table online using the DBMS_REDEFINITION package, you can perform incremental refresh of fast refreshable materialized views that are dependent on the table being redefined.You can use the complete, fast, or PCT refresh methods to refresh a materialized view that is based on a hybrid partitioned table.">Refreshing Materialized Views</a> for further details about partition change tracking
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="advanced-query-rewrite-materialized-views.html#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" title="Query rewrite considers external partitions in a hybrid partitioned table to be of UNKNOWN freshness. Therefore, when a query requests data from one or more external partitions, it can only be rewritten under TRUSTED or STALE_TOLERATED integrity mode.Queries containing SQL functions that return approximate results are automatically rewritten to use a matching materialized view, if these queries can be answered using the materialized view.Queries that contain COUNT(DISTINCT) operations on integer columns can be rewritten to use materialized views that contain bitmap-based functions.">Advanced Query Rewrite for Materialized Views</a> for further details about partition change tracking
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-37A6231A-2751-4EFB-9AF5-E5C60DB6393B__GUID-DD2328B4-1CB9-4F6D-8ADF-5C6424676722">
                           <p class="titleinexample">Example 5-9 DBMS_MVIEW.EXPLAIN_MVIEW</p>
                           <p>First, create the materialized view. Alternatively, you can use <code class="codeph">EXPLAIN_MVIEW</code> on a potential materialized view using its <code class="codeph">SELECT</code> statement or the complete <code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> statement.
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cal_month_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT t.calendar_month_desc,  SUM(s.amount_sold) AS dollars
FROM sales s,  times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre><p>Then, you invoke <code class="codeph">EXPLAIN_MVIEW</code> with the materialized view to explain. You need to use the <code class="codeph">SEQ</code> column in an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause so the rows will display in a logical order. If a capability is not possible, <code class="codeph">N</code> will appear in the <code class="codeph">P</code> column and an explanation in the <code class="codeph">MSGTXT</code> column. If a capability is not possible for multiple reasons, a row is displayed for each reason.
                           </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.EXPLAIN_MVIEW ('SH.CAL_MONTH_SALES_MV');

SELECT capability_name,  possible, SUBSTR(related_text,1,8)
  AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
FROM MV_CAPABILITIES_TABLE
ORDER BY seq;

</pre><pre class="oac_no_warn" dir="ltr">CAPABILITY_NAME                 P    REL_TEXT     MSGTXT
---------------                 -    --------     ------
PCT                             N
REFRESH_COMPLETE                Y
REFRESH_FAST                    N
REWRITE                         Y 
PCT_TABLE                       N    SALES        no partition key or PMARKER in select list  
PCT_TABLE                       N    TIMES        relation is not a partitioned table 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log must have ROWID 
REFRESH_FAST_AFTER_INSERT       N    SH.TIMES     mv log does not have all necessary columns  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have new values  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log must have ROWID  
REFRESH_FAST_AFTER_INSERT       N    SH.SALES     mv log does not have all necessary columns 
REFRESH_FAST_AFTER_ONETAB_DML   N    DOLLARS      SUM(expr) without COUNT(expr) 
REFRESH_FAST_AFTER_ONETAB_DML   N                 see the reason why
                                                  REFRESH_FAST_AFTER_INSERT is disabled
REFRESH_FAST_AFTER_ONETAB_DML   N                 COUNT(*) is not present in the select list 
REFRESH_FAST_AFTER_ONETAB_DML   N                 SUM(expr) without COUNT(expr)
REFRESH_FAST_AFTER_ANY_DML      N                 see the reason why 
                                                  REFRESH_FAST_AFTER_ONETAB_DML is disabled 
REFRESH_FAST_AFTER_ANY_DML      N    SH.TIMES     mv log must have sequence
REFRESH_FAST_AFTER_ANY_DML      N    SH.SALES     mv log must have sequence
REFRESH_PCT                     N                 PCT is not possible on any of the detail
                                                  tables in the materialized view
REWRITE_FULL_TEXT_MATCH         Y      
REWRITE_PARTIAL_TEXT_MATCH      Y  
REWRITE_GENERAL                 Y   
REWRITE_PCT                     N                 PCT is not possible on any detail tables
</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8224"></a><a id="DWHSG8223"></a><div class="props_rev_3"><a id="GUID-34046E83-7E73-495D-B071-30033E54C616" name="GUID-34046E83-7E73-495D-B071-30033E54C616"></a><h5 id="DWHSG-GUID-34046E83-7E73-495D-B071-30033E54C616" class="sect5"><span class="enumeration_section">5.10.1.3 </span>MV_CAPABILITIES_TABLE.CAPABILITY_NAME Details
                     </h5>
                     <div>
                        <div class="section">
                           <p><a href="basic-materialized-views.html#GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360" title="This table describes the values of the CAPABILITY_NAME column.">Table 5-6</a> lists explanations for values in the <code class="codeph">CAPABILITY_NAME</code> column.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformalwide" id="GUID-34046E83-7E73-495D-B071-30033E54C616__G1014360">
                           <p class="titleintable">Table 5-6 CAPABILITY_NAME Column Details</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="CAPABILITY_NAME Column Details" summary="This table describes the values of the CAPABILITY_NAME column." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="21%" id="d15276e5605">CAPABILITY_NAME</th>
                                    <th align="left" valign="bottom" width="79%" id="d15276e5608">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5613" headers="d15276e5605 ">
                                       <p><code class="codeph">PCT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5613 d15276e5608 ">
                                       <p>If this capability is possible, partition change tracking is possible on at least one detail relation. If this capability is not possible, partition change tracking is not possible with any detail relation referenced by the materialized view.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5621" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_COMPLETE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5621 d15276e5608 ">
                                       <p>If this capability is possible, complete refresh of the materialized view is possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5629" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_FAST</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5629 d15276e5608 ">
                                       <p>If this capability is possible, fast refresh is possible at least under certain circumstances.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5637" headers="d15276e5605 ">
                                       <p><code class="codeph">REWRITE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5637 d15276e5608 ">
                                       <p>If this capability is possible, at least full text match query rewrite is possible. If this capability is not possible, no form of query rewrite is possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5645" headers="d15276e5605 ">
                                       <p><code class="codeph">PCT_TABLE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5645 d15276e5608 ">
                                       <p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code class="codeph">FROM</code> list. When possible, partition change tracking (PCT) applies to the partitioned table named in the <code class="codeph">RELATED_TEXT</code> column. 
                                       </p>
                                       <p>PCT is needed to support fast refresh after partition maintenance operations on the table named in the <code class="codeph">RELATED_TEXT</code> column.
                                       </p>
                                       <p>PCT may also support fast refresh with regard to updates to the table named in the <code class="codeph">RELATED_TEXT</code> column when fast refresh from a materialized view log is not possible. 
                                       </p>
                                       <p>PCT is also needed to support query rewrite in the presence of partial staleness of the materialized view with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.
                                       </p>
                                       <p>When disabled, PCT does not apply to the table named in the <code class="codeph">RELATED_TEXT</code> column. In this case, fast refresh is not possible after partition maintenance operations on the table named in the <code class="codeph">RELATED_TEXT</code> column. In addition, PCT-based refresh of updates to the table named in the <code class="codeph">RELATED_TEXT</code> column is not possible. Finally, query rewrite cannot be supported in the presence of partial staleness of the materialized view with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5688" headers="d15276e5605 ">
                                       <p><code class="codeph">PCT_TABLE_REWRITE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5688 d15276e5608 ">
                                       <p>If this capability is possible, it is possible with respect to a particular partitioned table in the top level <code class="codeph">FROM</code> list. When possible, PCT applies to the partitioned table named in the <code class="codeph">RELATED_TEXT</code> column. 
                                       </p>
                                       <p>This capability is needed to support query rewrite against this materialized view in partial stale state with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column.
                                       </p>
                                       <p>When disabled, query rewrite cannot be supported if this materialized view is in partial stale state with regard to the table named in the <code class="codeph">RELATED_TEXT</code> column. 
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5712" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_FAST_AFTER_INSERT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5712 d15276e5608 ">
                                       <p>If this capability is possible, fast refresh from a materialized view log is possible at least in the case where the updates are restricted to <code class="codeph">INSERT</code> operations; complete refresh is also possible. If this capability is not possible, no form of fast refresh from a materialized view log is possible.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5723" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_FAST_AFTER_ONETAB_DML</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5723 d15276e5608 ">
                                       <p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation, provided all update operations are performed on a single table. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations are performed on multiple tables.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5731" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_FAST_AFTER_ANY_DML</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5731 d15276e5608 ">
                                       <p>If this capability is possible, fast refresh from a materialized view log is possible regardless of the type of update operation or the number of tables updated. If this capability is not possible, fast refresh from a materialized view log may not be possible when the update operations (other than <code class="codeph">INSERT</code>) affect multiple tables.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5742" headers="d15276e5605 ">
                                       <p><code class="codeph">REFRESH_FAST_PCT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5742 d15276e5608 ">
                                       <p>If this capability is possible, fast refresh using PCT is possible. Generally, this means that refresh is possible after partition maintenance operations on those detail tables where PCT is indicated as possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5750" headers="d15276e5605 ">
                                       <p><code class="codeph">REWRITE_FULL_TEXT_MATCH</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5750 d15276e5608 ">
                                       <p>If this capability is possible, full text match query rewrite is possible. If this capability is not possible, full text match query rewrite is not possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5759" headers="d15276e5605 ">
                                       <p><code class="codeph">REWRITE_PARTIAL_ TEXT_MATCH</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5759 d15276e5608 ">
                                       <p>If this capability is possible, at least full and partial text match query rewrite are possible. If this capability is not possible, at least partial text match query rewrite and general query rewrite are not possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5767" headers="d15276e5605 ">
                                       <p><code class="codeph">REWRITE_GENERAL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5767 d15276e5608 ">
                                       <p>If this capability is possible, all query rewrite capabilities are possible, including general query rewrite and full and partial text match query rewrite. If this capability is not possible, at least general query rewrite is not possible.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="21%" id="d15276e5775" headers="d15276e5605 ">
                                       <p><code class="codeph">REWRITE_PCT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="79%" headers="d15276e5775 d15276e5608 ">
                                       <p>If this capability is possible, query rewrite can use a partially stale materialized view even in <code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> modes. When this capability is not possible, query rewrite can use a partially stale materialized view only in <code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">STALE_TOLERATED</code> mode.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="DWHSG8226"></a><a id="DWHSG8225"></a><div class="props_rev_3"><a id="GUID-382EA476-95A5-4B2C-B708-79849C37DC57" name="GUID-382EA476-95A5-4B2C-B708-79849C37DC57"></a><h5 id="DWHSG-GUID-382EA476-95A5-4B2C-B708-79849C37DC57" class="sect5"><span class="enumeration_section">5.10.1.4 </span>MV_CAPABILITIES_TABLE Column Details
                     </h5>
                     <div>
                        <div class="section">
                           <p><a href="basic-materialized-views.html#GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409" title="This table describes the semantics of some columns in the MV_CAPABILITIES_TABLE table.">Table 5-7</a> lists the semantics for <code class="codeph">RELATED_TEXT</code> and <code class="codeph">RELATED_NUM</code> columns.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformalwide" id="GUID-382EA476-95A5-4B2C-B708-79849C37DC57__G1014409">
                           <p class="titleintable">Table 5-7 MV_CAPABILITIES_TABLE Column Details</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="MV_CAPABILITIES_TABLE Column Details" summary="This table describes the semantics of some columns in the MV_CAPABILITIES_TABLE table." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="10%" id="d15276e5843">MSGNO</th>
                                    <th align="left" valign="bottom" width="33%" id="d15276e5846">MSGTXT</th>
                                    <th align="left" valign="bottom" width="21%" id="d15276e5849">RELATED_NUM</th>
                                    <th align="left" valign="bottom" width="36%" id="d15276e5852">RELATED_TEXT</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5857" headers="d15276e5843 ">
                                       <p><code class="codeph">NULL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5857 d15276e5846 ">
                                       <p><code class="codeph">NULL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5857 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5857 d15276e5852 ">
                                       <p>For PCT capability only: <code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table upon which PCT is enabled
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5882" headers="d15276e5843 ">
                                       <p>2066</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5882 d15276e5846 ">
                                       <p>This statement resulted in an Oracle error</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5882 d15276e5849 ">
                                       <p>Oracle error number that occurred</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5882 d15276e5852 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5894" headers="d15276e5843 ">
                                       <p>2067</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5894 d15276e5846 ">
                                       <p>No partition key or <code class="codeph">PMARKER</code> or join dependent expression in <code class="codeph">SELECT</code> list
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5894 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5894 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5922" headers="d15276e5843 ">
                                       <p>2068</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5922 d15276e5846 ">
                                       <p>Relation is not partitioned</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5922 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5922 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5944" headers="d15276e5843 ">
                                       <p>2069</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5944 d15276e5846 ">
                                       <p>PCT not supported with multicolumn partition key</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5944 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5944 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5966" headers="d15276e5843 ">
                                       <p>2070</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5966 d15276e5846 ">
                                       <p>PCT not supported with this type of partitioning</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5966 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5966 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e5988" headers="d15276e5843 ">
                                       <p>2071</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e5988 d15276e5846 ">
                                       <p>Internal error: undefined PCT failure code</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e5988 d15276e5849 ">
                                       <p>The unrecognized numeric PCT failure code</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e5988 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not supported
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6011" headers="d15276e5843 ">
                                       <p>2072</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6011 d15276e5846 ">
                                       <p>Requirements not satisfied for fast refresh of nested materialized view</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6011 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6011 d15276e5852 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6022" headers="d15276e5843 ">
                                       <p>2077</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6022 d15276e5846 ">
                                       <p>Materialized view log is newer than last full refresh</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6022 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6022 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6044" headers="d15276e5843 ">
                                       <p>2078</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6044 d15276e5846 ">
                                       <p>Materialized view log must have new values</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6044 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6044 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6066" headers="d15276e5843 ">
                                       <p>2079</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6066 d15276e5846 ">
                                       <p>Materialized view log must have <code class="codeph">ROWID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6066 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6066 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6091" headers="d15276e5843 ">
                                       <p>2080</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6091 d15276e5846 ">
                                       <p>Materialized view log must have primary key</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6091 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6091 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6113" headers="d15276e5843 ">
                                       <p>2081</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6113 d15276e5846 ">
                                       <p>Materialized view log does not have all necessary columns</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6113 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6113 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6135" headers="d15276e5843 ">
                                       <p>2082</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6135 d15276e5846 ">
                                       <p>Problem with materialized view log</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6135 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6135 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">table_name</code></span> of table upon which the materialized view log is needed
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6157" headers="d15276e5843 ">
                                       <p>2099</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6157 d15276e5846 ">
                                       <p>Materialized view references a remote table or view in the <code class="codeph">FROM</code> list
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6157 d15276e5849 ">
                                       <p>Offset from the <code class="codeph">SELECT</code> keyword to the table or view in question
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6157 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table or view in question
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6186" headers="d15276e5843 ">
                                       <p>2126</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6186 d15276e5846 ">
                                       <p>Multiple master sites</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6186 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6186 d15276e5852 ">
                                       <p>Name of the first different node, or <code class="codeph">NULL</code> if the first different node is local
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6201" headers="d15276e5843 ">
                                       <p>2129</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6201 d15276e5846 ">
                                       <p>Join or filter condition(s) are complex</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6201 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6201 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of the table involved with the join or filter condition (or <code class="codeph">NULL</code> when not available)
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6226" headers="d15276e5843 ">
                                       <p>2130</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6226 d15276e5846 ">
                                       <p>Expression not supported for fast refresh</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6226 d15276e5849 ">
                                       <p>Offset from the <code class="codeph">SELECT</code> keyword to the expression in question
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6226 d15276e5852 ">
                                       <p>The alias name in the <code class="codeph">SELECT</code> list of the expression in question
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6245" headers="d15276e5843 ">
                                       <p>2150</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6245 d15276e5846 ">
                                       <p><code class="codeph">SELECT</code> lists must be identical across the <code class="codeph">UNION</code> operator
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6245 d15276e5849 ">
                                       <p>Offset from the <code class="codeph">SELECT</code> keyword to the first different select item in the <code class="codeph">SELECT</code> list
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6245 d15276e5852 ">
                                       <p>The alias name of the first different select item in the <code class="codeph">SELECT</code> list
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6272" headers="d15276e5843 ">
                                       <p>2182</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6272 d15276e5846 ">
                                       <p>PCT is enabled through a join dependency</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6272 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6272 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which <code class="codeph">PCT_TABLE_REWRITE</code> is not enabled
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6297" headers="d15276e5843 ">
                                       <p>2183</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6297 d15276e5846 ">
                                       <p>Expression to enable PCT not in <code class="codeph">PARTITION</code> <code class="codeph">BY</code> of analytic function or model
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6297 d15276e5849 ">
                                       <p>The unrecognized numeric PCT failure code</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6297 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not enabled
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6326" headers="d15276e5843 ">
                                       <p>2184</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6326 d15276e5846 ">
                                       <p>Expression to enable PCT cannot be rolled up</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6326 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6326 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which PCT is not enabled
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6349" headers="d15276e5843 ">
                                       <p>2185</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6349 d15276e5846 ">
                                       <p>No partition key or <code class="codeph">PMARKER</code> in the <code class="codeph">SELECT</code> list
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6349 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6349 d15276e5852 ">
                                       <p><code class="codeph">[</code><span class="italic"><code class="codeph">owner</code></span><code class="codeph">.]</code><span class="italic"><code class="codeph">name</code></span> of relation for which <code class="codeph">PCT_TABLE_REWRITE</code> is not enabled
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6380" headers="d15276e5843 ">
                                       <p>2186</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6380 d15276e5846 ">
                                       <p><code class="codeph">GROUP</code> <code class="codeph">OUTER</code> <code class="codeph">JOIN</code> is present
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6380 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6380 d15276e5852 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d15276e6399" headers="d15276e5843 ">
                                       <p>2187</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d15276e6399 d15276e5846 ">
                                       <p>Materialized view on external table</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d15276e6399 d15276e5849 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d15276e6399 d15276e5852 ">
                                       <p></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>