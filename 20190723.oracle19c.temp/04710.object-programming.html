<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Object Programming</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="oracle-c-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-03-06T02:31:59-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96205-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="accessing-oracle-database-using-cplusplus.html" title="Previous" type="text/html">
      <link rel="next" href="data-types.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle C++ Call Interface Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNCPP">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="accessing-oracle-database-using-cplusplus.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="data-types.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> 	Object Programming </li>
            </ol>
            <a id="GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997" name="GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997"></a><a id="LNCPP004"></a>
            
            <h2 id="LNCPP-GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997" class="sect2"><span class="enumeration_chapter">4 </span> 	Object Programming 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter provides information on how to implement object-relational programming using the Oracle C++ Call Interface (OCCI).</p>
               <p>This chapter contains these topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="object-programming.html#GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A">Overview of Object Programming</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0">About Working with Objects in C++ with OCCI</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9">About Representing Objects in C++ Applications</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF">About Developing a C++ Application using OCCI</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3">Migrating C++ Applications to Oracle Using OCCI</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-2E5F6826-403F-4925-8775-47D6849F555F">Overview of Associative Access</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-08991D90-AD38-4436-9B94-EA5AE02B5869">Overview of Navigational Access</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC">Overview of Complex Object Retrieval</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC">Working with Collections</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-E3D9E110-7335-4E84-9452-7FE689550FB7">About Using Object References</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-C7C82B8B-2056-4692-9BA0-C123902C6268">About Deleting Objects from the Database</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-43D835F1-F7E4-4EA5-8F32-F50393162132">About Type Inheritance</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598">A Sample OCCI Application</a></p>
                  </li>
               </ul>
            </div><a id="LNCPP20143"></a><div class="props_rev_3"><a id="GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A" name="GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A"></a><h3 id="LNCPP-GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A" class="sect3"><span class="enumeration_section">4.1 </span>Overview of Object Programming
               </h3>
               <div>
                  <p>OCCI supports both the associative and navigational style of data access. Traditionally, third-generation language (3GL) programs manipulate data stored in a database by using the <span class="bold">associative access</span> based on the associations organized by relational database tables. In associative access, data is manipulated by executing SQL statements and PL/SQL procedures. OCCI supports associative access to objects by enabling your applications to execute SQL statements and PL/SQL procedures on the database server without incurring the cost of transporting data to the client. 
                  </p>
                  <p>Object-oriented programs that use OCCI can also make use of <span class="bold">navigational access</span> that is a key aspect of this programming paradigm. Object relationships between objects are implemented as references (<code class="codeph">REF</code>s). Typically, an object application that uses navigational access first retrieves one or more objects from the database server by issuing a SQL statement that returns <code class="codeph">REF</code>s to those objects. The application then uses those <code class="codeph">REF</code>s to traverse related objects, and perform computations on these other objects as required. Navigational access does not involve executing SQL statements, except to fetch the references of an initial set of objects. By using the OCCI APIs for navigational access, your application can perform the following functions on Oracle objects: 
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Creating, accessing, locking, deleting, copying and flushing objects</p>
                     </li>
                     <li>
                        <p>Getting references to objects and navigating through the references</p>
                     </li>
                  </ul>
                  <p>This chapter gives examples that show you how to create a persistent object, access an object, modify an object, and flush the changes to the database server. It discusses how to access the object using both navigational and associative approaches.</p>
               </div>
            </div><a id="LNCPP20144"></a><div class="props_rev_3"><a id="GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0" name="GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0"></a><h3 id="LNCPP-GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0" class="sect3"><span class="enumeration_section">4.2 </span>About Working with Objects in C++ with OCCI
               </h3>
               <div>
                  <p>Many of the programming principles that govern a relational OCCI applications are identical for object-relational applications. An object-relational application uses the standard OCCI calls to establish database connections and process SQL statements. The difference is that the SQL statements that are issued retrieve object references, which can then be manipulated with OCCI object functions. An object can also be directly manipulated as a value (without using its object reference).</p>
                  <p>Instances of an Oracle type are categorized into <span class="bold">persistent objects</span> and <span class="bold">transient objects</span> based on their lifetime. Instances of persistent objects can be further divided into<span class="bold"> standalone objects</span> and <span class="bold">embedded objects</span> depending on whether they are referenced by way of an object identifier.
                  </p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D">About Persistent Objects</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5">About Transient Objects</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-16789D51-136F-45D7-AABE-A59B0765C78B">About Values</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20146"></a><a id="LNCPP20147"></a><a id="LNCPP20145"></a><div class="props_rev_3"><a id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D" name="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D"></a><h4 id="LNCPP-GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D" class="sect4"><span class="enumeration_section">4.2.1 </span>About Persistent Objects
                  </h4>
                  <div>
                     <p>A <span class="bold">persistent object</span> is an object which is stored in an Oracle database. It may be fetched into the object cache and modified by an OCCI application. The lifetime of a persistent object can exceed that of the application which is accessing it. There are two types of persistent objects:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A <span class="bold">standalone instance</span> is stored in a database table row, and has a unique object identifier. An OCCI application can retrieve a reference to a standalone object, pin the object, and navigate from the pinned object to other related objects. Standalone objects may also be referred to as <span class="bold">referenceable objects</span>.
                           </p>
                           <p>It is also possible to select a persistent object, in which case you fetch the object<span class="italic"> by value</span> instead of fetching it by reference.
                           </p>
                        </li>
                        <li>
                           <p>An <span class="bold">embedded instance</span> is not stored in a database table row, but rather is embedded within another object. Examples of embedded objects are objects which are attributes of another object, or objects that exist in an object column of a database table. Embedded objects do not have object identifiers, and OCCI applications cannot get <code class="codeph">REF</code>s to embedded instances.
                           </p>
                           <p>Embedded objects may also be referred to as <span class="bold">nonreferenceable objects</span> or<span class="bold"> value instances</span>. You may sometimes see them referred to as <span class="bold">values</span>, which is not to be confused with scalar data values. The context should make the meaning clear.
                           </p>
                        </li>
                     </ul>
                     <p>Users do not have to explicitly delete persistent objects that have been materialized through references.</p>
                     <p>Users should delete persistent objects created by application when the transactions are rolled back</p>
                     <p>The SQL examples, <a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEICJAAH">Example 4-1</a> and <a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEIIABGC">Example 4-2</a>, demonstrate the difference between these two types of persistent objects.
                     </p>
                     <div class="example" id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEICJAAH">
                        <p class="titleinexample">Example 4-1 Creating Standalone Objects</p>
                        <p>Objects that are stored in the object table <code class="codeph">person_tab</code> are standalone objects. They have object identifiers and can be referenced. They can be pinned in an OCCI application.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_t AS OBJECT
&nbsp;&nbsp;&nbsp;(name      varchar2(30),
&nbsp;&nbsp;&nbsp;&nbsp;age       number(3));
CREATE TABLE person_tab OF person_t;
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEIIABGC">
                        <p class="titleinexample">Example 4-2 Creating Embedded Objects</p>
                        <p>Objects which are stored in the <code class="codeph">manager</code> column of the <code class="codeph">department</code> table are embedded objects. They do not have object identifiers, and they cannot be referenced. Therefore, they cannot be pinned in an OCCI application, and they also never have to be unpinned. They are always retrieved into the object cache <span class="italic">by value</span>.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE department
&nbsp;&nbsp;&nbsp;(deptno     number,
&nbsp;&nbsp;&nbsp;&nbsp;deptname   varchar2(30),
&nbsp;&nbsp;&nbsp;&nbsp;manager    person_t);
</pre><p>The Array Pin feature allows a vector of references to be dereferenced in one round-trip to return a vector of the corresponding objects. A new global method, <code class="codeph">pinVectorOfRefs()</code>, takes a vector of <code class="codeph">Ref</code>s and populates a vector of <code class="codeph">PObject</code>s in a single round-trip, saving the cost of pinning <code class="codeph">n-1</code> references in <code class="codeph">n-1</code> round-trips.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20149"></a><a id="LNCPP20150"></a><a id="LNCPP20151"></a><a id="LNCPP20148"></a><div class="props_rev_3"><a id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5" name="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5"></a><h4 id="LNCPP-GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5" class="sect4"><span class="enumeration_section">4.2.2 </span>About Transient Objects
                  </h4>
                  <div>
                     <p>A transient object is an instance of an object type. Its lifetime cannot exceed that of the application. The application can also delete a transient object at any time.</p>
                     <p>The Object Type Translator (OTT) utility generates two <code class="codeph">operator new</code> methods for each C++ class, as demonstrated in <a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">Example 4-3</a><a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">Example 4-3</a>:
                     </p>
                     <p><a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEICGCBD">Example 4-4</a> demonstrates how to dynamically create a transient object. Transient objects cannot be converted to persistent objects. Their role is fixed at the time they are instantiated, and it is your responsibility to free memory by deleting transient objects.
                     </p>
                     <p>A transient object can also be created on the stack as a local variable, as demonstrated in <a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIGDIHD">Example 4-5</a>. The latter approach guarantees that the transient object is destroyed when the scope of the variable ends.
                     </p>
                     <div class="infoboxnotealso" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__GUID-C495804E-9A59-441E-A144-B6E0E7C51204">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT88817" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>for more information about objects
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">
                        <p class="titleinexample">Example 4-3 Two Methods for Operator new() in the Object Type Translator Utility</p><pre class="oac_no_warn" dir="ltr">class Person : public PObject {
&nbsp;&nbsp;&nbsp;...
public:
&nbsp;&nbsp;&nbsp;dvoid *operator new(size_t size);    // creates transient instance
&nbsp;&nbsp;&nbsp;dvoid *operator new(size_t size, Connection &amp;conn, string table);
                                        // creates persistent instance
}
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEICGCBD">
                        <p class="titleinexample">Example 4-4 How to Dynamically Create a Transient Object</p><pre class="oac_no_warn" dir="ltr">Person *p = new Person();
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIGDIHD">
                        <p class="titleinexample">Example 4-5 How to Create a Transient Object as a Local Variable</p><pre class="oac_no_warn" dir="ltr">Person p;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20152"></a><div class="props_rev_3"><a id="GUID-16789D51-136F-45D7-AABE-A59B0765C78B" name="GUID-16789D51-136F-45D7-AABE-A59B0765C78B"></a><h4 id="LNCPP-GUID-16789D51-136F-45D7-AABE-A59B0765C78B" class="sect4"><span class="enumeration_section">4.2.3 </span>About Values
                  </h4>
                  <div>
                     <p>In this manual, a<span class="bold"> value</span> refers to either:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A scalar value which is stored in a non-object column of a database table. An OCCI application can fetch values from a database by issuing SQL statements.</p>
                        </li>
                        <li>
                           <p>An embedded (nonreferenceable) object.</p>
                        </li>
                     </ul>
                     <p>The context should make it clear which meaning is intended.</p>
                     <p>It is possible to <code class="codeph">SELECT</code> a referenceable object into the object cache, rather than pinning it, in which case you fetch the object <span class="italic">by value</span> instead of fetching it by reference.
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20153"></a><div class="props_rev_3"><a id="GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9" name="GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9"></a><h3 id="LNCPP-GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9" class="sect3"><span class="enumeration_section">4.3 </span>About Representing Objects in C++ Applications
               </h3>
               <div>
                  <p>Before an OCCI application can work with object types, those types must exist in the database. Typically, you create types with SQL DDL statements, such as <code class="codeph">CREATE</code> <code class="codeph">TYPE</code>.
                  </p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6">Creating Persistent and Transient Objects</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718">Creating Object Representations using the OTT Utility</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20155"></a><a id="LNCPP20156"></a><a id="LNCPP20154"></a><div class="props_rev_3"><a id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6" name="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6"></a><h4 id="LNCPP-GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6" class="sect4"><span class="enumeration_section">4.3.1 </span>Creating Persistent and Transient Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section discusses how persistent and transient objects are created.</p>
                        <p>Before you create a persistent object, you must have created the environment and opened a connection.</p>
                        <p>A persistent object is created in the database only when one of the following occurs:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The transaction is committed (<code class="codeph">Connection::commit()</code>)
                              </p>
                           </li>
                           <li>
                              <p>The object cache is flushed (<code class="codeph">Connection::flushCache()</code>)
                              </p>
                           </li>
                           <li>
                              <p>The object itself is flushed (<code class="codeph">PObject::flush()</code>)
                              </p>
                           </li>
                        </ul>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIJIHDH">Example 4-6</a> shows how to create a persistent object, <code class="codeph">addr</code>, in the database table, <code class="codeph">addr_tab</code>.
                        </p>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIFGGJJ">Example 4-7</a> shows hot to create an instance of the transient object <code class="codeph">ADDRESS</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIJIHDH">
                        <p class="titleinexample">Example 4-6 How to Create a Persistent Object</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE ADDRESS AS OBJECT (
&nbsp;&nbsp;&nbsp;state CHAR(2), 
&nbsp;&nbsp;&nbsp;zip_code CHAR(5));
CREATE TABLE ADDR_TAB of ADDRESS;
ADDRESS *addr = new(conn, "ADDR_TAB") ADDRESS("CA", "94065");
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIFGGJJ">
                        <p class="titleinexample">Example 4-7 How to Create a Transient Object</p><pre class="oac_no_warn" dir="ltr">ADDRESS *addr_trans = new ADDRESS("MD", "94111");</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP21904"></a><a id="LNCPP20157"></a><div class="props_rev_3"><a id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718" name="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718"></a><h4 id="LNCPP-GUID-429F4D92-51D7-47F0-B637-D9F103CFE718" class="sect4"><span class="enumeration_section">4.3.2 </span>Creating Object Representations using the OTT Utility
                  </h4>
                  <div>
                     <div class="section">
                        <p>When your C++ application retrieves instances of object types from the database, it must have a client-side representation of the objects. The Object Type Translator (OTT) utility generates C++ class representations of database object types for you. <a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">Example 4-8</a> shows the declaration of a custom type in the database, and the corresponding C++ class that the OTT utility generates.
                        </p>
                        <p>These class declarations in <a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">Example 4-8</a> are automatically written by OTT to a header file that you name. This header file is included in the source files for an application to provide access to objects. Instances of a <code class="codeph">PObject</code> (and also instances of classes derived from <code class="codeph">PObject</code>s) can be either transient or persistent. The methods <code class="codeph">writeSQL()</code> and <code class="codeph">readSQL()</code> are used internally by the OCCI object cache to linearize and delinearize the objects and are not to be used or modified by OCCI clients.
                        </p>
                        <div class="infoboxnotealso" id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__GUID-7B44A730-E0A0-4366-B310-680B42BBF38B">
                           <p class="notep1">See Also:</p>
                           <p><a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">Object Type Translator Utility</a> for more information about the OTT utility
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">
                        <p class="titleinexample">Example 4-8 How to Declare a Custom Type in the Database</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE address AS OBJECT (state CHAR(2), zip_code CHAR(5));
</pre><p>The OTT utility produces the following C++ class:</p><pre class="oac_no_warn" dir="ltr">class ADDRESS : public PObject {

&nbsp;&nbsp;&nbsp;protected:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string state;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string zip;

&nbsp;&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Connection* conn, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const string&amp; table);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string  getSQLTypeName() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen, void **typeName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADDRESS(void *ctx) : PObject(ctx) { };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void *readSQL(void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void readSQL(AnyData&amp; stream);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void writeSQL(void *obj, void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20158"></a><div class="props_rev_3"><a id="GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF" name="GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF"></a><h3 id="LNCPP-GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF" class="sect3"><span class="enumeration_section">4.4 </span>About Developing a C++ Application using OCCI
               </h3>
               <div>
                  <p>This section discusses the steps involved in developing a basic OCCI object application.</p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-5DF13983-6CDD-401A-8175-6E735288DEC6">Developing Basic Object Program Structure</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE">About Basic Object Operational Flow</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20159"></a><div class="props_rev_3"><a id="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6" name="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6"></a><h4 id="LNCPP-GUID-5DF13983-6CDD-401A-8175-6E735288DEC6" class="sect4"><span class="enumeration_section">4.4.1 </span>Developing Basic Object Program Structure
                  </h4>
                  <div>
                     <div class="section">
                        <p>The basic structure of an OCCI application that uses objects is similar to a relational OCCI application, the difference being object functionality. The steps involved in an OCCI object program include:</p>
                        <ol>
                           <li>
                              <p>Initialize the <code class="codeph">Environment</code>. Initialize the OCCI programming environment in object mode. Your application must include C++ class representations of database objects in a header file. You can create these classes by using the Object Type Translator (OTT) utility, as described in <a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">Object Type Translator Utility</a>.
                              </p>
                           </li>
                           <li>
                              <p>Establish a Connection. Use the environment handle to establish a connection to the database server.</p>
                           </li>
                           <li>
                              <p>Prepare a SQL statement. This is a local (client-side) step, which may include binding placeholders. In an object-relational application, this SQL statement should return a reference (<code class="codeph">REF</code>) to an object.
                              </p>
                           </li>
                           <li>
                              <p>Access the object.</p>
                              <ol type="a">
                                 <li>
                                    <p>Associate the prepared statement with a database server, and execute the statement.</p>
                                 </li>
                                 <li>
                                    <p>By using navigational access, retrieve an object reference (<code class="codeph">REF</code>) from the database server and pin the object. You can then perform some or all of the following:
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Manipulate the attributes of an object and mark it as <span class="bold">dirty</span> (modified)
                                          </p>
                                       </li>
                                       <li>
                                          <p>Follow a reference to another object or series of objects</p>
                                       </li>
                                       <li>
                                          <p>Access type and attribute information</p>
                                       </li>
                                       <li>
                                          <p>Navigate a complex object retrieval graph</p>
                                       </li>
                                       <li>
                                          <p>Flush modified objects to the database server</p>
                                       </li>
                                    </ul>
                                 </li>
                                 <li>
                                    <p>By using associative access, you can fetch an entire object <span class="italic">by value </span>by using SQL. Alternately, you can select an embedded (nonreferenceable) object. You can then perform some or all of the following:
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Insert values into a table</p>
                                       </li>
                                       <li>
                                          <p>Modify existing values</p>
                                       </li>
                                    </ul>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>Commit the transaction. This step implicitly writes all modified objects to the database server and commits the changes.</p>
                           </li>
                           <li>
                              <p>Free statements and handles; the prepared statements should not be used or executed again.</p>
                              <div class="infoboxnotealso" id="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6__GUID-D4A12C80-CC9E-4CE9-8AE8-827F78948C5C">
                                 <p class="notep1">See Also:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3BE057FD-2205-4009-9710-FFDC601F438B">Accessing Oracle Database Using C++</a> for information about using OCCI to connect to a database server, process SQL statements, and allocate handles
                                       </p>
                                    </li>
                                    <li>
                                       <p><a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">Object Type Translator Utility</a> for information about the OTT utility
                                       </p>
                                    </li>
                                    <li>
                                       <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI Application Programming Interface</a> for descriptions of OCCI relational functions and the <code class="codeph">Connect</code> class and the <code class="codeph">getMetaData()</code> method 
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20161"></a><a id="LNCPP20160"></a><div class="props_rev_3"><a id="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE" name="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE"></a><h4 id="LNCPP-GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE" class="sect4"><span class="enumeration_section">4.4.2 </span>About Basic Object Operational Flow
                  </h4>
                  <div>
                     <p>Figure&nbsp;4-1 shows a simple program logic flow for how an application might work with objects. For simplicity, some required steps are omitted.</p>
                     <div class="figure" id="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE__GUID-6152359D-EBA9-46FF-B347-2DF11EEB4971">
                        <p class="titleinfigure">Figure 4-1 Basic Object Operational Flow</p><img src="img/object_operational_flow.gif" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows" longdesc="img_text/object_operational_flow.html"><br><a href="img_text/object_operational_flow.html">Description of "Figure 4-1 Basic Object Operational Flow"</a></div>
                     <!-- class="figure" -->
                     <div class="p">The steps shown in Figure&nbsp;4-1 are discussed in the following sections:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="object-programming.html#GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0">About Initializing OCCI in Object Mode</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2">About Pinning anObject</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7">About Operating on an Object in Cache</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65">About Flushing Changes to the Object</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677">About Deletion of an Object</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20162"></a><div class="props_rev_3"><a id="GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0" name="GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0"></a><h5 id="LNCPP-GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0" class="sect5"><span class="enumeration_section">4.4.2.1 </span>About Initializing OCCI in Object Mode
                     </h5>
                     <div>
                        <p>If your OCCI application accesses and manipulates objects, then it is essential that you specify a value of <code class="codeph">OBJECT</code> for the <code class="codeph">mode</code> parameter of the <code class="codeph">createEnvironment()</code> method, the first call in any OCCI application. Specifying this value for <code class="codeph">mode</code> indicates to OCCI that your application works with objects. This notification has the following important effects:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The object run-time environment is established.</p>
                           </li>
                           <li>
                              <p>The object cache is set up.</p>
                           </li>
                        </ul>
                        <p>Note that ithe <code class="codeph">mode</code> parameter is not set to <code class="codeph">OBJECT</code>, any attempt to use an object-related function results in an error.
                        </p>
                        <p>The following code example demonstrates how to specify the <code class="codeph">OBJECT</code> <code class="codeph">mode</code> when creating an OCCI environment:
                        </p><pre class="oac_no_warn" dir="ltr">Environment *env;
Connection *con;
Statement *stmt;

env = Environment::createEnvironment(Environment::OBJECT);
con = Connection(userName, password, connectString);
</pre><p>Your application does not have to allocate memory when database objects are loaded into the object cache. The object cache provides transparent and efficient memory management for database objects. When database objects are loaded into the object cache, they are transparently mapped into the host language (C++) representation. </p>
                        <p>The object cache<a id="d18836e1526" class="indexterm-anchor"></a> maintains the association between the object copy in the object cache and the corresponding database object. Upon <code class="codeph">commit</code>, changes made to the object copy in the object cache are automatically propagated back to the database.
                        </p>
                        <p>The object cache maintains a look-up table for mapping references to objects. When an application dereferences a reference to an object and the corresponding object is not yet cached in the object cache, the object cache automatically sends a request to the database server to fetch the object from the database and load it into the object cache. Subsequent dereferences of the same reference are faster since they are to the object cache itself and do not incur a round-trip to the database server.</p>
                        <p>Subsequent dereferences of the same reference fetch from the cache instead of requiring a round-trip. The exception to this is in a dereferencing operation that occurs just after a commit. In this case, the latest object copy from the server is returned. This ensures that the latest object from the database is cached after each transaction. </p>
                        <p>The object cache maintains a pin count for each persistent object in the object cache. When an application dereferences a reference to an object, the pin count of the object is incremented. The subsequent dereferencing of the same reference to the object does not change the pin count. Until the reference to the object goes out of scope, the object continues to be pinned in the object cache and be accessible by the OCCI client.</p>
                        <p>The pin count functions as a reference count for the object. The pin count of the object becomes zero (<code class="codeph">0</code>) only when there are no more references referring to this object, during which time the object becomes eligible for garbage collection. The object cache uses a least recently used algorithm to manage the size of the object cache. This algorithm frees objects with a pin count of 0 when the object cache reaches the maximum size.
                        </p>
                     </div>
                  </div><a id="LNCPP20163"></a><div class="props_rev_3"><a id="GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2" name="GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2"></a><h5 id="LNCPP-GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2" class="sect5"><span class="enumeration_section">4.4.2.2 </span>About Pinning anObject
                     </h5>
                     <div>
                        <p>In most situations, OCCI users do not have to explicitly pin or unpin the objects because the object cache automatically keeps track of the pin counts of all the objects in the cache. As explained earlier, the object cache increments the pin count when a reference points to the object and decrements it when the reference goes out of scope or no longer points to the object.</p>
                        <p>But there is one exception. If an OCCI application uses <code class="codeph">Ref&lt;T&gt;::ptr()</code> method to get a pointer to the object, then the <code class="codeph">pin</code> and <code class="codeph">unpin</code> methods of the <code class="codeph">PObject</code> class can be used by the application to control pinning and unpinning of the objects in the object cache. 
                        </p>
                     </div>
                  </div><a id="LNCPP20164"></a><div class="props_rev_3"><a id="GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7" name="GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7"></a><h5 id="LNCPP-GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7" class="sect5"><span class="enumeration_section">4.4.2.3 </span>About Operating on an Object in Cache 
                     </h5>
                     <div>
                        <p>Note that the object cache does not manage the contents of object copies; it does not automatically refresh object copies. Your application must ensure the validity and consistency of object copies. </p>
                     </div>
                  </div><a id="LNCPP20165"></a><div class="props_rev_3"><a id="GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65" name="GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65"></a><h5 id="LNCPP-GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65" class="sect5"><span class="enumeration_section">4.4.2.4 </span>About Flushing Changes to the Object
                     </h5>
                     <div>
                        <p>Whenever changes are made to object copies in the object cache, your application is responsible for flushing the changed object to the database.</p>
                        <p>Memory for the object cache is allocated on demand when objects are loaded into the object cache. </p>
                        <p>The client-side object cache is allocated in the program's process space. This object cache is the memory for objects that have been retrieved from the database server and are available to your application.</p>
                        <p>If you initialize the OCCI environment in object mode, your application allocates memory for the object cache, whether the application actually uses object calls.</p>
                        <p>There is only one object cache allocated for each OCCI environment. All objects retrieved or created through different connections within the environment use the same physical object cache. Each connection has its own logical object cache.</p>
                     </div>
                  </div><a id="LNCPP20166"></a><div class="props_rev_3"><a id="GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677" name="GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677"></a><h5 id="LNCPP-GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677" class="sect5"><span class="enumeration_section">4.4.2.5 </span>About Deletion of an Object
                     </h5>
                     <div>
                        <p>For objects retrieved into the cache by dereferencing a reference, you should not perform an explicit delete. For such objects, the pin count is incremented when a reference is dereferenced for the first time and decremented when the reference goes out of scope. When the pin count of the object becomes <code class="codeph">0</code>, indicating that all references to that object are out of scope, the object is automatically eligible for garbage collection and subsequently deleted from the cache. 
                        </p>
                        <p>For persistent objects that have been created by calling the <code class="codeph">new</code> operator, you must call a <code class="codeph">delete</code> if you do not commit the transaction. Otherwise, the object is garbage collected after the commit. This is because when such an object is created using <code class="codeph">new</code>, its pin count is initially <code class="codeph">0</code>. However, because the object is dirty it remains in the cache. After a commit, it is no longer dirty and thus garbage collected. Therefore, a delete is not required. 
                        </p>
                        <p>If a commit is not performed, then you must explicitly call <code class="codeph">delete</code> to destroy that object. You can do this if there are no references to that object. For transient objects, you must delete explicitly to destroy the object. 
                        </p>
                        <p>You should not call a delete operator on a persistent object. A persistent object that is not marked/dirty is freed by the garbage collector when its pin count is 0. However, for transient objects you must delete explicitly to destroy the object. </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP20167"></a><div class="props_rev_3"><a id="GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3" name="GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3"></a><h3 id="LNCPP-GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3" class="sect3"><span class="enumeration_section">4.5 </span>Migrating C++ Applications to Oracle Using OCCI
               </h3>
               <div>
                  <div class="section">
                     <p>This section describes how to migrate existing C++ applications using OCCI.</p>
                     <p>The steps of migration are:</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>Determine object model and class hierarchy</span></li>
                     <li><span>Use JDeveloper9<span class="italic">i</span> to map to Oracle object schema</span></li>
                     <li><span>Generate C++ header files using Oracle Type Translator</span></li>
                     <li><span>Modify old C++ access classes as required to work with new object type definitions</span></li>
                     <li><span>Add functionality for transient and persistent object management, as required.</span></li>
                  </ol>
               </div>
            </div><a id="LNCPP20169"></a><div class="props_rev_3"><a id="GUID-2E5F6826-403F-4925-8775-47D6849F555F" name="GUID-2E5F6826-403F-4925-8775-47D6849F555F"></a><h3 id="LNCPP-GUID-2E5F6826-403F-4925-8775-47D6849F555F" class="sect3"><span class="enumeration_section">4.6 </span>Overview of Associative Access
               </h3>
               <div>
                  <p>You can employ SQL within OCCI to retrieve objects, and to perform DML operations.</p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-91E34FB9-8769-415E-9221-B281F0F08D09">Using SQL to Access Objects</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5">Inserting and Modifying Values</a></p>
                        <div class="infoboxnotealso" id="GUID-2E5F6826-403F-4925-8775-47D6849F555F__GUID-C414457E-E810-4345-9364-C717EF10562C">
                           <p class="notep1">See Also:</p>
                           <p>Complete code listing of the demonstration programs</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20170"></a><div class="props_rev_3"><a id="GUID-91E34FB9-8769-415E-9221-B281F0F08D09" name="GUID-91E34FB9-8769-415E-9221-B281F0F08D09"></a><h4 id="LNCPP-GUID-91E34FB9-8769-415E-9221-B281F0F08D09" class="sect4"><span class="enumeration_section">4.6.1 </span>Using SQL to Access Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>In the previous sections we discussed navigational access, where SQL is used only to fetch the references of an initial set of objects and then navigate from them to the other objects. Here we discuss how to fetch the objects using SQL.</p>
                        <p>The following example shows how to use the <code class="codeph">ResultSet::getObject()</code> method to fetch objects through associative access where it gets each object from the table, <code class="codeph">addr_tab</code>, using SQL:
                        </p><pre class="oac_no_warn" dir="ltr">string sel_addr_val = "SELECT VALUE(address) FROM ADDR_TAB address";

ResultSet *rs = stmt-&gt;executeQuery(sel_addr_val);

while (rs-&gt;next())
{
&nbsp;&nbsp;&nbsp;ADDRESS *addr_val = rs-&gt;getObject(1); 
&nbsp;&nbsp;&nbsp;cout &lt;&lt; "state: " &lt;&lt; addr_val-&gt;getState();
}
</pre><p>The objects fetched through associative access are termed value instances and they behave just like transient objects. Methods such as <code class="codeph">markModified()</code>, <code class="codeph">flush()</code>, and <code class="codeph">markDeleted()</code> are applicable only for persistent objects.
                        </p>
                        <p>Any changes made to these objects are not reflected in the database.</p>
                        <p>Since the object returned is a value instance, it is the user's responsibility to free memory by deleting the object pointer.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20171"></a><div class="props_rev_3"><a id="GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5" name="GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5"></a><h4 id="LNCPP-GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5" class="sect4"><span class="enumeration_section">4.6.2 </span>Inserting and Modifying Values
                  </h4>
                  <div>
                     <div class="section">
                        <p>We have just seen how to use SQL to access objects. OCCI also provides the ability to use SQL to insert new objects or modify existing objects in the database server through the <code class="codeph">Statement::setObject</code> method interface.
                        </p>
                        <p><a id="d18836e2222" class="indexterm-anchor"></a>The following example creates a transient object <code class="codeph">Address</code> and inserts it into the database table <code class="codeph">addr_tab</code>:
                        </p><pre class="oac_no_warn" dir="ltr">ADDRESS *addr_val = new address("NV", "12563");  // new a transient instance
stmt-&gt;setSQL("INSERT INTO ADDR_TAB values(:1)");
stmt-&gt;setObject(1, addr_val);
stmt-&gt;execute();</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNCPP20172"></a><div class="props_rev_3"><a id="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869" name="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869"></a><h3 id="LNCPP-GUID-08991D90-AD38-4436-9B94-EA5AE02B5869" class="sect3"><span class="enumeration_section">4.7 </span>Overview of Navigational Access
               </h3>
               <div>
                  <p>By using navigational access, you engage in a series of operations.</p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-F6B35295-FF36-492B-BE81-ED363471303C">Retrieving an Object Reference (REF) from the Database Server</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259">Pinning an Object</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5">Manipulating Object Attributes</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96">About Marking Objects and Flushing Changes</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-452627F0-6A11-4141-9271-B1F813131E3A">Marking an Object as Modified (Dirty)</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477">About Recording Changes in the Database</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-9ED70097-5409-4E0C-905F-F8404C724690">Collecting Garbage in the Object Cache</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-85D81D09-85AF-4072-92F5-97E7CF194B52">About Ensuring Transactional Consistency of References</a></p>
                        <div class="infoboxnotealso" id="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869__GUID-FDADB1F8-6A1E-44FB-9452-A500318F085F">
                           <p class="notep1">See Also:</p>
                           <p>Complete code listing of the demonstration programs</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20173"></a><div class="props_rev_3"><a id="GUID-F6B35295-FF36-492B-BE81-ED363471303C" name="GUID-F6B35295-FF36-492B-BE81-ED363471303C"></a><h4 id="LNCPP-GUID-F6B35295-FF36-492B-BE81-ED363471303C" class="sect4"><span class="enumeration_section">4.7.1 </span>Retrieving an Object Reference (REF) from the Database Server 
                  </h4>
                  <div>
                     <div class="section">
                        <p>To work with objects, your application must first retrieve one or more objects from the database server. You accomplish this by issuing a SQL statement that returns references (<code class="codeph">REF</code>s) to one or more objects.
                        </p>
                        <p>It is also possible for a SQL statement to fetch value instances, rather than <code class="codeph">REF</code>s, from a database.
                        </p>
                        <p>The following SQL statement retrieves a <code class="codeph">REF</code> to a single object <code class="codeph">address</code> from the database table <code class="codeph">addr_tab</code>:
                        </p><pre class="oac_no_warn" dir="ltr">string sel_addr = "SELECT REF(address) 
&nbsp;&nbsp;&nbsp;FROM addr_tab address 
&nbsp;&nbsp;&nbsp;WHERE zip_code = '94065'";
</pre><p>The following code example illustrates how to execute the query and fetch the <code class="codeph">REF</code> from the result set.
                        </p><pre class="oac_no_warn" dir="ltr">ResultSet *rs = stmt-&gt;executeQuery(sel_addr);
rs-&gt;next();
Ref&lt;address&gt; addr_ref = rs-&gt;getRef(1);
</pre><p>At this point, you could use the object reference to access and manipulate the object or objects from the database.</p>
                        <div class="infoboxnotealso" id="GUID-F6B35295-FF36-492B-BE81-ED363471303C__GUID-6118A903-900D-4CC5-B606-591F473B0D94">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="accessing-oracle-database-using-cplusplus.html#GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B">About Executing SQL DDL and DML Statements</a>"</span> for general information about preparing and executing SQL statements
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20174"></a><div class="props_rev_3"><a id="GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259" name="GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259"></a><h4 id="LNCPP-GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259" class="sect4"><span class="enumeration_section">4.7.2 </span>Pinning an Object
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section deals with a simple pin operation involving a single object at a time. For information about retrieving multiple objects through complex object retrieval, see the section <a href="object-programming.html#GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC">Overview of Complex Object Retrieval</a>.
                        </p>
                        <p>Upon completion of the fetch step, your application has a <code class="codeph">REF</code> to an object. The actual object is not currently available to work with. Before you can manipulate an object, it must be <span class="bold">pinned</span>. Pinning an object loads the object into the object cache, and enables you to access and modify the object's attributes and follow references from that object to other objects. Your application also controls when modified objects are written back to the database server.
                        </p>
                        <p>OCCI requires only that you dereference the <code class="codeph">REF</code> in the same way you would dereference any C++ pointer. Dereferencing the <code class="codeph">REF</code> transparently materializes the object as a C++ class instance.
                        </p>
                        <p>Continuing the <code class="codeph">Address</code> class example from the previous section, assume that the user has added the following method:
                        </p><pre class="oac_no_warn" dir="ltr">string  Address::getState()
{
&nbsp;&nbsp;&nbsp;return state;
}
</pre><p>To dereference this <code class="codeph">REF</code> and access the object's attributes and methods:
                        </p><pre class="oac_no_warn" dir="ltr">string state = addr_ref-&gt;getState();     // -&gt; pins the object</pre><p>The first time<code class="codeph"> Ref&lt;T&gt;</code> <code class="codeph">(addr_ref)</code> is dereferenced, the object is pinned, which is to say that it is loaded into the object cache from the database server. From then on, the behavior of operator<code class="codeph"> -&gt;</code> on <code class="codeph">Ref&lt;T&gt;</code> is just like that of any C++ pointer<code class="codeph"> (T *)</code>. The object remains in the object cache until the <code class="codeph">REF</code> <code class="codeph">(addr_ref)</code> goes out of scope. It then becomes eligible for garbage collection.
                        </p>
                        <p>Now that the object has been pinned, your application can modify that object.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20175"></a><div class="props_rev_3"><a id="GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5" name="GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5"></a><h4 id="LNCPP-GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5" class="sect4"><span class="enumeration_section">4.7.3 </span>Manipulating Object Attributes
                  </h4>
                  <div>
                     <div class="section">
                        <p>Manipulating object attributes is no different from that of accessing them as shown in the previous section. Let us assume the <code class="codeph">Address</code> class has the following user defined method that sets the <code class="codeph">state</code> attribute to the input value:
                        </p><pre class="oac_no_warn" dir="ltr">void Address::setState(string new_state)
{
&nbsp;&nbsp;&nbsp;state = new_state;
}
</pre><p>The following example shows how to modify the state attribute of the object, <code class="codeph">addr</code>:
                        </p><pre class="oac_no_warn" dir="ltr">addr_ref-&gt;setState("PA");
</pre><p>As explained earlier, the first invocation of the operator <code class="codeph">-&gt;</code> on<code class="codeph"> Ref&lt;T&gt;</code> loads the object, if it is not in the object cache.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20176"></a><div class="props_rev_3"><a id="GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96" name="GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96"></a><h4 id="LNCPP-GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96" class="sect4"><span class="enumeration_section">4.7.4 </span>About Marking Objects and Flushing Changes
                  </h4>
                  <div>
                     <p>In the example in the previous section, an attribute of an object was changed. This change exists only in the client-side cache; you must implement specific programmatic steps to write the changes to the database.</p>
                  </div>
               </div><a id="LNCPP20177"></a><div class="props_rev_3"><a id="GUID-452627F0-6A11-4141-9271-B1F813131E3A" name="GUID-452627F0-6A11-4141-9271-B1F813131E3A"></a><h4 id="LNCPP-GUID-452627F0-6A11-4141-9271-B1F813131E3A" class="sect4"><span class="enumeration_section">4.7.5 </span>Marking an Object as Modified (Dirty)
                  </h4>
                  <div>
                     <div class="section">
                        <p>The first step is to indicate that the object has been modified. This is done by calling the <code class="codeph">markModified()</code> method on the object (derived method of <code class="codeph">PObject</code>). This method marks the object as <span class="bold">dirty</span> (modified). 
                        </p>
                        <p>Continuing the previous example, after object attributes are manipulated, the object referred to by <code class="codeph">addr_ref </code>can be marked dirty as follows:
                        </p><pre class="oac_no_warn" dir="ltr">addr_ref-&gt;markModified();</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20178"></a><div class="props_rev_3"><a id="GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477" name="GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477"></a><h4 id="LNCPP-GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477" class="sect4"><span class="enumeration_section">4.7.6 </span>About Recording Changes in the Database 
                  </h4>
                  <div>
                     <p>Objects that have had their dirty flag set must be flushed to the database server for the changes to be recorded in the database. This can be done in three ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Flush a single object marked dirty by calling the method <code class="codeph">flush</code>, a derived method of <code class="codeph">PObject</code>. 
                           </p>
                        </li>
                        <li>
                           <p>Flush the entire object cache using the <code class="codeph">Connection::flushCache()</code> method. In this case, OCCI traverses the dirty list maintained by the object cache and flushes all the dirty objects. 
                           </p>
                        </li>
                        <li>
                           <p>Commit a transaction by calling the <code class="codeph">Connection::commit()</code> method. Doing so also traverses the dirty list and flushes the objects to the database server. The dirty list includes newly created persistent objects. 
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20179"></a><div class="props_rev_3"><a id="GUID-9ED70097-5409-4E0C-905F-F8404C724690" name="GUID-9ED70097-5409-4E0C-905F-F8404C724690"></a><h4 id="LNCPP-GUID-9ED70097-5409-4E0C-905F-F8404C724690" class="sect4"><span class="enumeration_section">4.7.7 </span>Collecting Garbage in the Object Cache
                  </h4>
                  <div>
                     <div class="section">
                        <p>The object cache has two important associated parameters:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The maximum cache size percentage </p>
                           </li>
                           <li>
                              <p>The optimal cache size </p>
                           </li>
                        </ul>
                        <p>These parameters refer to levels of cache memory usage, and they help determine when the cache automatically 'ages out' eligible objects to free up memory.</p>
                        <p>If the memory occupied by the objects currently in the cache reaches or exceeds the maximum cache size, the cache automatically begins to free (or age out) unmarked objects which have a pin count of zero. The cache continues freeing such objects until memory usage in the cache reaches the optimal size, or until it runs out of objects eligible for freeing. Note that the cache can grow beyond the specified maximum cache size.</p>
                        <p>The maximum object cache size (in bytes) is computed by incrementing the optimal cache size (<code class="codeph">optimal_size</code>) by the maximum cache size percentage (<code class="codeph">max_size_percentage</code>), as follows: 
                        </p><pre class="oac_no_warn" dir="ltr">Maximum cache size = optimal_size + optimal_size * max_size_percentage / 100;
</pre><p>The default value for the maximum cache size percentage is 10%. The default value for the optimal cache size is 8MB. When a persistent object is created through the overloaded <code class="codeph">PObject::new()</code> operator, the newly created object is marked dirty and its pin count is set to<code class="codeph"> 0</code>. 
                        </p>
                        <p>These parameters can be set or retrieved using the following member functions of the Environment class:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">void setCacheMaxSize(unsigned int maxSize); </code></p>
                           </li>
                           <li>
                              <p><code class="codeph">unsigned int getCacheMaxSize() const;</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">void setCacheOptSize(unsigned int OptSize);</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">unsigned int getCacheOptSize() const;</code></p>
                           </li>
                        </ul>
                        <p><span class="q">"<a href="object-programming.html#GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2">About Pinning anObject</a>"</span>  describes how pin count of an object functions as a reference count and how an unmarked object with a <code class="codeph">0</code> pin count can become eligible for garbage collection. For a newly created persistent object, the object is unmarked after the transaction is committed or aborted, and if the object has a <code class="codeph">0</code> pin count. Because nothing is referencing this object, it becomes a candidate for ageing out. 
                        </p>
                        <p>If you are working with several object that have a large number of string or collection attributes, most of the memory is allocated from the C++ heap; this is because OCCI uses STLs. You should therefore set the cache size to a low value to avoid high memory use before garbage collection activates.</p>
                        <div class="infoboxnotealso" id="GUID-9ED70097-5409-4E0C-905F-F8404C724690__GUID-BC28D90A-FE64-43CA-A3A9-2E8F195274D3">
                           <p class="notep1">See Also:</p>
                           <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI Application Programming Interface</a> for details.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20180"></a><div class="props_rev_3"><a id="GUID-85D81D09-85AF-4072-92F5-97E7CF194B52" name="GUID-85D81D09-85AF-4072-92F5-97E7CF194B52"></a><h4 id="LNCPP-GUID-85D81D09-85AF-4072-92F5-97E7CF194B52" class="sect4"><span class="enumeration_section">4.7.8 </span>About Ensuring Transactional Consistency of References
                  </h4>
                  <div>
                     <p>As described in the previous section, dereferencing a <code class="codeph">Ref&lt;T&gt;</code> for the first time results in the object being loaded into the object cache from the database server. From then on, the behavior of operator <code class="codeph">-&gt;</code> on <code class="codeph">Ref&lt;T&gt;</code> equals any C++ pointer, and it provides access to the object copy in the cache. But when the transaction commits or aborts, the object copy in the cache can no longer be valid because it could be modified by any other client. Therefore, after the transaction ends, when the <code class="codeph">Ref&lt;T&gt;</code> is again dereferenced, the object cache recognizes the fact that the object is no longer valid and fetches the most recent copy from the database server. 
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20181"></a><div class="props_rev_3"><a id="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC" name="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC"></a><h3 id="LNCPP-GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC" class="sect3"><span class="enumeration_section">4.8 </span>Overview of Complex Object Retrieval
               </h3>
               <div>
                  <p>In the examples discussed earlier, only a single object was fetched or pinned at a time. In these cases, each pin operation involved a separate database server round-trip to retrieve the object. </p>
                  <p>Object-oriented applications often model their problems as a set of interrelated objects that form graphs of objects. These applications process objects by starting with some initial set of objects and then using the references in these objects to traverse the remaining objects. In a client/server setting, each of these traversals could result in costly network round-trips to fetch objects. </p>
                  <p>The performance of such applications can be increased with <span class="bold">complex object retrieval</span> (COR). This is a prefetching mechanism in which an application specifies some criteria (content and boundary) for retrieving a set of linked objects in a single network round-trip. Using COR does not mean that these prefetched objects are pinned. They are fetched into the object cache, so that subsequent pin calls are local operations.
                  </p>
                  <p>A <span class="bold">complex object</span> is a set of logically related objects consisting of a root object, and a set of objects each of which is prefetched based on a given depth level. The <span class="bold">root</span> object is explicitly fetched or pinned. The <span class="bold">depth</span> <span class="bold">level</span> is the shortest number of references that have to be traversed from the root object to a given prefetched object in a complex object.
                  </p>
                  <p>An application specifies a complex object by describing its content and boundary. The fetching of complex objects is constrained by an environment's <span class="bold">prefetch limit</span>, the amount of memory in the object cache that is available for prefetching objects.
                  </p>
                  <p>The use of complex object retrieval does not add functionality; it only improves performance, and so its use is optional.</p>
                  <p>This section discusses the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="object-programming.html#GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4">Retrieving Complex Objects</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0">About Prefetching Complex Objects</a></p>
                        <div class="infoboxnotealso" id="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC__GUID-4CFCDDED-78A9-4E2B-BC6A-C302DA1219B5">
                           <p class="notep1">See Also:</p>
                           <p>Complete code listing of the demonstration programs</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20182"></a><div class="props_rev_3"><a id="GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4" name="GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4"></a><h4 id="LNCPP-GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4" class="sect4"><span class="enumeration_section">4.8.1 </span>Retrieving Complex Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>An OCCI application can achieve COR by setting the appropriate attributes of a <code class="codeph">Ref&lt;T&gt;</code> before dereferencing it using the following methods:
                        </p><pre class="oac_no_warn" dir="ltr">// prefetch attributes of the specified type name up to the specified depth
Ref&lt;T&gt;::setPrefetch(const string &amp;typeName, unsigned int depth);
// prefetch all the attribute types up to the specified depth.
Ref&lt;T&gt;::setPrefetch(unsigned int depth);
</pre><p>The application can also choose to fetch all objects reachable from the root object by way of REFs (transitive closure) to a certain depth. To do so, set the level parameter to the depth desired. For the preceding two examples, the application could also specify <code class="codeph">(PO object REF, OCCI_MAX_PREFETCH_DEPTH)</code> and <code class="codeph">(PO object REF, 1)</code> respectively to prefetch required objects. Doing so results in many extraneous fetches but is quite simple to specify, and requires only one database server round-trip.
                        </p>
                        <p>As an example for this discussion, consider the following type declaration:</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE customer(...);
CREATE TYPE line_item(...);
CREATE TYPE line_item_varray as VARRAY(100) of REF line_item;
CREATE TYPE purchase_order AS OBJECT
&nbsp;&nbsp;&nbsp;( po_number         NUMBER, 
&nbsp;&nbsp;&nbsp;&nbsp;cust              REF customer,
&nbsp;&nbsp;&nbsp;&nbsp;related_orders    REF purchase_order,
&nbsp;&nbsp;&nbsp;&nbsp;line_items        line_item_varray);
</pre><p>The<code class="codeph"> purchase_order</code> type contains a scalar value for <code class="codeph">po_number</code>, a <code class="codeph">VARRAY</code> of <code class="codeph">line_items</code>, and two references. The first is to a <code class="codeph">customer</code> type and the second is to a <code class="codeph">purchase_order</code> type, indicating that this type can be implemented as a linked list.
                        </p>
                        <p>When fetching a complex object, an application must specify the following:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A reference to the desired root object</p>
                           </li>
                           <li>
                              <p>One or more pairs of type and depth information to specify the boundaries of the complex object. The type information indicates which <code class="codeph">REF</code> attributes should be followed for COR, and the depth level indicates how many levels deep those links should be followed.
                              </p>
                           </li>
                        </ul>
                        <p>In the case of the <code class="codeph">purchase_order</code> object in the preceding example, the application must specify the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The reference to the root <code class="codeph">purchase_order</code> object
                              </p>
                           </li>
                           <li>
                              <p>One or more pairs of type and depth information for <code class="codeph">customer</code>, <code class="codeph">purchase_order</code>, or <code class="codeph">line_item</code></p>
                           </li>
                        </ul>
                        <p>An application prefetching a purchase order needs access to the customer information for that purchase order. Using simple navigation, this would require two database server accesses to retrieve the two objects.</p>
                        <p>Through complex object retrieval, <code class="codeph">customer</code> can be prefetched when the application pins the <code class="codeph">purchase_order</code> object. In this case, the complex object would consist of the <code class="codeph">purchase_order</code> object and the <code class="codeph">customer</code> object it references.
                        </p>
                        <p>In the previous example, if the application wanted to prefetch a purchase order and the related customer information, the application would specify the <code class="codeph">purchase_order</code> object and indicate that <code class="codeph">customer</code> should be followed to a depth level of one as follows:
                        </p><pre class="oac_no_warn" dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("CUSTOMER",1);
</pre><p>If the application wanted to prefetch a <code class="codeph">purchase order</code> and all objects in the object graph it contains, the application would specify the <code class="codeph">purchase_order</code> object and indicate that both <code class="codeph">customer</code> and <code class="codeph">purchase_order</code> should be followed to the maximum depth level possible as follows:
                        </p><pre class="oac_no_warn" dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("CUSTOMER", OCCI_MAX_PREFETCH_DEPTH);
poref.setPrefetch("PURCHASE_ORDER", OCCI_MAX_PREFETCH_DEPTH);
</pre><p>where <code class="codeph">OCCI_MAX_PREFETCH_DEPTH</code> specifies that all objects of the specified type reachable through references from the root object should be prefetched.
                        </p>
                        <p>If an application wanted to prefetch a purchase order and all the line items associated with it, the application would specify the <code class="codeph">purchase_order </code>object and indicate that <code class="codeph">line_items</code> should be followed to the maximum depth level possible as follows:
                        </p><pre class="oac_no_warn" dir="ltr">Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("LINE_ITEM", 1);</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20183"></a><div class="props_rev_3"><a id="GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0" name="GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0"></a><h4 id="LNCPP-GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0" class="sect4"><span class="enumeration_section">4.8.2 </span>About Prefetching Complex Objects
                  </h4>
                  <div>
                     <p>After specifying and fetching a complex object, subsequent fetches of objects contained in the complex object do not incur the cost of a network round-trip, because these objects have been prefetched and are in the object cache. Keep in mind that excessive prefetching of objects can lead to a flooding of the object cache. This flooding, in turn, may force out other objects that the application had pinned, leading to a performance degradation instead of performance improvement.</p>
                     <p>Note that if there is insufficient memory in the object cache to hold all prefetched objects, some objects may not be prefetched. The application then incurs a network round-trip when those objects are accessed later.</p>
                     <p>You must have the <code class="codeph">READ</code> or <code class="codeph">SELECT </code>privilege for all prefetched objects. Objects in the complex object for which the application does not have <code class="codeph">READ</code> or <code class="codeph">SELECT</code> privilege cannot prefetched. 
                     </p>
                     <p>An entire vector of <code class="codeph">Ref</code>s can be prefetched into object cache in a single round-trip by using the global <a href="connection-class.html#GUID-D98EBFBE-3B25-4BD6-B228-F79E5A56AA7C">pinVectorOfRefs()</a> method of the <a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0">Connection Class</a>. This method reduces the number of round-trips for an <code class="codeph">n</code>-sized vector of <code class="codeph">Ref</code>s from <code class="codeph">n</code> to <code class="codeph">1</code>, and tracks the newly pinned objects through an <code class="codeph">OUT</code> parameter vector.
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP21905"></a><a id="LNCPP20184"></a><div class="props_rev_3"><a id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC" name="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC"></a><h3 id="LNCPP-GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC" class="sect3"><span class="enumeration_section">4.9 </span>Working with Collections
               </h3>
               <div>
                  <div class="section">
                     <p>Oracle supports two kinds of collections - variable length arrays (ordered collections) and nested tables (unordered collections). OCCI maps both of them to a Standard Template Library (STL) vector container, giving you the full power, flexibility, and speed of an STL vector to access and manipulate the collection elements. <a href="object-programming.html#GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__BEIJBAIA">Example 4-9</a> shows the SQL DDL to create a <code class="codeph">VARRAY</code> and an object that contains an attribute of type <code class="codeph">VARRAY</code>, and the resulting C++ declaration that OTT generates.
                     </p>
                     <div class="infoboxnotealso" id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__GUID-AAF77C80-C955-46CA-8B88-C6E6BA4E1F5C">
                        <p class="notep1">See Also:</p>
                        <p>Complete code listing of the demonstration programs</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__BEIJBAIA">
                     <p class="titleinexample">Example 4-9 How to Create a VARRAY Collection</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE ADDR_LIST AS VARRAY(3) OF REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (name VARCHAR2(20), addr_l ADDR_LIST);
</pre><p>Here is the C++ class declaration generated by OTT:</p><pre class="oac_no_warn" dir="ltr">class PERSON : public PObject
{
&nbsp;&nbsp;&nbsp;protected:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string name;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt; Ref&lt; ADDRESS &gt; &gt; addr_1;

&nbsp;&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Connection* conn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const string&amp; table); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string  getSQLTypeName() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen, void **typeName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PERSON (void *ctx) : PObject(ctx) { };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void *readSQL(void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void readSQL(AnyData&amp; stream);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void writeSQL(void *obj, void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void writeSQL(AnyData&amp; stream);
}</pre></div>
                  <!-- class="example" -->
                  <div class="section">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="object-programming.html#GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9">Fetching Embedded Objects</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0">About Nullness</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNCPP20185"></a><div class="props_rev_3"><a id="GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9" name="GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9"></a><h4 id="LNCPP-GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9" class="sect4"><span class="enumeration_section">4.9.1 </span>Fetching Embedded Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>If your application must fetch an embedded object, which is an object stored in a column of a regular table rather than an object table, you cannot use the <code class="codeph">REF</code> retrieval mechanism. Embedded instances do not have object identifiers, so it is not possible to get a reference to them. Therefore, they cannot serve as the basis for object navigation. There are still many situations, however, in which an application fetches embedded instances.
                        </p>
                        <p>For example, assume that an <code class="codeph">address</code> type has been created.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE address AS OBJECT
(&nbsp;&nbsp;street1             varchar2(50),
&nbsp;&nbsp;&nbsp;street2             varchar2(50),
&nbsp;&nbsp;&nbsp;city                varchar2(30),
&nbsp;&nbsp;&nbsp;state               char(2),
&nbsp;&nbsp;&nbsp;zip                 number(5));
</pre><p>You could then use that type as the data type of a column in another table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE clients
(&nbsp;name          varchar2(40),
&nbsp;&nbsp;&nbsp;addr          address);
</pre><p>Your OCCI application could then issue the following SQL statement:</p><pre class="oac_no_warn" dir="ltr">SELECT addr FROM clients
WHERE name='BEAR BYTE DATA MANAGEMENT';
</pre><p>This statement would return an embedded <code class="codeph">address</code> object from the <code class="codeph">clients</code> table. The application could then use the values in the attributes of this object for other processing. The application should execute the statement and fetch the object in the same way as described in the section <span class="q">"<a href="object-programming.html#GUID-2E5F6826-403F-4925-8775-47D6849F555F">Overview of Associative Access</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20186"></a><div class="props_rev_3"><a id="GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0" name="GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0"></a><h4 id="LNCPP-GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0" class="sect4"><span class="enumeration_section">4.9.2 </span>About Nullness
                  </h4>
                  <div>
                     <p>If a column in a row of a database table has no value, then that column is said to be <code class="codeph">NULL</code>, or to contain a <code class="codeph">NULL</code>. Two different types of <code class="codeph">NULL</code>s can apply to objects:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Any attribute of an object can have a<code class="codeph"> NULL</code> value. This indicates that the value of that attribute of the object is not known.
                           </p>
                        </li>
                        <li>
                           <p>An object may be <span class="bold">atomically NULL</span>. Therefore, the value of the entire object is unknown.
                           </p>
                        </li>
                     </ul>
                     <p>Atomic <code class="codeph">NULL</code>ness is different from nonexistence. An atomically <code class="codeph">NULL</code> object still exists, its value is just not known. It may be thought of as an existing object with no data.
                     </p>
                     <p>For every type of object attribute, OCCI provides a corresponding class. For instance, <code class="codeph">NUMBER</code> attribute type maps to the <code class="codeph">Number</code> class, <code class="codeph">REF</code> maps to <code class="codeph">RefAny</code>, and so on. Each and every OCCI class that represents a data type provides two methods:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">isNull()</code>  returns whether the object is <code class="codeph">NULL</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">setNull()</code>  sets the object to <code class="codeph">NULL</code></p>
                        </li>
                     </ul>
                     <p>Similarly, these methods are inherited from the <code class="codeph">PObject</code> class by all the objects and can be used to access and set atomically <code class="codeph">NULL</code> information about them.
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20187"></a><div class="props_rev_3"><a id="GUID-E3D9E110-7335-4E84-9452-7FE689550FB7" name="GUID-E3D9E110-7335-4E84-9452-7FE689550FB7"></a><h3 id="LNCPP-GUID-E3D9E110-7335-4E84-9452-7FE689550FB7" class="sect3"><span class="enumeration_section">4.10 </span>About Using Object References
               </h3>
               <div>
                  <p>OCCI provides the application with the flexibility to access the contents of the objects using their pointers or their references. OCCI provides the <code class="codeph">PObject::getRef()</code> method to return a reference to a persistent object. This call is valid for persistent objects only.
                  </p>
               </div>
            </div><a id="LNCPP20188"></a><div class="props_rev_3"><a id="GUID-C7C82B8B-2056-4692-9BA0-C123902C6268" name="GUID-C7C82B8B-2056-4692-9BA0-C123902C6268"></a><h3 id="LNCPP-GUID-C7C82B8B-2056-4692-9BA0-C123902C6268" class="sect3"><span class="enumeration_section">4.11 </span>About Deleting Objects from the Database
               </h3>
               <div>
                  <p>OCCI users can use the overloaded<code class="codeph"> PObject::operator</code> <code class="codeph">new()</code> to create the persistent objects. However, to delete the object from the database server, it is best to call <code class="codeph">ref</code>.<a href="pobject-class.html#GUID-AF071A80-A628-45B3-BEC6-92B28820A516">markDelete()</a> directly on the <code class="codeph">Ref</code>; this prevents the object from getting into the client cache. If the object is in the client cache, it can be removed by an <code class="codeph">obj</code>.<a href="pobject-class.html#GUID-AF071A80-A628-45B3-BEC6-92B28820A516">markDelete()</a> call on the object. The object marked for deletion is permanently removed when the transaction commits.
                  </p>
               </div>
            </div><a id="LNCPP20189"></a><div class="props_rev_3"><a id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132" name="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132"></a><h3 id="LNCPP-GUID-43D835F1-F7E4-4EA5-8F32-F50393162132" class="sect3"><span class="enumeration_section">4.12 </span>About Type Inheritance
               </h3>
               <div>
                  <p>Type inheritance of objects has many similarities to inheritance in C++ and Java. You can create an object type as a subtype of an existing object type. The subtype is said to inherit all the attributes and methods (member functions and procedures) of the supertype, which is the original type. Only single inheritance is supported; an object cannot have multiple supertypes. The subtype can add new attributes and methods to the ones it inherits. It can also override (redefine the implementation) of any of its inherited methods. A subtype is said to extend (that is, inherit from) its supertype.</p>
                  <div class="infoboxnotealso" id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132__GUID-4D386922-5E66-45D9-B0B0-0208A4CD8097">
                     <p class="notep1">See Also:</p>
                     <p><a href="../adobj/key-features-object-relational-model.html#ADOBJ7054" target="_blank"><span><cite>Oracle Database Object-Relational Developer's Guide</cite></span></a> for a more complete discussion of this topic
                     </p>
                  </div>
                  <p>As an example, a type <code class="codeph">Person_t</code> can have a subtype <code class="codeph">Student_t</code> and a subtype <code class="codeph">Employee_t</code>. In turn, <code class="codeph">Student_t</code> can have its own subtype, <code class="codeph">PartTimeStudent_t</code>. A type declaration must have the flag <code class="codeph">NOT FINAL</code> so that it can have subtypes. The default is <code class="codeph">FINAL</code>, which means that the type can have no subtypes. 
                  </p>
                  <p>All types discussed so far in this chapter are <code class="codeph">FINAL</code>. All types in applications developed before Oracle Database release 8.1.7 are <code class="codeph">FINAL</code>. A type that is <code class="codeph">FINAL</code> can be altered to be <code class="codeph">NOT FINAL</code>. A <code class="codeph">NOT FINAL</code> type with no subtypes can be altered to be <code class="codeph">FINAL</code>. <code class="codeph">Person_ t</code> is declared as <code class="codeph">NOT FINAL</code> for our example:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT
(&nbsp;&nbsp;ssn NUMBER,
&nbsp;&nbsp;&nbsp;name VARCAHR2(30),
&nbsp;&nbsp;&nbsp;address VARCHAR2(100)) NOT FINAL; 
</pre><p>A subtype inherits all the attributes and methods declared in its supertype. It can also declare new attributes and methods, which must have different names than those of the supertype. The keyword <code class="codeph">UNDER</code> identifies the supertype, like this:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Student_t UNDER Person_t
(&nbsp;&nbsp;deptid NUMBER,
&nbsp;&nbsp;&nbsp;major  VARCHAR2(30)) NOT FINAL;
</pre><p>The newly declared attributes <code class="codeph">deptid</code> and <code class="codeph">major</code> belong to the subtype <code class="codeph">Student_t</code>. The subtype <code class="codeph">Employee_t</code> is declared as, for example:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Employee_t UNDER Person_t
(&nbsp;&nbsp;empid NUMBER,
&nbsp;&nbsp;&nbsp;mgr   VARCHAR2(30));</pre><div class="infoboxnotealso" id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132__GUID-0733D9EF-AD7A-4F6B-98A5-7CFCD25ED442">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659">About OTT Support for Type Inheritance</a>"</span> for the classes generated by OTT for this example.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>Subtype <code class="codeph">Student_t</code> can have its own subtype, such as <code class="codeph">PartTimeStudent_t</code>:
                  </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE PartTimeStuden_t UNDER Student_t ( numhours NUMBER) ;
</pre><div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="object-programming.html#GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3">About Substitutability</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0">Declaring NOT INSTANTIABLE Types and Methods</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E">About OCCI Support for Type Inheritance</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659">About OTT Support for Type Inheritance</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20190"></a><div class="props_rev_3"><a id="GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3" name="GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3"></a><h4 id="LNCPP-GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3" class="sect4"><span class="enumeration_section">4.12.1 </span>About Substitutability
                  </h4>
                  <div>
                     <p>The benefits of polymorphism derive partially from the property substitutability. Substitutability allows a value of some subtype to be used by code originally written for the supertype, without any specific knowledge of the subtype being needed in advance. The subtype value behaves to the surrounding code just like a value of the supertype would, even if it perhaps uses different mechanisms within its specializations of methods. </p>
                     <p>Instance substitutability refers to the ability to use an object value of a subtype in a context declared in terms of a supertype. <code class="codeph">REF</code> substitutability refers to the ability to use a <code class="codeph">REF</code> to a subtype in a context declared in terms of a <code class="codeph">REF</code> to a supertype.
                     </p>
                     <p><code class="codeph">REF</code> type attributes are substitutable, that is, an attribute defined as <code class="codeph">REF T</code> can hold a <code class="codeph">REF</code> to an instance of <code class="codeph">T</code> or any of its subtypes. 
                     </p>
                     <p>Object type attributes are substitutable, that is, an attribute defined to be of (an object) type <code class="codeph">T</code> can hold an instance of <code class="codeph">T</code> or any of its subtypes. 
                     </p>
                     <p>Collection element types are substitutable, that is, if we define a collection of elements of type <code class="codeph">T</code>, then it can hold instances of type <code class="codeph">T</code> and any of its subtypes. Here is an example of object attribute substitutability:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT 
(&nbsp;&nbsp;title VARCHAR2(30),
&nbsp;&nbsp;&nbsp;author Person_t     /* substitutable */);
</pre><p>Thus, a <code class="codeph">Book_t</code> instance can be created by specifying a title string and a <code class="codeph">Person_t</code> (or any subtype of <code class="codeph">Person_t</code>) object:
                     </p><pre class="oac_no_warn" dir="ltr">Book_t('My Oracle Experience',
&nbsp;&nbsp;&nbsp;Employee_t(12345, 'Joe', 'SF', 1111, NULL))</pre></div>
               </div><a id="LNCPP20191"></a><div class="props_rev_3"><a id="GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0" name="GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0"></a><h4 id="LNCPP-GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0" class="sect4"><span class="enumeration_section">4.12.2 </span>Declaring NOT INSTANTIABLE Types and Methods
                  </h4>
                  <div>
                     <div class="section">
                        <p>A type can be declared <code class="codeph">NOT INSTANTIABLE</code>, which means that there is no constructor (default or user defined) for the type. Thus, it is not be possible to construct instances of this type. The typical usage would be to define instantiable subtypes for such a type. Here is how this property is used:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Address_t AS OBJECT(...) NOT INSTANTIABLE NOT FINAL;
CREATE TYPE USAddress_t UNDER Address_t(...);
CREATE TYPE IntlAddress_t UNDER Address_t(...);
</pre><p>A method of a type can be declared to be <code class="codeph">NOT INSTANTIABLE</code>. Declaring a method as <code class="codeph">NOT INSTANTIABLE</code> means that the type is not providing an implementation for that method. Further, a type that contains any <code class="codeph">NOT INSTANTIABLE</code> methods must necessarily be declared as <code class="codeph">NOT INSTANTIABLE</code>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE T AS OBJECT
(&nbsp;&nbsp;x NUMBER,
&nbsp;&nbsp;&nbsp;NOT INSTANTIABLE MEMBER FUNCTION func1() RETURN NUMBER 
) NOT INSTANTIABLE;
</pre><p>A subtype of <code class="codeph">NOT INSTANTIABLE</code> can override any of the <code class="codeph">NOT INSTANTIABLE</code> methods of the supertype and provide concrete implementations. If there are any <code class="codeph">NOT INSTANTIABLE</code> methods remaining, the subtype must also necessarily be declared as <code class="codeph">NOT INSTANTIABLE</code>.
                        </p>
                        <p>A <code class="codeph">NOT INSTANTIABLE</code> subtype can be defined under an instantiable supertype. Declaring a <code class="codeph">NOT INSTANTIABLE</code> type to be <code class="codeph">FINAL</code> is not useful and is not allowed.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20192"></a><div class="props_rev_3"><a id="GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E" name="GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E"></a><h4 id="LNCPP-GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E" class="sect4"><span class="enumeration_section">4.12.3 </span>About OCCI Support for Type Inheritance
                  </h4>
                  <div>
                     <div class="p">The following calls support type inheritance:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="object-programming.html#GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73">About Connection::getMetaData()</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648">About Bind and Define Functions</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20193"></a><div class="props_rev_3"><a id="GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73" name="GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73"></a><h5 id="LNCPP-GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73" class="sect5"><span class="enumeration_section">4.12.3.1 </span>About Connection::getMetaData()
                     </h5>
                     <div>
                        <p>This method provides information specific to inherited types. Additional attributes have been added for the properties of inherited types. For example, you can get the supertype of a type.</p>
                     </div>
                  </div><a id="LNCPP20194"></a><div class="props_rev_3"><a id="GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648" name="GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648"></a><h5 id="LNCPP-GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648" class="sect5"><span class="enumeration_section">4.12.3.2 </span>About Bind and Define Functions
                     </h5>
                     <div>
                        <p>The <code class="codeph">setRef()</code>, <code class="codeph">setObject()</code> and <code class="codeph">setVector()</code> methods of the <code class="codeph">Statement</code> class are used to bind <code class="codeph">REF</code>, object, and collections respectively. All these functions support <code class="codeph">REF</code>, instance, and collection element substitutability. Similarly, the corresponding <code class="codeph">get</code><span class="italic"><code class="codeph">xxx</code></span><code class="codeph">()</code> methods to fetch the data also support substitutability.
                        </p>
                     </div>
                  </div>
               </div><a id="LNCPP20196"></a><a id="LNCPP20195"></a><div class="props_rev_3"><a id="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659" name="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659"></a><h4 id="LNCPP-GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659" class="sect4"><span class="enumeration_section">4.12.4 </span>About OTT Support for Type Inheritance
                  </h4>
                  <div>
                     <p>Class declarations for objects with inheritance are similar to the simple object declarations except that the class is derived from the parent type class and only the fields corresponding to attributes not in the parent class are included. The structure for these declarations is listed in <a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659__CIHFBACF">Example 4-10</a>:
                     </p>
                     <p>In this structure, all variables are the same as in the simple object case. <code class="codeph">parentTypename</code> refers to the name of the parent type, that is, the class name of the type from which typename inherits.
                     </p>
                     <div class="example" id="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659__CIHFBACF">
                        <p class="titleinexample">Example 4-10 OTT Support Inheritance</p><pre class="oac_no_warn" dir="ltr">class &lt;typename&gt; : public &lt;parentTypename&gt; 
{
&nbsp;&nbsp;&nbsp;protected:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;OCCItype1&gt; &lt;attributename1&gt;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;OCCItypen&gt; &lt;attributenamen&gt;;

&nbsp;&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *operator new(size_t size, const Connection* conn, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const string&amp; table); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string  getSQLTypeName() const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen, void **typeName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;typename&gt; (void *ctx) : &lt;parentTypename&gt;(ctx) { };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void *readSQL(void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void readSQL(AnyData&amp; stream);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void writeSQL(void *obj, void *ctx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20198"></a><a id="LNCPP20199"></a><a id="LNCPP20200"></a><a id="LNCPP20201"></a><a id="LNCPP20202"></a><a id="LNCPP20203"></a><a id="LNCPP20204"></a><a id="LNCPP20205"></a><a id="LNCPP20206"></a><a id="LNCPP20207"></a><a id="LNCPP20197"></a><div class="props_rev_3"><a id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598" name="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598"></a><h3 id="LNCPP-GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598" class="sect3"><span class="enumeration_section">4.13 </span>A Sample OCCI Application 
               </h3>
               <div>
                  <div class="section">
                     <p>This section describes a sample OCCI application that uses some features discussed in this chapter.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D7B1BB61-8C4A-4E56-B167-3ECB3C2FAD4A">
                     <p class="titleinexample">Example 4-11 Listing of demo2.sql for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">drop table ADDR_TAB
/
drop table PERSON_TAB
/
drop type STUDENT
/
drop type PERSON
/
drop type ADDRESS_TAB
/
drop type ADDRESS
/
drop type FULLNAME
/
CREATE TYPE FULLNAME AS OBJECT (first_name CHAR(20), last_name CHAR(20))
/
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20)) 
/
CREATE TYPE ADDRESS_TAB  AS VARRAY(3) OF REF ADDRESS
/
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULLNAME,curr_addr REF ADDRESS, 
prev_addr_l ADDRESS_TAB) NOT FINAL
/
CREATE TYPE STUDENT UNDER  PERSON (school_name CHAR(20))
/
CREATE TABLE ADDR_TAB OF ADDRESS
/
CREATE TABLE PERSON_TAB OF PERSON
/</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__CIHEEFFI">
                     <p class="titleinexample">Example 4-12 Listing of demo2.typ for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">TYPE FULLNAME GENERATE CFullName as MyFullName
TYPE ADDRESS GENERATE CAddress as MyAddress
TYPE PERSON GENERATE CPerson as MyPerson
TYPE STUDENT GENERATE CStudent as MyStudent</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-791AD8E7-188B-40A3-B6D1-89E5388522E0">
                     <p class="titleinexample">Example 4-13 Listing of OTT Command that Generates Files for a Sample OCCI Application</p>
                     <p>OTT attempts to connect with user name <code class="codeph">demousr</code>; the system prompts for the password.
                     </p><pre class="oac_no_warn" dir="ltr">ott userid=demousr intype=demo2.typ code=cpp hfile=demo2.h
&nbsp;&nbsp;&nbsp;cppfile=demo2.cpp mapfile=mappings.cpp attraccess=private</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-CB32D2C6-B2A6-48B2-8638-194D7862D32F">
                     <p class="titleinexample">Example 4-14 Listing of mappings.h for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef MAPPINGS_ORACLE
# define MAPPINGS_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

#ifndef DEMO2_ORACLE
# include "demo2.h"
#endif

void mappings(oracle::occi::Environment* envOCCI_);

#endif</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-0D9FE4F4-4B1A-462E-8C71-E2D43BA80770">
                     <p class="titleinexample">Example 4-15 Listing of mappings.cpp for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef MAPPINGS_ORACLE
# include "mappings.h"
#endif

void mappings(oracle::occi::Environment* envOCCI_)
{
  oracle::occi::Map *mapOCCI_ = envOCCI_-&gt;getMap();
  mapOCCI_-&gt;put("HR.FULLNAME", &amp;CFullName::readSQL, &amp;CFullName::writeSQL);
  mapOCCI_-&gt;put("HR.ADDRESS", &amp;CAddress::readSQL, &amp;CAddress::writeSQL);
  mapOCCI_-&gt;put("HR.PERSON", &amp;CPerson::readSQL, &amp;CPerson::writeSQL);
  mapOCCI_-&gt;put("HR.STUDENT", &amp;CStudent::readSQL, &amp;CStudent::writeSQL);
}</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-164C7CCD-9950-4E4A-8D6C-9872D19F111F">
                     <p class="titleinexample">Example 4-16 Listing of demo2.h for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE
# define DEMO2_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

class MyFullName;
class MyAddress;
class MyPerson;
/*   Changes ended here */

/*  GENERATED DECLARATIONS FOR THE FULLNAME OBJECT TYPE. */
class CFullName : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string FIRST_NAME;
   OCCI_STD_NAMESPACE::string LAST_NAME;

public:   OCCI_STD_NAMESPACE::string getFirst_name() const;
   void setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getLast_name() const;
   void setLast_name(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CFullName();
   CFullName(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CFullName();
};

/* GENERATED DECLARATIONS FOR THE ADDRESS OBJECT TYPE. */ 
class CAddress : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string STATE;
   OCCI_STD_NAMESPACE::string ZIP;

public:
   OCCI_STD_NAMESPACE::string getState() const;
   void setState(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getZip() const;
   void setZip(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CAddress();
   CAddress(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CAddress();
};

/* GENERATED DECLARATIONS FOR THE PERSON OBJECT TYPE. */
class CPerson : public oracle::occi::PObject {

private:
   oracle::occi::Number ID;
   MyFullName * NAME;
   oracle::occi::Ref&lt; MyAddress &gt; CURR_ADDR;
   OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt; PREV_ADDR_L;

public:   oracle::occi::Number getId() const;
   void setId(const oracle::occi::Number &amp;value);
   MyFullName * getName() const;
   void setName(MyFullName * value);
   oracle::occi::Ref&lt; MyAddress &gt; getCurr_addr() const;
   void setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value);
   OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt; MyAddress&gt;&gt;&amp; 
      getPrev_addr_l();
   const OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt;MyAddress&gt;&gt;&amp; 
      getPrev_addr_l() const;
   void setPrev_addr_l(const OCCI_STD_NAMESPACE::vector 
      &lt;oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CPerson();
   CPerson(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CPerson();
};

/* GENERATED DECLARATIONS FOR THE STUDENT OBJECT TYPE. */
/*  changes to the generated file - declarations for the MyPerson class. */
class MyPerson : public CPerson {

public:
      MyPerson(Number id_i, MyFullName *name_i, const Ref&lt;MyAddress&gt;&amp; addr_i) ;
      MyPerson(void *ctxOCCI_);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
      MyPerson();
};
/* changes  end here */

class CStudent : public MyPerson {
private:
   OCCI_STD_NAMESPACE::string SCHOOL_NAME;

public:
   OCCI_STD_NAMESPACE::string getSchool_name() const;
   void setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value);\
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,\
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CStudent();
   CStudent(void *ctxOCCI_) : MyPerson (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CStudent();
};

/*changes  made to the generated file */
/* declarations for the MyFullName class. */
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
      MyFullName(void *ctxOCCI_);
};

// declarations for the MyAddress class.
class MyAddress : public CAddress
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
      MyAddress(void *ctxOCCI_);
};

class MyStudent : public CStudent
{
  public :
     MyStudent(void *ctxOCCI_) ;
};
/* changes end here */ 
#endif</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D70B55AF-E5B2-4397-8CB2-D6C6E7A2781A">
                     <p class="titleinexample">Example 4-17 Listing of demo2.cpp for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE
# include "demo2.h"
#endif

/* GENERATED METHOD IMPLEMENTATIONS FOR THE FULLNAME OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CFullName::getFirst_name() const
{
  return FIRST_NAME;
}

void CFullName::setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  FIRST_NAME = value;
}

OCCI_STD_NAMESPACE::string CFullName::getLast_name() const
{
  return LAST_NAME;
}

void CFullName::setLast_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  LAST_NAME = value;
}

void *CFullName::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CFullName::operator new(size_t size, const oracle::occi::Connection *
  sess,  const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.FULLNAME");
}

void *CFullName::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CFullName::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CFullName::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.FULLNAME");
}

void CFullName::getSQLTypeName(oracle::occi::Environment *env,
     void  **schemaName, unsigned int &amp;schemaNameLen, void **typeName,
     unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CFullName::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CFullName::CFullName()
{
}

void *CFullName::readSQL(void *ctxOCCI_)
{
  MyFullName *objOCCI_ = new(ctxOCCI_) MyFullName(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CFullName::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   FIRST_NAME = streamOCCI_.getString();
   LAST_NAME = streamOCCI_.getString();
}

void CFullName::writeSQL(void *objectOCCI_, void *ctxOCCI_){
  CFullName *objOCCI_ = (CFullName *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CFullName::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(FIRST_NAME);
   streamOCCI_.setString(LAST_NAME);
}

CFullName::~CFullName()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE ADDRESS OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CAddress::getState() const
{
  return STATE;
}

void CAddress::setState(const OCCI_STD_NAMESPACE::string &amp;value)
{
  STATE = value;
}

OCCI_STD_NAMESPACE::string CAddress::getZip() const
{
  return ZIP;
}

void CAddress::setZip(const OCCI_STD_NAMESPACE::string &amp;value)
{
  ZIP = value;
}

void *CAddress::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CAddress::operator new(size_t size, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const oracle::occi::Connection * sess,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.ADDRESS");
}

void *CAddress::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CAddress::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CAddress::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.ADDRESS");
}

void CAddress::getSQLTypeName(oracle::occi::Environment *env, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **typeName, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CAddress::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CAddress::CAddress()
{
}

void *CAddress::readSQL(void *ctxOCCI_)
{
  MyAddress *objOCCI_ = new(ctxOCCI_) MyAddress(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CAddress::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   STATE = streamOCCI_.getString();
   ZIP = streamOCCI_.getString();
}

void CAddress::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CAddress *objOCCI_ = (CAddress *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CAddress::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(STATE);
   streamOCCI_.setString(ZIP);
}

CAddress::~CAddress()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE PERSON OBJECT TYPE. */
oracle::occi::Number CPerson::getId() const
{
  return ID;
}

void CPerson::setId(const oracle::occi::Number &amp;value)
{
  ID = value;
}

MyFullName * CPerson::getName() const
{
  return NAME;
}

void CPerson::setName(MyFullName * value)
{
  NAME = value;
}

oracle::occi::Ref&lt; MyAddress &gt; CPerson::getCurr_addr() const
{
  return CURR_ADDR;
}

void CPerson::setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value)
{
  CURR_ADDR = value;
}

OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
&nbsp;&nbsp;&nbsp;CPerson::getPrev_addr_l() 
{
  return PREV_ADDR_L;
}

const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
  CPerson::getPrev_addr_l() const
{
  return PREV_ADDR_L;
}

void CPerson::setPrev_addr_l(const OCCI_STD_NAMESPACE::vector&lt;
 oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value)
{
  PREV_ADDR_L = value;
}
void *CPerson::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CPerson::operator new(size_t size, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const oracle::occi::Connection * sess,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.PERSON");
}

void *CPerson::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CPerson::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CPerson::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.PERSON");
}

void CPerson::getSQLTypeName(oracle::occi::Environment *env, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **typeName, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CPerson::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CPerson::CPerson()
{
   NAME = (MyFullName *) 0;
}

void *CPerson::readSQL(void *ctxOCCI_)
{
  MyPerson *objOCCI_ = new(ctxOCCI_) MyPerson(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CPerson::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   ID = streamOCCI_.getNumber();
   NAME = (MyFullName *) streamOCCI_.getObject(&amp;MyFullName::readSQL);
   CURR_ADDR = streamOCCI_.getRef();
   oracle::occi::getVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

void CPerson::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CPerson *objOCCI_ = (CPerson *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CPerson::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setNumber(ID);
   streamOCCI_.setObject(NAME);
   streamOCCI_.setRef(CURR_ADDR);
   oracle::occi::setVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

CPerson::~CPerson()
{
  int i;
  delete NAME;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE STUDENT OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CStudent::getSchool_name() const
{
  return SCHOOL_NAME;
}

void CStudent::setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  SCHOOL_NAME = value;
}

void *CStudent::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CStudent::operator new(size_t size, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const oracle::occi::Connection * sess,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.STUDENT");
}

void *CStudent::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CStudent::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CStudent::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.STUDENT");
}

void CStudent::getSQLTypeName(oracle::occi::Environment *env, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **schemaName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;schemaNameLen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **typeName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CStudent::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CStudent::CStudent()
{
}
void *CStudent::readSQL(void *ctxOCCI_)
{
  MyStudent *objOCCI_ = new(ctxOCCI_) MyStudent(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CStudent::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::readSQL(streamOCCI_);
   SCHOOL_NAME = streamOCCI_.getString();
}

void CStudent::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CStudent *objOCCI_ = (CStudent *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CStudent::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::writeSQL(streamOCCI_);
   streamOCCI_.setString(SCHOOL_NAME);
}

CStudent::~CStudent()
{
  int i;
}
</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>Let us assume OTT generates <code class="codeph">FULL_NAME</code>, <code class="codeph">ADDRSESS</code>, <code class="codeph">PERSON</code>, and <code class="codeph">PFGRFDENT</code> class declarations in <code class="codeph">demo2.h</code>. The following sample OCCI application extends the classes generated by OTT, as specified in <code class="codeph">demo2.typ</code> file in <a href="object-programming.html#GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__CIHEEFFI">Example 4-12</a>, and adds some user-defined methods. Note that these class declarations have been incorporated into <code class="codeph">demo2.h</code> to ensure correct compilation.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D9279E5A-488D-4B76-9AD8-1DC4BA3156CF">
                     <p class="titleinexample">Example 4-18  Listing of myDemo.h for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef MYDEMO_ORACLE
#define MYDEMO_ORACLE

#include &lt;string&gt;

#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

// declarations for the MyFullName class.
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
};

// declarations for the MyAddress class.
class MyAddress : public CAddress 
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
};

// declarations for the MyPerson class.
class MyPerson : public CPerson
{  public:
      MyPerson(Number id_i, MyFullname *name_i, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Ref&lt;MyAddress&gt;&amp; addr_i);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
};

#endif</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-6D956542-265C-4643-A9F1-3F7723419839">
                     <p class="titleinexample">Example 4-19 Listing for myDemo.cpp for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;

/* initialize MyFullName */
MyFullName::MyFullName(string first_name,string last_name)
{
 setFirst_name(first_name);
 setLast_name(last_name);
}

/* display all the information in MyFullName */
void MyFullName::displayInfo()
{
   cout &lt;&lt; "FIRST NAME is" &lt;&lt; getFirst_name() &lt;&lt; endl;
   cout &lt;&lt; "LAST NAME is" &lt;&lt; getLast_name() &lt;&lt; endl;
}

MyFullName::MyFullName(void *ctxOCCI_):CFullName(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyAddress CLASS. */

/* initialize MyAddress */
MyAddress::MyAddress(string state_i, string zip_i)
{
  setState(state_i); 
  setZip(zip_i);
}

/* display all the information in MyAddress */
void MyAddress::displayInfo()
{
   cout &lt;&lt; "STATE is" &lt;&lt; getState() &lt;&lt; endl;
   cout &lt;&lt; "ZIP is" &lt;&lt; getZip() &lt;&lt; endl;
}

MyAddress::MyAddress(void *ctxOCCI_) :CAddress(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyPerson CLASS. */

/* initialize MyPerson */
MyPerson::MyPerson(Number id_i, MyFullName* name_i, 
const Ref&lt;MyAddress&gt;&amp; addr_i)
{
  setId(id_i);
  setName(name_i);
  setCurr_addr(addr_i);
}

MyPerson::MyPerson(void *ctxOCCI_) :CPerson(ctxOCCI_)
{
}

/* move Person from curr_addr to new_addr */ 
void MyPerson::move(const Ref&lt;MyAddress&gt;&amp; new_addr)
{
   // append curr_addr to the vector //
   getPrev_addr_l().push_back(getCurr_addr());  
   setCurr_addr(new_addr);

   // mark the object as dirty
   this-&gt;markModified();
}

/*  display all the information of MyPerson */
void MyPerson::displayInfo()
{
   cout &lt;&lt; "ID is" &lt;&lt; (int)getId() &lt;&lt; endl;
   getName()-&gt;displayInfo();

   // de-referencing the Ref attribute using -&gt; operator
   getCurr_addr()-&gt;displayInfo();
   cout &lt;&lt; "Prev Addr List: " &lt;&lt; endl;
   for (int i = 0; i &lt; getPrev_addr_l().size(); i++)
   {  
      // access the collection elements using [] operator
      (getPrev_addr_l())[i]-&gt;displayInfo();
   }
}

MyPerson::MyPerson()
{
}

MyStudent::MyStudent(void *ctxOCCI_) : CStudent(ctxOCCI_)
{
}</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-8822A641-749E-498E-8111-12B519060507">
                     <p class="titleinexample">Example 4-20 Listing of main.cpp for a Sample OCCI Application</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

#ifndef MAPPINGS_ORACLE
#include &lt;mappings.h&gt;
#endif

#include &lt;iostream&gt;
using namespace std;
using namespace::oracle;

int main()
{
   Environment *env = Environment::createEnvironment(Environment::OBJECT);
   mappings(env);

   try {
     Connection *conn = Connection("HR", <span class="italic">"password</span>");

    /* Call the OTT generated function to register the mappings */
    /* create a persistent object of type ADDRESS in the database table, 
       ADDR_TAB */
    MyAddress *addr1 = new(conn, "ADDR_TAB") MyAddress("CA", "94065");
    conn-&gt;commit();

    Statement *st = conn-&gt;createStatement("select ref(a) from addr_tab a");
   ResultSet *rs = st-&gt;executeQuery();
   Ref&lt;MyAddress&gt; r1;
   if ( rs-&gt;next())
      r1 = rs-&gt;getRef(1);
   st-&gt;closeResultSet(rs);
   conn-&gt;terminateStatement(st);

   MyFullName * name1 = new MyFullName("Joe", "Black");

   /* create a persistent object of type Person in the database table 
      PERSON_TAB */
   MyPerson *person1 = new(conn, "PERSON_TAB") MyPerson(1,name1,r1);
   conn-&gt;commit();

   /* selecting the inserted information */
   Statement *stmt = conn-&gt;createStatement();
   ResultSet *resultSet = 
        stmt-&gt;executeQuery("SELECT REF(a) from person_tab a where id = 1");

   if (resultSet-&gt;next())
   {
      Ref&lt;MyPerson&gt; joe_ref = (Ref&lt;MyPerson&gt;) resultSet-&gt;getRef(1);
      joe_ref-&gt;displayInfo();

      /* create a persistent object of type ADDRESS in the database table
         ADDR_TAB */
      MyAddress *new_addr1 = new(conn, "ADDR_TAB") MyAddress("PA", "92140");
      joe_ref-&gt;move(new_addr1-&gt;getRef());
      joe_ref-&gt;displayInfo();
   }

   /* commit the transaction which results in the newly created object
       new_addr and the dirty object joe to be flushed to the server.
       Note that joe was marked dirty in move(). */
   conn-&gt;commit();

   conn-&gt;terminateStatement(stmt);
   env-&gt;terminateConnection(conn);
 }

 catch ( exception &amp;x)

 {
  cout &lt;&lt; x.what () &lt;&lt; endl;
 }
   Environment::terminateEnvironment(env);
   return 0;
}
</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>