<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>PL/SQL Name Resolution</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database PL/SQL Language Reference ">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database PL/SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96448-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="plsql-source-text-wrapping.html" title="Previous" type="text/html">
      <link rel="next" href="plsql-program-limits.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="LNPLS">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-source-text-wrapping.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="plsql-program-limits.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database PL/SQL Language Reference </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL/SQL Name Resolution</li>
            </ol>
            <a id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9" name="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9"></a><a id="LNPLS2153"></a><a id="LNPLS017"></a>
            
            <h2 id="LNPLS-GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9" class="sect2"><span class="enumeration_chapter">B </span>PL/SQL Name Resolution
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This appendix explains PL/SQL <span class="bold">name resolution</span>; that is, how the PL/SQL compiler resolves ambiguous references to identifiers.
               </p>
               <p>An unambiguous identifier reference can become ambiguous if you change identifiers in its compilation unit (that is, if you add, rename, or delete identifiers).</p>
               <div class="infoboxnote" id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9__GUID-4C7ADE5B-AE64-4AB1-9FDB-BA2D0D0D02C4">
                  <p class="notep1">Note:</p>
                  <p>The <code class="codeph">AUTHID</code> property of a stored PL/SQL unit affects the name resolution of SQL statements that the unit issues at run time. For more information, see <span class="q">"<a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="If you include a connected user database link in a DR unit (definer's rights unit), then you must grant the user who will run the DR unit the INHERIT REMOTE PRIVILEGES privilege.">Invoker's Rights and Definer's Rights (AUTHID Property)</a>"</span>.
                  </p>
               </div>
               <div class="section">
                  <p class="subhead1" id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9__GUID-98C0062E-3F48-4B4C-950B-393A234A5A4C">Topics</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C">Qualified Names and Dot Notation</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09">Column Name Precedence</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24">Differences Between PL/SQL and SQL Name Resolution Rules</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">Resolution of Names in Static SQL Statements</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-6471F04B-7872-4D88-B72D-8B46448B29EB">What is Capture?</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">Avoiding Inner Capture in SELECT and DML Statements</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="LNPLS1751"></a><a id="LNPLS01702"></a><div class="props_rev_3"><a id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C" name="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C"></a><h3 id="LNPLS-GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C" class="sect3"><span class="enumeration_section">B.1 </span>Qualified Names and Dot Notation
               </h3>
               <div>
                  <p>When one named item belongs to another named item, you can (and sometimes must) qualify the name of the "child" item with the name of the "parent" item, using dot notation. For example:</p>
                  <div class="tblformal" id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__GUID-A7F64158-28E0-4F59-9755-3252BF6B9969">
                     <table cellpadding="4" cellspacing="0" class="Formal" title summary='This table lists the "child" identifiers that you must qualify, their "parents," and the syntax of their qualified names.' width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d161356e232">When referencing ...</th>
                              <th align="left" valign="bottom" width="31%" id="d161356e235">You must qualify its name with ...</th>
                              <th align="left" valign="bottom" width="37%" id="d161356e238">Using this syntax ...</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e243" headers="d161356e232 ">
                                 <p>Field of a record</p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e243 d161356e235 ">
                                 <p>Name of the record</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e243 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">record_name.field_name</code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e255" headers="d161356e232 ">
                                 <p>Method of a collection</p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e255 d161356e235 ">
                                 <p>Name of the collection</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e255 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">collection_name.method</code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e267" headers="d161356e232 ">
                                 <p>Pseudocolumn <code class="codeph">CURRVAL</code></p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e267 d161356e235 ">
                                 <p>Name of a sequence</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e267 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">sequence_name</code></span><code class="codeph">.CURRVAL</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e283" headers="d161356e232 ">
                                 <p>Pseudocolumn <code class="codeph">NEXTVAL</code></p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e283 d161356e235 ">
                                 <p>Name of a sequence</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e283 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">sequence_name</code></span><code class="codeph">.NEXTVAL</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>If an identifier is declared in a named PL/SQL unit, you can qualify its simple name (the name in its declaration) with the name of the unit (block, subprogram, or package), using this syntax:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">unit_name.simple_identifier_name</span>
</pre><p>If the identifier is not visible, then you <span class="italic">must</span> qualify its name (see <span class="q">"<a href="plsql-language-fundamentals.html#GUID-2FC17012-FC99-4614-90DD-ADC99F2EDBE9" title="The scope of an identifier is the region of a PL/SQL unit from which you can reference the identifier. The visibility of an identifier is the region of a PL/SQL unit from which you can reference the identifier without qualifying it. An identifier is local to the PL/SQL unit that declares it. If that unit has subunits, the identifier is global to them.">Scope and Visibility of Identifiers</a>"</span>).
                  </p>
                  <p>If an identifier belongs to another schema, then you must qualify its name with the name of the schema, using this syntax:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.package_name</span>
</pre><p>A simple name can be qualified with multiple names, as <a href="plsql-name-resolution.html#GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__CHDBCGDB">Example B-1</a> shows.
                  </p>
                  <p>Some examples of possibly ambiguous qualified names are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Field or attribute of a function return value, for example:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">func_name</span>().<span class="italic">field_name</span>
<span class="italic">func_name</span>().<span class="italic">attribute_name</span>
</pre></li>
                     <li>
                        <p>Schema object owned by another schema, for example:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.table_name</span>
<span class="italic">schema_name.procedure_name</span>()
<span class="italic">schema_name.type_name.member_name</span>()
</pre></li>
                     <li>
                        <p>Package object owned by another user, for example:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.package_name.procedure_name</span>()
<span class="italic">schema_name.package_name.record_name.field_name</span>
</pre></li>
                     <li>
                        <p>Record containing an ADT, for example:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">record_name.field_name.attribute_name</span>
<span class="italic">record_name.field_name.member_name</span>()</pre></li>
                  </ul>
                  <div class="example" id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__CHDBCGDB">
                     <p class="titleinexample">Example B-1 Qualified Names</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE pkg1 AUTHID DEFINER AS
  m NUMBER;
  TYPE t1 IS RECORD (a NUMBER);
  v1 t1;
  TYPE t2 IS TABLE OF t1 INDEX BY PLS_INTEGER;
  v2 t2; 
  FUNCTION f1 (p1 NUMBER) RETURN t1;
  FUNCTION f2 (q1 NUMBER) RETURN t2;
END pkg1;
/

CREATE OR REPLACE PACKAGE BODY pkg1 AS
  FUNCTION f1 (p1 NUMBER) RETURN t1 IS
    n NUMBER;
  BEGIN
     n := m;             -- Unqualified variable name
     n := <span class="bold">pkg1.m</span>;        -- Variable name qualified by package name
     n := <span class="bold">pkg1.f1.p1</span>;    -- Parameter name qualified by function name,
                         --  which is qualified by package name
     n := <span class="bold">v1.a</span>;          -- Variable name followed by component name
     n := <span class="bold">pkg1.v1.a</span>;     -- Variable name qualified by package name
                         --  and followed by component name
     n := <span class="bold">v2(10).a</span>;      -- Indexed name followed by component name
     n := <span class="bold">f1(10).a</span>;      -- Function invocation followed by component name
     n := <span class="bold">f2(10)(10).a</span>;  -- Function invocation followed by indexed name
                         --  and followed by component name
     n := <span class="bold">hr.pkg1.f2(10)(10).a</span>;  -- Schema name, package name,
                                 -- function invocation, index, component name
     v1.a := p1;
     RETURN v1;
   END f1;

   FUNCTION f2 (q1 NUMBER) RETURN t2 IS
     v_t1 t1;
     v_t2 t2;
   BEGIN
     v_t1.a := q1;
     v_t2(1) := v_t1;
     RETURN v_t2;
   END f2;
END pkg1;
/
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS233"></a><a id="LNPLS2155"></a><a id="LNPLS2156"></a><a id="LNPLS234"></a><a id="LNPLS2154"></a><div class="props_rev_3"><a id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09" name="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09"></a><h3 id="LNPLS-GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09" class="sect3"><span class="enumeration_section">B.2 </span>Column Name Precedence
               </h3>
               <div>
                  <p>If a SQL statement references a name that belongs to both a column and either a local variable or formal parameter, then the column name takes precedence.</p>
                  <div class="infoboxnote" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__GUID-1E80CFA1-7C13-4ADC-AF53-73136D5294CC">
                     <p class="notep1">Caution:</p>
                     <p>When a variable or parameter name is interpreted as a column name, data can be deleted, changed, or inserted unintentionally.</p>
                  </div>
                  <p>In <a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">Example B-2</a>, the name <code class="codeph">last_name</code> belongs to both a local variable and a column (names are not case-sensitive). Therefore, in the <code class="codeph">WHERE</code> clause, both references to <code class="codeph">last_name</code> resolve to the column, and all rows are deleted.
                  </p>
                  <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABJJEBG">Example B-3</a> solves the problem in <a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">Example B-2</a> by giving the variable a different name.
                  </p>
                  <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABGGJJG">Example B-4</a> solves the problem in <a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">Example B-2</a> by labeling the block and qualifying the variable name with the block name.
                  </p>
                  <p>In <a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BEIFDBJD">Example B-5</a>, the function <code class="codeph">dept_name</code> has a formal parameter and a local variable whose names are those of columns of the table <code class="codeph">DEPARTMENTS</code>. The parameter and variable name are qualified with the function name to distinguish them from the column names.
                  </p>
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">
                     <p class="titleinexample">Example B-2 Variable Name Interpreted as Column Name Causes Unintended Result</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees2;
CREATE TABLE employees2 AS
  SELECT <span class="bold">LAST_NAME</span> FROM employees;
 
DECLARE
  <span class="bold">last_name</span>  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Deleted 107 rows.</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABJJEBG">
                     <p class="titleinexample">Example B-3 Fixing <span><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">Example B-2</a></span> with Different Variable Name
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE
  v_last_name  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = v_last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Deleted 2 rows.</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABGGJJG">
                     <p class="titleinexample">Example B-4 Fixing <span><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">Example B-2</a></span> with Block Label
                     </p><pre class="oac_no_warn" dir="ltr"><span class="bold">&lt;&lt;main&gt;&gt;</span>
DECLARE
  last_name  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">last_name = main.last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Deleted 2 rows.</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BEIFDBJD">
                     <p class="titleinexample">Example B-5 Subprogram Name for Name Resolution</p><pre class="oac_no_warn" dir="ltr">DECLARE
  FUNCTION <span class="bold">dept_name</span> (<span class="bold">department_id</span> IN NUMBER)
    RETURN departments.department_name%TYPE
  IS
    <span class="bold">department_name</span>  departments.department_name%TYPE;
  BEGIN
    SELECT <span class="bold">department_name</span> INTO <span class="bold">dept_name.department_name</span>
      --   <span class="bold"> ^column</span>              <span class="bold"> ^local variable</span>
    FROM departments
    WHERE <span class="bold">department_id</span> = <span class="bold">dept_name.department_id</span>;
    --    <span class="bold"> ^column</span>         <span class="bold"> ^formal parameter</span>
    RETURN department_name;
  END dept_name;
BEGIN
  FOR item IN (
    SELECT department_id
    FROM departments
    ORDER BY department_name) LOOP
 
      DBMS_OUTPUT.PUT_LINE ('Department: ' || dept_name(item.department_id));
  END LOOP;
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Department: Accounting
Department: Administration
Department: Benefits
Department: Construction
Department: Contracting
Department: Control And Credit
Department: Corporate Tax
Department: Executive
Department: Finance
Department: Government Sales
Department: Human Resources
Department: IT
Department: IT Helpdesk
Department: IT Support
Department: Manufacturing
Department: Marketing
Department: NOC
Department: Operations
Department: Payroll
Department: Public Relations
Department: Purchasing
Department: Recruiting
Department: Retail Sales
Department: Sales
Department: Shareholder Services
Department: Shipping
Department: Treasury</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS01703"></a><div class="props_rev_3"><a id="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24" name="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24"></a><h3 id="LNPLS-GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24" class="sect3"><span class="enumeration_section">B.3 </span>Differences Between PL/SQL and SQL Name Resolution Rules
               </h3>
               <div>
                  <p>PL/SQL and SQL name resolution rules are very similar. However:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>PL/SQL rules are less permissive than SQL rules.</p>
                        <p>Because most SQL rules are context-sensitive, they recognize as legal more situations than PL/SQL rules do.</p>
                     </li>
                     <li>
                        <p>PL/SQL and SQL resolve qualified names differently.</p>
                        <p>For example, when resolving the table name <code class="codeph">HR</code>.<code class="codeph">JOBS</code>:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>PL/SQL searches first for packages, types, tables, and views named <code class="codeph">HR</code> in the current schema, then for public synonyms, and finally for objects named <code class="codeph">JOBS</code> in the <code class="codeph">HR</code> schema.
                              </p>
                           </li>
                           <li>
                              <p>SQL searches first for objects named <code class="codeph">JOBS</code> in the <code class="codeph">HR</code> schema, and then for packages, types, tables, and views named <code class="codeph">HR</code> in the current schema.
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>To avoid problems caused by the few differences between PL/SQL and SQL name resolution rules, follow the recommendations in <span class="q">"<a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">Avoiding Inner Capture in SELECT and DML Statements</a>"</span>.
                  </p>
                  <div class="infoboxnote" id="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24__GUID-54DDFB5F-01BE-4A69-A676-5B5DDBF79504">
                     <p class="notep1">Note:</p>
                     <p>When the PL/SQL compiler processes a static SQL statement, it sends that statement to the SQL subsystem, which uses SQL rules to resolve names in the statement. For details, see <span class="q">"<a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">Resolution of Names in Static SQL Statements</a>"</span>.
                     </p>
                  </div>
               </div>
            </div><a id="LNPLS99882"></a><div class="props_rev_3"><a id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C" name="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C"></a><h3 id="LNPLS-GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C" class="sect3"><span class="enumeration_section">B.4 </span>Resolution of Names in Static SQL Statements
               </h3>
               <div>
                  <p>Static SQL is described in <a href="static-sql.html#GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" title="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement.">PL/SQL Static SQL</a>.
                  </p>
                  <p>When the PL/SQL compiler finds a static SQL statement:</p>
                  <ol>
                     <li id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABBAFCJ">
                        <p>If the statement is a <code class="codeph">SELECT</code> statement, the PL/SQL compiler removes the <code class="codeph">INTO</code> clause.
                        </p>
                     </li>
                     <li>
                        <p>The PL/SQL compiler sends the statement to the SQL subsystem.</p>
                     </li>
                     <li>
                        <p>The SQL subsystem checks the syntax of the statement.</p>
                        <p>If the syntax is incorrect, the compilation of the PL/SQL unit fails. If the syntax is correct, the SQL subsystem determines the names of the tables and tries to resolve the other names in the scope of the SQL statement.</p>
                     </li>
                     <li id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABIBAGB">
                        <p>If the SQL subsystem cannot resolve a name in the scope of the SQL statement, then it sends the name back to the PL/SQL compiler. The name is called an <span class="bold">escaped identifier</span>.
                        </p>
                     </li>
                     <li>
                        <p>The PL/SQL compiler tries to resolve the escaped identifier.</p>
                        <p>First, the compiler tries to resolve the identifier in the scope of the PL/SQL unit. If that fails, the compiler tries to resolve the identifier in the scope of the schema. If that fails, the compilation of the PL/SQL unit fails.</p>
                     </li>
                     <li>
                        <p>If the compilation of the PL/SQL unit succeeds, the PL/SQL compiler generates the text of the regular SQL statement that is equivalent to the static SQL statement and stores that text with the generated computer code.</p>
                     </li>
                     <li>
                        <p>At run time, the PL/SQL runtime system invokes routines that parse, bind, and run the regular SQL statement.</p>
                        <p>The bind variables are the escaped identifiers (see step&nbsp;<a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABIBAGB">4</a>).
                        </p>
                     </li>
                     <li>
                        <p>If the statement is a <code class="codeph">SELECT</code> statement, the PL/SQL runtime system stores the results in the PL/SQL targets specified in the <code class="codeph">INTO</code> clause that the PL/SQL compiler removed in step&nbsp;<a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABBAFCJ">1</a>.
                        </p>
                     </li>
                  </ol>
                  <div class="infoboxnote" id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__GUID-0C4C36EC-E128-4EB3-8EF7-EAAECC3FE9FE">
                     <p class="notep1">Note:</p>
                     <p>Bind variables can be evaluated in any order. If a program determines order of evaluation, then at the point where the program does so, its behavior is undefined.</p>
                  </div>
               </div>
            </div><a id="LNPLS2157"></a><a id="LNPLS01704"></a><div class="props_rev_3"><a id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB" name="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB"></a><h3 id="LNPLS-GUID-6471F04B-7872-4D88-B72D-8B46448B29EB" class="sect3"><span class="enumeration_section">B.5 </span>What is Capture?
               </h3>
               <div>
                  <p>When a declaration or definition prevents the compiler from correctly resolving a reference in another scope, the declaration or definition is said to <span class="bold">capture</span> the reference. Capture is usually the result of migration or schema evolution.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB__GUID-7A5A946F-8F74-43DB-91BF-BDA21D8C913E">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A">Outer Capture</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5">Same-Scope Capture</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-2FB522D5-7042-4E37-BB52-44344839D876">Inner Capture</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB__GUID-53DDA835-28B7-48CC-AD17-7D8F6A8FCBB6">
                        <p class="notep1">Note:</p>
                        <p>Same-scope and inner capture occur only in SQL scope.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS1754"></a><div class="props_rev_3"><a id="GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A" name="GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A"></a><h4 id="LNPLS-GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A" class="sect4"><span class="enumeration_section">B.5.1 </span>Outer Capture
                  </h4>
                  <div>
                     <p><span class="bold">Outer capture</span> occurs when a name in an inner scope, which had resolved to an item in an inner scope, now resolves to an item in an outer scope. Both PL/SQL and SQL are designed to prevent outer capture; you need not be careful to avoid it.
                     </p>
                  </div>
               </div><a id="LNPLS1753"></a><div class="props_rev_3"><a id="GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5" name="GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5"></a><h4 id="LNPLS-GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5" class="sect4"><span class="enumeration_section">B.5.2 </span>Same-Scope Capture
                  </h4>
                  <div>
                     <p><span class="bold">Same-scope capture</span> occurs when a column is added to one of two tables used in a join, and the new column has the same name as a column in the other table. When only one table had a column with that name, the name could appear in the join unqualified. Now, to avoid same-scope capture, you must qualify the column name with the appropriate table name, everywhere that the column name appears in the join.
                     </p>
                  </div>
               </div><a id="LNPLS2158"></a><a id="LNPLS1752"></a><div class="props_rev_3"><a id="GUID-2FB522D5-7042-4E37-BB52-44344839D876" name="GUID-2FB522D5-7042-4E37-BB52-44344839D876"></a><h4 id="LNPLS-GUID-2FB522D5-7042-4E37-BB52-44344839D876" class="sect4"><span class="enumeration_section">B.5.3 </span>Inner Capture
                  </h4>
                  <div>
                     <p><span class="bold">Inner capture</span> occurs when a name in an inner scope, which had resolved to an item in an outer scope, now either resolves to an item in an inner scope or cannot be resolved. In the first case, the result might change. In the second case, an error occurs.
                     </p>
                     <p>In <a href="plsql-name-resolution.html#GUID-2FB522D5-7042-4E37-BB52-44344839D876__BABGHDAJ">Example B-6</a>, a new column captures a reference to an old column with the same name. Before new column <code class="codeph">col2</code> is added to table <code class="codeph">tab2</code>, <code class="codeph">col2</code> resolves to <code class="codeph">tab1.col2</code>; afterward, it resolves to <code class="codeph">tab2.col2</code>.
                     </p>
                     <p>To avoid inner capture, follow the rules in <span class="q">"<a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">Avoiding Inner Capture in SELECT and DML Statements</a>"</span>.
                     </p>
                     <div class="example" id="GUID-2FB522D5-7042-4E37-BB52-44344839D876__BABGHDAJ">
                        <p class="titleinexample">Example B-6 Inner Capture of Column Reference</p>
                        <p>Table <code class="codeph">tab1</code> has a column named <code class="codeph">col2</code>, but table <code class="codeph">tab2</code> does not:
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE tab1;
CREATE TABLE <span class="bold">tab1</span> (col1 NUMBER, <span class="bold">col2</span> NUMBER);
INSERT INTO tab1 (col1, col2) VALUES (100, 10);

DROP TABLE tab2;
CREATE TABLE <span class="bold">tab2</span> (col1 NUMBER);
INSERT INTO tab2 (col1) VALUES (100);
</pre><p>Therefore, in the inner <code class="codeph">SELECT</code> statement, the reference to <code class="codeph">col2</code> resolves to column <code class="codeph">tab1.col2</code>:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PROCEDURE proc AUTHID DEFINER AS
  CURSOR c1 IS
    SELECT * FROM tab1
    WHERE EXISTS (<span class="bold">SELECT * FROM tab2 WHERE col2 = 10</span>);
BEGIN
  OPEN c1;
  CLOSE c1;
END;
/
</pre><p>Add a column named <code class="codeph">col2</code> to table <code class="codeph">tab2</code>:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE tab2 ADD (col2 NUMBER);
</pre><p>Now procedure <code class="codeph">proc</code> is invalid. At its next invocation, the database automatically recompiles it, and the reference to <code class="codeph">col2</code> in the inner <code class="codeph">SELECT</code> statement resolves to column <code class="codeph">tab2.col2</code>.
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS2160"></a><a id="LNPLS2159"></a><a id="LNPLS01705"></a><div class="props_rev_3"><a id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE" name="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE"></a><h3 id="LNPLS-GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE" class="sect3"><span class="enumeration_section">B.6 </span>Avoiding Inner Capture in SELECT and DML Statements
               </h3>
               <div>
                  <div class="section">
                     <p>Avoid inner capture of references in <code class="codeph">SELECT</code>, <code class="codeph">SELECT</code> <code class="codeph">INTO</code>, and DML statements by following these recommendations:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Specify a unique alias for each table in the statement.</p>
                        </li>
                        <li>
                           <p>Do not specify a table alias that is the name of a schema that owns an item referenced in the statement.</p>
                        </li>
                        <li>
                           <p>Qualify each column reference in the statement with the appropriate table alias.</p>
                        </li>
                     </ul>
                     <p>In <a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__BABGIFBD">Example B-7</a>, schema <code class="codeph">hr</code> owns tables <code class="codeph">tab1</code> and <code class="codeph">tab2</code>. Table <code class="codeph">tab1</code> has a column named <code class="codeph">tab2</code>, whose Abstract Data Type (ADT) has attribute <code class="codeph">a</code>. Table <code class="codeph">tab2</code> does not have a column named <code class="codeph">a</code>. Against recommendation, the query specifies alias <code class="codeph">hr</code> for table <code class="codeph">tab1</code> and references table <code class="codeph">tab2</code>. Therefore, in the query, the reference <code class="codeph">hr.tab2.a</code> resolves to table <code class="codeph">tab1</code>, column <code class="codeph">tab2</code>, attribute <code class="codeph">a</code>. Then the example adds column <code class="codeph">a</code> to table <code class="codeph">tab2</code>. Now the reference <code class="codeph">hr.tab2.a</code> in the query resolves to schema <code class="codeph">hr</code>, table <code class="codeph">tab2</code>, column <code class="codeph">a</code>. Column <code class="codeph">a</code> of table <code class="codeph">tab2</code> captures the reference to attribute <code class="codeph">a</code> in column <code class="codeph">tab2</code> of table <code class="codeph">tab1</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__GUID-F416694B-02C8-4610-9422-FF0074F4FCDA">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE">Qualifying References to Attributes and Methods</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-E052D320-D7F7-45EF-A577-3401776C478F">Qualifying References to Row Expressions</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__BABGIFBD">
                     <p class="titleinexample">Example B-7 Inner Capture of Attribute Reference</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE <span class="bold">TYPE type1</span> AS OBJECT (<span class="bold">a</span> NUMBER);
/
DROP TABLE tab1;
CREATE <span class="bold">TABLE tab1 (tab2 type1)</span>;
INSERT INTO tab1 (tab2) VALUES (type1(10));

DROP TABLE tab2;
CREATE <span class="bold">TABLE tab2 (x NUMBER)</span>;
INSERT INTO tab2 (x) VALUES (10);

<span class="bold">/* Alias tab1 with same name as schema name,</span>
   <span class="bold">a bad practice used here for illustration purpose.</span>
   <span class="bold">Note lack of alias in second SELECT statement. */</span>

SELECT * FROM tab1 <span class="bold">hr</span>
WHERE EXISTS (SELECT * FROM <span class="bold">hr.tab2</span> WHERE x = <span class="bold">hr.tab2.a</span>);
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">TAB2(A)
---------------
 
TYPE1(10)
 
1 row selected.
</pre><p>Add a column named <code class="codeph">a</code> to table <code class="codeph">tab2</code> (which belongs to schema <code class="codeph">hr</code>):
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE tab2 ADD (a NUMBER);
</pre><p>Now, when the query runs, <code class="codeph">hr.tab2.a</code> resolves to schema <code class="codeph">hr</code>, table <code class="codeph">tab2</code>, column <code class="codeph">a</code>. To avoid this inner capture, apply the recommendations to the query:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">hr.</span>tab1 <span class="bold">p1</span>
WHERE EXISTS (SELECT * FROM hr.tab2 <span class="bold">p2</span> WHERE <span class="bold">p2.</span>x = <span class="bold">p1.</span>tab2.a);</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS2161"></a><a id="LNPLS1755"></a><div class="props_rev_3"><a id="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE" name="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE"></a><h4 id="LNPLS-GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE" class="sect4"><span class="enumeration_section">B.6.1 </span>Qualifying References to Attributes and Methods
                  </h4>
                  <div>
                     <div class="section">
                        <p>To reference an attribute or method of a table element, you must give the table an alias and use the alias to qualify the reference to the attribute or method.</p>
                        <p>In <a href="plsql-name-resolution.html#GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE__BABFBEBJ">Example B-8</a>, table <code class="codeph">tbl1</code> has column <code class="codeph">col1</code> of data type <code class="codeph">t1</code>, an ADT with attribute <code class="codeph">x</code>. The example shows several correct and incorrect references to <code class="codeph">tbl1.col1.x</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE__BABFBEBJ">
                        <p class="titleinexample">Example B-8 Qualifying ADT Attribute References</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE t1 AS OBJECT (x NUMBER);
/
DROP TABLE tb1;
CREATE TABLE tb1 (col1 t1); 
</pre><p>The references in the following <code class="codeph">INSERT</code> statements do not need aliases, because they have no column lists:
                        </p><pre class="oac_no_warn" dir="ltr">BEGIN
  INSERT INTO tb1 VALUES ( t1(10) );
  INSERT INTO tb1 VALUES ( t1(20) );
  INSERT INTO tb1 VALUES ( t1(30) );
END;
/
</pre><p>The following references to the attribute <code class="codeph">x</code> cause error ORA-00904:
                        </p><pre class="oac_no_warn" dir="ltr">UPDATE tb1 SET <span class="bold">col1.x</span> = 10 WHERE <span class="bold">col1.x</span> = 20;

UPDATE tb1 SET <span class="bold">tb1.col1.x</span> = 10 WHERE <span class="bold">tb1.col1.x</span> = 20;

UPDATE hr.tb1 SET <span class="bold">hr.tb1.col1.x</span> = 10 WHERE <span class="bold">hr.tb1.col1.x</span> = 20;

DELETE FROM tb1 WHERE <span class="bold">tb1.col1.x</span> = 10;
</pre><p>The following references to the attribute <code class="codeph">x</code>, with table aliases, are correct:
                        </p><pre class="oac_no_warn" dir="ltr">UPDATE hr.tb1 <span class="bold">t</span> SET <span class="bold">t.col1.x</span> = 10 WHERE <span class="bold">t.col1.x</span> = 20;

DECLARE
  y NUMBER;
BEGIN
  SELECT <span class="bold">t.col1.x</span> INTO y FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 30;
END;
/

DELETE FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 10;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS2162"></a><a id="LNPLS1756"></a><div class="props_rev_3"><a id="GUID-E052D320-D7F7-45EF-A577-3401776C478F" name="GUID-E052D320-D7F7-45EF-A577-3401776C478F"></a><h4 id="LNPLS-GUID-E052D320-D7F7-45EF-A577-3401776C478F" class="sect4"><span class="enumeration_section">B.6.2 </span>Qualifying References to Row Expressions
                  </h4>
                  <div>
                     <div class="section">
                        <p>Row expressions must resolve as references to table aliases. A row expression can appear in the <code class="codeph">SET</code> clause of an <code class="codeph">UPDATE</code> statement or be the parameter of the SQL function <code class="codeph">REF</code> or <code class="codeph">VALUE</code>.
                        </p>
                        <p>In <a href="plsql-name-resolution.html#GUID-E052D320-D7F7-45EF-A577-3401776C478F__BABICCCJ">Example B-9</a>, table <code class="codeph">ot1</code> is a standalone nested table of elements of data type <code class="codeph">t1</code>, an ADT with attribute <code class="codeph">x</code>. The example shows several correct and incorrect references to row expressions.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E052D320-D7F7-45EF-A577-3401776C478F__BABICCCJ">
                        <p class="titleinexample">Example B-9 Qualifying References to Row Expressions</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE t1 AS OBJECT (x number);
/
DROP TABLE ot1;
CREATE TABLE ot1 OF t1;

BEGIN
  INSERT INTO ot1 VALUES (t1(10));
  INSERT INTO ot1 VALUES (20);
  INSERT INTO ot1 VALUES (30);
END;
/
</pre><p>The following references cause error ORA-00904:</p><pre class="oac_no_warn" dir="ltr">UPDATE ot1 SET VALUE(<span class="bold">ot1.x</span>) = t1(20) WHERE VALUE(<span class="bold">ot1.x</span>) = t1(10);

DELETE FROM ot1 WHERE VALUE(<span class="bold">ot1</span>) = (t1(10));
</pre><p>The following references, with table aliases, are correct:</p><pre class="oac_no_warn" dir="ltr">
UPDATE ot1 <span class="bold">o</span> SET <span class="bold">o</span> = (t1(20)) WHERE <span class="bold">o.x</span> = 10;

DECLARE
  n_ref  REF t1;
BEGIN
  SELECT REF(<span class="bold">o</span>) INTO n_ref FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = t1(30);
END;
/

DECLARE
  n t1;
BEGIN
  SELECT VALUE(<span class="bold">o</span>) INTO n FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = t1(30);
END;
/

DECLARE
  n NUMBER;
BEGIN
  SELECT <span class="bold">o.x</span> INTO n FROM ot1 <span class="bold">o</span> WHERE <span class="bold">o.x</span> = 30;
END;
/

DELETE FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = (t1(20));</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>