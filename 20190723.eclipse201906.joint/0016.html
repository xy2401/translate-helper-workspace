<html id="0563.Doc01_UserInterface.html" dir="ltr"></html><html dir="ltr">

<head>
<title>用户界面的元素（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Elements of the User Interface (CDO Model Repository Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>用户界面的元素</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="index.html" title="向后退到用户指南"><img src="../../images/backward.png" border="0"></a> <a href="Doc02_ManagingRepositories.html" title="转发到管理存储库"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Eike Stepper</p>
<p>CDO用户界面包含许多特定于CDO的视图，编辑器和首选项页面，以及与现有Eclipse视图的一些集成。这些用户界面元素可以添加到任何Eclipse透视图中，也可以在任何Eclipse透视图中使用，或者在<a href="Doc01_UserInterface.html#Doc_ExplorerPerspective" title="CDO模型存储库文档中的章节">CDO Explorer</a>透视图中更全面地添加。
 </p><p>以下部分描述了各种用户界面元素并说明了它们的用途。
 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_ExplorerPerspective" title="CDO模型存储库文档中的章节">CDO Explorer透视图</a></td></tr>
<tr><td>2</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></td></tr>
<tr><td>3</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_AdministrationView" title="CDO模型存储库文档中的章节">CDO管理视图</a></td></tr>
<tr><td>4</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_CollaborationView" title="CDO模型存储库文档中的章节">CDO协作视图</a></td></tr>
<tr><td>五</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_WatchListView" title="CDO模型存储库文档中的章节">CDO观察列表视图</a></td></tr>
<tr><td>6</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO时间机器视图</a></td></tr>
<tr><td>7</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">CDO会话视图</a></td></tr>
<tr><td>8</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_ServerBrowser" title="CDO模型存储库文档中的章节">CDO服务器浏览器</a></td></tr>
<tr><td>9</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">CDO结账向导</a></td></tr>
<tr><td>10</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_ModelEditor" title="CDO模型存储库文档中的章节">CDO模型编辑器</a></td></tr>
<tr><td>11</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer集成</a></td></tr>
<tr><td>12</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_PropertySheetIntegration" title="CDO模型存储库文档中的章节">物业单整合</a></td></tr>
<tr><td>13</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史整合</a></td></tr>
<tr><td>14</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_CompareIntegration" title="CDO模型存储库文档中的章节">比较整合</a></td></tr>
<tr><td>15</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_FormsIntegration" title="CDO模型存储库文档中的章节">表单集成</a></td></tr>
<tr><td>16</td><td class="te" colspan="3"><a href="Doc01_UserInterface.html#Doc_PreferencePages" title="CDO模型存储库文档中的章节">偏好页面</a></td></tr>
</table>



<h2><a name="Doc_ExplorerPerspective"></a> 1 CDO Explorer透视图</h2>
<p>CDO Explorer透视图可以方便地选择在使用CDO时最常用的视图和快捷方式。它具有以下默认布局：</p><p align="center"><img src="explorer-perspective.png">


</p><h2><a name="Doc_RepositoriesView"></a> 2 CDO存储库视图</h2>
<p>CDO存储库视图显示配置为在当前工作空间中使用的各种存储库和连接。它允许创建新的存储库和连接，重命名或删除现有的存储库和连接，管理它们中的分支，最后从它们中检出：</p><p align="center"><img src="repositories-view.png">

 </p><p>与<a href="Doc01_UserInterface.html#Doc_SessionsView" title="Chapter in CDO Model Repository Documentation">CDO会话</a>中的<a href="Doc01_UserInterface.html#Doc_SessionsView" title="Chapter in CDO Model Repository Documentation">会话</a>相比，Eclipse重新启动时会记住CDO存储库视图中配置的<a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">视图</a>存储库和连接。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc02_ManagingRepositories.html" title="CDO模型存储库文档中的文章">管理存储库</a></li>
	<li><a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库中签出</a></li>
</ul>


<h2><a name="Doc_AdministrationView"></a> 3 CDO管理视图</h2>
<p>CDO Administration视图显示已配置的服务器并实时列出其发现的存储库。可以添加新服务器，可以删除现有服务器。可以在服务器中创建新存储库，并可以删除现有存储库。如果存储库支持安全性，即身份验证和授权，则可以在其上打开各种安全性概念的编辑器，例如用户，组，角色和权限：</p><p align="center"><img src="administration-view.png">


</p><h2><a name="Doc_CollaborationView"></a> 4 CDO协作视图</h2>
<p>CDO协作视图显示连接到当前存储库的其他用户，更确切地说是其会话。在此视图中双击用户时，会弹出一个对话框，要求您提供要发送给所选用户的短消息。目标用户需要订阅接收消息。此视图是基于CDO协议的自定义聊天协议的一个非常简单的示例：</p><p align="center"><img src="collaboration-view.png">

 </p><p><a href="../../javadoc/org/eclipse/emf/cdo/session/remote/CDORemoteSessionManager.html" title="org.eclipse.emf.cdo.session.remote中的接口"><code>CDORemoteSessionManager</code></a>介绍了远程消息订阅的详细信息以及如何提供自定义消息处理程序。

</p><h2><a name="Doc_WatchListView"></a> 5 CDO观察列表视图</h2>
<p>CDO监视列表视图是<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOView.Options.html#addChangeSubscriptionPolicy(org.eclipse.emf.cdo.view.CDOAdapterPolicy)" title="org.eclipse.emf.cdo.view中的方法。CDOView。选项"><code>change subscriptions</code></a>的简单示例。模型对象可以从任何位置拖动并放在监视列表视图中，以创建一个表条目，显示从任何用户到所选模型对象的最新更改：</p><p align="center"><img src="watchlist-view.png">


</p><h2><a name="Doc_TimeMachineView"></a> 6 CDO时间机器视图</h2>
<p>CDO Time Machine视图提供了一个滑块控件，可用于查看不同历史时间的模型。仅当选择历史签出中的模型或模型对象时，才会启用时间滑块：</p><p align="center"><img src="timemachine-view.png">

 </p><p>所选历史结帐中的资源树以及在此结帐时打开的所有编辑器的内容实时更改，同时在时间上来回拖动滑块控件。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc04_CheckingOut.html#Doc_HistoricalCheckouts" title="CDO模型存储库文档中的章节">在线历史结帐</a></li>
</ul>


<h2><a name="Doc_SessionsView"></a> 7 CDO会议视图</h2>
<p>CDO Sessions视图提供了一种相当技术性的方法来处理存储库中的模型，并且现在主要通过<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a>和<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer集成</a>的更方便功能取代。尽管如此，它仍可用于打开远程存储库的会话，打开模型视图和会话事务，浏览存储库的资源树，在所选资源上打开模型编辑器等等：</p><p align="center"><img src="sessions-view.png">

 </p><p>请注意，在Eclipse重新启动时<b>不会</b>记住在CDO会话视图中打开的会话。

</p><h2><a name="Doc_ServerBrowser"></a> 8 CDO服务器浏览器</h2>
<p>CDO服务器浏览器允许在Web浏览器中内省<a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">本地存储库</a>的内部数据或<a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">脱机检出的</a>本地复制存储库：</p><p align="center"><img src="server-browser.png">

 </p><p>它仅用于测试和调试目的。它<b>并不</b>意味着可以扩展到任意存储库大小的生产工具！

</p><h2><a name="Doc_CheckoutWizard"></a> 9 CDO Checkout Wizard</h2>
<p>CDO提供了Eclipse导入向导，无需打开<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a>即可从存储库创建签出：</p><p align="center"><img src="import-wizard.png">
</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库中签出</a></li>
</ul>


<h2><a name="Doc_ModelEditor"></a> 10 CDO模型编辑器</h2>
<p>CDO模型编辑器是存储库中模型资源的通用编辑器。它在可编辑的结构化树中显示资源的内容，并允许通过New Child，New Sibling或Delete上下文菜单操作修改资源的树结构。可以使用拖放移动或复制模型元素。可以在“ <a href="Doc01_UserInterface.html#Doc_PropertySheetIntegration" title="CDO模型存储库文档中的章节">属性”视图中</a>编辑它们的属性和引用。
 </p><p>CDO模型编辑器是一个生成的EMF编辑器，具有一些其他功能，如实时锁定装饰和早期冲突检测：</p><p align="center"><img src="model-editor.png">

 </p><p>CDO模型编辑器是否实际支持编辑显示的模型取决于模型的结帐是否是<a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">事务性的</a> 。

</p><h2><a name="Doc_ProjectExplorerIntegration"></a> 11 Project Explorer集成</h2>
<p>从CDO 4.4开始，在存储库中或从存储库中使用模型的首选方法是Project Explorer集成。这种集成以<i>结账</i>的概念为中心。可以使用<a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="Chapter in CDO Model Repository Documentation">CDO Checkout向导</a>在<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a>或Project Explorer视图中创建<a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">签出</a> 。创建后，结帐将显示在Project Explorer中，如工作区项目，并使用小的蓝色存储库图像进行修饰。与工作空间项目相比，显示的检出在工作空间中没有物理表示。
 </p><p>签出存储库的文件夹，资源和模型元素显示在结帐时，可以通过拖放直接修改以移动或复制它们，或者通过双击打开资源上的<a href="Doc01_UserInterface.html#Doc_ModelEditor" title="CDO模型存储库文档中的章节">CDO模型编辑器</a>或模型元素上的EMF Forms对话框：</p><p align="center"><img src="project-explorer.png">

 </p><p>上下文菜单提供各种结帐功能，例如重命名，关闭或删除它们，在不同视图中显示它们，将它们切换到不同的分支或分支点，将它们与不同的分支或分支点进行比较，以及从不同的分支或分支进行合并点。
 </p><p>与<a href="Doc01_UserInterface.html#Doc_SessionsView" title="Chapter in CDO Model Repository Documentation">CDO会话视图</a>中的<a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">会话</a>相比，在Eclipse重新启动时会记住在Project Explorer视图中创建的检出项。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库中签出</a></li>
	<li><a href="Doc05_UsingCheckouts.html" title="CDO模型存储库文档中的文章">使用Checkout</a></li>
</ul>


<h2><a name="Doc_PropertySheetIntegration"></a> 12物业单整合</h2>
<p>CDO与Eclipse的Properties视图集成，并提供有关在当前透视图中选择的元素的各种语义和技术信息：</p><p align="center"><img src="property-sheet.png">

 </p><p>对于在<a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">事务</a>检出的编辑器中选择的模型元素，属性表集成支持修改元素的属性和引用值。

</p><h2><a name="Doc_HistoryIntegration"></a> 13历史整合</h2>
<p>CDO与Eclipse的History视图集成，并显示所选存储库，分支，结帐或模型元素的提交树：</p><p align="center"><img src="history.png">

 </p><p>如果“历史记录”视图未对选择更改做出反应，请激活“历史记录”视图工具栏中的“使用编辑器和选择链接”按钮。
 </p><p>提交本地事务时，以及其他用户从其他工作站提交更改时，将实时更新提交树。
 </p><p>如果当前提交树所基于的存储库支持分支（请参阅<a href="Doc03_UsingBranches.html" title="CDO模型存储库文档中的文章">使用分支</a> ），则可以在“历史记录”视图中直接从所选提交中分叉新分支。
 </p><p>也可以通过打开上下文菜单并选择Checkout操作或Checkout As操作，直接从所选提交创建新的签出。有关结帐过程的详细信息，请参阅<a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">CDO Checkout向导</a>或<a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库</a>签出。

</p><h2><a name="Doc_CompareIntegration"></a> 14比较整合</h2>
<p>CDO与EMF Compare集成，提供高效，可扩展的比较编辑器。不同的分支或不同的分支点可以相互比较：</p><p align="center"><img src="compare.png">

 </p><p>CDO还提供高效且可扩展的合并编辑器。不同的分支或不同的分支点可以相互合并：</p><p align="center"><img src="merge.png">

 </p><p>比较和合并可以从<a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录视图</a> ， <a href="Doc05_UsingCheckouts.html" title="CDO模型存储库文档中的文章">结帐</a>的上下文菜单中开始，也可以通过在按住Shift键（用于比较）或Ctrl键的同时将分支，分支点或结账拖放到<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer</a>中的其他结账时启动（用于合并）。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="http://www.eclipse.org/emf/compare/documentation/latest/user/user-guide.html" title="CDO模型存储库文档中的文章">EMF比较指南</a></li>
	<li><a href="Doc05_UsingCheckouts.html#Doc_ComparingCheckouts" title="CDO模型存储库文档中的章节">比较结账</a></li>
	<li><a href="Doc09_TechnicalBackground.html#Doc_BackgroundCompare" title="CDO模型存储库文档中的章节">比较整合的技术背景</a></li>
</ul>


<h2><a name="Doc_FormsIntegration"></a> 15表格整合</h2>
<p>CDO与EMF Forms集成，为<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer</a>中显示的模型元素提供通用编辑对话框：</p><p align="center"><img src="object-edit.png">
</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="http://www.eclipse.org/ecp/documentation.html" title="CDO模型存储库文档中的文章">EMF表格指南</a></li>
	<li><a href="Doc07_UsingModels.html#Doc_EditingModelElements" title="CDO模型存储库文档中的章节">在对话框中编辑模型元素</a></li>
</ul>


<h2><a name="Doc_PreferencePages"></a> 16个偏好页面</h2>
<p>当前可以在CDO Explorer首选项页面上调整的唯一设置是在最后一次使用后保持存储库连接的分钟数：</p><p align="center"><img src="preferences.png">


</p><p align="right">
<a href="index.html" title="向后退到用户指南"><img src="../../images/backward.png" border="0"></a> <a href="Doc02_ManagingRepositories.html" title="转发到管理存储库"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="1429.ch03s20s02.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>3.20.2。�使用对象映射编辑器</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula User Manual"></link>
<link rel="up" href="ch03s20.html" title="3.20.�Object mapping"></link>
<link rel="prev" href="ch03s20s01.html" title="3.20.1.�Object mapping"></link>
<link rel="next" href="ch03s20s03.html" title="3.20.3.�Deleting from the Object Mapping Editor"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">3.20.2。�使用对象映射编辑器</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch03s20s01.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">3.20。�对象映射</th>
<td width="20%" align="right">� <a href="ch03s20s03.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula用户手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch03.html">任务</a></span> &gt; <span class="breadcrumb-link"><a href="ch03s20.html">对象映射</a></span> &gt; <span class="breadcrumb-node">使用对象映射编辑器</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="object-mapping-editor"></a> 3.20.2。�使用对象映射编辑器</h3></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="opening-the-object-mapping-editor"></a> 3.20.2.1。�打开对象映射编辑器</h4></div></div></div>
<a name="object-mapping-editor.testExecViewContextId"></a><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<p>选择要映射并选择其组件的测试套件，打开对象映射编辑器：</p>
<p>
          <span class="menuPath">使用</span> - &gt; <span class="menuPath">对象映射编辑器</span> <span class="menuPath">打开</span> 。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>通过工具栏启动对象映射模式时，对象映射编辑器也会自动打开。
        </strong></span></td>
</tr></tbody>
</table>
<p>将出现此Test Suite使用的AUT的对象映射编辑器（参见（图<a class="xref" href="ch03s20s05.html#objectmappingeditor" title="Figure3.28。�对象映射编辑器">�3.28，“对象映射编辑器”</a> ））。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>您可以在编辑器的选项卡中查看要映射的AUT的名称。
        </strong></span></td>
</tr></tbody>
</table>
</li></ol></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="the-object-mapping-editor"></a> 3.20.2.2。�对象映射编辑器</h4></div></div></div>
<a name="the-object-mapping-editor.objectMapEditorContextId"></a><p>“对象映射编辑器”中的“对象映射”窗格是执行对象映射的位置。它包含三个主要类别的三个区域。我可以，你可以：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>通过将组件名称拖动到技术名称（已分配或未分配），将（技术名称）分配（映射）到组件名称（ <a class="xref" href="ch03s20s05.html" title="3.20.5。�将收集的技术名称（分配）到组件名称">Section�3.20.5，“将收集的技术名称映射（分配）到组件名称”</a> ）。
         </p></li>
<li class="listitem"><p>为测试创建新的组件名称（ <a class="xref" href="ch03s15s02.html" title="3.15.2。�创建新的组件名称">Section�3.15.2，“创建新的组件名称”</a> ）。
        </p></li>
<li class="listitem"><p>重命名组件名称（ <a class="xref" href="ch03s15s04.html" title="3.15.4。�重命名组件名称">Section�3.15.4，“重命名组件名称”</a> ）。
        </p></li>
<li class="listitem"><p>创建类别并将其映射到它们中（ <a class="xref" href="ch03s20s02.html#working-with-categories-in-the-object-mapping-editor" title="3.20.2.3。�在对象映射编辑器中使用类别">Section�3.20.2.3，“在对象映射编辑器中使用类别”</a> ）。
        </p></li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="working-with-categories-in-the-object-mapping-editor"></a> 3.20.2.3。�在对象映射编辑器中使用类别</h4></div></div></div>
<a name="working-with-categories-in-the-object-mapping-editor.objectMapEditorContextId"></a><a name="working-with-categories-in-the-object-mapping-editor.dialogOMCategoryNewContextId"></a><p>对象映射编辑器中有三个区域，对应于三种类型的名称。
	</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">未分配的组件名称：</span></dt>
<dd><p>这些是您在测试用例或组件名称中使用的名称（ <a class="xref" href="ch03s15s02.html" title="3.15.2。�创建新的组件名称">Section�3.15.2，“创建新组件名称”</a> ）。它们未分配，因为它们尚未映射到技术名称。
          </p></dd>
<dt><span class="term">未分配的技术名称：</span></dt>
<dd><p>这些是您从AUT收集的名称（ <a class="xref" href="ch03s20s04.html" title="3.20.4.�Collecting components (technical names) from the AUT">Section�3.20.4，“</a>从AUT <a class="xref" href="ch03s20s04.html" title="3.20.4。�从AUT收集组件（技术名称）">收集组件（技术名称）”</a> ），但尚未分配给组件名称。
          </p></dd>
<dt><span class="term">分配名称：</span></dt>
<dd><p>有一对已映射到彼此的名称。每个技术名称都可以映射到一个或多个组件名称。此映射告诉ITE您在测试用例中引用了哪些实际组件。
          </p></dd>
</dl></div>
<p>
      <span class="strong"><strong>在对象映射编辑器中创建类别</strong></span><br xmlns:d="http://docbook.org/ns/docbook">我们建议在对象映射编辑器中创建类别，以使您的映射更容易。
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem">
<p>您可以通过以下方式在对象映射编辑器下部的指定名称区域中创建类别和子类别：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>在对象映射编辑器中选择一个指定的名称。
            </p></li>
<li class="listitem"><p>从上下文相关菜单中选择“ <span class="emphasis"><em>创建类别</em></span> ”。
            </p></li>
<li class="listitem">
<p>输入类别的名称</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>您不能在同一级别具有两个具有相同名称的类别。
            </strong></span></td>
</tr></tbody>
</table>
</li>
</ol></div>
</li>
<li class="listitem"><p>映射时，您可以选择要映射到的类别。有关详细<a class="xref" href="ch03s20s02.html#working-with-categories-in-the-object-mapping-editor" title="3.20.2.3.�Working with categories in the Object Mapping Editor">信息，</a>请参见下一节<a class="xref" href="ch03s20s02.html#working-with-categories-in-the-object-mapping-editor" title="3.20.2.3。�在对象映射编辑器中使用类别">Section3.3.20.2.3“使用对象映射编辑器中的类别”</a> 。
        </p></li>
</ul></div>
<p>
      <span class="strong"><strong>在对象映射编辑器中映射到类别</strong></span><br xmlns:d="http://docbook.org/ns/docbook">在对象映射编辑器中创建类别后，您可以选择将从AUT收集的技术名称直接映射到类别中。如果您为每个对话框/窗口创建了一个类别，并且希望将其中的所有组件映射到一个类别，这可能会有所帮助。
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<p>当您处于对象映射模式时，右键单击要映射到的类别，然后选择：</p>
<p>
          <span class="menuPath">将组件映射到此类别</span>
        </p>
<p>使您从AUT收集的技术名称出现在此子类别中。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您已经映射了技术名称，则该名称将显示在“对象映射编辑器”中，但不会移动到该类别中。
        </strong></span></td>
</tr></tbody>
</table>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>状态栏显示您要映射到的类别。
        </strong></span></td>
</tr></tbody>
</table>
</li></ol></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="the-configuration-view-in-the-object-mapping-editor"></a> 3.20.2.4。�对象映射编辑器中的配置视图</h4></div></div></div>
<a name="the-configuration-view-in-the-object-mapping-editor.objectMapEditorContextId"></a><p>在对象映射编辑器的配置视图中，您可以更改测试执行的对象识别。
    </p>
<p>
      <span class="strong"><strong>了解对象识别</strong></span><br xmlns:d="http://docbook.org/ns/docbook">测试执行期间的对象识别基于考虑各种因素的计算。对于某些应用程序，某些因素可能比其他因素更重要，您可以相应地更改其权重。
    </p>
<p>对象位置是<span class="emphasis"><em>启发式</em></span>过程。在测试执行期间，将对AUT中的每个组件进行计算，以查看它与原始映射组件的相似程度。此计算主要基于组件类型 - 如果映射了组合框，则仅考虑组合框。对于相同类型的每个组件，使用加权属性计算与原始的相似性。计算中使用的因素是：</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">名称：</span></dt>
<dd><p>AUT代码中对象的名称，由开发人员给出（如果给出了名称）。
          </p></dd>
<dt><span class="term">路径：</span></dt>
<dd><p>通过AUT层次结构的路由到达此组件。
          </p></dd>
<dt><span class="term">语境：</span></dt>
<dd><p>此组件附近的组件。
          </p></dd>
<dt><span class="term">阈：</span></dt>
<dd><p>这确定了AUT中的组件必须具有的百分比值，以便被视为最初映射的组件。不考虑值低于阈值的组件。在执行期间选择具有高于阈值的最高值的组件。
          </p></dd>
</dl></div>
<p>
      <span class="strong"><strong>对象识别选项</strong></span>您可以使用组合框更改测试执行期间使用的配置文件：</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">标准：</span></dt>
<dd><p>这是默认配置文件。它具有较高的名称权重值和较低的上下文和路径值。门槛是85％。
          </p></dd>
<dt><span class="term">严格：</span></dt>
<dd><p>在此配置文件中，名称，路径和上下文的值与标准配置文件中的值相同。门槛为100％。这意味着组件必须与原始映射的组件完全对应。
          </p></dd>
<dt><span class="term">姓：</span></dt>
<dd><p>在此配置文件中，仅考虑组件名称。仅当组件与原始映射组件具有相同名称时，才会选择该组件。当您确定AUT中的所有组件都具有唯一名称时，可以使用此配置文件。
          </p></dd>
<dt><span class="term">自定义：</span></dt>
<dd><p>此配置文件允许您自己移动滑块。您可以锁定滑块以阻止它们受到其他滑块的影响。
          </p></dd>
</dl></div>
<div class="figure">
<a name="idm139858584814896"></a><div class="figure-contents"><div class="mediaobject"><img src="../images/objectmappingpref.png" xmlns:d="http://docbook.org/ns/docbook"></div></div>
<div class="figure-title">Figure3.27。�对象映射配置</div>
</div>
<br class="figure-break"><p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>手动自定义对象映射设置时要小心。如果您设置的值太严格或严格不够，则可能会出现测试执行问题。
    </strong></span></td>
</tr></tbody>
</table>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>您可以更改各个组件的配置文件，有关详细信息，请参阅<a class="xref" href="ch03s20s07.html" title="3.20.7。�组件特定的配置文件">章节3.20.7，“组件特定配置文件”</a> 。
    </strong></span></td>
</tr></tbody>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="refreshing-the-object-mapping-editor"></a> 3.20.2.5。�重新刷新对象映射编辑器</h4></div></div></div>
<a name="refreshing-the-object-mapping-editor.objectMapEditorContextId"></a><div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>从对象映射编辑器中的上下文相关菜单中选择<span class="emphasis"><em>刷新</em></span> ，或按<span class="input">�F5�</span>刷新对象映射编辑器。
        </p></li>
<li class="listitem"><p>确认您要刷新编辑器。
        </p></li>
</ol></div>
<p>刷新对象映射编辑器时，将收集已添加到此AUT的测试套件的所有新组件名称。
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="finding-components-in-the-aut-via-the-object-mapping-editor-highlight-in-aut"></a> 3.20.2.6。�通过对象映射编辑器在AUT中查找组件：在AUT中突出显示</h4></div></div></div>
<a name="finding-components-in-the-aut-via-the-object-mapping-editor-highlight-in-aut.objectMapEditorContextId"></a><p>在对象映射编辑器中，您可以搜索：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>在测试中使用组件名称的所有位置（ <a class="xref" href="ch03s30s03.html" title="3.30.3。�搜索已使用组件名称的位置">Section�3.30.3，“搜索已使用组件名称的位置”</a> ）</p></li>
<li class="listitem"><p>特定组件名称来自测试的特定位置（ <a class="xref" href="ch03s30s03.html" title="3.30.3。�搜索已使用组件名称的位置">Section�3.30.3，“搜索已使用组件名称的位置”</a> ）</p></li>
<li class="listitem"><p>AUT的技术组件（见下文）。
        </p></li>
</ul></div>
<p>
      <span class="strong"><strong>突出显示AUT中的组件</strong></span>
    </p>
<p>要在AUT中搜索组件，必须打开对象映射编辑器（ <a class="xref" href="ch03s20s02.html#opening-the-object-mapping-editor" title="3.20.2.1。�打开对象映射编辑器">Section�3.20.2.1，“打开对象映射编辑器”</a> ），并且AUT必须正在运行（ <a class="xref" href="ch03s21s02.html" title="3.21.2。�开始AUT">Section�3.21.2，“启动AUT”</a> ）在对象映射模式中（ <a class="xref" href="ch03s20s04.html" title="3.20.4。�从AUT收集组件（技术名称）">Section�3.20.4，“从AUT收集组件（技术名称）”</a> ）。
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>在对象映射编辑器中，右键单击要在AUT中找到其组件的技术名称，然后选择：</p>
<p>
          <span class="menuPath">在AUT中突出显示</span>
        </p>
<p>来自上下文相关菜单。
        </p>
</li>
<li class="listitem">
<p>您选择的技术名称的组件将在AUT中以绿色边框突出显示。</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>您只能突出显示当前在AUT中可见的组件。</strong></span></td>
</tr></tbody>
</table>
</li>
</ol></div>
</div>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="2454.table_of_contents.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><title>目录 -  PHP开发工具帮助</title><link type="text/css" rel="stylesheet" href="css/main.css"></link></head><body dir="ltr"><h1 id="table-of-contents">目录</h1><!--context:table_of_contents--><ul><li><a href="table_of_contents.html">目录</a></li><li><a href="getting_started/index.html">入门</a><ul><li><a href="getting_started/quick_start.html">快速开始</a></li><li><a href="getting_started/basic_tutorial/index.html">基础教程</a><ul><li><a href="getting_started/basic_tutorial/creating_and_uploading_a_project.html">创建项目和文件</a></li><li><a href="getting_started/basic_tutorial/working_with_code_assist.html">使用内容辅助</a></li><li><a href="getting_started/basic_tutorial/working_with_refactoring.html">使用重构</a></li><li><a href="getting_started/basic_tutorial/working_with_the_debugger.html">使用调试器</a></li></ul></li></ul></li><li><a href="concepts/index.html">概念</a><ul><li><a href="concepts/php_support.html">PHP版本支持</a></li><li><a href="concepts/code_assist_concept.html">内容辅助</a></li><li><a href="concepts/syntax_highlighting.html">语法着色</a></li><li><a href="concepts/automatic_insertion.html">自动完成</a></li><li><a href="concepts/matching_brackets.html">匹配括号</a></li><li><a href="concepts/mark_occurrences.html">Mark Occurrences</a></li><li><a href="concepts/code_folding.html">代码折叠</a></li><li><a href="concepts/commenting_code/index.html">代码评论</a><ul><li><a href="concepts/commenting_code/phpdoc_comments.html">phpDoc块评论</a></li><li><a href="concepts/commenting_code/bookmarks.html">书签</a></li></ul></li><li><a href="concepts/hover_support.html">悬停支持</a></li><li><a href="concepts/refactoring.html">重构</a></li><li><a href="concepts/override_indicators.html">覆盖指标</a></li><li><a href="concepts/php_working_sets.html">PHP工作集</a></li><li><a href="concepts/show_type_hierarchy.html">键入层次结构</a></li><li><a href="concepts/php_manual_integration.html">PHP手动集成</a></li><li><a href="concepts/real_time_error_detection.html">实时错误检测</a></li><li><a href="concepts/running.html">运行</a></li><li><a href="concepts/debugging_concept.html">调试</a></li><li><a href="concepts/breakpoints.html">断点</a></li><li><a href="concepts/include_paths.html">PHP包含路径</a></li><li><a href="concepts/build_paths.html">PHP构建路径</a></li><li><a href="concepts/path_mapping.html">路径映射</a></li><li><a href="concepts/javascript.html">JavaScript支持</a></li><li><a href="concepts/mylyn_integration.html">Mylyn集成</a></li><li><a href="concepts/phar_integration.html">Phar集成</a></li><li><a href="concepts/exception_breakpoints.html">异常断点</a></li><li><a href="concepts/profiling_concept.html">剖析</a></li></ul></li><li><a href="tasks/index.html">任务</a><ul><li><a href="tasks/creating_php_projects.html">创建PHP项目</a></li><li><a href="tasks/file_creation/index.html">创建PHP文件</a><ul><li><a href="tasks/file_creation/creating_a_php_file_within_a_project.html">在项目中创建PHP文件</a></li><li><a href="tasks/file_creation/creating_a_new_php_file_outside_of_a_project.html">在项目之外创建PHP文件</a></li><li><a href="tasks/file_creation/opening_an_external_file_in_neon.html">打开外部文件</a></li></ul></li><li><a href="tasks/using_code_assist.html">使用内容辅助</a></li><li><a href="tasks/using_templates.html">使用模板</a></li><li><a href="tasks/drag_and_drop.html">拖放</a></li><li><a href="tasks/formatting_code.html">格式化代码</a></li><li><a href="tasks/using_code_folding.html">使用代码折叠</a></li><li><a href="tasks/searching_for_php_elements.html">搜索PHP元素</a></li><li><a href="tasks/opening_php_elements.html">打开PHP元素</a></li><li><a href="tasks/opening_types_methods.html">打开类型/方法</a></li><li><a href="tasks/using_smart_goto_source.html">使用Smart Goto Source</a></li><li><a href="tasks/viewing_type_hierarchies.html">查看类型层次结构</a></li><li><a href="tasks/creating_php_working_sets.html">创建PHP工作集</a></li><li><a href="tasks/using_mark_occurrences.html">使用Mark Occurrences</a></li><li><a href="tasks/using_refactoring/index.html">使用重构</a><ul><li><a href="tasks/using_refactoring/renaming_files.html">重命名文件</a></li><li><a href="tasks/using_refactoring/renaming_elements.html">重命名元素</a></li><li><a href="tasks/using_refactoring/moving_files.html">移动文件</a></li><li><a href="tasks/using_refactoring/extracting_variables.html">提取变量</a></li><li><a href="tasks/using_refactoring/extracting_methods.html">提取方法</a></li></ul></li><li><a href="tasks/how_to_comment_and_uncomment_php_code.html">添加评论</a></li><li><a href="tasks/commenting_php_docblocks.html">添加PHP DocBlock注释</a></li><li><a href="tasks/accessing_an_existing_cvs_checkout.html">访问现有的CVS结帐</a></li><li><a href="tasks/running_files_and_applications/index.html">运行文件和应用程序</a><ul><li><a href="tasks/running_files_and_applications/running_php_scripts_locally.html">在本地运行PHP脚本</a></li><li><a href="tasks/running_files_and_applications/running_php_scripts_remotely.html">远程运行PHP脚本</a></li><li><a href="tasks/running_files_and_applications/running_php_web_pages.html">运行PHP网页</a></li></ul></li><li><a href="tasks/debugging/index.html">使用调试器</a><ul><li><a href="tasks/debugging/setting_breakpoints.html">设置断点</a></li><li><a href="tasks/debugging/using_the_inspect_action.html">使用Inspect Action</a></li><li><a href="tasks/debugging/locally_debugging_a_php_script.html">本地调试PHP脚本</a></li><li><a href="tasks/debugging/debugging_a_php_web_page.html">调试PHP网页</a></li><li><a href="tasks/debugging/analyzing_debugger_results.html">运行和分析调试器结果</a></li><li><a href="tasks/debugging/setting_exception_breakpoints.html">设置异常断点</a></li><li><a href="tasks/debugging/troubleshooting_remote_debugging/index.html">设置远程调试</a><ul><li><a href="tasks/debugging/troubleshooting_remote_debugging/setting_your_zend_studio_for_eclipse_to_be_an_allowed_host.html">将您的环境设置为允许的主机</a></li><li><a href="tasks/debugging/troubleshooting_remote_debugging/ensuring_the_placement_of_dummy_php.html">确保dummy.php的放置</a></li><li><a href="tasks/debugging/troubleshooting_remote_debugging/adding_a_server_path_map.html">添加服务器位置路径映射</a></li></ul></li></ul></li><li><a href="tasks/php_libraries_preferences/index.html">PHP库首选项</a><ul><li><a href="tasks/php_libraries_preferences/adding_a_php_library.html">添加PHP库</a></li><li><a href="tasks/php_libraries_preferences/adding_external_folders_to_php_libraries.html">将外部文件夹添加到PHP库</a></li><li><a href="tasks/php_libraries_preferences/importing_php_user_libraries.html">导入PHP用户库</a></li><li><a href="tasks/php_libraries_preferences/exporting_php_user_libraries.html">导出PHP用户库</a></li><li><a href="tasks/php_libraries_preferences/editing_php_library_components_or_folders.html">编辑PHP库组件或文件夹</a></li><li><a href="tasks/php_libraries_preferences/editing_php_user_libraries.html">编辑PHP用户库</a></li><li><a href="tasks/php_libraries_preferences/removing_a_php_library_or_library_folder.html">删除PHP库或库文件夹</a></li></ul></li><li><a href="tasks/adding_elements_to_a_project_s_include_path.html">配置项目的PHP包含路径</a></li><li><a href="tasks/configuring_build_paths.html">配置项目的PHP构建路径</a></li><li><a href="tasks/adding_a_server_path_map.html">添加服务器位置路径映射</a></li><li><a href="tasks/using_the_php_html_wysywig_editor.html">创建HTML文件</a></li><li><a href="tasks/mylyn_integration1.html">使用Mylyn集成</a></li><li><a href="tasks/using_javascript/index.html">使用JavaScript进行开发</a><ul><li><a href="tasks/using_javascript/enabling_javascript_support_in_php_projects.html">在PHP项目中启用JavaScript支持</a></li><li><a href="tasks/using_javascript/setting_the_javascript_build_path.html">设置JavaScript构建路径</a></li><li><a href="tasks/using_javascript/viewing_javascript_elements_in_the_outline_view.html">在大纲视图中查看JavaScript元素</a></li><li><a href="tasks/using_javascript/using_javascript_content_assist.html">使用JavaScript内容辅助</a></li><li><a href="tasks/using_javascript/using_javascript_syntax_coloring.html">使用JavaScript语法着色</a></li><li><a href="tasks/using_javascript/using_javascript_mark_occurences.html">使用JavaScript Mark Occurrences</a></li></ul></li><li><a href="tasks/profiling/index.html">使用Profiler</a><ul><li><a href="tasks/profiling/profiling_local_php_script.html">本地分析PHP脚本</a></li><li><a href="tasks/profiling/profiling_php_web_page.html">分析PHP Web页面</a></li><li><a href="tasks/profiling/profiling_with_browser_toolbars.html">使用浏览器工具栏进行分析</a></li><li><a href="tasks/profiling/exporting_profile_sessions.html">导出配置文件会话</a></li><li><a href="tasks/profiling/importing_profile_sessions.html">导入配置文件会话</a></li><li><a href="tasks/profiling/exporting_html_report.html">导出HTML报告</a></li></ul></li></ul></li><li><a href="reference/index.html">参考</a><ul><li><a href="reference/php_perspectives_and_views/index.html">PHP视角和视图</a><ul><li><a href="reference/php_perspectives_and_views/php_perspective_views/index.html">PHP透视</a><ul><li><a href="reference/php_perspectives_and_views/php_perspective_views/php_explorer_view.html">Project Explorer视图</a></li><li><a href="reference/php_perspectives_and_views/php_perspective_views/php_outline_view.html">大纲视图</a></li><li><a href="reference/php_perspectives_and_views/php_perspective_views/type_hierarchy_view.html">键入层次结构视图</a></li></ul></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/index.html">PHP调试透视图</a><ul><li><a href="reference/php_perspectives_and_views/php_debug_perspective/debug_view.html">调试视图[PHP调试透视]</a></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/variables_view.html">变量视图[PHP调试透视]</a></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/breakpoints_view.html">断点视图[PHP调试透视]</a></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/expressions_view.html">表达式视图[PHP调试透视]</a></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/debug_output_view.html">调试输出视图[PHP调试透视]</a></li><li><a href="reference/php_perspectives_and_views/php_debug_perspective/browser_output_view.html">浏览器输出视图[PHP调试透视]</a></li></ul></li><li><a href="reference/php_perspectives_and_views/php_additional_views/index.html">PHP附加视图</a><ul><li><a href="reference/php_perspectives_and_views/php_additional_views/php_functions_view.html">PHP函数视图</a></li><li><a href="reference/php_perspectives_and_views/php_additional_views/project_outline_view.html">PHP项目大纲视图</a></li></ul></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/index.html">PHP Profile Perspective</a><ul><li><a href="reference/php_perspectives_and_views/php_profile_perspective/profiling_monitor_view.html">分析监视器视图</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/profiler_information_view.html">Profiler信息视图</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/execution_statistics_view.html">执行统计视图[PHP Profile Perspective]</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/execution_flow_view.html">执行流程视图[PHP配置文件透视]</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/code_coverage_summary_view.html">代码覆盖率摘要视图[PHP Profile Perspective]</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/code_coverage_view.html">代码覆盖率视图[PHP配置文件透视]</a></li><li><a href="reference/php_perspectives_and_views/php_profile_perspective/function_invocation_statistics_view.html">函数调用统计视图[PHP Profile Perspective]</a></li></ul></li></ul></li><li><a href="reference/menus/index.html">PHP透视菜单</a><ul><li><a href="reference/menus/file/index.html">文件菜单</a><ul><li><a href="reference/menus/file/new.html">新子菜单</a></li><li><a href="reference/menus/file/import.html">导入子菜单</a></li><li><a href="reference/menus/file/export.html">导出子菜单</a></li></ul></li><li><a href="reference/menus/edit.html">编辑菜单</a></li><li><a href="reference/menus/source.html">来源菜单</a></li><li><a href="reference/menus/refactor.html">重构菜单</a></li><li><a href="reference/menus/navigate.html">导航菜单</a></li><li><a href="reference/menus/search.html">搜索菜单</a></li><li><a href="reference/menus/project.html">项目菜单</a></li><li><a href="reference/menus/run.html">运行菜单</a></li><li><a href="reference/menus/navigation.html">导航子菜单</a></li><li><a href="reference/menus/window.html">窗口菜单</a></li><li><a href="reference/menus/help.html">帮助菜单</a></li></ul></li><li><a href="reference/php_perspective_main_toolbar.html">PHP Perspective主工具栏</a></li><li><a href="reference/preferences/index.html">PHP首选项</a><ul><li><a href="reference/preferences/php.html">PHP首选项</a></li><li><a href="reference/preferences/appearance.html">外观偏好</a></li><li><a href="reference/preferences/code_refactor.html">代码重构首选项</a></li><li><a href="reference/preferences/code_style_preferences/index.html">代码样式首选项</a><ul><li><a href="reference/preferences/code_style_preferences/code_templates_preferences.html">代码模板首选项</a></li><li><a href="reference/preferences/code_style_preferences/formatter.html">Formatter首选项</a></li></ul></li><li><a href="reference/preferences/debug/index.html">调试首选项</a><ul><li><a href="reference/preferences/debug/installed_debuggers.html">调试器</a></li><li><a href="reference/preferences/debug/step_filtering_preferences.html">步骤过滤首选项</a></li><li><a href="reference/preferences/debug/launching.html">工作台选项首选项</a></li></ul></li><li><a href="reference/preferences/editor/index.html">编辑器偏好</a><ul><li><a href="reference/preferences/editor/code_assist.html">内容辅助首选项</a></li><li><a href="reference/preferences/editor/folding.html">代码折叠首选项</a></li><li><a href="reference/preferences/editor/hovers.html">悬停首选项</a></li><li><a href="reference/preferences/editor/mark_occurences.html">标记出现偏好</a></li><li><a href="reference/preferences/editor/save_actions.html">保存操作首选项</a></li><li><a href="reference/preferences/editor/syntax_coloring.html">语法着色首选项</a></li><li><a href="reference/preferences/editor/templates.html">模板首选项</a></li><li><a href="reference/preferences/editor/typing.html">键入首选项</a></li></ul></li><li><a href="reference/preferences/new_project_layout_preferences.html">新项目布局首选项</a></li><li><a href="reference/preferences/php_executables/index.html">PHP可执行文件首选项</a><ul><li><a href="reference/preferences/php_executables/php-execution-environment.html">PHP执行环境</a></li></ul></li><li><a href="reference/preferences/php_interpreter.html">PHP解释器首选项</a></li><li><a href="reference/preferences/profile/index.html">档案首选项</a></li><li><a href="reference/preferences/path_variables.html">路径变量首选项</a></li><li><a href="reference/preferences/php_manual.html">PHP手动首选项</a></li><li><a href="reference/preferences/php_servers.html">PHP服务器首选项</a></li><li><a href="reference/preferences/configuring_tunneling_debug_preferences.html">配置隧道调试首选项</a></li><li><a href="reference/preferences/code_coverage.html">代码覆盖率首选项</a></li><li><a href="reference/preferences/validation/index.html">验证首选项</a><ul><li><a href="reference/preferences/validation/task_tags.html">任务标签首选项</a></li></ul></li></ul></li><li><a href="reference/php_project_properties/index.html">PHP项目属性</a><ul><li><a href="reference/php_project_properties/resource_properties.html">资源属性</a></li><li><a href="reference/php_project_properties/builders_properties.html">建筑商物业</a></li><li><a href="reference/php_project_properties/code_style_properties/index.html">代码样式属性</a><ul><li><a href="reference/php_project_properties/code_style_properties/code_templates_properties.html">代码模板属性</a></li><li><a href="reference/php_project_properties/code_style_properties/formatter_properties.html">格式化程序属性</a></li></ul></li><li><a href="reference/php_project_properties/php_build_path_properties.html">PHP构建路径属性</a></li><li><a href="reference/php_project_properties/php_debug_properties.html">PHP调试属性</a></li><li><a href="reference/php_project_properties/php_include_path_properties.html">PHP包含路径属性</a></li><li><a href="reference/php_project_properties/php_interpreter_properties.html">PHP解释器属性</a></li><li><a href="reference/php_project_properties/php_task_tags_properties.html">PHP任务标签属性</a></li><li><a href="reference/php_project_properties/project_references_properties.html">项目参考属性</a></li><li><a href="reference/php_project_properties/run_debug_settings_properties.html">运行/调试设置属性</a></li><li><a href="reference/php_project_properties/editor/index.html">编辑器属性</a><ul><li><a href="reference/php_project_properties/editor/save_actions_properties.html">保存操作属性</a></li></ul></li><li><a href="reference/php_project_properties/validation_properties/index.html">验证属性</a><ul><li><a href="reference/php_project_properties/validation_properties/task_tags_properties.html">任务标签属性</a></li></ul></li></ul></li><li><a href="reference/php_icons.html">PHP图标</a></li><li><a href="reference/keymap.html">按键图</a></li></ul></li><li><a href="video_tutorials.html">视频教程</a></li><li><a href="legal.html">法律</a></li></ul><div class="footer">
    <p>PHP开发工具6.2.0-201812112302的<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=PDT&amp;component=Documentation&amp;short_desc=Bug in table_of_contents.html" target="_BLANK">文档</a> ，报告<a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=PDT&amp;component=Documentation&amp;short_desc=Bug in table_of_contents.html" target="_BLANK">文档错误（</a>如果有）。
    </p>
</div></body></html><html id="0760.jdt_whatsnew.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="copyright" content="Copyright (c) Eclipse contributors and others 2018, 2019. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
<meta http-equiv="Content-Language" content="en-us"></meta>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<link rel="STYLESHEET" href="../book.css" type="text/css"></link>
<style type="text/css">body {
  max-width: 900px;
}
table.news col.title {
  width: 30%;
}
/* img {max-width: 520px;} */
table.news {
  table-layout: fixed;
  border-collapse: collapse;
  width: 100%;
}
table.news td {
  border-top: solid thin black;
  padding: 10px;
  overflow: visible;
}
table.news tr {
  vertical-align: top;
}
table.news tr td.section {
  font-size: 20px;
  font-weight: bold;
}
table.news tr td.title {
  vertical-align: top;
  font-weight: bold;
}
table.news tr td.content {
  vertical-align: top;
}
ul {
  padding-left: 13px;
}
</style>
<title>Eclipse 4.12（JDT）中的新功能</title>
</head>

<body dir="ltr">
<h2>Eclipse 4.12（JDT）中的新功能</h2>
<p>以下是对Eclipse 4.12版本的Java开发工具（JDT）所做的一些更有趣或重要的更改的描述。它们分为：</p>
<ul>
	<li><a href="#Java12">Java™12支持</a></li>
	<li><a href="#JavaEditor">Java编辑器</a></li>
	<li><a href="#JavaViewsAndDialogs">Java视图和对话框</a></li>
	<li><a href="#Debug">调试</a></li>
	<li><a href="#JDTDev">JDT开发人员</a></li>
</ul>

<p>另请参阅<b><a href="../../org.eclipse.platform.doc.user/whatsNew/platform_whatsnew.html">Eclipse平台</a></b>有关<b><a href="../../org.eclipse.platform.doc.user/whatsNew/platform_whatsnew.html">平台</a></b>更改<b><a href="../../org.eclipse.platform.doc.user/whatsNew/platform_whatsnew.html">的新</a></b>文档。</p>
<p>我们还建议您阅读<a href="../tips/jdt_tips.html">提示和技巧</a> 。</p>
<br>

<!-- ****************** START OF N&N TABLE****************** -->
<table class="news">
<colgroup>
  <col class="title">
  <col>
</colgroup>
<tbody>

  <td><!-- ******************* Java 12 Support ************************************* -->
  <tr>
    </tr></td><td id="Java12" class="section" colspan="2">
    <h2>Java™12支持</h2>
    </td>
  
  
  <tr id="quickfix-change-compliance-12"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=543781 -->
    </td><td class="title">将项目合规性和JRE更改为12</td>
    <td class="content">快速修复将<b>项目合规性和JRE更改为12</b> ，以将当前项目更改为与Java 12兼容。
    <p>
      <img src="images/quickfix-change-compliance-12.png" alt="">
    </p>
    </td>
  </tr>
   
  <tr id="enable-preview"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=542579 -->
    </td><td class="title">启用预览功能</td>
    <td class="content">可以使用<b>“首选项”&gt;“Java”&gt;“编译器”&gt;“启用预览功能”</b>选项启用Java 12中的<b>预览功能</b> 。可以使用<b>具有严重性级别</b>选项的<b>预览功能</b>来配置这些预览功能的问题严重性。
    <p>
      <img src="images/enable-preview.png" alt="">
    </p>
    </td>
  </tr>

  <tr id="quickfix-enable-preview-12"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=544257 -->
    </td><td class="title">设置启用预览功能</td>
    <td class="content"><b>提供了</b>对首选项中<b>启用预览功能</b>选项的快速修复。
    <p>
      <img src="images/enable_preview_features_quickfix.png" alt="">
    </p>
    </td>
  </tr>
  
  <tr id="quickfix-configure-severity-12"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=543669 -->
    </td><td class="title">配置预览功能的问题严重性</td>
    <td class="content">快速修复<b>配置问题严重性</b>可用于更新Java 12中预览功能的问题严重性。
    <p>
      <img src="images/quickfix-configure-severity-12.png" alt="">
    </p>
    </td>
  </tr>
   
  <tr id="quickfix-default-switch-statement"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=543665 -->
    </td><td class="title">为switch语句添加默认大小写</td>
    <td class="content">快速修复<b>添加“默认”大小写</b>以将默认大小写添加到Java 12中的增强型switch语句。
    <p>
      <img src="images/quickfix-default-switch-statement.png" alt="">
    </p>
    </td>
  </tr>

  <tr id="quickfix-missing-case-switch-statement"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545259 -->
    </td><td class="title">将缺少的case语句添加到switch语句中</td>
    <td class="content">快速修复为Java 12中的增强型switch语句提供了<b>缺少的case语句</b> 。
    <p>
      <img src="images/quickfix-missing-case-switch-statement.png" alt="">
    </p>
    </td>
  </tr>

  <tr id="quickfix-default-switch-expression"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545256 -->
    </td><td class="title">添加默认大小写以切换表达式</td>
    <td class="content">快速修复<b>添加“默认”大小写</b>以将默认大小写添加到开关表达式。
    <p>
      <img src="images/quickfix-default-switch-expression.png" alt="">
    </p>
    </td>
  </tr>

  <tr id="quickfix-missing-case-switch-expression"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545340 -->
    </td><td class="title">添加缺少的case语句来切换表达式</td>
    <td class="content">快速修复为switch表达式<b>添加了缺少的case语句</b> 。
    <p>
      <img src="images/quickfix-missing-case-switch-expression.png" alt="">
    </p>
    </td>
  </tr>

  <tr id="switch-spaces"><td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545423 -->
    </td><td class="title">在'switch'中格式化空格</td>
    <td class="content">由于Java 12在<code>switch</code>结构中引入了一些新功能，因此formatter配置文件有一些新设置。这些设置允许您控制箭头操作符周围的空格（分别用于<code>case</code>和<code>default</code> ）以及多值情况下的逗号。
      <p>可以在<b>配置文件编辑器</b> （ <b>首选项&gt; Java&gt;代码样式&gt;格式化程序&gt;编辑...</b> ）中的<b>空白&gt;控制语句&gt;'开关'</b>子部分下找到这些设置。
      </p>
      <p>
        <img src="images/formatter-switch.png" alt="">
      </p>
    </td>
  </tr>

  <tr id="split-switch-case-labels"><td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545261 -->
    </td><td class="title">分体式开关盒标签</td>
    <td class="content">由于Java 12引入了将多个<code>switch</code>案例标签分组为单个案例表达式的功能，因此提供了快速帮助，允许将这些分组标签拆分为单独的案例语句。
      <p>
        <img src="images/split-switch-case-labels.png" alt="">
      </p>
    </td>
  </tr>
  	
  <td><!-- ******************* End of Java 12 Support ************************************* -->

  <!-- ******************* JUnit ************************************* -->
  <!--
  <tr>
    <td id="JUnit" class="section" colspan="2">
    <h2>JUnit</h2>
    </td>
  </tr>
  -->
  <!-- ******************* End of JUnit ************************************* -->

  <!-- ******************* Java Editor ************************************* -->
  <tr>
    </tr></td><td id="JavaEditor" class="section" colspan="2">
    <h2>Java编辑器</h2>
    </td>
  

  <tr id="parameter-name-codemining"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=529011 -->
   </td><td class="title">在代码上显示方法参数名称作为代码挖掘</td>
    <td class="content">在<b>Java&gt;编辑器&gt;代码挖掘</b>首选项中，您现在可以启用“ <b>显示参数名称”</b>选项。这将在方法或构造函数调用中将参数名称显示为代码挖掘，以用于对于人类读者而言分辨率可能不明显的情况。
      <p>例如，如果方法调用中的参数名称与参数名称不完全匹配，或者参数名称不包含参数名称作为子字符串，则将显示代码挖掘。
      </p>
      <p>
        <img src="images/parameter-name-codeminings.png" alt="">
      </p>
    </td>
  </tr>
  <tr id="method-implementation-codemining"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=529011 -->
   </td><td class="title">显示方法的实现数量作为代码挖掘</td>
    <td class="content">在<b>Java&gt;编辑器&gt;代码矿业</b>的喜好， <b>选择</b>与<b>参考文献展（包括实现）</b> <b>实现形式</b> - &gt; <b>方法</b>选项现在显示的方法的实现。
      <p>
        <img src="images/method-implementation-codeminings.png" alt="">
      </p>
      <p>单击方法实现将显示“ <b>搜索”</b>视图，该视图显示子类型中方法的所有实现。
      </p>
      <p>
        <img src="images/method-implementation-codeminings-click.png" alt="">
      </p>
    </td>
  </tr>
  <tr id="ctrl-click-codemining"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=529011 -->
   </td><td class="title">从代码挖掘中打开编辑器中的单个实现/引用</td>
    <td class="content">启用<b>Java&gt;编辑器&gt;代码挖掘</b>首选项并显示单个实现或引用时，将光标移到注释上并使用<b>Ctrl +单击</b>将打开编辑器并显示单个实现或引用。
      <p>
        <img src="images/ctrlclickimpl.png" alt="">
      </p>
    </td>
  </tr>

  <tr id="service-provider-constructor-quick-fix"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=541261 -->
   </td><td class="title">服务提供者构造函数的其他快速修复</td>
    <td class="content">当<code>module-info.java</code>文件中定义的服务具有无参数构造函数不可见或不存在的服务提供者实现时，提供适当的快速修复。
      <p>
        <img src="images/service-provider-create-constructor.png" alt="">
      </p>
         <p>
        <img src="images/service-provider-change-constructor-visibility.png" alt="">
      </p>
    </td>
  </tr>
  
  <tr id="new-switch_labeled_statment_expression_template"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545417 -->
      </td><td class="title">用于创建Switch Labeled Statement和Switch Expressions的模板</td>
      <td class="content"><b>Java编辑器</b>现在提供了用于创建交换机标记语句和切换表达式的新模板。在switch语句中，有三个新模板： <b>switch标签语句</b> ， <b>switch case表达式</b>和<b>switch标签表达式</b> ，如下所示。这些新模板可用于符合Java 12或更高级别的Java项目。
          <p>
              <img src="images/switch_labeled_statement.png" alt="">
          </p>
          <p>
              <img src="images/switch_case_expression.png" alt="">
          </p>
          <p>
              <img src="images/switch_labeled_expression.png" alt="">
          </p>如果将<b>switch</b>用作表达式，则只有<b>switch case表达式</b>和<b>切换标记的表达式</b>模板可用，如下所示：<p>
              <img src="images/switch_expression_templates.png" alt="">
          </p>
           
      </td>
  </tr>
  <td><!-- ******************* End of Java Editor ************************************* -->

  <!-- ******************* Java Views and Dialogs ************************************* -->
  <tr>
    </tr></td><td id="JavaViewsAndDialogs" class="section" colspan="2">
    <h2>Java视图和对话框</h2>
    </td>
  
  
  <tr id="comment-generation-checkbox"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=545011 -->
   </td><td class="title">在模块和包中启用注释生成</td>
    <td class="content">现在可以使用一个选项在创建<code>module-info.java</code>或<code>package-info.java</code>时启用/禁用注释生成。
      <p>
        <img src="images/module-info-comment-generation-check-box.png" alt="">
      </p>
         <p>
        <img src="images/package-info-comment-generation-checkbox.png" alt="">
      </p>
    </td>
  </tr>
  <tr id="getter-setter-quick-assist"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=232920 -->
      </td><td class="title">改进了“创建getter和setter”快速辅助</td>
      <td class="content">从字段创建getter和setter方法的快速帮助不再强制您创建两者。
          <p>
              <img src="images/getter-setter-dialog-new.png" alt="">
          </p>
      </td>
  </tr>
  <tr id="quickfix-open-missing-projects"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=343121 -->
      </td><td class="title">快速修复以打开所有必需的已关闭项目</td>
      <td class="content">现在，可以在“ <b>问题”</b>视图中找到打开所有必需已关闭项目的快速修复程序。
          <p>
              <img src="images/quickfix-open-missing-projects-problem-view.png" alt="">
          </p>
          <p>
              <img src="images/quickfix-open-missing-projects.png" alt="">
          </p>
      </td>
  </tr>
  <tr id="buildpath-module-dependencies"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=546352 -->
  	</td><td class="title">用于配置<b>模块依赖关系的</b>新UI</td>
  	<td class="content"><b>Java Build Path</b>配置现在有一个新的选项卡<b>Module Dependencies</b> ，它将逐步替换此对话框其他选项卡上之前隐藏在<b>Is Modular</b>节点后面的选项。新选项卡提供了一种直观的方式来配置所有与模块相关的选项，Java 9引入了新的命令行选项，如<code>--limit-modules</code>等。<p>
  			<a href="images/module-dependencies.png"><img src="images/module-dependencies-cropped.png" alt="“模块依赖关系”对话框"></a>
  		</p>
  		<p>该对话框重点介绍如何构建一个Java项目，这里是“org.greetings”。
		</p><p>在此焦点模块下方，左侧窗格显示参与构建的所有模块，其中装饰A和S分别标记自动模块和系统模块。可以使用<b>Add System Module ...</b>和<b>Remove</b>按钮（对应于<code>--add-modules</code>和<code>--limit-modules</code> ）修改系统模块（来自JRE）的范围。
 		</p><p>在左侧窗格中选择模块后，右侧窗格允许为此模块配置以下属性：</p>
		<dl>
		<dt><b>阅读模块：</b></dt>
		<dd>选择应该可以从所选模块访问的其他模块（对应于<code>--add-reads</code> ）</dd>
		<dt><b>暴露包装：</b></dt>
		<dd>从所选模块中选择要公开的其他包（“导出”或“打开”）（对应于<code>--add-exports</code>或<code>--add-opens</code> ）</dd>
		<dt><b>补丁：</b></dt>
		<dd>向所选模块添加更多包和类（对应于<code>--patch-module</code> ）</dd>
		</dl>
  	</td>
  </tr>
 
  <td><!-- ******************* End of Java Views and Dialogs ************************************* -->

  <!-- ******************* Java Compiler ************************************* -->

  <tr>
    </tr></td><td id="JavaCompiler" class="section" colspan="2">
    <h2>Java编译器</h2>
    </td>
  
  <tr id="new-java-index">
    <td class="title">实验性Java索引已经退役</td>
    <td class="content">Eclipse 4.7引入了一个新的实验性Java索引，默认情况下已禁用。<br>由于缺乏适当支持所有Java 9+语言更改的资源，从Eclipse 4.12开始，此索引不再可用。
      <p>将删除在<b>Preferences&gt; Java中</b>启用它的<b>首选项，</b>并始终使用旧索引。
      </p>
      <b>注意：</b> <b>Preferences&gt; Java&gt; Rebuild Index</b>按钮可用于删除现有索引文件和可用磁盘空间。
    </td>
  </tr>

  <td><!-- ******************* End of Java Compiler ************************************* -->

  <!-- ******************* Java Formatter ************************************* -->
  <!--
  <tr>
    <td id="JavaFormatter" class="section" colspan="2">
    <h2>Java Formatter </h2>
    </td>
  </tr>
  -->
  <!-- ******************* End of Java Formatter ************************************* -->
  
  <!-- *********************** Debug ******************************** -->
  <tr>
    </tr></td><td id="Debug" class="section" colspan="2">
    <h2>调试</h2>
    </td>
  
   <tr id="run-to-line-in-annotation-ruler"><td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=498428 -->
    </td><td class="title">按Ctrl + Alt +'运行到行'并单击注释标尺</td>
    <td class="content">新的快捷键<b>Ctrl + Alt + Click</b>已添加到注释标尺中，该标尺将调用<b>“Run to Line”</b>命令并将程序执行带到调用行。
      <p>
      	<img src="images/run-to-line.png" alt="">
      </p>
    </td>
  </tr>
  
  <tr id="content-assist-debug-shell"><td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=546071 -->
    </td><td class="title">Debug Shell中的内容辅助</td>
    <td class="content">现在， <b>Debug Shell中</b>提供了内容辅助<b>（Ctrl + Space）</b>支持。
      <p><img src="images/content-assist-debug-shell.png" alt=""></p>
    </td>
  </tr>
  
  <tr id="jstc-clear-initial-message"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=343023 -->
    </td><td class="title">首次编辑时清除Java堆栈跟踪控制台使用提示</td>
    <td class="content"><b>Java Stack Trace Console</b>在第一次打开时显示使用提示。现在，当用户开始键入或粘贴堆栈跟踪时，将自动删除此消息。
      <p><img src="images/jstc-initial-clear.png" alt=""></p>
    </td>
  </tr>
  
  <tr id="lambda-variables-variable-view"> <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=534687 -->
    </td><td class="title">变量视图中显示的Lambda变量名称</td>
    <td class="content">现在，在工作空间中调试项目时，Lambda变量名称将显示在“ <b>变量”</b>视图中。
      <p><img src="images/lambda-variables-view.png" alt=""></p>
    </td>
  </tr>
  
  <td><!--************************ End of Debug ******************************** -->

  <!-- *********************** JDT Developers ******************************** -->
  <tr>
    </tr></td><td id="JDTDev" class="section" colspan="2">
    <h2>JDT开发人员</h2>
    </td>
  
  
  <td><!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=544362 -->
  <!-- https://bugs.eclipse.org/bugs/show_bug.cgi?id=540485 -->
    
  <tr id="javadoc-support-tags"> 
   </tr></td><td class="title">支持新的Javadoc标记</td>
    <td class="content">现在，编译器支持以下Javadoc标记并自动完成。
      <p>JDK 8中引入的标签：<br>
		<code>@apiNote</code><br>
		<code>@implSpec</code><br>
		<code>@implNote</code>
	  </p>
	  <p>JDK 9中引入的标签：<br>
		<code>@指数</code><br>
		<code>@隐</code><br>
		<code>@Provides</code><br>
		<code>@uses</code>
	  </p>
	  <p>JDK 10中引入的标签：<br>
		<code>@摘要</code>
	  </p>
    </td>
  
 
  
  <td><!-- *********************** End of JDT Developers ******************************** -->
</td></tbody>
</table>
<!-- ****************** END OF N&N TABLE ****************** -->

</body>
</html><html id="2382.DocTaskComposition.html" dir="ltr"></html><html dir="ltr">

<head>
<title>任务组合（Oomph设置文档）</title>

<link rel="stylesheet" href="../book.css"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Task Composition (Oomph Setup Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>任务组合</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="DocSetupResource.html" title="向后设置资源"><img src="../../images/backward.png" border="0"></a> <a href="DocTaskExecution.html" title="转发到任务执行"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p>通过从可用<a href="DocScope.html" title="Oomph设置文档中的文章">范围</a>收集<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a>列表以准备<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">任务执行</a>来驱动安装和配置过程。
 </p>

<h2><a name="ScopeList"></a> 1范围清单</h2>
<p>在准备收集任务列表时，收集有序<a href="DocScope.html" title="Oomph设置文档中的文章">范围</a>列表。

<a name="ScopeList.scopeList">对于<a href="../user/wizard/DocProjectPage.html" title="Oomph设置文档中的文章">项目页面</a>或<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区中</a>指定的每个<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流</a> ，将重复以下收集范围的过程：<ul>

 <li>访问<a href="../user/wizard/DocProductPage.html" title="Oomph设置文档中的文章">产品页面</a>或<a href="DocScope.html#DocInstallation" title="Oomph设置文档中的章节">安装中</a>选择的<a href="DocScope.html#DocVersion" title="Oomph设置文档中的章节">产品版本</a> 。
 <ul>
 <li>该产品版本的含有添加<a href="DocScope.html#DocProduct" title="Oomph设置文档中的章节">产品</a>的含<a href="DocScope.html#DocProductCatalog" title="Oomph设置文档中的章节">产品目录</a>到列表中。将包含产品的产品版本添加到列表中。将该产品版本本身添加到列表中。
 </li>
 </ul>
 </li>

 <li>访问<a href="../user/wizard/DocProjectPage.html" title="Oomph设置文档中的文章">项目页面</a>或<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区中</a>选择的<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流</a> （如果有）。
 <ul>
 <li>将包含<a href="DocScope.html#DocProject" title="Oomph设置文档中的章节">项目</a>包含<a href="DocScope.html#DocProjectCatalog" title="Oomph设置文档中的章节">项目目录的</a>流添加到列表中。将该流的最外层项目添加到列表中，然后向下遍历嵌套项目直到包含项目的流，将每个项目添加到列表中。将该流本身添加到列表中。
 </li>
 </ul>
 </li>

 <li>将<a href="DocScope.html#DocInstallation" title="Oomph设置文档中的章节">安装</a>添加到列表中。
 </li>

 <li>将<a href="DocScope.html#DocWorkspace" title="Oomph设置文档中的章节">工作区</a>添加到列表中。
 </li>

 <li>将<a href="DocScope.html#DocUser" title="Oomph设置文档中的章节">用户</a>添加到列表中。
 </li>
 </ul>
 </a></p>

<a name="ScopeList.scopeVariables">
<p>对于每个范围列表，将收集有序的任务列表。最初，对于列表中的每个范围，引入三个<a href="DocTask.html#DocVariableTask" title="Chapter in Oomph Setup Documentation">变量</a> ，每个<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>用于范围的<a href="DocScope.html.name" title="Oomph设置文档中的部分">名称</a> ， <a href="DocScope.html.label" title="Oomph设置文档中的部分">标签</a>和<a href="DocScope.html.description" title="Oomph设置文档中的部分">描述</a>属性，其中变量名称以<a href="../../javadoc/org/eclipse/oomph/setup/ScopeType.html" title="org.eclipse.oomph.setup中的类"><code>scope type</code></a>为前缀，如下所示：</p><ul>
 <li>
 <code>scope.product.catalog</code>
 </li>
 <li>
  <code>scope.product</code>
 </li>
 <li>
  <code>scope.product.version</code>
 </li>
 <li>
 <code>scope.project.catalog</code>
 </li>
 <li>
 <code>scope.project</code>
 </li>
 <li>
 <code>scope.project.stream</code>
 </li>
 <li>
 <code>scope.installation</code>
 </li>
 <li>
 <code>scope.workspace</code>
 </li>
 <li>
  <code>scope.user</code>
 </li>
 </ul>每个此类变量的值将是范围的该属性的值。如果作用域的标签为<code>null</code> ，则该名称用作标签值，如果作用域的描述为<code>null</code> ，则作用域的标签将用作描述值。此外，对于<code>name</code>变量，对于每个产品，产品版本，项目和项目流，将引入名为suffix <code>.qualifier</code>的附加变量，其中值是范围的<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getQualifiedName()" title="org.eclipse.oomph.setup中的方法。范围"><code>qualified name</code></a> 。例如，Oomph.setup项目的主流的<code>scope.project.stream.name.qualified</code>变量的值是<code>org.eclipse.oomph.master</code>所有这些诱导变量按范围顺序添加到初始收集的列表中任务。
 

<a name="ScopeList.footer">
<p>通过访问每个范围的每个包含任务，将其他任务从有序范围收集到任务列表中，如下所示：</p><ul>
 <li>如果任务已禁用，请忽略该任务。
 </li>
 <li>如果范围列表不包含任何任务的限制，请忽略该任务。
 </li>
 <li>如果任务是<a href="DocTask.html#DocCompoundTask" title="Oomph设置文档中的章节">复合的</a> ，则递归地访问每个复合任务的包含任务。
 </li>
 <li>否则，将任务添加到任务列表中。在其他工作中，收集的任务列表将仅包含叶任务。
 </li>
 </ul>在范围处理结束时，收集的任务列表包含所有每个流的任务，如果没有流，则只包含任务列表。每个任务列表（或一个任务列表）分两个阶段进一步处理。初始阶段分别应用于每个任务列表。然后将每流任务列表连接成单个列表，并将第二阶段应用于该最终组成列表，或者由第二阶段进一步处理该一个任务列表。每个阶段中任务列表的处理大致相同。
 

<h2><a name="TaskList"></a> 2任务列表</h2>
<p>处理任务列表以引发其他任务， <a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖和合并</a>任务，评估和扩展变量以及<a href="DocTask.html.order" title="Oomph设置文档中的部分">重新排序</a>任务。作为<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>的任务列表的成员引起一组初始键，即一组所有变量名。Oomph任务使用EMF建模，因此每个任务实例都知道它对应的EMF类。在初始阶段处理期间，分析任务列表以确定实现列表中所有任务所需的EMF类集。每个EMF类的处理方式如下：</p><ul>
 <li>如果类包含启用注释，则引发<a href="DocTask.html#DocP2Task" title="Oomph设置文档中的章节">p2任务</a> ，即在已安装的产品中安装必要实现的任务，并将这些引发的任务添加到任务列表的头部。
 </li>
 <li>如果类包含变量注释，则引发<a href="DocTask.html#DocVariableTask" title="Oomph设置文档中的章节">变量</a>并将它们添加到任务列表的头部。
 </li>

 <li>访问该类的每个属性，如下所示：<ul>如果属性的类型不是String，则忽略它。
 <li>如果属性同时具有变量注释和变量规则注释，请访问任务列表中该属性类的每个实例，如下所示：<ul>
 <li>如果该实例任务中的属性值不为空，则不需要该规则，因此请忽略该规则。
 </li>
 <li>如果实例任务没有ID，或者它具有ID，但是由ID值组成的键，带有'。'并且附加的属性名称已经在诱导键列表中，不需要该规则，因此请忽略它。
 </li>
 <li>如果尚未针对另一个任务实例引入该规则变量，则为该属性引入规则变量。
 </li>
 </ul>保持从规则变量到其诱导属性的映射。
 </li><li>
 </li>
 </ul></li>
 </ul>在第一阶段的处理结束时，任务列表包括附加的诱导变量和任务。对于最后阶段，组合的任务列表不包含变量，因为它们都已经过评估和扩展，并且已经存在诱导任务。
 

<a name="TaskList.substitutions">
<p>进一步处理如下：</p><ul>
 <li>通过访问每个任务来构建替换映射，即替换的任务到任务映射，如下所示：<ul>
 <li>将任务的<a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖令牌</a>放入令牌到任务映射中，如果令牌到任务映射中已存在该令牌的另一个任务，则访问的任务将替换该另一个任务，因此将其添加到替换映射中。因此，列表中稍后的任务可以覆盖列表中较早的任务。
 </li>然后进一步处理替换映射以遵循替换映射以便表示直接替换。
 </ul>
 </li>
 </ul>
 

<h3><a name="InitialPhase"></a> 2.1初始阶段</h3>
<p>对于初始阶段处理，所有任务都被有效复制，包括复制包含的范围。复制过程将任务 - 任务<a href="DocTaskComposition.html#TaskList.substitutions" title="Oomph设置文档中的部分">替换</a>映射考虑在内，即每个任务在其副本中通过其<a href="DocTask.html.override" title="Oomph设置文档中的部分">合并的覆盖进行</a>逻辑替换。因此，只有最终重写的合并任务仍保留在生成的任务列表副本中，并且对重写和重写任务的所有引用都将引用最终合并的重写。任务列表的进一步处理继续该复制的任务列表。
 </p>
 <p>通过访问任务列表中的每个变量来计算显式键映射，即从变量名到变量的映射。请注意，前面的复制过程将消除重复的变量。然后，初始阶段处理通过使用非空ID属性访问每个任务来进行，如下所示：</p><ul>
 <li>访问任务的EMF类的每个属性，关于通过附加'。'引起的变量名称。以及任务ID属性值的属性名称：<ul>
 <li>如果属性是任务的ID属性，或者该属性不是单值String类型属性，请忽略它。
 </li>
 <li>如果显式键包含诱导变量的名称，则该属性的任务值为空，并且该属性具有变量注释，将该属性的任务值更改为对显式变量的引用。
 </li>
 <li>如果显式键不包含诱导变量名称，则引发一个新变量记录，使其成为显式键，将其添加到任务列表中，并执行以下操作：<ul>
 <li>如果属性的任务值为空，并且属性具有变量注释，则将该属性的任务值更改为对诱导变量的引用。
 </li>
 <li>相反，如果属性的任务值非空，则将诱导变量的值设置为该值，对于空值情况，如果属性具有变量注释，则将该属性的任务值更改为参考到诱导变量。
 </li>
 <li>还为每个属性的规则注释引入规则变量，将它们记录为显式键。
 </li>
 <li>最后，如果属性具有变量注释，并且诱导变量的值是将导致循环评估的自引用，则引入另一个变量，其中诱导变量的名称以属性的显式注释为<code>.explicit</code>后缀，并且还可以更改自引用变量的值以引用该显式变量。
 </li>
 </ul>
 </li>
 </ul>
 </li>
 <li>访问每个任务以处理其所谓的活动注释。这些注释可用于变量，以从其他变量中定义的选项组成一组选择，或从另一个变量的值中引出选择。TODO的例子</li>
 <li>访问每个变量任务以构建键到值映射。分析该映射以确定变量引用，根据此依赖性分析重新排序映射。并在有序映射中展开变量。
 </li>
 <li>根据键值映射扩展所有任务的所有属性的值，但标记为不可扩展的属性除外。例如，不扩展变量本身的name属性。
 </li>
 <li>回想一下，任务的收集有效地<a href="DocTaskComposition.html#ScopeList.footer" title="Oomph设置文档中的部分">忽略了</a> <a href="DocTask.html#DocCompoundTask" title="Oomph设置文档中的章节">复合任务</a> 。但是那些复合任务可以指定<a href="DocTask.html.order" title="Oomph设置文档中的部分">前辈和后继者</a>以及<a href="DocTask.html.restrictions" title="Oomph设置文档中的部分">限制</a> 。因此，这些前身和后继者被扩展为参考叶子任务。此外，由此产生的扩展前辈和后续者以及限制因素都会传播到叶子任务中。
 </li>
 </ul>
 <p>

</p><h3><a name="FinalPhase"></a> 2.2最后阶段</h3>
<p>最后阶段处理任务列表，该列表是从初始阶段生成的任务列表的串联，或者仅是初始阶段已经处理的一个任务列表。因此，它正在使用任务副本，所有变量都已扩展和消除。此阶段的处理通过分析结构重复的任务列表来增强替换映射。然后，它应用这些替换，即覆盖和合并重复任务，从而在进一步处理之前减少任务列表。
 </p>

<h3><a name="Reorder"></a> 2.3重新排序</h3>
<p>任务列表的处理，特别是任务<a href="DocTask.html.override" title="Oomph设置文档中的部分">覆盖</a>和合并，会影响任务列表的整体顺序，使其与从作用域收集的原始创作顺序不同。不仅如此，当涉及多个流时， <a href="DocTaskComposition.html#FinalPhase" title="Oomph设置文档中的章节">最终阶段</a>处理正在处理连接列表，其中必须正确地重新排序任务。为了支持这一点，每项任务都具有内在的<a href="DocTask.html.order" title="Oomph设置文档中的部分">优先权</a> ;任务列表主要根据该优先级排序。每个任务还指定<a href="DocTask.html.order" title="Oomph设置文档中的部分">前任和后继者</a> ;对任务列表进行二次排序以尊重诱导的部分顺序。在这两个排序步骤之后，修改列表中的任务以清除前驱者和后继者，然后将前驱者设置为形成一个链，该链引起整个顺序，这正是排序任务列表的最终顺序;这个链排除了变量。这种依赖关系确保处理连接任务列表的最终阶段处理将正确地交织任务（由于优先级排序），同时还遵守多个流的每个流的顺序。
 </p><p>

</p><h3><a name="Filter"></a> 2.4触发过滤</h3>
<p>从任务列表中删除<a href="DocTask.html.excludedTriggers" title="Oomph设置文档中的部分">排除</a>当前<a href="DocTask.html#DocTrigger" title="Oomph设置文档中的章节">触发器的</a>每个任务。请注意，任务列表收集过程收集<b>所有</b>任务，因为会分析任务列表以确定需要为所有可能的触发器安装哪些任务。因此，对于<a href="DocTask.html#DocTrigger.bootstrap" title="Oomph设置文档中的部分">引导程序引导程序</a>触发器，即使是在已安装的产品中运行之前无法执行的任务也会被分析，以确保在安装产品后，需要在该安装中执行的任务，即<a href="DocTask.html#DocTrigger.startup" title="Oomph设置文档中的部分">启动</a>或<a href="DocTask.html#DocTrigger.manual" title="Oomph设置文档中的部分">手动</a>触发器，已正确安装。所有任务的处理也意味着在系统启动时，将在运行安装的产品所需要的所有变量将被<a href="../user/wizard/DocVariablePage.html" title="Oomph设置文档中的文章">提示</a>早，因此在运行安装的产品都已经上市。
 </p>

<h3><a name="Consolidation"></a> 2.5合并</h3>
<p>最终任务列表处理步骤从任务列表中删除所有变量并<a href="DocTask.html.consolidate" title="Oomph设置文档中的部分">合并</a>每个剩余任务。此时，列表中的任务已准备好<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">执行</a> 。
 </p>

<p align="right">
<a href="DocSetupResource.html" title="向后设置资源"><img src="../../images/backward.png" border="0"></a> <a href="DocTaskExecution.html" title="转发到任务执行"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（Loehne，Germany）和其他人。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v2.0条款提供，可从http://www.eclipse.org/legal/epl-v20.html获取。</div>
</a></a></a></body>
</html><html id="3845.104_jvmdomainmodel.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>JVM语言的五个简单步骤</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="jvm-domain-model">JVM语言的五个简单步骤</h1>

<p>在本教程中，我们将基本上再次实现域模型语言，但这次我们将使用Xtext 2.x附带的特殊JVM支持。这种语言确实是DSL的最佳选择，因此可以随意将其用作蓝图并在以后添加项目特定功能。</p>

<p>修订后的域模型语言支持表达式和Java类型的交叉链接。它直接翻译为Java源代码。语法应该看起来非常熟悉。这是一个例子：</p>

<pre><code class="language-domainexample">import java.util。列表包my.model {entity Person {name：String firstName：String friends：List &lt;Person&gt; address：Address op getFullName（）：String {return firstName +“”+ name; } op getFriendsSortedByFullName（）：List &lt;Person&gt; {return friends.sortBy [f | f.fullName]}} entity Address {street：String zip：String city：String}}</code></pre>

<p>如您所见，它支持各种高级功能，如Java泛型和完整表达式，甚至包括lambda表达式。不要惊慌，你不必自己实现这些概念，但会重用很多有用的基础设施来构建语言。</p>

<p>我们现在将介绍使该语言完全正常工作所需的五个小步骤，包括其编译器。前三个步骤与<a href="102_domainmodelwalkthrough.html">15 Minutes Tutorial</a>中的步骤非常相似。</p>

<p>在计算机上安装Xtext后，启动Eclipse并设置一个新的工作区。</p>

<h2 id="domain-model-step1">第一步：创建一个新的Xtext项目</h2>

<p>为了开始，我们首先需要创建一些Eclipse项目。使用Eclipse向导执行此操作：</p>

<p><em>文件→新建→项目...→Xtext→Xtext项目</em></p>

<p>选择有意义的项目名称，语言名称和文件扩展名，例如</p>

<table>
  <tbody>
    <tr>
      <td><strong>主要项目名称：</strong></td>
      <td>org.example.domainmodel</td>
    </tr>
    <tr>
      <td><strong>语言名称：</strong></td>
      <td>org.example.domainmodel。的DomainModel</td>
    </tr>
    <tr>
      <td><strong>DSL-File扩展：</strong></td>
      <td>dmodel</td>
    </tr>
  </tbody>
</table>

<p>单击“ <em>完成”</em>以创建项目。</p>

<p><img src="images/30min_wizard.png" alt=""></p>

<p>成功完成向导后，您将在工作区中找到五个新项目。</p>

<table>
  <tbody>
    <tr>
      <td>org.example.domainmodel</td>
      <td>语法定义和所有特定于语言的组件（解析器，词法分析器，链接器，验证等）</td>
    </tr>
    <tr>
      <td>org.example.domainmodel.tests</td>
      <td>语言的单元测试</td>
    </tr>
    <tr>
      <td>org.example.domainmodel.ide</td>
      <td>独立于平台的IDE功能（例如，用于内容辅助的服务）</td>
    </tr>
    <tr>
      <td>org.example.domainmodel.ui</td>
      <td>Eclipse编辑器和其他工作台相关的功能</td>
    </tr>
    <tr>
      <td>org.example.domainmodel.ui.tests</td>
      <td>Eclipse编辑器的单元测试</td>
    </tr>
  </tbody>
</table>

<p><img src="images/30min_initialprojectlayout.png" alt=""></p>

<h2 id="domain-model-step2">第二步：写出语法</h2>

<p>该向导将在编辑器中自动打开语法文件<em>Domainmodel.xtext</em> 。如您所见，它已经包含一个简单的<em>Hello World</em>语法。将该语法定义替换为我们语言的定义：</p>

<pre><code class="language-xtext">语法org.example.domainmodel。带有org.eclipse.xtext.xbase的Domainmodel。Xbase生成domainmodel“http://www.example.org/domainmodel/Domainmodel”Domainmodel：importSection = XImportSection？元素+ = AbstractElement *; AbstractElement：PackageDeclaration |实体; PackageDeclaration：'package'name = QualifiedName'{'elements + = AbstractElement *'}';实体：'entity'name = ValidID（'extends'superType = JvmTypeReference）？'{'features + = Feature *'}';特征：财产|操作;属性：name = ValidID'：'type = JvmTypeReference;操作：'op'name = ValidID'（'（params + = FullJvmFormalParameter（'，'params + = FullJvmFormalParameter）*）？'）''：'type = JvmTypeReference body = XBlockExpression;</code></pre>

<p>该语法的某些部分与<a href="102_domainmodelwalkthrough.html">15分钟教程中的</a>部分相同，但其他部分则不同。</p>

<ol>
  <li>

    <pre><code class="language-xtext">语法org.example.domainmodel。带有org.eclipse.xtext.xbase的Domainmodel。XBASE</code></pre>

    <p>首先要注意的是，而不是从通常的<em>org.eclipse.xtext.common继承<em>。终端</em>语法，我们使用<em>org.eclipse.xtext.xbase。Xbase</em> 。Xbase允许我们在我们的语言中轻松地重用和嵌入现代的静态类型表达式以及Java类型签名。</p>
  </li>
  <li>

    <pre><code class="language-xtext">Domainmodel：importSection = XImportSection？元素+ = AbstractElement *;</code></pre>

    <p><em>Domainmodel</em>包含可选的导入部分和任意数量的<em>AbstractElements</em> 。<em>XImportSection</em>的概念是<em>org.eclipse.xtext.xbase的一部分<em>。Xbase</em>并提供了工具支持和语法，就像您从Java中了解到的那样。</p>
  </li>
  <li>

    <pre><code class="language-xtext">AbstractElement：PackageDeclaration |实体;</code></pre>

    <p>规则<em>AbstractElement</em>委托给规则<em>PackageDeclaration</em>或规则<em>Entity</em> 。</p>
  </li>
  <li>

    <pre><code class="language-xtext">PackageDeclaration：'package'name = QualifiedName'{'elements + = AbstractElement *'}';</code></pre>

    <p><em>PackageDeclaration</em>用于声明一个名称空间，该空间可以再次包含任意数量的<em>AbstractElement</em> 。Xtext基于生成的模型的层次结构内置了对限定名称和作用域的支持。默认实现将添加包名称作为包含实体和嵌套包的前缀。这是包含在<em>PackageDeclaration“foo.bar”</em> <em>实体</em> “巴兹”的限定名称将是“foo.bar。巴兹”。如果您不喜欢默认行为，则需要使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">IQualifiedNameProvider</a>的其他实现。</p>
  </li>
  <li>

    <pre><code class="language-xtext">实体：'entity'name = ValidID（'extends'superType = JvmTypeReference）？'{'features + = Feature *'}';</code></pre>

    <p>规则<em>实体</em>以关键字的定义开头，后跟名称。<em>extends</em>子句使用以超级语法定义的规则<em>JvmTypeReference</em> 。<em>JvmTypeReference</em>定义完整类Java类型名称的语法。这就是从简单的名称，完全限定的名称到完全成熟的泛型，包括通配符，下界和上界。最后在花括号之间可以有任意数量的<em>功能</em> ，这将引导我们进入下一个规则。</p>
  </li>
  <li>

    <pre><code class="language-xtext">特征：财产|操作;</code></pre>

    <p>规则<em>功能</em>委托给<em>属性</em>或<em>操作</em> 。</p>
  </li>
  <li>

    <pre><code class="language-xtext">属性：name = ValidID'：'type = JvmTypeReference;</code></pre>

    <p><em>属性</em>具有名称，并再次使用继承的规则<em>JvmTypeReference</em> 。</p>
  </li>
  <li>

    <pre><code class="language-xtext">操作：'op'name = ValidID'（'（params + = FullJvmFormalParameter（'，'params + = FullJvmFormalParameter）*）？'）''：'type = JvmTypeReference body = XBlockExpression;</code></pre>

    <p><em>操作</em> s也有预期的签名。请注意，对于形式参数，我们可以重用超语法中的规则。</p>

    <p><em>Operation</em>的主体是实际的实现，由规则<em>XBlockExpression</em>定义， <em>XBlockExpression</em>是Xbase中最常用的入口规则之一。块由大括号之间的任意数量的表达式组成，例如：</p>

    <pre><code class="language-xbase">{返回“Hello World”+“！“}</code></pre>
  </li>
</ol>

<h2 id="domain-model-step3">第三步：生成语言工件</h2>

<p>现在我们已经掌握了语法，我们需要执行将派生各种语言组件的代码生成器。为此，右键单击语法编辑器并选择</p>

<p><em>运行方式→生成Xtext工件</em> 。</p>

<p>此操作将生成解析器和文本编辑器以及一些其他基础结构代码。您将在控制台视图中看到其日志消息。</p>

<p><img src="images/JvmTutorial_RunGenerator.png" alt=""></p>

<h2 id="domain-model-step4">第四步：定义映射到JVM概念</h2>

<p>单凭语法不足以使语言有效。我们需要将特定于域的概念映射到其他语言，以便指示Xtext如何执行它。通常您为此定义代码生成器或解释器，但使用Xbase的语言可以省略此步骤并使用<a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java">IJvmModelInferrer</a> 。</p>

<p>我们的想法是将您的语言概念转换为任意数量的Java类型（ <a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java">JvmDeclaredType</a> ）。这种类型可以是Java类，Java接口，Java注释类型或Java枚举，并且可以包含任何有效成员。最后，作为语言开发人员，您有责任根据Java语言创建正确的模型。</p>

<p>通过将您的语言概念映射到Java元素，您可以隐式地告诉Xtext各种表达式所处的范围以及它们所期望的返回类型。Xtext 2.x还附带了一个代码生成器，可以将该Java模型转换为可读的Java代码，包括表达式。</p>

<p>如果您已经触发了“生成Xtext工件”操作，则应该在src文件夹中找到名为<em>org / example / domainmodel / jvmmodel / DomainmodelJvmModelInferrer.xtend</em>的存根。请用以下内容替换其内容：</p>

<pre><code class="language-xtend">包org.example.domainmodel.jvmmodel import com.google.inject。注入import org.example.domainmodel.domainmodel。实体导入org.example.domainmodel.domainmodel。操作导入org.example.domainmodel.domainmodel。属性导入org.eclipse.xtext.naming。IQualifiedNameProvider导入org.eclipse.xtext.xbase.jvmmodel。AbstractModelInferrer导入org.eclipse.xtext.xbase.jvmmodel。IJvmDeclaredTypeAcceptor导入org.eclipse.xtext.xbase.jvmmodel。JvmTypesBuilder类DomainmodelJvmModelInferrer扩展AbstractModelInferrer {/ ** *构建器API，以可读方式以编程方式创建Jvm元素*。* / @Inject扩展名JvmTypesBuilder @Inject扩展名IQualifiedNameProvider def dispatch void infer（实体元素，IJvmDeclaredTypeAcceptor acceptor，boolean isPrelinkingPhase）{acceptor.accept（element.toClass（element.fullyQualifiedName））[documentation = element.documentation if（element.superType！== null）superTypes + = element.superType.cloneWithProxies for（feature：element.features）{switch feature {Property：{members + = feature.toField（feature.name，feature.type）members + = feature.toGetter（feature .name，feature.type）members + = feature.toSetter（feature.name，feature.type）}操作：{members + = feature.toMethod（feature.name，feature.type）[documentation = feature.documentation for（p ：feature.params）{parameters + = p.toParameter（p.name，p.parameterType）} body = feature.body]}}}]}}</code></pre>

<p>让我们通过代码来了解正在发生的事情。（有关详细信息，请参阅所用API的JavaDoc，尤其是<a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">JvmTypesBuilder</a> ）。</p>

<ol>
  <li>
    <pre><code class="language-xtend">def dispatch void infer（实体元素，IJvmDeclaredTypeAcceptor acceptor，boolean isPrelinkingPhase）{</code></pre>

    <p>使用dispatch关键字可确保仅为<em>Entity</em>类型的实例调用该方法。查看有关多态调度<a href="http://www.eclipse.org/xtend/documentation/202_xtend_classes_members.html#polymorphic-dispatch">的Xtend文档</a> ，了解Xtend的调度函数。扩展<a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/AbstractModelInferrer.java">AbstractModelInferrer</a>确保我们不必独自遍历语法模型。</p>
  </li>
  <li>
    <pre><code class="language-xtend">acceptor.accept（element.toClass（element.fullyQualifiedName））[...]</code></pre>

    <p>您在模型推断中创建的每个<a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmDeclaredType.java">JvmDeclaredType</a>都需要传递给<em>接受器</em>才能被识别。扩展方法<em>toClass</em>来自<a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">JvmTypesBuilder</a> 。该类提供了许多方便的扩展方法，有助于使代码具有极高的可读性和简洁性。重要的是要理解限定名称的创建和分配是在编译器收集所有全局符号的早期阶段完成的。此时无法解析类型引用。</p>
  </li>
  <li><em>接受</em>的第二个参数是一个lambda块，它包含已创建的Java类型的进一步初始化。只有在此块中，您才可以进行类型参考分辨率。这也是您添加成员并将XExpressions放入上下文的位置。让我们详细了解一下我们在初始化块中做了些什么：</li>
  <li>
    <pre><code class="language-xtend">documentation = element.documentation</code></pre>

    <p>这里我们将一些JavaDoc分配给新创建的元素。赋值转换为方法<em><a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">JvmTypesBuilder</a> .setDocumentation（ <a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.common.types/emf-gen/org/eclipse/xtext/common/types/JvmIdentifiableElement.java">JvmIdentifiableElement</a> ，String）的</em>调用，而<code>element.documentation</code>实际上是调用扩展方法<em><a href="https://github.com/eclipse/xtext-extras/blob/master/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/JvmTypesBuilder.java">JvmTypesBuilder</a> .getDocumentation（ <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a> ）</em> 。这些扩展方法在<a href="https://www.eclipse.org/xtend/documentation/202_xtend_classes_members.html#extension-methods">Xtend文档</a>中有详细<a href="https://www.eclipse.org/xtend/documentation/202_xtend_classes_members.html#extension-methods">说明</a> 。</p>
  </li>
  <li>
    <pre><code class="language-xtend">if（element.superType！== null）superTypes + = entity.superType.cloneWithProxies</code></pre>

    <p>在推断的元素上设置<em>superType</em> 。请注意，我们必须从<em>element.superType</em>克隆类型引用。如果我们不这样做，类型引用将自动从<em>元素中</em>删除，因为<em>superType</em>是EMF包含引用。</p>
  </li>
  <li>
    <pre><code class="language-xtend">for（feature：element.features）{switch feature {Property：{// ...操作：{// ...}}}</code></pre>

    <p>迭代异构类型列表时，带有类型保护的switch表达式就派上用场了。如果<em>feature</em>属于<em>Property</em>类型，则执行第一个块。如果是<em>操作</em> ，则执行第二个块。请注意，变量<em>要素</em>将隐式地转换为块中的相应类型。</p>
  </li>
  <li>
    <pre><code class="language-xtend">属性：{members + = feature.toField（feature.name，feature.type）members + = feature.toSetter（feature.name，feature.type）members + = feature.toGetter（feature.name，feature.type）}</code></pre>

    <p>对于每个<em>Property，</em>我们创建一个字段以及相应的getter和setter。</p>
  </li>
  <li>
    <pre><code class="language-xtend">操作：{members + = feature.toMethod（feature.name，feature.type）[documentation = feature.documentation for（p：feature.params）{parameters + = p.toParameter（p.name，p.parameterType）} body = feature.body]}</code></pre>

    <p><em>操作</em>映射到相应的Java方法。翻译文档并在初始化程序中添加参数。line <code>body = feature.body</code>将<em>Operation</em>的表达式注册为新创建的Java方法的主体。这定义了表达式的范围。该框架从该信息中推导出可见字段和参数以及预期的返回类型。</p>
  </li>
</ol>

<h2 id="domain-model-step5">第五步：尝试编辑！</h2>

<p>我们现在可以使用我们的插件生成一个新的Eclipse来测试IDE集成：右键单击Package Explorer中的项目<code>org.example.domainmodel</code> ，然后选择<em>Run As→Eclipse Application</em> 。</p>

<p>在新工作台中，创建一个Java项目（ <em>文件→新建→项目...→Java项目</em> ）。Xbase依赖于类路径上的小型运行时库。要添加它，请右键单击项目，然后转到<em>Java Build Path→Libraries→Add Library</em>并选择<em>Xtend Library</em> 。然后使用您在Java项目的源文件夹中的开头（ <em>* .dmodel</em> ）中选择的文件扩展名创建一个新文件。这将打开生成的实体编辑器。试一试，发现它提供的丰富功能。您还应该查看语言的首选项，以了解可以根据用户需求单独配置的内容。</p>

<p>玩得开心！</p>

<p><img src="images/JvmTutorial_Editor.png" alt=""></p>

<hr>

<p><strong><a href="301_grammarlanguage.html">下一章：语法语言</a></strong></p>


</body>
</html><html id="1394.ch03s14s06.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>3.14.6。�使用函数作为测试用例的数据</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula User Manual"></link>
<link rel="up" href="ch03s14.html" title="3.14.�Working with test data"></link>
<link rel="prev" href="ch03s14s05.html" title="3.14.5.�Using variables as data for Test Cases"></link>
<link rel="next" href="ch03s14s07.html" title="3.14.7.�Concatenating (combining) parameters"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">3.14.6。�使用函数作为测试用例的数据</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch03s14s05.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">3.14。�使用测试数据</th>
<td width="20%" align="right">� <a href="ch03s14s07.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula用户手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch03.html">任务</a></span> &gt; <span class="breadcrumb-link"><a href="ch03s14.html">使用测试数据</a></span> &gt; <span class="breadcrumb-node">使用函数作为</span> <span class="breadcrumb-link"><a href="ch03s14.html">测试用例的数据</a></span>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="using-functions-as-data-for-test-cases"></a> 3.14.6。�使用函数作为测试用例的数据</h3></div></div></div>
<a name="using-functions-as-data-for-test-cases.guidancerDataSetViewContextId"></a><a name="using-functions-as-data-for-test-cases.guidancerPropertiesViewContextId"></a><a name="using-functions-as-data-for-test-cases.guidancerCentralTestDataEditorContextId"></a><p>您可以使用<span class="emphasis"><em>函数</em></span>自行计算特定值而无需输入结果。有一些特定的功能可以开箱即用，还可以添加其他功能。
  </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="syntax-for-functions"></a> 3.14.6.1。�函数的语法</h4></div></div></div>
<p>用于引入功能的标志是问号： <span class="input">？</span>（没有引号）。
    </p>
<p>在符号之后，您必须输入函数的名称，后跟函数所需的参数，例如：</p>
<p>
      <code class="literal">？加（ARG1，ARG2）</code>
    </p>
<p>参数以逗号分隔，并放在圆括号内。
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="pre-defined-functions"></a> 3.14.6.2。�预定义的功能</h4></div></div></div>
<p>ITE中可直接使用以下功能：</p>
<p>
      <span class="strong"><strong>数学函数</strong></span><br xmlns:d="http://docbook.org/ns/docbook">以下函数将结果显示为十进制数，例如1.0,1.2等。</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">加</span></dt>
<dd><p>将0或更多数字添加到0，例如： <span class="input">？加（1,2）</span> 。
          </p></dd>
<dt><span class="term">子</span></dt>
<dd><p>从第一个数字中减去第二个数字： <span class="input">？sub（3,2）</span> 。<br xmlns:d="http://docbook.org/ns/docbook">此功能仅接受两个数字。
          </p></dd>
<dt><span class="term">MULT</span></dt>
<dd><p>将0或更多数字乘以1，例如： <span class="input">？mult（2,4）</span> 。
          </p></dd>
<dt><span class="term">DIV</span></dt>
<dd><p>将第一个数字除以第二个数字： <span class="input">？div（2,1）</span> 。<br xmlns:d="http://docbook.org/ns/docbook">此功能仅接受两个数字。
          </p></dd>
<dt><span class="term">TRUNC</span></dt>
<dd><p>采用两个参数，要截断的小数和要截断小数的精度（作为整数）。使用<span class="input">0</span>将数字切除为无小数位（即接收一个普通整数），并使用<span class="input">1</span>将小数切成一位小数位等： <span class="input">？trunc（2.396,0）</span>给出<span class="input">2</span>和<span class="input">？trunc（2.789,1）</span>给出<span class="input">2.7</span> 。
          </p></dd>
<dt><span class="term">回合</span></dt>
<dd>
<p>采用两个参数，小数要舍入，精度（作为整数）舍入到。此函数使用<span class="emphasis"><em>半向</em></span>舍入来舍入数字，以便如果舍入后的最后小数位数为5或更高，则最终数字将增加1，例如： <span class="input">？圆（2.56,1）</span>给出<span class="input">2.6</span> 。如果舍入后的最终数字是4或更少，则没有增量，例如。
            <span class="input">？圆（2.43,1）</span>给出<span class="input">2.4</span> 。
          </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>目前只能使用以小数点<span class="emphasis"><em>周期</em></span>或<span class="emphasis"><em>fullstop</em></span> （ <span class="input">。</span> ）格式化的数字。可能不会使用数千个分离器。例如， <span class="input">1.5</span>被接受，但<span class="input">1,5</span>不被接受。 <span class="input">1000</span>可以进入，但<span class="input">1000</span>不能。输入<span class="input">1.000</span>相当于输入<span class="input">1</span> 。您可以使用<span class="input">formatNumber</span>函数将数字转换为整数或更改数字所具有的小数点数。
          </strong></span></td>
</tr></tbody>
</table>
</dd>
<dt><span class="term">formatNumber</span></dt>
<dd><p>采用两个参数，要格式化的小数和格式化数字应包含的小数位数。使用此功能时，数字或小数位不会舍入。
            <span class="input">？formatNumber（15.43,0）</span>给出<span class="input">15</span> 。 <span class="input">？formatNumber（15.4,3）</span>给出<span class="input">15.4</span> ，不会附加零。 <span class="input">？formatNumber（15.4356,2）</span>给出<span class="input">15.43</span> 。
          </p></dd>
</dl></div>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>在负数周围使用单引号，例如'-0.5'。
    </strong></span></td>
</tr></tbody>
</table>
<p>
      <span class="strong"><strong>日期功能</strong></span>
    </p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">现在</span></dt>
<dd><p>以当前格式保存当前日期，该格式可用作formatDate和modifyDate函数的基础。这个函数没有参数： <span class="input">？现在（）</span> 。
          </p></dd>
<dt><span class="term">formatDate</span></dt>
<dd><p>将日期设置为特定格式。要格式化的日期作为第一个参数输入，后跟格式字符串，例如<span class="input">？formatDate（？now（），dd-MM-yyyy）</span> 。这里可以使用的格式是Java中SimpleDateFormat类的格式。
          </p></dd>
<dt><span class="term">parseDate</span></dt>
<dd><p>读取一个日期值并根据给定的格式字符串将其解析为内部格式（即应该如何理解日期）。第一个参数是日期，第二个参数是格式字符串<span class="input">？parseDate（2011.06.25，YYYY。MM.dd）</span> 。在阅读和使用AUT中显示的日期时，应使用此功能。</p></dd>
<dt><span class="term">modifyDate</span></dt>
<dd><p>此功能可以将天（d），月（M），年（y），小时（h），分钟（i），秒（s）和毫秒（j）添加到给定日期。必须首先解析日期（即使用parseDate），以便使用正确的内部格式。这个函数有两个参数：第一个是要修改的日期，第二个是要执行的修改，例如<span class="input">？modifyDate（？now（），1d）</span> 。加法作为正整数输入（但没有加号，例如1d，1M，1y），减法作为负整数输入，例如-1d，-1M，-1y，-1i。
          </p></dd>
</dl></div>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您想将日期函数的结果用作测试数据的一部分（即输入或检查），那么您很可能需要在已执行的任何日期修改上使用formatDate。
    </strong></span></td>
</tr></tbody>
</table>
<p>
      <span class="strong"><strong>测试功能</strong></span>
    </p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">getNodeAttribute</span></dt>
<dd><p>读取解析此函数的节点（例如测试用例，测试步骤）上的值，并将其用作测试步骤的数据。它有四个可能的参数， <span class="emphasis"><em>name</em></span>读取节点的名称， <span class="emphasis"><em>comment</em></span>读取节点上的注释， <span class="emphasis"><em>description</em></span>读取节点上的原始（非呈现）描述， <span class="emphasis"><em>task.id</em></span>读取节点上的任务ID。如果内容为空，则使用的值为<span class="emphasis"><em>null</em></span> 。如果您在此重用位置覆盖了名称或注释，则会使用这些新详细信息。
          </p></dd>
<dt><span class="term">getCentralTestDataSetValue</span></dt>
<dd><p>使用此功能可以访问保存在中央数据集中的值。这使您可以将已集中定义的值与本地使用的值组合，或者允许组合测试中不同中央数据集的值。它根据您定义为键的列中的值以及要在其中搜索所需值的列，在特定中央数据集中查找单个单元格。它需要四个参数：要搜索的中央数据集的名称，要用作“键”的列的名称（如果需要，可以将列命名为KEY），键列中的值（指定行）以及所需数据单元所在的列。
          </p></dd>
</dl></div>
<p>
      <span class="strong"><strong>getCentralTestDataSetValue函数的示例</strong></span><br xmlns:d="http://docbook.org/ns/docbook">可以使用此示例中央数据集（例如<span class="emphasis"><em>Customer）</em></span>来举例说明从中央数据集检索数据的功能：</p>
<p>
      </p>
<div class="informaltable"><table border="1">
<colgroup>
<col align="center">
<col align="center">
</colgroup>
<thead><tr>
<th align="center">客户类型</th>
<th align="center">顾客姓名</th>
</tr></thead>
<tbody>
<tr>
<td align="center">NormalUser</td>
<td align="center">Bob Normal</td>
</tr>
<tr>
<td align="center">超级用户</td>
<td align="center">爱丽丝超级</td>
</tr>
<tr>
<td align="center">SupportUser</td>
<td align="center">约翰支持</td>
</tr>
</tbody>
</table></div>
<p>
    </p>
<p>要使用客户类型选择客户名称，您应输入：</p>
<div class="blockquote"><blockquote class="blockquote"><p>
        <span class="strong"><strong>？getCentralTestDataSetValue<br xmlns:d="http://docbook.org/ns/docbook">（客户，CUSTOMER_TYPE，超级用户，CUSTOMER_NAME）</strong></span>
      </p></blockquote></div>
<p>这将查看名为<span class="emphasis"><em>Customer</em></span>的中央数据集，在<span class="emphasis"><em>CUSTOMER_TYPE</em></span>列中找到值<span class="emphasis"><em>SuperUser</em></span> ，并使用该行选择<span class="emphasis"><em>CUSTOMER_NAME</em></span>列中的单元格 -  Alice Super。
    </p>
<p>如果使用此功能，则可以尝试使用属性或数据集视图中的跳转到中央测试数据集命令跳转到引用的数据集（ <a class="xref" href="../userInterface/ch05s05s02.html" title="5.5.2。�属性视图">Section�5.5.2，“属性视图”</a> ， <a class="xref" href="../userInterface/ch05s05s03.html" title="5.5.3。�数据集视图">Section� 5.5.3，“数据集视图”</a> ）。
    </p>
<p>
      <span class="strong"><strong>来自其他库的包装函数</strong></span><br xmlns:d="http://docbook.org/ns/docbook">您还可以在测试中使用以下功能。有关它们的完整文档，请参阅相应的库。
    </p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">randomInt（独占最大值）</span></dt>
<dd><p>使用此函数生成一个随机整数，但不包括您指定的值。该函数来自<span class="emphasis"><em>org.apache.commons.lang.math。RandomUtils</em></span>
          </p></dd>
<dt><span class="term">replaceAll（字符串，正则表达式，替换）</span></dt>
<dd><p>使用此函数可以用其他内容替换指定的字符串的所有部分。执行替换的<span class="emphasis"><em>字符串</em></span>作为<span class="emphasis"><em>字符串</em></span>输入，要替换的<span class="emphasis"><em>字符串</em></span>的部分由<span class="emphasis"><em>正则表达式</em></span>定义，替换它的字符串作为<span class="emphasis"><em>替换</em></span> 。该函数来自<span class="emphasis"><em>java.util.regex</em></span> 。
          </p></dd>
<dt><span class="term">UUID（）</span></dt>
<dd><p>此函数生成通用唯一标识符。该函数来自<span class="emphasis"><em>java.util。UUID</em></span> 。</p></dd>
<dt><span class="term">base64Encode（串）</span></dt>
<dd><p>此函数将字符串编码为base 64。该函数来自<span class="emphasis"><em>org.apache.commons.codec.binary。Base64</em></span> 。
          </p></dd>
<dt><span class="term">base64Decode（串）</span></dt>
<dd><p>此函数解码基数为64的字符串。该函数来自<span class="emphasis"><em>org.apache.commons.codec.binary。Base64</em></span> 。
          </p></dd>
<dt><span class="term">进行urlencode（串）</span></dt>
<dd><p>此函数对（使用UTF-8）字符串进行编码，以便在URL中进一步使用。</p></dd>
<dt><span class="term">urlDecode（串）</span></dt>
<dd><p>此函数从URL解码（使用UTF-8）字符串。</p></dd>
</dl></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="embedding-functions-in-other-functions"></a> 3.14.6.3。�嵌入功能在其他功能中</h4></div></div></div>
<p>函数可以作为参数添加到其他函数中。例如，如果你想使用减法的结果作为你的加法的第一个参数，你可以像这样写：</p>
<p>
      <span class="input">？加（？子（2,1），1）</span>
    </p>
<p>结果为<span class="input">1.0 + 1</span> ，即<span class="input">2.0</span>
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="useful-examples-for-functions"></a> 3.14.6.4。�功能的有用示例</h4></div></div></div>
<p>特别是在涉及日期功能时，通常需要使用彼此嵌入的多个功能。
    </p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">？formatDate（？now（），dd'MMMM'yyyy）</span></dt>
<dd><p>例如2012年2月29日</p></dd>
<dt><span class="term">？formatDate（？now（），dd'MMM'yyyy）</span></dt>
<dd><p>例如2012年2月29日</p></dd>
<dt><span class="term">？formatDate（？now（），dd-MMM-yyyy）</span></dt>
<dd><p>例如，2012年2月29日</p></dd>
<dt><span class="term">？formatDate（？now（），dd。MM.yyyy）</span></dt>
<dd><p>例如29.02.2012</p></dd>
<dt><span class="term">？formatDate（？now（），dd / MM / yyyy）</span></dt>
<dd><p>例如29/02/2012</p></dd>
</dl></div>
<p>涉及嵌入式函数的更复杂的示例是：</p>
<div class="blockquote"><blockquote class="blockquote"><p>
        <span class="strong"><strong>？formatDate（？modifyDate（？parseDate<br xmlns:d="http://docbook.org/ns/docbook">（2012年2月22日，dd。MM.yyyy）， -  1D），DD。MM.yy）</strong></span><br xmlns:d="http://docbook.org/ns/docbook">此函数将日期22.2.2012解析为内部格式，减去一天，然后将其格式化为dd。MM.yy，在这种情况下：21.2.12。
      </p></blockquote></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="adding-your-own-functions"></a> 3.14.6.5。�添加自己的功能</h4></div></div></div>
<p>您还可以使用扩展点添加自己的功能。这在开发者手册中有所描述。
    </p>
</div>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="2871.org_eclipse_ui_console_consolePageParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>控制台页面参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">控制台页面参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.console.consolePageParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点提供了一种用于提供控制台页面参与者的机制。向控制台页面参与者通知页面生命周期事件，例如创建，激活，停用和处置。页面参与者还可以为页面提供适配器。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.consolePageParticipant">consolePageParticipant</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.consolePageParticipant">consolePageParticipant</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST consolePageParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 指定此控制台页面参与者的唯一标识符</li>
<li><b>class</b> - 指定实现<code>IConsolePageParticipant</code>的Java类的完全限定名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是控制台页面参与者扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.console.consolePageParticipants”</span> <span class="code SchemaTag">&gt; &lt;consolePageParticipant class =</span> <span class="code SchemaCstring">“com.example。ExamplePageParticipant“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”com.example。ExamplePageParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”com.example。ExampleConsole“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ consolePageParticipant&gt; &lt;/ extension&gt;</span></pre>在上面的示例中，提供的控制台页面参与者将用于“com.example”类型的所有控制台。ExampleConsole“。<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>属性<b>类的</b>值必须是实现接口<b>org.eclipse.ui.console的Java类的完全限定名称<b>。IConsolePageParticipant</b> 。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2005 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0013.textproductionrules.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content=""></meta>
    <meta name="author" content="Stéphane Bégaudeau"></meta>    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet"></link>
    <link href="../../assets/css/docs.css" rel="stylesheet"></link>
    
    <title>Acceleo</title>
  </head>
  <body dir="ltr">
    <div class="container">
      <section id="introduction">
        <div class="page-header">
          <h1>文本制作规则<small>格式规则</small></h1>
        </div>
        <p>这仍然是草案，仅作为信息提供。虽然这个文档仍然缺少一些格式和示例，但它可以用来准确了解Acceleo中如何处理缩进和回车。
        </p>
      </section>
      
      <section id="definitions">
        <div class="page-header">
          <h1>定义<small></small></h1>
        </div>
        <p>文本制作规则将适用于所有正文元素。每个身体元素可以是独立的或嵌入其他身体元素中。通过将这些主体元素分为五个主要类别来理解文本生成规则将更容易：表达式，静态文本，注释，模板调用和块。
        </p>
        <p>“块”包括模板，for，if，let，protected区域，文件，跟踪和宏块。如果一个块是以下任何一个块，它将被视为“独立”：</p>
        <ul>
          <li>没有任何其他body元素包围的单个行块，除了空格，块尾和注释</li>
          <li>除了白色空格，块尾和注释之外没有任何其他主体元素包围的多行块，在块头和尾部出现的行上</li>
        </ul>
        <p>任何不属于这些类别的块都将被视为“嵌入式”块。
        </p>
        
        <h2>例子</h2>
        <h3>独立的单行块</h3>
        <p>线路起始和块头之间没有任何相关的产生，块尾和线端之间没有任何关系;头尾都在同一条线上。以下所有都属于此类别。
        </p>
        <pre>[for（Sequence {false，false，false}）] [self /] [/ for]</pre>
        <br>
        <pre>[if（true）]输出[/ if]</pre>
        <br>
        <pre>[/ if] [评论... /] [if（true）]输出[/ if]</pre>
        <br>
        <pre>[/ if] [if（true）]输出[/ if]</pre>
        <br>
        
        <h3>嵌入式单线程块</h3>
        <p>块的头部和尾部在同一条线上，但是除了同一条线上的块之外，还有一些与生成相关的东西。
        </p>
        <pre>一些文本[for（Sequence {false，false，false}）]输出[/ for]</pre>
        <br>
        <pre>[if（true）]输出[/ if]和一些文字</pre>
        <br>
        <pre>[for（Sequence {false，false，false}）] [self /] [/ for]和一些文本。</pre>
        <br>
        
        <h3>独立的多线块</h3>
        <p>线路起始和块头之间没有任何相关的产生，块尾和线端之间没有任何关系;头和尾在不同的线上。
        </p>
        <pre>[for（Sequence {false，false，false}）] [self /] [/ for]</pre>
        <pre>[if（true）]输出[/ if]</pre>
        <pre>[if（true）]输出[/ if]</pre>
        <pre>[评论]生成布尔[/ comment] [for（Sequence {false，false，false}）] [self /] [/ for]</pre>
        <pre>[for（Sequence {false，false，false}）] [self /] [/ for]</pre>
        
        <h3>嵌入式多线块</h3>
        <p>块的头部和尾部位于不同的线上，但是除了同一线上的块之外，还有一些与生成相关的东西。
        </p>
        <pre>text [for（Sequence {false，false，false}）] [self /] [/ for]</pre>
        <pre>[if（true）]输出[/ if]文本</pre>
      </section>
      
      <section id="boundaries">
        <div class="page-header">
          <h1><small>识别身体元素边界的边界</small></h1>
        </div>
        <h2>块体</h2>
        <h3>单行块</h3>
        <p>主体在块头的闭合支架之后开始，并在块尾的起始支架之前结束。
        </p>
        
        <h3>多行块</h3>
        <p>如果块头的闭合括号后面紧跟一条新线，则块的主体在块头之后的下一行开始处开始。否则块的主体在其头部的闭合支架之后开始。主体在块尾的起始括号之前结束，无论是否直接在新行之前。
        </p>
        
        <h3>特殊处理“模板”块</h3>
        <p>如果块尾部的起始括号之前的最后一个字符是新行，后跟可选的空格，则模板体在其尾部之前的最后一个新行字符之前结束。
        </p>
        
        <h2>静态文本</h2>
        <p>我们需要定义线相关的概念以正确识别这些边界。为此，我们将静态文本中包含的空白字符描述为“空格”，无论它们在文本中的位置如何。
        </p>
        <p>如果一行包含除空格，块头，块尾和注释之外的任何内容，则该行被视为“相关”。但是，请注意，仅由空格组成的行也被认为是相关的。
        </p>
        <ul>
          <li>如果静态文本完全位于非相关行上，则不会生成任何文本。</li>
          <li>如果静态文本在非相关行上开始，则忽略此行上的所有字符，并且静态文本被视为以字符在其第一个新行字符之后开始。</li>
          <li>如果静态文本在非相关行上结束，则忽略此行上的所有字符，并且静态文本被视为以最后一个新行字符之前的字符结束。</li>
          <li>�保护区域后的静态文本的特殊处理�块：保留区域尾部后面的所有空格都被保留，包括新行字符。然后静态文本在受保护区域尾部的右括号后面开始。</li>
        </ul>
      </section>
      
      <section id="rules">
        <div class="page-header">
          <h1>规则<small></small></h1>
        </div>
        <p>考虑到上面识别身体元素边界一节中概述的边界，文本生成规则如下：</p>
        <ul>
          <li>表达式执行产生的文本按原样输出;</li>
          <li>执行静态文本产生的文本按原样输出;</li>
          <li>评论不产生任何文字;</li>
          <li>模板调用生成的每行文本都将缩进以匹配运动调用的行的缩进;</li>
          <li>通过执行嵌入块产生的文本，无论是多行块还是单行块，将与周围的主体元素产生的所有文本一起输出。
          </li>
          <li>执行独立单行块生成的文本按原样输出。位于块之前和之后的白色空间被保留;</li>
          <li>执行独立的多行块所产生的文本将按照上述边界输出：如果块体的第一个字符是新行，则忽略它。请注意，如果独立的多行块不生成任何文本，则生成的文本中甚至不会出现换行符。
          </li>
        </ul>
      </section>
      
      <section id="examples">
        <div class="page-header">
          <h1>例子<small></small></h1>
        </div>
        <p>在以下示例中，隐含的字符已实现：</p>
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="24%">
            <col width="76%">
          </colgroup>
          <tbody valign="top">
            <tr>
              <td>·</td>
              <td>表示空格字符</td>
            </tr>
            <tr>
              <td>↪</td>
              <td>表示水平制表符</td>
            </tr>
            <tr>
              <td>¶</td>
              <td>表示回车</td>
            </tr>
          </tbody>
        </table>
        
        <h2>嵌入式块</h2>
        <h3>例1</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">一些</tt> · <tt class="docutils literal">文</tt> · <tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal">false，</tt> · <tt class="docutils literal">false}）</tt> · <tt class="docutils literal">separator</tt> · <tt class="docutils literal">（'</tt> · <tt class="docutils literal">-</tt> · <tt class="docutils literal"><span class="pre">'）]输出[/ for]</span></tt></blockquote>
        <p>产生以下结果：</p>
        <blockquote>
        <tt class="docutils literal">一些</tt> · <tt class="docutils literal">文本</tt> · <tt class="docutils literal">输出</tt> · <tt class="docutils literal">-</tt> · <tt class="docutils literal">输出</tt> · <tt class="docutils literal">-</tt> · <tt class="docutils literal">输出</tt></blockquote>
        <hr class="docutils">

        <h3>例2</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">[if</tt> · <tt class="docutils literal"><span class="pre">（true）]输出[/ if]</span></tt> · <tt class="docutils literal">和</tt> · <tt class="docutils literal">some</tt> · <tt class="docutils literal">text</tt></blockquote>
        <p>生产：</p>
        <blockquote>
        <tt class="docutils literal">输出</tt> · <tt class="docutils literal">和</tt> · <tt class="docutils literal">一些</tt> · <tt class="docutils literal">文本</tt></blockquote>
        <hr class="docutils">

        <h3>例3</h3>
        <p>Acceleo代码：</p>
        <blockquote>↪ <tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> · <tt class="docutils literal"><span class="pre">[self /] [/ for]</span></tt> · <tt class="docutils literal">和</tt> · <tt class="docutils literal">some</tt> · <tt class="docutils literal">text</tt></blockquote>
        <p>生产：</p>
        <blockquote>↪· <tt class="docutils literal">false</tt> · <tt class="docutils literal">false</tt> · <tt class="docutils literal">和</tt> · <tt class="docutils literal">some</tt> · <tt class="docutils literal">text</tt></blockquote>
        <hr class="docutils">

        <h3>例4</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">text [for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> ¶</p>
        <p>↪ <tt class="docutils literal">[self /]</tt> ¶</p>
        <p><tt class="docutils literal">[/用于]文本</tt></p>
        </blockquote>
        <p>生产：</p>
        <blockquote>
        <p><tt class="docutils literal">文字</tt> ↪ <tt class="docutils literal">假</tt> ¶</p>
        <p>↪ <tt class="docutils literal">假</tt> ¶</p>
        <p><tt class="docutils literal">文本</tt></p>
        </blockquote>
        <hr class="docutils">

        <h3>例5</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">text [for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> ¶</p>
        <p>↪ <tt class="docutils literal"><span class="pre">输出[/ for]文字</span></tt></p>
        </blockquote>
        <p>生产：</p>
        <blockquote>
        <tt class="docutils literal">文字</tt> ↪ <tt class="docutils literal">输出</tt> ↪ <tt class="docutils literal">输出</tt> <tt class="docutils literal">文字</tt> ¶</blockquote>
        
        <h2>独立的单线块</h2>
        <h3>例1</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal">false，</tt> · <tt class="docutils literal"><span class="pre">false}）] [self /] [/ for]</span></tt></blockquote>
        <p>生产：</p>
        <blockquote>
        <tt class="docutils literal">falsefalsefalse</tt></blockquote>

        <hr class="docutils">

        <h3>例2</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">[if</tt> · <tt class="docutils literal"><span class="pre">（true）]输出[/ if]</span></tt></blockquote>
        <p>生产：</p>
        <blockquote>
        <tt class="docutils literal">产量</tt></blockquote>

        <hr class="docutils">

        <h3>例3</h3>
        <p>Acceleo代码：</p>
        <blockquote>↪ <tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal">false，</tt> · <tt class="docutils literal"><span class="pre">false}）] [self /] [/ for]</span></tt></blockquote>
        <p>生产：</p>
        <blockquote><tt class="docutils literal">↪falsefalsefalse</tt></blockquote>

        <hr class="docutils">

        <h3>例4</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">[/ if]</tt> ↪↪ <tt class="docutils literal">[if</tt> · <tt class="docutils literal"><span class="pre">（true）]输出[/ if]</span></tt></blockquote>
        <p>生产：</p>
        <blockquote>↪↪ <tt class="docutils literal">输出</tt></blockquote>

        <hr class="docutils">

        <h3>例5</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <tt class="docutils literal">[/ if]</tt> · <tt class="docutils literal">[评论<span class="pre">... /]</span></tt> ↪ <tt class="docutils literal">[if</tt> · <tt class="docutils literal"><span class="pre">（true）]输出[/ if]</span></tt></blockquote>
        <p>生产：</p>
        <blockquote>·↪ <tt class="docutils literal">输出</tt></blockquote>
        
        
        <h2>独立的多线块</h2>
        
        <h3>例1</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal">false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> ¶</p>
        <p>↪ <tt class="docutils literal">[self /]</tt> ¶</p>
        <p><tt class="docutils literal">[/对于]</tt></p>
        </blockquote>
        <p>生产：</p>
        <blockquote>
        <p>↪ <tt class="docutils literal">假</tt> ¶</p>
        <p>↪ <tt class="docutils literal">假</tt> ¶</p>
        <p>↪ <tt class="docutils literal">假</tt> ¶</p>
        </blockquote>

        <hr class="docutils">

        <h3>例2</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">[if</tt> · <tt class="docutils literal"><span class="pre">（false）]输出</span></tt> ¶</p>
        <p><tt class="docutils literal">[/如果]</tt></p>
        </blockquote>
        <p>什么都不产生，既不是空白，也不是空行。</p>

        <hr class="docutils">

        <h3>例3</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">[if</tt> · <tt class="docutils literal">（true）]</tt> ¶</p>
        <p>↪ <tt class="docutils literal"><span class="pre">输出[/ if]</span></tt></p>
        </blockquote>
        <p>生产：</p>
        <blockquote>↪ <tt class="docutils literal">输出</tt></blockquote>

        <hr class="docutils">

        <h3>例4</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p><tt class="docutils literal">[注释] for</tt> <tt class="docutils literal"><span class="pre">循环[/ comment] [for</span></tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> ¶</p>
        <p>↪ <tt class="docutils literal">[if</tt> · <tt class="docutils literal">（self）]</tt> ¶</p>
        <p>↪↪ <tt class="docutils literal">[self /]</tt> ¶</p>
        <p>↪ <tt class="docutils literal">[/ if]</tt> ¶</p>
        <p><tt class="docutils literal">[/对于]</tt></p>
        </blockquote>
        <p>什么都不产生，既不是空白，也不是空行。</p>

        <hr class="docutils">

        <h3>例5</h3>
        <p>Acceleo代码：</p>
        <blockquote>
        <p>↪ <tt class="docutils literal">[for</tt> · <tt class="docutils literal">（Sequence {false，</tt> · <tt class="docutils literal">false，</tt> · <tt class="docutils literal"><span class="pre">false}）]</span></tt> ¶</p>
        <p><tt class="docutils literal">[self /]</tt> ¶</p>
        <p>↪ <tt class="docutils literal">[/ for]</tt> ¶</p>
        </blockquote>
        <p>生产：</p>
        <blockquote>
        <p><tt class="docutils literal">假</tt> ¶</p>
        <p><tt class="docutils literal">假</tt> ¶</p>
        <p><tt class="docutils literal">假</tt> ¶</p>
        </blockquote>
        
        <br>
        <br>
      </section>
      
      <footer class="footer">
        <p>这些指南中的材料是版权所有（c）2008,2012 Obeo。该材料可在Eclipse Public License v1.0下获得</p>
      </footer>
    </div>
  </body>
</html><html id="2675.removals.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2011, 2018. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<meta http-equiv="Content-Style-Type" content="text/css"></meta>
<link rel="STYLESHEET" href="../book.css" type="text/css" charset="ISO-8859-1"></link>
<title>弃用的API删除</title>
</head>
<body dir="ltr">
<h1>弃用的API删除</h1>

<p>可以将不推荐使用的API标记为删除。有关详细信息，请参阅<a href="http://wiki.eclipse.org/Eclipse/API_Central/Deprecation_Policy">策略</a> 。本节介绍过去版本中发生的API删除以及将来版本中即将发生的删除。
</p>

<p>删除了Neon（4.6）版本中的API：</p>
<ol>
 <li><a href="#runtime">Eclipse 2.0运行时模型和引导API</a></li>
</ol>
<p>在Oxygen（4.7）版本中删除了API：</p>
<ol>
 <li><a href="#listenerlist">org.eclipse.jface.util。ListenerList</a></li>
</ol>

<p>删除了Photon（4.8）版本中的API：</p>
<ol>
 <li><a href="#updatemanager">更新经理</a></li>
 <li><a href="#platform-methods">平台方法</a></li>
 <li><a href="#tasklist">org.eclipse.ui.views.tasklist。任务列表</a></li>
  <li><a href="#icontextcomputer">IContextComputer</a></li>
</ol>

<p>Eclipse 4.10发行版中删除了API：</p>
<ol>
 <li><a href="#tabletreeviewer">TableTree和TableTreeViewer</a></li>
</ol>


<p>Eclipse 4.11版本中删除了API：</p>
<ol>
 <li><a href="#imageandmessagearea">来自JFace的ImageAndMessageArea</a></li>
</ol>

<p>Eclipse 4.12版本中删除了API：</p>
<ol>
 <li><a href="#iplugindescriptor">IPluginDescriptor</a></li>
 <li><a href="#tabletree">使用TableTree</a></li>
</ol>



<p>2017年6月之后计划的API清除：</p>
<ol>

 <li><a href="#auth">平台授权API</a></li>
</ol>

<p>2018年6月之后计划的API清除：</p>
<ol>
 <li><a href="#fullscreen">org.eclipse.ui.cocoa.fullscreenWindow</a></li>
</ol>

<p>2020年6月之后计划的API清除：</p>
<ol>
 <li><a href="#jfaceassert">JFace和JFace文本断言</a></li>
 <li><a href="#minputpart">删除Input和MInputPart</a></li>
 <li><a href="#mpartdescriptor">从MPartDescriptor中删除Dirtable标志</a></li>
 <li><a href="#iplatformrunnable">删除org.eclipse.core.runtime。IPlatformRunnable</a></li>
 <li><a href="#ui-dialogs">从org.eclipse.ui.dialogs中删除已弃用的对话框</a></li>
 <li><a href="#platform-getjobmanager">删除方法org.eclipse.core.runtime。平台＃getJobManager（）</a></li>
 <li><a href="#jface-popupdialog">在PopupDialog中删除不推荐使用的方法和构造函数</a></li>
</ol>

<p>2020年12月之后计划的API清除：</p>
<ol>
 <li><a href="#imodelprovider">删除org.eclipse.pde.core。IModelProvider</a></li>
</ol>

<p>2021年3月之后计划的API清除：</p>
<ol>
 <li><a href="#targetProvisioners">删除org.eclipse.pde.ui.targetProvisioners扩展点</a></li>
 <li><a href="#commandsutil">org.eclipse.core.commands.util包</a></li>
 <li><a href="#encodingactiongroup">org.eclipse.ui.editors.text。EncodingActionGroup</a></li>
 <li><a href="#equinoxlauncher">org.eclipse.core.launcher＃Main和WebStartMain</a></li>
 <li><a href="#20supportclasses">删除2.0插件兼容性类和相关API</a></li>
 <li><a href="#jobcreateSystem">删除Job.createSystem（ICoreRunnable）API</a></li>
 <li><a href="#workbenchwindowconfigurer">删除WorkbenchWindowConfigurer中不支持的方法</a></li>
</ol>

<p>2021年6月之后计划的API清除：</p>
<ol>
 <li><a href="#commands">删除org.eclipse.ui.commands包的弃用内容</a></li>
</ol>
<hr>
<!-- ############################################## -->

<h2>Eclipse 4.6发行版中的API删除</h2>

<h3>1。<a name="runtime">Eclipse 2.0运行时模型和引导API</a></h3>
<p>当Eclipse运行时转换为使用OSGi作为其实现时，不推荐使用一些用于与旧运行时进行交互的现有API，并将其移至兼容性片段（ <tt>org.eclipse.core.runtime.compatibility</tt> ）。所有仍然有效的API都移到了其他位置。自Eclipse 3.0以来，这些API一直无法使用，因此将来会被删除。将删除以下包：</p>
<ul>
 <li><tt>org.eclipse.core.boot</tt></li>
 <li><tt>org.eclipse.core.runtime.model</tt></li>
 </ul>兼容性片段<tt>org.eclipse.core.runtime.compatibility</tt>也将被删除。因此，如果未指定实现<code>org.eclipse.ui.的类，则<code>org.eclipse.ui.startup</code>扩展将不再有效<code>org.eclipse.ui.IStartup</code> 。
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=370248" target="_blank">错误370248</a> 。
</p>

<h2>Eclipse 4.7版本中的API删除</h2>

<h3>1. <a name="listenerlist">org.eclipse.jface.util。ListenerList</a></h3>
<p><code>org.eclipse.jface.util.ListenerList</code>类自2005年以来已弃用，并已被<code>org.eclipse.core.runtime.取代<code>org.eclipse.core.runtime.使用org.eclipse.core.runtime的ListenerList。ListenerList。IDENTITY</code>作为参数。<code>org.eclipse.jface.util.ListenerList</code>类计划被删除。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=436448" target="_blank">错误436448</a> 。
</p>


<!-- ############################################## -->

<h2>Eclipse 4.8版本中的API删除</h2>

<h3>1。<a name="updatemanager">更新管理器</a></h3>
<p>从旧的更新管理器API中删除了捆绑org.eclipse.update.core。该API在4.2中标记为删除。通过<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=311590" target="_blank">错误311590</a>发布。
</p>

 <h3>2。<a name="platform-methods">平台中的方法已删除</a></h3>
<p>删除了Eclipse 4.2中宣布的Platform API。该API在4.2中标记为删除。通过<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=476404" target="_blank">bug 476404</a>发布。删除以下方法：</p>
<ul>
 <li><tt>平台＃addAuthorizationInfo</tt></li>
 <li><tt>平台＃getAuthorizationInfo</tt></li>
 <li><tt>平台＃flushAuthorizationInfo</tt></li>
 <li><tt>平台＃addProtectionSpace</tt></li>
 <li><tt>平台＃getProtectionSpace</tt></li>
 </ul>

<h3>3. <a name="tasklist">org.eclipse.ui.views.tasklist。任务列表</a></h3>
<p><code>org.eclipse.ui.views.tasklist.自Eclipse 3.4以来，不推荐使用TaskList</code>类，并且已被<code>MarkerSupportView</code>取代。<code>org.eclipse.ui.views.tasklist.此类仅使用的TaskList</code>类和相关类计划被删除。
</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=436506" target="_blank">错误436506</a> 。
</p>

<h3>4。<a name="icontextcomputer">IContextComputer和相关的类</a></h3>
<p><code>org.eclipse.ui.help.IContextComputer</code>类和依赖类，即org.eclipse.ui.help。WorkbenchHelp，DialogPageContextComputer和ViewContextComputer已被删除。它们自2002年以来被弃用。
</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=442961" target="_blank">错误442961</a> 。
</p>

<!-- ############################################## -->

<h2>Eclipse 4.10发行版中的API删除</h2>

 <h3>1。<a name="tabletreeviewer">TableTreeViewer</a></h3>
<p><code>org.eclipse.jface.viewers.自Eclipse 3.1以来，不推荐使用TableTreeViewer</code>类，并且已被<code>TreeViewer</code>取代。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=540481" target="_blank">错误436505</a> 。
</p>


<!-- ############################################## -->

<h2>Eclipse 4.11发行版中的API删除</h2>

 <h3>1。<a name="imageandmessagearea">来自JFace的ImageAndMessageArea</a></h3>
<p><code>org.eclipse.jface.dialogs.ImageAndMessageArea</code>类已被删除。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=475863" target="_blank">错误475863</a> 。
</p>



<!-- ############################################## -->

<h2>Eclipse 4.12发行版中的API删除</h2>

 <h3>1。<a name="iplugindescriptor">删除IPluginDescriptor和相关API</a></h3>
<p><code>IPluginDescriptor</code>类已被删除。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=475944" target="_blank">错误475944</a> 。
</p>

<h3>2。<a name="tabletree">使用TableTree</a></h3>
<p><code>org.eclipse.swt.custom.TableTree</code>和<code>org.eclipse.swt.custom.已删除TableTreeItem</code>类以及使用这些类型的方法。
</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=475833" target="_blank">错误475833</a> 。
</p>



<!-- ############################################## -->

<h2>2017年6月之后的API清除</h2>


<h3>1。<a name="auth">平台授权API</a></h3>
<p>从Eclipse 1.0开始，Eclipse Platform类提供了用于在密钥环文件中存储和检索密码的API。此API使用固有的不安全方法来加密凭据，并使用自定义加密算法，使一些消费者难以分发和导出基于Eclipse的产品。出于这些原因和其他原因，这个API在Eclipse 3.4中被弃用并替换为新的Equinox安全存储API。在Eclipse 4.2中，删除了旧授权方法的实现，但API仍然存在。这个旧API将在以后的版本中完全删除。以下API方法将从<tt>org.eclipse.core.runtime中删除<tt>。平台</tt> ：</p>
<ul>
 <li><tt>addAuthorizationInfo（URL serverUrl，String realm，String authScheme，Map info）</tt></li>
 <li><tt>getAuthorizationInfo（URL serverUrl，String realm，String authScheme）</tt></li>
 <li><tt>flushAuthorizationInfo（URL serverUrl，String realm，String authScheme）</tt></li>
 <li><tt>addProtectionSpace（URL resourceUrl，String realm）</tt></li>
 <li><tt>getProtectionSpace（URL resourceUrl）</tt></li>
 </ul>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=476404" target="_blank">错误476404</a> 。
</p>



<!-- ############################################## -->
<h2>2018年6月之后的API清除</h2>

<h3>2. <a name="fullscreen">org.eclipse.ui.cocoa.fullscreenWindow</a></h3>
<p>Eclipse Platform 4.2引入了一个特定于OS X的命令来切换全屏，名为<code>org.eclipse.ui.cocoa.fullscreenWindow</code> （ <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=376394" target="_blank">bug 376394</a> ），绑定到Command-Ctrl-F。在4.6中，我们引入了一个跨平台命令来切换全屏名为<code>org.eclipse.ui.window.fullscreenmode</code> （ <a href="https://bugs.eclipse.org/489087" target="_blank">bug 489087</a>和<a href="https://bugs.eclipse.org/491572" target="_blank">bug 491572</a> ）。因此，我们在OS X上有两个“Toggle Full Screen”命令，并且都出现在<em>快速访问中</em> 。我们将整合我们的代码以使用<code>org.eclipse.ui.window.fullscreenmode</code> ，并计划删除<code>org.eclipse.ui.cocoa.fullscreenWindow</code> 。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/493932" target="_blank">错误493932</a> 。
</p>



<!-- ############################################## -->
<h2>2020年6月之后的API清除</h2>
<h3>1. <a name="jfaceassert">org.eclipse.jface.util。Assert和org.eclipse.jface.text。断言</a></h3>
<p><code>org.eclipse.jface.util.Assert</code>和<code>org.eclipse.jface.text.计划删除Assert</code>类。
</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=528191" target="_blank">错误528191</a> 。
</p>

<h3>2。<a name="minputpart">删除Input和MInputPart</a></h3>
<p>计划删除<code>MInput</code>和<code>MInputPart</code>类以及相关的API。
</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=509868" target="_blank">错误509868</a> 。
</p>

<h3>3。<a name="mpartdescriptor">从MPartDescriptor中删除Dirtable标志</a></h3>
<p><code>DirtableMInput</code>字段将从<code>MPartDescriptor</code>类和相关API中删除。</p>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=530887" target="_blank">错误530887</a> 。
</p>

<h3>4. <a name="iplatformrunnable">org.eclipse.core.runtime。IPlatformRunnable</a></h3>
<p><code>org.eclipse.core.runtime.计划删除IPlatformRunnable</code>接口。
</p>
<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=457134" target="_blank">错误457134</a> 。
</p>


<h3>5。<a name="ui-dialogs">从org.eclipse.ui.dialogs中删除已弃用的对话框</a></h3>
<p>计划从此包中删除以下对话框：</p><ul>
 <li><tt>FileSelectionDialog</tt></li>
 <li><tt>WizardImportPage</tt></li>
 <li><tt>WizardExportPage</tt></li>
</ul>
<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=448275" target="_blank">错误448275</a> 。
</p>

<h3>6。<a name="platform-getjobmanager">删除方法org.eclipse.core.runtime。平台＃getJobManager（）</a></h3>计划从类<code>org.eclipse.core.runtime.删除<code>getJobManager()</code>方法<code>org.eclipse.core.runtime.Platform</code> 。鼓励客户使用方法<code>org.eclipse.core.runtime.jobs.Job#getJobManager()</code>代替。

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=528192" target="_blank">错误528192</a> 。
</p>

<h3>7。<a name="jface-popupdialog">在PopupDialog中删除不推荐使用的方法和构造函数</a></h3>计划从类<code>org.eclipse.jface.dialogs.删除<code>getPersistBounds()</code>方法<code>org.eclipse.jface.dialogs.PopupDialog</code> 。鼓励客户使用方法<code>getPersistLocation()</code>或<code>getPersistSize()</code>代替。还计划删除已弃用的构造函数。客户端应使用未弃用的构造函数。

<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=531913" target="_blank">错误531913</a> 。
</p>


<!-- ############################################## -->
<h2>2020年12月之后的API清除</h2>

<h3>1。<a name="imodelprovider">删除org.eclipse.pde.core。IModelProvider</a></h3><code>org.eclipse.pde.core.计划删除IModelProvider</code>接口。

<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=541068" target="_blank">错误541068</a> 。
</p>


<!-- ############################################## -->
<h2>2021年3月之后的API清除</h2>

<h3>1。<a name="targetProvisioners">删除org.eclipse.pde.ui.targetProvisioners扩展点</a></h3>计划删除<code>org.eclipse.pde.ui.targetProvisioners</code>扩展点。客户端应该使用<code>org.eclipse.pde.ui.targetLocationProvisioners</code>扩展点。

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=541806" target="_blank">错误541806</a> 。
</p>

<h3>2. <a name="commandsutil">org.eclipse.core.commands.util包</a></h3>计划删除<code>org.eclipse.core.commands.util</code>包。它包含一个用于跟踪代码的实用程序类。

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=143992" target="_blank">错误143992</a> 。
</p>

<h3>3. <a name="encodingactiongroup">org.eclipse.ui.editors.text。EncodingActionGroup</a>和相关接口</h3>类<code>org.eclipse.ui.editors.text.EncodingActionGroup</code>及其相关接口<code>org.eclipse.ui.editors.text.IEncodingActionsConstants</code> ， <code>org.eclipse.ui.editors.text.IEncodingActionsDefinitionIds</code> ， <code>org.eclipse.ui.editors.text.计划删除IEncodingActionsHelpContextIds</code> 。它们已被Eclipse 3.1弃用。

<p>有关更改的详细信息或提供有关此更改的反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=544309" target="_blank">错误544309</a> 。
</p>

<h3>4. <a name="equinoxlauncher">org.eclipse.core.launcher＃Main和WebStartMain</a>及相关接口</h3>类<code>org.eclipse.core.launcher.Main</code> ， <code>org.eclipse.equinox.launcher.WebStartMain</code>将删除其相关接口。

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=544262" target="_blank">错误544262</a> 。
</p>

<h3>5。<a name="20supportclasses">删除2.0插件兼容性类和相关API</a></h3>将删除以下类及其相关API。

<ul>
 <li><tt>ILibrary</tt></li>
 <li><tt>IPluginPrerequisite</tt></li>
 <li><tt>IPluginRegistry</tt></li>
</ul>

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=544339" target="_blank">错误544339</a> 。
</p>


<h3>7。<a name="jobcreateSystem">删除Job.createSystem（ICoreRunnable）API</a></h3><code>Job#createSystem(ICoreRunnable)</code>将被删除。请改用<code>JobcreateSystem(String, ICoreRunnable)</code> 。

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=531968" target="_blank">错误531968</a> 。
</p>


<h3>8。<a name="workbenchwindowconfigurer">删除WorkbenchWindowConfigurer中不支持的方法</a></h3>平台不再使用以下方法，将被删除。


<ul>
 <li><tt>createMenuBar</tt></li>
 <li><tt>createCoolBarControl</tt></li>
 <li><tt>createStatusLineControl</tt></li>
 <li><tt>createPageComposite</tt></li>
 <li><tt>setShowFastViewBars</tt></li>
 <li><tt>getShowFastViewBars</tt></li>
</ul>

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=485835" target="_blank">错误485835</a> 。
</p>


<!-- ############################################## -->
<h2>2021年6月之后的API清除</h2>

<h3>1。<a name="commands">删除org.eclipse.ui.commands包的弃用内容</a></h3>平台不再使用以下已弃用的org.eclipse.ui.commands内容，将被删除。

<ul> <li>AbstractHandler</li>
 <li>的ActionHandler</li>
 <li>CategoryEvent</li>
 <li>CommandEvent</li>
 <li>CommandException</li>
 <li>CommandManagerEvent</li>
 <li>为ExecutionException</li>
 <li>HandlerEvent</li>
 <li>HandlerSubmission</li>
 <li>ICategory</li>
 <li>ICategoryListener</li>
 <li>ICommand的</li>
 <li>ICommandListener</li>
 <li>ICommandManager</li>
 <li>ICommandManagerListener</li>
 <li>IHandler</li>
 <li>IHandlerListener</li>
 <li>IKeyConfiguration</li>
 <li>IKeyConfigurationListener</li>
 <li>IKeySequenceBinding</li>
 <li>IWorkbenchCommandSupport</li>
 <li>KeyConfigurationEvent</li>
 <li>NotDefinedException</li>
 <li>NotHandledException</li>
 <li>优先</li>
 <li>org.eclipse.ui。IWorkbench.getCommandSupport（）</li>
</ul>

<p>有关此更改的更多详细信息或提供反馈，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=431177" target="_blank">错误431177</a> 。
</p>

</body>
</html><html id="0293.exampletemplate.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<link href="_stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen"></link>
<link href="_stock/sysdoc.css" type="text/css" rel="stylesheet" media="print"></link>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>如何使用模板扩展用户界面中的示例模板</title>

   <style type="text/css" media="screen">.ButtonBox {
  background-image: url('_stock/gradient.jpg');
}
</style>
   </head>
   <body dir="ltr">
   <table width="100%" border="0" cellspacing="0" cellpadding="0"><tbody><tr>
   </tr><tr><td class="DocSetBox" width="25%">
   <p> </p>
   </td>
   <td class="ButtonBox" align="right" width="40%">
   <p><a href="../_index/index.html"></a>   
   <a href="Howtoregistertemplates.html"><img height="22" alt="[以前]" src="_stock/btn_prev_wt.gif" width="85" border="0"></a> <a href="index.html"></a></p>
   </td>
   </tr></tbody></table>
   <hr noshade="" size="1">
   <p class="breadcrumbNav"><span class="separator">»</span> <a href="index.html">如何使用模板扩展用户界面</a> <span class="separator">»</span>示例模板</p>

   <hr noshade="" size="1">
   <div class="AuthoredContent">
    

</div><div class="Head1">

<h1>示例模板</h1>
</div><div class="Bodytext">
<p>以下是创建简单Symbian OS <code class="filename">EXE</code>项目的示例模板：</p>
<p class="CodeBlock"><code>&lt;？xml version =“1.0”encoding =“ISO-8859-1”？&gt;<br>&lt;template type =“ProjTempl”version =“1.0”supplier =“Symbian”revision =“1.0”author =“Bala Torati”<br>id =“EXE”label =“Simple EXE”description =“骨干Symbian OS EXE项目。为源创建一个文件夹，为include创建另一个文件夹。“<br>帮助= “help.html”&gt;<br>
<br>&lt;property-group id =“basics”label =“基本设置”description =“项目的基本属性”type =“PAGES-ONLY”help =“help.html”&gt;<br>
        <br>&lt;property id =“uid2”<br>label =“UID 2”<br>description =“UID 2”<br>默认值=“00000000”<br>类型=“输入”<br>图案= “0X [0-9A-FA-F] {8}”<br>隐藏=“假”<br>强制性=“真”<br>坚持= “真”/&gt;<br>
        <br>&lt;property id =“uid3”<br>label =“UID 3”<br>description =“UID 3”<br>默认值=“00000000”<br>类型=“输入”<br>图案= “0X [0-9A-FA-F] {8}”<br>隐藏=“假”<br>强制性=“假”<br>坚持= “真”/&gt;<br>
<br>&lt;property id =“vid”<br>label =“供应商ID”<br>description =“供应商ID”<br>默认值=“00000000”<br>类型=“输入”<br>图案= “0X [0-9A-FA-F] {8}”<br>隐藏=“假”<br>强制性=“真”<br>坚持= “真”/&gt;<br>
<br>&lt;property id =“author”<br>标签=“作者”<br>description =“作者姓名”<br>类型=“输入”<br>图案= “*”<br>默认值=“”<br>隐藏=“假”<br>坚持= “真”/&gt;<br>
<br>&lt;property id =“copyright”<br>label =“版权声明”<br>description =“您的版权声明”<br>类型=“输入”<br>图案= “*”<br>default =“您的版权声明”<br>隐藏=“假”<br>坚持= “真”/&gt;<br>
<br>&lt;property id =“targetType”<br>label =“目标类型”<br>description =“选择目标类型”<br>类型=“选择”<br>默认为“应用程序”<br>隐藏=“假”<br>强制性=“真”<br>坚持=“真”&gt;<br>&lt;item label =“APP”value =“app”/&gt;<br>&lt;item label =“LIB”value =“lib”/&gt;<br>&lt;item label =“DLL”value =“dll”/&gt;<br>&lt;item label =“EXE”value =“exe”/&gt;<br>&lt;item label =“EXEDLL”value =“exedll”/&gt;<br>&lt;/属性&gt;<br>&lt;/属性组&gt;<br>
<br>&lt;property-group id =“directories”label =“项目目录”description =“生成的文件将被复制到项目根目录下的指定目录”type =“PAGES-ONLY”help =“help.html”&gt;<br>&lt;property id =“incDir”<br>标签=“包含”<br>description =“C ++头文件的目录”<br>类型=“输入”<br>默认为“公司”<br>图案= “[A-ZA-Z0-9] +”<br>强制性=“真”<br>坚持= “真”/&gt;<br>
<br>&lt;property id =“sourceDir”<br>标签=“源”<br>description =“C ++源文件的目录”<br>类型=“输入”<br>默认为“SRC”<br>图案= “[A-ZA-Z0-9] +”<br>强制性=“真”<br>坚持= “真”/&gt;<br>&lt;/属性组&gt;<br>
    <br>&lt;process type =“org.eclipse.cdt.managedbuilder.core。NewManagedProject“&gt;<br>&lt;simple name =“name”value =“$（projectName）”/&gt;<br>&lt;simple name =“targetType”value =“$（targetType）”/&gt;<br>&lt;simple name =“uid2”value =“$（uid2）”/&gt;<br>&lt;simple name =“uid3”value =“$（uid3）”/&gt;<br>&lt;simple name =“vid”value =“$（vid）”/&gt;<br>&lt;/过程&gt;<br>
<br>&lt;process type =“org.eclipse.cdt.core。CreateSourceFolder“&gt;<br>&lt;simple name =“projectName”value =“$（projectName）”/&gt;<br>&lt;simple name =“path”value =“$（sourceDir）”/&gt;<br>&lt;/过程&gt;<br>
<br>&lt;process type =“org.eclipse.cdt.managedbuilder.core。CreateIncludeFolder“&gt;<br>&lt;simple name =“projectName”value =“$（projectName）”/&gt;<br>&lt;simple name =“path”value =“$（incDir）”/&gt;<br>&lt;/过程&gt;<br>
<br>&lt;process type =“org.eclipse.cdt.core。AddFiles“&gt;<br>&lt;simple name =“projectName”value =“$（projectName）”/&gt;<br>&lt;complex-array name =“files”&gt;<br>&lt;元件&gt;<br>&lt;simple name =“source”value =“inc / Basename.h”/&gt;<br>&lt;simple name =“target”value =“$（incDir）/ $（baseName）.h”/&gt;<br>&lt;simple name =“replaceable”value =“true”/&gt;<br>&lt;/元件&gt;<br>&lt;元件&gt;<br>&lt;simple name =“source”value =“src / Basename.cpp”/&gt;<br>&lt;simple name =“target”value =“$（sourceDir）/ $（baseName）.cpp”/&gt;<br>&lt;simple name =“replaceable”value =“true”/&gt;<br>&lt;/元件&gt;<br>&lt;/复杂阵列&gt;<br>&lt;/过程&gt;<br>
<br>&lt;process type =“org.eclipse.cdt.managedbuilder.core。AppendToMBSStringListOptionValues“&gt;<br>&lt;simple name =“projectName”value =“$（projectName）”/&gt;<br>&lt;complex-array name =“resourcePaths”&gt;<br>&lt;元件&gt;<br>&lt;simple name =“id”value =“。* linker \ .libraries \ .libraries。*”/&gt;<br>&lt;simple-array name =“values”&gt;<br>&lt;element value =“euser.lib”/&gt;<br>&lt;/简单阵列&gt;<br>&lt;simple name =“path”value =“”/&gt;<br>&lt;/元件&gt;<br>&lt;/复杂阵列&gt;<br>&lt;/过程&gt;<br>&lt;/模板&gt;</code></p>
<p>上面给出的模板分别复制<code>src</code>和<code>inc</code>文件夹中的以下源（ <code class="filename">.cpp</code> ）和头文件（ <code class="filename">.h</code> ）。这些文件使用一组宏来获取开发人员为文件名，作者姓名，版权等指定的值。</p>
<p class="CodeBlock"><code>/ *<br>================================================== ==========================<br>名称：$（baseName）.cpp<br>作者：$（作者）<br>版本：<br>版权：$（版权）<br>描述：Exe源文件<br>================================================== ==========================<br>* /<br>
<br>//包含文件<br>
<br>#include“$（baseName）.h”<br>#include &lt;e32base.h&gt;<br>#include &lt;e32std.h&gt;<br>#include &lt;e32cons.h&gt; //控制台<br>
<br>
<br>//常数<br>
<br>_LIT（KTextConsoleTitle，“Console”）;<br>_LIT（KTextFailed，“失败，请假代码=％d”）;<br>_LIT（KTextPressAnyKey，“[按任意键] \ n”）;<br>
<br>
<br>//全局变量<br>
<br>LOCAL_D CConsoleBase * console; //将所有消息写入此消息<br>
<br>
<br>//本地函数<br>
<br>LOCAL_C void MainL（const TDesC＆aArgs）<br>{<br>//<br>//在这里添加程序代码，下面是示例代码<br>//<br>console-&gt; Write（_L（“你好，世界！\ n“））;<br>console-&gt; Printf（_L（“命令行参数：\”％S \“\ n”）和＆aArgs）;<br>}<br>
<br>
<br>LOCAL_C void DoStartL（）<br>{<br>//创建活动调度程序（运行活动对象）<br>CActiveScheduler * scheduler = new（ELeave）CActiveScheduler（）;<br>清理栈:: PushL（调度）;<br>CActiveScheduler ::安装（调度）;<br>
<br>//使用命令行调用main函数<br>TBuf &lt;256&gt; cmdLine;<br>RProcess（）。的CommandLine（CMDLINE）;<br>成为内地（CMDLINE）;<br>
<br>//删除活动的调度程序<br>清理栈:: PopAndDestroy（调度）;<br>}<br>
<br>
<br>//全局函数<br>
<br>GLDEF_C TInt E32Main（）<br>{<br>//创建清理堆栈<br>__UHEAP_MARK;<br>CTrapCleanup * cleanup = CTrapCleanup :: New（）;<br>
<br>//创建输出控制台<br>TRAPD（createError，console = Console :: NewL（KTextConsoleTitle，TSize（KConsFullScreen，KConsFullScreen）））;<br>if（createError）<br>return createError;<br>
<br>//在TRAP线束内运行应用程序代码，终止时等待按键<br>TRAPD（mainError，DoStartL（））;<br>if（mainError）<br>console-&gt; Printf（KTextFailed，mainError）;<br>控制台 - &gt; printf的（KTextPressAnyKey）;<br>控制台 - &gt;的getch（）;<br>
    <br>删除控制台;<br>删除清理;<br>__UHEAP_MARKEND;<br>返回KErrNone;<br>}</code></p>
<p class="CodeBlock"><code>/ *<br>================================================== ==========================<br>名称：$（baseName）.h<br>作者：$（作者）<br>版本：<br>版权：$（版权）<br>描述：Exe头文件<br>================================================== ==========================<br>* /<br>
<br>#ifndef __ $（baseName）_H__<br>#define __ $（baseName）_H__<br>
<br>
<br>//包含文件<br>
<br>#include &lt;e32base.h&gt;<br>
<br>
<br>//功能原型<br>
<br>GLDEF_C TInt E32Main（）;<br>
<br>
<br>#endif // __ $（baseName）_H__</code></p>
<p>当开发人员在“新建项目”向导中选择上述模板时，将生成以下向导页面：</p>
<div class="Figure">
	<p class="Image"><a name="Basic Settings"><img alt="基本设置" src="_stock/basicsettings.gif" border="0"></a></p>
<p class="Caption">基本设置</p>
</div>
<div class="Figure">
	<p class="Image"><a name="Project Directories"><img alt="项目目录" src="_stock/projectdirectories.gif" border="0"></a></p>
<p class="Caption">项目目录</p>
</div>
<p>上述给定页面中列出的输入字段与模板中给出的定义一致。在模板中，ID为“basics”的<code>property-group</code>元素定义了<code class="ProgramOutput">Basic Settings</code>页面所需的所有输入字段。具有ID“directories”的<code class="ProgramOutput">property-group</code>元素定义了<code class="ProgramOutput">Project Directories</code>页面所需的所有输入字段。
</p>
<p>该模板将在Eclipse工作区中创建一个包含所有必需资源的Symbian OS <code class="filename">EXE</code>项目。
</p>
<p>以下<code class="ProgramOutput">C/C++ Projects</code>视图显示了New Project向导为上面给出的模板创建的资源：</p>
<div class="Figure">
	<p class="Image"><a name="Explorer view"><img alt="Explorer视图" src="_stock/explorerview.gif" border="0"></a></p>
<p class="Caption">Explorer视图</p>
</div> 

   </div><div class="Footer">
   <hr noshade="" size="1">
   <table cellpadding="0" cellspacing="0" border="0" width="100%">
     <tr>
       <td class="ButtonBottomBox" align="right" height="12" width="67%">
         <p>
	 <a href="Howtoregistertemplates.html"><img height="22" alt="[以前]" src="_stock/btn_prev.gif" width="85" border="0"></a>
	 <a href="#_top"><img height="22" alt="[最佳]" src="_stock/btn_top.gif" width="51" align="bottom" border="0"></a> 
           <a href="index.html"></a>
         </p>
       </td>
     </tr>
   </table>
   </div>
   </body>
   </html><html id="2041.s2.4.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s2.3.html" rel="prev">&lt;&lt;§2.3提升</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.5.html" rel="next">§2.5摘要角色&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
         <div class="sect depth2" id="s2.4">
            <h2 class="sect">§2.4明确的角色创建<a class="img" href="s2.4.html" title="PermaLinkto§2.4显式角色创建"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <p>提升是隐式创建角色对象的常用技术。本节定义了在哪些条件下还可以明确创建角色。
               		
            </p>
            <div class="sect depth3" id="s2.4.1">
               <h3 class="sect">§2.4.1通过提升构造函数创建角色<a class="img" href="s2.4.1.html" title="PermaLinkto§2.4.1通过提升构造函数创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.4</a></span></h3>
               <p>提升使用角色的默认构造函数（参见<a href="s2.3.1.html" title="§2.3.1隐式角色创建" class="sect">§2.3.1</a> ）。如果遵循以下规则，则可以从客户端代码调用此构造函数。
                  			
               </p>
               <div class="subsect depth4" id="s2.4.1.a">
                  <h4 class="subsect">（a） <span class="title">团队背景</span><a class="img" href="s2.4.1.a.html" title="PermaLink到（a）团队环境"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>提升构造函数只能在要实例化的角色的封闭团队中使用。因此，合格的分配表达式（ <code>someTeam.new SomeRole(..)</code> ）可能永远不会使用提升构造函数。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.4.1.b">
                  <h4 class="subsect">（b） <span class="title">新鲜基础物体</span><a class="img" href="s2.4.1.b.html" title="PermaLink to（b）Fresh base object"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果提升构造函数调用的参数是一个<code>new</code>表达式，创建一个新的基础对象，则使用提升构造函数是安全的。否则，以下（c）的规则适用。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.4.1.c">
                  <h4 class="subsect">（c） <span class="title">重复角色运行时检查</span><a class="img" href="s2.4.1.c.html" title="PermaLink到（c）重复角色运行时检查"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果它不能在语法上派生，那么提升构造函数的参数是一个新创建的基础对象（b），编译时警告将指示需要进行额外的运行时检查：必须防止为a创建新角色基础对象，已在给定团队中具有所需类型的角色。使用提升构造器无法替换现有角色。在运行时，任何尝试这样做都会导致<code>org.objectteams.要抛出DuplicateRoleException</code> 。此异常只能在发出上述编译时警告的情况下发生。
                     		<br><a href="s6.1.html" title="§6.1反思" class="sect">§6.1</a>将引入反射函数，可用于手动防止重复角色等错误。
                     				
                  </p>
               </div>
            </div>
            <div class="sect depth3" id="s2.4.2">
               <h3 class="sect">§2.4.2通过常规构造函数创建角色<a class="img" href="s2.4.2.html" title="PermaLinkto§2.4.2通过常规构造函数创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.4</a></span></h3>
               <p>还可以使用具有除提升构造函数的签名之外的任意签名的自定义构造函数来显式创建角色。<br>在角色构造函数中，有四种自调用：</p>
               <dl>
                  <dt><code>基础（..）</code></dt>
                  <dd>相应基类的构造函数（第<a href="sA.html#sA.5.3" title="§A.5.3BaseCall" class="sect">A.5.3节</a> （c））， <span class="underline">除非</span>该角色涉及基类循环（第<a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">2.1.2节（b）</a> ），在这种情况下，基础构造函数调用是非法的。
                  </dd>
                  <dt><code>这个（..）</code></dt>
                  <dd>同一类的另一个构造函数。</dd>
                  <dt><code>超（..）</code></dt>
                  <dd>超类的构造函数（normal <code>extends</code> ）， <span class="underline">除非</span>超类绑定到不同的基类，在这种情况下调用<code>super(..)</code>是不合法的。
                  </dd>
                  <dt><code>tsuper（..）</code></dt>
                  <dd>超级团队相应角色的构造函数（ <a href="sA.html#sA.5.4" title="§A.5.4TSuperCall" class="sect">§A.5.4</a> （e））。另见<a href="s1.3.2.c.html" title="§1.3.2。（c）构造者和被覆盖的&#39;延伸&#39;" class="sect">§1.3.2。（c）中</a>的约束。
                  </dd>
               </dl>
               <div class="subsect depth4" id="s2.4.2.a">
                  <h4 class="subsect">（a） <span class="title">不受约束的角色</span><a class="img" href="s2.4.2.a.html" title="PermaLink到（a）未绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><strong>未绑定</strong>到基类的角色的每个构造函数必须使用<code>this(..)</code> ， <code>super(..)</code>或<code>tsuper(..)</code> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.4.2.b">
                  <h4 class="subsect">（b） <span class="title">约束角色</span><a class="img" href="s2.4.2.b.html" title="PermaLink到（b）绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><strong>绑定角色的</strong>每个构造函数必须直接或间接调用<code>base(..)</code>构造函数或提升构造函数（参见<a href="s2.3.1.html" title="§2.3.1隐式角色创建" class="sect">§2.3.1</a> ）。间接调用基础构造函数或提升构造函数可以使用任何<code>this(..)</code> ， <code>super(..)</code> 或者<code>tsuper(..)</code> ，它只是将义务委托给被调用的构造函数。
                     		<br>如果<code>base(..)</code>引用的构造函数根据Java的常规规则不可见，则仍可使用解<b>封装</b>调用它（另请参见<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ， <a href="s2.1.2.c.html" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）。
                     <br>请注意，如果未绑定super或tsuper角色，则将该义务委派给该未绑定角色将不起作用。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.4.2.c">
                  <h4 class="subsect">（c） <span class="title">超级约束角色</span><a class="img" href="s2.4.2.c.html" title="PermaLink to（c）超级调用绑定角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>而不是在调用<code>base(..)</code>之前或之前，绑定角色的构造函数显式或隐式地调用超级构造函数。哪个构造函数适用取决于超级角色及其<code>playedBy</code>子句。
                     				
                  </p>
                  <ul>
                     <li>如果超级角色绑定到与当前角色相同的基类，<ul>
                           <li>不写超级调用会导致调用超级角色的提升构造函数。</li>
                           <li>显式调用超构造函数需要超级构造<i>要么</i><ol>
                                 <li>使用基础构造函数调用（直接或间接）创建角色实例， <i>或</i></li>
                                 <li>是一个提升构造函数，接收一个基本实例，当前角色必须提供该实例作为参数。</li>
                              </ol>
                           </li>
                        </ul>
                     </li>
                     <li>如果超级角色被绑定但当前角色改进了<code>playedBy</code>关系（参见<a href="s2.1.c.html" title="§2.1。（c）协变细化" class="sect">§2.1。（c）</a> ），<ul>
                           <li>必须调用提升构造函数，显式传递基础对象作为参数。</li>
                        </ul>
                     </li>
                     <li>如果角色具有未绑定的显式或隐式超级角色，则构造函数可以在调用<code>base(..)</code>之前可选地调用超级构造函数（使用<code>super(..)</code>或<code>tsuper(..)</code> <code>base(..)</code> 。否则，将隐式调用默认构造函数。
                        					
                     </li>
                  </ul>
                  <p>在调用超级角色的提升构造函数时，可以选择通过使用基础构造函数调用作为表达式来获取基础对象：</p>
                  <div class="listing plain"><pre>super（base（ <i>&lt;args&gt;</i> ））;</pre></div>
               </div>
               <p>语言系统通过使用具有匹配签名的构造函数创建适当基类的实例来评估基本构造函数。此外，还设置了从角色访问基础对象以及将来将基础对象提升到新角色所需的内部链接。
                  			
               </p>
               <p>基本构造函数的语法遵循以下规则：角色实现永远不会直接引用基类的任何名称或其功能。
                  			
               </p>
            </div>
            <div class="sect depth3" id="s2.4.3">
               <h3 class="sect">§2.4.3在智能提升的情况下创建角色<a class="img" href="s2.4.3.html" title="PermaLinkto§2.4.3在智能提升的情况下创建角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.4</a></span></h3>
               <p>明确地实例化绑定到基本<code>B</code>的角色<code>R1</code> ，其中智能提升<code>B</code>到<code>R1</code>实际上将提供子角色<code>R2</code>是危险的：实例化将<code>R1</code>输入到团队的内部缓存中。如果在以后任何时候请求将此<code>B</code>提升为<code>R2</code> ，这是合法请求，则运行时系统将通过抛出<code>org.objectteams.WrongRoleException</code>因为它找到<code>R1</code>而不是所需的<code>R2</code> 。因此，在这种特定情况下，显式实例化<code>new R1(..)</code>将被警告标记。通过在实例化表达式中使用<code>R2</code>可以避免该问题。
                  			
               </p>
               <h5 class="listing">示例代码（WrongRoleException）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>课</b> B { <b>void</b> bm（）{}}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>班级</b> T {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>受保护的</b> <b>类</b> R1 <b>播放了</b> B {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  <b>受保护的</b> <b>类</b> R2 <b>扩展</b> R1 { <span class="comment">//继承绑定到B</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>    <b>void</b> rm（）{ <span class="comment">/ * body省略* /</span> }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>public</b> B getDecoratedB（）{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    <b>返回</b> <em><b>新的</b> R1</em> （ <b>new</b> B（））; <span class="comment">// <span class="error">编译时警告！</span></span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>  <b>public</b> <b>void</b> requestLifting（B <b>as</b> R2 r）{}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre>T t = <b>new</b> T（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>B b = t.getDecoratedB（）; <span class="comment">//为b创建一个R1</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>t.requestLifting（b）中; <span class="comment">// =&gt; <span class="error"><code>org.objectteams.WrongRoleException！</code></span></span></pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <ul>
                     <li>第8行的注释：该行将新的<code>B</code>实例传递给<code>R1</code>的提升构造函数（参见<a href="#s2.4.1.b" title="§2.4.1。（b）新鲜的基础物体" class="sect">§2.4.1。（b）</a> ）。为了返回此<code>B</code>实例，降级被隐式用于return语句。
                     </li>
                     <li>当执行第15行时，请求将<code>b</code>提升到<code>R2</code> ，但是由于第8行，在内部高速缓存中找到了<code>R1</code> 。
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s2.3.html" rel="prev">&lt;&lt;§2.3提升</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.5.html" rel="next">§2.5摘要角色&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="2835.org_eclipse_ltk_ui_refactoring_changePreviewViewers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>重构更改预览查看器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">重构更改预览查看器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.ui.refactoring.changePreviewViewers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义能够呈现更改对象的特殊查看器。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.internal.ui.refactoring.AbstractDescriptor#matches(Object, String): -->默认变量是用于显示预览的更改对象。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“更改”：输入<code>org.eclipse.ltk.core.refactoring.Change</code> ;更改对象以呈现预览（与默认变量相同）</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.changePreviewViewer">changePreviewViewer</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符。</li>
<li><b>id</b> - 扩展实例的可选标识符。</li>
<li><b>name</b> - 扩展实例的可选名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.changePreviewViewer">changePreviewViewer</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST changePreviewViewer</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 更改预览查看器的唯一标识符。</li>
<li><b>class</b> - 提供实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面的示例为文本更改对象提供了预览查看器。

<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ltk.ui.refactoring.changePreviewViewers”</span> <span class="code SchemaTag">&gt; &lt;changePreviewViewer class =</span> <span class="code SchemaCstring">“org.eclipse.ltk.internal.ui.refactoring。TextEditChangePreviewViewer“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.ltk.internal.ui.refactoring.textEditChangePreviewViewer“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.ltk.core.refactoring。TextChange“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ changePreviewViewer&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.ui.refactoring.IChangePreviewViewer</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3334.Trees.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>树</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingTreeEditors">指定树编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingTreeEditors">指定树编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#tree_description">树的描述</a>
						<ol style="list-style:disc">
							<li>
								<a href="#tree_tools">树工具</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#mappings">树项映射</a>
						<ol style="list-style:disc">
							<li>
								<a href="#item_style">物品风格</a>
							</li>
							<li>
								<a href="#item_tools">物品工具</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>树是一种表示，它为您的数据提供分层视点。它可以以清晰简洁的方式提供大量信息，并且当用户扩展树元素以“挖掘”模型时，可以特别有用地逐步显示关于模型的更多和更详细的信息。</p>
		<p>树木可能是Sirius中最容易定义的表示形式。不要犹豫，定义小树描述，甚至只读，以提供数据的替代和合成视点，如类型层次结构，元素之间的依赖关系等。</p> 
		<img border="0" src="./images/tree_description_editor.png">
<em>
<ul>
<img src="images/tricks.png" style="display:inline;margin:0px;padding:0px"> <em>使用<img src="images/questionMarque.png" style="display:inline;margin:0px;padding:0px">用于访问可用字段工具提示的图标：</em>
<ul>
			<li> 
		<b>Id</b>字段：此元素的标识符。必须是独特的。更改此标识符将破坏引用旧标识符的现有用户模型。</li>
			<li> 
		<b>标签</b>字段：用于向最终用户显示此标签的标签。</li>
			<li> 
		<b>域类</b>字段：节点表示的元素的类型。</li>
			<li> 
		<b>语义候选者表达</b>字段：<ul>
			    <li>预期的返回类型： <code>Collection&lt;EObject&gt;</code>或EObject。</li>
			        <li>可变变量：<ul>
		    		    <li>containerView：ecore。EObject |当前DTreeElement的容器（如果容器不为null，则变量可用）。</li>
			    	    <li>观点：天狼星。DTreeElement |当前的DTreeElement。</li>
				        <li>容器：ecore。EObject | $ containerView的语义目标（如果它是DSemanticDecorator）。</li>
			        </ul>
			    </li>
			    </ul>
			</li>
</ul>
</ul>
</em>
		<p>
			<strong>注意</strong> ：图表中存在的图层，过滤器和映射导入等高级功能目前不适用于树。
		</p>
		<h2 id="tree_description">树的描述</h2>
		<p>与其他类型的Sirius表示类似，通过在<a href="../../Glossary.html#VSM"><em>视点规范模型中</em></a>创建<em>树描述</em>元素及其子元素来配置<em>树</em> 。
		</p>
		<p><em>树描述</em>具有强制<em>Id</em> ，在其所属的视点的上下文中必须是唯一的，并且是可选的<em>Label</em> 。<em>Id</em>在内部用于标识树的类型，并且必须在不同版本的描述中保持稳定（或者它将使用旧<em>Id</em>创建的树不可用）。<em>标签</em>在UI中使用，并且对最终用户可见。它可以在不影响现有表示文件的情况下进行更改。如果未指定<em>Label</em> ，则在UI中使用<em>Id</em> 。</p>
		<p><em>树描述</em>的强制<em>Domain Class</em>属性是由<em>树</em>表示的语义元素的类型。在<em>模型资源管理器中</em> ，最终用户将能够在此类型的语义元素上创建此树的新实例（假设在<em>建模项目中</em>启用了相应的视点）。域类名称的语法可以是基本名称，如<code>Class</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml.Class</code> ，或完全限定的URI，如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Class</code> 。</p>
		<p>默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新树。您可以使用“ <em>前置条件表达式”</em> （在“ <em>高级”</em>类别中可用）来更改此值。如果指定了这样的表达式，则将在用户选择的语义元素的上下文中对其进行求值，并且仅当表达式返回<code>true</code>时，用户才能够在此元素上创建新树。
		</p>
		<p>可以使用<em>Title表达式</em>指定新创建的树的默认标题， <em>Title表达式</em>在创建树的语义元素的上下文中计算，并应返回字符串。如果未指定表达式，则默认标题是树描述的标签（如果未设置<em>Label，</em>则为其<em>ID</em> ），前缀为字符串<code>"new "</code> （例如， <code>new Class Hierarchy</code> ）。
		</p>
		<p>建议将<em>树描述</em>明确地与它将表示的语义元素的元模型相关联。您可以在“ <em>树描述”</em>的“ <em>元模型”</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p>最后， <em>初始化</em>和<em>显示启动</em>标志控制是否在没有用户干预的情况下自动创建和/或打开树实例。如果设置了<em>Initialization</em> ，则当启用包含此树描述的视点时，将在所有兼容的语义元素上自动创建此树描述的实例。如果在set中<em>启动</em>时<em>显示</em> ，那么当打开包含此树描述实例的建模项目时，它们将被打开：如果只存在一个这样的表示，它将自动打开;如果有多个，将出现一个对话框，允许用户选择打开哪一个。
		</p>
		<p>定义树的主要概念是：</p>
		<ul>
			<li>
				<em>树项目</em>映射，描述将出现在此树上的元素，以及它们如何映射到它们所代表的基础语义元素;</li>
			<li>
				<em>样式</em> ，描述这些表示元素的图形外观;</li>
			<li>
				<em>工具</em> ，描述最终用户可以对树及其项目执行的操作及其对相关语义元素的影响。
			</li>
		</ul>
		<h3 id="tree_tools">树工具</h3>
		<p>可以在树编辑器上定义的一些工具直接在顶级<em>Tree Description</em>元素中指定：</p>
		<ul>
			<li>
				<em>创建</em> ：直接包含在<em>树描述</em>中的<em>创建</em>工具用于创建根树项。它们通过主Eclipse工具栏中的组合按钮提供给最终用户。要配置它，只需选择工具将在<em>Mapping</em>属性中创建的树项类型，并使用常规模型操作指定工具的行为。
			</li>
			<li>
				<em>删除工具</em> ：当直接在<em>树描述中</em>定义时， <em>删除工具</em>指定当用户在树的根处（即在编辑器内部而不是在现有树项目上）删除元素时会发生什么。<em>Drag source</em>属性指示工具是否接受从树表示（值<em>树</em> ）， <em>模型资源管理器</em>视图（值<em>模型</em> ）或两者拖动的元素。如果检测到这样的drop并且<em>Precondition的</em>计算结果为<code>true</code> ，则执行drop工具的主体，其中<code>element</code>变量指向被删除的语义元素， <code>newContainer</code>是删除它的语义元素（在这种情况下是树的语义元素）。
				<i>警告</i> ：如果选择“ <em>模型”</em>或“ <em>两者”</em>作为源，则必须准备好工具以接受可在“ <em>模型资源管理器”</em>视图中出现的任何类型的源元素，包括与为工具指定的源映射无关的元素。使用前提条件检查被拖动元素的性质（可通过<code>element</code>变量获得）以禁用工具不支持的工具源元素。
			</li>
			<li>
				<em>树创建</em> ：此工具可用于从现有树项创建（和打开）新树。它将在兼容树项目的“ <em>导航”</em>上下文菜单中供最终用户使用。要配置工具，只需在<em>Mappings</em>属性中选择工具应显示哪些树项（如果需要，可以使用<em>Precondition</em>表达式更精确），并选择使用<em>Tree Description</em>属性创建哪种树。通常，将在由用户调用工具的树项所表示的语义元素上创建新树表示。有时您希望工具出现在一个元素上，但在另一个元素上创建一个表示。在这种情况下，使用“ <em>浏览”表达式</em> （在“ <em>高级”</em>类别中）从所选元素导航到实际应在其中创建新树的元素。最后，在调用工具时，将执行您在工具正文中指定的任何操作;您可以使用它来初始化所表示的模型的内容。
			</li>
			<li>
				<em>树导航</em> ：此工具与前一个工具非常相似。唯一的区别是它允许用户导航到现有树而不是创建新树。如果存在此类工具，则项目上的“ <em>导航”</em>上下文菜单将包含已在所选元素上存在的每个对应树的条目（或使用“ <em>浏览”表达式</em>从所选元素可访问）。您可以指定要在菜单项中使用的<em>导航名称表达式</em> （ <em>高级</em>类别），而不是使用现有树的标题。这有助于更明确地说明当前元素与目标树之间的关系。
			</li>
		</ul>
		<h4 id="tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h2 id="mappings">树项映射</h2>
		<p>树木本质上是递归的。它们的内容使用<em>Tree Item</em>映射的单个概念来指定，该映射可以递归地组成。<em>树描述</em>包含<em>树项目</em>映射，它定义哪些元素将出现在树的顶层，而每个<em>树项目</em>映射可以包含定义其自己的直接内容的子映射。如果元素（树或树项映射）包含多个子映射，则元素的内容将按映射的顺序出现：首先是第一个映射的所有实例，然后是第二个映射的实例，等等。</p>
		<p><em>树项目</em>映射由<em>域类</em> ， <em>语义候选表达式</em>和可选的<em>前提条件表达式</em> （在<em>高级</em>类别中）定义。<em>语义候选表达式</em>指示在语义模型中查找应该由映射表示的元素的位置。表达式在父级语义元素的上下文中进行计算（父级是树本身或父项）。它应该返回一组语义元素。只保留那些作为指定<em>域类</em>实例并且还验证可选<em>Precondition表达式</em>的实例，并将其实际表示为此映射的实例。因此与每个树项关联的语义元素称为项的<em>目标</em>元素。
		</p>
		<p>您可以通过定义<em>关联元素表达式</em> （在<em>高级类别中</em> ）将更多语义元素与项目相关联，该<em>关联元素表达式</em>在目标上下文中进行评估，并且可以返回更多语义元素。目标元素或其中一个关联元素的任何更改都将自动触发树项的刷新。
		</p>
		<p><em>树项目</em>映射可以<em>专门化</em>另一个映射，在这种情况下，它将继承所有未指定显式值的专用映射属性。
		</p>
		<p><em>树项目</em>映射可以<em>重用</em> （参见<em>Imports</em>类别）现有映射（包括其自身）作为子映射。效果与重用的映射创建为父项的子项完全相同。然而，因为映射可以重用自身或其父映射之一，所以这允许创建无限深度的树（或者至少不是先验的有界）。
		</p>
		<p>仅当用户展开父项时，才会延迟创建树项。这意味着如果您定义使用昂贵的操作来创建的子映射，则只有当用户实际“挖掘”树到相应的详细级别时才会支付成本。这也意味着通过重用，您可以创建具有潜在无限深度的树（就像用户选择扩展它们一样深），而不会冒无限循环的风险。但请注意，一旦创建了树项，如果父项折叠，它们就不会消失。只有在用户明确删除它们时才会删除它们。</p>
		<p>树项的实际外观由其<a href="#item_style">样式</a>定义，而其行为由与其关联的<a href="#item_tools">工具</a>定义。
		</p>
		<h3 id="item_style">物品风格</h3>
		<p>项目的外观由相应树项映射中定义的一个或多个<em>Style</em>元素控制。每个树项映射<em>必须只</em>包含一个默认样式（在创建映射本身时自动创建），并且<em>可能</em>包含一个或多个<em>条件样式</em> 。
		</p>
		<p>项目的样式由<em>Label表达式组成</em> ，在项目的语义目标的上下文中进行评估，并且应该返回要为项目显示的文本，以及用于控制字体，样式，颜色（文本和文本）的几个配置属性。它的背景）和项目的图标。为元素<em>显示</em>的默认图标（如果设置了<em>显示图标</em> ）是在项目的目标元素的语义元模型中定义的<em>图标</em> 。您可以使用“ <em>图标路径”</em>属性（在“ <em>高级”</em>类别中）指定其他属性。如果您有多个项目表示同一语义元素的不同方面，从而共享相同的目标，则此功能尤其有用。
		</p>
		<p>
			<em>树项目</em>映射可以有一个或多个<em>条件样式</em> 。它们是具有与上述相同属性的普通样式元素，但包含在定义布尔表达式的<em>条件样式</em>元素中。如果项目映射包含此类样式，则对于映射的每个实例，将首先按其定义的顺序尝试条件样式。使用条件为项目目标返回<code>true</code>的第一个样式（并且不测试其余样式）。如果不应用任何条件样式，则使用默认样式。请注意，由于条件是按照定义的顺序进行测试的，因此您应该从最可能优化性能的顺序对它们进行排序。
		</p>
		<h3 id="item_tools">物品工具</h3>
		<p>树项的行为由与其映射关联的工具定义。应用于树项映射的工具只是在映射本身内创建。他们可以：</p>
		<ul>
			<li>
				<em>创建工具</em> ，用于创建新的树项。映射可以包含几个这样的工具。如果工具的（可选） <em>前提条件</em>适用于实例的目标，它们将出现在映射实例的上下文菜单中。创建工具必须指定它将创建的<em>映射</em>类型。使用所有标准模型操作，在工具的主体中定义创建工具的实际行为。
			</li>
			<li>
				<em>删除工具</em> ，用于删除元素。如果映射没有明确定义删除工具，则<em>删除树项</em>操作的默认行为是从语义模型中删除项的语义<em>目标</em>和所有<em>关联元素</em> 。如果需要特定行为，则必须显式创建“ <em>删除”工具</em>并描述工具主体中的行为。如果要防止删除元素，则必须创建“ <em>删除”工具</em>并将“ <em>前提条件”</em>设置为对不应删除的元素返回<code>false</code> 。
			</li>
			<li>
				<em>直接编辑工具</em> ，用于允许最终用户直接编辑树项的标签（通过双击或按下树项目上的<em>F2</em>或<em>返回</em> ）。它指定了如何解释新标签值以及应用于模型元素的更改。<em>Edit Mask</em>元素（包含在工具中）用于解析用户输入的新标签值，并选择此标签的一部分作为编辑操作主体的输入变量。掩码可以包含<code>{N}</code>形式的子串，其中<em>N</em>是数字。与这些子字符串对应的新标签值的部分将作为名为<code>argN</code>变量提供。例如，使用编辑掩码<code>{0}:{1}</code>和由<code>attr : EString</code>用户输入的输入字符串，工具的主体将执行变量<code>arg0</code>设置为<code>attr␣</code> ， <code>arg1</code>设置为<code>␣EString</code> 。
			</li>
			<li>
				<em>删除工具</em> ：在<em>树项目</em>映射中定义时， <em>删除工具</em>指定当用户将元素放到映射实例上时会发生什么。<em>Drag source</em>属性指示工具是否接受从树表示（值<em>树</em> ）， <em>模型资源管理器</em>视图（值<em>模型</em> ）或两者拖动的元素。如果检测到这样的drop并且<em>Precondition的</em>计算结果为<code>true</code> ，则执行drop工具的主体，其中<code>element</code>变量指向被删除的语义元素， <code>newContainer</code>是删除它的语义元素（在这种情况下是树的语义元素）。
			</li>
			<li>
				<em>弹出菜单</em>用于向与任何树项关联的上下文菜单添加新菜单和操作。
			</li>
		</ul>
	</body>
</html><html id="2021.s2.3.4.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s2.3.3.html" rel="prev">&lt;&lt;§2.3.3智能提升</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.3.5.html" rel="next">§2.3.5解除问题的后果&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a> &gt; <a class="nav" href="s2.3.html" rel="section">§2.3提升</a></div>
         <div class="sect depth3" id="s2.3.4">
            <h3 class="sect">§2.3.4绑定含糊不清<a class="img" href="s2.3.4.html" title="PermaLinkto§2.3.4绑定含糊不清"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h3>
            <p>虽然到目前为止所有示例都只显示了1对1的类绑定，但允许多个绑定的情况。可以在编译时和/或在运行时检测模糊度。
               			
            </p>
            <div class="subsect depth4" id="s2.3.4.a">
               <h4 class="subsect">（a） <span class="title">潜在的模糊性</span><a class="img" href="s2.3.4.a.html" title="永久链接到（a）潜在的模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果存在两个角色类<code>R1</code>和<code>R2</code> ，则给出<strong>潜在的歧义</strong></p>
               <ul>
                  <li><code>R1</code>和<code>R2</code>由相同的基类<code>B</code>播放，并且</li>
                  <li><code>R1</code>和<code>R2</code>具有共同的超级角色<code>R0</code> ，它也绑定到基类<code>B0</code> ，和</li>
                  <li>角色类<code>R1</code>和<code>R2</code>都不是另一个的（间接）子类。
                  </li>
               </ul>
               <div class="note">
                  <h5>注意：</h5>根据<a href="s2.1.c.html" title="§2.1。（c）协变细化" class="sect">§2.1。（c）中</a> ，如果<code>B</code>有别于<code>B0</code>它必须是一个亚类的<code>B0</code> 。
                  				
               </div>
               <div class="note">
                  <h5>影响：</h5>在这种情况下，编译器发出警告，声明<code>B</code> <em>可能不是可升级的，</em>因为角色类<code>R1</code>和<code>R2</code>都是候选者，并且没有理由<em>优先</em>选择其中一个。
                  					<br><strong>如果没有检测到潜在的歧义，那么提升将始终是明确的。</strong></div>
               <p>在上述情况下，尝试将类型<code>B</code>的实例提升到角色类型<code>R0</code>是<strong>非法的提升请求</strong> 。如果<code>R0</code>与其子角色<code>R1</code>和<code>R2</code>绑定到相同的基类<code>B</code> ，则角色<code>R0</code>是<strong>不可释放的</strong> ，这意味着不能通过提升获得<code>R0</code>实例。
                  				
               </p>
               <h5 class="listing">示例代码（潜在歧义）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展了</b> SuperRole {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth4" id="s2.3.4.b">
               <h4 class="subsect">（b） <span class="title">明确的歧义</span><a class="img" href="s2.3.4.b.html" title="PermaLink to（b）明确的歧义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果有一个<strong>明确的歧义</strong></p>
               <ul>
                  <li>根据上述（a）给出的潜在歧义的情况给出了</li>
                  <li>需要提升（通过方法绑定或显式（ <a href="s2.3.2.html" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ））从共享基类<code>B</code>到任何角色类<code>R0</code> ，它是<code>R1</code>和<code>R2</code>的共同超级角色。
                  </li>
               </ul>
               <p>在通用声明提升<a href="s2.3.2.e.html" title="§2.3.2.(e) Generic declared lifting" class="sect">§2.3.2的</a>情况下也会出现明确的绑定歧义<a href="s2.3.2.e.html" title="§2.3.2。（e）通用宣布解除" class="sect">。（e）</a>如果指定的角色<code>R</code>是未绑定的，并且存在两个独立的子角色<code>R1</code>和<code>R2</code> ，它们将playBy绑定引入同一个基类<code>BX</code> 。在这种情况下，没有标记潜在的歧义，因为角色<code>R1</code>和<code>R2</code>没有共享绑定超级角色。
                  				
               </p>
               <div class="note">
                  <h5>影响：</h5>处理<code>org.objectteams.需要导致明确歧义的代码<code>org.objectteams.LiftingFailedException</code> 。
                  				
               </div>
               <p>在明确约束的情况下，除了一些极端情况之外，提升确实会失败。如果提升已经在缓存中找到了适当的角色，或者如果模糊绑定角色的（间接）子角色在运行时对于基础对象的具体类型是明确的提升目标，则可能出现这种极端情况。另见<a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> 。
                  				
               </p>
               <h5 class="listing">示例代码（Definite Ambiguity）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  <b>public</b> <b>void</b> useSuperRole（SubBase <b>as</b> SuperRole r）{...} <span class="comment">// <span class="error">必须声明LiftingFailedException</span></span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth4" id="s2.3.4.c">
               <h4 class="subsect">（c） <span class="title">实际含糊不清</span><a class="img" href="s2.3.4.c.html" title="永久链接到（c）实际模糊性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在运行时，如果要提升基础的<em>动态类型</em> ，则可能发生<strong>实际模糊</strong> ，因此上述（b）的条件相应地保持。实际模糊性仅在编译器报告为潜在或明确歧义的情况下才有可能。
                  				
               </p>
               <div class="note">
                  <h5>影响：</h5>通过抛出<code>org.objectteams.在运行时报告实际的歧义<code>org.objectteams.LiftingFailedException</code> 。
                  				
               </div>
               <h5 class="listing">示例代码（实际歧义）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>import</b> org.objectteams。LiftingFailedException;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre><b>团队</b> <b>一级</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole <b>playingBy</b> SubBase {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  </pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>public</b> <b>void</b> useSuperRole（MyBase <b>as</b> SuperRole r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre>MyTeam mt = <b>new</b> MyTeam（）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>mt.useSuperRole（ <b>new</b> SubBase（））; <span class="comment">// <span class="error">将抛出LiftingFailedException</span></span></pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth4" id="s2.3.4.d">
               <h4 class="subsect">（d） <span class="title">不匹配的作用</span><a class="img" href="s2.3.4.d.html" title="永久链接到（d）不匹配的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在可能存在歧义的情况下，可能会发生另一个运行时错误：在缓存中找到角色时遇到<strong>不匹配的角色</strong> ，该角色不符合所需的类型。如果基础对象先前已被提升到与当前请求的类型不兼容的类型，则会发生这种情况。
                  				
               </p>
               <div class="note">
                  <h5>影响：</h5>这是通过抛出<code>org.objectteams.来报告的<code>org.objectteams.WrongRoleException</code> 。
                  				
               </div>
               <h5 class="listing">示例代码（不匹配的角色）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>import</b> org.objectteams。LiftingFailedException;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>					<b>团队</b> <b>一级</b> MyTeam {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <b>公共</b> <b>课</b> SuperRole <b>演奏了</b> MyBase {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleA <b>扩展了</b> SuperRole {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>  <b>公共</b> <b>类</b> SubRoleB <b>扩展了</b> SuperRole {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>  </pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>public</b> <b>void</b> useRoleA（MyBase <b>as</b> SubRoleA r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>  <b>public</b> <b>void</b> useRoleB（MyBase <b>as</b> SubRoleB r） <b>抛出</b> LiftingFailedException {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">10</td>
                        <td><pre><span class="comment">//加上这些电话：</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">11</td>
                        <td><pre>MyTeam mt = <b>new</b> MyTeam（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">12</td>
                        <td><pre>MyBase b = <b>new</b> MyBase（）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">13</td>
                        <td><pre>mt.useRoleA（b）中; <span class="comment">//为b创建一个SubRoleA</span></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">14</td>
                        <td><pre>mt.useRoleB（b）中; <span class="comment">// <span class="error">找到不兼容的SubRoleA</span></span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">15</td>
                        <td><pre>                <span class="comment">// <span class="error">到期望的类型SubRoleB。</span></span></pre></td>
                     </tr>
                  </table>
               </div>
               <p>从<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">§2.3.4。（a）</a>的第二项<a href="#s2.3.4.a" title="§2.3.4.(a) Potential ambiguity" class="sect">开始</a> ，对于绑定歧义，不同的角色层次结构是<a href="#s2.3.4.a" title="§2.3.4。（a）潜在的模糊性" class="sect">单独</a>分析的。对于此分析，只考虑那些绑定到基类的角色类（直接使用<code>playedBy</code>或从另一个角色类继承此关系）。即，两个没有共同超级角色的角色类永远不会导致任何歧义。
                  				
               </p>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s2.3.3.html" rel="prev">&lt;&lt;§2.3.3智能提升</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.3.5.html" rel="next">§2.3.5解除问题的后果&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a> &gt; <a class="nav" href="s2.3.html" rel="section">§2.3提升</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="2836.org_eclipse_ltk_ui_refactoring_statusContextViewers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>重构状态上下文查看器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">重构状态上下文查看器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.ui.refactoring.statusContextViewers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义能够向用户显示重构状态条目的上下文的特殊查看器。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.internal.ui.refactoring.AbstractDescriptor#matches(Object, String): -->默认变量是重构状态上下文。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“context”：输入<code>org.eclipse.ltk.core.refactoring.RefactoringStatusContext</code> ;由将在用户界面中显示的重构状态条目管理的上下文对象（与默认变量相同）</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.statusContextViewer">statusContextViewer</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符。</li>
<li><b>id</b> - 扩展实例的可选标识符。</li>
<li><b>name</b> - 扩展实例的可选名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.statusContextViewer">statusContextViewer</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST statusContextViewer</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 状态上下文查看器的唯一标识符。</li>
<li><b>class</b> - 提供实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面的示例为FileStatusContext对象提供了状态上下文查看器。

<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ltk.ui.refactoring.statusContextViewers”</span> <span class="code SchemaTag">&gt; &lt;statusContextViewer class =</span> <span class="code SchemaCstring">“org.eclipse.ltk.internal.ui.refactoring。FileStatusContextViewer“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.ltk.internal.ui.refactoring.fileStatusContextViewer“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.ltk.core.refactoring。FileStatusContext“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ statusContextViewer&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.ui.refactoring.IStatusContextViewer</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2331.ProgrammersGuide.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>经典Ecore / UML程序员指南</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="index.html" title="OCL Documentation"></link>
<link rel="prev" href="OCLInterpreterExample.html" title="OCL Interpreter Example"></link>
<link rel="next" href="EvaluatingConstraints.html" title="Evaluating Constraints and Queries"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">经典Ecore / UML程序员指南</h1>
<div class="chapter" title="经典Ecore / UML程序员指南">
<div class="titlepage">
<div>
<div>
<h2 class="title">
<a name="ProgrammersGuide"></a>经典Ecore / UML程序员指南</h2>
</div>
</div>
</div>
<div class="toc">
<dl>
<dt>
<span class="section"><a href="ProgrammersGuide.html#ParsingConstraints">解析约束和查询</a></span>
</dt>
<dt>
<span class="section"><a href="EvaluatingConstraints.html">评估约束和查询</a></span>
</dt>
<dt>
<span class="section"><a href="ParsingDocuments.html">解析OCL文档</a></span>
</dt>
<dt>
<span class="section"><a href="TargetMetamodels.html">OCL与元模型的关系</a></span>
</dt>
<dt>
<span class="section"><a href="ContentAssistSupport.html">内容辅助支持</a></span>
</dt>
<dt>
<span class="section"><a href="AbstractSyntax.html">OCL抽象语法模型</a></span>
</dt>
<dt>
<span class="section"><a href="CustomizingtheEnvironment.html">自定义环境</a></span>
</dt>
<dt>
<span class="section"><a href="Persistence.html">OCL持久性</a></span>
</dt>
<dt>
<span class="section"><a href="AdvancedMetamodelBindings.html">创建元模型绑定</a></span>
</dt>
<dt>
<span class="section"><a href="ImpactAnalyzer.html">使用Impact Analyzer逐步重新评估OCL表达式</a></span>
</dt>
<dt>
<span class="section"><a href="Delegates.html">代表</a></span>
</dt>
<dt>
<span class="section"><a href="Standalone.html">Ecore / UML独立配置</a></span>
</dt>
</dl>
</div>
<p>Ecore / UML程序员指南描述了可以从Java程序中使用Eclipse OCL的Ecore或UML绑定的方式。</p>
<p>自Eclipse OCL 1.0.0（Callisto）以来，Ecore绑定已经可用。UML绑定在1.1.0（Europa）中添加。两者都将在必要时保留。新的UML对齐的Pivot绑定的示例质量原型首先在3.1.0（Indigo）中提供。Pivot结合成为6.0.0（Mars）中的首选结合。Pivot绑定在单独的<a class="link" href="PivotProgrammersGuide.html" title="Unified或Pivot程序员指南">Pivot程序员指南中</a>描述。
		</p>
<p>OCL解析器/解释器为基于EMF的元模型和模型提供了<a class="ulink" href="http://www.omg.org/spec/OCL" target="_new">对象约束语言2.4</a>规范的实现。它提供OCL约束和查询解析和评估，基于模型的验证，并为文本编辑器中的内容辅助提供基础结构。
		</p>
<p>当前版本支持以下功能：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>分类器不变约束</p>
</li>
<li class="listitem">
<p>操作前提条件和后置条件约束和身体状况</p>
</li>
<li class="listitem">
<p>属性约束（初始值和派生）</p>
</li>
<li class="listitem">
<p>属性和操作定义（def：表达式）</p>
</li>
<li class="listitem">
<p>包上下文声明</p>
</li>
<li class="listitem">
<p>基本价值观和类型</p>
</li>
<li class="listitem">
<p>集合类型</p>
</li>
<li class="listitem">
<p>属性和关联的导航结束</p>
</li>
<li class="listitem">
<p>操作调用</p>
</li>
<li class="listitem">
<p>迭代表达式（所有标准迭代器）</p>
</li>
<li class="listitem">
<p>让表达</p>
</li>
<li class="listitem">
<p>如果表达</p>
</li>
<li class="listitem">
<p>元组</p>
</li>
<li class="listitem">
<p>消息表达式，包括未指定的值</p>
</li>
<li class="listitem">
<p>OCL预定义的操作：allInstances（），oclIsKindOf（），oclIsTypeOf（），oclAsType（），oclIsNew（）</p>
</li>
<li class="listitem">
<p>非法名称的转义语法：类型，操作，属性等与OCL保留字对应的名称可以使用前导下划线（'_'）以标准方式转义。此外，包含空格或制表符的名称可以通过用双引号括起来进行转义（'“';这是非标准的）。例如， <code class="code">self.ownedRule-&gt;forAll(c : Constraint | c._context = self)</code>
				
</p>
</li>
</ul>
</div>
<p>解析器支持上述结构进行解析和评估，但oclIsNew（）操作和消息表达式除外。Ecore和UML模型都支持以上所有功能。UML默认支持以下内容（解析和评估）：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>不可导航关联的导航结束（包括该关联拥有的那些）</p>
</li>
<li class="listitem">
<p>合格的协会结束导航</p>
</li>
<li class="listitem">
<p>导航到关联类，包括源限定符</p>
</li>
<li class="listitem">
<p>OCL预定义的操作：oclIsInState（）</p>
</li>
</ul>
</div>
<p>除OCL规范外，还提供以下功能：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>字符串大小写转换操作：toUpper（），toLower（）</p>
</li>
<li class="listitem">
<p>支持比较（&lt;，&lt;=等）和排序符合类型的任何java <code class="code">Comparable</code></p>
</li>
<li class="listitem">
<p>关联的传递闭包：closure（expr：OCLExpression）迭代器</p>
</li>
<li class="listitem">
<p>使用<code class="code">Property.oppositeRoleName</code>注释在前向引用上使用源<code class="code">http://schema.omg.org/spec/MOF/2.0/emof.xml</code>导出Ecore模型中指定的引用的“隐藏”对立，生成<code class="code">OppositePropertyCallExp</code>表达式</p>
</li>
</ul>
</div>
<p>OCL实现在插件中定义，以便在Eclipse中进行部署，但与EMF的情况一样，它也可以单独使用。插件因此被分区：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl</code> ：核心解析，评估和内容辅助服务。OCL抽象语法模型和环境API的定义。这些API是通用的，独立于任何特定的元模型（尽管使用Ecore / EMF作为元元模型）。
				</p>
</li>
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl.ecore</code> ：Ecore元模型环境的实现，将通用环境和AST API绑定到Ecore语言。为使用OCL约束和针对Ecore模型的查询提供支持。
				</p>
</li>
<li class="listitem">
<p>
					
<code class="code">org.eclipse.ocl.uml</code> ：UML元模型环境的实现，将通用环境和AST API绑定到UML语言。为使用针对UML模型的OCL提供支持。
				</p>
</li>
</ul>
</div>
<p>请参阅<a class="link" href="OCLInterpreterTutorial.html" title="使用经典OCL">OCL口译员教程</a>以查看代码示例。
		</p>
<div class="section" title="解析约束和查询">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="ParsingConstraints"></a>解析约束和查询</h2>
</div>
</div>
</div>
<p>OCL解析器提供了两个用于解析约束和查询表达式的API。<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html" target="_new"><code class="code">OCLHelper</code></a>接口主要用于解析嵌入在模型中的约束和查询表达式，例如Ecore或UML模型。<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html" target="_new"><code class="code">OCL</code></a>类充当解析API的主要入口点，但也实现了对<a class="link" href="ParsingDocuments.html" title="解析OCL文档">OCL文档</a>的解析，例如从文本文件中解析。在这两种情况下， <code class="code">Environment</code>概念都至关重要。
			</p>
<div class="section" title="OCL环境">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLEnvironment"></a> OCL环境</h3>
</div>
</div>
</div>
<p>下图显示了<code class="code">Environment</code> API的核心，OCL解析器的客户端与之交互：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-environment.png"></div>
<p>
				
</p>
<p><a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html" target="_new"><code class="code">OCL</code></a>类是泛型类型;它的类型参数表示OCL在OMG规范的UML / MOF系列中使用的元模型的各种元类。例如， <code class="code">&lt;C&gt;</code>表示分类器概念， <code class="code">&lt;O&gt;</code>操作概念等。有关映射的详细信息，请参阅<a class="link" href="TargetMetamodels.html" title="OCL Relationship to Metamodels">OCL支持</a>的<a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">元模型</a>的讨论。在整个OCL API中始终使用相同类型的参数名称来表示相同的元类。
				</p>
<p><code class="code">OCL</code>类定义自治OCL解析和评估环境的实例。它具有由<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/EnvironmentFactory.html" target="_new"><code class="code">EnvironmentFactory</code></a>实现为特定的基于EMF的元模型创建的单个根<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Environment.html" target="_new"><code class="code">Environment</code></a> 。从概念上讲，OCL环境包括要与所有约束以及为了制定约束而定义的附加操作和属性（通过OCL）一起约束的模型。
				</p>
<p>
					
<code class="code">Environment</code>的巢。通常根环境具有在模型中没有相关性的元素，或者其可对应于一些<code class="code">Package</code>中提供默认名称空间（称为包上下文）。或者，它可以包含一个或多个定义包命名空间的嵌套环境。包上下文包含一个或多个分类器上下文，而这些上下文又可以包含操作和/或属性上下文。虽然包上下文的目的主要是帮助查找命名模型元素，但分类器，操作和属性上下文具有更深层的含义。
				</p>
<p>分类器上下文定义OCL约束和查询中的<code class="code">self</code>变量的类型。就其本身而言，它是上下文分类器的不变约束的上下文。另外，作为操作和属性约束的父上下文，它指示应用操作或属性约束的上下文的分类器;这可能是定义这些特征的分类器，或者它可以从一些更通用的分类器继承它们。
				</p>
<p><code class="code">Environment</code>可以包含OCL表达式可以引用的命名<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/expressions/Variable.html" target="_new"><code class="code">Variable</code></a> 。其中最常见的是<code class="code">self</code> 。其他包括在操作上下文的情况下由操作（及其<code class="code">result</code> ）定义的参数。OCL API甚至允许客户端在代码中添加变量来定义“全局”名称。
				</p>
</div>
<div class="section" title="创建OCL环境">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CreatinganOCLEnvironment"></a>创建OCL环境</h3>
</div>
</div>
</div>
<p><code class="code">OCL</code>类上的静态工厂方法用于创建实例。在加载该模型时（通常在编辑器中的某些<code class="code">ResourceSet</code>中）重复使用相同的OCL实例来对模型上的约束和查询进行所有解析和评估是一种很好的做法。使用Ecore <a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">元模型</a>的共享环境工厂，我们可以创建一个适合在任何Ecore模型上解析OCL约束并在模型实例上评估它们的OCL环境：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-creating.png"></div>
<p>

					
<a class="ulink" href="../references/5110-creating.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p><code class="code">OCL</code>泛型类型签名中的几个类型参数主要在OCL API中很有用。我们把它们留在这里作为通配符。
				</p>
</div>
<div class="section" title="OCL助手">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLHelper"></a> OCL助手</h3>
</div>
</div>
</div>
<p>在OCL实例中，我们可以创建一个辅助对象，用于解析约束和其他操作/属性定义。此<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html" target="_new"><code class="code">OCLHelper</code></a>存储OCL模板元类的所有实例（例如<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/types/CollectionType.html" target="_new"><code class="code">CollectionType(T)</code></a>和<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/types/TupleType.html" target="_new"><code class="code">TupleType</code></a>以及在创建它的<code class="code">OCL</code>的根环境中的其他操作/属性定义。这可确保所有这些构造都可用于后续解析。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-oclhelper.png"></div>
<p> 
				
</p>
<p><code class="code">OCLHelper</code>主要用于解析模型中嵌入的约束和查询表达式，为此提供以下API：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">createQuery()</code> ：解析查询表达式</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createConstraint()</code> ：解析给定<code class="code">ConstraintKind</code>
						
</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createInvariant()</code> ：不变约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createPrecondition()</code> ：前置条件约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createPostcondition()</code> ：后置条件约束的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createBodyCondition()</code> ：方便身体状况</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createInitialValueExpression()</code> ：属性初始值的便利</p>
</li>
<li class="listitem">
<p>
							
<code class="code">createDerivedValueExpression()</code> ：属性派生值的便利</p>
</li>
<li class="listitem">
<p>
							
<code class="code">defineOperation()</code> ：其他操作定义的便利性</p>
</li>
<li class="listitem">
<p>
							
<code class="code">defineAttribute()</code> ：其他属性定义的便利性</p>
</li>
</ul>
</div>
<p>不同类型的约束需要不同的上下文环境。<code class="code">setContext()</code> ， <code class="code">setOperationContext()</code>和<code class="code">setAttributeContext()</code>方法<code class="code">Environment@s in the host @OCL</code>实例的根环境中创建适当的嵌套<code class="code">Environment@s in the host @OCL</code> 。
				</p>
<p>解析查询表达式的结果是<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/expressions/OCLExpression.html" target="_new"><code class="code">OCLExpression</code></a> ，它是<a class="link" href="AbstractSyntax.html" title="OCL抽象语法模型">抽象语法模型的</a>一个实例。解析约束的结果是由<code class="code">OCL</code>的<a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">目标元模型</a>定义的<code class="code">Constraint</code>元类的实例。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-context.png"></div>
<p>

					
<a class="ulink" href="../references/5110-context.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
<p>Ecore没有定义<code class="code">Constraint</code>元类，因此Ecore的OCL <a class="link" href="TargetMetamodels.html" title="OCL与元模型的关系">绑定</a>提供了一个。
				</p>
</div>
<div class="section" title="操作和属性上下文">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OperationandAttributeContexts"></a>操作和属性上下文</h3>
</div>
</div>
</div>
<p>在对操作或属性的约束的情况下，上下文由两个元素组成：约束操作/属性和要应用约束的上下文中的分类器。这解释了分类器定义对继承特征的约束的可能性。作为示例，请考虑Ecore元模型中的<code class="code">EModelElement::getEAnnotation(EString)</code>操作和<code class="code">EReference::eReferenceType</code>属性。这些可以限制如下：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5110-define.png"></div>
<p>

					
<a class="ulink" href="../references/5110-define.txt" target="_new">[剪切和粘贴文本]</a>
				
</p>
</div>
</div>
</div>
</body>
</html><html id="0090.ds-HowToSpecifyWhatDataToRetrieveDataFromCassandraDataSource.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>如何指定从Cassandra数据源检索哪些数据</title>
    <link rel="StyleSheet" href="css/connecting.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="con-HowToSpecifyConnectionInformationForCassandraDataSource.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="con-HowToSpecifyConnectionInformationForExcelDataSource.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h4 class="N_hth_HowToHelp"><a name="363873">如何指定从Cassandra数据源检索哪些数据</a></h4>
      <p class="b_Body"><a name="345452">在此过程中，在CQL查询中使用以下open子句：</a></p>
      <div class="cf_CodeFirst"><a name="345453">importPackage（Packages.java.util）;</a></div>
      <div class="co_Code"><a name="345454">importPackage（Packages.me.prettyprint.cassandra.serializers）;</a></div>
      <div class="co_Code"><a name="345455">importPackage（Packages.me.prettyprint.cassandra.service）;</a></div>
      <div class="co_Code"><a name="345456">importPackage（Packages.me.prettyprint.hector.api）;</a></div>
      <div class="co_Code"><a name="345457">importPackage（Packages.me.prettyprint.hector.api.beans）;</a></div>
      <div class="co_Code"><a name="345458">importPackage（Packages.me.prettyprint.hector.api.factory）;</a></div>
      <div class="co_Code"><a name="345459">importPackage（Packages.me.prettyprint.hector.api.query）;</a></div>
      <div class="co_Code"><a name="345460">importPackage（Packages.me.prettyprint.cassandra.model）;</a></div>
      <div class="co_Code"><a name="345461">var cluster = HFactory.getOrCreateCluster（“Test Cluster”，new CassandraHostConfigurator（“192.168.218.246:9160”））;</a></div>
      <div class="co_Code"><a name="345462">var keyspace = HFactory.createKeyspace（“users”，cluster）;</a></div>
      <div class="co_Code"><a name="345463">var cqlQuery = new CqlQuery（keyspace，StringSerializer.get（），StringSerializer.get（），StringSerializer.get（））;</a></div>
      <div class="co_Code"><a name="345464">cqlQuery.setQuery（“select * from User”）;</a></div>
      <div class="co_Code"><a name="345465">var resultCQL = cqlQuery.execute（）;</a></div>
      <div class="co_Code"><a name="345466">rowsIterator = resultCQL.get（）。iterator（）;</a></div>
      <p class="b_Body"><a name="345467">还使用以下fetch子句：</a></p>
      <div class="cf_CodeFirst"><a name="345468">if（rowsIterator.hasNext（））{</a></div>
      <div class="co_Code"><a name="345469">var myrow = rowsIterator.next（）;</a></div>
      <div class="co_Code"><a name="345470">var cols = myrow.getColumnSlice（）。getColumns（）;</a></div>
      <div class="co_Code"><a name="345471">for（ii = 0; ii &lt;cols.size（）; ii ++）{</a></div>
      <div class="co_Code"><a name="345472">row [cols.get（ii）.getName（）] = cols.get（ii）.getValue（）;</a></div>
      <div class="co_Code"><a name="345473">}</a></div>
      <div class="co_Code"><a name="345474">返回true;</a></div>
      <div class="co_Code"><a name="345475">}其他{</a></div>
      <div class="co_Code"><a name="345476">返回false;</a></div>
      <div class="co_Code"><a name="345477">}</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345483">在数据资源管理器中，右键单击“数据集”，然后选择“新建数据集”。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345485">在“新数据集”中，指定以下信息：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345487">在“数据源选择”中，选择要使用的Cassandra数据源。数据集类型显示HQL选择查询。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345489">在“数据集名称”中，键入数据集的名称。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345490">选择下一步。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345491">在“输出”列中，选择“添加”并添加必要的输出列以从数据源检索。对于每个输出列，您可以在New Script Data Set Column上指定以下值，</a> <a href="#345507" title="如何指定从Cassandra数据源检索哪些数据">如图2-2</a> 所示</a> ：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345495">名称</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345496">类型</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345497">别号</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345498">分析类型</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345499">显示名称</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345500">显示名称密钥</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="345501">完成指定数据集列属性后，选择“确定”。</a></div>
      <p class="i2_Image2"><a name="345505"><img class="Default" src="images/Cass-NewScriptDSCol.png" alt="图2-2添加输出列" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图2-2</b> <a name="345507">添加输出列</a></div>
      <div class="N_i_Indent1"><a name="345509">指定的输出列显示在“新数据集”中，</a> <a href="#345518" title="如何指定从Cassandra数据源检索哪些数据">如图2-3</a> <a name="345509">所示</a> 。在此示例中，输出列是first，last和age。</div>
      <p class="i2_Image2"><a name="345516"><img class="Default" src="images/Cass-OutputCols.png" alt="图2-3指定要检索的输出列" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图2-3</b> <a name="345518">指定要检索的输出列</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345520">选择完成。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345521">在Script中，从下拉菜单中选择一种类型的子句，并指定必要的CQL子句。例如：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345522">在Script中，选择open，并指定一个类似于下面的CQL子句，</a> <a href="#345545" title="如何指定从Cassandra数据源检索哪些数据">如图2-4</a> <a name="345522">所示</a> ：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="345526">importPackage（Packages.java.util）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345527">importPackage（Packages.me.prettyprint.cassandra.serializers）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345528">importPackage（Packages.me.prettyprint.cassandra.service）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345529">importPackage（Packages.me.prettyprint.hector.api）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345530">importPackage（Packages.me.prettyprint.hector.api.beans）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345531">importPackage（Packages.me.prettyprint.hector.api.factory）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345532">importPackage（Packages.me.prettyprint.hector.api.query）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345533">importPackage（Packages.me.prettyprint.cassandra.model）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345534">var cluster = HFactory.getOrCreateCluster（“Test Cluster”，new CassandraHostConfigurator（“192.168.218.246:9160”））;</a></div>
      <div class="coi2_CodeIndent2"><a name="345535">var keyspace = HFactory.createKeyspace（“users”，cluster）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345536">var cqlQuery = new CqlQuery（keyspace，StringSerializer.get（），StringSerializer.get（），StringSerializer.get（））;</a></div>
      <div class="coi2_CodeIndent2"><a name="345537">cqlQuery.setQuery（“select * from User”）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345538">var resultCQL = cqlQuery.execute（）;</a></div>
      <div class="coi2_CodeIndent2"><a name="345539">rowsIterator = resultCQL.get（）。iterator（）;</a></div>
      <p class="i3_Image3"><a name="345543"><img class="Default" src="images/Cass-Open.png" alt="图2-4指定open子句" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图2-4</b> <a name="345545">指定open子句</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345547">在Script中，选择fetch，并指定一个类似于下面的CQL子句，</a> <a href="#345566" title="如何指定从Cassandra数据源检索哪些数据">如图2-5</a> <a name="345547">所示</a> ：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="345551">if（rowsIterator.hasNext（））{</a></div>
      <div class="coi_CodeIndent"><a name="345552">var myrow = rowsIterator.next（）;</a></div>
      <div class="coi_CodeIndent"><a name="345553">var cols = myrow.getColumnSlice（）。getColumns（）;</a></div>
      <div class="coi_CodeIndent"><a name="345554">for（ii = 0; ii &lt;cols.size（）; ii ++）{</a></div>
      <div class="coi_CodeIndent"><a name="345555">row [cols.get（ii）.getName（）] = cols.get（ii）.getValue（）;</a></div>
      <div class="coi_CodeIndent"><a name="345556">}</a></div>
      <div class="coi2_CodeIndent2"><a name="345557">返回true;</a></div>
      <div class="coi2_CodeIndent2"><a name="345558">}其他{</a></div>
      <div class="coi2_CodeIndent2"><a name="345559">返回false;</a></div>
      <div class="coi2_CodeIndent2"><a name="345560">}</a></div>
      <p class="i3_Image3"><a name="345564"><img class="Default" src="images/Cass-Fetch.png" alt="图2-5指定fetch子句" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图2-5</b> <a name="345566">指定fetch子句</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="345569">选择“预览结果”以查看数据集返回的数据行。</a></div>
            </td>
          </tr>
        </table>
      </div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="2956.feature_manifest.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2012. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>

   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<link rel="STYLESHEET" href="../../book.css" type="text/css" charset="ISO-8859-1"></link>
   <title>特征清单</title>
</head>
<body dir="ltr">

<h1>Eclipse平台功能清单</h1>
<p><i>版本4.2  - 最后修订于2012年5月</i></p>

<p>功能清单格式由以下dtd定义：</p>
<p><tt>&lt;？xml encoding =“ISO-8859-1”？&gt;</tt></p>
<p><tt>&lt;！ELEMENT功能（安装处理程序？|描述？|版权？|执照？|网址是什么？|包括* |要求？|插件* |数据*）&gt;</tt>
<br><tt>&lt;！ATTLIST功能</tt>
<br><tt>id CDATA #REQUIRED</tt>
<br><tt>版本CDATA #REQUIRED</tt>
<br><tt>标签CDATA #IMPLIED</tt>
<br><tt>provider-name CDATA #IMPLIED</tt>
<br><tt>os CDATA #IMPLIED</tt>
<br><tt>arch CDATA #IMPLIED</tt>
<br><tt>是CDATA #IMPLIED</tt>
<br><tt>nl CDATA #IMPLIED</tt>
<br><tt>插件CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！元素描述（#PCDATA）&gt;</tt>
<br><tt>&lt;！ATTLIST描述</tt>
<br><tt>url CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT版权所有（#PCDATA）&gt;</tt>
<br><tt>&lt;！ATTLIST版权所有</tt>
<br><tt>url CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT许可证（#PCDATA）&gt;</tt>
<br><tt>&lt;！ATTLIST许可证</tt>
<br><tt>url CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT网址（更新？，发现*）&gt;</tt></p>
<p><tt>&lt;！ELEMENT更新EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST更新</tt>
<br><tt>url CDATA #REQUIRED</tt>
<br><tt>标签CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT发现EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST发现<br></tt>
<br><tt>url CDATA #REQUIRED</tt>
<br><tt>标签CDATA #IMPLIED</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT包括EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST包括</tt>
<br><tt>id CDATA #REQUIRED</tt>
<br><tt>版本CDATA #REQUIRED<br>名称CDATA #IMPLIED<br>可选（true | false）“false”</tt>
<br><tt>os CDATA #IMPLIED</tt>
<br><tt>arch CDATA #IMPLIED</tt>
<br><tt>是CDATA #IMPLIED</tt>
<br><tt>nl CDATA #IMPLIED</tt> <tt><br>&gt;</tt></p>
<p><tt>&lt;！ELEMENT需要（import +）&gt;</tt></p>
<p><tt>&lt;！ELEMENT导入EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST导入</tt>
<br><tt>插件CDATA #IMPLIED<br>功能CDATA #IMPLIED</tt>
<br><tt>版本CDATA #IMPLIED</tt>
<br><tt>匹配（完美|等效|兼容| greaterOrEqual）“兼容”<br>patch（true | false）“false”</tt>
<br><tt>&gt;</tt></p>
<p><tt>&lt;！ELEMENT插件EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST插件</tt>
<br><tt>id CDATA #REQUIRED</tt>
<br><tt>版本CDATA #REQUIRED</tt>
<br><tt>fragment（true | false）“false”</tt>
<br><tt>os CDATA #IMPLIED</tt>
<br><tt>arch CDATA #IMPLIED</tt>
<br><tt>是CDATA #IMPLIED</tt>
<br><tt>nl CDATA #IMPLIED</tt>
<br><tt>下载大小CDATA #IMPLIED</tt>
<br><tt>install-size CDATA #IMPLIED</tt>
<br><tt>unpack（true | false）“true”</tt>
<br><tt>&gt;</tt></p>
<p>元素和属性定义如下：</p>
<ul>

<li>&lt;feature&gt;  - 定义功能<ul>
<li>id  - 必需的要素标识符（例如com.xyz.myfeature）</li>
<li>版本 - 所需的组件版本（例如1.0.3）</li>
<li>label  - 可选的可显示标签（名称）。打算翻译。</li>
<li>provider-name  - 标识提供此组件的组织的可选显示标签。打算翻译。</li>
<li>os  - 可选的操作系统规范。由Eclipse定义的以逗号分隔的操作系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此功能应仅安装在其中一个指定的OS系统上。如果未指定此属性，则可以在所有系统上安装该功能（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>arch  - 可选的机器架构规范。由Eclipse定义的以逗号分隔的体系结构指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此功能应仅安装在其中一个指定的系统上。如果未指定此属性，则可以在所有系统上安装该功能（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>ws  - 可选的窗口系统规范。由Eclipse定义的以逗号分隔的窗口系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此功能应仅安装在指定的WS之一上。如果未指定此属性，则可以在所有系统上安装该功能（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>nl  - 可选的区域设置规范。由Java定义的以逗号分隔的区域设计指示符列表。表示此功能只应安装在使用兼容语言环境运行的系统上（使用Java语言环境匹配规则）。如果未指定此属性，则可以在所有系统上安装该功能（与语言无关的实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>plugin  - 可选标识符，表示功能中列出的插件的id，用于携带功能的品牌信息（主要功能时的图像，翻译，启动画面等）。如果未指定，则假设归因插件具有与该功能相同的ID。</li>
</ul>
</li>

<li>&lt;description&gt;  - 简短的组件描述为简单文本。打算翻译。
<ul>
<li>url  - 完整描述为HTML的可选URL。 URL可以指定为相对的绝对值。如果是相对的，则假定它与特征档案相关（并打包）。请注意，对于NL处理，URL值应该分开，以允许为每种国家语言指定备用URL。</li>
</ul>
</li>

<li>&lt;copyright&gt;  - 将版权作为简单文本。打算翻译。
<ul>
<li>url  - 完整描述为HTML的可选URL。 URL可以指定为相对的绝对值。如果是相对的，则假定它与特征档案相关（并打包）。请注意，对于NL处理，URL值应该分开，以允许为每种国家语言指定备用URL。</li>
</ul>
</li>

<li>&lt;license&gt;  - 将“点击”许可证作为简单文本。打算翻译。它在下载/安装过程中以[Accept] [Reject]操作显示在标准对话框中。请注意，必须为将使用Eclipse更新管理器选择进行安装或更新的任何功能指定单击许可证。使用嵌套功能时，只有嵌套父级（即选择安装或更新的功能）必须定义了点击许可文本。即使指定了可选的<i>url</i>属性，也需要许可证文本。
<ul>
<li>url  - 完整描述为HTML的可选URL。 URL可以指定为相对的绝对值。如果是相对的，则假定它与特征档案相关（并打包）。请注意，对于NL处理，URL值应该分开，以允许为每种国家语言指定备用URL。请注意，此URL的“内容” <b>不是</b>安装处理期间作为点击许可证呈现的内容。点击许可证是<i>&lt;license&gt;</i>元素的实际值（例如， <tt>&lt;license&gt;点击文本&lt;/ license&gt;</tt> ）</li>
</ul>
</li>

<li>&lt;url&gt;  - 指定站点的可选URL包含功能更新或新功能<ul>
<li>&lt;update&gt;  - 要转到此功能的更新的URL<ul>
<li>url  - 实际网址</li>
<li>label  - 引用站点的可显示标签（名称）</li>
</ul>
</li>
<li>&lt;discovery&gt;  - 转到新功能的网址。通常，提供商可以使用此元素来引用其自己的站点或提供补充功能的合作伙伴的站点。Eclipse仅将此元素用作将新站点URL分发给客户端的方法。
<ul>
<li>url  - 实际网址</li>
<li>label  - 引用站点的可显示标签（名称）</li>
</ul>
</li>
</ul>
</li>

<li>&lt;includes&gt;  - 对被视为此功能一部分的嵌套功能的可选引用。嵌套功能必须与此功能位于同一更新站点上<ul>
<li>id  - 必需的嵌套功能标识符。如果该功能是补丁（请参阅下面的&lt;requires&gt;部分），则必须是另一个补丁的ID。</li>
<li>version  - 必需的嵌套功能版本</li>
<li>可选 - 当此属性为“true”时，可以将要素包含为可选项。允许用户不安装可选功能，如果已安装则禁用它们，并在以后安装。丢失的可选功能不会被视为错误。</li>
<li>name  - 如果缺少可选功能，Eclipse无法正确呈现其名称。此属性可用作“占位符”，以允许Eclipse在未安装时呈现可选功能的名称。</li>
<li>os  - 可选的操作系统规范。由Eclipse定义的以逗号分隔的操作系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此条目只应安装在其中一个指定的OS系统上。如果未指定此属性，则可以在所有系统上安装该条目（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
<li>arch  - 可选的机器架构规范。由Eclipse定义的以逗号分隔的体系结构指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此功能应仅安装在其中一个指定的系统上。如果未指定此属性，则可以在所有系统上安装该功能（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>ws  - 可选的窗口系统规范。由Eclipse定义的以逗号分隔的窗口系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此条目只应安装在指定的WS之一上。如果未指定此属性，则可以在所有系统上安装该条目（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
<li>nl  - 可选的区域设置规范。由Java定义的以逗号分隔的区域设计指示符列表。表示此条目只应安装在使用兼容语言环境运行的系统上（使用Java语言环境匹配规则）。如果未指定此属性，则可以在所有系统上安装该条目（与语言无关的实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
</ul>
</li>

<li>&lt;requires&gt;  - 可选功能依赖性信息。以插件依赖关系表示。如果已指定，则在安装时由安装和更新支持强制执行<ul>
<li>&lt;import&gt;  - 依赖项输入。规范和处理是plugin.xml中&lt;import&gt;规范的一个子集<ul>
<li>plugin  - 依赖插件的标识符，如果插件用于表示依赖性</li>
<li>feature  - 依赖特性的标识符，如果使用特征来表示依赖性。<b>必须设置插件或功能属性，但不能同时设置。</b>如果“patch”为“true”，则必须使用feature属性。</li>
<li>version  - 可选的插件版本规范。如果“patch”为“true”，则必须设置版本。</li>
<li>匹配 - 可选匹配规则。有效值和处理如下：<ul>
<li>如果未指定version属性，则忽略match属性（如果指定）。</li>
<li><b><i>完美</i></b>依赖的插件版本必须与指定的版本完全匹配。如果“patch”为“true”，则假定为“perfect”，并且不能设置其他值。</li>
<li><b><i>等效</i></b>依赖的插件版本必须至少在指定的版本或更高的服务级别（主要和次要版本级别必须等于指定的版本）。</li>
<li><b><i>兼容</i></b> - 依赖的插件版本必须至少在指定的版本，或更高的服务级别或次要级别（主要版本级别必须等于指定的版本）。</li>
<li><b><i>greaterOrEqual</i></b>依赖的插件版本必须至少在指定的版本，或更高的服务，次要或主要级别。</li>
</ul>
</li>
<li>patch  - 如果为“true”，则此约束将封闭特征声明为引用特征的修补程序。设置此属性时必须遵循某些规则：<ul>
  <li>要素属性必须用于要修补的要素的标识符</li>
  <li>必须设置版本属性</li>
  <li>不应设置match属性，并假设“完美”值。</li>
  <li>如果其他功能是&lt;include&gt;'ed，它们也必须是补丁。</li>
</ul>补丁是一项特殊功能，可以为其正在修补的功能提供更新版本的插件。它不会取代该功能。补丁也可以通过包含来携带其他补丁。</li>
</ul>
</li>
</ul>
</li>

<li>&lt;plugin&gt;  - 标识引用的插件<ul>
<li>id  - 必需的插件标识符（来自plugin.xml）</li>
<li>version  - 必需的插件版本（来自plugin.xml）</li>
<li>fragment  - 指示此条目是否为插件片段的可选规范。默认为“false”</li>
<li>os  - 可选的操作系统规范。由Eclipse定义的以逗号分隔的操作系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此条目只应安装在其中一个指定的操作系统上。如果未指定此属性，则可以在所有系统上安装该条目（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
<li>arch  - 可选的机器架构规范。由Eclipse定义的以逗号分隔的体系结构指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此功能应仅安装在其中一个指定的系统上。如果未指定此属性，则可以在所有系统上安装该功能（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装功能）。</li>
<li>ws  - 可选的窗口系统规范。由Eclipse定义的以逗号分隔的窗口系统指示符列表（请参阅<tt>org.eclipse.core.runtime的 Javadoc <tt>。平台）</tt> 。表示此条目只应安装在指定的WS之一上。如果未指定此属性，则可以在所有系统上安装该条目（可移植实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
<li>nl  - 可选的区域设置规范。由Java定义的以逗号分隔的区域设计指示符列表。表示此条目只应安装在使用兼容语言环境运行的系统上（使用Java语言环境匹配规则）。如果未指定此属性，则可以在所有系统上安装该条目（与语言无关的实现）。此信息用作安装和更新支持的提示（无论此设置如何，用户都可以强制安装条目）。</li>
<li>download-size  - 功能包装程序提供的可选提示，指示引用的插件存档的下载大小（以KB为单位）。如果未指定，则下载大小未知（ <b>实现注意：</b>实现需要区分“未知”和0大小）</li>
<li>install-size  - 功能包装程序提供的可选提示，指示引用的插件存档的安装大小（以KB为单位）。如果未指定，则安装大小未知（ <b>实现注意：</b>实现需要区分“未知”和0大小）</li>
<li>unpack  - 功能包装程序提供的可选规范，表示插件能够从jar运行，并且不应将插件jar的内容解压缩到目录中。默认为“true”。
</li>
</ul>
</li>
</ul>
<p>请注意，通常，feature.xml清单文档应指定UTF-8编码。例如：</p>
<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</pre>
<p>可以使用Java属性包约定将feature.xml中包含的可翻译文本分隔为feature &lt;_locale&gt; .properties文件。请注意，翻译的字符串在安装时使用（即不使用插件片段运行时机制）。
</p>
</body>
</html><html id="0004.index.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content=""></meta>
    <meta name="author" content="Stéphane Bégaudeau"></meta>    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet"></link>
    <link href="../../assets/css/docs.css" rel="stylesheet"></link>
    
    <title>Acceleo</title>
  </head>
  <body dir="ltr">
    <div class="container">
      <section id="domainfree">
        <div class="page-header">
          <h1>Domain Free <small>可以从任何EMF模型生成任何内容</small></h1>
        </div>
        <h2>任何一种EMF模型......</h2>
        <p>大多数代码生成器要么生成一种技术（例如Java），要么仅使用一种模型（例如UML）。Acceleo不会将您限制在特定域，您希望从以下位置生成代码：</p>
        <ul>
          <li>UML模型？支持的！</li>
          <li>Ecore模特？支持的！</li>
          <li>工作区中的元模型是否包含动态实例（“。xmi”）？支持的！</li>
          <li>定制的元模型？支持的！</li>
          <li>一个定制的元模型，依赖于UML？支持的！</li>
          <li>带配置文件的UML模型？支持的！</li>
          <li>几个定制的元模型从一个到另一个具有依赖性？支持的！</li>
        </ul>
        
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>将鼠标光标悬停在图片上以查看图例。
        </div>
        
        <ul class="thumbnails">
          <li class="span8">
            <a href="../../assets/img/features/domain-free-uml-gen.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-uml-gen_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-uml-gen_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-uml-gen_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-scalamodel-gen.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-scalamodel-gen_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-scalamodel-gen_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-scalamodel-gen_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-ecore-gen.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-ecore-gen_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-ecore-gen_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-ecore-gen_th.png&#39;">
            </a>
          </li>
        </ul>
        
        <h2>使用您选择的工具构建......</h2>
        <p>由于Acceleo基于流行的框架EMF，您可以使用任何类型的基于EMF的工具创建模型，并将其用作您的一代的输入。您想要使用以下创建的模型生成代码：</p>
        <ul>
          <li>好的'基于EMF树的编辑器？支持的！</li>
          <li>图形建模师？支持的！</li>
          <li>使用Xtext实现基于文本的编辑器？支持的！</li>
          <li>基于CDO的应用程序用于创建远程模型？支持的！</li>
        </ul>
        <ul class="thumbnails">
          <li class="span6">
            <a href="../../assets/img/features/domain-free-graphical-model.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-graphical-model_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-graphical-model_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-graphical-model_th.png&#39;">
            </a>
          </li>
          <li class="span6">
            <a href="../../assets/img/features/domain-free-treebased-model.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-treebased-model_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-treebased-model_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-treebased-model_th.png&#39;">
            </a>
          </li>
        </ul>
        <ul class="thumbnails">
          <li class="span4">
            <a href="../../assets/img/features/domain-free-textbased-model.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-textbased-model_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-textbased-model_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-textbased-model_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-graphical-model-2.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-graphical-model-2_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-graphical-model-2_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-graphical-model-2_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-cdo-model.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-cdo-model_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-cdo-model_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-cdo-model_th.png&#39;">
            </a>
          </li>
        </ul>
        
        <h2>生成你想要的任何东西......</h2>
        <p>既然您有输入模型，那么您想要生成哪种技术？使用基于模板的方法，您可以定义生成的代码类型，并且可以自定义它以尊重您自己的编码风格。你想生成：</p>
        <ul>
          <li>Java的？支持的！
          </li><li>Scala呢？支持的！</li>
          <li>JavaScript的？支持的！</li>
          <li>HTML？支持的！</li>
          <li>蟒蛇？支持的！</li>
        </ul>
        <p>Acceleo不限制生成的代码类型，只有一条规则：</p>
        <div class="well"><h2><b>如果你可以写它，Acceleo可以生成它！</b></h2></div>
        <ul class="thumbnails">
          <li class="span8">
            <a href="../../assets/img/features/domain-free-scala-code.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-scala-code_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-scala-code_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-scala-code_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-python-code.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-python-code_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-python-code_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-python-code_th.png&#39;">
            </a>
          </li>
          <li class="span4">
            <a href="../../assets/img/features/domain-free-javascript-code.png" class="thumbnail">
              <img src="../../assets/img/features/domain-free-javascript-code_th.png" alt="" onmouseover="this.src=&#39;../../assets/img/features/domain-free-javascript-code_th-hover.png&#39;" onmouseout="this.src=&#39;../../assets/img/features/domain-free-javascript-code_th.png&#39;">
            </a>
          </li>
        </ul>
      </section>
      
      <section id="standalone">
        <div class="page-header">
          <h1>独自站立<small>免于Eclipse</small></h1>
        </div>
        <h2><b>从任何基于Java的应用程序启动Acceleo生成器！</b></h2>
        <ul class="thumbnails">
          <li class="span5">一开始，您需要快速编写一个高效的生成器，但是一旦完成，您将需要将它交付给您的客户，为此您必须构建它并将其嵌入到应用程序中。如果您的目标是在Eclipse中使用您的生成器，那么Acceleo可以创建一个基于Eclipse的UI来将您的生成器集成到Eclipse实例中，它还可以让您轻松构建生成器以将其用作Eclipse插件，但是您的一些最终用户可能会需要使用Eclipse中的生成器。对于这些用例，Acceleo还支持从Eclipse中编译和启动Acceleo生成器。如果可以调用Java源代码，则可以启动Acceleo生成器。
          </li>
          <li class="span7">
            <img src="../../assets/img/features/stand-alone-lib.png" alt="" class="thumbnail">
          </li>
        </ul>
        <div class="alert alert-info">
          <strong>技巧和窍门：</strong>学习如何配置你的发电机使用它的Eclipse <a href="../reference/standalone.html">这里</a> 。
        </div>
      </section>
      
      <section id="tooling">
        <div class="page-header">
          <h1>Eclipse Tooling <small>集成在您最喜欢的IDE中</small></h1>
        </div>
        <h2>Acceleo项目</h2>
        <ul class="thumbnails">
          <li class="span5">
            <p>当您想使用Acceleo启动代码生成项目时，您的第一个操作是创建一个Acceleo项目。在Acceleo项目中，您可以放置Acceleo模块，Acceleo项目附带的构建器将自动为您编译模块。Acceleo项目也是几个关键首选项的容器，例如Acceleo模块所需的序列化类型或编译期间错误检测的严重性。
            </p>
          </li>
          <li class="span7">
            <img src="../../assets/img/features/eclipse-tooling-acceleo-project.png" alt="" class="thumbnail">
          </li>
        </ul>
        
        <h2>Acceleo Perspective</h2>
        <p>Acceleo透视图定义了在Acceleo生成器上工作的理想工作台。它的中心包含Acceleo编辑器，其中包含几个专用于代码生成器版本的视图。您可以在Acceleo透视图中找到以下视图：</p>
        <ul>
          <li>“Package Explorer”视图</li>
          <li>“大纲”视图</li>
          <li>“口译员”视图</li>
          <li>“问题”视图</li>
          <li>“错误日志”视图</li>
          <li>“结果”视图</li>
          <li>“覆盖”视图</li>
          <li>“生成模式”视图</li>
        </ul>
        <p>这些视图将让您测试操作Acceleo项目中的文件，测试Acceleo表达式，查看项目中发现的问题和错误，并使用代码生成设计模式。
        </p>
        <ul class="thumbnails">
          <li class="span8">
            <img src="../../assets/img/features/perspective-doc.png" alt="">
          </li>
          <li class="span4">
            <img src="../../assets/img/features/first-view-block.png" alt="">
          </li>
          <li class="span4">
            <img src="../../assets/img/features/second-view-block.png" alt="">
          </li>
        </ul>
        <p>Acceleo工具具有代码搜索系统，可让您找到所选模板或查询的所有引用。
        </p>
        
        <h2>Acceleo编辑</h2>
        <p>Acceleo编辑器是Acceleo工具的中心。它与Acceleo模块（“.mtl”文件）相关联，并提供现代编程编辑器的所有功能，以便在开发代码生成器时提高工作效率。因此，您可以在Acceleo编辑器中找到实时错误检测，语法突出显示，代码完成，代码导航，动态轮廓等功能。</p>
        <ul class="thumbnails">
          <li class="span8">
            <img src="../../assets/img/features/editor.png" alt="">
          </li>
          <li class="span4">您还可以在窗口 - &gt;首选项 - &gt;加速菜单中的Acceleo首选项菜单中更改Acceleo编辑器使用的颜色。
          </li>
        </ul>
        
        <h2>快速修复</h2>
        <p>Acceleo编辑器还支持“快速修复”。借助“Ctrl + 1”快捷键，您可以在几秒钟内访问基本问题的解决方案。这些快速修复将让您举例来定义新模板或新查询，以替换您可能尝试在模块中调用的未知操作。
        </p>
        
        <h2>重构</h2>
        <p>Acceleo工具提供了多种重构工具，可帮助您轻松地重命名或移动项目中的模块，模板和查询。
        </p>
        
        <br>
        <br>
      </section>
      
      <section id="javaservices">
        <div class="page-header">
          <h1>Java服务</h1>
        </div>
        <p>Acceleo允许您使用Java源代码来计算使用Acceleo语言无法实现的复杂操作。因此，您可以确保您甚至可以生成最复杂的请求。
        </p>
        <p>为了使用Java服务，您需要使用Acceleo操作“invoke”以告知Acceleo调用您的Java方法并为您提供结果。Java服务仅限于参数和返回值，其中包含来自生成器中使用的元模型之一的类型或“基本类型”（String，Integer，Real，Boolean等）。
        </p>
        
        <br>
        <br>
      </section>
      
      <section id="interpreter">
        <div class="page-header">
          <h1>Interpreter <small>实时评估所有Acceleo表达式</small></h1>
        </div>
        <p>从Acceleo 3.2.0开始，您现在可以在Acceleo工具中找到Interpreter视图。由于这个视图，您可以使用Acceleo语言直接测试和评估Acceleo表达式，而无需构建和运行整个代码生成器。此视图也是可扩展的，因此，您可以非常轻松地贡献自己的评估语言。
        </p>
        <p>解释器很容易让其他人贡献自己的语言来操作基于EMF的元素。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong> <a href="https://wiki.eclipse.org/Acceleo/Interpreter">Eclipse Wiki上的</a> Acceleo解释器的详细说明。
        </div>
        
        <br>
        <br>
      </section>
      
      <section id="override">
        <div class="page-header">
          <h1>覆盖<small>静态和动态覆盖</small></h1>
        </div>
        <p>使用静态覆盖，您可以轻松地重用现有模块的内容并更改其原始行为。动态覆盖是完全不同的级别，因为它允许您通过定义将替换生成器的现有模板的模板来更改现有生成器的行为。这样，与面向方面编程一样，您可以修补在客户计算机上构建，认证和部署的现有生成器，而无需更改原始生成器。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>查看<a href="https://www.obeo.fr/en/acceleo-best-practices">最佳实践指南</a> ，了解如何使用这两种行为。
        </div>
        
        <br>
        <br>
      </section>
      
      <section id="incremental">
        <div class="page-header">
          <h1>增量生成<small>保护您对生成的代码的更改</small></h1>
        </div>
        <p>Acceleo允许您定义保护区域，为最终用户提供可以修改生成代码的特定区域。您可以使用默认代码初始化这些受保护区域，并让您的用户知道他们可以安全地修改受保护的代码。
        </p>
        <p>Acceleo还允许您使用JMerge for Java文件，以便通过文档标记（@generated和@generate NOT）精确确定哪些功能应被视为用户代码，从而在下一代中保护其免受更改。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong> Acceleo生成的用于启动生成器的Java启动程序类也使用这些机制。
        </div>
        
        <br>
        <br>
      </section>
      
      <section id="userinterface">
        <div class="page-header">
          <h1>用户界面<small>在30秒内为您的发电机创建用户界面</small></h1>
        </div>
        <p>如果您希望将Eclipse中的Acceleo生成器集成到客户中，以便他们不必操作Acceleo项目，您可以使用Acceleo提供的向导为您的生成器创建基本的Eclipse用户界面。
        </p>
        <p>您可以使用以下说明创建此用户界面项目。右键单击Acceleo生成器并选择File  - &gt; New  - &gt; Project  - &gt; Acceleo Model to Text  - &gt; Acceleo UI Launcher  - &gt; Next  - &gt; Next  - &gt; Next。在那里，您可以选择生成器的名称，应该用于生成的文件类型（UML生成器的* .uml）以及生成代码的位置，默认情况下，它将在名为“”的文件夹中生成src-gen“位于包含输入模型的项目的根目录。
        </p>
        
        <br>
        <br>
      </section>
      
      <section id="build">
        <div class="page-header">
          <h1>建立<small>持续集成</small></h1>
        </div>
        <p>在Eclipse中，Acceleo项目会自动构建您的模块，但您可能希望将Acceleo生成器置于持续集成系统中。为了做到这一点，Acceleo为独立的maven编译提供支持，可以在任何基于maven的构建中轻松插入。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>查看<a href="https://wiki.eclipse.org/Acceleo/Maven">Acceleo wiki</a>以获取有关Acceleo的maven集成的更多信息。
        </div>
        
        <br>
        <br>
      </section>
      
      <footer class="footer">
        <p>这些指南中的材料是版权所有（c）2008,2012 Obeo。该材料可在Eclipse Public License v1.0下获得</p>
      </footer>
    </div>
  </body>
</html><html id="2904.org_eclipse_ui_ide_projectConfigurators.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>项目配置器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">项目配置器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.ide.projectConfigurator<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.12<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点允许贡献者添加导入策略。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.projectConfigurator">projectConfigurator</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.projectConfigurator">projectConfigurator</a> （ <a href="#e.activeWhen">activeWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST projectConfigurator</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 定义导入策略贡献的类。这堂课负责3件事：<ul>
                    <li>检测并确定给定文件夹是否是工作空间中的Eclipse项目，通常取决于特定文件，模式或文本的存在</li>
                    <li>它是否适用于现有的Eclipse项目，通常取决于特定文件，模式或文本的存在</li>
                    <li>在工作区中应用新项目或现有Eclipse项目的配置</li>
                  </ul></li>
<li><b>label</b> - 配置器的标签，呈现给用户。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.activeWhen">activeWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> | <a href="#e.hasFile">hasFile</a> | <a href="#e.hasFileRecursively">hasFileRecursively</a> | <a href="#e.hasFileWithSuffixRecursively">hasFileWithSuffixRecursively</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制项目配置的启用。将在加载项目配置之前进行检查</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.hasFile">hasFile</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST有文件</p>
<p class="code SchemaDtdAttlist">路径CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>path</b> -  File是这个表达式寻找的。这是表达式将应用于容器的相对路径。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.hasFileRecursively">hasFileRecursively</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST hasFile递归</p>
<p class="code SchemaDtdAttlist">filename CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>filename</b> - 表达式将在上下文容器中递归查找的文件名。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.hasFileWithSuffixRecursively">hasFileWithSuffixRecursively</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST hasFileWithSuffix递归</p>
<p class="code SchemaDtdAttlist">后缀CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>后缀</b> - 文件的后缀。Expression将在上下文容器中以递归方式查找具有此后缀的文件。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>请参阅相同的插件，EclipseProjectConfigurator的贡献。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>API目前不稳定。特色是孵化。
<p></p>

<br>
<p class="note SchemaCopyright">
</p>
</body>
</html><html id="2895.org_eclipse_ui_genericeditor_reconcilers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>Reconcilers</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">Reconcilers</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.reconcilers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供协调程序，以控制具有给定内容类型的文件上的表示。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.reconciler">协调程序</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reconciler">协调器</a> （ <a href="#e.enabledWhen">启用时间</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST协调员</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.reconciler.的完全限定类名<code>org.eclipse.jface.text.reconciler.IReconciler</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定协调程序的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是如何使用Reconciler扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.reconcilers”</span> <span class="code SchemaTag">&gt; &lt;reconciler class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionReconciler“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ reconciler&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2017 Red Hat Inc.及其他本程序及随附材料均根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="2888.org_eclipse_ui_genericeditor_autoEditStrategies.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>自动编辑策略</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">自动编辑策略</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.autoEditStrategies<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于为给定的内容类型提供自动编辑策略。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.autoEditStrategy">autoEditStrategy</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.autoEditStrategy">autoEditStrategy</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST autoEditStrategy</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.的完全限定类名<code>org.eclipse.jface.text.IAutoEditStrategy</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定自动编辑策略的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>这是为目标定义文件类型注册的策略示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.autoEditStrategies”</span> <span class="code SchemaTag">&gt; &lt;autoEditStrategy class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionAutoEditStrategy“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ autoEditStrategy&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2017 Rogue Wave Software Inc.及其他本程序及随附材料均根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">/epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="1792.analyzingjavacollectionusage.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<meta name="DC.Type" content="task"></meta>
<meta name="DC.Title" content="Analyzing Java Collection Usage"></meta>
<meta name="copyright" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Rights.Owner" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Format" content="XHTML"></meta>
<meta name="DC.Identifier" content="task_analyzingjavacollectionusage"></meta>
<meta name="DC.Language" content="en-us"></meta>
<link rel="stylesheet" type="text/css" href="../styles/commonltr.css"></link>
<title>分析Java集合使用情况</title>
</head>
<body id="task_analyzingjavacollectionusage" dir="ltr">


	<h1 class="title topictitle1">分析Java集合使用情况</h1>

	

	<div class="body taskbody">
		<div class="section context">
			<p class="p">集合是用于存储，检索和操作数据的对象。Memory Analyzer提供以下查询来分析Java集合：</p>

			
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" class="table" border="1" summary="" frame="border" rules="all">
					<tbody class="tbody">
						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">阵列填充率查询</strong>
							</td>

							<td class="entry" valign="top">打印非原始阵列的填充率的频率分布。填充率是数组中非null元素的比例。然后将阵列累积到与参数化一样多的段中。基元数组不能具有空值，因此此查询仅适用于对象数组。
							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">按大小查询分组的数组</strong>
							</td>

							<td class="entry" valign="top">按大小分组的给定阵列的分布直方图。</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">收集填充率查询</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">打印给定集合的填充率的频率分布。以下集合可用于查询：</p>

								<ul class="ul">
									<li class="li">
										<pre class="pre codeblock">java.awt中。的RenderingHints</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.beans.beancontext中。化子级</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.lang中。ThreadLocal的$ ThreadLocalMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ArrayDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。数组列表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。数组$的ArrayList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$的emptyList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ EmptyMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ EmptySet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SingletonList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SingletonSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ArrayBlockingQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的ConcurrentHashMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentLinkedDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的ConcurrentLinkedQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentSkipListMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的CopyOnWriteArrayList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。DelayQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。LinkedBlockingDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的LinkedBlockingQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。LinkedTransferQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的SynchronousQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashSet的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。哈希表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $列表0</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ SET1</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。LinkedHashSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。链表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。的PriorityQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。TreeSet中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。WeakHashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.jar中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">javax.script中。SimpleBindings</pre>

									</li>

								</ul>

								<p class="p">可以通过'collection'，'size_attribute'和'array_attribute'参数指定一个额外的自定义集合（例如，非JDK）集合。</p>

							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">按大小查询分组的集合</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">给定集合的分布直方图按大小排列。以下集合可用于查询。已知系列：</p>

								<ul class="ul">
									<li class="li">
										<pre class="pre codeblock">java.awt中。的RenderingHints</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.beans.beancontext中。化子级</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.lang中。ThreadLocal的$ ThreadLocalMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ArrayDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。数组列表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。数组$的ArrayList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$的emptyList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ EmptyMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ EmptySet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SingletonList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SingletonMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SingletonSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableCollection</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ArrayBlockingQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的ConcurrentHashMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentLinkedDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的ConcurrentLinkedQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentSkipListMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentSkipListSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的CopyOnWriteArrayList</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。CopyOnWriteArraySet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。DelayQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。LinkedBlockingDeque</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的LinkedBlockingQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。LinkedTransferQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的SynchronousQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashSet的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。哈希表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。IdentityHashMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $列表0</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $列表1</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $列表2</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ ListN</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ MapN</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ SET0</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ SET1</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ SET2</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ SETN</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.jar中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。LinkedHashMap的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。LinkedHashSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。链表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。的PriorityQueue</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。TreeMap的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。TreeSet中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。向量</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。WeakHashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">javax.script中。SimpleBindings</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">javax.swing中。的UIDefaults</pre>

									</li>

								</ul>

								<p class="p">可以通过'collection'，'size_attribute'和'array_attribute'参数指定一个额外的自定义集合（例如，非JDK）集合。</p>

							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">提取列表值查询</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">列出单个LinkedList，ArrayList，Vector，CopyOnWriteArrayList，PriorityQueue，ArrayDeque对象的元素。</p>

								
							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">哈希条目查询</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">从哈希映射和哈希表中提取键值对。</p>

							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">提取哈希集值查询</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">列出单个HashSet的元素。</p>

							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">地图碰撞率查询</strong>
							</td>

							<td class="entry" valign="top">
								<p class="p">打印类似地图集合的碰撞比率的频率分布。以下类似地图的集合可用于查询。</p>

								<ul class="ul">
									<li class="li">
										<pre class="pre codeblock">java.util中。HashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。哈希表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。WeakHashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentHashMap的$段</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashMap中</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。HashSet的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。哈希表</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。IdentityHashMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。的ConcurrentHashMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentSkipListMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.concurrent中。ConcurrentSkipListSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ CheckedMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ SynchronizedSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。集合$ UnmodifiableSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。LinkedHashMap的</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。LinkedHashSet</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util中。ImmutableCollections $ MapN</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.util.jar中。属性</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.awt中。的RenderingHints</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.beans.beancontext中。化子级</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">java.lang中。ThreadLocal的$ ThreadLocalMap</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">javax.script中。SimpleBindings</pre>

									</li>

									<li class="li">
										<pre class="pre codeblock">javax.swing中。的UIDefaults</pre>

									</li>

								</ul>

								<p class="p">可以通过'collection'，'size_attribute'和'array_attribute'参数指定另一个自定义类似地图（例如，非JDK）集合。</p>

							</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top">
								<strong class="ph b">具有常数值的原始数组</strong>
							</td>

							<td class="entry" valign="top">列出所有填充了一个相同值的原始数组（来自选择）</td>
							
						</tr>

					</tbody>

				</table>
</div>

			<p class="p">可以从工具栏下拉菜单访问所有这些查询： <span class="ph menucascade"><span class="ph uicontrol">打开查询浏览器</span> &gt; <span class="ph uicontrol">Java集合</span></span>
			</p>

		</div>

	</div>


</body>
</html><html id="2741.org_eclipse_core_resources_modelProviders.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>模型提供商</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">模型提供商</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.core.resources.modelProviders<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>模型提供者有两个目的。首先，它是一种将单个模型的资源映射分组在一起以执行操作，显示等的方法。此外，它还提供了一种将一组文件系统资源映射到描述模型如何的资源映射的方法。映射到资源。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.modelProvider">modelProvider</a> ， <a href="#e.extends-model">extends-model</a> *， <a href="#e.enablement">enablement</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.modelProvider">modelProvider</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST modelProvider</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>课程</b> -</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extends-model">扩展模型</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展模型</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是使用modelProvider扩展点的示例。（在文件plugin.xml中）<pre class="Example"><span class="code SchemaTag">&lt;extension id =</span> <span class="code SchemaCstring">“modelProvider”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“Library Model Provider”</span> <span class="code SchemaTag">point =</span> <span class="code SchemaCstring">“org.eclipse.core.resources.modelProviders”</span> <span class="code SchemaTag">&gt; &lt;modelProvider class =</span> <span class="code SchemaCstring">“org.eclipse.examples.library。LibraryModelProvider“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”Library Model Provider“</span> <span class="code SchemaTag">/&gt; &lt;extends-model id =</span> <span class="code SchemaCstring">”org.eclipse.core.resources.modelProvider“</span> <span class="code SchemaTag">/&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”or“</span> <span class="code SchemaTag">&gt; &lt; equals value =</span> <span class="code SchemaCstring">“org.eclipse.team.examples.library.nature”</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须表示<tt>org.eclipse.core.resources.mapping的实现<tt>。ModelProvider</tt> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>平台本身没有任何预定义的模型提供者。特定产品安装可能包括模型提供者。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2010 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2918.org_eclipse_ui_navigator_linkHelper.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>导航器链接助手</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">导航器链接助手</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.navigator.linkHelper<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>为希望扩展Common Navigator的“Link with Editor”功能的客户端提供挂钩。链接助手必须包含在<b>org.eclipse.ui.navigator.viewer</b>扩展点的<b>viewerContentBinding</b>元素中。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.linkHelper">linkHelper</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.linkHelper">linkHelper</a> （ <a href="#e.editorInputEnablement">editorInputEnablement</a> ， <a href="#e.selectionEnablement">selectionEnablement</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST linkHelper</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.navigator.ILinkHelper</code> 。</li>
<li><b>id</b> - 此<b>linkHelper</b>扩展名的唯一ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.editorInputEnablement">editorInputEnablement</a> （ <a href="#e.not">not</a> ， <a href="#e.and">and</a> ， <a href="#e.or">或</a> <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">Eclipse Core Expression，描述此帮助程序何时可以从编辑器输入中提供选择。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selectionEnablement">selectionEnablement</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">Eclipse Core Expression，描述此扩展何时可以为给定选择提供IEditorInput。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.linkHelper”</span> <span class="code SchemaTag">&gt; &lt;linkHelper class =</span> <span class="code SchemaCstring">“org.eclipse.ui.internal.navigator.resources.workbench。ResourceLinkHelper“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.ui.navigator.resources.linkHelper“</span> <span class="code SchemaTag">&gt; &lt;selectionEnablement&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;/ selectionEnablement&gt; &lt;editorInputEnablement&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.ui。IFileEditorInput“</span> <span class="code SchemaTag">/&gt; &lt;/ editorInputEnablement&gt; &lt;/ linkHelper&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2009 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2889.org_eclipse_ui_genericeditor_characterPairMatchers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>字符对匹配器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">字符对匹配器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.characterPairMatchers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供字符对匹配器，用于控制具有给定内容类型的文件上的匹配括号。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.characterPairMatcher">characterPairMatcher</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.characterPairMatcher">characterPairMatcher</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST characterPairMatcher</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.source.的完全限定类名<code>org.eclipse.jface.text.source.ICharacterPairMatcher</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定字符对匹配器的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面是如何使用字符对匹配扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.characterPairMatchers”</span> <span class="code SchemaTag">&gt; &lt;characterPairMatcher class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionCharacterPairMatchers“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ characterPairMatcher&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2018 Angelo ZERR和其他所有权利保留。本程序及随附材料根据本发行版附带的Eclipse Public License v2.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v20.html">http://www.eclipse.org/legal/epl-v20.html</a>获取<a href="http://www.eclipse.org/legal/epl-v20.html">。</a>

</p>
</body>
</html><html id="2830.org_eclipse_ltk_core_refactoring_createParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>创建参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">创建参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.core.refactoring.createParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义重构创建参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是要创建的元素<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>java.lang.Object</code> ;要创建的元素（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.createParticipant">createParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.createParticipant">createParticipant</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST createParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 创建参与者的唯一标识符。</li>
<li><b>name</b> - 创建参与者的人类可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下示例定义了创建参与者。如果受重构影响的项目之一具有Java特性，并且要创建的元素是文件夹，则启用参与者。

<pre class="Example"><span class="code SchemaTag">&lt;createParticipant id =</span> <span class="code SchemaCstring">“org.myCompany.createParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“％CreateParticipant.name”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.myCompany。CreateParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFolder“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ createParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.core.refactoring.participants.CreateParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2731.org_eclipse_core_expressions_definitions.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>表达定义</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">表达定义</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.core.expressions.definitions<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.3<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>此扩展点允许您创建可重用的扩展。然后，它们可以用于其他核心表达构造。
</p>
<p>核心表达式中的引用元素将使用对引用元素有效的评估上下文来计算表达式定义。
</p><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.definition">定义</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.definition">定义</a> （ <a href="#e.not">不是</a> | <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">等于</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST定义</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">提供要与&lt;reference /&gt;表达式元素一起使用的表达式的全局定义。这有助于重用常用表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 表达式定义的全局唯一标识符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>您可以定义和使用核心表达式：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.core.expressions.definitions”</span> <span class="code SchemaTag">&gt; &lt;definition id =</span> <span class="code SchemaCstring">“com.example.parts.activeProblemsView”</span> <span class="code SchemaTag">&gt; &lt;with variable =</span> <span class="code SchemaCstring">“activePartId”</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">“org.eclipse.ui.views 。ProblemsView“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ definition&gt; &lt;definition id =</span> <span class="code SchemaCstring">”com.example.markers.markerSelection“</span> <span class="code SchemaTag">&gt; &lt;iterate&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IMarker“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ definition&gt; &lt;/ extension&gt;</span></pre>

<p>然后，在编写其他表达式时可以使用此表达式定义。
</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;enabledWhen&gt; &lt;reference definitionId =</span> <span class="code SchemaCstring">“com.example.parts.activeProblemsView”</span> <span class="code SchemaTag">&gt; &lt;/ enabledWhen&gt;</span></pre>
<pre class="Example"><span class="code SchemaTag">&lt;visibleWhen&gt; &lt;和&gt; &lt;reference definitionId =</span> <span class="code SchemaCstring">“com.example.parts.activeProblemsView”</span> <span class="code SchemaTag">/&gt; &lt;reference definitionId =</span> <span class="code SchemaCstring">“com.example.markers.markerSelection”</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ visibleWhen&gt;</span></pre>

<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2007,2008 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2831.org_eclipse_ltk_core_refactoring_deleteParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>删除参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">删除参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.core.refactoring.deleteParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义重构删除参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是要删除的元素。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>java.lang.Object</code> ;要删除的元素（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.deleteParticipant">deleteParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.deleteParticipant">deleteParticipant</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST deleteParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 删除参与者的唯一标识符。</li>
<li><b>name</b> - 删除参与者的人类可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下示例定义了删除参与者。如果受重构影响的项目之一具有Java特性，并且要删除的元素属于ICompilationUnit类型，则启用参与者。

<pre class="Example"><span class="code SchemaTag">&lt;deleteParticipant id =</span> <span class="code SchemaCstring">“org.myCompany.deleteParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“％DeleteParticipant.name”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.myCompany。参与者“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.jdt.core。ICompilationUnit“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ deleteParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.core.refactoring.participants.DeleteParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2890.org_eclipse_ui_genericeditor_contentAssistProcessors.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>内容辅助处理器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">内容辅助处理器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.contentAssistProcessors<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供内容辅助处理器，以便为给定内容类型添加内容辅助支持。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.contentAssistProcessor">contentAssistProcessor</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.contentAssistProcessor">contentAssistProcessor</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST contentAssistProcessor</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.contentassist.的完全限定类名<code>org.eclipse.jface.text.contentassist.IContentAssistProcessor</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定内容辅助处理器的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>这是为目标定义文件类型注册的处理器的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.contentAssistProcessors”</span> <span class="code SchemaTag">&gt; &lt;contentAssistProcessor class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargedDefinitionContentAssist“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ contentAssistProcessor&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2016 Red Hat Inc.及其他本程序及随附材料均按照此发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="2894.org_eclipse_ui_genericeditor_presentationReconcilers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>演示协调员</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">演示协调员</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.presentationReconcilers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供演示文稿协调程序，以控制具有给定内容类型的文件上的演示文稿。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.presentationReconciler">presentationReconciler</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.presentationReconciler">presentationReconciler</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST presentationReconciler</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.presentation.的完全限定类名<code>org.eclipse.jface.text.presentation.IPresentationReconciler</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定演示文稿协调程序的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是如何使用Presentation Reconciler扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.presentationReconcilers”</span> <span class="code SchemaTag">&gt; &lt;presentationReconciler class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionPresentationReconciler“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ presentationReconciler&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2016 Red Hat Inc.及其他本程序及随附材料均按照此发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="2941.org_eclipse_ui_workbench_texteditor_codeMiningProviders.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>CodeMining提供商</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">CodeMining提供商</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.workbench.texteditor.codeMiningProviders<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.10<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于注册代码提供程序。通过此扩展关联提供程序不会自动启用代码挖掘，并且客户端也应该使用协调程序或任何事件机制来调用ISourceViewerExtension5.updateCodeMinings（）。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.codeMiningProvider">codeMiningProvider</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.codeMiningProvider">codeMiningProvider</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST codeMiningProvider</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">CodeMining提供商。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 唯一标识此代码提供程序的字符串</li>
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.codemining.的完全限定类名<code>org.eclipse.jface.text.codemining.ICodeMiningProvider</code> 。</li>
<li><b>label</b> - 代码提供程序的显示标签，将显示在CodeMining UI首选项中</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定的代码提供程序的启用</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是代码提供程序定义的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.workbench.texteditor.codeMiningProviders”</span> <span class="code SchemaTag">&gt; &lt;codeMiningProvider class =</span> <span class="code SchemaCstring">“org.eclipse.jdt.internal.ui.codemining。JavaReferencesCodeMiningProvider“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.jdt.ui.codemining.references“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”Java References“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.internal.ui。 javaeditor。CompilationUnitEditor“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ codeMiningProvider&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>请参阅org.eclipse.jface.text.codemining。ICodeMiningProvider类和org.eclipse.ui.workbench.texteditor.codeMiningProviders扩展点。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2017 Angelo ZERR。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2832.org_eclipse_ltk_core_refactoring_moveParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>移动参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">移动参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.core.refactoring.moveParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义重构移动参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是要移动的元素。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>java.lang.Object</code> ;要移动的元素（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.moveParticipant">moveParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.moveParticipant">moveParticipant</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST moveParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 移动参与者的唯一标识符。</li>
<li><b>name</b> - 移动参与者的人类可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下示例定义了类型移动参与者。如果受重构影响的项目之一具有Java特性，并且要移动的类型是JUnit测试，则启用参与者。<pre class="Example"><span class="code SchemaTag">&lt;moveParticipant id =</span> <span class="code SchemaCstring">“org.eclipse.jdt.junit.moveTypeParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“％MoveTypeParticipant.name”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.jdt.internal.junit.ui。TypeMoveParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.jdt.core。IType“</span> <span class="code SchemaTag">/&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.jdt.junit.isTest“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ moveParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.core.refactoring.participants.MoveParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2892.org_eclipse_ui_genericeditor_highlightReconcilers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>突出显示协调员</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">突出显示协调员</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.highlightReconcilers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供高亮协调程序，用于控制具有给定内容类型的文件的突出显示。附加到此扩展点的调节器将通过“Toggle Mark Occurences”按钮切换，以监听首选项“org.eclipse.ui.genericeditor.togglehighlight”。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.highlightReconciler">highlightReconciler</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.highlightReconciler">highlightReconciler</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST highlightReconciler</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.reconciler.的完全限定类名<code>org.eclipse.jface.text.reconciler.IReconciler</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定高亮协调程序的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是如何使用Highlight Reconciler扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.highlightReconcilers”</span> <span class="code SchemaTag">&gt; &lt;highlightReconciler class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionHighlightReconciler“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ highlightReconciler&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2017 Red Hat Inc.及其他本程序及随附材料均根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="2891.org_eclipse_ui_genericeditor_foldingReconcilers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>折叠调节器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">折叠调节器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.foldingReconcilers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供折叠协调程序，以控制具有给定内容类型的文件上的折叠。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.foldingReconciler">foldingReconciler</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.foldingReconciler">foldingReconciler</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST foldingReconciler</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.reconciler.的完全限定类名<code>org.eclipse.jface.text.reconciler.IReconciler</code>要操纵折叠，实现协调器需要使用ProjectionAnnotation和viewer.getProjectionModel（）。您可以在org.eclipse.ui.internal.genericeditor.folding中找到示例。DefaultFoldingReconciler。</li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定折叠协调程序的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面是如何使用Folding Reconciler扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.foldingReconcilers”</span> <span class="code SchemaTag">&gt; &lt;foldingReconciler class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionFoldingReconciler“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ foldingReconciler&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2017 Red Hat Inc.及其他本程序及随附材料均根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="3138.org_eclipse_ui_commands.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>命令</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">命令</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.commands<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>2.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p><code>org.eclipse.ui.commands</code>扩展点用于使用<code>command</code>和<code>category</code>元素声明命令和命令类别。命令是一些语义行为的抽象表示，但不是它的实际实现。这允许不同的开发人员为他们的各个部分贡献特定的行为。例如，可能存在“粘贴”命令，其中编辑器中具有一个实现，而浏览器窗口小部件中具有不同的实现。这些实现称为处理程序。命令也可以被视为声明性函数指针或信号处理程序。
</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.category">类别</a> *， <a href="#e.command">命令</a> *， <a href="#e.commandParameterType">commandParameterType</a> *， <a href="#e.context">context</a> *， <a href="#e.scope">scope</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 扩展实例的可选标识符。</li>
<li><b>name</b> - 扩展实例的可选名称。</li>
<li><b>point</b> - 目标扩展点的标准标识符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.command">命令</a> （ <a href="#e.defaultHandler">defaultHandler</a> ？， <a href="#e.state">state</a> *， <a href="#e.commandParameter">commandParameter</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令</p>
<p class="code SchemaDtdAttlist">类别CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">categoryId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultHandler CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">returnTypeId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>该元素用于定义命令。命令表示来自用户的可以由动作处理的请求，并且在其他命令中应该在语义上是唯一的。如果已经定义了具有相同含义的命令，则不要定义命令。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。请参阅扩展点<a href="org_eclipse_ui_actionSets.html">org.eclipse.ui.actionSets</a>和<a href="org_eclipse_ui_editorActions.html">org.eclipse.ui.editorActions</a>以了解操作如何连接到命令。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">弃用</i> <b>类别</b> - 请改用<code>categoryId</code> 。</li>
<li><b>description</b> - 此命令的可翻译简短描述，用于在UI中显示。</li>
<li><b>id</b> - 此命令的唯一标识符。</li>
<li><b>name</b> - 要在UI中显示的此命令的可翻译名称。命令通常以命令式动词的形式命名。</li>
<li><b>categoryId</b> -<p>此命令的类别的唯一ID。如果此命令未指定类别，则将其置于全局“未分类”类别中。
</p>
<p><em>从：3.0</em></p></li>
<li><b>defaultHandler</b> -<p>此命令的默认处理程序（请参阅<a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>扩展点）。如果没有其他处理程序处于活动状态，则此处理程序将处此处理程序将与指定没有<code>activeWhen</code>条件的其他处理程序定义冲突。如果要创建<code>IExecutableExtension</code> ，则可以使用<code>defaultHandler</code>元素。
</p>
<p><em>自：3.1</em></p></li>
<li><b>returnTypeId</b> -<p><code>commandParameterType</code>的id，指示此命令返回的值的类型。指定<code>returnTypeId</code>允许执行该命令的客户端将返回的值与Java类型相关联，并将该值转换为可以存储和/或传递给另一个接受相同类型参数的命令的String形式。
</p>
<p><em>自：3.2</em></p></li>
<li><b>helpContextId</b> -<p>通常与此命令相关的帮助上下文的标识符。处理程序可以覆盖此上下文标识符，以提供更特定于其特定行为的帮助。
</p>
<p><em>自：3.2</em></p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.category">类别</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST类别</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>在UI中，命令通常按类别组织，以使其更易于管理。此元素用于定义这些类别。命令可以将自己添加到最多一个类别。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>description</b> - 此类别的可翻译简短描述，用于在UI中显示。</li>
<li><b>id</b> - 此类别的唯一标识符。</li>
<li><b>name</b> - 要在UI中显示的此类别的可翻译名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.commandParameter">commandParameter</a> （ <a href="#e.values">值</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令参数</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">typeId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">optional（true | false）“true”&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>定义命令应该理解的参数。参数是一种在执行时向处理程序提供更多信息的方法。例如，“show view”命令可能会将视图作为参数。处理程序应该能够理解这些参数，因此它们应该像API一样对待。</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此参数的唯一标识符。</li>
<li><b>name</b> - 参数的名称。这是将显示给最终用户的名称。因此，它应该是可翻译的。这个名字应该简短 - 最好是一个字。</li>
<li><b>values</b> - 提供用户选择的参数值列表的类。这个类应该实现<code>org.eclipse.core.commands.IParameterValues</code> 。如果未指定此类，则必须指定更详细的<code>values</code>元素。请参阅<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
<li><b>typeId</b> - 此<b>commandParameter的commandParameterType</b>的id。指定typeId允许命令的处理程序以一致的方式将字符串参数值转换为对象，并允许命令的潜在调用者查找为其参数获取各种类型的对象的命令。</li>
<li><b>可选</b> - 此参数是否可选。如果参数是可选的，则处理程序应该能够处理参数的缺失。默认情况下，所有参数都是可选的。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.commandParameterType">commandParameterType</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST commandParameterType</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">键入CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">转换器CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>定义commandParameter的对象类型，并可以指定<code>org.eclipse.core.commands.AbstractParameterValueConverter</code>子类，用于在字符串参数值和对象之间进行转换。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此commandParameterType的唯一标识符。</li>
<li><b>type</b> - 要用作此命令参数类型的Java类或接口的标准名称。此属性是可选的，但如果省略，则为<code>java.lang.Object</code>将用作参数类型。</li>
<li><b>converter</b> - 用于在命令参数值的对象和字符串表示形式之间进行转换的类。这个类应该扩展<code>org.eclipse.core.commands.AbstractParameterValueConverter</code> 。转换器应生成和使用<code>type</code>属性中指示的<code>type</code>对象。如果未指定此类，则此参数类型的字符串和对象值之间的转换将无法使用（类<code>ParameterType</code>上的<code>getValueConverter()</code>将返回<code>null</code> ）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.values">值</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST值</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p><code>commandParameter</code>上的<code>values</code>属性的详细版本。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 提供用户选择的参数值列表的类。这个类应该实现<code>org.eclipse.core.commands.IParameterValues</code> 。如果未指定此类，则必须指定更详细的<code>values</code>元素。请参阅<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>参数的可能值。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 要传递给<code>IExecutableExtension</code>的参数的名称。</li>
<li><b>value</b> - 要传递给<code>IExecutableExtension</code>的参数的值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.defaultHandler">defaultHandler</a> （ <a href="#e.parameter">参数</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST defaultHandler</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>此命令的默认处理程序。如果没有其他处理程序处于活动状态，则此处理程序将处此处理程序将与指定没有<code>activeWhen</code>条件的其他处理程序定义冲突。如果您没有创建<code>IExecutableExtension</code> ，则可以使用<code>defaultHandler</code>属性。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.core.commands.的类<code>org.eclipse.core.commands.IHandler</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.state">状态</a> （ <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST州</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>所有处理程序之间共享的状态信息，并且可能在会话之间持续存在。状态只是一个被加载以监视状态的类。有关更多详细信息，请参阅API信息。这不用于UI属性，如菜单贡献复选框状态或标签。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 可以加载以存储此命令状态的类。状态由处理程序共享，并且可以在会话之间保持不变。该类必须是<code>org.eclipse.core.commands.子类<code>org.eclipse.core.commands.State</code> 。请参阅API信息。</li>
<li><b>id</b> -<p>此状态的唯一标识符。这用于在会话之间保持状态（如果状态是<code>org.eclipse.jface.commands.的实例<code>org.eclipse.jface.commands.PersistentState</code> ）。某些常用标识符（请参阅<code>org.eclipse.jface.menus.在菜单或工具栏中呈现命令时，可以理解IMenuStateIds</code> ）。标识符在定义状态的命令中只需要是唯一的。
</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>可以加载以存储此命令状态的类。如果要将多个参数传递给<code>org.eclipse.core.runtime.则使用此元素<code>org.eclipse.core.runtime.IExecutableExtension</code> 。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 可以加载以存储此命令状态的类。状态由处理程序共享，并且可以在会话之间保持不变。该类必须实现<code>org.eclipse.core.commands.State</code> 。请参阅API信息。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>context</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.context">context</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST背景</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">parentId CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义上下文。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。请改用<a href="org_eclipse_ui_contexts.html">org.eclipse.ui.contexts</a>扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>描述</b> - 用于在UI中显示的此上下文的可翻译简短描述。</li>
<li><i style="color:red">不推荐使用的</i> <b>ID</b> - 此上下文的唯一标识符。</li>
<li><i style="color:red">不推荐使用的</i> <b>名称</b> - 用于在UI中显示的此上下文的可翻译名称。如果此上下文具有父级，则不必在名称中添加“（extends parent）”。这将在必要时由UI自动添加。</li>
<li><i style="color:red">不推荐使用的</i> <b>父级</b> - 父级上下文的唯一ID。如果此上下文具有父级，则除了在其自己的上下文中定义的键绑定之外，它还将从其父级借用所有键绑定。@deprecated请改用“parentId”。</li>
<li><i style="color:red">不推荐使用的</i> <b>parentId</b> - 父上下文的唯一ID。如果此上下文具有父级，则除了在其自己的上下文中定义的键绑定之外，它还将从其父级借用所有键绑定。</li>
</ul>
<br><div style="color:red;font-style:italic"><b>scope</b>元素已弃用</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.scope">范围</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST范围</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义范围。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>描述</b> - 用于在UI中显示的此范围的可翻译简短描述。 @deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>ID</b> - 此范围的唯一标识符。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>名称</b> - 此范围的可翻译名称，用于在UI中显示。如果此范围具有父级，则无需在名称中添加“（extends parent）”。这将在必要时由UI自动添加。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>父级</b> - 父级作用域的唯一ID。如果此作用域具有父作用域，则除了在其自己的作用域中定义的键绑定外，它还将从其父作业中借用所有键绑定。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p><code>org.eclipse.ui</code>插件中的<code>plugin.xml</code>文件广泛使用了<code>org.eclipse.ui.commands</code>扩展点。
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>可以使用<code>org.eclipse.ui.handlers.在命令中注册处理程序<code>org.eclipse.ui.handlers.IHandlerService</code> 。这可以通过调用<code>getService(IHandlerService.class)</code>从各种工作台组件（例如，工作台，工作台窗口，零件站点等）中<code>getService(IHandlerService.class)</code> 。
</p>
<p>通常，最好静态地声明所有命令（在<code>plugin.xml</code> ）。这样用户可以将键绑定附加到命令。但是，可以在运行时声明命令。为此，请检索<code>org.eclipse.ui.commands.来自工作台组件的ICommandService</code> ，调用<code>getCommand(yourCommandID)</code>然后调用<code>Command.define(...)</code> 。如果已卸载，则必须通过编程方式清除以编程方式定义的命令。
</p>
<p>有一些处理程序状态的默认实现可能对此扩展点的用户有用：</p>
<ul>
<li>org.eclipse.jface.commands。TextState</li>
<li>org.eclipse.jface.commands。RadioState</li>
<li>org.eclipse.jface.commands。ToggleState</li>
<li>org.eclipse.ui.handlers。RegistryRadioState</li>
<li>org.eclipse.ui.handlers。RegistryToggleState</li>
</ul>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2007 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="2829.org_eclipse_ltk_core_refactoring_copyParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>复制参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">复制参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.core.refactoring.copyParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义重构复制参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是要复制的元素。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>java.lang.Object</code> ;要复制的元素（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.copyParticipant">copyParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.copyParticipant">copyParticipant</a> （ <a href="#e.enablement">启用</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST copyParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">processOnCancel CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 复制参与者的唯一标识符。</li>
<li><b>name</b> - 复制参与者的人类可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。</li>
<li><b>processOnCancel</b> - 如果为true，即使整体更改被取消，参与者创建的更改也将被执行。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下示例定义了复制文件的参与者。如果受重构影响的项目之一具有Java特性，则启用参与者。

<pre class="Example"><span class="code SchemaTag">&lt;copyParticipant id =</span> <span class="code SchemaCstring">“org.eclipse.samples.copyParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“％CopyFileParticipant.name”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.samples。CopyFileParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ copyParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.core.refactoring.participants.CopyParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="1340.ch03s08s04.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>3.8.4。�开始Java AUT（Swing，SWT / RCP / GEF）</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula User Manual"></link>
<link rel="up" href="ch03s08.html" title="3.8.�Starting and configuring AUTs"></link>
<link rel="prev" href="ch03s08s03.html" title="3.8.3.�Using a working directory in an AUT configuration"></link>
<link rel="next" href="ch03s08s05.html" title="3.8.5.�Starting JavaFX AUTs"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">3.8.4。�开始Java AUT（Swing，SWT / RCP / GEF）</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch03s08s03.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">3.8。�开始和配置AUT</th>
<td width="20%" align="right">� <a href="ch03s08s05.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula用户手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch03.html">任务</a></span> &gt; <span class="breadcrumb-link"><a href="ch03s08.html">启动和配置AUT</a></span> &gt; <span class="breadcrumb-node">启动Java AUT（Swing，SWT / RCP / GEF）</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="starting-java-auts"></a> 3.8.4。�开始Java AUT（Swing，SWT / RCP / GEF）</h3></div></div></div>
<a name="starting-java-auts.autConfigSettingWizardPagePageContextId"></a><div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="two-options-to-start-java"></a> 3.8.4.1。�启动Java AUT的两个选项</h4></div></div></div>
<a name="two-options-to-start-java.autConfigSettingWizardPagePageContextId"></a><a name="two-options-to-start-java.autSettingWizardPagePageContextId"></a><p>启动Java AUT进行测试有两种选择：</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">通过AUT配置：</span></dt>
<dd><p>此选项意味着您在项目中创建AUT配置，并且从ITE启动AUT（ <a class="xref" href="ch03s08s04.html#configuring-a-java-aut-ite-start" title="3.8.4.2。�配置从ITE启动的Java AUT">章节�3.8.4.2，“配置要从ITE启动的Java AUT”</a> ）。
          </p></dd>
<dt><span class="term">使用<span class="emphasis"><em>autrun</em></span>命令：</span></dt>
<dd><p>此选项允许您在不创建配置的情况下启动AUT。AUT需要某些启动参数，以便可以找到它（ <a class="xref" href="ch03s08s04.html#starting-java-with-the-command" title="3.8.4.6。�使用autrun命令启动Java AUT">Section�3.8.4.6，“使用<span class="emphasis"><em>autrun</em></span>命令启动Java AUT”</a> ）。
          </p></dd>
</dl></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="configuring-a-java-aut-ite-start"></a> 3.8.4.2。�配置从ITE启动的Java AUT</h4></div></div></div>
<p>Java的AUT配置对话框有三个不同的详细级别：基本，高级和专家。
    </p>
<p>有关不同级别的信息，请参阅以下部分。
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="basic-java-configuration"></a> 3.8.4.3。�BasicJavaAUT配置</h4></div></div></div>
<p>您可以使用基本设置（图<a class="xref" href="ch03s08s04.html#autconfigbasic" title="Figure�3.13.�AUTconfiguration window: basic">�3.13，“</a> AUT配置<a class="xref" href="ch03s08s04.html#autconfigbasic" title="Figure3.13。�AUT配置窗口：基本">窗口：基本”</a> ）来配置您的AUT，如果它可以由可执行文件（例如.bat，.exe，.cmd，.sh等）启动，如果它是用Java 1.5或更高版本编写的，您使用的是Java Standard Edition JRE。</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您正在测试RCP或GEF AUT，则需要采取某些特定步骤来配置它们。有关详细信息，请参阅有关RCP测试（ <a class="xref" href="../toolkit/ch04s03.html" title="4.3。�测试RCP AUT">章节�3.3，“测试RCP AUT”</a> ），GEF测试（ <a class="xref" href="../toolkit/ch04s04.html" title="4.4.�Testing GEF AUTs">章节�.4.4，“测试GEF AUT”</a> ）的<a class="xref" href="../toolkit/ch04s04.html" title="4.4。�测试GEF AUT">章节</a> 。
    </strong></span></td>
</tr></tbody>
</table>
<div class="figure">
<a name="autconfigbasic"></a><div class="figure-contents"><div class="mediaobject"><img src="../images/autconfigwindow_basic.png" xmlns:d="http://docbook.org/ns/docbook"></div></div>
<div class="figure-title">Figure3.13。�AUT配置窗口：基本</div>
</div>
<br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>如前所述输入基本配置详细信息（ <a class="xref" href="ch03s08s02.html" title="3.8.2。�每个AUT配置都需要基本信息">Section�3.8.2，“每个AUT配置所需的基本信息”</a> ）。
        </p></li>
<li class="listitem"><p>在“ <span class="emphasis"><em>可执行文件名”</em></span>字段中输入可执行文件名。如果定义工作目录<a class="xref" href="ch03s08s04.html#advanced-aut-config" title="3.8.4.4.�Advanced AUT configuration">，</a>则此路径可以是相对的（ <a class="xref" href="ch03s08s04.html#advanced-aut-config" title="3.8.4.4。�高级AUT配置">Section�3.8.4.4，“高级AUT配置”</a> ）。
        </p></li>
</ol></div>
<p>有关AUT配置的高级属性的信息，请参阅下一节（ <a class="xref" href="ch03s08s04.html#advanced-aut-config" title="3.8.4.4。�高级AUT配置">Section�3.8.4.4，“高级AUT配置”</a> ）。
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="advanced-aut-config"></a> 3.8.4.4。�高级AUT配置</h4></div></div></div>
<p>您可以使用高级对话框（图<a class="xref" href="ch03s08s04.html#autconfigadvanced" title="Figure3.14。�AUT配置窗口：高级">�3.14，“AUT配置窗口：高级”</a> ）为AUT创建工作目录，并添加启动AUT所需的命令行参数。您可以选择JRE可执行文件，对于SWT / RCP AUT，可以选择键盘布局。
    </p>
<div class="figure">
<a name="autconfigadvanced"></a><div class="figure-contents"><div class="mediaobject"><img src="../images/autconfigwindowadvanced.png" xmlns:d="http://docbook.org/ns/docbook"></div></div>
<div class="figure-title">Figure3.14。�AUT配置窗口：高级</div>
</div>
<br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>在“ <span class="emphasis"><em>可执行文件JAR文件名”</em></span>字段中输入JAR路径（目录和文件名）。
        </p>
<p>此路径可以是相对的（如果您定义工作目录（ <a class="xref" href="ch03s08s03.html" title="3.8.3。�在AUT配置中使用工作目录">Section�3.8.3，“在AUT配置中使用工作目录”</a> ））或绝对路径。此JAR文件必须包含清单文件，该文件包含主类和类路径。
        </p>
</li>
<li class="listitem"><p>在<span class="emphasis"><em>AUT Arguments</em></span>字段中输入<span class="emphasis"><em>AUT的</em></span>任何必要的命令行参数。
        </p></li>
<li class="listitem">
<p>浏览到JRE可执行文件或单击“ <span class="emphasis"><em>新建</em></span> ”添加新的可执行文件。使用的Java版本必须为1.5或更高版本。
        </p>
<p>Java与ITE一起安装。您可以在以下<span class="menupath">位置</span>找到Java文件： <span class="menupath">Jubula</span> - &gt; <span class="menupath">jre</span> - &gt; <span class="menupath">bin</span> 。如果要使用控制台，请使用java.exe，如果不需要控制台，请使用javaw.exe。
        </p>
</li>
<li class="listitem">
<p>对于SWT和RCP AUT，选择在将运行AUT的机器上使用的键盘布局。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>键盘布局不是连接到计算机的实际键盘，而是基于操作系统的区域语言设置。
        </strong></span></td>
</tr></tbody>
</table>
<p>英语（美国）和德语（DE）键盘布局支持开箱即用。如果要使用其他键盘布局，请参阅“开发人员手册”以获取有关创建键盘布局的信息。
        </p>
</li>
</ol></div>
<p>有关AUT配置的专家属性的信息，请参见下一节<a class="xref" href="ch03s08s04.html#expert-aut-config" title="3.8.4.5。�ExpertAUT配置">Section3.8.4.5“专家AUT配置”</a> 。
    </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="expert-aut-config"></a> 3.8.4.5。�ExpertAUT配置</h4></div></div></div>
<p>您可以使用专家对话框（图<a class="xref" href="ch03s08s04.html#autconfigexpert" title="Figure�3.15.�AUTconfiguration window: expert">�3.15，“</a> AUT配置<a class="xref" href="ch03s08s04.html#autconfigexpert" title="Figure3.15。�AUT配置窗口：专家">窗口：专家”</a> ）来配置有关如何启动AUT的更多详细信息。
    </p>
<div class="figure">
<a name="autconfigexpert"></a><div class="figure-contents"><div class="mediaobject"><img src="../images/errorHighlighting.png" xmlns:d="http://docbook.org/ns/docbook"></div></div>
<div class="figure-title">Figure3.15。�AUT配置窗口：专家</div>
</div>
<br class="figure-break"><div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>添加任何其他所需的<span class="emphasis"><em>JRE参数</em></span> 。
        </p></li>
<li class="listitem">
<p>输入任何所需的<span class="emphasis"><em>系统环境变量</em></span> ，格式为“ <span class="emphasis"><em>&lt;VARNAME&gt; = &lt;value&gt;</em></span> ”，即“<span class="emphasis"><em>路径= C：\</em></span> “。按<span class="input">�ENTER�</span>将每个变量用新行<span class="input">分开</span> 。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>请注意，目前不支持将一个变量的内容“嵌入”到另一个变量中。也就是说，如果你有一个名为<span class="input">FOO</span>的变量，其值为“ <span class="emphasis"><em>abc</em></span> ”，并将第二个变量<span class="input">BAR</span>的值设置为“ <span class="emphasis"><em>％FOO％def</em></span> ”，则第二个变量将<span class="emphasis"><em>不</em></span>包含“ <span class="emphasis"><em>abcdef</em></span> ”，而是包含确切的文本“ <span class="emphasis"><em>％FOO％def</em></span> “，未经评估。
        </strong></span></td>
</tr></tbody>
</table>
</li>
<li class="listitem"><p>选择AUT的激活方法。有关AUT激活的更多信息，请参见上一节第<a class="xref" href="ch03s08s01.html#aut-activation" title="3.8.1.1。�AUT激活">3.8.1.1节“AUT激活”</a> 。
        </p></li>
<li class="listitem"><p>如果要执行监视（代码覆盖率（ <a class="xref" href="ch03s28.html" title="3.28。�使用Java测试进行代码覆盖">Section�3.28，“使用Java测试代码覆盖率”</a> ），请从组合框中选择此项。
        </p></li>
<li class="listitem"><p>如果希望发生错误的组件在正在拍摄的屏幕截图中突出显示，请选中“ <span class="emphasis"><em>组件突出显示</em></span> ”复选框。（不适用于HTML AUT）</p></li>
</ol></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="starting-java-with-the-command"></a> 3.8.4.6。�使用<span class="emphasis"><em>autrun</em></span>命令启动Java AUT</h4></div></div></div>
<a name="starting-java-with-the-command.autSettingWizardPagePageContextId"></a><p><span class="emphasis"><em>autrun</em></span>命令可以用作从ITE启动AUT的替代方法。 （即使用AUT配置（ <a class="xref" href="ch03s08s01.html" title="3.8.1.�Configuring AUTs to be started from the ITE">Section�3.8.1，“配置从ITE启动</a> AUT <a class="xref" href="ch03s08s01.html" title="3.8.1。�配置要从ITE启动的AUT">”</a> ））。它只能在您使用Java 1.5或更高版本编写AUT并且使用Java Standard Edition JRE时使用。</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong><span class="emphasis"><em>autrun</em></span>命令不能用于HTML或纯SWT AUT。
    </strong></span></td>
</tr></tbody>
</table>
<p>该命令允许您在运行AUT代理的计算机上独立启动AUT。连接到此AUT代理时，ITE将识别正在运行的AUT作为可测试的应用程序。
    </p>
<p>要使用<span class="emphasis"><em>autrun</em></span>命令：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>确保AUT Agent已安装在要启动AUT的计算机上。</p></li>
<li class="listitem"><p>通过命令行导航到安装中的<span class="emphasis"><em>服务器</em></span>目录。
        </p></li>
<li class="listitem">
<p>通过Linux下的Windows或<span class="input">autrun</span>下进入<span class="input">autrun.exe</span>那么下面的参数启动通过命令行的AUT：</p>
<div class="table">
<a name="idm139858586703920"></a><div class="table-contents"><table border="1" summary="
            Parameters for autrun command
          ">
<colgroup>
<col width="40%" align="left">
<col align="left">
</colgroup>
<thead><tr>
<th align="left">
                  <span class="strong"><strong>详情</strong></span>
                </th>
<th align="left">
                  <span class="strong"><strong>参数</strong></span>
                </th>
</tr></thead>
<tbody>
<tr>
<td align="left">-H</td>
<td align="left">
                  <span class="input">-H</span><br xmlns:d="http://docbook.org/ns/docbook">提供参数帮助</td>
</tr>
<tr>
<td align="left">-w， <code class="literal">--</code> workingdir</td>
<td align="left">
                  <span class="input">-w &lt;directory&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入AUT的工作目录</td>
</tr>
<tr>
<td align="left">-a， <code class="literal">--</code> autagenthost</td>
<td align="left">
                  <span class="input">-a &lt;主机名&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入AUT代理的主机名</td>
</tr>
<tr>
<td align="left">-p， <code class="literal">--</code> autagentport</td>
<td align="left">
                  <span class="input">-p &lt;端口号&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入AUT代理的端口号</td>
</tr>
<tr>
<td align="left">-摇摆</td>
<td align="left">如果AUT是Swing AUT</td>
</tr>
<tr>
<td align="left">-rcp</td>
<td align="left">如果AUT是RCP AUT</td>
</tr>
<tr>
<td align="left">-swt</td>
<td align="left">如果AUT是SWT AUT</td>
</tr>
<tr>
<td align="left">-javafx</td>
<td align="left">如果AUT是JavaFX AUT</td>
</tr>
<tr>
<td align="left">-k， <code class="literal">--</code> kblayout</td>
<td align="left">
                  <span class="input">-k &lt;en_US&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入SWT / RCP AUT的键盘布局</td>
</tr>
<tr>
<td align="left">-i， <code class="literal">--</code> autid</td>
<td align="left">
                  <span class="input">-i &lt;ID&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入要提供给此AUT的ID</td>
</tr>
<tr>
<td align="left">-e， <code class="literal">--</code> exec</td>
<td align="left">
                  <span class="input">-e &lt;AUT.exe&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">输入AUT的可执行文件<br xmlns:d="http://docbook.org/ns/docbook">这必须是命令行中的最后一个参数</td>
</tr>
<tr>
<td align="left">-g， <code class="literal">--</code> generatenames（可选）</td>
<td align="left">
                  <span class="input">-g &lt;true / false&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">对于RCP AUT，请输入是否<br xmlns:d="http://docbook.org/ns/docbook">生成技术名称。（ <a class="xref" href="ch03s07.html" title="3.7。�定义测试中的应用程序（AUT）">Section�3.7，“定义被测试应用程序（AUT）”</a> ）</td>
</tr>
</tbody>
</table></div>
<div class="table-title">表3.1。auautrun命令的参数</div>
</div>
<br class="table-break">
</li>
</ol></div>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您的AUT是RCP AUT，请在可执行文件之后使用<span class="input">-data'&lt;WORKSPACE&gt;'</span>来指定AUT应使用的工作空间。
    </strong></span></td>
</tr></tbody>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="create-aut-def"></a> 3.8.4.7。�从正在运行的AUT中创建AUT定义</h4></div></div></div>
<p>使用<span class="emphasis"><em>autrun</em></span>命令启动AUT后，您可以自动<a class="xref" href="ch03s07.html" title="3.7.�Defining applications under test (AUTs)">为此</a> AUT生成AUT定义（ <a class="xref" href="ch03s07.html" title="3.7.�Defining applications under test (AUTs)">Section�3.7，“为测试中的应用程序</a>定义（AUT <a class="xref" href="ch03s07.html" title="3.7。�定义测试中的应用程序（AUT）">））”</a> ：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>在Running AUTs View中，选择要定义的AUT（它将被标记为未知的AUT ID）。
        </p></li>
<li class="listitem">
<p>选择：</p>
<p>
          <span class="menuPath">创建AUT定义</span>
        </p>
<p>从上下文菜单中。
        </p>
</li>
<li class="listitem"><p>将出现AUT定义窗口。完成对话框（ <a class="xref" href="ch03s07.html" title="3.7。�定义测试中的应用程序（AUT）">Section�3.7，“定义被测试的应用程序（AUT）”</a> ）并单击“ <span class="emphasis"><em>确定</em></span> ”。
        </p></li>
</ul></div>
</div>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="2160.s4.9.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s4.8.html" rel="prev">&lt;&lt;§4.8Callin优先权</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s4.10.html" rel="next">§4.10通用callin绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s4.html" rel="section">§4Callin绑定</a></div>
         <div class="sect depth2" id="s4.9">
            <h2 class="sect">§4.9Callin继承<a class="img" href="s4.9.html" title="PermaLinkto§4.9Callin继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <p>本节定义了callin绑定和callin方法如何与继承相关。
               		
            </p>
            <div class="sect depth3" id="s4.9.1">
               <h3 class="sect">§4.9.1基础侧继承<a class="img" href="s4.9.1.html" title="PermaLinkto§4.9.1基本侧继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4.9</a></span></h3>
               <p>通常，callin绑定会影响其绑定碱基的所有子类型。具体来说，如果绑定到基类型<code>B</code>的角色类型<code>R</code>定义了callin绑定<code>rm &lt;- <i>callin_modifier</i> bm</code> ，则以下规则适用：</p>
               <div class="subsect depth4" id="s4.9.1.a">
                  <h4 class="subsect">（a） <span class="title">对子类的影响</span><a class="img" href="s4.9.1.a.html" title="PermaLink（a）对子类的影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>callin绑定还影响作为<code>B</code>的子类型的任何类型<code>BSub</code>实例。如果<code>BSub</code>覆盖绑定的基本方法<code>bm</code> ， <code>BSub</code>覆盖的版本通常也会受到影响。但是，如果<code>bm</code>从其超级版本<a href="#s4.9.3.b" title="§4.9.3.(b) Capturing covariant base methods" class="sect">协同</a>重新定义返回类型，则callin绑定必须明确指定协变子类版本是否也应受到影响（参见<a href="#s4.9.3.b" title="§4.9.3。（b）捕获协变基方法" class="sect">§4.9.3。（b）</a> ）。
                     
                  </p>
               </div>
               <div class="subsect depth4" id="s4.9.1.b">
                  <h4 class="subsect">（b） <span class="title">对超级班级没有影响</span><a class="img" href="s4.9.1.b.html" title="PermaLink到（b）对超类没有影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>即使方法<code>bm</code>从超类继承或覆盖继承的方法，绑定也不会影响任何超类型<code>B</code>的实例。这确保了由于callin绑定而调度到角色方法总是提供至少具有在角色的<code>playedBy</code>子句中声明的类型的基本实例。
                     
                  </p>
               </div>
               <p>有关静态方法的相应定义，请参见<a href="s4.7.e.html" title="§4.7。（e）没有压倒一切" class="sect">§4.7。（e）</a> 。
                  			
               </p>
            </div>
            <div class="sect depth3" id="s4.9.2">
               <h3 class="sect">§4.9.2角色侧继承<a class="img" href="s4.9.2.html" title="PermaLinkto§4.9.2角色侧继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4.9</a></span></h3>
               <p><code>R</code>任何子类型都继承了给定的callin绑定（用于覆盖绑定，参见<a href="s4.8.e.html" title="§4.8。（e）绑定覆盖" class="sect">§4.8。（e）</a> ）。如果子角色覆盖角色方法<code>rm</code>则在触发callin绑定时将考虑动态分派。
                  
               </p>
            </div>
            <div class="sect depth3" id="s4.9.3">
               <h3 class="sect">§4.9.3协变返回类型<a class="img" href="s4.9.3.html" title="PermaLinkto§4.9.3协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§4.9</a></span></h3>
               <p>从版本5开始，Java支持对方法返回类型的协变重定义（参见<a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.4.5" class="ext">JLS 8.4.5</a> ）。<code>callin</code>方法<em>不</em>支持此功能（ <a href="#s4.9.3.a" title="§4.9.3。（a）没有协变的callin方法" class="sect">§4.9.3。（a）</a> ）。如果具有协同重新定义返回类型的基本方法将受到callin绑定的约束，则后续规则将确保保留类型安全性。必须考虑两个<em>限制</em>因素：</p>
               <ol>
                  <li>当callin方法发出基本调用或调用其tsuper版本时，此调用必须生成一个值，该类型的类型与封闭方法声明的返回类型兼容。
                     				
                  </li>
                  <li>如果替换绑定角色方法返回的值不是基本调用的结果，则必须确保返回值实际满足绑定基本方法的声明签名。
                     				
                  </li>
               </ol>
               <div class="subsect depth4" id="s4.9.3.a">
                  <h4 class="subsect">（a） <span class="title">没有协变的callin方法</span><a class="img" href="s4.9.3.a.html" title="永久链接到（a）没有协变的callin方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>使用<code>callin</code>修饰符声明的覆盖继承方法的方法不得重新定义与继承方法相关的返回类型。这反映了这样一个事实，即继承的callin绑定在绑定到新的重写角色方法时应保持类型安全。将协变角色方法绑定到原始基本方法将破坏上面的约束（1）。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s4.9.3.b">
                  <h4 class="subsect">（b） <span class="title">捕获协变基方法</span><a class="img" href="s4.9.3.b.html" title="PermaLink to（b）捕获协变基本方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果callin绑定确实不仅影响指定的基本方法，而且还覆盖了协同重新定义返回类型的覆盖版本，则绑定必须指定基本方法的返回类型，并在类型名称后附加“+”，如</p>
                  <div class="listing plain"><pre><b>void</b> rm（） <b>&lt; -</b> <b>在</b> <em>RT +</em> bm（）之前;</pre></div>
                  <p>没有“+”符号，绑定只会捕获其返回类型正好是<code>RT</code>基本方法;通过附加“+”，也接受<code>RT</code>子类型作为声明的返回类型。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s4.9.3.c">
                  <h4 class="subsect">（c） <span class="title">协变替换绑定</span><a class="img" href="s4.9.3.c.html" title="PermaLink到（c）协变替换绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>当使用<a href="#s4.9.3.b" title="§4.9.3。（b）捕获协变基方法" class="sect">§4.9.3。（b）</a>的语法在与<code>replace</code>修饰符的callin绑定中捕获具有协变返回类型的基本方法时，必须使用free类型参数指定role方法，如下所示：</p>
                  <div class="listing plain"><pre><em>&lt;E <b>extends</b> RT&gt; E</em> rm（） <b>&lt; -</b> <b>替换</b> RT + bm（）;</pre></div>
                  <p>此callin绑定引用的角色方法<code>rm</code>必须使用类型参数使用相同类型的返回类型。从这种方法返回的唯一可能的类型<code>E</code>非空值是base-call或tsuper-call提供的值。<br>此规则强制执行上面的约束（2）。<br>请注意，此规则在<a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10中</a>进一步概括。
                     				
                  </p>
                  <h5 class="listing">绑定参数角色方法</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>类</b> SuperBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>SuperBase foo（）{ <b>返回</b>此; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>    <b>void</b> check（）{System.out.print（“OK”）; }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre><b>公共</b> <b>类</b> SubBase <b>扩展</b> SuperBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>@覆盖</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>SubBase foo（）{ <b>return</b> this; }</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>    <b>void</b> print（）{System.out.print（“SubBase”）; }</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>字符串测试（）{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>。this.foo（）打印（）; <span class="comment">// print（）需要一个SubBase</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">14</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>班</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">15</td>
                           <td><pre>    <b>受保护的</b> <b>类</b> R <b>playingBy</b> SuperBase {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">16</td>
                           <td><pre>        <b>callin</b> &lt;E <b>extends</b> SuperBase&gt; E ci（）{</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">17</td>
                           <td><pre>E result = base.ci（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">18</td>
                           <td><pre>result.check（）; <span class="comment">//通过类型绑定的SuperBase在E上提供check（）</span></pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">19</td>
                           <td><pre>			<b>返回</b>结果;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">20</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">21</td>
                           <td><pre>&lt;E <b>extends</b> SuperBase&gt; E ci（） <b>&lt; -</b> <b>替换</b> SuperBase + foo（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">22</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">23</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>说明：</h5>
                     <ul>
                        <li>第7行中的方法<code>SubBase.foo</code>将返回类型从<code>SuperBase</code> （继承版本）重新定义为<code>SubBase</code> ，因此像第10行中的方法调用这样的客户端必须安全地假设返回值始终符合<code>SubBase</code> 。
                           						
                        </li>
                        <li>第21行中的callin绑定通过将<code>SuperBase+</code>指定为预期的返回类型，显式捕获了两个版本的<code>foo</code> 。因此，如果<code>MyTeam</code>的实例在第10行的方法调用中处于活动状态，则即使静态地知道此调用返回<code>SubBase</code>类型的值，也会截获对<code>foo</code>调用。
                           						
                        </li>
                        <li>第16-20行中的callin方法具有静态未知的返回类型，但返回类型由类型变量<code>E</code> 。由于已知基本调用具有与其封闭方法完全相同的签名，因此基本调用提供的值与<code>E</code>类型相同，因此可以从<code>ci</code>安全地返回。
                           							<em>注意，</em>没有其他非空值可以具有类型<code>E</code></li>
                        <li>通过指定<code>SuperBase</code>作为上界类型<code>E</code>的呼唤方法<code>ci</code>可以调用在类型中声明的任何方法<code>SuperBase</code>上类型的任何值<code>E</code> 。有关示例，请参阅第18行的<code>check</code>电话。
                           						
                        </li>
                     </ul>
                     <p><em>顺便指出，上述例子中使用类型<code>SuperBase</code>在散漫方式：角色内<code>R</code>此类型使用约束<code>playedBy</code> <strong>和</strong>相同类型也直接使用（作为上限<code>E</code> ）。这被认为是错误的样式，如果使用基本导入导入<code>SuperBase</code> ，则禁止使用它（ <a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ）。在这里，这个规则被忽略只是为了保持示例小。
                           						</em></p>
                  </div>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s4.8.html" rel="prev">&lt;&lt;§4.8Callin优先权</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s4.10.html" rel="next">§4.10通用callin绑定&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s4.html" rel="section">§4Callin绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="0752.org_eclipse_jdt_ui_quickAssistProcessors.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>快速辅助处理器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">快速辅助处理器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.jdt.ui.quickAssistProcessors<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点允许添加快速辅助处理器以在Java编辑器中提供新的快速辅助。此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.jdt.internal.ui.text.correction.ContributedProcessorDescriptor#matches(ICompilationUnit): -->默认变量是包含<code>org.eclipse.jdt.core.ICompilationUnit</code> 。
<br><code>&lt;with&gt;</code>表达式的定义变量是：<ul>
<li>“compilationUnit”：输入<code>org.eclipse.jdt.core.ICompilationUnit</code> ;应用快速辅助的编译单元（与默认变量相同）</li>
<li>“projectNatures”：输入<code>java.util.Collection&lt;String&gt;</code> ;当前项目的所有项目性质</li>
<li>“sourceLevel”：输入<code>java.lang.String</code> ;当前项目的源合规级别</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.quickAssistProcessor">quickAssistProcessor</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.quickAssistProcessor">quickAssistProcessor</a> （ <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST quickAssistProcessor</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">requiredSourceLevel CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 快速辅助处理器的唯一标识符</li>
<li><b>name</b> - 快速辅助处理器的本地化名称</li>
<li><b>class</b> - 实现此Quick Assist处理器的类的名称。该类必须是公共的并实现<samp>org.eclipse.jdt.ui.text.java。IQuickAssistProcessor</samp>与一个公共0参数构造函数。</li>
<li><b>requiredSourceLevel</b> - 一个可选属性，用于指定此处理器所需的最小源合规性</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是快速辅助处理器贡献的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.jdt.ui.quickAssistProcessors”</span> <span class="code SchemaTag">&gt; &lt;quickAssistProcessor id =</span> <span class="code SchemaCstring">“AdvancedQuickAssistProcessor”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“Advanced Quick Assist Processor”</span> <span class="code SchemaTag">requiredSourceLevel =</span> <span class="code SchemaCstring">“1.5”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.example。AdvancedQuickAssistProcessor“</span> <span class="code SchemaTag">&gt; &lt;/ quickAssistProcessor&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”projectNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with &gt; &lt;/ enablement&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献类必须实现<code>org.eclipse.jdt.ui.text.java.IQuickAssistProcessor</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0721.org_eclipse_jdt_core_manipulation_changeMethodSignatureParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>更改方法签名参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">更改方法签名参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.jdt.core.manipulation.changeMethodSignatureParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.4<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义更改方法签名重构参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是<code>org.eclipse.jdt.core.IMethod</code>要改变。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>org.eclipse.jdt.core.IMethod</code> ;要更改的方法（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.changeMethodSignatureParticipant">changeMethodSignatureParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.changeMethodSignatureParticipant">changeMethodSignatureParticipant</a> （ <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST changeMethodSignatureParticipant</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 更改方法签名参与者的唯一标识符。</li>
<li><b>name</b> - 更改方法签名参与者的人员可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。必须扩展<code>org.eclipse.jdt.core.refactoring.participants.ChangeMethodSignatureParticipant</code></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下示例定义了更改方法签名参与者。如果受重构影响的项目之一具有Java特性，并且要更改的方法是在JUnit测试中，则启用参与者。<pre class="Example"><span class="code SchemaTag">&lt;changeMethodSignatureParticipant id =</span> <span class="code SchemaCstring">“org.eclipse.example.myChangeMethodSignatureParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“My Change Method Signature Participant”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.example。MyChangeMethodSignatureParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.jdt.core。IType“</span> <span class="code SchemaTag">/&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.jdt.junit.isTest“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ changeMethodSignatureParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.jdt.core.refactoring.participants.ChangeMethodSignatureParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2007,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2776.org_eclipse_debug_ui_detailPaneFactories.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>细节窗格工厂扩展</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">细节窗格工厂扩展</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.debug.ui.detailPaneFactories<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.3<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点允许客户端在变量，寄存器，表达式和断点视图中为详细信息窗格提供自定义渲染（请注意，3.6中添加了对断点视图详细信息窗格的支持）。要提供自定义详细信息窗格，请使用此扩展点注册<code>IDetailPaneFactory</code>的实现。详细信息窗格工厂为每个自定义呈现创建<code>IDetailPane</code> （请注意，可选扩展已通过<code>IDetailPane2</code>和<code>IDetailPane3</code>添加到详细信息窗格）。
<p>具有详细窗格的视图允许用户通过上下文菜单从可用的详细信息窗格中进行选择。对当前选择的所有贡献都将检查此扩展点。详细信息工厂应提供启用表达式以确保延迟插件加载。如果工厂的表达式对当前选择的计算结果为true，则只会实例化该工厂（请参阅示例启用表达式的示例扩展点）。然后咨询每个适用的工厂，了解它可以为当前选择生成的详细窗格类型。
</p><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.detailFactories">detailFactories</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.detailFactories">detailFactories</a> （ <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST detailFactories</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 指定此工厂的唯一标识符</li>
<li><b>class</b> - 实现<code>org.eclipse.debug.ui.的类的完全限定名<code>org.eclipse.debug.ui.IDetailPaneFactory</code></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面是一个详细信息窗格工厂扩展的示例，其中包含一个表达式，该表达式允许包含两个Java变量的选择：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.debug.ui.detailPaneFactories”</span> <span class="code SchemaTag">&gt; &lt;detailFactories class =</span> <span class="code SchemaCstring">“org.eclipse.temp。JavaTableDetailPaneFactory“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”javaTableDetailPaneFactory“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”selection“</span> <span class="code SchemaTag">&gt; &lt;count value =</span> <span class="code SchemaCstring">”2“</span> <span class="code SchemaTag">&gt; &lt;/ count&gt; &lt;iterate&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.debug.core。IJavaVariable“</span> <span class="code SchemaTag">&gt; &lt;/ instanceof&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ detailFactories&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>属性<b>类的</b>值必须是实现接口<b>org.eclipse.debug.ui的Java类的完全限定名<b>。IDetailPaneFactory</b> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>调试平台提供详细信息窗格工厂，提供默认文本源查看器详细信息窗格。默认详细信息窗格根据相应的调试模型演示文稿的<code>computeDetail(IValue value, IValueDetailListener listener)</code>实现<code>computeDetail(IValue value, IValueDetailListener listener)</code>显示所选元素的文本详细信息。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2010 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3188.Text.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 文本</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">输入文字</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。文本</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Text.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Text.html#constructor">文字</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the fields documented in the class Text.">
          <caption>现场总结</caption>
          <thead>
            <tr>
              <th scope="col">字段属性</th>
              <th scope="col">字段名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Text.html#$input">$输入</a></b>
                </div>
                <div class="description"><a href="../symbols/%24.html">$</a>包装小部件HTML <code>input</code>元素的实例。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Text.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Text.html#getEditable">getEditable</a></b> （）</div>
                <div class="description">返回可编辑状态。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Text.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">返回一个数组，其第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Text.html#getText">getText</a></b> （）</div>
                <div class="description">返回小部件文本。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Text.html#setSelection">setSelection</a></b> （选择）</div>
                <div class="description">将选择设置为数组指定的范围，该数组的第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Text.html#setText">setText</a></b> （文本）</div>
                <div class="description">将接收器的内容设置为给定的字符串。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Text.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Text.html#event:Modify">修改</a></b>
                </div>
                <div class="description">更改窗口小部件文本时发送</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Text.html#event:Verify">校验</a></b>
                </div>
                <div class="description">在更改窗口小部件文本之前发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>文字</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      
        <div class="sectionTitle">现场细节</div>
        
          <a name="$input"> </a>
          <div class="fixedFont">

          
          <b>$输入</b>

          </div>
          <div class="description"><a href="../symbols/%24.html">$</a>包装小部件HTML <code>input</code>元素的实例。
            
          </div>

          

            
            
            
            

          
        
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getEditable"> </a>
          <div class="fixedFont">

          <span class="light">{boolean}</span> <b>getEditable</b> （）</div>
          <div class="description">返回可编辑状态。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{boolean}</span>接收者是否可编辑</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{int []}</span> <b>getSelection</b> （）</div>
          <div class="description">返回一个数组，其第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。“空”选择由相同的值表示。
<p>索引是基于零的。选择的范围是0 ..N其中N是小部件中的字符数。
</p>
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int []}</span>数组表示选择的开始和结束</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getText"> </a>
          <div class="fixedFont">

          <span class="light">{string}</span> <b>getText</b> （）</div>
          <div class="description">返回小部件文本。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{string}</span>小部件文本</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （选择）</div>
          <div class="description">将选择设置为数组指定的范围，该数组的第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。“空”选择由相同的值表示。
<p>索引是基于零的。选择的范围是0 ..N其中N是小部件中的字符数。
</p><p>文本选择根据插入符号位置指定。在包含N个字符的文本小部件中，有N + 1个插入符号位置，范围从0开始。N.这与解决字符位置的其他函数（例如使用常用数组索引规则的getText（））不同。
</p>
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{int []}</span> <b>选择</b>
                  
                </dt>
                <dd>表示选择开始和结束的数组</dd>
              
              </dl>
            
            
            
            
            
            
            

          <hr>
        
          <a name="setText"> </a>
          <div class="fixedFont">

          
          <b>setText</b> （文本）</div>
          <div class="description">将接收器的内容设置为给定的字符串。如果接收器具有样式SINGLE并且参数包含多行文本，则此操作的结果是未定义的，并且可能因平台而异。
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{string}</span> <b>文字</b>
                  
                </dt>
                <dd>新文本</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Modify"> </a>
          <div class="fixedFont">

          
          <b>修改</b>

          </div>
          <div class="description">更改窗口小部件文本时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Modify">SWT.Modify</a></dd>
              
              </dl>
            

          <hr>
        
          <a name="event:Verify"> </a>
          <div class="fixedFont">

          
          <b>校验</b>

          </div>
          <div class="description">在更改窗口小部件文本之前发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Verify">SWT.Verify</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="3677.emf_tutorial_define_metamodel.html" dir="ltr"></html><html dir="ltr">
<head>
<title>定义EMF元模型</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="Xpand Documentation"></link>
<link rel="up" href="emf_tutorial.html" title="Getting Started"></link>
<link rel="prev" href="emf_tutorial_overview.html" title="Tutorial overview"></link>
<link rel="next" href="emf_tutorial_generate_emf_tooling.html" title="Generating the EMF tooling"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">定义EMF元模型</h1>
<div class="section" title="定义EMF元模型">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="emf_tutorial_define_metamodel"></a>定义EMF元模型</h2>
</div>
</div>
</div>
<p>为了说明元模型，在我们处理EMF的复杂性之前，这里是UML中的元模型：</p>
<div class="figure">
<a name="emf_tutorial_sample_metamodel"></a>
<p class="title">
<b>图1。示例元模型</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/emf_tutorial/metamodel.gif" alt="示例元模型">
</div>
</div>
</div>
<p>
<br class="figure-break">
</p>
<div class="section" title="创建EMF项目">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="emf_tutorial_creating_emf_project"></a>创建EMF项目</h3>
</div>
</div>
</div>
<p>创建一个EMF项目，如下所示：</p>
<div class="figure">
<a name="emf_tutorial_create_emf_project"></a>
<p class="title">
<b>图2。创建EMF项目</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/emf_tutorial/create_emf_project.png" alt="创建EMF项目">
</div>
</div>
</div>
<br class="figure-break">
<p>创建EMF项目非常重要，而不仅仅是简单项目或Java项目。将其命名为<code class="filename">xpand.demo.emf.datamodel</code> 。</p>
</div>
<div class="section" title="定义（meta）模型">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="emf_tutorial_defining_metamodel"></a>定义（meta）模型</h3>
</div>
</div>
</div>
<p>在该项目中创建一个新的源文件夹<code class="filename">metamodel</code> 。然后，在名为<code class="filename">data.ecore</code>源文件夹中创建一个新的Ecore模型。使用<span class="type">EPackage</span>作为模型对象。</p>
<div class="figure">
<a name="emf_tutorial_create_ecore_model"></a>
<p class="title">
<b>图3。创建新的Ecore模型</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/emf_tutorial/create_ecore_model.png" alt="创建新的Ecore模型">
</div>
</div>
</div>
<p>
<br class="figure-break">这将打开Ecore编辑器。您将看到名为<code class="varname">null</code>的根包。打开“属性视图”（上下文菜单）。为包设置以下属性：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>名称：数据</p>
</li>
<li class="listitem">
<p>Ns前缀：数据</p>
</li>
<li class="listitem">
<p>Ns URI：http：//www.xpand.org/xpand.demo.emf.datamodel</p>
</li>
</ul>
</div>
<p> </p>
<div class="figure">
<a name="emf_tutorial_adjust_namespace_settings"></a>
<p class="title">
<b>图4。调整命名空间设置</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/emf_tutorial/create_ecore_model_adjust_namespace.png" alt="调整命名空间设置">
</div>
</div>
</div>
<p>
<br class="figure-break">
</p>
<p>创建以下Ecore模型。 <sup>[ <a href="#ftn.N100A4" name="N100A4" class="footnote">1</a> ]</sup>确保<span class="emphasis"><em>完全</em></span>按照下面的描述设置以下属性：</p>
<p>在<span class="package">数据</span>包中，使用它们的属性创建这些<code class="classname">EClass</code>元素： <sup>[ <a href="#ftn.N100B6" name="N100B6" class="footnote">2</a> ]</sup>
</p>
<div class="informaltable">
<a name="emf_tutorial_metamodel_attributes"></a>
<table cellspacing="0" cellpadding="10" style="border-collapse:collapse;border-bottom:0.5pt solid">
<colgroup>
<col align="left">
<col align="left">
<col align="left">
</colgroup>
<thead>
<tr>
<th align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">EClass名称</th>
<th align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">EAttribute名称</th>
<th align="left" style="border-bottom:2 solid #000000">EAttribute EType</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">的DataModel</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">名称</td>
<td align="left" style="border-bottom:2 solid #000000">为EString</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">实体</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">名称</td>
<td align="left" style="border-bottom:2 solid #000000">为EString</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">属性</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">名称</td>
<td align="left" style="border-bottom:2 solid #000000">为EString</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">类型</td>
<td align="left" style="border-bottom:2 solid #000000">为EString</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">的EntityReference</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">名称</td>
<td align="left" style="border-bottom:2 solid #000000">为EString</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000">太多</td>
<td align="left">EBoolean</td>
</tr>
</tbody>
</table>
</div>
<p>现在，是时候在模型元素之间创建引用了。添加<code class="classname">EReferences</code>类型的子<code class="classname">EReferences</code>如下： <sup>[ <a href="#ftn.N1010E" name="N1010E" class="footnote">3</a> ]</sup>
</p>
<div class="informaltable">
<a name="emf_tutorial_metamodel_references"></a>
<table cellspacing="0" cellpadding="10" width="100%" style="border-collapse:collapse;border-bottom:0.5pt solid">
<colgroup>
<col align="left">
<col align="left">
<col align="left">
<col align="left">
</colgroup>
<thead>
<tr>
<th align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">的EClass</th>
<th align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">EReference名称</th>
<th align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">EReference属性名称</th>
<th align="left" style="border-bottom:2 solid #000000">EReference属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">的DataModel</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">实体</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">ETYPE</td>
<td align="left" style="border-bottom:2 solid #000000">实体</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">遏制</td>
<td align="left" style="border-bottom:2 solid #000000">真正</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">下界</td>
<td align="left" style="border-bottom:2 solid #000000">0</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">UPPERBOUND</td>
<td align="left" style="border-bottom:2 solid #000000">-1</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">实体</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">属性</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">ETYPE</td>
<td align="left" style="border-bottom:2 solid #000000">属性</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">遏制</td>
<td align="left" style="border-bottom:2 solid #000000">真正</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">下界</td>
<td align="left" style="border-bottom:2 solid #000000">1</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">UPPERBOUND</td>
<td align="left" style="border-bottom:2 solid #000000">-1</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">实体</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">参考</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">ETYPE</td>
<td align="left" style="border-bottom:2 solid #000000">的EntityReference</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">遏制</td>
<td align="left" style="border-bottom:2 solid #000000">真正</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">下界</td>
<td align="left" style="border-bottom:2 solid #000000">0</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">UPPERBOUND</td>
<td align="left" style="border-bottom:2 solid #000000">-1</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">的EntityReference</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">目标</td>
<td class="auto-generated" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td class="auto-generated" style="border-bottom:2 solid #000000"> </td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">ETYPE</td>
<td align="left" style="border-bottom:2 solid #000000">实体</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">遏制</td>
<td align="left" style="border-bottom:2 solid #000000">假</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000;border-bottom:2 solid #000000">下界</td>
<td align="left" style="border-bottom:2 solid #000000">1</td>
</tr>
<tr>
<td align="left" style="border-right:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000"> </td>
<td align="left" style="border-right:2 solid #000000">UPPERBOUND</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
</div>
<div class="figure">
<a name="emf_tutorial_metamodel_structure"></a>
<p class="title">
<b>图5。元模型结构</b>
</p>
<div class="figure-contents">
<div class="mediaobject">
<img src="images/emf_tutorial/create_ecore_model_mm_structure.png" alt="元模型结构">
</div>
</div>
</div>
<p>
<br class="figure-break">
</p>
<p>EMF将我们在上面创建的模型保存在自己的XMI方言中<a name="N101D9" class="indexterm"></a> 。为避免任何歧义，这里是元模型的完整XMI源。它进入文件<code class="filename">data.ecore</code> ：</p>
<pre class="programlisting">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;ecore：EPackage xmi：version =“2.0”xmlns：xmi =“http://www.omg.org/XMI”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance” xmlns：ecore =“http://www.eclipse.org/emf/2002/Ecore”name =“data”nsURI =“http://www.xpand.org/xpand.demo.emf.datamodel”nsPrefix =“ data“&gt; &lt;eClassifiers xsi：type =”ecore：EClass“name =”DataModel“&gt; &lt;eStructuralFeatures xsi：type =”ecore：EAttribute“name =”name“eType =”ecore：EDataType http：//www.eclipse。 org / emf / 2002 / Ecore＃// EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”entity“upperBound =” -  1“eType =”＃// Entity“containment =”true“/ &gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =“ecore：EClass”name =“Entity”&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“name”eType =“ecore：EDataType http：// www。 eclipse.org/emf/2002/Ecore#// EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”attribute“lowerBound =”1“upperBound =” -  1“eType =”＃// Attribute “containment =”true“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EReference“name =”reference“upperBound =” -  1“eType = “＃// EntityReference”containment =“true”/&gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =“ecore：EClass”name =“Attribute”&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“name” eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString”/&gt; &lt;eStructuralFeatures xsi：type =“ecore：EAttribute”name =“type”eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString“/&gt; &lt;/ eClassifiers&gt; &lt;eClassifiers xsi：type =”ecore：EClass“name =”EntityReference“&gt; &lt;eStructuralFeatures xsi：type =” ecore：EAttribute“name =”name“eType =”ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EString“/&gt; &lt;eStructuralFeatures xsi：type =”ecore：EAttribute“name = “toMany”eType =“ecore：EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean”/&gt; &lt;eStructuralFeatures xsi：type =“ecore：EReference”name =“target”lowerBound =“ 1“eType =”＃//实体“/&gt; &lt;/ eClassifiers&gt; &lt;/ ecore：EPackage&gt;</pre>
</div>
<div class="footnotes">
<br>
<hr align="left" width="100">
<div class="footnote">
<p>
<sup>[ <a href="#N100A4" name="ftn.N100A4" class="para">1</a> ]</sup>要添加子项，请右键单击要添加这些子项的元素，然后从列表中选择子项的类型。要配置属性，请通过选择任何上下文菜单底部的“ <span class="guimenu">显示属性视图”</span>打开属性对话框。请注意，这不是EMF教程。有关如何构建EMF（元）模型的更多详细信息，请参阅EMF文档。</p>
</div>
<div class="footnote">
<p>
<sup>[ <a href="#N100B6" name="ftn.N100B6" class="para">2</a> ]</sup>属性是<code class="classname">EAttribute</code>类型的子类。请填写<span class="property">名称</span>和<span class="property">EType</span>属性。</p>
</div>
<div class="footnote">
<p>
<sup>[ <a href="#N1010E" name="ftn.N1010E" class="para">3</a> ]</sup>注意：有几个<span class="emphasis"><em>-1的</em></span> ...不要错过减号！此外，收容标志是必不可少的。如果包含为<code class="literal">true</code>您将能够创建引用类型的子项，否则您只能引用它们。</p>
</div>
</div>
</div>
</body>
</html><html id="2893.org_eclipse_ui_genericeditor_hoverProviders.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>悬停提供商</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">悬停提供商</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.genericeditor.hoverProviders<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于提供悬停提供程序，以便在具有给定内容类型的文件中显示文本悬停。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.hoverProvider">hoverProvider</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.hoverProvider">hoverProvider</a> （ <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST hoverProvider</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">contentType IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">isBefore IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">是IDREF #IMPLIED&gt;之后</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 唯一标识此引用提供程序的字符串。</li>
<li><b>class</b> - 实现接口<code>org.eclipse.jface.text.的完全限定类名<code>org.eclipse.jface.text.ITextHover</code></li>
<li><b>contentType</b> - 此扩展的目标内容类型。内容类型被定义为org.eclipse.core.contenttype.contentTypes扩展点的扩展。</li>
<li><b>isBefore</b> - <b>hoverProvider</b>的id，在此之前放置此贡献。计划是根据该值对贡献进行排序，并且仅显示第一个（或第一个“可复合”的）</li>
<li><b>isAfter</b> - <b>hoverProvider</b>的id，然后放置此贡献。计划是根据该值对贡献进行排序，并且仅显示第一个（或第一个“可复合”的）</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定悬停提供程序的启用。查看器，编辑器和编辑器输入在评估上下文中注册为变量：* <with variable="viewer"></with> ：如果您的表达式需要查看器，请使用它。* <with variable="document"></with> ：如果您的表达式需要文档，请使用它。* <with variable="editor"></with> ：如果表达式需要编辑器，则使用它（不建议使用，不要总是设置）。* <with variable="editorInput"></with> ：如果表达式需要编辑器输入（不建议使用，并不总是设置），请使用它。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是使用悬停提供程序扩展点的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.hoverProviders”</span> <span class="code SchemaTag">&gt; &lt;hoverProvider class =</span> <span class="code SchemaCstring">“org.eclipse.ui.genericeditor.examples。TargetDefinitionHoverProvider“</span> <span class="code SchemaTag">contentType =</span> <span class="code SchemaCstring">”org.eclipse.pde.targetFile“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”editor“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.ui.genericeditor.examples。TargetDefinitionPropertyTester“</span> <span class="code SchemaTag">&gt; &lt;/ test&gt; &lt;/ with&gt; &lt;/ enabledWhen&gt; &lt;/ hoverProvider&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2016 Red Hat Inc.及其他本程序及随附材料均按照此发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/</a>获取。 <a href="https://www.eclipse.org/legal/epl-2.0">epl-v20.html</a> / SPDX-License-Identifier：EPL-2.0</p>
</body>
</html><html id="2834.org_eclipse_ltk_core_refactoring_renameParticipants.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>重命名参与者</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">重命名参与者</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ltk.core.refactoring.renameParticipants<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于定义重构重命名参与者。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.ltk.core.refactoring.participants.ParticipantExtensionPoint#createEvaluationContext(..): -->默认变量是要重命名的元素。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“element”：输入<code>java.lang.Object</code> ;要重命名的元素（与默认变量相同）</li>
<li>“affectedNatures”：输入<code>java.util.List&lt;String&gt;</code> ;受重构影响的所有项目的性质</li>
<li>“processorIdentifier”：输入<code>java.lang.String</code> ;将拥有参与者的重构处理器的ID</li>
</ul><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.renameParticipant">renameParticipant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.renameParticipant">renameParticipant</a> （ <a href="#e.param">param</a> *， <a href="#e.enablement">enablement</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST重命名参与者</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 重命名参与者的唯一标识符。</li>
<li><b>name</b> - 重命名参与者的人类可重用名称</li>
<li><b>class</b> - 提供参与者实现的类的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.param">param</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST param</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 附加参数的名称</li>
<li><b>value</b> - 附加参数的值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>下面的示例定义了一个参与类型重命名的重命名参与者。如果受重构影响的项目之一具有Java特性，并且要重命名的类型是JUnit测试，则启用参与者。<pre class="Example"><span class="code SchemaTag">&lt;renameParticipant id =</span> <span class="code SchemaCstring">“org.eclipse.jdt.junit.renameTypeParticipant”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“％RenameTypeParticipant.name”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.jdt.internal.junit.ui。TypeRenameParticipant“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”affectedNatures“</span> <span class="code SchemaTag">&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.javanature“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;with variable =</span> <span class="code SchemaCstring">“element”</span> <span class="code SchemaTag">&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">“org.eclipse.jdt.core。IType“</span> <span class="code SchemaTag">/&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.jdt.junit.isTest“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ renameParticipant&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.ltk.core.refactoring.participants.RenameParticipant</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2001,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0742.org_eclipse_jdt_ui_classpathFixProcessors.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>类路径修复处理器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">类路径修复处理器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.jdt.ui.classpathFixProcessors<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.4<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点允许添加处理器，以便在无法解析类型时为不完整的类路径提供修复。

<p>此扩展点支持<code>&lt;enablement&gt;</code>元素。
<!-- see org.eclipse.jdt.internal.ui.text.correction.ClasspathFixProcessorDescriptor#matches(IJavaProject): -->默认变量是包含<code>org.eclipse.jdt.core.IJavaProject</code> 。
<br><code>&lt;with&gt;</code>表达式的定义变量是：</p>
<ul>
<li>“project”：输入<code>org.eclipse.jdt.core.IJavaProject</code> ;当前项目（与默认变量相同）</li>
<li>“sourceLevel”：输入<code>java.lang.String</code> ;当前项目的源合规级别</li>
</ul>处理器可以指定覆盖另一个处理器。当覆盖处理器返回<code>null</code>作为提议时，仅要求被覆盖的处理器提供提议。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.classpathFixProcessor">classpathFixProcessor</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.classpathFixProcessor">classpathFixProcessor</a> （ <a href="#e.enablement">enablement</a> ？， <a href="#e.overrides">overrides</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST classpathFixProcessor</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -  Classpath Fix处理器的唯一标识符</li>
<li><b>name</b> -  Classpath Fix处理器的本地化名称</li>
<li><b>class</b> - 实现此Classpath Fix处理器的类的名称。该类必须是public并扩展<samp>org.eclipse.jdt.ui.text.java。带有公共0参数构造函数的ClasspathFixProcessor</samp> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.overrides">覆盖</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST覆盖</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 由当前处理器覆盖的classspath修复处理器的id。当前处理器可以选择替换扩展处理器的提议。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是Classpath Fix处理器贡献的示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.jdt.ui.classpathFixProcessors”</span> <span class="code SchemaTag">&gt; &lt;classpathFixProcessor id =</span> <span class="code SchemaCstring">“MyClasspathFixProcessor”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“My Classpath Fix Processor”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.example。MyClasspathFixProcessor“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">”project“</span> <span class="code SchemaTag">&gt; &lt;test property =</span> <span class="code SchemaCstring">”org.eclipse.jdt.core.isInJavaProjectWithNature“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”org.eclipse.pde。PluginNature“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;覆盖id =</span> <span class="code SchemaCstring">”org.eclipse.jdt.ui.text.correction。DefaultClasspathFixProcessor“</span> <span class="code SchemaTag">&gt; &lt;/ overrides&gt; &lt;/ classpathFixProcessor&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>贡献的类必须扩展<code>org.eclipse.jdt.ui.text.java.ClasspathFixProcessor</code>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2007,2013 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html>