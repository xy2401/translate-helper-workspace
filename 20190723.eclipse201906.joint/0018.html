<html id="3338.Aird_Editor.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Aird_Editor</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="AirdEditor">Aird编辑</h1>
		<p>本文档介绍了5.0版中引入的<code>aird</code>文件的基于表单的新编辑器。此编辑器与<code>*.aird</code>文件（包含Sirius表示数据）相关联，并为最终用户提供其模型和表示的完整概述，以及直接访问最常见的操作。
		</p>
		<p>本文假设您已经熟悉与Sirius相关的词汇;如果不是这种情况，请参阅<a href="Modeling Project.html">建模项目文档</a> ，该<a href="Modeling Project.html">文档</a>详细描述了更“传统”的Sirius UI及相关概念。
		</p>
		<p>
			<em>注意：</em> Sirius 5.0引入了这个新的编辑器。虽然它已经正常运行，但它应该被视为第一次迭代，并且其UI可能会根据经验和用户反馈在更高版本中发布而不会发出警告。
		</p>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#AirdEditor">Aird编辑</a>
				<ol style="list-style:disc">
					<li>
						<a href="#overview">概观</a>
					</li>
					<li>
						<a href="#opening">打开Aird编辑器</a>
					</li>
					<li>
						<a href="#closing">关闭Aird编辑器并卸载模型</a>
					</li>
					<li>
						<a href="#semantic_models">管理语义模型</a>
						<ol style="list-style:disc">
							<li>
								<a href="#LoadinganExistingModel">加载现有模型</a>
							</li>
							<li>
								<a href="#model_creation_wizard">创建新模型</a>
							</li>
							<li>
								<a href="#removing_model">从Aird编辑器中删除模型依赖关系和表示</a>
							</li>
							<li>
								<a href="#removing_representation">从Aird编辑器中删除表示</a>
							</li>
							<li>
								<a href="#quick_editing">模型快速编辑</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#representations">管理表示和观点</a>
						<ol style="list-style:disc">
							<li>
								<a href="#visualize_viewpoints_representations">可视化视点和表示</a>
							</li>
							<li>
								<a href="#enable_disable_viewpoints">启用和禁用视点</a>
							</li>
							<li>
								<a href="#create_remove_representations">创建和删除表示</a>
							</li>
							<li>
								<a href="#open_representation">从代表处打开Sirius Modeler</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="overview">概观</h2>
		<p>传统的Sirius UI以<em>Modeling</em>透视图为中心，特别是在<em>Model Explorer</em>视图中。对于某些用例，特别是当Sirius表示不是用户的主要关注点而只是支持其主要任务的辅助功能时，这种对特定视角或视图的依赖可能是不方便的。Aird编辑器旨在提供与Sirius交互的替代UI，更适合这些用例。由于编辑器可从任何角度使用，并直接在其UI中公开最常见的用户操作，因此在各种上下文中使用Sirius更加方便。
		</p>
		<p>请注意，aird编辑器提供的大多数功能也可以从<em>Model Explorer</em>的UI中获得;编辑器只是提供了使用它们的替代方法，在某些情况下可以更方便。有两个例外，下面将详细介绍，目前特定于Aird编辑器：通用<a href="#model_creation_wizard">模型创建向导</a>以及<a href="#quick_editing">直接</a>从语义模型<a href="#quick_editing">添加/删除元素的功能</a> 。
		</p>
		<p>使用Sirius显示和操作您的域模型需要告诉Sirius：</p>
		<ul>
			<li>哪些是您感兴趣的模型（文件）;</li>
			<li>您想要使用哪种兼容的表示类型。</li>
		</ul>
		<p>表示类型在扩展Sirius的插件中定义，您需要在您的环境中安装。哪些可供您使用取决于您已安装的具体建模器。基于Sirius的建模者可以为相同的语义模型提供许多替代表示类型，并在<em>视点中</em>组织它们，这对应于可以应用于模型的不同活动或视点。
		</p>
		<p>该组织反映在编辑器中，该编辑器提供了两个主要块：</p>
		<p>
			<img border="0" src="images/aird_editor_full.png">
		</p>
		<p>在左侧， <em>Models</em>块显示原始语义模型，它可以来自多个文件（资源），并允许您配置应加载哪些模型，在其中导航，执行一些基本编辑任务，最后创建并管理Sirius对他们的陈述。
		</p>
		<p>在右侧，“ <em>表示”</em>块显示可用的所有表示类型以及已创建的所有具体表示形式，按视点组织（默认情况下）。它还允许您管理表示和视点。您可以使用的表示类型取决于您已加载的模型类型以及您在环境中安装的建模器插件。例如，如果您已经安装了<a href="http://www.umldesigner.org/">UML Designer</a> <strong>并且</strong>至少加载了一个<code>*.uml</code>模型，那么您会发现在<em>UML Designer中</em>实现了不同类型的UML图。
		</p>
		<h2 id="opening">打开Aird编辑器</h2>
		<p>Aird编辑器是与Eclipse中<code>*.aird</code>文件关联的默认编辑器。在某些视角（例如<em>Java</em> ）中，双击<code>aird</code>文件将打开编辑器并自动加载所需的所有文件/模型（如果不是这种情况）。在双击执行不同操作的其他上下文中，您可能需要打开上下文菜单并选择<i>打开方式&gt; Aird Editor</i> 。
		</p>
		<p>当首次加载<code>*.aird</code>文件时，也可以将Sirius配置为自动打开Aird编辑器。启用此模式后，从<em>模型资源管理器中</em>打开/展开<em>建模项目</em> （触发模型的加载）也将打开编辑器。可以通过Sirius首选项启用此行为<strong><i>当加载播放文件时自动打开播出编辑器</i></strong> ：</p>
		<p>
			<img border="0" src="images/aird_editor_pref.png">
		</p>
		<p>激活此首选项后，在以下情况下会自动打开aird编辑器：</p>
		<ul>
			<li>单击“ <i>创建建模项目”</i>向导的“ <i>完成”</i>按钮后，将<i>创建项目</i>及其播放文件。新创建的播放文件将在编辑器中自动打开。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_modeling_project_creation_wizard.png">
		</p>
		<ul>
			<li>当从<i>Model Explorer</i>或<i>Project Explorer</i>打开具有<em>建模</em>特性的<i>项目时</i> ，如果空中编辑器包含主要文件，则它也会自动打开。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_open_project_modeling_explorer.png">
		</p>
		<ul>
			<li>当Aird文件首次从<i>Model Explorer</i>或<i>Project Explorer</i>视图中具有<em>Modeling</em>属性的项目展开时，aird编辑器也会自动打开。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_expand_aird_file.png">
		</p>
		<h2 id="closing">关闭Aird编辑器并卸载模型</h2>
		<p>您有四种不同的方式可以关闭播出的编辑器。但并非所有方式都有相同的行为。</p>
		<p>关闭播出的编辑器有一点需要考虑：</p>
		<ul>
			<li>打开的aird编辑器将所有引用的模型加载到内存中，以及在Sirius编辑器中打开的任何表示。对于大型模型和大型表示，这可能会占用大量内存。因此，当你想要关闭播出的编辑器时，你必须问自己是否要释放被加载的空闲或不使用的内存。然后你必须选择正确的方式关闭编辑器。确实，某种关闭编辑器的方法不会释放这种记忆而其他一些人会这样做。</li>
		</ul>
		<p>不卸载模型和表示的关闭机制如下：</p>
		<ul>
			<li>单击编辑器选项卡右上角的编辑器白色十字。这将仅关闭播出的编辑器，并且不会释放由Sirius编辑器中打开的已加载模型和表示所使用的内存。</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_close_editor_with_cross.png">
		</p>
		<p>从内存中卸载模型和表示的关闭机制如下：</p>
		<ul>
			<li>如果您的播出编辑器引用<em>建模项目中</em>的播出文件，则从内存中卸载模型和表示的唯一方法是关闭它。
			</li>
		</ul>
		<ul>
			<li>如果您的播出编辑器没有引用<em>建模项目中</em>的播放文件，则编辑器会提供一个按钮<em>卸载模型</em> ，并允许关闭播放的编辑器以及加载的模型和表示所使用的空闲内存。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_close_editor_with_button.png">
		</p>
		<ul>
			<li>如果播出编辑器不在<em>建模项目中</em> ，则可以使用播出文件的上下文菜单中的<em>关闭</em>操作。在任何视图中都可以看到此操作，如同<em>模型资源管理器</em> ， <em>包资源管理器</em>等一样将其视为IFile ...
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_close_editor_with_right_click.png">
		</p>
		<h2 id="semantic_models">管理语义模型</h2>
		<p>本节介绍如何管理与播放文件关联的语义模型，这些<em>模型</em>在编辑器左侧的“ <em>模型”</em>块中可见：</p>
		<p>
			<img border="0" src="images/aird_editor_models_block.png">
		</p>
		<p><em>模型</em>块显示一个树，显示与播出文件关联的所有语义模型，分为两类：</p>
		<ul>
			<li>位于同一工作空间项目中的模型与包含已打开编辑器的播出文件的模型相同。这些在图形树上作为根项可见。</li>
		</ul>
		<ul>
			<li>位于项目中的模型与包含已打开编辑器的aird文件的项目不同。这些模型在<em>Project Dependencies</em>类别下可见。
			</li>
		</ul>
		<p>例如：</p>
		<p>
			<img border="0" src="images/aird_editor_model_loading.png">
		</p>
		<p>无论它们出现在哪个类别中，与aird文件关联的所有语义模型都已完全加载，您可以展开树元素以在模型内导航。可以使用顶部的搜索框在元素标签上过滤树，以快速定位特定的模型元素：</p>
		<p>
			<img border="0" src="images/aird_editor_filter_models_elements.png">
		</p>
		<p>除了实际的语义元素之外，该视图还包括所有现有的表示（图表，表格，树）。与<em>Model Explorer</em>的情况一样，表示在它们所代表的语义元素的正下方可用，并且可以通过双击它们来打开。
		</p>
		<h3 id="LoadinganExistingModel">加载现有模型</h3>
		<p>为了能够使用Sirius建模器编辑语义模型，您必须先告诉aird它可以编辑该模型。有两种机制可以这样做：</p>
		<ul>
			<li>如果您的项目具有<em>建模</em>性质，则自动添加项目中的任何模型文件都将自动添加到aird文件中。
			</li>
			<li>手动一个是编辑器中有两个不同的按钮：<ul>
					<li><strong><i>新...</i>
						</strong>按钮，打开一个向导，允许从任何已注册的包和所需的任何项目中创建新模型（有关向导的更多详细信息，请参阅下一节）。新创建的模型将自动加载到aird文件中。
					</li>
					<li>“ <strong><i>添加”</i></strong>按钮，允许从同一项目或另一个项目中加载已存在的模型。
					</li>
				</ul>
			</li>
		</ul>
		<p>请注意，您只需将模型文件从工作空间（从任何Eclipse视图）拖放到编辑器左侧的<em>Models</em>块中，即可向会话添加新的语义模型。
		</p>
		<h3 id="model_creation_wizard">创建新模型</h3>
		<p>aird编辑器具有通用模型创建向导，可用于创建环境中支持的任何类型的新模型文件（即任何已安装的元模型的实例）。要创建新模型，请选择“ <i>新建...”</i>按钮。它打开一个创建向导：</p>
		<ul>
			<li>第一页要求您选择要创建的模型类型。它将向您显示安装中可用的所有EMF元模型（例如UML或BPMN）。您可以使用文本字段在所有可用的元模型中进行过滤（在大型安装中，可能有数百个）。</li>
		</ul>
		<p>
			<img border="0" src="images\aird_editor_create_new_model.png">
		</p>
		<ul>
			<li>选择元模型后，第二个页面会询问新模型文件中根元素的类型。默认情况下，Sirius会尝试推断出这个根元素类型的优秀候选者，并仅显示那些。您可以取消选中“ <em>仅显示建议的根类型”</em>复选框，以显示您选择的元模型中定义的<strong>所有</strong>具体类型。
			</li>
			<li>最后，向导的第三页将询问您要创建的新文件的名称和位置。默认情况下，该文件将在与<code>aird</code>文件相同的项目中创建，并具有生成的名称。
			</li>
		</ul>
		<h3 id="removing_model">从Aird编辑器中删除模型依赖关系和表示</h3>
		<p>要删除<strong>模型依赖项</strong> ，必须选择根模型项并单击“ <strong><i>删除”</i></strong>按钮：</p>
		<p>
			<img border="0" src="images/aird_editor_remove_semantic_model.png">
		</p>请注意，此操作不会删除物理模型文件。
		<p>只有在遵守某些规则的情况下才能应用删除。如果不是，则删除按钮仍将处于活动状态，并且其激活将告知您无法继续删除的原因。</p>
		<p>有关模型依赖性删除的规则如下：</p>
		<ul>
			<li>如果至少有一个元素包含表示，则无法删除模型依赖项。请注意，如果未启用提供它的视点，则表示可以是不可见的。</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_remove_semantic_model_representation.png">
		</p>
		<ul>
			<li>如果您在具有<em>建模</em>特性的项目内部工作且语义模型位于此项目内，则无法删除模型依赖关系。实际上， <em>建模</em>特性可确保项目中存储的所有模型文件始终加载到项目的<code>aird</code>文件中。
			</li>
		</ul>
		<ul>
			<li>如果模型依赖项是模型的片段，则无法将其删除。在这种情况下，您需要使用<strong><i>Uncontrol</i></strong>操作将其删除。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_remove_semantic_model_uncontrol.png">
		</p>
		<h3 id="removing_representation">从Aird编辑器中删除表示</h3>
		<p>要从aird文件中删除<strong>表示</strong> ，您可以在编辑器中选择它并使用右键单击上下文操作<strong><i>Delete</i></strong>或<strong><i>DEL</i></strong>键盘键。
		</p>
		<h3 id="quick_editing">模型快速编辑</h3>
		<p>使用Sirius显示和编辑模型的常规方法是通过一个或多个Sirius定义的表示（ <em>建模器</em> ）来完成，这些表示定义了特定于域的方式来表示和操作数据，并确保一定程度的一致性。
		</p>
		<p>在某些情况下，您可能需要更直接地操作模型元素，即使没有定义基于Sirius的建模器或工具来支持您的用例。<em>aird编辑器</em>支持独立于Sirius表示的语义模型的“快速编辑”。它像任何通用的EMF模型编辑器一样工作：</p>
		<ul>
			<li>您可以右键单击语义元素以在其中创建新子项，或将其删除。</li>
			<li>选择元素后，可以使用“ <em>属性”</em>视图编辑其功能。请注意，此视图的内容取决于当前启用的<em>视点</em> 。如果已启用为元素定义特定属性视图的视点，则将使用这些视图而不是通用视图，因此并非所有直接模型操作都可用。
			</li>
		</ul>
		<p>请记住，以这种方式编辑语义模型会绕过Sirius建模者可能带来的任何高级限制和规则。根据语义模型，这些直接操作可能会破坏域约束。小心使用。</p>
		<h2 id="representations">管理表示和观点</h2>
		<p>要使用Sirius建模器编辑模型元素，您需要为其创建图形表示。然后可以使用Sirius建模器来编辑此表示，该建模器可以是图表，树或表格编辑器。具体表示是从<em>表示类型</em>创建的，由基于Sirius的建模者提供，并由<em>视点</em>组织。
		</p>
		<p>除了提供可以从中创建表示的表示类型之外，视点还可以为其他视点的表示类型提供扩展，例如向它们添加新工具。</p>
		<p>以下部分描述了如何创建/删除表示和相关功能。</p>
		<h3 id="visualize_viewpoints_representations">可视化视点和表示</h3>
		<p>aird编辑器有一个名为<em>Representation</em>的块，它显示所有可用的视点（与加载的语义模型兼容），它们定义的表示类型以及已创建的实际具体表示。所有这些元素都组织在树中：</p>
		<p>
			<img border="0" src="images/aird_editor_representations_block.png">
		</p>
		<p>此<em>表示</em>块分为两部分：</p>
		<ul>
			<li>左边是显示视点及其表示类型（显示其包含的表示数）和表示的树。</li>
			<li>右侧部分显示所选元素的视点的文档。它允许查找哪些视点提供表示类型，提供符合您需要的Sirius建模器功能，以图形方式编辑模型。</li>
		</ul>
		<p>这两个部分的底部是两个复选框，可用于控制显示哪些元素：</p>
		<ul>
			<li>
				<strong><i>按视点分组表示</i></strong> ：当激活（默认）时，视点项目显示在树中。取消激活时，仅显示表示类型及其表示。
			</li>
			<li>
				<strong><i>显示禁用的视点</i></strong> ：激活（默认）时，将显示应用于当前加载的语义元素的<strong>所有</strong>可用视点（及其内容），即使它们当前已禁用。这在启动新项目时非常有用，因为它立即显示了您可以使用的所有功能，即使您尚未启用任何功能。一旦启用了所需的视点，您可能希望隐藏其他视点以帮助您集中注意力。
			</li>
		</ul>
		<p>如果禁用，则视点将变灰。否则，它在aird文件中启用。</p>
		<p>显示的视点是您的环境中可用的所有视点，这些视点与aird文件中加载的模型兼容。因此，如果您的环境不包含与模型兼容的任何视点，或者如果未加载模型，则图形表示组件将为空。</p>
		<p>如果包含用于创建表示的表示类型的视点被激活，则还可以在相关模型元素下的空中编辑器的模型图形组件中直接看到表示。如果不是，则表示将不可见。</p>
		<p>
			<img border="0" src="images/aird_editor_rep_under_model.png">
		</p>
		<p>要打开现有的表示，只需双击它（这在“ <em>表示”</em>树和“ <em>语义”</em>树中都有效）。
		</p>
		<h3 id="enable_disable_viewpoints">启用和禁用视点</h3>
		<p>视点为其他表示类型提供表示类型和/或扩展。在某些情况下，您需要禁用这些扩展带来的功能，或者相反启用它们。</p>
		<p>要启用/禁用视点，您可以：</p>
		<ul>
			<li>双击播出编辑器的表示图形组件上的视点项。它将根据其当前状态启用或禁用视点。</li>
			<li>选择一个或多个视点后使用“ <strong><i>启用</i></strong> <strong><i>禁用”</i></strong>按钮。
			</li>
			<li>创建在先前禁用的视点中定义的新表示。它将激活相应表示类型的视点。</li>
		</ul>
		<p>一些观点与另一观点有依赖关系。启用视点将自动启用其所有依赖项。禁用作为另一个视图的依赖关系的视点将要求您确认其禁用以及取决于它的视图。</p>
		<h3 id="create_remove_representations">创建和删除表示</h3>
		<p>在确定了提供所需Sirius建模功能的表示类型后，可以使用三种方法从中创建新表示，并使用模型元素编辑其内容：</p>
		<ul>
			<li>首先，您可以从aird编辑器的表示图形组件中双击表示类型。它将打开“ <strong><i>创建新表示</i></strong>向导”。然后，您必须选择与将从中创建新表示的描述兼容的模型元素。
			</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_create_rep_double_click.png">
		</p>
		<ul>
			<li>其次，您可以单击播出编辑器的表示图形组件的“ <strong><i>新建”</i></strong>按钮。如果您在选择模型元素之前首先选择要从中创建表示的表示类型，则会打开向导。
			</li>
		</ul>
		<ul>
			<li>最后一种方法是使用上下文菜单操作右键单击模型图形组件中的模型元素时可用的<strong><i>新表示</i></strong> ：</li>
		</ul>
		<p>
			<img border="0" src="images/aird_editor_new_rep_menu.png">
		</p>
		<p>菜单仅显示与所选模型元素兼容且属于激活视点的表示类型。选择<strong><i>其他时......</i>
			</strong>打开创建新表示的向导，并显示与所选元素兼容的表示类型，无论它们属于激活还是取消激活的视点。如果创建在先前禁用的视点中定义的表示，则会自动启用它。
		</p>
		<p>您可以通过以下方式从aird编辑器的表示或模型图形组件中<em>删除</em>表示：</p>
		<ul>
			<li>使用表示的上下文菜单中的“ <i>删除”</i>操作;</li>
			<li>当在那里选择要删除的表示时，使用表示块的<i>删除</i>按钮;</li>
			<li>选择表示并按<i>Del</i>键。
			</li>
		</ul>
		<h3 id="open_representation">从代表处打开Sirius Modeler</h3>
		<p>要打开表示以图形方式编辑与之关联的模型元素，您只需在aird编辑器的模型或表示图形组件中双击它即可。</p>
		<p>如果双击“ <em>表示”</em>块中属于禁用视点的表示，则在打开表示之前将自动启用此视点。
		</p>
	</body>
</html><html id="3313.extensions-provide_custom_style.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>扩展 -  provide_custom_style</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SiriusProvidecustomstyle">天狼星 - 提供定制风格</h1>
		<h2 id="Goals">目标</h2>
		<p>Sirius提供了设计和显示图表的工具。这些图基本上由不同风格的图组成<br>和形状，即使工具最初允许使用各种样式，许多图表仍然需要<br>定制的款式符合公司的主题。
		</p>
		<p>Sirius提供了三种不同的自定义图形样式的方法：</p>
		<ol>
			<li><code>StyleConfiguration</code>扩展点。
			</li>
			<li><code>CustomStyle</code>以及<code>EditPartProvider</code> GMF扩展点。
			</li>
			<li>GMF提供的扩展点。</li>
		</ol>
		<h2 id="StyleConfiguration">StyleConfiguration</h2>
		<p>StyleConfiguration是一种可以自定义特定样式的机制。它旨在为不同的人提供支持<br>显示标签，锚点，...的方式
		</p>
		<h3 id="TheStyleConfigurationinterface">StyleConfiguration接口</h3>
		<p>此接口定义了一组需要实现的方法，以便可以自定义syle：</p>
		<ul>
			<li>
				<code>void adaptNodeLabel（DNode node，WrapLabel nodeLabel）</code>
			</li>
			<li>
				<code>BorderItemLocatorProvider getBorderItemLocatorProvider（）</code>
			</li>
			<li>
				<code>IBorderItemLocator getNameBorderItemLocator（DNode节点，IFigure mainFigure）</code>
			</li>
			<li>
				<code>int adaptViewNodeSizeWithLabel（DNode viewNode，WrapLabel nodeLabel，int nodeWidth）</code>
			</li>
			<li>
				<code>AnchorProvider getAnchorProvider（）</code>
			</li>
			<li>
				<code>Image getLabelIcon（DDiagramElement元素）</code>
			</li>
			<li>
				<code>Dimension fitToText（DNode节点，WrapLabel nodeLabel，DefaultSizeNodeFigure defaultSizeNodeFigure）</code>
			</li>
		</ul>
		<h4 id="adaptNodeLabel">adaptNodeLabel</h4>
		<p>该方法可用于根据给定节点改变给定标签的大小和位置。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>viewNode</code> ：节点表示。
					</li>
					<li>
						<code>nodeLabel</code> ：节点的标签。
					</li>
				</ul>
			</li>
		</ul>
		<h4 id="getBorderItemLocatorProvider">getBorderItemLocatorProvider</h4>
		<p>此方法返回当前为节点提供边框项定位符的实例。边框项是位于另一个节点边界上的节点。</p>
		<h4 id="getNameBorderItemLocator">getNameBorderItemLocator</h4>
		<p>此方法返回节点标签的项目定位器。如果标签的位置不是<code>BORDER</code>则此方法无意义。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>node</code> ：节点表示。
					</li>
					<li>
						<code>mainFigure</code> ：表示节点的Draw2D图。
					</li>
				</ul>
			</li>
		</ul>
		<h4 id="adaptViewNodeSizeWithLabel">adaptViewNodeSizeWithLabel</h4>
		<p>此方法返回节点需要使用其标签正确显示的最小宽度。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>viewNode</code> ：节点表示。
					</li>
					<li>
						<code>nodeLabel</code> ：节点的标签。
					</li>
					<li>
						<code>nodeWidth</code> ：节点的当前宽度。
					</li>
				</ul>
			</li>
		</ul>
		<h4 id="getAnchorProvider">getAnchorProvider</h4>
		<p>此方法返回提供连接锚点的实例。</p>
		<h4 id="getLabelIcon">getLabelIcon</h4>
		<p>此方法返回将为此元素的表示显示的图标。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>vpElement</code> ：我们需要一个图标的元素。
					</li>
				</ul>
			</li>
		</ul>
		<h4 id="fitToText">fitToText</h4>
		<p>此方法返回节点的最佳维度。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>node</code> ：节点表示。
					</li>
					<li>
						<code>nodeLabel</code> ：节点的标签。
					</li>
					<li>
						<code>defaultSizeNodeFigure</code> ：节点的draw2d表示。
					</li>
				</ul>
			</li>
		</ul>
		<h3 id="ProvidingcustomStyleConfiguration">提供自定义StyleConfiguration</h3>
		<p><code>StyleConfiguration</code>机制目前仅适用于<code>ViewNode</code> 。默认配置最初安装在节点上。
		</p>
		<p>
			<b>SimpleStyleConfiguration</b>
		</p>
		<p>此配置是最简单的实现。</p>
		<p>
			<b>SquareStyleConfiguration</b>
		</p>
		<p>这是使用具有方形形状的<code>BundledImage</code>样式的节点的最小配置。
		</p>
		<p>
			<b>SimpleSquareStyleConfiguration</b>
		</p>
		<p>这是具有<code>Square</code>样式的节点的最小配置。
		</p>
		<h4 id="ProvidersofStyleConfiguration">StyleConfiguration的提供者</h4>
		<p>可以通过<code>org.eclipse.sirius.diagram.styleConfigurationProvider</code>扩展来安装您自己的配置<br>点。此扩展点只需要一个属性：提供程序类的限定名称。
		</p>
		<pre><code>&lt;extension point =“org.eclipse.sirius.diagram.styleConfigurationProvider”&gt; &lt;styleConfigurationProvider providerClass =“com.example.diagseq.style。DiagSeqStyleConfigurationProvider“/&gt; &lt;/ extension&gt;</code></pre>
		<p>以下是填写此扩展点时PDE编辑器的扩展选项卡示例：</p>
		<p>
			<img border="0" src="./images/style/styleConfigurationProviderExt.png">
		</p>
		<p>此示例将<code>DiagSeqStyleConfigurationProvider</code>记录为配置提供程序。这个类必须实现<br>
			<code>IStyleConfigrationProvider</code>接口。
		</p>
		<p>后一个接口定义了两种方法：</p>
		<p>
			<strong>
				<code>boolean提供（DiagramElementMapping映射，样式样式）</code>
			</strong>
		</p>
		<p>如果提供程序为给定的映射和样式提供配置，则此方法返回true。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>mapping</code> ：节点的映射。
					</li>
					<li>
						<code>style</code> ：节点的样式。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<strong>
				<code>StyleConfiguration createStyleConfiguration（DiagramElementMapping映射，样式样式）</code>
			</strong>
		</p>
		<p>此方法为指定的映射和样式创建StyleConfiguration。</p>
		<ul>
			<li>参数<ul>
					<li>
						<code>mapping</code> ：节点的映射。
					</li>
					<li>
						<code>style</code> ：节点的样式。
					</li>
				</ul>
			</li>
		</ul>
		<p>以下是提供商的示例：</p>
		<pre><code>public class DiagSeqStyleConfigurationProvider实现IStyleConfigurationProvider {public StyleConfiguration createStyleConfiguration（DiagramElementMapping mapping，Style style）{if（mapping instanceof NodeMapping）{NodeMapping nodeMapping =（NodeMapping）mapping; if（nodeMapping.getName（）！= null &amp;&amp; nodeMapping.getName（）。equals（DiagSeqConstants。INSTANCE_ROLE_MAPPING_NAME））{return new InstanceRoleStyleConfiguration（）; if（nodeMapping.getName（）！= null &amp;&amp; nodeMapping.getName（）。equals（DiagSeqConstants。EXECUTION_MAPPING_NAME））{return new ExecutionSpecificationStyleConfiguration（）;返回null; public boolean提供（DiagramElementMapping映射，样式样式）{返回映射instanceof NodeMapping &amp;&amp;（（NodeMapping）映射）.getName（）！= null &amp;&amp;（（（NodeMapping）mapping）.getName（）。equals（DiagSeqConstants。INSTANCE_ROLE_MAPPING_NAME）|| DiagSeqConstants。EXECUTION_MAPPING_NAME.equals（（（NodeMapping）mapping）.getName（）））; }}</code></pre>
		<h3 id="ExampleofaStyleConfigurationimplementation">StyleConfiguration实现的示例</h3>
		<pre><code>public class SimpleStyleConfiguration实现StyleConfiguration {public void adaptNodeLabel（DNode node，WrapLabel nodeLabel）{if（nodeLabel.getParent（）！= null）{Rectangle constraint = nodeLabel.getParent（）。getBounds（）。getCopy（）; insets borderDimension = this.getBorderDimension（node）; constraint.height  -  =（borderDimension.top + borderDimension.bottom）; constraint.width  -  =（borderDimension.left + borderDimension.right）; constraint.x + = borderDimension.left; constraint.y + = borderDimension.top; nodeLabel.setBounds（约束）; nodeLabel.getParent（）。setConstraint（nodeLabel，constraint）; public int adaptViewNodeSizeWithLabel（DNode viewNode，WrapLabel nodeLabel，int nodeWidth）{if（viewNode.getResizeKind（）！= ResizeKind。NONE_LITERAL）{}返回nodeWidth; } public AnchorProvider getAnchorProvider（）{return null; public ObjectItemLocatorProvider getBorderItemLocatorProvider（）{return DefaultBorderItemLocatorProvider.getInstance（）; public IBorderItemLocator getNameBorderItemLocator（DNode node，IFigure mainFigure）{BorderItemLocator locator = new AirBorderItemLocator（mainFigure，PositionConstants。NSEW）; locator.setBorderItemOffset（new Dimension（1,1））;返回定位器; public Image getLabelIcon（DDiagramElement vpElement）{EObject target = vpElement; if（vpElement instanceof DSemanticDecorator）{target =（（DSemanticDecorator）vpElement）.getTarget（）; } if（isShowIcon（vpElement））{if（target！）= null）{IItemLabelProvider labelProvider =（IItemLabelProvider）SiriusDiagramEditorPlugin.getInstance（）。getItemProvidersAdapterFactory（）。adapt（target，IItemLabelProvider.class）; if（labelProvider！= null）{ImageDescriptor descriptor = ExtendedImageRegistry.getInstance（）。getImageDescriptor（labelProvider.getImage（target））; if（descriptor == null）{descriptor = ImageDescriptor.getMissingImageDescriptor（）;返回SiriusDiagramEditorPlugin.getInstance（）。getImage（descriptor）;返回null; } protected boolean isShowIcon（DDiagramElement vpElement）{if（vpElement instanceof MappingBased）{DiagramElementMapping vpElementMapping =（（MappingBased）vpElement）。getMapping（）; if（vpElementMapping instanceof NodeMapping）{return（（NodeMapping）vpElementMapping）.isShowIcon（）; } if（vpElementMapping instanceof EdgeMapping）{return（（EdgeMapping）vpElementMapping）.isShowIcon（）; } if（vpElementMapping instanceof ContainerMapping）{return true;返回false; public Dimension fitToText（DNode node，WrapLabel nodeLabel，DefaultSizeNodeFigure defaultSizeNodeFigure）{if（nodeLabel.getFont（）！= null）{String text = node.getName（）; int charHeight = FigureUtilities.getStringExtents（“ABCDEF”，nodeLabel.getFont（））。height + 5; int charWidth = FigureUtilities.getTextWidth（“ABCDEFGHIJKLMNOPQRSTUVWXYZ”，nodeLabel.getFont（））/ 26; double ratio = charHeight / charWidth; int nbLines =（int）（Math.sqrt（text.length（））/ ratio）+ 1; int nbCols =（int）（Math.sqrt（text.length（））* ratio）+ 1; int longestWord = this.getTheLongestWord（text.split（“\\ s”））; nbCols = Math.max（nbCols，longestWord）; int hHeight = nbLines * charHeight; int hWidth = nbCols * charWidth; Dimension size = nodeLabel.getPreferredSize（hWidth + nodeLabel.getIconBounds（）。width + nodeLabel.getIconTextGap（），hHeight）.getCopy（）; size.width + = 20; size.height + = 30; insets borderDimension = this.getBorderDimension（node）; size.width + =（borderDimension.left + borderDimension.right）; size.height + =（borderDimension.top + borderDimension.bottom）; // //方形？if（node.getHeight（）。intValue（）== node.getWidth（）。intValue（））{// size.width = Math.max（size.height，size.width）; // size.height = Math.max（size.height，size.width）;返回大小; } return defaultSizeNodeFigure.getBounds（）。getSize（）。getCopy（）; private int getTheLongestWord（String [] strings）{int max = -1; for（int i = 0; i &lt;strings.length; i ++）{if（strings [i] .length（）&gt; max）{max = strings [i] .length（）;返回最大值; } / ** *返回边框的尺寸。* * @param nodeth * view node。* @return边框的尺寸。* / public Insets getBorderDimension（DNode node）{return new Insets（0,0,0,0）; }}</code></pre>
		<p>实现自己的配置的最简单方法是使其成为<code>SimpleStyleConfiguration</code>的子类。
		</p>
		<h2 id="GMFextensionpointsCustomStyleandEditPartProvider">GMF扩展点，CustomStyle和EditPartProvider</h2>
		<p>
			<code>CustomStyle</code>是一种可应用于节点的样式。它唯一的属性是<code>id</code> ，它是一个字符串值。默认情况下，<br>应用CustomStyle将显示绿色方块。描述节点外观的自定义<code>EditPart</code><br>必须实施。
		</p>
		<p>以下是如何应用<code>CustomStyle</code> ：</p>
		<p>
			<img border="0" src="./images/style/customStyle.png">
		</p>
		<p>下一步是创建并记录<code>EditPart</code>以定义此样式的管理方式。
		</p>
		<p><code>EditPart</code>是GEF类。它引用了模型元素和表示它的形状。GMF为GEF增加了一层<br>并公开自己的<strong>EditPart</strong> API。此API的基本类型是<code>IGraphicalEditPart</code> （在包中<br>
			<code>org.eclipse.gmf.runtime.diagram.ui.editparts</code> ）。以下是此接口定义的主要方法：</p>
		<ul>
			<li>
				<code>EObject resolveSemanticElement()</code> ：此方法返回编辑部分的语义元素。此语义元素的类型是Sirius包所包含的类型（请参阅<code>SiriusPackage</code> ）。例如，如果我们要为<code>CustomStyle</code>编写<code>EditPart</code> ，则语义元素将是所述<code>CustomStyle</code> 。可以使用它获取ViewNode，然后获取目标元素。
			</li>
			<li>
				<code>View getNotationView()</code> ：此方法返回编辑部分的GMF视图。这是将保存到GMF图表中的视图。
			</li>
		</ul>
		<p>所有自定义样式编辑部件都必须实现<code>IStyleEditPart</code>接口。在语义上，样式编辑部件不应该是可选的：当选择包含它的Shape或Connector时，它会被选中。因此， <strong>所有自定义样式编辑部件都应覆盖<code>isSelectable()</code>方法并返回false</strong> 。如果可以，从已经正确覆盖此方法的抽象类<code>AbstractNotSelectableShapeNodeEditPart</code>继承。如果你想让Sirius控制你的自定义节点，你也应该覆盖<code>createDefaultEditPolicies</code> ，因为它是在提供的Sirius样式编辑部分中完成的：样式部分负责样式/图形方面，而其父部分将主要控制其政策的行为。否则，您需要正确添加策略以覆盖默认的GMF策略，添加您自己的特定策略或Sirius策略。
		</p>
		<p>以下是自定义样式编辑部分的示例：</p>
		<pre><code>公共类InstanceRoleStyleEditPart extends AbstractNotSelectableShapeNodeEditPart实现IStyleEditPart {/ ** *内容窗格。* / protected IFigure contentPane; / ** *主要形状。* / protected ImageFigure primaryShape; / ** *创建一个新的{@link ChangingImageEditPart}。* * @param view *视图。* / public InstanceRoleStyleEditPart（View view）{super（view）; public DragTracker getDragTracker（请求请求）{return getParent（）。getDragTracker（request）; } protected NodeFigure createNodeFigure（）{NodeFigure figure = createNodePlate（）; figure.setLayoutManager（new XYLayout（））; IFigure shape = createNodeShape（）; figure.add（形状）; contentPane = setupContentPane（shape）;返回数字; } private NodeFigure createNodePlate（）{DefaultSizeNodeFigure result = new AirStyleDefaultSizeNodeFigure（getMapMode（）。DPtoLP（40），getMapMode（）。DPtoLP函数（40））;返回结果; } / ** *创建实例角色图。* * @return创建的数字。* / protected ImageFigure createNodeShape（）{if（primaryShape == null）{primaryShape = new ImageFigure（）; } return primaryShape; } / ** *返回实例角色图。* * @return实例角色图。* / public ImageFigure getPrimaryShape（）{return primaryShape; } / ** *默认实现将传递的数字视为内容窗格。尊重*布局可能已为生成的数字设置。* * @param nodeShape *生成的图类的实例* @return图* / protected IFigure setupContentPane（IFigure nodeShape）{return nodeShape; //使用nodeShape本身作为contentPane} public IFigure getContentPane（）{if（contentPane！= null）{return contentPane; } return super.getContentPane（）; } protected void refreshVisuals（）{CustomStyle customStyle =（CustomStyle）this.resolveSemanticElement（）; if（customStyle.eContainer（）instanceof DNode）{this.getPrimaryShape（）。setImage（SiriusPlugin.getDefault（）。getBundledImage（（（DNode）customStyle.eContainer（））。getName（）））; protected void createDefaultEditPolicies（）{//为空。}}</code></pre>
		<p>我们现在必须通知Sirius我们正在为具有该id的CustomStyle的节点提供新的<code>EditPart</code> 。
			<br>GMF扩展机制可用于实现此目的。
		</p>
		<p>plugin.xml中：</p>
		<p>
			<img border="0" src="./images/style/editPartProvider_plugin1.png">
		</p>
		<pre><code>&lt;extension point =“org.eclipse.gmf.runtime.diagram.ui.editpartProviders”&gt; &lt;editpartProvider class =“com.example.diagseq.provider。DiagSeqEditPartProvider“&gt; &lt;优先级名称=”高“/&gt; &lt;/ editpartProvider&gt; &lt;/ extension&gt;</code></pre>
		<p>提供程序类（ <code>com.example.diagseq.provider.DiagSeqEditPartProvider</code> ）扩展了GMF类<br>
			<code>org.eclipse.gmf.runtime.diagram.ui.services.editpart。AbstractEditPartProvider</code> 。我们的自定义编辑部分将是<br>由覆盖<code>getNodeEditPartClass</code>提供。这是这个类的样子：</p>
		<pre><code>公共类DiagSeqEditPartProvider扩展AbstractEditPartProvider {public DiagSeqEditPartProvider（）{super（）; } @Override protected class getNodeEditPartClass（View view）{if（view.getElement（）instanceof CustomStyle）{CustomStyle customStyle =（CustomStyle）view.getElement（）; if（customStyle.getId（）。equals（DiagSeqConstants。INSTANCE_ROLE_STYLE_ID））{return InstanceRoleStyleEditPart.class;返回super.getNodeEditPartClass（view）; }}</code></pre>
		<p><code>DiagSeqConstants.INSTANCE_ROLE_STYLE_ID</code>是我们自定义样式的ID。
		</p>
		<p>在建模器中，结果如下所示：</p>
		<p>
			<img border="0" src="./images/style/instanceRole.png">
		</p>
		<h2 id="GMFextensionpoints">GMF扩展点</h2>
		<p>GMF公开了所有必要的API以扩展建模者的默认行为。</p>
		<ul>
			<li>编辑零件提供者。</li>
			<li>编辑策略提供者。</li>
			<li>布局提供者</li>
		</ul>
		<h3 id="EditPartProvider">编辑零件供应商</h3>
		<p>我们之前看到过如何提供自定义编辑部分。以下是Sirius的结果。</p>
		<p>Sirius元模型的快照：</p>
		<p>
			<img border="0" src="./images/style/viewpoint.jpg">
		</p>
		<p>DNode，DNodeContainer，DNodeList，DNodeListElement等类型都有自己的编辑部分：</p>
		<p>
			<img border="0" src="./images/style/editParts.jpg">
		</p>
		<h3 id="EditPolicyProvider">编辑策略提供者</h3>
		<p>编辑策略是负责处理用户操作的对象。有针对不同行为的编辑策略：</p>
		<ul>
			<li>创建</li>
			<li>删除</li>
			<li>移动元素</li>
			<li>选择</li>
			<li>等等</li>
		</ul>
		<p>与编辑部分一样，有必要编写编辑策略提供程序以及要提供的编辑策略。该<br>编辑策略提供程序必须实现<code>IEditPolicyProvider</code>接口：</p>
		<ul>
			<li>
				<code>public void addProviderChangeListener(IProviderChangeListener listener)</code> ：在提供程序上注册侦听器。
			</li>
			<li>
				<code>public boolean provides(IOperation operation)</code> ：如果此实例为指定的操作提供编辑策略，则返回true。
			</li>
			<li>
				<code>public void removeProviderChangeListener(IProviderChangeListener listener)</code> ：从此提供程序中删除侦听器。
			</li>
			<li>
				<code>public void createEditPolicies(EditPart editPart)</code> ：在指定的编辑部件上添加编辑策略。
			</li>
		</ul>
		<p>以下是编辑策略提供程序的示例</p>
		<pre><code>/ ** *为注释附件提供编辑策略。* / public class AirNoteAttachmentEditPolicyProvider实现IEditPolicyProvider {/ **属性更改支持。* /私人名单听众; / ** *创建一个新的{@link AirNoteAttachmentEditPolicyProvider}。* / public AirNoteAttachmentEditPolicyProvider（）{this.listeners = new ArrayList（2）; public void createEditPolicies（EditPart editPart）{if（editPart instanceof NoteAttachmentEditPart）{editPart.installEditPolicy（EditPolicy。CONNECTION_ROLE，新的AirNoteAttachmentEditPolicy（））; public void addProviderChangeListener（IProviderChangeListener listener）{this.listeners.add（listener）; public boolean提供（IOperation操作）{if（操作instanceof CreateEditPoliciesOperation）{CreateEditPoliciesOperation castedOperation =（CreateEditPoliciesOperation）操作; EditPart editPart = castedOperation.getEditPart（）;对象模型= editPart.getModel（）; if（model instanceof View）{View view =（View）model; if（view.getDiagram（）！= null &amp;&amp; view.getDiagram（）。getElement（）！= null &amp;&amp; view.getDiagram（）。getElement（）。eClass（）。getEPackage（）。getNsURI（）。equals（ViewpointPackage.eINSTANCE.getNsURI（）））{if（“NoteAttachment”.equals（view.getType（） ））{return true;返回false; public void removeProviderChangeListener（IProviderChangeListener listener）{this.listeners.remove（listener）; } / ** *触发{@link ProviderChangeEvent}。* / protected void fireProviderChanged（）{ProviderChangeEvent event = new ProviderChangeEvent（this）; Iterator iterListener = this.listeners.iterator（）; while（iterListener.hasNext（））{IProviderChangeListener listener =（IProviderChangeListener）iterListener.next（）; listener.providerChanged（事件）; }}}</code></pre>
		<p>通过编写抽象提供程序可以实现更大的灵活性：</p>
		<pre><code>public abstract class AbstractEditPolicyProvider实现IEditPolicyProvider {/ **所有监听器。* / private List listeners = new ArrayList（1）; public void addProviderChangeListener（IProviderChangeListener listener）{this.listeners.add（listener）; public void removeProviderChangeListener（IProviderChangeListener listener）{this.listeners.remove（listener）; } protected void fireProviderChanged（）{ProviderChangeEvent event = new ProviderChangeEvent（this）; Iterator iterListener = this.listeners.iterator（）; while（iterListener.hasNext（））{IProviderChangeListener listener =（IProviderChangeListener）iterListener.next（）; listener.providerChanged（事件）; }}}</code></pre>
		<p>目前仅剩覆盖的方法<code>provides()</code>和<code>createEditPolicies()</code>在此提供的实现。
		</p>
	</body>
</html><html id="2275.DebuggerTutorial.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>调试器教程</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="Tutorials.html" title="Tutorials"></link>
<link rel="prev" href="CodeGenerationTutorial.html" title="Code Generation tutorial"></link>
<link rel="next" href="ValidationTutorial.html" title="Validation tutorial"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">调试器教程</h1>
<div class="section" title="调试器教程">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="DebuggerTutorial"></a>调试器教程</h2>
</div>
</div>
</div>
<p>本教程已针对Eclipse Mars更新：Eclipse 4.5，EMF 2.11，OCL 6.0。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一些截图可能会略微过时。</p>
</li>
</ul>
</div>
<p>在本教程中，我们将继续<a class="link" href="Tutorials.html#OCLinEcoreTutorial" title="OCLinEcore教程">OCLinEcore教程</a>并演示如何使用<a class="link" href="Debugger.html" title="调试器（Luna中的新功能）">OCL调试器</a>进行调试：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在控制台视图中手动键入约束</p>
</li>
<li class="listitem">
<p>有效性视图中嵌入的OCLinEcore验证失败</p>
</li>
<li class="listitem">
<p>从Validity View中完成OCL验证失败</p>
</li>
</ul>
</div>
<div class="section" title="加载OCLinEcore教程示例项目">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadOCLinEcoreTutorialExampleProject2"></a>加载OCLinEcore教程示例项目</h3>
</div>
</div>
</div>
<p>本教程前两部分的材料作为OCLinEcore示例项目的一部分提供，您可以通过使用Project Explorer的右键上下文菜单选择<span class="bold"><strong>New，</strong></span>然后<span class="bold"><strong>示例</strong></span>来加载。这应该给出<span class="bold"><strong>New Example</strong></span>对话框，您可以在其中选择<span class="bold"><strong>OCL（OCL约束语言）插件</strong></span>和<span class="bold"><strong>OCLinEcore教程</strong></span> 。
				</p>
<p>本教程第三部分的材料作为CompleteOCL示例项目的一部分提供，您可以以类似的方式加载它。</p>
</div>
<div class="section" title="OCL调试器">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="TheOCLDebugger"></a> OCL调试器</h3>
</div>
</div>
</div>
<p>OCL调试器是Eclipse调试器框架的自定义，因此它的大多数功能应该给熟悉Java调试器的人带来一些惊喜。</p>
<p>有：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>堆栈视图，显示嵌套评估环境中的当前行号</p>
</li>
<li class="listitem">
<p>变量视图，可以重新检查本地和中间变量</p>
</li>
<li class="listitem">
<p>一个编辑器，其中突出显示源以显示要评估的下一个AST节点</p>
</li>
<li class="listitem">
<p>一个大纲，其中源以树形式显示</p>
</li>
<li class="listitem">
<p>断点可以控制断点的视图</p>
</li>
</ul>
</div>
<p>我们将通过调试一个简单的例子来演示其中的一些功能。</p>
</div>
<div class="section" title="非常简单的调试会话">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="VerySimpleDebugsession"></a>非常简单的调试会话</h3>
</div>
</div>
</div>
<p>我们将在<span class="bold"><strong>EPackage</strong></span>上调试OCL表达式<span class="bold"><strong>self.name</strong></span>的执行。
				</p>
<div class="section" title="启动调试器">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Startingthedebugger"></a>启动调试器</h4>
</div>
</div>
</div>
<p>双击<span class="bold"><strong>model / Tutorial.ecore</strong></span>打开模型并展开顶部条目以显示EPackage。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-model.png"></div>
<p>
					
</p>
<p>如果模型使用其他编辑器打开，请将其关闭，然后使用Sample Ecore Editor打开，方法是选择<span class="bold"><strong>model / Tutorial.ecore</strong></span> ，然后从上下文菜单中选择<span class="bold"><strong>Open With-&gt; Sample Ecore Model Editor</strong></span> 。
					</p>
<p>从上下文菜单中选择<span class="bold"><strong>教程</strong></span> EPackage并调用<span class="bold"><strong>OCL-&gt; Show Xtext OCL Console</strong></span> 。（等一两秒。）
					</p>
<p>在控制台窗口的底部键入<span class="bold"><strong>self.name</strong></span> ，然后按Enter键。然后点击Page Up键重新显示您的条目。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-input.png"></div>
<p>
					
</p>
<p>控制台在按Enter键后自动运行评估并显示评估结果： <span class="bold"><strong>'tutorial'</strong></span> 。
					</p>
<p>控制台视图提供运行OCL调试器所需的两条信息：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一个EObject用作OCL的<span class="bold"><strong>自我</strong></span> ;控制台在其工具栏下方显示当前选择</p>
</li>
<li class="listitem">
<p>要执行的OCL表达式</p>
</li>
</ul>
</div>
<p>单击Console View工具栏中的debug图标启动调试器。（等一两秒。）</p>
<p>调试器透视图应自动出现。如果没有，您可以通过从Eclipse菜单栏调用<span class="bold"><strong>Window-&gt; Perspective-&gt; Open Perspective-&gt; Debug</strong></span>来手动打开Debug透视图。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-image.png"></div>
<p>
					
</p>
<p>将自动创建一个完整的OCL文档，以将OCL表达式封装在内部，作为<span class="bold"><strong>自身</strong></span>对象类型的附加操作。该文件显示在编辑器中;它是readonly。
					</p>
<p>堆栈显示在合成的完整OCL文档中将上下文显示为<span class="bold"><strong>oclDebugExpression（）</strong></span>的第5行。
					</p>
<p>在堆栈显示中选择<span class="bold"><strong>oclDebugExpression（）</strong></span>行; <span class="bold"><strong>self</strong></span>在Complete OCL文档中突出显示，因为要执行的下一个评估是评估执行自我访问的VariableExp AST节点。
					</p>
<p>变量视图显示两个变量。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<span class="bold"><strong>self</strong></span>是OCL的自我对象</p>
</li>
<li class="listitem">
<p>
								
<span class="bold"><strong>$ pc</strong></span>是表示当前程序计数器的合成变量</p>
</li>
</ul>
</div>
<p>大纲视图显示略微修剪的OCL抽象语法树;您可以选择关闭此视图。在将来的版本中，它可能会更改为支持断点。视图显示</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><span class="bold"><strong>生态</strong></span>的<span class="bold"><strong>进口</strong></span> 
							
</p>
</li>
<li class="listitem">
<p>一个名为<span class="bold"><strong>EPackage</strong></span>的<span class="bold"><strong>类</strong></span>包含</p>
</li>
<li class="listitem">
<p>一个名为<span class="bold"><strong>oclDebugExpression</strong></span>的<span class="bold"><strong>操作</strong></span>包含</p>
</li>
<li class="listitem">
<p>一个<span class="bold"><strong>ExpressionInOCL，</strong></span>其<span class="bold"><strong>OwnedBody</strong></span>是一个<span class="bold"><strong>名为</strong></span> <span class="bold"><strong>PropertyCallExp</strong></span> ，其来源是</p>
</li>
<li class="listitem">
<p>一个<span class="bold"><strong>自己</strong></span>的<span class="bold"><strong>VariableExp</strong></span> 。
							</p>
</li>
</ul>
</div>
<p>大纲显示更全面的签名以帮助调试。</p>
</div>
<div class="section" title="探索变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExploringVariables"></a>探索变量</h4>
</div>
</div>
</div>
<p>“变量视图”提供了任意向下钻取以检查程序可用数据的功能。</p>
<p>显示的左列显示变量的名称，可以展开以导航到变量引用的数据部分。部件名称显示当前显示为0，而不是像OCL中那样基于1。</p>
<p>右列以各种方式显示可以展开的部件类型以及不能展开的部件的值。使用OCL语法，因此字符串出现在单引号中，而集合使用诸如OrderedSet之类的名称。</p>
<p>底线显示所选变量的文本呈现。对于许多类型的数据，可以使用有用的渲染。对于其他人，后备是默认的Java toString（）功能。文本可以自定义</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>如果对象实现<span class="bold"><strong>Labelable，则为</strong></span> <span class="bold"><strong>org.eclipse.ocl.pivot.utilities.getText（）</strong></span>方法
							
</p>
</li>
<li class="listitem">
<p><span class="bold"><strong>LabelUtil。如果<span class="bold"><strong>org.eclipse.ocl.pivot.label_generator</strong></span>扩展点具有对象类的注册，则为QUALIFIED_NAME_REGISTRY</strong></span></p>
</li>
</ul>
</div>
<p>单击<span class="bold"><strong>$ pc</strong></span>左侧的展开/折叠图标以展开它并允许检查OCL AST。接下来执行一个VariableExp，可以检查其<span class="bold"><strong>$ pc.referredProperty</strong></span>或<span class="bold"><strong>$ pc.type</strong></span>以查看更多程序详细信息。
					</p>
<p>单击<span class="bold"><strong>self</strong></span>左侧的展开/折叠图标，即<span class="bold"><strong>ecore :: EPackage</strong></span> ，展开它并显示其<span class="bold"><strong>名称</strong></span>为<span class="bold"><strong>'tutorial'的</strong></span>字段。
					</p>
<p>单击<span class="bold"><strong>self.eClassifiers</strong></span>左侧的展开/折叠图标以显示四个分类器。
					</p>
<p>选择<span class="bold"><strong>self.eClassifiers [1]</strong></span> ，使底行显示显示第二个名为Book。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-image.png"></div>
<p>
					
</p>
<p>变量视图提供了对样本生成器属性视图的更多洞察，因此您可能会发现使用<span class="bold"><strong>self</strong></span>作为OCL表达式来浏览任意模型数据时，使用简单的OCL调试器会话很方便。
					</p>
</div>
<div class="section" title="步进执行">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="SteppingExecution"></a>步进执行</h4>
</div>
</div>
</div>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span>图标以通过一个AST节点评估推进执行。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-step1.png"></div>
<p>
					
</p>
<p>编辑器现在突出显示<span class="bold"><strong>.name</strong></span> ; <span class="bold"><strong>$ pc</strong></span>显示一个PropertCallExp作为下一次执行。
						<span class="bold"><strong>$ pc.referredProperty</strong></span>显示它是<span class="bold"><strong>ecore :: ENamedElement：name</strong></span> 。
					</p>
<p>另一个合成变量<span class="bold"><strong>$ owwnedSource</strong></span>显示构成PropertyCallExp的源项的<span class="bold"><strong>自我</strong></span>评估的结果。正如所料，这与<span class="bold"><strong>自我</strong></span>相同。
					</p>
<p>再次单击F5或<span class="bold"><strong>Step Into</strong></span>图标以通过进一步的AST节点评估来提前执行。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4500-simple-debugger-step2.png"></div>
<p>
					
</p>
<p>整个<span class="bold"><strong>self.name</strong></span>突出显示， <span class="bold"><strong>$ pc</strong></span>显示整个ExpressionInOCL即将被评估。其输入的合成<span class="bold"><strong>$ ownedBody</strong></span>显示<span class="bold"><strong>self.name被</strong></span>评估为<span class="bold"><strong>'tutorial'</strong></span> 。
					</p>
</div>
</div>
<div class="section" title="调试验证失败">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DebuggingaValidationfailure"></a>调试验证失败</h3>
</div>
</div>
</div>
<p>OCL对于使用其他格式良好的规则来详细说明是有用的，但是当这些规则失败时，很难理解为什么会发生故障，特别是如果bug在OCL而不是模型中。我们现在将展示如何使用OCL调试器来调试验证失败。</p>
<p>双击<span class="bold"><strong>model / Tutorial.xmi</strong></span>打开模型，然后展开前两个条目以显示一些细节。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-model.png"></div>
<p>
				
</p>
<p>如果模型使用其他编辑器打开，请将其关闭，然后使用Sample Reflective Ecore Model Editor打开，方法是选择<span class="bold"><strong>model / Tutorial.xmi</strong></span> ，然后从上下文菜单中选择<span class="bold"><strong>Open With-&gt; Sample Reflective Ecore Model Editor</strong></span> 。
				</p>
<p>选择第一行并从上下文菜单中调用<span class="bold"><strong>Validate</strong></span> 。（等一等。）（可选）单击“细节”
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-errors.png"></div>
<p>
				
</p>
<p>这些错误消息提供的精确度不足以真正理解问题，因此单击“ <span class="bold"><strong>确定”</strong></span>关闭弹出窗口，然后选择<span class="bold"><strong>“Book b2”</strong></span> ，这会出现错误，并调用<span class="bold"><strong>OCL-&gt;“显示有效性视图”</strong></span>以提供更多信息。
				</p>
<p>如果“有效性视图”显示问号而不是红色/绿色/琥珀色状态装饰，请单击“有效性视图”工具栏中的“运行”图标。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-vv1.png"></div>
<p>
				
</p>
<p>单击“有效性视图”工具栏中的“ <span class="bold"><strong>固定”</strong></span>图标，以避免在更改鼠标选择时发生颠簸。
				</p>
<p>取消选中Metamodel约束中的顶级<span class="bold"><strong>ecore</strong></span>行，因为我们对<span class="bold"><strong>教程</strong></span>元模型中的成功Ecore元模型约束不感兴趣。
				</p>
<p>同样取消选中Model Elements中的底部<span class="bold"><strong>教程</strong></span>行，因为我们对成功的元模型不感兴趣，只是对教程模型中的元模型感兴趣。
				</p>
<p>单击+工具栏图标以显示详细信息。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-vv2.png"></div>
<p>
				
</p>
<p>我们现在将调试<span class="bold"><strong>Library lib :: Book b2</strong></span>模型元素上的<span class="bold"><strong>tutorial :: Book :: SufficientCopies</strong></span>的失败。选择任一叶子警告，即左侧窗格中的<span class="bold"><strong>Book b2</strong></span>的<span class="bold"><strong>tutorial :: Book :: SufficientCopies</strong></span>子项，或右侧窗格中的<span class="bold"><strong>SufficientCopies</strong></span>的<span class="bold"><strong>Library lib :: Book b2</strong></span>子项，并调用<span class="bold"><strong>Debug Single Enabled选择</strong></span> 。等一两秒钟，调试器启动。如果没有，请手动打开Debugger透视图。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-image.png"></div>
<p>
				
</p>
<p>选择<span class="bold"><strong>oclDebuggerExpression（）</strong></span>堆栈行。调试器显示<span class="bold"><strong>library.loans-&gt; select（（book = self）） - &gt; size（）&lt;=副本，</strong></span>其中<span class="bold"><strong>l</strong></span>突出显示为下一次执行。大纲表明， <span class="bold"><strong>自我</strong></span> <span class="bold"><strong>VariableExp</strong></span>是接下来要执行。源代码中的<span class="bold"><strong>库</strong></span>是<span class="bold"><strong>self.library</strong></span>的简写，因此突出显示<span class="bold"><strong>l</strong></span>是突出显示不可见<span class="bold"><strong>源</strong></span>的近似值<span class="bold"><strong>。</strong></span>在<span class="bold"><strong>图书馆</strong></span>前。

					变量视图中的<span class="bold"><strong>$ pc</strong></span>也显示自己的VariableExp作为下一条指令。
				</p>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span> ， <span class="bold"><strong>$ pc</strong></span>前进，编辑器突出显示对<span class="bold"><strong>库的</strong></span>更改。
				</p>
<p>单击F5或<span class="bold"><strong>Step Into</strong></span>几次，突出显示将显示<span class="bold"><strong>选择</strong></span>主体内的迭代，允许检查每个元素的每个状态以确定展示行为发生的原因。
				</p>
<p>继续单击F5或<span class="bold"><strong>Step Into</strong></span>直到<span class="bold"><strong>- &gt; size（）</strong></span>突出显示。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-step1.png"></div>
<p>
				
</p>
<p>在变量视图中展开<span class="bold"><strong>$ ownedSource</strong></span>显示了三个选定贷款的集合，每个贷款与自己具有相同的图书。
				</p>单击F5或<span class="bold"><strong>Step Into</strong></span>三次，直到<span class="bold"><strong>&lt;=</strong></span>突出显示。
				<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-validation-debugger-step2.png"></div>
<p>
				
</p>
<p>我们现在可以看到比较的<span class="bold"><strong>$ ownedSource</strong></span> （左侧）是3而<span class="bold"><strong>$ ownedArguments [0]</strong></span>右侧是2。进一步的步骤，我们看到结果为<span class="bold"><strong>$ ownedBody</strong></span>演示验证失败的原因。
				</p>
</div>
<div class="section" title="调试完成OCL验证失败">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DebuggingCompleteOCLvalidationfailure"></a>调试完成OCL验证失败</h3>
</div>
</div>
</div>
<p>前两个示例在合成的完整OCL文档中显示其源文本。</p>
<p>在此示例中，我们调试OCL已在完整OCL文档中可用的故障。</p>
<p>使用Sample Ecore Editor从<a class="link" href="CompleteOCLTutorial.html" title="完成OCL教程">Complete OCL教程</a>项目打开<span class="bold"><strong>模型/ EcoreTestFile.ecore</strong></span> 。
				</p>
<p>在Ecore编辑器中使用<span class="bold"><strong>OCL-&gt; Load Document</strong></span>然后拖放<span class="bold"><strong>model / ExtraEcoreValidation.ocl</strong></span>并单击<span class="bold"><strong>OK</strong></span>关闭弹出窗口。
				</p>
<p>再次在Ecore编辑器中使用<span class="bold"><strong>OCL-&gt;显示有效性视图</strong></span>来查看约束/元素对。
					<span class="italic">如果有效视图已经可见，请将其关闭并重新显示，因为在Mars中添加完整的OCL文档无法正确刷新。</span>
				
</p>
<p>在Validity View中，取消选中仅保留<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>贡献的<span class="bold"><strong>ecore</strong></span> Metamodel Constraint贡献。单击<span class="bold"><strong>Metamodel Constraint</strong></span>工具栏中的加号图标以展开所有条目。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-complete-ocl-debugger-model.png"></div>
<p>
				
</p>
<p>在<span class="bold"><strong>DerivationIsVolatile</strong></span>约束下面选择右下角的<span class="bold"><strong>BadClass</strong></span>模型元素，并调用<span class="bold"><strong>Debug Single Enabled Selection</strong></span> 。从上下文菜单（等待一两秒）。如果没有手动打开Debugger透视图，调试器应该启动。
				</p>
<p>
					
<span class="italic">在Mars中，选择<span class="bold"><strong>DerivationIsVolatile</strong></span>堆栈行以刷新选择。
					</span>
				
</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4500-complete-ocl-debugger-image.png"></div>
<p>
				
</p>
<p><span class="bold"><strong>asError</strong></span>和<span class="bold"><strong>hasDerivation</strong></span>都是OCL定义的，因此当您逐步导航到已定义的属性和操作时。
				</p>
</div>
<div class="section" title="控制台实验">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Consoleexperiments"></a>控制台实验</h3>
</div>
</div>
</div>
<p>在调试时，Console中的原始OCL表达式将显示在完整的OCL编辑器中。此编辑器是只读的，因此您无法对其进行编辑以纠正错误或进行实验。</p>
<p>但是，您可以安全地使用OCL控制台执行进一步的实验。在“变量视图”中选择合适的自身对象，然后剪切并粘贴以准备实验性OCL表达式。</p>
<p>
					
<span class="italic">在Mars中，控制台选择不能是集合，因此您不幸地被限制为单个对象。</span>
				
</p>
</div>
<div class="section" title="更长距离的踩踏">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Longerrangestepping"></a>更长距离的踩踏</h3>
</div>
</div>
</div>
<p>在上面的例子中，我们只使用了F5或<span class="bold"><strong>Step Into</strong></span> 。
				</p>
<p>原则上，可以通过F7或<span class="bold"><strong>Step Return</strong></span>来避免繁琐的迭代<span class="bold"><strong>步骤</strong></span> ，这应该在迭代结束时在弹出的评估环境中终止。
					<span class="italic">该设施尚未在火星上进行过充分测试</span> 。
				</p>
<p>如果您在源文本中安排了一些换行符，则可以使用F6或<span class="bold"><strong>Step Next</strong></span>继续操作，直到行号前进。
					<span class="italic">该设施尚未在火星上进行过充分测试</span> 。可以使用Shift和Enter一起在OCL控制台中添加换行符。
				</p>
</div>
<div class="section" title="断点">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Breakpoints"></a>断点</h3>
</div>
</div>
</div>
<p>从完整OCL文档调试OCL时，原始文档是调试器的合适来源，因此可以设置行断点。
					<span class="italic">该设施尚未在火星上进行过充分测试</span>
				
</p>
</div>
</div>
</body>
</html><html id="3167.org_eclipse_ui_themes.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>主题</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">主题</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.themes<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于自定义UI的外观。它允许定义颜色和字体实体以及主题实体。主题允许应用程序有选择地覆盖特定用途的默认颜色和字体规范。<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.theme">主题</a> *， <a href="#e.colorDefinition">colorDefinition</a> *， <a href="#e.fontDefinition">fontDefinition</a> *， <a href="#e.themeElementCategory">themeElementCategory</a> *， <a href="#e.data">data</a> *， <a href="#e.categoryPresentationBinding">categoryPresentationBinding</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.theme">主题</a> （ <a href="#e.colorOverride">colorOverride</a> *， <a href="#e.fontOverride">fontOverride</a> *， <a href="#e.description">description</a> ？， <a href="#e.data">data</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST主题</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">字体，颜色和数据覆盖的集合。这样的集合可用于改变工作台的外观。许多主题元素可能存在相同的id。这允许组件作者为现有主题做出贡献。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 将用于标识此主题的唯一名称</li>
<li><b>name</b> - 要呈现给用户的主题的可翻译名称。具有任何给定id的至少一个主题定义应包含此属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.themeElementCategory">themeElementCategory</a> （ <a href="#e.description">描述</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST themeElementCategory</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">parentId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">标签CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">主题元素定义的逻辑分组。此类别可能包括颜色和字体。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此类别的ID</li>
<li><b>parentId</b> - 父类别的ID（如果有）。</li>
<li><b>class</b> - 实现<code>org.eclipse.ui.themes.的类<code>org.eclipse.ui.themes.IThemePreview</code></li>
<li><b>label</b> - 要呈现给用户的主题元素类别的可翻译名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.colorDefinition">colorDefinition</a> （ <a href="#e.colorFactory">colorFactory</a> ？， <a href="#e.colorValue">colorValue</a> *， <a href="#e.description">description</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST colorDefinition</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">defaultsTo CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">categoryId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">colorFactory CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">isEditable（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">符号颜色定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于标识此颜色定义的唯一ID。</li>
<li><b>label</b> - 要呈现给用户的颜色的可翻译名称。</li>
<li><b>defaultsTo</b> - 另一个颜色定义的id，它是接收器的默认设置。如果没有此颜色的首选项，颜色注册表将在注册表中为其设置defaultsTo值。只能定义<code>defaultsTo</code> ， <code>value</code>或<code>colorFactory</code>一个。</li>
<li><b>value</b> - 此颜色的默认值。可以通过以下方式指定值：<ul>
<li>包含逗号分隔整数的字符串，格式为红色，绿色，蓝色</li><li>一个映射到SWT颜色常量的String（即：COLOR_RED）。
</li></ul>只能定义<code>defaultsTo</code> ， <code>value</code>或<code>colorFactory</code>一个。如果<code>value</code>指定，附加的值定义可经由每个平台/窗口系统基础来指定<code>colorValue</code>元件。</li>
<li><b>categoryId</b> - 此颜色所属的<code>themeElementCategory</code>的可选id。</li>
<li><b>colorFactory</b> - 实现<code>org.eclipse.ui.themes.的类<code>org.eclipse.ui.themes.IColorFactory</code> 。可以使用它来代替<code>value</code>来指定颜色的默认值。请注意，应谨慎使用 - 使用此属性将导致工作台启动时激活插件。</li>
<li><b>isEditable</b> - 是否允许用户在首选项页面中编辑此颜色。如果这是<code>false</code>那么贡献不会显示给用户。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.fontDefinition">fontDefinition</a> （ <a href="#e.fontValue">fontValue</a> *， <a href="#e.description">description</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST fontDefinition</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">categoryId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultsTo CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">isEditable（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">符号字体定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于标识此字体定义的唯一名称。</li>
<li><b>label</b> - 要呈现给用户的字体的可翻译名称。</li>
<li><b>价值</b> -<p>字体值。它的格式为： <code>fontname-style-height</code>其中<code>fontname</code>是字体的名称， <code>style</code>是字体样式（ <code>"regular"</code> ， <code>"bold"</code> ， <code>"italic"</code>或<code>"bold italic"</code> ）， <code>height</code>是表示字体高度的整数。</p>
<p>示例： <code>Times New Roman-bold-36</code> 。</p>  
<p>只能使用一个（或两个） <code>value</code>或<code>defaultsTo</code> 。</p>如果<code>value</code>指定，附加的值定义可经由每个平台/窗口系统基础来指定<code>fontValue</code>元件。</li>
<li><b>categoryId</b> - 此字体所属的<code>themeElementCategory</code>的可选id。</li>
<li><b>defaultsTo</b> - 另一个字体定义的id，它是接收器的默认设置。如果没有对此字体的首选项，则字体注册表将在注册表中为其设置defaultsTo值。
<p>只能使用一个（或两个） <code>value</code>或<code>defaultsTo</code> 。
</p></li>
<li><b>isEditable</b> - 是否允许用户在首选项页面中编辑此颜色。如果这是<code>false</code>那么贡献不会显示给用户。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.colorOverride">colorOverride</a> （ <a href="#e.colorFactory">colorFactory</a> ？， <a href="#e.colorValue">colorValue</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST colorOverride</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">colorFactory CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">允许覆盖<code>colorDefinition</code>元素中定义的颜色。使用主题时将应用这些颜色。工作台定义的颜色是：</p><ul>
<li>org.eclipse.jface.preference。JFacePreference。ERROR_COLOR</li><li>org.eclipse.jface.preference。JFacePreference。HYPERLINK_COLOR</li><li>org.eclipse.jface.preference。JFacePreference。ACTIVE_HYPERLINK_COLOR</li></ul>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于标识此颜色定义覆盖的唯一ID。这应该与现有的字体标识符匹配。严格地说，您可以覆盖基本主题中不存在的颜色，但不建议这样做。实际上，这种替代将有类似的行为<code>colorDefinition</code>是含有S <code>isEditable</code>设置为<code>false</code> 。</li>
<li><b>value</b> - 此颜色的最重要值。可以通过以下方式指定值：<ul>
<li>包含逗号分隔整数的字符串，格式为红色，绿色，蓝色</li><li>一个映射到SWT颜色常量的String（即：COLOR_RED）。
</li></ul>只能定义<code>value</code>或<code>colorFactory</code>一个。与<code>colorDefinition</code>不同，您可能不会为覆盖提供<code>defaultsTo</code> 。</li>
<li><b>colorFactory</b> - 实现<code>org.eclipse.ui.themes.的类<code>org.eclipse.ui.themes.IColorFactory</code> 。可以使用它来代替<code>value</code>来指定颜色的默认值。请注意，应谨慎使用 - 使用此属性将导致工作台启动时激活插件。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.fontOverride">fontOverride</a> （ <a href="#e.fontValue">fontValue</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST fontOverride</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">允许覆盖<code>fontDefinition</code>元素中定义的字体。使用主题时将应用这些字体。工作台定义的字体是：</p><ul>
<li>org.eclipse.jface.resource。JFaceResources。BANNER_FONT</li><li>org.eclipse.jface.resource。JFaceResources。DIALOG_FONT</li><li>org.eclipse.jface.resource。JFaceResources。HEADER_FONT</li><li>org.eclipse.jface.resource。JFaceResources。TEXT_FONT</li></ul>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于标识此字体定义覆盖的唯一ID。这应该与现有的字体标识符匹配。严格来说，您可以覆盖基本主题中不存在的字体，但不建议这样做。实际上，这种替代将有类似的行为<code>fontDefinition</code>是含有S <code>isEditable</code>设置为<code>false</code> 。</li>
<li><b>价值</b> -<p>这个字体的重写值。它的格式为： <code>fontname-style-height</code>其中<code>fontname</code>是字体的名称， <code>style</code>是字体样式（ <code>"regular"</code> ， <code>"bold"</code> ， <code>"italic"</code>或<code>"bold italic"</code> ）， <code>height</code>是表示字体高度的整数。</p>
<p>示例： <code>Times New Roman-bold-36</code> 。</p>
<p>必须为字体覆盖定义<code>value</code> 。与<code>fontDefinition</code>不同，您可能无法为<code>fontOverride</code>提供<code>defaultsTo</code> 。</p>

<p>如果未指定此值，则将使用默认字体</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！元素<a name="e.description">描述</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">元素用法的简短描述。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.colorFactory">colorFactory</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST colorFactory</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">插件CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>colorFactory</code>属性的元素版本。当colorFactory实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.themes.的类<code>org.eclipse.ui.themes.IColorFactory</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
<li><b>plugin</b> - 包含该类的插件的标识符</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在colorFactory元素中使用的参数元素。这将作为初始化数据传递给colorFactory类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.data">数据</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST数据</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>允许任意数据与主题或默认主题相关联的元素。该数据可以是梯度方向或百分比，标签，作者信息等。</p>
<p>此元素的行为与定义和覆盖类似。如果默认主题和标识的主题中都存在键，则在访问该主题时将使用标识的主题值。如果标识的主题未提供值，则使用默认值。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 数据名称，</li>
<li><b>value</b> - 数据值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.colorValue">colorValue</a> （ <a href="#e.colorFactory">colorFactory</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST colorValue</p>
<p class="code SchemaDtdAttlist">os CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">是CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">colorFactory CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素允许在每个平台的基础上指定颜色值。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>os</b> - 一个可选的os字符串，用于根据当前操作系统选择颜色。例如：win32，linux</li>
<li><b>ws</b> - 一个可选的os字符串，用于根据当前WS选择颜色。例如：win32，gtk</li>
<li><b>value</b> - 此颜色的默认值。可以通过以下方式指定值：<ul>
<li>包含逗号分隔整数的字符串，格式为红色，绿色，蓝色</li><li>一个映射到SWT颜色常量的String（即：COLOR_RED）。
</li></ul>只能定义<code>value</code>或<code>colorFactory</code>一个。</li>
<li><b>colorFactory</b> - 实现<code>org.eclipse.ui.themes.的类<code>org.eclipse.ui.themes.IColorFactory</code> 。可以使用它来代替<code>value</code>来指定颜色的值。请注意，应谨慎使用 - 使用此属性将导致工作台启动时激活插件。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.fontValue">fontValue</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST fontValue</p>
<p class="code SchemaDtdAttlist">os CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">是CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素允许基于每个平台指定字体值。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>os</b> - 一个可选的os字符串，用于根据当前操作系统选择字体。例如：win32，linux</li>
<li><b>ws</b> - 一个可选的os字符串，用于根据当前WS选择字体。例如：win32，gtk</li>
<li><b>价值</b> -<p>字体值。它的格式为： <code>fontname-style-height</code>其中<code>fontname</code>是字体的名称， <code>style</code>是字体样式（ <code>"regular"</code> ， <code>"bold"</code> ， <code>"italic"</code>或<code>"bold italic"</code> ）， <code>height</code>是表示字体高度的整数。</p>
<p>示例： <code>Times New Roman-bold-36</code> 。</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.categoryPresentationBinding">categoryPresentationBinding</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST categoryPresentationBinding</p>
<p class="code SchemaDtdAttlist">categoryId IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">presentationId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素允许将类别绑定到特定表示，如<code>org.eclipse.ui.presentationFactory</code>扩展点所述。如果一个类别有任何表示绑定，那么它（和它的子节点）只有在用户绑定到活动表示时才能配置。这对于从用户考虑中删除未使用的项目非常有用。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>categoryId</b> - 要绑定的类别的id</li>
<li><b>presentationId</b> - 要绑定的表示的id</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是几个颜色和字体定义的示例以及覆盖它们的主题。
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.themes”</span> <span class="code SchemaTag">&gt; &lt;themeElementCategory id =</span> <span class="code SchemaCstring">“com.xyz。ThemeCategory“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz。XYZPreview“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Elements“</span> <span class="code SchemaTag">/&gt; &lt;colorDefinition id =</span> <span class="code SchemaCstring">”com.xyz。Forground“</span> <span class="code SchemaTag">categoryId =</span> <span class="code SchemaCstring">”com.xyz。ThemeCategory“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ前景色“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”COLOR_BLACK“</span> <span class="code SchemaTag">&gt; &lt;！ - 白色应该用于GTK  - &gt; &lt;colorValue value =</span> <span class="code SchemaCstring">”COLOR_WHITE“</span> <span class="code SchemaTag">os =</span> <span class="code SchemaCstring">”linux“</span> <span class="code SchemaTag">ws =</span> <span class="code SchemaCstring">”gtk“</span> <span class="code SchemaTag">/&gt; &lt;description&gt;此颜色用于XYZ插件编辑器的前景色。&lt;/ description&gt; &lt;/ colorDefinition&gt; &lt;colorDefinition id =</span> <span class="code SchemaCstring">“com.xyz。背景“</span> <span class="code SchemaTag">categoryId =</span> <span class="code SchemaCstring">”com.xyz。ThemeCategory“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Background Color“</span> <span class="code SchemaTag">&gt; &lt;colorFactory class =</span> <span class="code SchemaCstring">”org.eclipse.ui.themes。RGBBlendColorFactory“</span> <span class="code SchemaTag">plugin =</span> <span class="code SchemaCstring">”org.eclipse.ui“</span> <span class="code SchemaTag">&gt; &lt;parameter name =</span> <span class="code SchemaCstring">”color1“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”COLOR_WHITE“</span> <span class="code SchemaTag">/&gt; &lt;parameter name =</span> <span class="code SchemaCstring">”color2“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”COLOR_BLUE“</span> <span class="code SchemaTag">/&gt; &lt;/ colorFactory&gt; &lt;！ -  black should用于GTK  - &gt; &lt;colorValue value =</span> <span class="code SchemaCstring">“COLOR_BLACK”</span> <span class="code SchemaTag">os =</span> <span class="code SchemaCstring">“linux”</span> <span class="code SchemaTag">ws =</span> <span class="code SchemaCstring">“gtk”</span> <span class="code SchemaTag">/&gt; &lt;description&gt;此颜色用于XYZ插件编辑器的背景颜色。&lt;/ description&gt; &lt;/ colorDefinition&gt; &lt;fontDefinition id =</span> <span class="code SchemaCstring">“com.xyz。TextFont“</span> <span class="code SchemaTag">categoryId =</span> <span class="code SchemaCstring">”com.xyz。ThemeCategory“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ编辑器字体“</span> <span class="code SchemaTag">defaultsTo =</span> <span class="code SchemaCstring">”org.eclipse.jface.textfont“</span> <span class="code SchemaTag">&gt; &lt;description&gt;此字体由XYY插件编辑器使用。&lt;/ description&gt; &lt;/ fontDefinition&gt; &lt;data name =</span> <span class="code SchemaCstring">“com.xyz。EditorMarginWidth“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”5“</span> <span class="code SchemaTag">/&gt; &lt;theme id =</span> <span class="code SchemaCstring">”com.xyz。HarshTheme“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ的严酷颜色“</span> <span class="code SchemaTag">&gt; &lt;colorOverride id =</span> <span class="code SchemaCstring">”com.xyz。Forground“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”COLOR_CYAN“</span> <span class="code SchemaTag">/&gt; &lt;colorOverride id =</span> <span class="code SchemaCstring">”com.xyz。背景“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”COLOR_MAGENTA“</span> <span class="code SchemaTag">/&gt; &lt;data name =</span> <span class="code SchemaCstring">”com.xyz。EditorMarginWidth“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”1“</span> <span class="code SchemaTag">/&gt; &lt;/ theme&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><code>org.eclipse.ui.IWorkbench.getThemeManager()</code>提供了<code>org.eclipse.ui.themes.的实例<code>org.eclipse.ui.themes.IThemeManager</code>可用于获取命名主题（通过id，包括id为<code>IThemeManager.的默认主题） <code>IThemeManager.DEFAULT_THEME</code> ）或当前主题。来自<code>org.eclipse.ui.themes.ITheme</code>你可能获得<code>org.eclipse.jface.resources.ColorRegistry</code> ，一个<code>org.eclipse.jface.resources.FontRegistry</code>和与主题相关的任意数据。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>工作台提供文本，对话框，横幅，标题和部分标题字体的字体定义。它还为超链接，活动超链接，错误，活动部分（背景渐变部分和前景）和非活动部分（背景渐变部分和前景）提供颜色定义。工作台还提供标题梯度百分比（活动和非活动）和梯度方向（活动和非活动）的数据常量。工作台不提供任何命名主题。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2003,2006 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="3035.sync.html" dir="ltr"></html><html dir="ltr">
<head>
<title>同步项目</title>
<link rel="stylesheet" type="text/css" href="help.css"></link>
<script type="text/javascript" src="thumb.js"> </script>
</head> 
<body dir="ltr">
<h1 id="top">同步项目</h1>
<p>
</p><ul>
<li><a href="#prereq">同步项目的要求</a>
</li><li><a href="#create">创建新的同步项目</a>
</li><li><a href="#work">使用同步项目</a>
</li><li><a href="#context-menu">使用“同步上下文菜单”更改同步行为</a>
</li><li><a href="#file-filter">更改与文件筛选同步的文件</a>
</li><li><a href="#conversion-wizard">将项目转换为同步项目</a>
</li><li><a href="#merge-conflict">解决合并冲突</a>
</li><li><a href="#remote-discovery">发现远程环境（远程包括和代码分析）</a>
</li><li><a href="#prefs">同步首选项</a>
</li></ul>
<p>同步项目由在本地系统以及一个或多个远程系统上镜像的文件组成。编辑在本地进行，每个文件在更改，创建或删除时与当前活动的远程系统同步。这样可以更快地与文件和编辑器交互，更多CDT编辑器功能，因为文件是本地的，并且如果网络连接丢失，则继续进行交互以进行编辑等。
</p><p>有关不同类型项目（本地，同步和远程）的<a href="localVsRemote.html">概述，</a>请参阅<a href="localVsRemote.html">PTP项目类型简介</a> 。
</p><p>
</p><h2 id="prereq">同步项目的要求</h2>
<p>要托管同步项目，远程系统必须支持<a href="http://git-scm.com/">Git</a>分布式版本控制系统。请注意，这完全独立于使用<a href="http://git-scm.com/">Git</a>进行源代码控制。

</p><h2 id="create">创建新的同步项目</h2>
<p>首先，我们假设您处于<b>C / C ++透视图中</b> 。
</p><p>如果还没有，请使用<b>Window&gt; Open Perspective&gt; Other ...</b>切换到C / C ++ Perspective，然后选择<b>C / C ++</b></p> 

<p>要创建新的同步项目，请首先选择适当的向导：</p>选择<b>文件&gt;新建&gt;其他...</b>然后在向导选择对话框中，选择<b>远程&gt;同步C / C ++项目</b> ， <b>同步Fortran项目</b>或<b>同步项目</b>以进行同步，而不支持特定语言。
<p><br></p>
<p><img src="images/sync-newproj.png">
</p><p><br></p>
<p>或者，从C / C ++ Perspective的Project Explorer中的上下文菜单（右键），选择<b>New&gt; Synchronized C / C ++ Project</b> ， <b>Synchronized Fortran Project</b>或<b>Synchronized Project</b>进行同步，但不支持特定语言。
</p><p><br></p>
<p><img src="images/sync-newprojContext.png">
</p><p><br></p>
<p id="new-sync-proj">现在填写显示的<b>New Synchronized Project</b>对话框。通用<b>同步项目</b> （仅同步）的对话框不包含用于选择项目类型和工具链的下半部分。

</p><p>
<img src="images/sync-newprojCreate.png">

</p><p><br></p>填写项目名称。对于<b>本地目录，</b>提供项目名称和位置，很可能是本地工作空间目录中的默认位置。然后通过指定<a href="#connection">连接</a>和远程目录来提供远程位置。接下来，指定项目类型。最后，选择要用于远程和本地站点的工具链。通常，您只为每个工具链选择一个工具链，但可以选择其他工具链。
<i>请注意，如果您不需要在本地构建，则不需要本地工具链。</i>
<p>文件筛选指定将在本地计算机和远程目标之间同步哪些文件。可以通过“ <b>修改文件过滤...”</b>按钮为此新项目更改默认值。默认情况下，eclipse相关文件（如<code>.project</code>在本地和远程系统之间不同步。二进制文件是。有关更多信息，请参阅<a href="#file-filter">文件过滤</a> 。有关如何修改后续新同步项目的默认行为的信息，请参阅<a href="#prefs">同步首选项</a> 。
</p><p>此时，您可以选择“ <b>完成”</b>以使用其余选项的默认值完成项目设置。
</p><p>或者，您可以选择“ <b>下一步”</b>以滚动其余页面，这些页面根据所选项目类型和工具链而有所不同。这包括配置页面，它将为之前选择的每个工具链列出单独的构建配置。
</p><p><br></p>
<!-- <p><img src="images/sync-newprojConfig.png"> -->
<p><img src="images/sync-newprojConfig.png">
</p><p><br></p>从这里，您可以配置构建属性。（这也可以在创建项目后完成。）请注意，如果为本地和远程选择相同的工具链，则只显示一个配置。在项目创建期间，将重复此配置，为本地创建一个，为远程创建另一个。
<p>如果然后选择<b>Next&gt;</b>而不是<b>Finish</b> ，将显示<b>Default Build Configurations</b>页面。有关同步配置和构建配置的更多信息，请参阅<a href="#work">使用同步项目</a> 。
</p><p><img src="images/sync-build-config.png"></p>
<p> 
</p><p>选择“ <b>完成”</b>以结束“新建项目向导”。
</p><p> 
</p><h3 id="connection">创建远程连接</h3>在第一个向导页面上， <b>New ...</b>按钮可用于创建新的远程连接。填写主机名，用户和密码（或其他身份验证信息）。选择<b>完成</b> 。在返回上一个对话框并选择“ <b>浏览...”</b>按钮或需要进行其他通信之前，不会测试连接。
<p><br></p>
<p><img src="images/sync-newprojConnection.png">
</p><p>注意：要在创建连接后编辑连接信息，例如更改用户名或密码，请参阅<a href="remoteTools.html#edit">编辑远程连接</a> 。</p><p>
<br></p>

<h2 id="work">使用同步项目</h2>
<p>在Eclipse Kepler（PTP 7.0）中，同步和构建的设置已分开。对于前者，使用<b>同步配置</b> ，并且可在所有同步项目中使用。这些主要用于指定应同步的本地文件（机器和目录）的位置。对于构建，使用<b>构建配置</b> ，仅适用于同步的C，C ++或Fortran项目。它们用于配置构建参数，例如编译器和编译器选项。这两种配置类型主要独立运行，同步或构建始终分别使用当前<b>活动同步配置</b>或<b>活动构建配置</b> 。

</p><p>唯一的依赖是默认情况下，构建发生在活动同步配置指定的位置。此外，您可以为每个同步配置指定默认构建配置。切换到其他同步配置时，会自动选择其默认构建配置。这只是为了方便起见，因此切换到不同的遥控器时不需要更改两个设置。您还可以独立于同步配置更改构建配置。对于相同的源位置，甚至对多个远程位置（同步配置）使用相同的构建配置，通常有多种类型的构建，例如“调试”和“发布”构建。

</p><p>如果在向导中选择，则启动同步配置将用于具有其默认构建配置的远程系统。因此，对于最常见的情况（要修改和构建的单个远程站点），同步项目开箱即用。如果远程位置不存在，则创建它。否则，该目录中的文件将同步到本地工作区。您可以像编辑任何本地项目一样编辑文件。每次保存文件时，它都将与远程系统同步。如果您创建或删除文件，将适当更新远程系统。请注意，即使未选择本地工具链，也始终为方便起见创建本地同步配置。它提供了一种简单的方法来禁用所有远程操作并在本地工作而不更改其他同步设置。
</p>
<p>要构建项目（假设您已经创建了一个makefile），请确保在<b>Project Explorer</b>视图中选择了<b>项目</b> ，然后单击构建图标（看起来像锤子的图标）。Console视图显示构建的结果。
</p><p>有关创建和构建简单的新同步项目的更多示例，请参阅<a href="01buildMPIprog.html">创建MPI项目简介</a> 。
</p>
<p>有关构建配置，同步配置等的详细信息，请参阅“ <a href="build.html">构建同步项目”</a>页面上的“ <a href="build.html#syncConfig">同步配置</a> ”。

</p><h2 id="context-menu">使用“同步上下文菜单”更改同步行为</h2>
<p>使用同步上下文菜单可以查看或更改与同步行为相关的多个属性。要访问同步上下文菜单，请在<b>Project Explorer</b>视图中右键单击项目，然后向下移动到<b>Synchronize</b>子菜单。
</p><p><img src="images/sync-contextMenu.png"></p>
<p>在此菜单中，您可以立即强制执行活动同步配置，设置活动同步配置，管理配置（同步配置及其关联的构建配置），强制同步所有同步配置等。 <b>自动同步（全局） ）</b>和<b>自动同步设置</b>允许您更改所有项目或每个项目的自动<b>同步</b>行为。
</p><p>在构建之前，无论任何设置如何，文件始终使用仅活动配置的强制同步进行更新。这可确保构建基于最新版本。在构建更新文件之后可能会发生另一次同步，因为构建可能会在编译期间更改远程文件。（但是，此同步确实尊重用户的设置。）有关“ <a href="#file-filter">过滤</a>器...”选项的信息，请参阅“ <a href="#file-filter">文件过滤：更改要同步的文件</a> ”。



</p><h2 id="file-filter">文件过滤：更改同步的文件</h2>
<p>默认情况下，所有文件通常都是同步的。
</p><p>但是某些文件不需要在本地和远程位置之间同步。例如，二进制文件可能在本地计算机上没有用（并且可能很大且复制速度很慢），但源文件通常是因为它们通常是从本地Eclipse工作台编辑的，但用于构建远程目标系统。
</p><p>从<a href="#context-menu">同步上下文菜单</a>的“过滤器...”选项，</p><p><img src="images/sync-filter-menu.png"></p>您可以更改当前项目的同步文件。您还可以在“ <a href="#prefs">同步项目”首选项页面</a>上更改以后项目的默认设置。默认情况下，Eclipse专门使用的文件和目录将从同步中排除。（请注意，这些文件，例如<code>.project</code>和<code>.project</code>等通常不可见。）
<p>可以在三个位置访问同步过滤信息：</p><ol>
<li>现有项目的“ <b>配置同步项目过滤器”</b>对话框（同步过滤器对话框）可从上面显示的同步上下文菜单中获得，如下所示。它显示了当前所选项目中的设置及其对文件的作用</li><li><a href="#new-sync-proj">新同步项目对话框中</a>的<b>文件过滤器</b>弹出对话框（来自<b>修改文件过滤...</b>按钮）允许在创建项目时设置同步过滤器设置，并且</li><li>“ <q href="#sync-prefs">同步过滤器首选项”页面设置将在新项目中使用的默认值。
</q></li></ol>
<p>现有项目的“ <b>配置同步项目过滤器”</b>对话框的部分：</p><ul>
<li>顶部的<b>文件/文件夹</b>列表指示当前所选项目的当前排除和包含的目录和文件。（不包含在“ <a href="#prefs">同步首选项”</a>页面中。）您可以选择（包括）或取消选择（排除）单个文件和文件夹，这将向“ <b>模式”</b>区域添加相应的<b>模式</b> 。
</li><li>底部附近的“ <b>模式”</b>区域显示当前的排除和包含模式。可以添加，编辑或删除模式。结果将显示在文件/文件夹列表中。
</li></ul>
<p><img src="images/sync-filter-dialog.png">
</p><p>如果更改了其他部分，则对话框的每个部分都会自动更新，以便它们始终保持一致。这使您可以立即看到添加新模式的效果。默认情况下，不显示远程文件。在更新视图时，显示远程文件可能会导致响应时间变慢。如果要<b>查看远程文件，</b>请选中它们。如果远程系统断开连接，则会显示错误消息。
</p><p>
</p><p>要输入新模式，请选择<b>添加...</b>按钮。出现“ <b>添加模式”</b>对话框。
</p><p><img src="images/sync-filter-add-dialog.png"></p>
<p>在<b>Pattern：</b>字段中，输入使用Git语法的模式（gitignore）</p><ul>
<li>支持fnmatch（*，？，[]）</li><li>过滤目录会忽略其中的所有文件</li><li>最后一个模式具有最高优先级</li><li>路径以/匹配目录结尾</li></ul>
<p>选择<b>Pattern：</b>字段下方的单选按钮，以指示是否应在同步中包含或排除该模式。默认排除。


</p><p>模式按“ <b>配置同步项目过滤器”</b>对话框的模式区域中给出的顺序应用。新模式位于底部（最高优先级）。因此，将根据第一个匹配模式排除或包含文件，或者如果没有模式匹配则包括该文件。使用“上移”和“下移”按钮更改模式的优先级。如果新模式与旧模式相同，则删除旧模式。请注意，旧模式是排除模式还是包含模式并不重要，因为新模式会取代它。

</p><p>例如，要从同步中排除<code>*.o</code>文件（例如，它们是在远程系统上构建的，但您不希望将它们复制回本地目录），请在“ <b>配置同步项目”的</b> “模式”区域中选择“ <b>添加...”</b>按钮。 <b>过滤</b>对话框。
</p><p>在模式字段中键入<code>*.o</code> ，并确保为<b>模式类型</b>选择了<b>排除</b> 。
</p><p><img src="images/sync-filter-add-dialog-dot-o.png"></p>
<p>然后选择<b>确定</b>按钮。新过滤器将显示在“ <b>配置同步项目过滤器”</b>对话框的模式区域中， <code>*.o</code>文件不再包含在同步中。
</p><p><img src="images/sync-filter-add-dialog-dot-o-results.png"></p>
<p>您可以使用按钮向上或向下移动优先级，编辑图案等。
</p><p>
</p><p><b>单击确定</b>以保存对同步过滤所做的任何更改。

</p><h2 id="conversion-wizard">将项目转换为同步项目</h2>
<p>转换向导允许您将任何项目类型转换为同步项目。目前只能转换本地项目。要转换项目，请在<b>Project Explorer</b>视图中单击鼠标右键，然后选择<b>New&gt; Other ...</b> 在向导选择对话框中，选择“ <b>远程”&gt;“转换为同步项目”，</b>然后选择“ <b>下一步&gt;”</b> 。
</p><p><img src="images/sync-selectConversionWizard.png"></p>

<p>在此对话框中，您可以选择要转换的项目。
</p><p><img src="images/sync-conversionWizard.png"></p><p>
</p><p>选择本地项目以将其转换为同步项目。选择一个连接（或<a href="remoteTools.html#create"></a>创建一个新的连接。）
</p><p>选择<b>Next&gt;</b> ，然后在下一个对话框中，为每个Sync Configuration选择默认的Build Configurations（仅适用于C，C ++或Fortran项目）。
</p><p><img src="images/sync-conversionWizard2.png"></p><p>
</p><p>选择<b>Finish</b> ，将项目同步（复制）到连接指定的远程系统。

</p><h2 id="merge-conflict">解决合并冲突</h2>
<p>通常，在将文件的两个不同版本合并为单个版本时，可能发生“合并冲突”。由于各种原因，最终版本可能存在分歧。对于同步项目，在正常使用期间不会发生合并冲突，因为底层系统知道本地文件更改是对旧版远程版本的更新，反之亦然。但是，如果文件在本地和远程更改而没有插入同步，则可能会发生合并冲突，因为下一次同步可能不知道如何合并这两个版本。（在Eclipse中恢复工作之前进行远程更改后进行同步是一个好主意。）检测到冲突时，将显示以下对话框：</p><p><br></p>
<p><img src="images/sync-mergeConflictDialog.png">
</p><p><br></p>您可以从此对话框或从“ <b>窗口”&gt;“显示视图”&gt;“其他...”</b>打开合并冲突视图，然后单击“ <b>远程开发”&gt;“同步合并视图”</b> 。<b>同步合并视图</b> （可能位于工作台窗口的底部）显示了冲突文件的列表。（如果查看器为空，您可能需要在Project Explorer中选择项目。）双击“ <b>同步合并视图</b> ”中的文件以<b>显示</b> “比较编辑器”，其中可以查看差异并解决冲突。在此编辑器中，左窗格显示本地文件，该文件已标记为显示冲突，右窗格显示远程文件。“祖先”文件可选地显示在这两个窗格上方，可以使用编辑器的最左侧图标打开或关闭。祖先是文件的最后一个已知版本，本地和远程都是从该文件派生的。另请注意，右键单击查看器中的文件会显示上下文菜单，从中可以选择某些选项（如下所述）。

<p><br></p>
<p><img src="images/sync-mergeConflictResolve.png">
</p><p><br></p>在比较编辑器中，编辑左窗格会编辑文件的本地版本。比较编辑器仅为方便起见。您还可以从普通的Eclipse文本编辑器编辑该文件。完成编辑后，请务必保存文件，然后从“ <b>同步合并视图”</b>的上下文菜单中选择“ <b>标记为已解决</b> <b>”</b> 。此版本将在下次同步时复制到远程站点。对每个冲突的文件执行相同的操作。在所有冲突都已解决之前，阻止同步。而是会出现合并冲突对话框。（单击合并冲突对话框中的复选框以禁用它，直到解析合并。）解析合并后手动同步以将编辑推送到远程系统是个好主意。要手动同步，请在<b>Project Explorer</b>视图中选择项目，然后单击鼠标右键， <b>Synchronize&gt; Sync Active Now</b> 。
<p>合并冲突后，本地文件添加了标记和注释，以显示本地和远程站点上的不同内容。这对于单独编辑文件很有用，但对于使用比较编辑器则没有那么多。在“ <b>同步合并视图”</b>的上下文菜单中选择“ <b>合并前重置为版本”，</b>以将本地文件还原为其先前版本。现在，比较编辑器将清楚地显示本地和远程之间的差异。有时您可能只想要文件的远程版本。选择<b>Resolve as remote</b>会使本地文件与远程版本相同，然后将其标记为已解决。

</p><h2 id="remote-discovery">发现远程环境（远程包括和代码分析）</h2>
<h3>介绍</h3>现代软件项目几乎总是依赖于外部代码，宏和变量，它们通过include指令和各种编译器命令和设置引入到源代码中。我们将所有这些外部元素称为项目的“环境”。检测此环境是一个难题，但对于Eclipse提供有用的代码帮助（错误突出显示，代码导航等）至关重要。这很困难，因为这个环境部分内置在编译器中，并且在构建时由编译器部分“发现”。CDT在开发<b><i>扫描仪发现</i></b>方面有着悠久的历史来解决这个问题，并且最近公布了对发现机制的重新设计。同步项目扩展了这种新的重新设计，以便发现可以反映当前远程计算机的环境（由活动的构建配置指定）。目前，仅支持GCC编译器。请注意，CDT仍然提供旧的扫描程序发现方法，但尚未扩展为使用同步项目。
<p>扫描仪发现发现的元素由CDT <i>索引器</i>和CDT <i>Codan（CODe ANalysis）</i>工具使用。前者是一个可能长期运行的任务，它收集有关所有源代码组件（变量，函数，类等）的信息。然后，Codan使用此信息分析并可能使用各种错误报告和警告标记源文件。这三个组件（发现，索引和Codan）中的每一个都在不同时间独立运行。此外，构建过程可能会在<b>Problems</b>视图中生成编译器错误的标记。Codan使用类似于bug的图标，将其与构建系统使用的更传统的图标区分开来。（由于分析C ++的复杂性，经常出现程序在编译时仍会显示Codan标记的情况。这可能是由于发现，索引或代码分析方面的问题。）
</p><p>
</p><h3>建立</h3>
<p>注意：还相关： <a href="includes.html">包含同步项目的文件</a>
</p><p>默认情况下，同步项目使用正常的CDT发现机制，该机制读取本地环境。要配置新的发现元素，请在创建新的同步项目后按照这些说明进行操作。转到<b>项目&gt;属性&gt; C / C ++常规&gt;预处理器包括路径，宏等</b> 。确保在对话框顶部选择了远程配置。在“提供程序”选项卡下，如果要输入自己的路径，请取消选择“CDT用户设置条目”以外的所有CDT提供程序。接下来，选择两个同步提供程序，“同步GCC构建输出分析器”和“同步GCC内置编译器设置”。后一个提供程序运行特制的编译器命令以获取特定于编译器的设置。选择“确定”后立即运行。前提供程序将与构建同时执行。它拦截构建输出并尝试查找环境信息。因此，必须在此提供程序有用之前运行构建。
</p><p>现在，确保启用了索引并调用远程构建。为了使构建输出解析器有用，构建必须生成详细输出。设置此类构建的方法因项目而异，但请参阅<a href="https://developer.mozilla.org/en-US/docs/Eclipse_CDT">Mozilla Project CDT设置页面</a>以获取一个好例子。对每个远程构建配置重复这些步骤。对于本地配置，标准CDT或新的Sync提供程序都应该可用。如果您希望在切换构建配置时自动更新环境，请转到<b>项目&gt;属性&gt; C / C ++常规&gt;索引器，</b>然后为“构建索引器的配置”选择“使用活动构建配置”。这样做的缺点是每次切换配置时索引器都会运行。

</p><p><br></p>
<p><img src="images/sync-discoveryDialog.png">
</p><p><br></p>

<h3>结果</h3>可以在上一页的“条目”选项卡下找到已发现路径和宏的列表。请注意，连接名称前置为远程包含（UNC表示法）。添加自己的条目时，可以使用相同的表示法通过省略连接名称来指定远程计算机或本地路径上的路径。（因此，远程配置可以使用本地路径，反之亦然。）
<p>默认情况下，构建输出解析器会发现每个文件的条目。这可以在<b>Providers</b>选项卡下更改（见上图）。但是，如果发现是按文件进行的，则从项目菜单访问或右键单击项目或文件夹并选择“ <b>属性”时</b> ，包含和宏列表将为空<b>。</b> 而是，右键单击单个文件，然后选择“ <b>属性”</b>以查看该特定文件的条目。

<!-- FIXME end not changed to here -->
</p><h3 id="prefs">同步首选项</h3>
<p>同步项目的首选项页面包括设置同步<a href="#file-filter">过滤的</a>默认值。
</p><p><img src="images/sync-prefs.png">
</p><p>另请参阅<a href="07ptpPrefs.html">PTP首选项</a> 。
</p><p> 
</p><h3>提示</h3>
<dl>
<li>索引源文件可能需要很长时间。您可能要取消该过程或完全禁用索引，直到上述设置完成（ <b>项目&gt;属性&gt; C / C ++常规&gt;索引器</b> ）</li>
<li><b>Indexer</b>页面还有一些用于微调索引器的有用设置。</li>
<li>要重新编制索引，请右键单击该项目，然后选择“ <b>索引器”&gt;“重建”</b></li>
<li>在“提供程序”选项卡（而不是“条目”选项卡）中，使用“清除条目”按钮删除特定提供程序的条目。在为不同的远程创建新配置后，通常需要执行此操作。复制配置的条目将复制到新配置。</li>
<li>构建输出解析器在包含编译器可执行文件名称的构建输出行上运行。在提供程序选项卡下，如果它与您的可执行文件名不匹配，请更改“编译器命令模式”（参见上图）。例如，如果您使用MPI，则可执行文件可能是“mpicc”，“mpic ++”或“mpiCC”。小心模仿正则表达式格式。例如，添加“mpic ++”追加：|（mpic \ + \ +）到模式。</li>
<li>如果切换配置不会改变环境，请仔细检查索引器“为索引器构建配置”设置。出于某种原因，它有时会重置为使用固定配置，例如重新启动Eclipse时。</li>
</dl>

<p>有关<a href="http://wiki.eclipse.org/PTP/sync-projects">同步项目</a>的更多信息，另请参阅<a href="http://wiki.eclipse.org/PTP/sync-projects">PTP Wiki页面上的同步项目使用信息</a> 。

</p><p> </p><p> </p><p> 

</p><p>见<a href="localVsRemote.html">本地比。远程项目</a> ，了解有关不同类型的本地和远程项目的更多信息。</p><p> 
</p><p><a href="#top">回到顶部</a> | <a href="toc.html">返回目录</a>
</p></body>

</html><html id="0572.index.html" dir="ltr"></html><html dir="ltr">

<head>
<title>用户指南（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="User's Guide (CDO Model Repository Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>用户指导</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="../Overview.html" title="后退到概述"><img src="../../images/backward.png" border="0"></a> <a href="Doc01_UserInterface.html" title="转发到用户界面的元素"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p>
</p><table border="0">
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc01_UserInterface.html" title="CDO模型存储库文档中的文章">用户界面的元素</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_ExplorerPerspective" title="CDO模型存储库文档中的章节">CDO Explorer透视图</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_AdministrationView" title="CDO模型存储库文档中的章节">CDO管理视图</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_CollaborationView" title="CDO模型存储库文档中的章节">CDO协作视图</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_WatchListView" title="CDO模型存储库文档中的章节">CDO观察列表视图</a></td></tr>
<tr><td></td><td>6</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO时间机器视图</a></td></tr>
<tr><td></td><td>7</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">CDO会话视图</a></td></tr>
<tr><td></td><td>8</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_ServerBrowser" title="CDO模型存储库文档中的章节">CDO服务器浏览器</a></td></tr>
<tr><td></td><td>9</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">CDO结账向导</a></td></tr>
<tr><td></td><td>10</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_ModelEditor" title="CDO模型存储库文档中的章节">CDO模型编辑器</a></td></tr>
<tr><td></td><td>11</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer集成</a></td></tr>
<tr><td></td><td>12</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_PropertySheetIntegration" title="CDO模型存储库文档中的章节">物业单整合</a></td></tr>
<tr><td></td><td>13</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史整合</a></td></tr>
<tr><td></td><td>14</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_CompareIntegration" title="CDO模型存储库文档中的章节">比较整合</a></td></tr>
<tr><td></td><td>15</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_FormsIntegration" title="CDO模型存储库文档中的章节">表单集成</a></td></tr>
<tr><td></td><td>16</td><td class="te" colspan="4"><a href="Doc01_UserInterface.html#Doc_PreferencePages" title="CDO模型存储库文档中的章节">偏好页面</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc02_ManagingRepositories.html" title="CDO模型存储库文档中的文章">管理存储库</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">创建存储库和连接</a></td></tr>
<tr><td></td><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RemoteRepositories" title="CDO模型存储库文档中的章节">连接到远程存储库</a></td></tr>
<tr><td></td><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_CloneRepositories" title="CDO模型存储库文档中的章节">克隆主存储库</a></td></tr>
<tr><td></td><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">创建本地存储库</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_RenamingConnections" title="CDO模型存储库文档中的章节">重命名存储库连接</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_DeletingConnections" title="CDO模型存储库文档中的章节">删除存储库连接</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接和断开存储库</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowIn" title="CDO模型存储库文档中的章节">在其他视图中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.1</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInSessions" title="CDO模型存储库文档中的章节">在CDO会话视图中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.2</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInServerBrowser" title="CDO模型存储库文档中的章节">在CDO服务器浏览器中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.3</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInProperties" title="CDO模型存储库文档中的章节">在属性视图中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.4</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInHistory" title="CDO模型存储库文档中的章节">在历史记录视图中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.5</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInProjectExplorer" title="CDO模型存储库文档中的章节">在Project Explorer中显示存储库</a></td></tr>
<tr><td></td><td></td><td>5.6</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInSystemExplorer" title="CDO模型存储库文档中的章节">在系统资源管理器中显示存储库</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc03_UsingBranches.html" title="CDO模型存储库文档中的文章">与分支机构合作</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc03_UsingBranches.html#Doc_CreatingBranches" title="CDO模型存储库文档中的章节">创建分支</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc03_UsingBranches.html#Doc_RenamingBranches" title="CDO模型存储库文档中的章节">重命名分支</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc03_UsingBranches.html#Doc_DeletingBranches" title="CDO模型存储库文档中的章节">删除分支</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc03_UsingBranches.html#Doc_BranchShowInHistory" title="CDO模型存储库文档中的章节">在历史视图中显示分支</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库中签出</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutRepository" title="CDO模型存储库文档中的章节">选择存储库</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutType" title="CDO模型存储库文档中的章节">选择结帐类型</a></td></tr>
<tr><td></td><td></td><td>2.1</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">在线交易结账</a></td></tr>
<tr><td></td><td></td><td>2.2</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_HistoricalCheckouts" title="CDO模型存储库文档中的章节">在线历史结帐</a></td></tr>
<tr><td></td><td></td><td>2.3</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">离线结账</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutBranchPoint" title="CDO模型存储库文档中的章节">选择分支点</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutRootObject" title="CDO模型存储库文档中的章节">选择根对象</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutName" title="CDO模型存储库文档中的章节">命名结帐</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc05_UsingCheckouts.html" title="CDO模型存储库文档中的文章">使用Checkout</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_RenamingCheckouts" title="CDO模型存储库文档中的章节">重命名结帐</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_DuplicatingCheckouts" title="CDO模型存储库文档中的章节">复制结账</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_OpeningClosing" title="CDO模型存储库文档中的章节">打开和关闭结帐</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_DeletingCheckouts" title="CDO模型存储库文档中的章节">删除结帐</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranch" title="CDO模型存储库文档中的章节">切换结账的分支</a></td></tr>
<tr><td></td><td></td><td>5.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchNewBranch" title="CDO模型存储库文档中的章节">切换到新分支</a></td></tr>
<tr><td></td><td></td><td>5.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranch" title="CDO模型存储库文档中的章节">切换到其他分支</a></td></tr>
<tr><td></td><td>6</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranchPoint" title="CDO模型存储库文档中的章节">切换结账的时间戳</a></td></tr>
<tr><td></td><td></td><td>6.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranchPoint" title="CDO模型存储库文档中的章节">切换到其他分支点</a></td></tr>
<tr><td></td><td></td><td>6.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchCommit" title="CDO模型存储库文档中的章节">切换到提交</a></td></tr>
<tr><td></td><td>7</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_ComparingCheckouts" title="CDO模型存储库文档中的章节">比较结账</a></td></tr>
<tr><td></td><td></td><td>7.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranch" title="CDO模型存储库文档中的章节">与其他分支比较</a></td></tr>
<tr><td></td><td></td><td>7.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranchPoint" title="CDO模型存储库文档中的章节">与其他分支点比较</a></td></tr>
<tr><td></td><td></td><td>7.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareCommit" title="CDO模型存储库文档中的章节">与提交相比</a></td></tr>
<tr><td></td><td>8</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_MergingCheckouts" title="CDO模型存储库文档中的章节">合并结账</a></td></tr>
<tr><td></td><td></td><td>8.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranch" title="CDO模型存储库文档中的章节">从其他分支合并</a></td></tr>
<tr><td></td><td></td><td>8.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranchPoint" title="CDO模型存储库文档中的章节">从其他分支点合并</a></td></tr>
<tr><td></td><td></td><td>8.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeCommit" title="CDO模型存储库文档中的章节">从提交中合并</a></td></tr>
<tr><td></td><td>9</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowIn" title="CDO模型存储库文档中的章节">在其他视图中显示结帐</a></td></tr>
<tr><td></td><td></td><td>9.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInSessions" title="CDO模型存储库文档中的章节">在CDO会话视图中显示结帐</a></td></tr>
<tr><td></td><td></td><td>9.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInTimeMachine" title="CDO模型存储库文档中的章节">在CDO时间机器视图中显示结帐</a></td></tr>
<tr><td></td><td></td><td>9.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInServerBrowser" title="CDO模型存储库文档中的章节">在CDO服务器浏览器中显示Checkout</a></td></tr>
<tr><td></td><td></td><td>9.4</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInProperties" title="CDO模型存储库文档中的章节">在属性视图中显示结帐</a></td></tr>
<tr><td></td><td></td><td>9.5</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInHistory" title="CDO模型存储库文档中的章节">在历史记录视图中显示结帐</a></td></tr>
<tr><td></td><td></td><td>9.6</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInSystemExplorer" title="CDO模型存储库文档中的章节">在系统资源管理器中显示Checkouts</a></td></tr>
<tr><td></td><td>10</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_UsingOfflineCheckouts" title="CDO模型存储库文档中的章节">使用脱机结帐</a></td></tr>
<tr><td></td><td></td><td>10.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">更新脱机结帐</a></td></tr>
<tr><td></td><td></td><td>10.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineCheckin" title="CDO模型存储库文档中的章节">签入离线结账</a></td></tr>
<tr><td></td><td></td><td>10.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineRevert" title="CDO模型存储库文档中的章节">还原离线结帐</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc06_UsingResources.html" title="CDO模型存储库文档中的文章">使用文件夹和资源</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc06_UsingResources.html#Doc_CreatingResourceNodes" title="CDO模型存储库文档中的章节">创建资源节点</a></td></tr>
<tr><td></td><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc06_UsingResources.html#Doc_CreatingFolders" title="CDO模型存储库文档中的章节">创建文件夹</a></td></tr>
<tr><td></td><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc06_UsingResources.html#Doc_CreatingModelResources" title="CDO模型存储库文档中的章节">创建模型资源</a></td></tr>
<tr><td></td><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc06_UsingResources.html#Doc_CreatingTextFiles" title="CDO模型存储库文档中的章节">创建文本文件</a></td></tr>
<tr><td></td><td></td><td>1.4</td><td class="te" colspan="3"><a href="Doc06_UsingResources.html#Doc_CreatingBinaryFiles" title="CDO模型存储库文档中的章节">创建二进制文件</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc06_UsingResources.html#Doc_RenamingResourceNodes" title="CDO模型存储库文档中的章节">重命名资源节点</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc06_UsingResources.html#Doc_MovingResourceNodes" title="CDO模型存储库文档中的章节">在结帐中移动和复制资源节点</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc06_UsingResources.html#Doc_TransferingResourceNodes" title="CDO模型存储库文档中的章节">在Checkout和更远之间移动和复制资源节点</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc06_UsingResources.html#Doc_DeletingResourceNodes" title="CDO模型存储库文档中的章节">删除资源节点</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc07_UsingModels.html" title="CDO模型存储库文档中的文章">使用模型和模型元素</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_CreatingModelElements" title="CDO模型存储库文档中的章节">创建模型元素</a></td></tr>
<tr><td></td><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc07_UsingModels.html#Doc_CreatingRootElements" title="CDO模型存储库文档中的章节">创建根模型元素</a></td></tr>
<tr><td></td><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc07_UsingModels.html#Doc_CreatingNestedElements" title="CDO模型存储库文档中的章节">创建嵌套模型元素</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_MovingModelElements" title="CDO模型存储库文档中的章节">在结帐中移动和复制模型元素</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_TransferingModelElements" title="CDO模型存储库文档中的章节">在结帐之间移动和复制模型元素</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_DeletingModelElements" title="CDO模型存储库文档中的章节">删除模型元素</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_EditingModelElements" title="CDO模型存储库文档中的章节">在对话框中编辑模型元素</a></td></tr>
<tr><td></td><td>6</td><td class="te" colspan="4"><a href="Doc07_UsingModels.html#Doc_EditingModelElementsEditor" title="CDO模型存储库文档中的章节">在编辑器中编辑模型元素</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc08_Collaborating.html" title="CDO模型存储库文档中的文章">实时协作</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc08_Collaborating.html#Doc_OptimisticLocking" title="CDO模型存储库文档中的章节">乐观锁定</a></td></tr>
<tr><td></td><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc08_Collaborating.html#Doc_EarlyConflictDetection" title="CDO模型存储库文档中的章节">早期冲突检测</a></td></tr>
<tr><td></td><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc08_Collaborating.html#Doc_AutomaticConflictResolution" title="CDO模型存储库文档中的章节">自动冲突解决</a></td></tr>
<tr><td></td><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc08_Collaborating.html#Doc_InteractiveConflictResolution" title="CDO模型存储库文档中的章节">互动冲突解决方案</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc08_Collaborating.html#Doc_PessimisticLocking" title="CDO模型存储库文档中的章节">悲观锁定</a></td></tr>
<tr><td></td><td></td><td>2.1</td><td class="te" colspan="3"><a href="Doc08_Collaborating.html#Doc_TreeLocking" title="CDO模型存储库文档中的章节">树锁定</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc08_Collaborating.html#Doc_AutomaticLocking" title="CDO模型存储库文档中的章节">自动锁定</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc08_Collaborating.html#Doc_AutomaticCommitting" title="CDO模型存储库文档中的章节">自动提交</a></td></tr>
<tr><td><img src="../../images/article.gif"> </td><td class="te" colspan="5"><a href="Doc09_TechnicalBackground.html" title="CDO模型存储库文档中的文章">了解技术背景</a></td></tr>
<tr><td></td><td>1</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundModelElements" title="CDO模型存储库文档中的章节">模型元素的技术背景</a></td></tr>
<tr><td></td><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundNativeModels" title="CDO模型存储库文档中的章节">原生模特</a></td></tr>
<tr><td></td><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundLegacyModels" title="CDO模型存储库文档中的章节">遗产模型</a></td></tr>
<tr><td></td><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundDynamicModels" title="CDO模型存储库文档中的章节">动态模型</a></td></tr>
<tr><td></td><td>2</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundRepositories" title="CDO模型存储库文档中的章节">存储库的技术背景</a></td></tr>
<tr><td></td><td>3</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundCheckouts" title="CDO模型存储库文档中的章节">结帐技术背景</a></td></tr>
<tr><td></td><td>4</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundSessions" title="CDO模型存储库文档中的章节">会议的技术背景</a></td></tr>
<tr><td></td><td>五</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundViews" title="CDO模型存储库文档中的章节">观点的技术背景</a></td></tr>
<tr><td></td><td>6</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundTransactions" title="CDO模型存储库文档中的章节">交易技术背景</a></td></tr>
<tr><td></td><td>7</td><td class="te" colspan="4"><a href="Doc09_TechnicalBackground.html#Doc_BackgroundCompare" title="CDO模型存储库文档中的章节">比较整合的技术背景</a></td></tr>
</table>



<p align="right">
<a href="../Overview.html" title="后退到概述"><img src="../../images/backward.png" border="0"></a> <a href="Doc01_UserInterface.html" title="转发到用户界面的元素"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="2656.p2_actions_touchpoints.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2010, 2011. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<meta http-equiv="Content-Style-Type" content="text/css"></meta>
<link rel="STYLESHEET" href="../book.css" type="text/css" charset="ISO-8859-1"></link>
<title>供应操作和接触点</title>
</head>
<body dir="ltr">
<h1>供应操作和接触点</h1>
<h2>介绍</h2>
<p>使用<i>接触点</i>提供的功能安装p2可安装单元（IU）。IU元数据包括对接触点的引用（接触点类型），其也定义接触点的版本（即，它支持某一组操作的期望），并描述在各种p2引擎阶段中执行的指令。这些说明以阶段命名 - 在创作时，“安装”，“卸载”，“配置”，“取消配置”阶段是有意义的，但也有一些内部阶段，例如“收集”和“检查信任”由发动机。每条指令（例如“安装”）描述了在引用的接触点上执行的一系列动作。操作示例包括：创建和删除目录，更改权限，安装和删除包。目前，已经实现了两个接触点（本机和日食）。原生接触点有大约5种不同的动作，而eclipse接触点大约有20种。大多数这些操作都采用参数。</p>
<p>指令在接触点数据元素中分组和描述。接触点数据元素使用Map，其中键是p2引擎阶段的名称（例如“install”），值是一系列动作的字符串表示。使用多个接触点数据元素非常有用，因为它允许在安装/卸载/配置/取消配置的操作集之间进行分离，这使得更容易维护元数据。</p>
<h2>操作</h2>
<h3>完全合格的操作名称和导入操作</h3>
<p>每个动作都有一个完全限定的名称;例如，“org.eclipse.equinox.p2.touchpoint.eclipse.installBundle”是Eclipse接触点“installBundle”操作的FQN。如果导入操作或IU“接触点类型”与操作匹配，则可以使用操作的短名称。</p>大多数bundle IU使用Eclipse touchpoint类型，因此您可以使用：<table>
	<tr>
		<td><pre>installBundle（包：$ {}神器）</pre></td>
	</tr>
</table>但是，如果出现如下错误，请使用完全限定名称。
<table>
	<tr>
		<td><pre>java.lang中。IllegalArgumentException：找不到以下操作：installBundle。
</pre></td>
	</tr>
</table>使用FQN对此操作进行有效调用可能类似于：<table>
	<tr>
		<td><pre>org.eclipse.equinox.p2.touchpoint.eclipse.installBundle（包：$ {}神器）</pre></td>
	</tr>
</table>
<h3>原生接触点操作</h3>
<p><b>行动完全合格的名称：</b></p>
<pre>org.eclipse.equinox.p2.touchpoint.natives。 <i>ACTION_NAME</i> 
</pre>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>行动</b></td>
		<td><b>参数</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">搜集</td>
		<td>-</td>
		<td>收集IU的所有相关工件并将它们放在本地接触点可寻址缓存中。此操作可以在收集阶段显式调用，但通常称为“默认”操作，调用具有本机接触点类型作为主收集和调整阶段的一部分的IU。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">cleanupzip</td>
		<td><code>来源，目标</code></td>
		<td>删除从<i>源</i> <i>解压缩</i>到<i>目标</i>的<i>解</i>压缩文件和目录 - 即<i>解压缩</i>指令的“撤消操作”。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">拉开拉链</td>
		<td>来源，目标</td>
		<td>将<i>源</i>解压缩到<i>目标</i>目录中。<i>源</i>可以是特殊值<code>@artifact</code> ，它表示可安装单元中第一个工件密钥的下载缓存位置。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">MKDIR</td>
		<td>路径</td>
		<td>创建参数<i>path</i>指定的目录。
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">命令rmdir</td>
		<td>路径</td>
		<td>删除参数<i>path</i>指定的目录。如果引用的目录包含文件，则Action不起作用。使用<i>remove</i>操作进行强制递归删除。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">LN</td>
		<td>targetDir，linkTarget，linkName，force</td>
		<td>使用参数<i>linkTarget</i>作为源文件执行系统操作<code>ln -s</code> ， <i>targetDir</i>是将创建符号链接的目录， <i>linkName</i>是<i>targetDir</i>中生成的链接的<i>名称</i> 。 <i>force</i>参数是字符串形式的布尔值（即“true”/“false”），表示在创建新链接之前是否应删除具有相同名称的现有链接。
		<p><em>在没有此命令的平台上（即Windows），此操作不可用</em></p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">CHMOD</td>
		<td>targetDir，targetFile，权限，选项</td>
		<td>使用system <code>chmod</code>命令更改文件的权限。<i>targetDir</i>参数是路径，或者是特殊的<code>@artifact</code> ，它是对可安装单元中包含的第一个工件所在目录的引用。参数<i>targetFile</i>是文件的名称， <i>权限</i>的编写方式与<i>chmod</i> system命令类似。options参数允许传递其他选项，如“-R”，用于递归操作。如果需要多个参数，请用空格分隔它们（就像在命令行上一样）。
		<p><em>这在没有此命令的平台上不可用（即Windows）</em></p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">去掉</td>
		<td>路径</td>
		<td>删除参数<i>路径</i>引用的文件或目录（以及此目录下的所有文件）。
		<p><br>（自3.5起）</p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">复制</td>
		<td>来源，目标，覆盖</td>
		<td>将<i>源</i>路径表示的文件或目录（及其所有内容）复制到<i>目标</i>路径。
		<p>如果复制操作应覆盖现有文件，则应将布尔标志<i>覆盖</i>设置为<i>true</i> 。如果overwrite为<i>false，</i>则操作将失败，并且文件中已存在IO错误。
		<br>（自3.5起）</p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">cleanupcopy</td>
		<td>来源，目标</td>
		<td>使用从<i>源</i>到<i>目标</i>的<i>副本</i>清除之前安装的内容。即这是<i>复制</i>操作的“撤消”。
		<p><br>（自3.5起）</p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">checkAndPromptNativePackage</td>
		<td>发行，包装，[比较器，版本]</td>
		<td>如果尚未安装包，则提示用户输入已识别的包。 <i>发行版</i>识别包适用的<i>发行版</i> 。 <i>package</i>是OS已知的包标识符。 <i>version</i>是一个可选字符串，用于捕获包的预期版本。 <i>比较器</i>来自<i>eq，gt，ge，lt，le</i>的可选字符串<i>，</i>用于表示要安装的版本的更具体的依赖关系。知道在这一点上只支持Ubuntu，我们欢迎支持其他操作系统。<p>例：</p><pre>org.eclipse.equinox.p2.touchpoint.natives.checkAndPromptNativePackage（发行版：Debian的，包：须藤）;</pre>要么<pre>org.eclipse.equinox.p2.touchpoint.natives.checkAndPromptNativePackage（发行版：Debian的，包：手刹，比较：GE，版本：0.9）;</pre>
		<p>（自4.5起）</p>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">checkAndPromptNativePackageWindowsRegistry</td>
		<td>包，密钥，[attributeName，attributeValue，downloadLink，version]</td>
		<td>如果尚未安装Windows注册表中标识的Windows库，则提示用户。 <i>package</i>是描述性库标识符。 <i>version</i>是描述性版本字符串。 <i>key</i>是完整的注册表项。 <i>attributeName</i>和<i>attributeValue</i>是要检查的注册表属性的可选名称和值。 <i>downloadLink</i>是一个可选的URL，用于在UI中显示可从中获取库的URL。
		<p>例：</p><pre>org.eclipse.equinox.p2.touchpoint.natives.checkAndPromptNativePackageWindowsRegistry（\ package：MS VC Runtime，\ version：2010，\ key：HKLM \\ SOFTWARE \\ Wow6432Node \\ Microsoft \\ VisualStudio \\ 10.0 \\ VC \\ VCRedist \\ x64，\ attributeName：已安装，\ attributeValue：1，\ downloadLink：http $ {＃58} // www.microsoft.com/download/details.aspx？ID = 14632）;</pre>
		<p>（自4.5起）</p>
		</td>
	</tr>
</table>
<h3>Eclipse Touchpoint操作</h3>
<p><b>行动完全合格的名称：</b></p>
<pre>org.eclipse.equinox.p2.touchpoint.eclipse。 <i>ACTION_NAME</i> 
</pre>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>指令</b></td>
		<td><b>参数</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">搜集</td>
		<td>-</td>
		<td>收集IU的所有相关工件并将它们放在本地接触点可寻址缓存中。此操作可以在收集阶段显式调用，但通常称为“默认”操作，调用IU，Eclipse Touchpoint Type作为主要收集和调整阶段的一部分。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">installBundle</td>
		<td>束</td>
		<td>安装参数<i>包</i>指定的包工件
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">uninstallBundle</td>
		<td>束</td>
		<td>使用参数<i>包</i>指定的bundle-id卸载包工件</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">addSourceBundle</td>
		<td>束</td>
		<td>使用参数<i>bundle</i>指定的bundle-id安装源包工件</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">removeSourceBundle</td>
		<td>束</td>
		<td>使用参数<i>bundle</i>指定的bundle-id删除/卸载源包工件</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">installFeature</td>
		<td>feature，featureId，version</td>
		<td>安装参数功能引用的<i>功能</i> （与iu中的工件匹配）。使用参数<i>featureId</i>指定的id安装该功能，或者如果此参数的值为<code>default</code> ，则在<i>功能</i>引用的工件中指定id。如果<i>版本</i>参数的值为<code>default</code> ，则使用版本中指定的<i>版本</i>或使用<i>feature</i>参数引用的工件中指定的<i>版本</i>安装这些功能</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">uninstallFeature</td>
		<td>feature，featureId，version</td>
		<td>卸载功能。参数与命令<code>installFeature</code>含义相同</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setLauncherName</td>
		<td>名称</td>
		<td>将启动器的名称设置为<code>name</code> 。启动器名称用于配置启动器名称特定的ini文件。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">addProgramArg</td>
		<td>programArg</td>
		<td>将参数<i>programArg中</i>指定的字符串作为参数添加到程序中。如果参数是特殊值<code>@artifact</code> ，则IU中第一个工件密钥引用的工件的位置将用作参数值。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">removeProgramArg</td>
		<td>programArg</td>
		<td>除去了串<i>programArg</i>指定的程序参数-如果所述参数是所述特殊值<code>@artifact</code> ，通过在IU第一工件键所引用的工件的位置被用作所述参数值。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setStartLevel</td>
		<td>STARTLEVEL</td>
		<td>将起始级别设置为参数<i>startValue中</i>指定的整数值</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">markStarted</td>
		<td>开始</td>
		<td>将可安装单元中第一个工件键引用的包标记为已启动或未启动，由boolean参数<i>start控制</i> 。参数值“true”将捆绑标记为已启动，“false”将捆绑标记为未启动。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setFrameworkDependentProperty</td>
		<td>propName，propValue</td>
		<td>将名为<i>propName</i>的框架相关属性设置为<i>propValue中</i>指定的值。依赖于框架的属性是特定于OSGi框架的Equinox实现的属性。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setFrameworkIndependentProperty</td>
		<td>propName，propValue</td>
		<td>将名为<i>propName</i>的框架独立属性设置为<i>propValue中</i>指定的值。与框架无关的属性并不专门针对Eclipse，并且通常适用于其他OSGi框架。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">addProgramProperty</td>
		<td>propName，propValue</td>
		<td>将<i>propValue中</i>指定的给定值添加到名为<i>propName</i>的程序属性中。程序属性值被视为以逗号分隔的列表，并将给定值添加到该列表中。可执行程序使用程序属性来定位启动Eclipse所需的jar。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">removeProgramProperty</td>
		<td>propName，propValue</td>
		<td>从名为<i>propName</i>的程序属性中删除<i>propValue中</i>指定的给定值。程序属性值被视为以逗号分隔的列表，并从该列表中删除给定值。如果列表中没有更多元素，则删除属性本身。可执行程序使用程序属性来定位启动Eclipse所需的jar。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setProgramProperty</td>
		<td>propName，propValue</td>
		<td>将名为<i>propName</i>的程序属性设置为<i>propValue中</i>指定的值。可执行程序使用程序属性来定位启动Eclipse所需的jar。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">addJvmArg</td>
		<td>jvmArg</td>
		<td>将参数<i>jvmArg中</i>指定的字符串添加到传递给JVM的参数中。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">removeJvmArg</td>
		<td>jvmArg</td>
		<td>从传递给JVM的参数中删除参数<i>jvmArg中</i>指定的字符串。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">setJvm</td>
		<td>JVM</td>
		<td>将JVM设置为参数<i>jvm中</i>指定的路径。如果指定<i>null</i>值，则删除当前JVM路径值。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">checkTrust</td>
		<td>-</td>
		<td>收集应在其上执行签名信任检查的捆绑文件集。checkTrust操作不是用户可调用的，而是作为CheckTrust阶段的一部分完成的。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">addRepository</td>
		<td>位置，类型，已启用</td>
		<td>将类型<i>类型</i> <i>位置</i>的存储库添加到已知存储库列表中。在将来安装或更新配置文件时，存储库将可用。<i>enabled</i>参数采用布尔值（“true”或“false”），指示是否应启用添加存储库。<i>location</i>参数的值必须是格式正确的URI。 <i>类型</i>参数值必须是其中一个IRepository的值。TYPE_ *常量，具体而言，类型“0”表示元数据存储库，类型“1”表示工件存储库。
		<p><i>例：</i></p>
		<pre>instructions.configure = org.eclipse.equinox.p2.touchpoint.eclipse.addRepository（位置：http $ {＃58} // download.eclipse.org/birt/update-site/2.5/,type:0,name:BIRT 2.5，启用：真）; \ org.eclipse.equinox.p2.touchpoint.eclipse.addRepository（位置：http $ {＃58} // download.eclipse.org/birt/update-site/2.5/,type:1,name:BIRT 2.5，已启用：真正）;</pre></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">removeRepository</td>
		<td>位置，类型</td>
		<td>从已知列表中删除类型<i>类型</i> <i>位置</i>的存储库<p>库。<i>location</i>参数的值必须是格式正确的URI。 <i>类型</i>参数值必须是其中一个IRepository的值。TYPE_ *常量，具体而言，类型“0”表示元数据存储库，类型“1”表示工件存储库。</p>
		</td>
	</tr>
</table>
<h2>行动格式</h2>
<p>Touchpoint数据元素有一个Map，用于描述在各种p2引擎阶段中执行的操作（例如“install”，“uninstall”，“configure”，“unconfigure”，“collect”和“checktrust”）。Map条目的关键是阶段的名称（即应该执行的操作），并且值是<i>语句序列</i> ：</p>
<pre>语句序列：|声明';' |语句序列语句;</pre>
<p>如果声明的格式如下：</p>
<pre>声明：| actionName'（'parameters'）';</pre>
<pre>参数：| //空|参数|参数'，'参数;</pre>
<pre>参数：| paramName'：'paramValue; actionName，paramName，paramValue：|字符串;</pre>
<p>在p2引擎中，Phase将使用它自己的阶段特定操作（例如“collect”）以及相关联的接触点（例如本机接触点中的“mkdir”和“installBundle”）中的那些查找“actionName”。 Eclipse接触点）。</p>
<p>例如，bundle的“install”指令可能包含以下语句：</p>
<pre>installBundle（束：$ {工件}）;</pre>
<ul>
	<li><i>installBundle</i>是操作名称</li>
	<li><i>bundle</i>是参数名称</li>
	<li><i>$ {artifact}</i>是参数值。值$ {artifact}表示使用名为“artifact”的预定义变量。</li>
</ul>
<h2>内置动作变量</h2>
<p>以下是阶段和接触点提供的变量目录。其中许多对于新操作和接触点类型的实现者大多有用。</p>
<h3>变量适用于所有阶段</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">为#nnnn</td>
		<td>一个字符的unicode值。
		<p><i>注意：这对于需要转义的六个字符尤为重要。</i></p>
		<ol>
			<li>$ = $ {＃36}</li>
			<li>，= $ {＃44}</li>
			<li>：= $ {＃58}</li>
			<li>; = $ {＃59}</li>
			<li>{= $ {＃123}</li>
			<li>} = $ {＃125}</li>
		</ol>
		</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">轮廓</td>
		<td>正在修改的配置文件。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">phaseId</td>
		<td>阶段的名称，例如收集，安装等</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">操作数</td>
		<td>动作操作数（例如IU对）</td>
	</tr>
</table>
<h3>变量适用于所有可安装的单元阶段</h3>
<p><i>例如，收集，取消配置，卸载，安装，配置，......</i></p>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">installFolder</td>
		<td>此配置文件的根文件夹。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">接触点</td>
		<td>与操作数中的IU相关联的接触点（如果适用）</td>
	</tr>
</table>
<h3>收集阶段变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">artifactRequests</td>
		<td>接触点“收集”操作的列表将用于添加镜像请求。</td>
	</tr>
</table>
<h3>取消配置相位变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">IU</td>
		<td>IU未配置。这是从操作数对的第一个IU设置的。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">神器</td>
		<td>IU中列出的第一个工件的工件ID。</td>
	</tr>
</table>
<h3>卸载阶段变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">IU</td>
		<td>IU正在卸载。这是从操作数对的第一个IU设置的。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">神器</td>
		<td>IU中列出的第一个工件的工件ID。</td>
	</tr>
</table>
<h3>安装阶段变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">IU</td>
		<td>IU正在安装。这是从操作数对的第二个IU设置的。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">神器</td>
		<td>IU中列出的第一个工件的工件ID。</td>
	</tr>
</table>
<h3>配置相位变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">IU</td>
		<td>正在配置IU。这是从操作数对的第二个IU设置的。</td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">神器</td>
		<td>IU中列出的第一个工件的工件ID。</td>
	</tr>
</table>
<h3>Eclipse Touchpoint变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">机械手</td>
		<td>用于更改Eclipse安装配置的Manipulator类的实例。</td>
	</tr>
</table>
<h3>原生接触点变量</h3>
<table border="1" cellpadding="5" style="border:1px solid #ccc;border-collapse:collapse">

	<tr valign="top" style="background-color:#eeeeee;color:#444444">
		<td><b>变量</b></td>
		<td><b>描述</b></td>
	</tr>
	<tr valign="top">
		<td style="font-weight:bold">备用</td>
		<td>BackupStore用于在本机文件操作期间保存事务状态。</td>
	</tr>
</table>
<h2>有关备份文件操作操作的附加说明</h2>
<p>Native Touchpoint存储在安装过程中删除或覆盖的文件的临时备份。如果安装成功，则只需删除备份。但是，如果安装失败，则备份中的文件将还原到其原始位置。如果还原按预期工作，则还会删除备份副本。两个“灾难”案件仍然存在：</p>
<ul>
	<li>无法恢复文件（可能是因为硬件故障，磁盘用完，或者在安装过程中手动篡改文件）。</li>
	<li>系统在安装过程中崩溃了</li>
</ul>
<p>备份放在系统属性“java.io.tmpdir”引用的目录下的目录中。备份目录的名称前缀为“.p2bu”，后面是每个正在运行的备份实例的唯一键。在“.p2bu ...”目录下，文件存储在反映其原始位置的层次结构中。</p>
<p>在这两种灾难情况下，java.io.tempdir下的备份存储将包含未自动还原的所有文件的副本。如果需要恢复，可以通过将内容复制回原始位置来手动执行（从“.p2bu”下的结构可以看出这一点）。这可以使用zip之类的工具（只需将相对于.p2bu的所有内容压缩，然后从真实的文件系统根目录解压缩）。</p>
<p>如果在恢复备份期间出现问题，将记录事件，并详细说明需要手动恢复的内容。这是尽力支持，因此在系统崩溃的情况下可能会丢失文件。</p>
</body>
</html><html id="3200.DateTime.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>约会时间</title>
<link rel="stylesheet" type="text/css" href="../../style.css"></link>
<style type="text/css">h2 {
  margin: 20px 0 5px;
  padding: 5px 10px;
  background-color: #ccccff;
  border: 1px solid black;
}
h3 {
  margin: 15px 0 5px;
  padding: 5px 10px;
  background-color: #eeeeff;
  border: 1px solid black;
}
ul {
  list-style-type: none;
  padding: 0;
  margin: 8px 0 8px 18px;
}
li {
  margin: -1px 0 0;
  padding: 2px 5px;
  border: 1px solid black;
}
h2+p {
  margin: 10px 0 5px 12px;
}
h3+p {
  margin: 8px 0 3px 24px;
}
.deprecated {
  text-decoration: line-through;
}
.css-name {
  font-weight: bold;
  color: #0000aa;
}
.css-desc {
  margin: 1px 0 2px 20px;
}
</style>
</head>
<body dir="ltr">
<span><a href="index.html">RWT主题参考</a> &gt;日期时间</span> <a name="DateTime">  </a>
<h2>约会时间</h2>
<p>DateTime控件</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">背景颜色</p>
</li>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime的背景渐变。不适用于DateTime日历。
      </p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕DateTime绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">DateTime的底边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">DateTime的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-radius" class="css-name">边界半径</a>
<p class="css-desc">边界半径。如果使用增强边框（如“inset”或“outset”），则边框半径无效。
      </p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">DateTime的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">DateTime的顶部边框。</p>
</li>
<li>
<a href="Properties.html#box-shadow" class="css-name">箱阴影</a>
<p class="css-desc">DateTime小部件边界周围的内部或外部阴影。</p>
</li>
<li>
<a href="Properties.html#color" class="css-name">颜色</a>
<p class="css-desc">DateTime的文本颜色。</p>
</li>
<li>
<a href="Properties.html#font" class="css-name">字形</a>
<p class="css-desc">DateTime的文本字体。不适用于DateTime日历。
      </p>
</li>
<li>
<a href="Properties.html#padding" class="css-name">填充</a>
<p class="css-desc">填充DateTime日期/时间。</p>
</li>
<li>
<a href="Properties.html#text-shadow" class="css-name">文字阴影</a>
<p class="css-desc">文字的阴影。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[边界]</span>
<p class="css-desc">边界行为的样式常量。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于已停用的DateTime控件。</p>
</li>
<li>
<span class="css-name">：重点</span>
<p class="css-desc">适用于聚焦的DateTime控件。</p>
</li>
</ul>
<a name="DateTime-Field">  </a>
<h2>日期时间场</h2>
<p>日期，月份，年份，小时，分钟，秒的字段</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">DateTime字段的背景颜色</p>
</li>
<li>
<a href="Properties.html#color" class="css-name">颜色</a>
<p class="css-desc">DateTime字段的文本颜色。</p>
</li>
<li>
<a href="Properties.html#padding" class="css-name">填充</a>
<p class="css-desc">日期时间日期/时间字段部分的填充。</p>
</li>
<li>
<a href="Properties.html#text-shadow" class="css-name">文字阴影</a>
<p class="css-desc">文字的阴影。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：选择</span>
<p class="css-desc">适用于选定的DateTime字段。</p>
</li>
</ul>
<a name="DateTime-Calendar-Day">  </a>
<h2>日期时间日历天</h2>
<p>日历的一天</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">背景颜色</p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">在日历日框周围绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">日历日框的底部边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">日历日框的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">日历日框的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">日历日框的顶部边框。</p>
</li>
<li>
<a href="Properties.html#color" class="css-name">颜色</a>
<p class="css-desc">文字颜色</p>
</li>
<li>
<a href="Properties.html#text-shadow" class="css-name">文字阴影</a>
<p class="css-desc">文字的阴影。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">适用于用户在日历日盘旋的情况。</p>
</li>
<li>
<span class="css-name">：otherMonth</span>
<p class="css-desc">适用于属于其他月份的日期。</p>
</li>
<li>
<span class="css-name">：选择</span>
<p class="css-desc">适用于选定日期。</p>
</li>
<li>
<span class="css-name">：今天</span>
<p class="css-desc">适用于当天。</p>
</li>
<li>
<span class="css-name">：聚焦</span>
<p class="css-desc">适用于不专心的日历上的那一天。</p>
</li>
</ul>
<a name="DateTime-Calendar-Navbar">  </a>
<h2>日期时间，日历，导航栏</h2>
<p>日历导航栏</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">背景颜色</p>
</li>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">日历导航栏背景图像或渐变</p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕日历导航栏绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">日历导航栏的底部边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">日历导航栏的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-radius" class="css-name">边界半径</a>
<p class="css-desc">边界半径。如果使用增强边框（如“inset”或“outset”），则边框半径无效。
        </p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">日历导航栏的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">日历导航栏的顶部边框。</p>
</li>
<li>
<a href="Properties.html#color" class="css-name">颜色</a>
<p class="css-desc">文字颜色</p>
</li>
<li>
<a href="Properties.html#font" class="css-name">字形</a>
<p class="css-desc">日历导航栏的文本字体。
        </p>
</li>
<li>
<a href="Properties.html#text-shadow" class="css-name">文字阴影</a>
<p class="css-desc">文字的阴影。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于已停用的DateTime控件。</p>
</li>
</ul>
<a name="DateTime-Calendar-PreviousMonthButton">  </a>
<h2>日期时间，日历，PreviousMonthButton</h2>
<p>上个月的日历按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">日历上个月按钮的背景图像。图像的大小应为16 x 16像素。
        </p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">日历上个月按钮光标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示日历从右向左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于已禁用的日历上个月按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
</ul>
<a name="DateTime-Calendar-NextMonthButton">  </a>
<h2>日期时间，日历，NextMonthButton</h2>
<p>下个月的日历按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">日历下个月按钮的背景图像。图像的大小应为16 x 16像素。
        </p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">日历下个月按钮光标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示日历从右向左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于下个月禁用的日历按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
</ul>
<a name="DateTime-Calendar-PreviousYearButton">  </a>
<h2>日期时间，日历，PreviousYearButton</h2>
<p>日历前一年按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">日历前一年按钮的背景图像。图像的大小应为16 x 16像素。
        </p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">日历前一年按钮光标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示日历从右向左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于已禁用的日历上一年按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
</ul>
<a name="DateTime-Calendar-NextYearButton">  </a>
<h2>日期时间，日历，NextYearButton</h2>
<p>明年的日历按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">日历明年按钮的背景图像。图像的大小应为16 x 16像素。
        </p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">明年的日历按钮光标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示日历从右向左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于明年禁用的日历按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
</ul>
<a name="DateTime-UpButton">  </a>
<h2>日期时间，UpButton</h2>
<p>DateTime日期/时间向上按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">DateTime日期/时间向上按钮的背景颜色。
        </p>
</li>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime向上按钮的背景图像或渐变。
        </p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕DateTime日期/时间向上按钮绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">DateTime日期/时间向上按钮的底部边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">DateTime日期/时间向上按钮的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-radius" class="css-name">边界半径</a>
<p class="css-desc">边界半径。如果使用增强边框（如“inset”或“outset”），则边框半径无效。
        </p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">DateTime日期/时间向上按钮的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">DateTime日期/时间向上按钮的顶部边框。</p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">DateTime日期/时间向上按钮光标。</p>
</li>
<li>
<a href="Properties.html#width" class="css-name">宽度</a>
<p class="css-desc">DateTime日期/时间向上按钮的宽度。
        </p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示DateTime从右到左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于禁用的DateTime向上按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-UpButton-Icon">  </a>
<h2>日期时间-UpButton图标</h2>
<p>DateTime向上按钮图标</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime向上按钮的图标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于禁用的DateTime向上按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-DownButton">  </a>
<h2>日期时间，DownButton</h2>
<p>DateTime向下按钮</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">DateTime日期/时间向下按钮的背景颜色。
        </p>
</li>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime向下按钮的背景图像或渐变。
        </p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕DateTime日期/时间向下按钮绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">DateTime日期/时间向下按钮的底部边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">DateTime日期/时间向下按钮的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-radius" class="css-name">边界半径</a>
<p class="css-desc">边界半径。如果使用增强边框（如“inset”或“outset”），则边框半径无效。
        </p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">DateTime日期/时间向下按钮的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">DateTime日期/时间向下按钮的顶部边框。</p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">DateTime日期/时间向下按钮光标。</p>
</li>
<li>
<a href="Properties.html#width" class="css-name">宽度</a>
<p class="css-desc">DateTime日期/时间向下按钮的宽度。
        </p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示DateTime从右到左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于禁用的DateTime向下按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-DownButton-Icon">  </a>
<h2>日期时间-DownButton图标</h2>
<p>DateTime向下按钮图标</p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime向下按钮的图标。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于禁用的DateTime向下按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-DropDownButton">  </a>
<h2>日期时间，DropDownButton</h2>
<p>DateTime下拉按钮。在使用SWT.DROP_DOWN样式时应用。
      </p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-color" class="css-name">背景颜色</a>
<p class="css-desc">DateTime Date下拉按钮的背景颜色。
        </p>
</li>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime下拉按钮的背景图像或渐变。
        </p>
</li>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕DateTime Date下拉按钮绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">DateTime Date下拉按钮的底部边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">DateTime Date下拉按钮的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-radius" class="css-name">边界半径</a>
<p class="css-desc">边界半径。如果使用增强边框（如“inset”或“outset”），则边框半径无效。
        </p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">DateTime Date下拉按钮的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">DateTime Date下拉按钮的顶部边框。</p>
</li>
<li>
<a href="Properties.html#cursor" class="css-name">光标</a>
<p class="css-desc">DateTime Date下拉按钮光标。</p>
</li>
<li>
<a href="Properties.html#width" class="css-name">宽度</a>
<p class="css-desc">DateTime Date下拉按钮的宽度。
        </p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>可以在此元素的选择器中引用的SWT样式标志（作为CSS属性）：</p>
<ul>
<li>
<span class="css-name">[右到左]</span>
<p class="css-desc">表示DateTime从右到左。</p>
</li>
</ul>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：禁用</span>
<p class="css-desc">适用于禁用的DateTime Date下拉按钮。</p>
</li>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-DropDownButton-Icon">  </a>
<h2>日期时间-DropDownButton图标</h2>
<p>下拉按钮图标。
      </p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#background-image" class="css-name">背景图片</a>
<p class="css-desc">DateTime下拉按钮的图标。
        </p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>窗口小部件可以在选择器中引用该元素（作为CSS伪类）：</p>
<ul>
<li>
<span class="css-name">：徘徊</span>
<p class="css-desc">用户将鼠标悬停在按钮上时应用。</p>
</li>
<li>
<span class="css-name">：按下</span>
<p class="css-desc">按下按钮时应用。</p>
</li>
</ul>
<a name="DateTime-DropDownCalendar">  </a>
<h2>日期时间，DropDownCalendar</h2>
<p>DateTime下拉日历。在使用SWT.DROP_DOWN样式时应用。
      </p>
<h3>可用的CSS属性</h3>
<p>可以为此元素定义的属性：</p>
<ul>
<li>
<a href="Properties.html#border" class="css-name">边界</a>
<p class="css-desc">围绕下拉日历绘制的边框。</p>
</li>
<li>
<a href="Properties.html#border-bottom" class="css-name">下边框</a>
<p class="css-desc">下拉日历的底边框。</p>
</li>
<li>
<a href="Properties.html#border-left" class="css-name">左边框</a>
<p class="css-desc">下拉日历的左侧边框。</p>
</li>
<li>
<a href="Properties.html#border-right" class="css-name">右边框</a>
<p class="css-desc">下拉日历的右侧边框。</p>
</li>
<li>
<a href="Properties.html#border-top" class="css-name">边框顶部</a>
<p class="css-desc">下拉日历的顶部边框。</p>
</li>
</ul>
<h3>适用的SWT样式</h3>
<p>
<em>没有</em>
</p>
<h3>适用国家</h3>
<p>
<em>没有</em>
</p>
</body>
</html><html id="3333.Tables.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>表</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingTableEditors">指定表编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingTableEditors">指定表编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#edition_tables">版表</a>
						<ol style="list-style:disc">
							<li>
								<a href="#table_tools">表工具</a>
							</li>
							<li>
								<a href="#line_mappings">线映射</a>
							</li>
							<li>
								<a href="#feature_column_mapping">特征列映射</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#cross_tables">交叉表</a>
						<ol style="list-style:disc">
							<li>
								<a href="#cross_table_tools">表工具</a>
							</li>
							<li>
								<a href="#element_column_mapping">元素列映射</a>
							</li>
							<li>
								<a href="#intersection_mapping">交点映射</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>Sirius支持两种表格建模器的定义：</p>
		<ul>
			<li>
				<em>版本表</em>是经典表格，其中每一行代表一个元素，每一列（来自固定集合）代表元素的某些（可能计算的）属性。行可以包含子行（递归地）来表示子元素，最终用户可以随意展开/折叠它们。如果您指定相应的工具，用户可以创建新行并删除现有行。
			</li>
			<li>
				<em>交叉表</em>略有不同，经过优化，以类似矩阵的方式表示元素之间的关系。行和列都表示元素，如果它们之间存在某种关系，则每个调用在交叉点。交叉表也支持子行，但不支持子列。但是，如果指定了正确的工具，则除了行之外，用户还可以创建和/或删除列。
			</li>
		</ul>
		<p>这两种表共享很多元素。本文档将重点介绍最常用的<a href="#edition_tables">编辑表</a> 。<a href="#cross_tables">关于交叉表</a>的<a href="#cross_tables">部分</a>根据它们与编辑表的不同来描述它们。
		</p> 
		<img border="0" src="./images/table_description_editor.png">
<em>
<ul>
<img src="images/tricks.png" style="display:inline;margin:0px;padding:0px"> <em>使用<img src="images/questionMarque.png" style="display:inline;margin:0px;padding:0px">用于访问可用字段工具提示的图标：</em>
<ul>
			<li> 
		<b>Id</b>字段：此元素的标识符。必须是独特的。更改此标识符将破坏引用旧标识符的现有用户模型。</li>
			<li> 
		<b>标签</b>字段：用于向最终用户显示此标签的标签。</li>
			<li> 
		<b>域类</b>字段：节点表示的元素的类型。</li>
			<li> 
		<b>Semantic Candidates Expression</b>字段：在创建图形元素之前限制要考虑的元素列表。如果未设置，则将浏览会话中的所有语义模型，并且验证前提条件表达式的给定类型的任何元素将导致创建图形元素。如果设置此属性，则仅考虑表达式求值返回的元素。</li>
</ul>
</ul>
</em>
		<p>
			<strong>注意</strong> ：图表中存在的图层，过滤器和映射导入等高级功能目前不适用于表。
		</p>
		<h2 id="edition_tables">版表</h2>
		<p>通过创建<em>版本表描述</em>元素（在<em>视点内</em> ）及其子元素（描述行，列和工具）来配置<em>版本表</em> 。
			<em>版本表描述</em>类似于其他表示描述元素。
		</p>
		<p>强制<em>Domain Class</em>属性是由表表示的语义元素的类型。在<em>模型资源管理器中</em> ，最终用户将能够在此类型的语义元素上创建此表的新实例（假设在<em>建模项目中</em>启用了相应的视点）。域类名称的语法可以是基本名称，如<code>Class</code> ，使用定义类型的EMF EPackage名称的限定名称，如<code>uml.Class</code> ，或完全限定的URI，如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Class</code> 。</p>
		<p>默认情况下，可以在<em>Domain Class的</em> <em>任何</em>实例上创建新表。您可以使用“ <em>前置条件表达式”</em> （在“ <em>高级”</em>类别中可用）来更改此值。如果指定了这样的表达式，则将在用户选择的语义元素的上下文中对其进行求值，并且仅当表达式返回<code>true</code>时，用户才能够在此元素上创建新表。
		</p>
		<p>可以使用<em>Title表达式</em> （ <em>Advanced</em> category）指定新创建的表的默认标题，该<em>表达式</em>在创建表的语义元素的上下文中进行评估，并应返回一个字符串。如果未指定表达式，则默认标题是表描述的标签（如果未设置<em>标签，</em>则为其<em>ID</em> ），前缀为字符串<code>"new "</code> （例如， <code>new Package Contents</code> ）。
		</p>
		<p>建议将<em>版本表描述</em>明确地与它将表示的语义元素的元模型相关联。您可以在<em>Edition Table Description</em>的<em>Metamodels</em>属性部分中添加来自不同源的引用元模型。即使没有这种关联，Sirius也会工作，但明确设置它会在验证你的<a href="../../Glossary.html#VSM"><em>VSM</em></a>时给你更好的反馈。
		</p>
		<p><em>启动</em>标志<em>上</em>的<em>初始化</em>和<em>显示</em>控制是否在没有用户干预的情况下自动创建和/或打开表实例。如果设置了<em>Initialization</em> ，则当启用包含此表描述的视点时，将在所有兼容的语义元素上自动创建此表描述的实例。如果在set中<em>启动</em>时<em>显示</em> ，那么当打开包含此表描述实例的建模项目时，它们将被打开：如果只存在一个这样的表示，它将自动打开;如果有多个，将出现一个对话框，允许用户选择打开哪一个。
		</p>
		<p>最后， <em>初始标题列宽</em> （ <em>高级</em>类别）特定于表描述（版本表和交叉表）。它可用于指定表格最左侧列的默认大小（以像素为单位），其中包含每行所代表的元素的标签。如果值为0（默认值），则将在创建表时从初始内容计算列宽。对于版本表，如果值为-1，则隐藏标题列。在交叉表的情况下，-1值具有与0值相同的行为。
		</p>
		<h3 id="table_tools">表工具</h3>
		<p>适用于整个表的一些工具直接在<em>版本表描述</em>中指定：</p>
		<ul>
			<li>
				<em>表示创建工具</em> ：这些工具（Sirius支持的每种表示形式之一）可用于从现有表元素创建（和打开）新表示。它将在兼容表元素的<em>Navigate</em>上下文菜单中供最终用户使用。要配置工具，只需在<em>Mappings</em>属性中选择工具应显示的哪些行（如果需要，可以使用<em>Precondition</em>表达式更精确），并选择应使用<em>Representation Description</em>属性创建的<em>表示类型</em> （在实践中， <em>图表描述</em> ， <em>表描述</em>或<em>树描述之一</em>取决于工具）。通常，将在由用户调用该工具的树项所表示的语义元素上创建新表示。有时您希望工具出现在一个元素上，但在另一个元素上创建一个表示。在这种情况下，使用“ <em>浏览”表达式</em> （在“ <em>高级”</em>类别中）从所选元素导航到实际应创建新表示的元素。最后，在调用工具时，将执行您在工具正文中指定的任何操作;您可以使用它来初始化所表示的模型的内容。
			</li>
			<li>
				<em>表示导航工具</em> ：这些工具（Sirius支持的每种表示形式的工具）与之前的工具非常相似。唯一的区别是它们允许用户导航到现有的表示而不是创建新的表示。如果存在此类工具，则元素上的“ <em>导航”</em>上下文菜单将包含已在所选元素上存在的每个对应表示的条目（或者可以使用“ <em>浏览”表达式</em>从所选元素访问）。您可以指定要在菜单项中使用的<em>导航名称表达式</em> （ <em>高级</em>类别），而不是使用现有表示的标题。这有助于更明确地说明当前元素与目标树之间的关系。
			</li>
			<li>
				直接包含在<em>表描述</em>中的<em>行创建工具</em>用于创建根表行。它们通过主Eclipse工具栏中的组合按钮提供给最终用户。要配置它，只需选择工具将在<em>Mapping</em>属性中创建的行类型，并使用常规模型操作指定工具的行为。
			</li>
		</ul>
		<h4 id="tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h3 id="line_mappings">线映射</h3>
		<p>将出现在表中的行（及其在子行中的组织）由<em>表描述</em>元素内的<em>行</em>映射元素定义。<em>表描述</em>包含<em>行</em>映射，它定义哪些元素将显示为表的顶级行，而每个<em>行</em>映射可以包含定义其自己的直接子行的子映射。如果元素（表或行映射）包含多个子映射，则元素的内容将按映射的顺序出现：首先是第一个映射的所有实例，然后是第二个映射的实例，等等。</p>
		<p><em>线</em>映射由<em>域类</em>和<em>语义候选表达式定义</em> 。<em>语义候选表达式</em>指示在语义模型中查找应该由映射表示的元素的位置。表达式在父语义元素的上下文中进行计算（父表是表本身或父行）。它应该返回一组语义元素。只保留那些属于指定<em>域类</em>的实例，并将其实际表示为此映射的实例。因此与每一行相关联的语义元素称为行的<em>目标</em>元素。
		</p>
		<p>您可以通过定义<em>关联元素表达式</em> （在<em>高级类别中</em> ）将更多语义元素关联到一行，该<em>关联元素表达式</em>在目标上下文中进行评估，并且可以返回更多语义元素。目标元素或其中一个关联元素的任何更改都将自动触发该行的刷新。
		</p>
		<p><em>标题标签表达式</em> （在<em>标签</em>类别中）在行的目标上下文中进行评估，并且应该返回标题列（在表的左侧）中为该行显示的文本。
		</p>
		<p><em>线</em>映射可以<em>重用子线</em> （参见<em>导入</em>类别），包括其自身，作为子映射。效果与将重用的映射创建为子节点（如果父节点）的效果完全相同。但是，因为映射可以重用自身或其父映射之一，所以这允许创建无限深度的表（或者至少不是先验的有界）。“ <em>在映射中重用”</em>属性是“ <em>重用子行”</em>的对称：它显示哪些行映射将此一行重用为子行。
		</p>
		<h4 id="line_style">线条样式</h4>
		<p>您可以在线条映射内创建<em>样式</em>元素，以设置此行上所有单元格的默认样式（请注意，此样式会覆盖列映射一个）。
		</p>
		<p><em>Foreground Style</em>元素可用于设置字体大小，字体样式（例如斜体）和文本颜色。<em>背景样式</em>可用于设置背景颜色。两者都是可选的。
		</p>
		<p>您还可以为前景指定<em>条件样式</em> 。每个都是包含在谓词表达式中的正常前景样式（在行的语义元素的上下文中计算）。如果指定了条件样式，则按顺序测试它们的条件，并使用匹配的第一个条件。如果未定义条件样式，则应用<em>前景样式</em> （或默认值）。
		</p>
		<h4 id="line_tools">线工具</h4>
		<p>可以在线映射内创建两种工具（并应用于该映射的所有实例）。</p>
		<ul>
			<li>
				<em>创建线工具</em>用于创建新线。映射可以包含几个这样的工具。如果工具的（可选） <em>前提条件</em>适用于实例的目标，它们将出现在映射实例的上下文菜单中。创建工具必须指定它将创建的<em>映射</em>类型。使用所有标准模型操作，在工具的主体中定义创建工具的实际行为。
			</li>
			<li>
				<em>删除行工具</em> ，用于删除元素。如果行映射未明确定义删除工具，则<em>删除行</em>操作的默认行为是从语义模型中删除行的语义<em>目标</em>和所有<em>关联元素</em> 。如果需要特定行为，则必须显式创建“ <em>删除行工具”</em>并描述工具主体中的行为。如果要防止删除元素，则必须创建“ <em>删除行工具”</em>并将“ <em>前提条件”</em>设置为对不应删除的元素返回<code>false</code> 。
			</li>
		</ul>
		<h3 id="feature_column_mapping">特征列映射</h3>
		<p>将出现在编辑表中的<em>列</em>由“ <em>表描述”</em>元素内的“ <em>特征列”</em>映射元素定义。它们被命名为<em>Feature Column</em>映射，因为它们通常表示由表的行表示的元素的属性（可能是计算的），并且还将它们与<a href="#cross_tables">交叉表</a>中出现的列类型区分开来。
		</p>
		<p><em>特征列</em>映射由其<em>特征名称</em>定义，该<em>特征名称</em>通常应该是表格行中出现的元素的有效特征（属性或参考）的名称。如果一行表示语义元素<em>S1，</em>但您希望某些列显示可从<em>S1</em>而不是<em>S1</em>本身到达的元素的属性，则可以使用在<em>S1</em>的上下文中评估的<em>要素父表达式</em> （ <em>高级</em>类别）。应该返回一个元素<em>S2</em> 。
			<em>S2</em>将被视为该交叉点处的单元的<em>目标</em>元素而不是<em>S1</em> 。
		</p>
		<p>您可以使用“ <em>高级”</em>类别中的“ <em>关联元素”表达式</em>将更多语义元素与映射<em>关联</em> 。表达式将在单元格的目标语义元素的上下文中进行评估。
		</p>
		<p><em>标签表达式</em>用于计算要在每个单元格中显示的文本。在其目标语义元素的上下文中评估每个单元格。如果为EClass没有公共EStructuralFeatures（继承或具有相同名称）的元素计算文本，则可以使用<code>*</code>作为<em>功能名称</em>在单元创建期间跳过功能名称验证。
		</p>
		<p>在表格中，默认情况下，单元格的内容是可编辑的。即使没有指定直接编辑工具，Sirius也会尝试根据列所代表的要素类型（由<em>功能名称</em>定义）来解释用户输入的文本。例如，如果列表示布尔属性，则Sirius将正确解释字符串<code>"true"</code>和<code>"false"</code>并在用户编辑单元格时相应地设置值。您可以通过提供<em>Can Edit</em>表达式来禁用此行为，该表达式在每个单独单元格的语义元素的上下文中进行评估。如果该单元格不可编辑，则应返回<code>false</code> 。
		</p>
		<p>最后， <em>标题标签表达式</em>用于计算列本身的标题，并在表的目标语义元素的上下文中进行评估， <em>初始宽度</em> （如果设置为非零值）用作初始宽度列。
		</p>
		<h4 id="column_styles">列样式</h4>
		<p>列可以包含样式定义，以设置这些列上所有单元格的样式。但是，这些样式可以被样式覆盖，这些样式可能存在于此列单元格的行映射中。样式定义元素（包括对条件样式的支持）与与行映射关联的样式相同。有关更多详细信息，请参阅<a href="#line_style">相应部分</a> 。
		</p>
		<h4 id="column_tools">列工具</h4>
		<p>列当前只能定义<em>标签编辑</em>工具，该工具将应用于列的所有单元格。它像所有编辑一样工作<em>编辑蒙版</em>元素（包含在工具中）用于解析用户输入的新标签的值，并选择此标签的一部分作为编辑操作主体的输入变量。掩码可以包含<code>{N}</code>形式的子串，其中<em>N</em>是数字。与这些子字符串对应的新标签值的部分将作为名为<code>argN</code>变量提供。例如，使用编辑掩码<code>{0}:{1}</code>和由<code>attr : EString</code>用户输入的输入字符串，工具的主体将执行变量<code>arg0</code>设置为<code>attr␣</code> ， <code>arg1</code>设置为<code>␣EString</code> 。
		</p>
		<h2 id="cross_tables">交叉表</h2>
		<p>
			<em>交叉表</em>与版本表略有不同。它们经过优化，以类似矩阵的方式表示元素之间的关系。行和列都表示元素，如果它们之间存在某种关系，则每个调用在交叉点。交叉表也支持子行，但不支持子列。但是，如果指定了正确的工具，则除了行之外，用户还可以创建和/或删除列。
		</p>
		<p>使用“ <em>交叉表描述”</em>元素指定<em>交叉表</em> ，该元素与“ <a href="#edition_tables"><em>版本表描述”</em></a>元素完全相同。差异出现在它们可以包含的元素类型中。
		</p>
		<h3 id="cross_table_tools">表工具</h3>
		<p>交叉表可以包含与编辑表相同的工具（有关详细信息，请参阅<a href="#table_tools">相应的部分</a> ）。此外，它们可以包含“ <em>创建列工具”</em> ，其行为与“ <em>创建行”</em>工具完全相同，只是它们适用于“ <a href="#element_column_mapping"><em>元素列”</em>映射</a> （请参阅下文），并用于在表中创建新列。
		</p>
		<h4 id="cross_table_tools_specification">工具规范</h4>
		<p>
			<a href="../general/ToolsSpecification.html">请参阅工具规范</a>
		</p>
		<h3 id="element_column_mapping">元素列映射</h3>
		<p>在交叉表中，列表示元素而不是元素的属性（与编辑表的情况一样）。列集由一个或多个<em>元素列</em>映射定义。它们与<a href="#line_mappings">行映射</a>几乎完全相同，除了：</p>
		<ul>
			<li>它们不能嵌套（没有像子行那样的“子列”），因此也不能“重用”列映射;</li>
			<li>它们可以具有<em>初始宽度</em> （在“ <em>高级”</em>类别中设置）。
			</li>
		</ul>
		<p>
			<em>元素列</em>映射可以包含“ <em>创建列工具”</em>和“ <em>删除列工具”</em> ，这些<em>工具</em>的指定和行为方式与<em>创建行</em>和<em>删除行</em> <a href="#line_tools">工具</a>类似， <a href="#line_tools">用于行映射</a> 。
		</p>
		<p>它们还可以包含样式定义（包括条件样式），它们适用于列中的所有单元格（除非被交集映射或行映射（如果有）覆盖）。</p>
		<h3 id="intersection_mapping">交点映射</h3>
		<p>交叉表中的行和元素列映射定义表中将显示哪些行和列，但不定义单元格的内容。这由<em>交叉点</em>映射定义。“ <em>线条映射”</em>和“ <em>列映射”</em>属性指示映射描述的单元格。在单元格的目标语义元素的上下文中评估的<em>标签表达式</em>应返回要在单元格中显示的文本，而“ <em>可编辑”</em>表达式指示最终用户是否<em>可以编辑</em>单元格的值。
		</p>
		<p>交集映射有两种略有不同的用例，它们使用剩余属性的不同子集：</p>
		<ol>
			<li>交点，表示一行上的元素与列上的元素之间的关系。例如，如果行和列都表示UML类，那么这可能是类与它继承的类之间的“超类”引用;</li>
			<li>表示语义元素（而不仅仅是关系）的交集，它本身与行上的元素和列上的元素相关。要继续使用UML示例，这将用于表示UML关联，它们是表示类之间关系的完整对象。</li>
		</ol>
		<p>如果您熟悉它，这类似于Sirius图中的<em>基于</em> <em>关系的边</em>和<em>基于元素的边</em> 。
		</p>
		<p>在第一种情况下（“基于关系的交集”），单元格的语义元素将是单元格行的语义元素。要配置这样的交集，您必须只设置<em>列查找器表达式</em> ：从行的语义目标元素，它应该返回单元格应该出现的列的语义元素。
		</p>
		<p>通过在“ <em>基于</em> <em>域的”类别中</em>设置“ <em>使用域类”</em>标志来启用第二个用例（“基于元素的交集”）。然后，您必须指出将由单元格表示的元素的<em>Domain Class</em> ，以及<em>Semantic Candidates Expression</em> 。表达式将在整个表的语义元素的上下文中进行计算，并应返回应由单元格表示的所有元素（ <em>Domain类的</em>实例）。这些元素将是单元格的语义目标元素。您可以使用<em>前置表达式</em>和<em>关联元素表达式</em> （ <em>高级</em>类别），其语义与其他映射相同。最后，您必须同时设置<em>Column Finder Expression</em> （ <em>常规</em>类别）和<em>Line Finder Expression</em> （ <em>基于域的</em>类别）：它们都将在单元格的语义元素的上下文中进行评估，并且应该返回列和行的语义元素应该出现交叉点。在我们的示例中，这些表达式是从<em>Association</em>元素中查找<em>关联</em>的源类和目标类的表达式。
		</p>
		<h4 id="intersection_mapping_style">交叉风格</h4>
		<p><em>交点</em>映射可以包含样式元素，包括条件样式。如果它们存在，则它们将覆盖相应列映射或线映射上设置的任何样式。
		</p>
		<h4 id="intersection_mapping_tools">交叉口工具</h4>
		<p>交叉点映射可以包含两种工具：</p>
		<ul>
			<li>
				<em>标签编辑</em>工具是标准的“直接编辑”工具，允许最终用户编辑单元格的标签。您可以在工具主体中指定模型中的实际更改。
			</li>
			<li>
				当用户编辑最初为空的单元格时，将使用“ <em>创建单元格工具”</em> ，其中行和列没有关系（或元素相关）。它被定义为<em>标签编辑</em>工具（带有<em>编辑掩码变量</em>以获取用户输入的文本），但它不应编辑现有关系，而应创建关系（例如，将列中的类添加为超类到线上的那个）或与线和列相关的元素（例如创建一个链接类的<em>关联</em> ）。
			</li>
		</ul>
	</body>
</html><html id="0023.ScriptingReference.24.7.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>BirtStr</title>
    <link rel="StyleSheet" href="css/ScriptingReference.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ScriptingReference.24.6.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="ScriptingReference.24.8.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h2 class="RH1_Class"><a name="267653">BirtStr</a>类</h2>
      <p class="b_Body"><a name="261858">BirtStr类提供了操作字符串的函数，例如，连接字符串，修剪额外的空格，获取字符串的一部分以及以大写或大写形式显示字符串。这个类是静态的。应用程序无法创建该类的实例。</a></p>
      <h3 class="RH2_Method"><a name="261859">BirtStr.charLength</a></h3>
      <p class="b_Body"><a name="261860">此函数返回给定字符串的长度。</a></p>
      <p class="N_sb_ScanBold"><a name="261861">句法</a></p>
      <div class="rs_RSyntax"><a name="261862">整数BirtStr.charLength（字符串源代码）</a></div>
      <p class="N_sb_ScanBold"><a name="261863">参数</a></p>
      <p class="RParameter"><a name="261864">资源</a></p>
      <p class="bn_BodyNoLead"><a name="261865">串。要评估的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="261868">返回</a></p>
      <p class="b_Body"><a name="261869">整数。指定字符串中的字符数。</a></p>
      <p class="N_sb_ScanBold"><a name="261870">例子</a></p>
      <p class="b_Body"><a name="261871">以下示例返回特定字符串的长度：</a></p>
      <div class="cf_CodeFirst"><a name="261872">BirtStr.charLength（“Julie Murphy”）//返回12</a></div>
      <p class="b_Body"><a name="261876">以下示例返回CustomerName字段中每个值的长度：</a></p>
      <div class="cf_CodeFirst"><a name="261877">BirtStr.charLength（row [“CustomerName”]）</a></div>
      <h3 class="RH2_Method"><a name="263870">BirtStr.concat</a></h3>
      <p class="b_Body"><a name="263871">此函数返回串联指定字符串的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="263872">句法</a></p>
      <div class="rs_RSyntax"><a name="263873">string BirtStr.concat（string source1，...，sourceN）</a></div>
      <p class="N_sb_ScanBold"><a name="263874">参数</a></p>
      <p class="RParameter"><a name="263875">source1，...，sourceN</a></p>
      <p class="bn_BodyNoLead"><a name="263876">串。要连接的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="263877">返回</a></p>
      <p class="b_Body"><a name="263878">串。串联一系列字符串产生的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="263879">例</a></p>
      <p class="b_Body"><a name="263882">以下示例通过连接多个字段中的值来返回完整地址：</a></p>
      <div class="cf_CodeFirst"><a name="263883">BirtStr.concat（row [“AddressLine1”]，“，”，row [“AddressLine2”]，“，”，row [“City”]，“”，row [“PostalCode”]，“row [”State“] ，“，”，行[“国家”]）</a></div>
      <h3 class="RH2_Method"><a name="264323">BirtStr.indexOf</a></h3>
      <p class="b_Body"><a name="264324">此函数返回给定字符串中指定子字符串的位置。</a></p>
      <p class="N_sb_ScanBold"><a name="264325">句法</a></p>
      <div class="rs_RSyntax"><a name="264326">整数BirtStr.indexOf（sring target，string source，integer start）</a></div>
      <p class="N_sb_ScanBold"><a name="264327">参数</a></p>
      <p class="RParameter"><a name="264328">目标</a></p>
      <p class="bn_BodyNoLead"><a name="264329">串。要搜索的子字符串。搜索区分大小写。</a></p>
      <p class="RParameter"><a name="264373">资源</a></p>
      <p class="bn_BodyNoLead"><a name="264393">串。要在其中查找指定子字符串的字符串。</a></p>
      <p class="RParameter"><a name="264398">开始</a></p>
      <p class="bn_BodyNoLead"><a name="264503">整数。可选的。搜索开始的源字符串中的位置。如果省略此参数，该函数将从字符串的第一个字符开始搜索。</a></p>
      <p class="N_sb_ScanBold"><a name="264330">返回</a></p>
      <p class="b_Body"><a name="264331">整数。字符串中子字符串的数字位置。字符串的第一个字符从0开始。如果未找到子字符串，则该函数返回-1。</a></p>
      <p class="N_sb_ScanBold"><a name="264332">例子</a></p>
      <p class="b_Body"><a name="264333">以下示例返回特定字符串中指定字符的数字位置：</a></p>
      <div class="cf_CodeFirst"><a name="264334">BirtStr.indexOf（“”，“Julie Murphy”）//返回5</a></div>
      <div class="co_Code"><a name="264705">BirtStr.indexOf（“ - ”，“ModelA-1234-567”）//返回6</a></div>
      <div class="co_Code"><a name="266548">BirtStr.indexOf（“ - ”，“ModelA-1234-567”，7）//返回11</a></div>
      <p class="b_Body"><a name="266569">以下示例将BirtStr.indexOf（）与BirtStr.left（）结合使用，以显示客户名称中空格字符前面的字符。BirtStr.left（）函数从第一个字符开始提取指定长度的子字符串。在此示例中，要显示的子字符串的长度等于空格字符的数字位置。</a></p>
      <div class="cf_CodeFirst"><a name="266570">spaceCharPosition = BirtStr.indexOf（“”，row [“customerName”]）;</a></div>
      <div class="co_Code"><a name="266571">displayFirstName = BirtStr.left（row [“customerName”]，spaceCharPosition）;</a></div>
      <p class="b_Body"><a name="266572">如果客户名称是Julie Murphy，那么表达式将返回Julie。</a></p>
      <h3 class="RH2_Method"><a name="264831">BirtStr.left</a></h3>
      <p class="b_Body"><a name="264832">此函数从字符串中提取指定长度的子字符串，从最左侧或第一个字符开始。</a></p>
      <p class="N_sb_ScanBold"><a name="264833">句法</a></p>
      <div class="rs_RSyntax"><a name="264834">string BirtStr.left（string source，integer n）</a></div>
      <p class="N_sb_ScanBold"><a name="264835">参数</a></p>
      <p class="RParameter"><a name="265142">资源</a></p>
      <p class="bn_BodyNoLead"><a name="265143">串。从中提取子字符串的字符串。</a></p>
      <p class="RParameter"><a name="265144">ñ</a></p>
      <p class="bn_BodyNoLead"><a name="264839">整数。要从第一个字符开始提取的字符数。</a></p>
      <p class="N_sb_ScanBold"><a name="264842">返回</a></p>
      <p class="b_Body"><a name="265267">SRING。特定长度的子字符串。</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265268">如果省略n，要提取的字符数，该函数仅返回第一个字符。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265269">如果n为零，则该函数返回一个空字符串。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265270">如果n大于字符串的长度，则该函数返回整个字符串。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="N_sb_ScanBold"><a name="264844">例子</a></p>
      <p class="b_Body"><a name="264845">以下示例从特定字符串返回各种长度的子字符串：</a></p>
      <div class="cf_CodeFirst"><a name="264846">BirtStr.left（“Julie Murphy”，5）//回归朱莉</a></div>
      <div class="co_Code"><a name="264847">BirtStr.left（“Julie Murphy”，12）//回归Julie Murphy</a></div>
      <p class="b_Body"><a name="264849">以下示例将BirtStr.indexOf（）与BirtStr.left（）结合使用，以显示客户名称中空格字符前面的字符。BirtStr.left（）函数从第一个字符开始提取指定长度的子字符串。在此示例中，要显示的子字符串的长度等于空格字符的数字位置。</a></p>
      <div class="cf_CodeFirst"><a name="264850">spaceCharPosition = BirtStr.indexOf（“”，row [“customerName”]）;</a></div>
      <div class="co_Code"><a name="264851">displayFirstName = BirtStr.left（row [“customerName”]，spaceCharPosition）;</a></div>
      <p class="b_Body"><a name="264852">如果客户名称是Julie Murphy，那么表达式将返回Julie。</a></p>
      <h3 class="RH2_Method"><a name="265393">BirtStr.right</a></h3>
      <p class="b_Body"><a name="265394">此函数从字符串中提取指定长度的子字符串，从最右边或最后一个字符开始。</a></p>
      <p class="N_sb_ScanBold"><a name="265395">句法</a></p>
      <div class="rs_RSyntax"><a name="265396">String BirtStr.right（String source，integer n）</a></div>
      <p class="N_sb_ScanBold"><a name="265397">参数</a></p>
      <p class="RParameter"><a name="265398">资源</a></p>
      <p class="bn_BodyNoLead"><a name="265399">串。从中提取子字符串的字符串。</a></p>
      <p class="RParameter"><a name="265400">ñ</a></p>
      <p class="bn_BodyNoLead"><a name="265401">整数。从最后一个字符开始提取的字符数。</a></p>
      <p class="N_sb_ScanBold"><a name="265402">返回</a></p>
      <p class="b_Body"><a name="265403">串。特定长度的子字符串。</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265404">如果省略n，要提取的字符数，该函数仅返回最后一个字符。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265405">如果n为零，则该函数返回一个空字符串。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="265406">如果n大于字符串的长度，则该函数返回整个字符串。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="N_sb_ScanBold"><a name="265407">例子</a></p>
      <p class="b_Body"><a name="265408">以下示例从特定字符串返回各种长度的子字符串：</a></p>
      <div class="cf_CodeFirst"><a name="265409">BirtStr.right（“Julie Murphy”，6）//回归墨菲</a></div>
      <div class="co_Code"><a name="265410">BirtStr.right（“Julie Murphy”，12）//回归Julie Murphy</a></div>
      <p class="b_Body"><a name="265683">以下示例将BirtStr.right（）与BirtStr.indexOf（）和BirtStr.charLength（）函数结合使用，以显示客户名称中空格字符后面出现的字符。此示例假定连字符后面的字符数不同。因此，整个字符串的长度（由BirtStr.charLength（）返回）减去连字符的长度（由BirtStr.indexOf（）返回）是要显示的字符数。</a></p>
      <div class="cf_CodeFirst"><a name="265684">spaceCharPosition = BirtStr.indexOf（“”，row [“customerName”]）;</a></div>
      <div class="co_Code"><a name="265731">displayLastName = BirtStr.right（row [“customerName”]，（BirtStr.charLength（row [“customerName”]  - （spaceCharPosition + 1）））</a></div>
      <p class="b_Body"><a name="265685">如果客户名称是Julie Murphy，则表达式返回Murphy。如果客户名称是Kwai Li，则表达式返回Li。</a></p>
      <h3 class="RH2_Method"><a name="265763">BirtStr.search</a></h3>
      <p class="b_Body"><a name="265764">此函数返回给定字符串中指定子字符串的位置。子字符串可以包含通配符。</a></p>
      <p class="N_sb_ScanBold"><a name="265765">句法</a></p>
      <div class="rs_RSyntax"><a name="265766">整数BirtStr.search（字符串模式，字符串源，整数索引）</a></div>
      <p class="N_sb_ScanBold"><a name="265767">参数</a></p>
      <p class="RParameter"><a name="265768">图案</a></p>
      <p class="bn_BodyNoLead"><a name="266046">串。要搜索的字符串模式。搜索不区分大小写。您可以在模式中使用以下通配符：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><span style="font-family:&quot;Microsoft Sans Serif&quot;"><a name="266052">星号（*）匹配零个或多个字符，包括空格</a></span> 。例如，t * n匹配tn，tin和teen。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="266054">问号（？）恰好匹配一个字符。例如，t？n匹配tan，ten，tin和ton。它与青少年或tn不匹配。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="307053">要匹配字符串中的文字星号或问号，请在这些字符前面加上两个反斜杠字符（\\）。例如，要查找子字符串R * 10，请使用以下字符串模式：</a></p>
      <div class="cfb_CodeFirst_Break"><a name="307079">“R * \\ 10”</a></div>
      <p class="RParameter"><a name="266022">资源</a></p>
      <p class="bn_BodyNoLead"><a name="265769">串。要在其中查找指定子字符串的字符串。</a></p>
      <p class="RParameter"><a name="265770">指数</a></p>
      <p class="bn_BodyNoLead"><a name="266100">整数。可选的。搜索开始的源字符串中的位置。如果省略此参数，该函数将从字符串的第一个字符开始搜索。</a></p>
      <p class="N_sb_ScanBold"><a name="266101">返回</a></p>
      <p class="b_Body"><a name="266102">整数。字符串中子字符串的数字位置。字符串的第一个字符从0开始。如果未找到子字符串，则该函数返回-1。</a></p>
      <p class="N_sb_ScanBold"><a name="265777">例子</a></p>
      <p class="b_Body"><a name="266358">以下示例返回特定字符串中指定字符串模式的数字位置：</a></p>
      <div class="cf_CodeFirst"><a name="266359">BirtStr.search（“XM？“，”XMS-ModelA-1234-567“）//返回0</a></div>
      <div class="co_Code"><a name="266360">BirtStr.search（“ModelA *”，“XMS-ModelA-1234-567”）//返回4</a></div>
      <div class="co_Code"><a name="266377">BirtStr.search（“ - ”，“XMS-ModelA-1234-567”，4）//返回10</a></div>
      <p class="b_Body"><a name="266308">以下示例在ProductCode字段的每个值中搜索字符串模式S * A.如果产品代码是KBS5412A，则表达式返回2。</a></p>
      <div class="cf_CodeFirst"><a name="266214">BirtStr.search（“S * A”，row [“ProductCode”]）</a></div>
      <p class="b_Body"><a name="266580">以下示例将BirtStr.search（）与BirtStr.left（）结合使用，以在产品名称中显示字符串模式前面的字符-Model *。BirtStr.left（）函数从第一个字符开始提取指定长度的子字符串。在此示例中，要显示的子字符串的长度等于字符串模式的数字位置。</a></p>
      <div class="cf_CodeFirst"><a name="266581">stringPatternPosition = BirtStr.search（“ -  Model *”，row [“productName”]）;</a></div>
      <div class="co_Code"><a name="266597">displayString = BirtStr.left（row [“productName”]，stringPatternPosition）;</a></div>
      <p class="b_Body"><a name="266582">如果产品名称为XMS-ModelA-1234，则表达式返回XMS。</a></p>
      <h3 class="RH2_Method"><a name="266634">BirtStr.toLower</a></h3>
      <p class="b_Body"><a name="266635">此函数将字符串中的所有字母转换为小写。</a></p>
      <p class="N_sb_ScanBold"><a name="266636">句法</a></p>
      <div class="rs_RSyntax"><a name="266637">string BirtStr.toLower（string source）</a></div>
      <p class="N_sb_ScanBold"><a name="266638">参数</a></p>
      <p class="RParameter"><a name="266639">资源</a></p>
      <p class="bn_BodyNoLead"><a name="266640">串。要转换为小写的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="266641">返回</a></p>
      <p class="b_Body"><a name="266642">串。全部小写字母的指定字符串</a></p>
      <p class="N_sb_ScanBold"><a name="266643">例</a></p>
      <p class="b_Body"><a name="266644">以下示例以小写形式显示productLine字段中的所有值：</a></p>
      <div class="cf_CodeFirst"><a name="266645">BirtStr.toLower（row [“productLine”]）</a></div>
      <h3 class="RH2_Method"><a name="266740">BirtStr.toUpper</a></h3>
      <p class="b_Body"><a name="266741">此函数将字符串中的所有字母转换为大写。</a></p>
      <p class="N_sb_ScanBold"><a name="266742">句法</a></p>
      <div class="rs_RSyntax"><a name="266743">string BirtStr.toUpper（string source）</a></div>
      <p class="N_sb_ScanBold"><a name="266744">参数</a></p>
      <p class="RParameter"><a name="266745">资源</a></p>
      <p class="bn_BodyNoLead"><a name="266746">串。要转换为大写的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="266747">返回</a></p>
      <p class="b_Body"><a name="266748">串。全部大写字母的指定字符串</a></p>
      <p class="N_sb_ScanBold"><a name="266749">例</a></p>
      <p class="b_Body"><a name="266750">以下示例以大写形式显示customerName字段中的所有值：</a></p>
      <div class="cf_CodeFirst"><a name="266751">BirtStr.toUpper（row [“customerName”]）</a></div>
      <h3 class="RH2_Method"><a name="267084">BirtStr.trim</a></h3>
      <p class="b_Body"><span style="font-family:&quot;Microsoft Sans Serif&quot;"><a name="267147">此函数返回一个字符串，其中删除了所有前导和尾随空白字符。</a></span>它不会删除单词之间的空白字符。</p>
      <p class="N_sb_ScanBold"><a name="267148">句法</a></p>
      <div class="rs_RSyntax"><a name="267149">string BirtStr.trim（string source）</a></div>
      <p class="N_sb_ScanBold"><a name="267150">参数</a></p>
      <p class="RParameter"><a name="267151">资源</a></p>
      <p class="bn_BodyNoLead"><a name="267152">串。用于删除前导和尾随空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267153">返回</a></p>
      <p class="b_Body"><a name="267154">串。删除了所有前导和尾随空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267155">例</a></p>
      <p class="b_Body"><a name="267156">以下示例使用BirtStr.trim（）从FirstName和LastName数据字段中的值中删除所有前导和尾随空白字符。</a></p>
      <div class="cf_CodeFirst"><a name="267157">BirtStr.trim（row [“FirstName”]）+“”+ BirtStr.trim（row [“LastName”]）</a></div>
      <h3 class="RH2_Method"><a name="267249">BirtStr.trimLeft</a></h3>
      <p class="b_Body"><span style="font-family:&quot;Microsoft Sans Serif&quot;"><a name="267250">此函数返回一个字符串，其中删除了所有前导和尾随空白字符。</a></span>它不会删除单词之间的空白字符。</p>
      <p class="N_sb_ScanBold"><a name="267251">句法</a></p>
      <div class="rs_RSyntax"><a name="267252">string BirtStr.trimLeft（string source）</a></div>
      <p class="N_sb_ScanBold"><a name="267253">参数</a></p>
      <p class="RParameter"><a name="267254">资源</a></p>
      <p class="bn_BodyNoLead"><a name="267255">串。要从中删除前导空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267256">返回</a></p>
      <p class="b_Body"><a name="267257">串。删除了所有前导空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267258">例</a></p>
      <p class="b_Body"><a name="267307">以下示例将文字字符串与customerName字段中的每个值连接在一起。BirtStr.trimLeft（）删除customerName值之前的所有空白字符，以便在文字字符串和customerName值之间没有多余的空白字符。</a></p>
      <div class="cf_CodeFirst"><a name="267308">“客户名称：”+ BirtStr.trimLeft（row [“customerName”]）</a></div>
      <h3 class="RH2_Method"><a name="267327">BirtStr.trimRight</a></h3>
      <p class="b_Body"><span style="font-family:&quot;Microsoft Sans Serif&quot;"><a name="267328">此函数返回一个字符串，其中删除了所有尾随空白字符。</a></span>它不会删除单词之间的空白字符。</p>
      <p class="N_sb_ScanBold"><a name="267329">句法</a></p>
      <div class="rs_RSyntax"><a name="267330">string BirtStr.trimRight（string source）</a></div>
      <p class="N_sb_ScanBold"><a name="267331">参数</a></p>
      <p class="RParameter"><a name="267332">资源</a></p>
      <p class="bn_BodyNoLead"><a name="267333">串。要从中删除尾随空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267334">返回</a></p>
      <p class="b_Body"><a name="267335">串。删除了所有尾随空白字符的字符串。</a></p>
      <p class="N_sb_ScanBold"><a name="267336">例</a></p>
      <p class="b_Body"><a name="267541">以下示例使用分号连接“注释”字段中的每个值，然后使用“操作”字段中的值连接。BirtStr.trimRight（）删除Comment值后面的所有空白字符，以便Comment字符串和分号之间没有多余的空白字符。</a></p>
      <div class="cf_CodeFirst"><a name="267542">BirtStr.trimRight（row [“Comment”]）+“;”+ row [“Action”]）</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3851.306_mwe2.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>MWE 2</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="mwe2">MWE 2</h1>

<p>建模工作流引擎2（MWE2）是建模工作流引擎（MWE）的重写向后兼容实现。它是一个声明式，外部可配置的发电机引擎。用户可以通过简单，简洁的语法描述任意对象组合，该语法允许声明对象实例，属性值和引用。一个用例 - 这就是名称的起源 - 是工作流的定义。这样的工作流程通常包括许多彼此交互的组件。有些组件可以读取EMF资源，对它们执行操作（转换）并将它们写回或从信息中生成任意数量的其他工件。工作流通常在单个JVM中执行。但是，防止实现者没有限制提供产生多个线程或新进程的组件。</p>

<h2 id="mwe2-exampe">例子</h2>

<p>让我们从几个示例开始，演示MWE2的一些使用场景。第一个示例是一个简单的<code>HelloWorld</code>模块，除了将标准输出打印出来之外什么都不做。第二个模块由三个组件组成，这三个组件读取Ecore文件，将包含的分类器名称转换为大写，并将资源序列化为新文件。最后一个示例使用<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/IWorkflowComponent.java">IWorkflowComponent</a>的生命周期方法来打印工作流的执行时间。</p>

<h3 id="mwe2-hello-world">最简单的工作流程</h3>

<p>可以说是最短的MWE2模块可能看起来像下面的代码片段：</p>

<pre><code class="language-mwe2">模块HelloWorld SayHello {message =“Hello World！“}</code></pre>

<p>它配置了一个非常简单的工作流组件，其中包含应在执行工作流时打印到<code>System.out</code>的消息。该模块以声明其名称开头。它必须满足完全限定类名的Java约定。这就是为什么必须将模块<code>HelloWorld</code>放入Java源文件夹的默认包中。模块中的第二个元素是类名<code>SayHello</code> ，它引入了模块的根元素。解释器将创建给定类型的实例，并将其配置为花括号之间声明的。例如，赋值<code>message = "Hello World!"</code>在模块中将被解释为对实例化对象的<code>setMessage(String)</code>的调用。正如人们可以想象的那样， <code>SayHello</code>类的实现看起来很直接：</p>

<pre><code class="language-java">import org.eclipse.emf.mwe2.runtime.workflow。IWorkflowComponent; import org.eclipse.emf.mwe2.runtime.workflow。IWorkflowContext;公共类SayHello实现IWorkflowComponent {private String message =“Hello World！“; public void setMessage（String message）{this.message = message;} public String getMessage（）{return message;} public void invoke（IWorkflowContext ctx）{System.out.println（getMessage（））;} public void postInvoke （）{} public void preInvoke（）{}}</code></pre>

<p>它看起来像一个简单的POJO，这是MWE2背后的哲学。很容易以声明的方式组装完全独立的对象。要使工作流可以使用<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.launch/src/org/eclipse/emf/mwe2/launch/runtime/Mwe2Runner.java">Mwe2Runner执行</a> ，组件<code>SayHello</code>必须嵌套在根工作流中：</p>

<pre><code class="language-mwe2">模块HelloWorld Workflow {component = SayHello {message =“Hello World！“}}</code></pre>

<p><a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/Workflow.java">工作流</a>类的<code>org.eclipse.emf.mwe2.runtime.workflow</code>包隐式导入MWE2模块，使模块更简洁。快速<em>运行后，将显示此工作流程的执行结果<em>。→MWE2</em>控制台中的工作流程</em>为</p>

<p><code>你好，世界！</code></p>

<h3 id="mwe2-simple-transformation">简单的转型</h3>

<p>以下工作流程解决了重命名<em>* .ecore</em>文件中的每个<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java">EClassifier</a>的示例性任务。它由三个读取，修改和写入模型文件的组件组成：</p>

<pre><code class="language-mwe2">module Renamer Workflow {component = ResourceReader {uri =“model.ecore”} component = RenamingTransformer {} component = ResourceWriter {uri =“uppercaseModel.ecore”}}</code></pre>

<p>这些组件的实现非常简单。即使是用于自动化过程的次要操作，也可以轻松创建自己的组件。</p>

<p><code>ResourceReader</code>只是读取具有给定<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a>的文件，并将其存储在工作流上下文的所谓<em>插槽</em>中。插槽可以理解为字典或地图条目。</p>

<pre><code class="language-java">公共类ResourceReader扩展WorkflowComponentWithSlot {private String uri; public void invoke（IWorkflowContext ctx）{ResourceSet resourceSet = new ResourceSetImpl（）; URI fileURI = URI.createFileURI（uri）;资源资源= resourceSet.getResource（fileURI，true）; ctx.put（getSlot（），resource）; public void setUri（String uri）{this.uri = uri; public String getUri（）{return uri; }}</code></pre>

<p>实际的变压器从槽中取出模型并对其进行修改。它只是迭代资源的内容，识别每个<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClassifier.java">EClassifier</a>并设置其名称。</p>

<pre><code class="language-java">public class RenamingTransformer扩展WorkflowComponentWithSlot {private boolean toLowerCase = false; public void invoke（IWorkflowContext ctx）{Resource resource =（Resource）ctx.get（getSlot（））; EcoreUtil.resolveAll（资源）; Iterator &lt;Object&gt; contents = EcoreUtil.getAllContents（resource，true）; Iterator &lt;EClassifier&gt; iter = Iterators.filter（contents，EClassifier.class）; while（iter.hasNext（））{EClassifier classifier =（EClassifier）iter.next（）; classifier.setName（isToLowerCase（）？classifier.getName（）。toLowerCase（）：classifier.getName（）。toUpperCase（））; public void setToLowerCase（boolean toLowerCase）{this.toLowerCase = toLowerCase; public boolean isToLowerCase（）{return toLowerCase; }}</code></pre>

<p>修改模型后，应将其写入新文件。这就是<code>ResourceWriter</code>所做的。它实际上从给定的<em>插槽</em>获取资源并使用配置的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a>保存它：</p>

<pre><code class="language-java">公共类ResourceWriter扩展WorkflowComponentWithSlot {private String uri; public void invoke（IWorkflowContext ctx）{Resource resource =（Resource）ctx.get（getSlot（））; URI uri = URI.createFileURI（getUri（））; uri = resource.getResourceSet（）。getURIConverter（）。normalize（uri）; resource.setURI（URI）; try {resource.save（null）; } catch（IOException e）{throw new WrappedException（e）; public void setUri（String uri）{this.uri = uri; public String getUri（）{return uri; }}</code></pre>

<p>最后但并非最不重要的是，这些组件的常见超类型如下所示：</p>

<pre><code class="language-java">公共抽象类WorkflowComponentWithSlot实现IWorkflowComponent {private String slot =“model”; public void setSlot（String slot）{this.slot = slot; public String getSlot（）{return slot; } public void postInvoke（）{} public void preInvoke（）{}}</code></pre>

<p>每个提到的实现都相当简单，可以在几分钟内完成。开发人员在日常工作中面临的许多乏味任务可以通过一系列相当简单的组件来解决。MWE2可用于以最小的努力自动执行这些任务。</p>

<h3 id="mwe2-stopwatch">停止观察</h3>

<p>最后一个示例演示了如何组合MWE2概念以创建一个简单的秒表，以便测量一组组件的执行时间。我们的想法是将两个相同的秒表作为组件添加到工作流程中。它将测量从第一次预调用到最后一次调用后事件的时间，并将经过的毫秒数打印到控制台。</p>

<pre><code class="language-java">公共类StopWatch实现IWorkflowComponent {private long start; private boolean shouldStop = false; public void invoke（IWorkflowContext ctx）{} public void postInvoke（）{if（shouldStop）{long elapsed = System.currentTimeMillis（） -  start; System.out.println（“已过去的时间：”+已过去+“ms”）; } shouldStop = true; public void preInvoke（）{start = System.currentTimeMillis（）; }}</code></pre>

<p>想要利用这种秒表的客户可以使用以下模式。必须将类<code>StopWatch</code>的实例添加为工作流的第一个组件和最后一个组件。中间的每个组件都将被测量。在这种情况下，它是另一个不需要了解这种装饰的工作流程。我们的想法是为实例化的<code>StopWatch</code>使用本地标识符，并在最后重用这个标识符以接收两次调用后生命周期事件。</p>

<pre><code class="language-mwe2">模块MeasuredWorkflow工作流程{component = StopWatch：stopWatch {} component = @OtherWorkflow {} component = stopWatch}</code></pre>

<h2 id="mwe2-language-reference">语言参考</h2>

<p>MWE2有一些定义明确的概念，可以组合起来以紧凑和声明的方式组合任意对象图。</p>

<ul>
  <li>MWE2文件定义了一个<code>module</code> ，该<code>module</code>将其根<code>component</code>公开为可重用工件。</li>
  <li><code>Properties</code>可用于提取工作流的可重用，可配置部分。</li>
  <li>组件映射到普通的vanilla <em>Java对象</em> 。任意<code>setABC(..)</code>和<code>addXYZ(..)</code>方法用于配置它们。</li>
</ul>

<p>让我们考虑以下简短示例模块和<code>SampleClass</code>来解释这些概念。</p>

<pre><code class="language-mwe2">模块com.mycompany。示例import java.util。* SampleClass {singleValue ='a string'ultiValue = ArrayList {} child = {}}</code></pre>

<pre><code class="language-java">包com.mycompany; import java.util。清单; public class SampleClass {public void setSingleValue（String value）{..}public void addMultiValue（List &lt;？&gt;价值）{..}public void addChild（SampleClass value）{..}}</code></pre>

<h3 id="mwe2-java-references">映射到Java类</h3>

<p><code>com.mycompany.模块<code>com.mycompany.Example</code>定义了<code>com.mycompany.类型的根组件<code>com.mycompany.SampleClass</code> 。可以使用简单的类名，因为MWE2使用与Java编译器完全相同的可见性规则。与模块位于同一包中的类可以通过其简单名称引用。同样的规则适用于<code>java.lang</code>包中的类。为方便起见，隐式导入了<code>org.eclipse.emf.mwe2.runtime.workflow</code>包，并公开了一些库工作流组件。但是，导入比Java更灵活，因为MWE2导入可以是相对的，例如<code>import java.*</code>解析引用<code>util.ArrayList</code>到<code>java.util.ArrayList</code> 。</p>

<p><code>SampleClass</code>类型的根实例必须在创建后进行配置。因此， <code>setSingleValue</code>会调用方法<code>setSingleValue</code> 。给定的参数是<code>'a string'</code> 。该方法由其名称以<code>set</code>开头标识。为了允许分配多值属性，MWE还提供对<code>add*</code>方法的访问。</p>

<p>如果工作流文件中赋值的右侧未明确定义类，则从method参数推断其类型。行<code>child = {}</code>等同于<code>child = SampleClass {}</code>并创建<code>SampleClass</code>的新实例。</p>

<p>MWE2提供了很好的工具支持。编辑器将为允许的类型提供内容辅助，并突出显示不兼容的分配。还将提出Java类的可用属性。</p>

<h3 id="mwe2-module">模</h3>

<p>由于MWE2模块具有完全限定名称，因此可以从其他模块引用它们。模块的类型源自其根组件的类型。<code>com.mycompany.可以在<code>com.mycompany.任何位置分配Example</code> <code>com.mycompany.SampleClass</code>是预期的。</p>

<p>让我们创建第二个模块<code>com.mycompany.Second</code>是这样的：</p>

<pre><code class="language-mwe2">module com.mycompany.sub。第二次导入com.mycompany。* SampleClass {child = @Example {}}</code></pre>

<p><code>child</code>值将分配给在第一个示例工作流中配置的<code>SampleClass</code>实例。这样可以实现精美的构图和非常集中，可重复使用的组件设计。</p>

<p>由于相同的规则适用于MWE2，例如Java， <code>com.mycompany.sub.模块<code>com.mycompany.sub.Second</code>必须在<code>com.mycompany.sub</code>包中名为<em>Second.mwe2</em>的文件中定义。其他模块的导入语义与类相同。import语句允许引用<code>com.mycompany.缩写名称的Example</code> 。</p>

<h3 id="mwe2-properties">属性</h3>

<p>MWE2允许将任意信息提取到属性中，以确保这些碎片不会在工作流周围混乱，并允许更容易的外部定制。仅通过引入属性<code>value</code>略微改变示例性组件定义。</p>

<pre><code class="language-mwe2">模块com.mycompany。示例var value ='a string'SampleClass {singleValue = value}</code></pre>

<p>属性的类型将从默认值派生，类似于<code>set</code> - 和<code>add</code> -methods中已知的机制。如果没有给出默认值，则假定为<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a> 。但是，属性不限于字符串。第二个内置类型是boolean，通过熟悉的文字<code>true</code>和<code>false</code> 。通过实际的组件文字可以获得更大的灵活性。</p>

<pre><code class="language-mwe2">模块com.mycompany。示例var childInstance = SampleClass {singleValue =“child”} SampleClass {child = childInstance}</code></pre>

<p>如果想要定义作为其他属性的实际可重用部分的字符串属性，她可以在其他文字中使用定义的变量，如下所示：</p>

<pre><code class="language-mwe2">var aString =“part”var anotherString =“在这里重用$ {part}”</code></pre>

<p>这对于工作流中的文件路径特别有用，因为人们通常只想在工作流中定义一些公共根目录，并在某些其他文件位置重用此片段。</p>

<h3 id="mwe2-mandatory">强制性属性</h3>

<p>定义属性的默认值并不总是可行的。这就是强制性财产发挥作用的地方。模块不仅通过其完全限定名称和根组件的类型定义其接口，还通过定义的属性定义它们的接口。</p>

<pre><code class="language-mwe2">模块com.mycompany。示例var optional ='a string'var mandatory SampleClass {singleValue = optional child = {singleValue = mandatory}}</code></pre>

<p>此版本的示例模块公开了两个外部可分配的属性。第二个没有分配默认值，因此被认为是强制性的。如果我们重用<code>org.mycompany.则必须分配强制值<code>org.mycompany.像这样的另一个模块中的Example</code> ：</p>

<pre><code class="language-mwe2">模块com.mycompany。第二个var newMandatory @Example {mandatory =“mandatoryValue”optional = newMandatory}</code></pre>

<p>请注意，甚至可以重用另一个模块作为新模块的根组件。在这种情况下，我们将<code>Example</code>的强制属性设置为特定的常量值，而先前的可选值现在通过没有默认值的新属性重新定义为必需。</p>

<p>不仅可以为MWE2模块定义强制属性，还可以为类定义强制属性。因此MWE2附带<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/Mandatory.java">强制性</a>注释。如果<code>set</code> - 或<code>add</code> -method被标记为<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/Mandatory.java">Mandatory</a> ，则如果没有为该功能分配值，模块验证将失败。</p>

<h3 id="mwe2-named-components">命名组件</h3>

<p>属性不是定义可以重用的东西的唯一方法。可以为任何实例化组件指定名称，无论它是从类文字还是从其他组件创建的。这允许引用先前创建和配置的实例。命名实例可以方便用于通知和回调机制，或者在定义的生命周期事件方面更通用。</p>

<p>如果我们想将创建的实例分配给自己的属性，我们可以使用以下语法：</p>

<pre><code class="language-mwe2">模块com.mycompany。示例SampleClass：self {child = self}</code></pre>

<p>命名组件可在创建后立即引用，但无法在MWE2文件中使用前向引用。</p>

<h3 id="mwe2-auto-inject">自动注射</h3>

<p>现有模块或类通常会公开一组属性，这些属性将分别分配给其根组件或set-和add-方法的功能。在许多情况下，很难为同一个概念提出另一个名称，导致属性本身与组件功能名称完全相同的情况。为了避免重复分配，MWE2提供了在组件文字上使用<code>auto-inject</code>修改器的可能性：</p>

<pre><code class="language-mwe2">模块com.mycompany。示例var child = SampleClass {} SampleClass auto-inject {}</code></pre>

<p>此示例将隐式地将属性<code>child</code>的值分配给根组件的feature <code>child</code>项。这对于高度可配置的工作流程尤其有用，这些工作流程可以显示许多可选参数，每个可选参数都可以分配给一个或多个组件。</p>

<p><code>auto-inject</code>修改器也可用于可用特征的子集。它将被抑制为组件的显式设置值。</p>

<h2 id="mwe2-syntax-reference">语法参考</h2>

<p>以下章节作为MWE2具体语法的参考。将用几个词来描述模块的构建块。</p>

<p>MWE2对空白区域不敏感，允许在任何地方定义行注释和块注释。语法与Java语言中使用的语法相同：</p>

<pre><code class="language-mwe2">//这是评论/ *这是另一个评论。* /</code></pre>

<p>MWE2中的每个名称都可以是完全限定的标识符，并且必须遵循Java约定。但是，与Java标识符相反，不允许在标识符中使用德语变音符号或Unicode转义序列。MWE2中的有效ID段以字母或下划线开头，后跟任意数量的字母，数字或下划线。标识符由一个或多个由“。”分隔的段组成。点。</p>

<pre><code class="language-xtext">姓名：ID（'。' ID）*; ID：（'a'..'z'|'A'..'Z'|'_'）（'a'..'z'|'A'..'Z' | '_' | '0' ..'9'）*;</code></pre>

<p>MWE2在任何地方都不使用分号作为语句分隔符。</p>

<h3 id="mwe2-module-syntax">模</h3>

<p><img src="images/mwe2/module.png" alt=""></p>

<p>一个<code>module</code>由四部分组成。<em>* .mwe2</em>文件中的第一个语句是模块声明。模块的名称必须遵循Java类的命名约定。因此，MWE2文件的名称必须与module-name的最后一段相同，并且必须将其放在Java源路径的相应包中。</p>

<p>允许在模块中定义任意数量的import语句。导入以通配符为后缀，或者导入具体的类或模块。如果使用通配符表示法，MWE2可以处理相对导入：</p>

<pre><code class="language-xtext">'import'name'。*“？
</code></pre>

<h3 id="mwe2-property-syntax">属性</h3>

<p>声明的属性列表遵循可选的导入部分。允许定义没有任何属性的模块。</p>

<p><img src="images/mwe2/property.png" alt=""></p>

<p>每个声明的属性在模块中都是本地可见的。它进一步定义了模块的可分配特征，以防一个模块从另一个模块引用它。属性可以具有默认值，也可以认为是<em>必需的</em> 。如果省略属性类型，则将从默认值推断。属性的默认类型是<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a> 。也就是说，如果没有可用的默认值，则该属性是<em>必需的，</em>并且类型为<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a> 。</p>

<p>MWE2中有四种类型的值。可以定义字符串，布尔值或组件文字或对先前定义的属性的引用。</p>

<h3 id="mwe2-component-syntax">零件</h3>

<p>模块的构建块是根组件。它定义了模块的外部可见类型，可以从Java类型或另一个模块创建。</p>

<p><img src="images/mwe2/component.png" alt=""></p>

<p>除了根组件之外，在许多情况下可以导出组件的类型。这就是为什么它在组件文字中是可选的。如果没有给出类型，则将从作业的左侧推断出。指定的功能可以是模块的声明属性，也可以是Java类的<code>set</code>或<code>add</code> -method。</p>

<p>可以命名组件以使其在后续分配中具有可参考性。在<code>':'</code>关键字后面，可以为实例化组件定义标识符。标识符在模块中是本地可见的，并且在命名组件之后定义的任何赋值都可以引用此标识符，从而精确指向实例化对象。</p>

<p>组件的下一个选项是<code>auto-inject</code> 。如果在组件上设置了此修饰符，则将自动分配与属性或先前创建的命名组件具有相同名称的组件的任何可用功能。</p>

<p>组件的核心是花括号之间的分配列表。可以通过特征 - 值对在组件上设置任意数量的值。</p>

<p><img src="images/mwe2/assignment.png" alt=""></p>

<p>赋值右侧的可用构造与属性的默认值相同。</p>

<h3 id="mwe2-string-literals-syntax">字符串文字</h3>

<p>字符串值可能是MWE2中使用最多的文字。由于描述性对象组合和配置语言的高度相关性，因此可以使用方便的字符串连接语法。MWE2字符串是多行字符串，可以由多个部分组成。</p>

<pre><code class="language-mwe2">var aString ='a value'var anotherString ='可以将$ {aString}嵌入到多行字符串中'</code></pre>

<p>如果定义例如公共根目录并且想要指定相对于基础的其他路径，则这对于路径替换特别方便。</p>

<p>字符串有两种不同的分隔符。用户可以使用单引号或双引号来开始和结束字符串。如果某个字符串包含大量单引号，则最好选择双引号作为分隔符，反之亦然。两种符号之间没有语义差异。</p>

<p>MWE2中的转义字符是反斜杠<code>"\\"</code> 。它可以用于显式地写行换行符或表格字符，以及转义替换变量<code>${</code>和引号本身的开头。允许的转义序列是：</p>

<table>
  <tbody>
    <tr>
      <td><code>\ n</code></td>
      <td>越线</td>
    </tr>
    <tr>
      <td><code>\ r</code></td>
      <td>回车</td>
    </tr>
    <tr>
      <td><code>\ t</code></td>
      <td>表格字符</td>
    </tr>
    <tr>
      <td><code>\”</code></td>
      <td>单引号（可以在双引号字符串中省略）</td>
    </tr>
    <tr>
      <td><code>\”</code></td>
      <td>双引号（可以在单引号字符串中省略）</td>
    </tr>
    <tr>
      <td><code>\ $ {</code></td>
      <td>转义替换变量start $ {</td>
    </tr>
    <tr>
      <td><code>\\</code></td>
      <td>反斜杠本身</td>
    </tr>
  </tbody>
</table>

<p>其他转义序列在MWE2字符串中是非法的。</p>

<h3 id="mwe2-boolean-literals">布尔文字</h3>

<p>MWE2本身支持布尔类型。文字是<code>true</code>和<code>false</code> 。</p>

<h3 id="mwe2-references">参考</h3>

<p>MWE2中的每个赋值都可以是属性或组件赋值的默认值，可以是对先前声明的属性或命名组件的引用。可以通过名称直观地引用。</p>


</body>
</html><html id="0601.slibmod.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<link rel="stylesheet" href="images/../../../css/book.css" type="text/css"></link>
<link rel="stylesheet" href="images/../../../css/emf-book.css" type="text/css"></link>
<title>生成扩展的EMF模型</title>
</head>
<body lang="EN-US" dir="ltr" xml:lang="EN-US">
<h1>生成扩展的EMF模型</h1>

<p>最后更新时间：2006年5月31日</p>

<p>本教程是<a href="../../tutorials/clibmod/clibmod.html">生成EMF模型</a>的后续内容，其中<a href="../../tutorials/clibmod/clibmod.html">生成了</a>一个简单的库模型。在该教程中，我们展示了如何从Rose模型或一组Java接口文件中轻松生成EMF模型。在本教程中，我们将向您展示如何生成扩展现有模型的EMF模型。</p>

<p>首先，让我们回顾一下库模型：</p>
<img src="images/../../clibmod/images/model.gif" alt="库UML模型">

<p>我们现在将通过创建一个新的包，schoollibrary来扩展这个库模型。这个包包含三个类，其中两个扩展了库模型中的类：</p>
<img src="images/model.gif" alt="Schoollibrary UML模型">

<p>本教程将逐步向您展示如何使用您已创建的库模型生成此schoollibrary包的EMF模型。与前一个教程一样，我们将演示如何从Rose模型和一组Java接口创建这个新模型。</p>

<p>屏幕截图基于Eclipse SDK的3.2.0版RC6和EMF版本2.2.0 RC6a。</p>

<hr>
<h2>内容</h2>

<table border="0" cellspacing="2" cellpadding="2" width="100%">
<tr>
<td valign="top">步骤1：</td>
<td valign="top"><a href="#step1a">从Rose导入模型</a>或<a href="#step1b">使用带注释的Java定义模型</a>
</td>
</tr>

<tr>
<td valign="top">第2步：</td>
<td valign="top"><a href="#step2">生成EMF模型和编辑器代码</a>
</td>
</tr>

<tr>
<td valign="top">第3步：</td>
<td valign="top"><a href="#step3">运行生成的编辑器</a> </td>
</tr>

<tr>
<td valign="top">第4步：</td>
<td valign="top"><a href="#step4">修改编辑器</a>
</td>
</tr>

<tr>
<td valign="top">附录：</td>
<td valign="top"><a href="#appendix">生成模型的另一种方法</a>
</td>
</tr>
</table>
<br>

<hr>
<p style="text-align:right"><a id="step0" name="step0"> </a> <a href="#top">内容</a></p>
<h2>第0步：先决条件</h2>

<p>库模型和编辑器是在上一个教程“ <a href="../../tutorials/clibmod/clibmod.html">生成EMF模型”中生成的</a> 。</p>

<ul>
<li>启动Eclipse并验证这三个项目是否显示在Resource透视图的Navigator视图中：“library”，library.edit“和”library.editor“。<br>
<img src="images/img001.gif" alt="现有的库项目"><br>
 </li>
</ul>

<p>如果未列出这些软件包，则需要完成上一个教程，或者参阅<a href="#appendix">附录</a> ，了解如何一次创建两个模型。</p>

<hr>
<p style="text-align:right"><a id="step1a" name="step1a"> </a> <a href="#top">内容</a></p>
<h2>步骤1a：从Rose导入模型</h2>

<p>将Rose模型文件<a href="images/../schoollibrary.mdl" target="_code">schoollibrary.mdl</a>保存在工作站的某个位置。它包含图书馆和学校图书馆套餐。</p>

<p>在各种模型之间共享包时，我们确实应该将每个包放在自己的.cat文件中，并在.mdl文件中引用它们。但是，出于本教程的目的，我们只是将库包复制并扩展到单个模型文件中。无论包是在单个.mdl文件中还是在外部.cat文件中引用，生成器的行为都完全相同。<br>
</p>

<p>在工作区中创建一个新的EMF项目：</p>

<ul>
<li>打开“文件/新建/项目...”对话框。<br>
<img src="images/../../clibmod/images/img101.gif" alt="文件/新建/项目..."><br>
 </li>

<li>展开“Eclipse Modeling Framework”并选择“EMF Project”。单击“下一步”按钮。<br>
<img src="images/../../clibmod/images/img102.gif" alt="EMF项目"><br>
 </li>

<li>为项目命名，例如“schoollibrary”，然后单击“下一步”按钮。<br>
<img src="images/img101.gif" alt="为项目命名"><br>
 </li>

<li>选择“Rose class model”并单击“Next”按钮。<br>
<img src="images/../../clibmod/images/img104.gif" alt="玫瑰级模特"><br>
 </li>

<li>单击“浏览”按钮并使用文件对话框找到Rose模型文件。将检查该文件，并建议使用默认的生成器型号名称。如果您愿意，可以在输入框中更改名称。然后，单击“下一步”按钮。<br>
<img src="images/img102.gif" alt="浏览Rose文件和名称生成器模型"><br>
 </li>

<li>Rose模型包含两个包，“org.eclipse.example.library”和“org.eclipse.example.schoollibrary”。我们只选择我们想要生成的包“org.eclipse.example.schoollibrary”。但是，因为后一个包中包含对前者类的引用，所以我们需要指定在哪里找到该模型，以便可以重用它。单击“浏览”按钮。<br>
<img src="images/img103.gif" alt="选择包裹"><br>
 </li>

<li>在文件选择对话框中，展开包含库模型的文件夹，然后选择生成器模型“library.genmodel”。单击“确定”按钮。<br>
<img src="images/img104.gif" alt="选择参考模型"><br>
 </li>

<li>展开“Library”模型，然后选择“org.eclipse.example.library”包。请注意，错误消息消失。单击“完成”按钮。<br>
<img src="images/img105.gif" alt="选择引用的包"><br>
 </li>

<li>将创建Ecore模型（schoollibrary.ecore）和生成器模型（schoollibrary.genmodel）。后者在主视图中打开。<br>
<img src="images/img106.gif" alt="打开发电机"><br>
 </li>
</ul>

<hr>
<p style="text-align:right"><a id="step1b" name="step1b"> </a> <a href="#top">内容</a></p>
<h2>步骤1b：使用带注释的Java定义模型</h2>

<p>以下是schoollibrary包的带注释的Java接口。我们可以从这些接口文件生成EMF模型，而不是Rose模型。</p>

<blockquote>
<strong><a href="images/../SchoolLibrary.java" target="_code">SchoolLibrary.java</a></strong> <a name="schoollibrarysrc"> </a><br>

<table border="1" frame="box"><tr><td>
<pre>包org.eclipse.example.schoollibrary; import org.eclipse.example.library。图书馆; / ** * @model * / public interface SchoolLibrary扩展了库{/ ** * @model * / String getLocation（）; }</pre>
</td></tr></table>
</blockquote>

<blockquote>
<strong><a href="images/../Asset.java" target="_code">Asset.java</a></strong> <a name="assetsrc"> </a><br>

<table border="1" frame="box"><tr><td>
<pre>包org.eclipse.example.schoollibrary; / ** * @model * / public interface Asset {/ ** * @model * / float getValue（）; }</pre>
</td></tr></table>
</blockquote>

<blockquote>
<strong><a href="images/../SchoolBook.java" target="_code">SchoolBook.java</a></strong> <a name="schoolbooksrc.java"> </a><br>

<table border="1" frame="box"><tr><td>
<pre>包org.eclipse.example.schoollibrary; import org.eclipse.example.library。书; / ** * @model * / public interface SchoolBook扩展Book，Asset {}</pre>
</td></tr></table>
</blockquote>

<p>在工作区中创建一个新的空EMF项目：</p>

<ul>
<li>打开“文件/新建/项目...”对话框。<br>
<img src="images/../../clibmod/images/img101.gif" alt="文件/新建/项目..."><br>
 </li>

<li>展开“Eclipse Modeling Framework”并选择“Empty EMF Project”。单击“下一步”按钮。<br>
<img src="images/../../clibmod/images/img121.gif" alt="空EMF项目"><br>
 </li>

<li>为项目命名，例如“schoollibrary”，然后单击“完成”按钮。<br>
<img src="images/img121.gif" alt="为项目命名"><br>
 </li>
</ul>

<p>在现有库项目上添加插件依赖项：</p>

<ul>
<li>在Package Explorer视图中，展开“schoollibrary / META-INF”并双击“MANIFEST.MF”以打开Plug-in Manifest Editor。<br>
<img src="images/img122.gif" alt="打开插件清单编辑器"><br>
 </li>

<li>切换到“依赖关系”选项卡，然后单击“必需的插件”下的“添加...”按钮。<br>
<img src="images/img123.gif" alt="切换到Depedencies选项卡，然后单击Add"><br>
 </li>

<li>选择“库”插件，然后单击“确定”按钮。<br>
<img src="images/img123b.gif" alt="选择依赖插件：库"><br>
 </li>

<li>将更改保存到清单文件并关闭编辑器。<br>
<img src="images/img124.gif" alt="清单中添加了新的插件依赖项"><br>
 </li>
</ul>

<p>你可以像上一个教程一样创建和输入界面，但是我们将在这里展示如何从zip文件<a href="images/../schoollibrary.zip">schoollibrary.zip中</a>导入它们。将此文件保存在工作站的某个位置，或者保存在工作区中的其他空项目中。</p>

<ul>
<li>右键单击“src”文件夹，然后从弹出菜单中选择“导入...”。<br>
<img src="images/img125.gif" alt="进口..."><br>
 </li>

<li>展开“常规”并选择“存档文件”作为导入源。单击“下一步”按钮。<br>
<img src="images/img126.gif" alt="选择导入源"><br>
 </li>

<li>单击“浏览”按钮，找到zip文件。确保选中所有zip文件的内容。您可以展开文件夹树并单击“schoollibrary”以查看其包含的文件。确保将它们导入“schoollibrary / src”。单击“完成”按钮。<br>
<img src="images/img127.gif" alt="选择一个zip文件"><br>
 </li>

<li>展开“src”文件夹并观察接口是否已导入。<br>
<img src="images/img128.gif" alt="导入的接口"><br>
 </li>
</ul>

<p>创建EMF模型：</p>

<ul>
<li>右键单击“model”文件夹，然后从弹出菜单中选择“New / Other ...”。<br>
<img src="images/img129.gif" alt="新建/其他..."><br>
 </li>

<li>展开“Eclipse Modeling Framework”并选择“EMF Model”。单击“下一步”按钮。<br>
<img src="images/../../clibmod/images/img131.gif" alt="EMF模型"><br>
 </li>

<li>将文件名更改为“schoollibrary.genmodel”，然后单击“下一步”按钮。<br>
<img src="images/img130.gif" alt="输入文件名"><br>
 </li>

<li>选择“Annotated Java”并单击“Next”按钮。<br>
<img src="images/../../clibmod/images/img134.gif" alt="带注释的Java"><br>
 </li>

<li>选择“org.eclipse.example.schoollibrary”包，然后单击“完成”按钮。<br>
<img src="images/img131.gif" alt="选择包裹"><br>
 </li>

<li>将创建Ecore模型（schoollibrary.ecore）和生成器模型（schoollibrary.genmodel）。后者在主视图中打开。<br>
<img src="images/img132.gif" alt="打开发电机"><br>
 </li>
</ul>

<hr>
<p style="text-align:right"><a id="step2" name="step2"> </a> <a href="#top">内容</a></p>
<h2>第2步：生成EMF模型和编辑器代码</h2>

<p>生成器模型显示根对象，表示整个模型。此模型对象的子项代表模型中的包。</p>

<ul>
<li>展开模型以查看其各种元素。请注意，“Library”包的图标有一个重叠箭头，表示它是对现有库项目中定义的包的引用。<br>
<img src="images/img201.gif" alt="扩展的发电机模型"><br>
 </li>

<li>通过右键单击根元素并从弹出菜单中选择“Generate All”，可以在一个步骤中为模型中的所有包生成模型代码和编辑器。这也将创建一个测试插件，其中包含生成的JUnit测试代码。<br>
<img src="images/img202.gif" alt="全部生成"><br>
 </li>

<li>代码生成到schoollibrary，schoollibrary.edit，schoollibrary.editor和schoollibrary.tests项目中。不会生成引用模型库的代码。<br>
<img src="images/img203.gif" alt="生成的文件"><br>
 </li>
</ul>

<p>代码应该在生成时自动编译，并且应该在更改时重新编译。如果您在工作台首选项中禁用了自动构建，请不要忘记在代码发生更改时重建代码。</p>

<hr>
<p style="text-align:right"><a id="step3" name="step3"> </a> <a href="#top">内容</a></p>
<h2>第3步：运行生成的编辑器</h2>

<p>为了测试新的插件，必须启动Eclipse的第二个实例。插件将在此工作台中运行。</p>

<ul>
<li>选择其中一个项目，然后从“运行”菜单或工具栏下拉列表中选择“运行方式/ Eclipse应用程序”。<br>
<img src="images/../../clibmod/images/img401.gif" alt="运行As / Eclipse应用程序"><br>
 </li>

<li>等待Eclipse IDE的第二个实例出现。打开“帮助/关于Eclipse平台”对话框，单击“插件详细信息”按钮，并验证生成的插件是否存在。<br>
<img src="images/img301.gif" alt="生成的插件：schoollibrary.edit，schoollibrary.editor，schoollibrary"><br>
 </li>
</ul>

<p>Schoollibrary Model向导现在可用于创建模型的新实例。</p>

<ul>
<li>打开“文件/新建/项目...”对话框。展开“常规”，选择“项目”，然后单击“下一步”按钮。为项目命名，然后单击“完成”按钮。<br>
<img src="images/img302.gif" alt="为项目命名"><br>
 </li>

<li>右键单击项目，然后从弹出菜单中选择“新建/其他...”。<br>
<img src="images/img303.gif" alt="新建/其他..."><br>
 </li>

<li>展开“示例EMF模型创建向导”并选择“Schoollibrary模型”。单击“下一步”按钮。<br>
<img src="images/img304.gif" alt="学校图书馆模式"><br>
 </li>

<li>输入schoollibrary模型的文件名。确保它以“.schoollibrary”扩展名结尾。然后，单击“下一步”按钮。<br>
<img src="images/img305.gif" alt="命名schoollibrary模型文件"><br>
 </li>

<li>选择“SchoolLibrary”作为模型对象，然后单击“完成”按钮。<br>
<img src="images/img306.gif" alt="选择模型对象"><br>
 </li>

<li>新创建的模型在主视图中打开。<br>
<img src="images/img307.gif" alt="新的学校图书馆模式"><br>
 </li>
</ul>

<p>此编辑器中的根对象对应于My.schoollibrary资源。请注意，它下面的对象确实是一个学校图书馆。</p>

<ul>
<li>展开“platform：/resource/librarytest/My.schoollibrary”资源以查看“School Library”对象。选择它。<br>
<img src="images/img308.gif" alt="扩大资源"><br>
 </li>

<li>如果尚未显示“属性”视图，请右键单击“School Library”对象，然后从弹出菜单中选择“显示属性视图”。为“位置”和“名称”属性输入一些值。<br>
<img src="images/img309.gif" alt="学校图书馆物业"><br>
 </li>

<li>右键单击学校库，然后从弹出菜单中选择“新建子项”。请注意，可以在学校图书馆下创建三种对象：“Writer”，“Book”和“School Book”。Writer和Book在库包中定义，而SchoolBook在schoollibrary包中定义。<br>
<img src="images/img310.gif" alt="新生儿"><br>
 </li>

<li>创建几个作家，一本书和一本教科书。请注意，SchoolBook继承了Book的所有属性，并按照我们的意图添加了额外的属性（值）。<br>
<img src="images/img311.gif" alt="学校书籍属性"><br>
 </li>

<li>保存模型。<br>
<img src="images/img312.gif" alt="文件/保存"><br>
 </li>
</ul>

<p>退出Eclipse的第二个实例，返回原始的开发工作台。</p>

<hr>
<p style="text-align:right"><a id="step4" name="step4"> </a> <a href="#top">内容</a></p>
<h2>第4步：修改编辑器</h2>

<p>本教程的这一部分将介绍如何修改生成的代码。我们只是在生成的编辑器中更改标签，但我们将以一些不同的，说明性的方式来完成。</p>

<p>首先，我们将对生成器模型进行更改，这将影响生成的代码。</p>

<ul>
<li>在学校图书馆生成器模型中，选择“SchoolLibrary”类。在“属性”视图中，将“标签功能”更改为“location：EString”属性。这将确定将在SchoolLibrary对象的标签中使用哪个功能。<br>
<img src="images/img401.gif" alt="更改标签功能"><br>
 </li>

<li>要使此更改生效，我们只需要为SchoolLibrary重新生成项目提供程序类。保存更改，然后右键单击“SchoolLibrary”并从弹出菜单中选择“生成编辑代码”。这将生成这一个项目提供程序，以及包含包和模型的编辑工件。重新生成所有代码也没有坏处，但是，它只需要更长的时间。<br>
<img src="images/img402.gif" alt="生成编辑代码"><br>
 </li>
</ul>

<p>下表总结了由不同对象的上下文相关菜单中的“生成模型代码”，“生成编辑代码”，“生成编辑器代码”和“生成测试代码”菜单项生成的文件。“Generate All”菜单项相当于选择所有三个菜单项。</p>

<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tr>
<td valign="top"> </td>
<td valign="top">生成模型代码</td>
<td valign="top">生成编辑代码</td>
<td valign="top">生成编辑器代码</td>
<td valign="top">生成测试代码</td>
</tr>

<tr>
<td valign="top">型号&lt;M&gt;</td>
<td valign="top">MANIFEST.MF<br>build.properties<br>plugin.properties<br>plugin.xml中<br>&lt;M&gt; Plugin.java *<br>...加上每个包的文件</td>
<td valign="top">MANIFEST.MF<br>build.properties<br>plugin.properties<br>plugin.xml中<br>&lt;M&gt; EditPlugin.java<br>...加上每个包的文件</td>
<td valign="top">MANIFEST.MF<br>build.properties<br>plugin.properties<br>plugin.xml中<br>&lt;M&gt; EditorPlugin.java<br>&lt;M&gt; EditorAdvisor.java *<br>...加上每个包的文件</td>
<td valign="top">MANIFEST.MF<br>build.properties<br>plugin.properties<br>plugin.xml中<br>&lt;M&gt; AllTests.java<br>...加上每个包的文件</td>
</tr>

<tr>
<td valign="top">包装&lt;P&gt;</td>
<td valign="top">&lt;P&gt; Package.java<br>&lt;P&gt; PackageImpl.java<br>&lt;P&gt; Factory.java<br>&lt;P&gt; FactoryImpl.java<br>&lt;P&gt; Switch.java<br>&lt;P&gt; AdaptorFactory.java<br>&lt;P&gt; ResourceImpl.java *<br>&lt;P&gt; ResourceFactoryImpl.java *<br>&lt;P&gt; Validator.java *<br>&lt;P&gt; XMLProcessor.java *<br>...加上每个类和枚举的文件<br>并为模型</td>
<td valign="top">&lt;P&gt; ItemProviderAdaptorFactory.java<br>...加上每个班级的文件<br>并为模型</td>
<td valign="top">&lt;P&gt; Editor.java<br>&lt;P&gt; ModelWizard.java<br>&lt;P&gt; ActionBarContributor.java<br>...加上模型的文件</td>
<td valign="top">&lt;P&gt; Tests.java<br>&lt;P&gt; Example.java<br>...加上每个班级的文件<br>并为模型</td>
</tr>

<tr>
<td valign="top">类&lt;C&gt;</td>
<td valign="top">&lt;C&gt;的.java<br>&lt;C&gt; Impl.java<br>...加上包的文件</td>
<td valign="top">&lt;C&gt; ItemProvider.java<br>...加上包的文件</td>
<td valign="top"> </td>
<td valign="top">&lt;C&gt; Test.java<br>...加上包的文件</td>
</tr>

<tr>
<td valign="top">Enum &lt;E&gt;</td>
<td valign="top">&lt;E&gt;的.java<br>...加上包的文件</td>
<td valign="top"> </td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>
</table>

<p>*默认情况下不会生成这些文件。</p>

<p>现在，我们可以测试我们的变化。</p>

<ul>
<li>再次启动Eclipse的第二个实例（“Run / Run As / Eclipse Application”）打开“My.schoollibrary”资源。展开资源对象并选择学校库。请注意，学校图书馆的位置显示在标签中，而不是名称。<br>
<img src="images/img403.gif" alt="学校图书馆与位置标签"><br>
 </li>
</ul>

<p>现在假设您不喜欢标签中的前缀“School Library”并希望摆脱它。执行此操作的唯一方法是编辑代码，但这是一个很容易的更改。</p>

<p>如<a href="../../references/overview/EMF.Edit.html">EMF.Edit框架概述中所述</a> ，EMF.Edit使用项目提供程序来确定要为给定类型的对象显示的标签。特别是，getText（）方法执行此操作，我们需要更改。</p>

<ul>
<li>在Package Explorer中，展开“schoollibrary.edit”项目。找到并打开“SchoolLibraryItemProvider.java”。<br>
<img src="images/img404.gif" alt="找到SchoolLibraryItemProvider.java"><br>
 </li>

<li>在Outline视图中找到“getText（）”方法并选择它。<br>
<img src="images/img405.gif" alt="选择getText（）"><br>
 </li>

<li>Java编辑器中的光标将移动到该方法。<br>
<img src="images/img406.gif" alt="getText（）的生成实现"><br>
 </li>

<li>从return语句中删除第二个getString（）调用，该调用预先呈现外化类名称字符串。为了确保在重新生成代码时不会丢失更改，还需要删除“@generated”Javadoc标记。<br>
<img src="images/img407.gif" alt="修改了getText（）实现：删除了@generated，并将三元运算符的最终操作数更改为label"><br>
 </li>

<li>保存更改，再次启动Eclipse的第二个实例，并打开“My.schoollibrary”。请注意，学校图书馆的标签现在只包含其location属性的值。<br>
<img src="images/img408.gif" alt="学校图书馆有不合格的地点标签"><br>
 </li>
</ul>

<p>我们已经从最初生成的内容中更改了getText（）的实现。生成器模型中SchoolLibrary类的label feature属性不再对生成的代码产生任何影响。这是因为我们删除了@generated Javadoc标记，防止在代码生成期间覆盖此方法。</p>

<p>现在假设您尚未确定编辑器是否应显示location属性或name属性的值。相反，您希望以后能够通过生成器模型进行更改。但是，您知道您不希望显示“School Library”前缀。从本质上讲，您希望保持生成的实现可供手动编码方法使用，该方法从返回的内容中删除前缀。必须将新方法称为“getText（）”，因此必须重命名生成的方法。</p>

<p>幸运的是，EMF代码生成器支持这一点：当它要生成的方法与没有@generated标记的方法冲突时，它会查找具有相同名称加上后缀“Gen”的方法。如果该方法存在并标记为“@generated”，则将在此方法中生成实现。</p>

<ul>
<li>将getText（）方法重命名为“getTextGen（），保持其”@generated“标记不变。要显示它将真正重新生成，请删除方法体并将其替换为单个return语句。创建一个getText（）方法，从getTextGen（）返回的字符串中删除前缀。<br>
<img src="images/img409.gif" alt="清空getTextGen（）实现和手工编写的getText（）"><br>
 </li>

<li>保存SchoolLibraryItemProvider.java，切换回生成器模型，选择“SchoolLibrary”，然后重新生成编辑代码。<br>
<img src="images/img410.gif" alt="生成编辑代码"><br>
 </li>

<li>切换回SchoolLibraryItemProvider.java中的getTextGen（）方法。请注意，原始实现已生成回其中。<br>
<img src="images/img411.gif" alt="重新生成getTextGen（）"><br>
 </li>
</ul>

<p>您可以返回生成器模型，更改标签功能属性，重新生成代码，并验证这确实会影响生成的代码。</p>

<hr>
<p style="text-align:right"><a id="appendix" name="appendix"> </a> <a href="#top">内容</a></p>
<h2>附录：生成模型的另一种方法</h2>

<p>如果您还没有基础库模型，其编辑器在单独的项目中生成，则可以在一个步骤中将库和学校库模型生成到同一组项目中。这可以通过Rose模型或一组带注释的Java接口来完成。</p>

<p>从Rose模型开始，该过程与上述过程相同，除了选择两个包用于代码生成。</p>

<ul>
<li>在New Project向导的最后一页上，选择“org.eclipse.example.library”和“org.eclipse.example.schoollibrary”包，而不是引用它们。<br>
<img src="images/img501.gif" alt="选择两个包进行代码生成"><br>
 </li>
</ul>

<p>从带注释的Java接口开始，在完成任何代码生成之前，将两个包导入到单个空EMF项目中。</p>

<ul>
<li>从<a href="images/../library.zip">library.zip</a>和<a href="images/../schoollibrary.zip">schoollibrary.zip</a>导入包。<br>
 </li>

<li>在New Models向导的最后一页上，选择“org.eclipse.example.library”和“org.eclipse.example.schoollibrary”包。<br>
<img src="images/img502.gif" alt="选择两个包进行代码生成"><br>
 </li>
</ul>

<p>当您启动运行时工作空间来测试新编辑器时，您可能会注意到库模型编辑器的一个小差异，与我们从学校图书馆模型中单独生成它时相比。</p>

<ul>
<li>创建或打开库模型，展开资源对象，然后右键单击“库”对象。选择“新建子项”菜单项。<br>
<img src="images/img503.gif" alt="新生儿"><br>
 </li>
</ul>

<p>请注意，有三种类型的子项可用，而在上一个教程中，只有两种。具体而言，包括来自学校图书馆套餐的“学校图书”。以前，代码生成器在为库生成项提供程序时并不知道它。现在，由于两个包是一起生成的，因此基本包知道扩展它的包的所有内容。</p>

<hr>
<p style="text-align:right"><a href="#top">内容</a></p>
</body>
</html><html id="1627.Tasks.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>LDT用户指南 - 任务</title>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">任务</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="以前" border="0" src="../../../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">概念</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table><hr>
		<h1 id="Tasks">任务</h1>
		<h2 id="Configuring_Build_paths">配置构建路径</h2>
		<p>请参阅<a href="Concepts.html#Buildpath">Buildpath</a> 。
		</p>
		<h3 id="Adding_source_folder">添加源文件夹</h3>
		<p>您可以通过右键单击源路径中的文件夹，然后选择<i>BuildPath&gt; Use as Source Folder</i> <img align="middle" border="0" src="images/AddFolderToSourcePath0.9.png">
		</p>
		<h3 id="Adding_project_dependencies">添加项目依赖项</h3>
		<p>在要添加依赖项的项目o上，右键单击并选择“构建路径”&gt;“配置构建路径...”''。</p>
		<p>
			<img align="middle" border="0" src="images/BuildPath.png">
		</p>
		<p>然后选择<i>Projects</i>选项卡并使用<i>Add</i>按钮创建依赖项。
		</p>
		<p>
			<img align="middle" border="0" src="images/AddProjectDependency0.9.png">
		</p>
		<h2 id="Managing_Execution_Environments">管理执行环境</h2>
		<p>请参阅<a href="Concepts.html#Execution_Environment">执行环境</a> 。
		</p>
		<p>要查找与执行环境相关的首选项，请转到<i>窗口&gt;首选项&gt; Lua&gt;执行环境</i> ，您将拥有以下界面。
		</p>
		<p>
			<img align="middle" border="0" src="images/EePref_10.png">
		</p>
		<p>正如您在前面的屏幕截图中看到的， <i>LDT</i>附带了<i>Lua 5.1执行环境</i> 。LDT附带的所有执行环境都以<i>（嵌入式）</i>为后缀。
		</p>
		<p>从这里，是否可以将执行环境添加到当前工作空间。首先，从<a href="http://wiki.eclipse.org/LDT/User_Area/Available_Execution_Environments" target="doc_external">可用的执行环境列表中</a>下载<a href="http://wiki.eclipse.org/LDT/User_Area/Available_Execution_Environments" target="doc_external">执行环境</a>或<a href="http://wiki.eclipse.org/LDT/User_Area/Execution_Environment_file_format" target="doc_external">创建一个执行环境</a> 。然后，返回<i>Execution Environments</i>首选项页面，按“ <i>添加”</i>按钮并选择“执行环境”文件。
		</p>
		<p>
			<img align="middle" border="0" src="images/EePrefAdd0.9.png">
		</p>
		<p>现在可以使用执行环境了。</p>
		<p>
			<img align="middle" border="0" src="images/EePrefAdded10.png">
		</p>
		<p>''如果需要覆盖已安装的嵌入式执行环境，请创建一个具有相同名称的新执行环境并添加它。使用嵌入式执行环境的所有项目都将自动使用新的项目。“”</p>
		<h3 id="Link_an_existing_project_to_an_Execution_Environment">将现有项目链接到执行环境</h3>
		<p>如果您创建了没有执行环境的项目，则可以在之后添加一个项目。右键单击项目，然后选择<i>Build Path&gt; Add Libraries ....</i>请注意，每个项目只需要一个执行环境。
		</p>
		<p>
			<img align="middle" border="0" src="images/EeContextSelection.png">
		</p>
		<p>您必须在几种库类型之间进行选择，选择<i>Lua Execution Environment</i> 。
		</p>
		<p>
			<img align="middle" border="0" src="images/EeAddLib.png">
		</p>
		<p>您现在可以在已安装的执行环境中进行选择，然后按“ <i>完成”</i> 。
		</p>
		<p>
			<img align="middle" border="0" src="images/SelectEE10.png">
		</p>
		<p>它现在链接到选定的项目。</p>
		<p>
			<img align="middle" border="0" src="images/EeAddedToProject.png">
		</p>
		<h2 id="Managing_Interpreters">管理口译员</h2>
		<p><i>LDT</i>使用解释器在本地计算机上运行脚本，请参阅<a href="Concepts.html#Interpreters">解释器</a> 。
		</p>
		<h3 id="Embedded_Interpreters">嵌入式口译员</h3>
		<p>嵌入式解释器是<i>LDT</i>附带的解释器。您可以在解释器首选项页面上识别它们，它们的位置被称为<i>（嵌入式）</i> 。目前， <i>LDT</i>随JNLua（Lua 5.1）嵌入式解释器一起提供，JNLua是Lua解释器和API的Java绑定。</p>
		<h3 id="Local_Interpreters">当地口译员</h3>
		<p>要使用本地安装的Lua解释器的Lua本地应用程序启动配置在<i>LDT中</i>运行Lua脚本，您必须配置本地解释器。要配置解释器，您只需要解释器可执行文件的路径，然后您可以设置解释器参数和一些环境变量。
		</p>
		<p>请参阅下文，了解如何引用计算机上安装的Lua解释器，并在<i>LDT中</i>使用它。</p>
		<p>要打开Interpreters首选项页面，请转到<i>Window&gt; Preferences&gt; Lua&gt; Interpreters</i> ： <img align="middle" border="0" src="images/InterpreterPreferencePage_1.2.png">
		</p>
		<p>然后，按<i>添加...</i>按钮配置新的解释器并填写如下所述的字段：</p>
		<ul>
			<li>选择以下解释器类型之一：<ul>
					<li>
						<b>JNLua 5.1</b>或<b>JNLua 5.2</b>类型的解释器基于LDT嵌入式JNLua解释器。
					</li>
					<li>
						<b>Lua 5.1</b>或<b>Lua 5.2</b>类型的标准Lua解释器。
					</li>
					<li>
						用于Lua JIT 2.0解释器的<b>LuaJIT 2.0</b>类型。
					</li>
					<li>
						对于没有任何其他类型的口译人员的<b>通用Lua</b>类型。
					</li>
				</ul>
			</li>
			<li>您可以浏览文件系统并找到解释器可执行文件，或者如果可执行文件位于PATH环境变量中，只需在此处键入其名称（例如<code>lua</code> ）。</li>
			<li>为解释器命名（这是必需的）。</li>
			<li>如果需要，添加额外的解释器参数，就像在常规命令行上一样。</li>
			<li>为此解释器设置环境变量。您可以修改现有变量或创建新变量。可以使用属性文件导出和导入环境变量。</li>
			<li>设置解释器功能：<ul>
					<li>如果您的解释器不接受在官方Lua解释器之前执行给定代码的<i>-e <a href="code">代码</a></i>选项，则取消选中<i>Accept -e <a href="code">code</a>作为参数</i> 。ide使用此选项来启动调试器，因此如果未选中此选项，则您有责任自行启动调试器，如<a href="Tasks.html#Configuring_debug_sessions">配置调试会话</a>部分中的说明。
					</li>
					<li>如果您的解释器不将文件作为参数运行，则取消选中<i>Accept file作为参数</i> ，这意味着您的解释器必须自己运行Lua文件。
					</li>
				</ul>
			</li>
		</ul>
		<p>
			<img align="middle" border="0" src="images/AddInterpreter_1.2.png">
		</p>
		<p>按下“ <i>确定”</i>按钮后，创建的解释器将出现在“解释器”页面中。每个解释器前面的复选框允许检查启动配置中使用的默认解释器。

			<img align="middle" border="0" src="images/InterpreterAdded_1.0.png">
		</p>
		<h2 id="Configuring_debug_sessions">配置调试会话</h2>
		<p>请参阅<a href="Concepts.html#Debug">有关</a>在<i>LDT中</i> <a href="Concepts.html#Debug">调试的三种方法</a>的<a href="Concepts.html#Debug">说明</a> 。</p>
		<h3 id="Local_session">本地会议</h3>
		<p>根据解释器首选项中设置的解释器功能，如果您的解释器不处理“-e”选项。您必须通过添加以下代码来启动调试器：</p>
		<pre class="source-lua">如果os.getenv（'DEBUG_MODE'）则需要“debugger”（）结束</pre>
		<p>
			<b>注意：</b> <i><code>DEBUG_MODE</code></i>环境变量仅为<i>debug</i>设置，以避免启动常规<i>运行</i>的调试器。
		</p>
		<p>在<i>Debug Configuration</i>菜单中创建Lua Application启动配置。

			<img align="middle" border="0" src="images/DebugConfiguration.png">
		</p>
		<p>在<i>Main</i>选项卡中，您可以选择项目，要启动的脚本和Lua解释器。

			<img align="middle" border="0" src="images/MainLocalLaunchConfig.png">
		</p>
		<p>在<i>Arguments</i>选项卡中，您可以指定解释器参数和脚本参数。解释器参数将在运行时合并到解释器级别（在解释器首选项页面中）指定的参数。

			<img align="middle" border="0" src="images/ArgumentsLocalLaunchConfig.png">
		</p>
		<p>在<i>Environment</i>选项卡中，您可以为运行时指定环境变量。定义的环境变量可以追加<img align="middle" border="0" src="images/EnvironmentLocalLaunchConfig.png">
		</p>
		<p>在<i>Common</i>选项卡中，您可以设置与启动配置相关的一些设置：</p>
		<ul>
			<li>将当前启动配置保存在指定文件中。</li>
			<li>在收藏夹菜单中查看启动配置。</li>
			<li>更改启动配置文件的编码。</li>
			<li>在控制台中分配标准输入/输出和/或在文件中重定向标准输出。</li>
		</ul>
		<h3 id="Attach_session">附加会话</h3>
		<p>Lua Development Tools的调试器基于DBGp协议，IDE实现了DBGp服务器。
			<br>要连接到此服务器并启动远程/附加调试，您需要使用DBGp Lua客户端。
		</p>
		<h4 id="Launching_DBGp_Client">启动DBGp客户端</h4>
		<p>DBGp Lua客户端是一个Lua文件，可以通过<b>Lua Attach to Application</b>启动配置UI下载。<br>
		</p>
		<p>
			<img align="middle" border="0" src="images/DownloadDebuggerClient0.9.png">
		</p>
		<p>它运行在类Unix操作系统和Windows（XP及更高版本）上。它是用<b>Lua编写的</b> ， <b>取决于lua-socket</b> 。
			<br>

			<i>您可以通过<a href="http://www.lua.org/download.html" target="doc_external">http://www.lua.org/download.html</a>获取Lua，并通过<a href="http://luarocks.org/en/Download" target="doc_external">luarocks</a>或您的官方操作系统存储库安装lua-socket。
			</i>
			<br>

			<i>如果由于某些原因你不能使用lua-socket，你可以根据自己的库实现自己的传输接口（参见<a href="http://git.eclipse.org/c/ldt/org.eclipse.ldt.git/tree/libraries/luadbgpclient/debugger/transport/fake.lua" target="doc_external">接口</a>和<a href="#transport_parameter">传输参数</a> ）</i>
			<br>
		</p>
		<p>要使用它，您必须在Lua路径中包含<tt>debugger.lua</tt>文件。
			<br>要开始连接，您必须执行此Lua代码：</p>
		<pre>&gt; local initconnection = require（“debugger”）&gt; initconnection（idehost，ideport，idekey）</pre>
		<p>这可以缩短为：</p>
		<pre>&gt; require（“调试器”）（idehost，ideport，idekey）</pre>
		<ul>
			<li>
				<b>idehost</b> ：DBGp服务器的主机名或IP地址（因此，您的IDE）。
				<ul>
					<li>如果<tt>idehost</tt>为<tt>nil</tt> ，则使用<tt>DBGP_IDEHOST</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，则使用默认值“127.0.0.1”。</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<b>ideport</b> ：DBGp服务器的端口（必须在IDE中配置）。
				<ul>
					<li>如果<tt>ideport</tt>为nil，则使用<tt>DBGP_IDEPORT</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，则使用默认值“10000”。</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<b>idekey</b> ：用作会话密钥的字符串（必须在IDE中配置）。
				<ul>
					<li>如果<tt>idekey</tt>为<tt>nil</tt> ，则使用<tt>DBGP_IDEKEY</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，则使用默认值“ <tt>luaidekey</tt> ”。</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>高级可选参数：</p>
		<ul>
			<li><span id="transport_parameter"><b>transport</b></span> ：实现用于与服务器通信的传输接口的模块的名称。
				<ul>
					<li>默认情况下，调试器使用基于luasocket的内部实现，但如果您不能使用它，则可以实现或使用其他传输层实现。</li>
					<li>如果<tt>transport</tt>为<tt>nil</tt> ，则使用<tt>DBGP_TRANSPORT</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，则使用默认值' <tt>debugger.transport.luasocket</tt> '：这是基于luasocket的默认实现。</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<b>platform</b> ：'unix'或'win32'字符串，用于定义要在其上执行调试程序的平台类型。
				<ul>
					<li>默认情况下，调试器会尝试猜测并经常成功。如果由于某种原因它失败了，你可以通过精确执行平台来帮助它。</li>
					<li>如果<tt>platform</tt>为<tt>nil</tt> ，则使用<tt>DBGP_PLATFORM</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，调试器将尝试猜测它。</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
				<b>workingdir</b> ：执行调试程序的工作目录。
				<ul>
					<li>默认情况下，调试器会尝试猜测并经常成功。如果由于某种原因它失败了，你可以通过精确工作目录来帮助它。</li>
					<li>如果<tt>workingdir</tt>为<tt>nil</tt> ，则使用<tt>DBGP_WORKINGDIR</tt>环境变量。
						<ul>
							<li>如果环境变量为<tt>nil</tt> ，调试器将尝试猜测它。</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>因此，要调试任何Lua脚本，您可以：</p>
		<pre>lua -e“require（'debugger'）（'idehost'，'ideport'）;” MyApp.lua</pre>
		<p>或者甚至只是去：</p>
		<pre>lua -e“require（'debugger'）（）;” MyApp.lua</pre>
		<p>如果您想依赖调试主机和端口的默认值（如果您没有调整任何<tt>DBGP_ *</tt>环境变量，则应该是127.0.0.1:10000）。</p>
		<p>
			<img align="left" border="0" src="images/Idea.png"> <b>控制台输出</b>
		</p>
		<dl>
			<dd>
				<dl>
					<dd>由于缓冲区配置，可能会发生某些控制台输出问题要在每次打印调用时强制stdout缓冲区刷新，您应该添加以下行：</dd>
					<dd><tt>io.stdout：调用setvbuf（ “线”）;</tt>或者<tt>io.stdout：setvbuf（“no”）;</tt>看<a href="http://www.lua.org/manual/5.1/manual.html#pdf-file:setvbuf" target="doc_external">Lua文档</a>
					</dd>
					<dd>整行看起来应该是这样的：</dd>
					<dd><tt>lua -e“io.stdout：setvbuf（'line'）; require（'debugger'）（）;” MyApp.lua</tt></dd>
				</dl>
			</dd>
		</dl>
		<h4 id="Setup_DBGp_Server">设置DBGp服务器</h4>
		<p>DBGp服务器集成在<i>LDT中</i> 。<br>要接受传入的调试会话，您必须创建一个新的<b>Lua Attach to Application</b>启动配置，然后启动它。
		</p>
		<p>进入<b>运行/调试配置....</b>
		</p>
		<p>
			<img align="middle" border="0" src="images/LuaAttachToApplication0.9.png">
		</p>
		<ul>
			<li>
				<b>项目</b> ：在工作区中选择<i>LDT</i>项目，其中包括要调试的应用程序的Lua源文件。
			</li>
			<li>
				<b>IdeKey</b> ：默认值为<tt>luaidekey</tt> ，如果需要同时调试多个应用程序，则应更改它以将启动配置与仅一个应用程序关联以进行调试。
			</li>
			<li>
				<b>源映射</b> ：为DBGp服务器（IDE）和DBGp客户端（运行应用程序）定义识别源文件的通用方法。有几种策略，每种策略或多或少都适应特定的用例。为了更好地理解，请阅读有关它的<a href="Concepts.html#Source_Mapping">高级文档</a> 。
			</li>
		</ul>
		<p>现在，您可以通过单击<b>Debug</b>启动调试会话。IDE将在调试视图中看到的端口上等待来自调试器客户端的传入连接。默认情况下，使用的端口是10000，但如果使用，则可以使用另一个端口。
			<br> 
		</p>
		<p>
			<img align="middle" border="0" src="images/LuaAttachToApplicationDebugView0.9.png"> 
		</p>
		<p>如果需要，可以在“ <i>窗口”&gt;“首选项”&gt;“动态语言”&gt;“调试”中</i>更改服务器端口。
		</p>
		<p>
			<img align="middle" border="0" src="images/ConfigureDebuggerPort0.9.png">
		</p>
		<h3 id="Remote_session">远程会话</h3>
		<p>由于远程调试是一项高级功能，大多数Lua开发人员都不需要。<i>LDT</i>不附带远程调试，之后必须下载并安装。要安装<i>LDT</i>远程功能，请先选择顶部菜单<i>帮助/安装新软件...</i>
		</p>
		<p>
			<img align="middle" border="0" src="images/InstallSoftware.png">
		</p>
		<p>在<i>LDT</i>更新站点上，选择列表中的远程功能并进行安装。 （参见<a href="https://wiki.eclipse.org/LDT/User_Area/updatesites" target="doc_external">LDT更新站点文档</a> ）</p>
		<p>
			<img align="middle" border="0" src="images/remoteFeature.png">
		</p>
		<p>在Remote System Explorer透视图中，在新向导中，创建一个新<i>Connection</i>并选择<i>Lua SSH System</i>类型的系统。
		</p>
		<p>
			<img align="middle" border="0" src="images/CreateConnexion.png">
		</p>
		<p>在下一页上，输入远程系统的网络名称，或直接输入其IP地址。</p>
		<p>
			<img align="middle" border="0" src="images/CreateConnexionEnterIP.png">
		</p>
		<p>如果需要，请在ssh-lua子系统高级属性中配置运行时路径。如果未配置路径，则将使用远程系统的环境变量。要更改属性，请选择连接的SSH Lua节点。然后，在属性视图中按下<i>显示高级属性</i>按钮。您可以通过选择适当的单元格来编辑属性值。如果让某些属性为空，则将使用远程系统Lua默认值。
		</p>
		<p>
			<img align="left" border="0" src="images/warning2.png"> <b>用户环境变量限制：</b>
		</p>
		<dl>
			<dd>
				<dl>
					<dd>
						<i>LDT</i>无法检索用户范围中指定的环境变量。例如，如果在远程用户的.profile或.bashrc文件中修改了变量LUA_PATH，则在运行时可能不会考虑这些修改。
					</dd>
				</dl>
			</dd>
		</dl>
		<p>
			<img align="middle" border="0" src="images/remoteConnection.png">
		</p>
		<p>在顶部菜单中，选择<i>Run / Debug Configuration ...。</i>
		</p>
		<p>
			<img align="middle" border="0" src="images/DebugConfiguration.png">
		</p>
		<p>然后，创建<i>远程Lua应用程序</i>启动配置。配置项目和要运行的脚本，也选择远程系统。
		</p>
		<p>
			<img align="middle" border="0" src="images/RemoteLaunchConf.png">
		</p>
		<p>还提供了以下选项卡来配置启动配置：</p>
		<ul>
			<li>
				<i>参数</i> ：您可以在此处指定脚本和远程解释器参数，像在命令行中一样键入参数。在选项卡的底部，您还可以编辑将在远程系统上复制Lua文件的位置，绝对路径是必需的。
			</li>
			<li>
				<i>环境</i> ：在此指定运行时的一些<i>环境</i>变量。这些变量将被添加到远程系统的现有环境变量中。如上所述， <i>LDT</i>无法检索用户范围中指定的环境变量值。
			</li>
			<li>
				<i>常见</i> ：一些常见的启动配置相关设置。
				<ul>
					<li>将当前启动配置保存在指定文件中。</li>
					<li>查看收藏菜单中显示的当前启动配置。</li>
					<li>更改启动配置文件的编码。</li>
					<li>在控制台中分配标准输入/输出和/或在文件中重定向标准输出。</li>
				</ul>
			</li>
		</ul>
		<p>启动调试会话，了解如何<a href="Tasks.html#Debugging_a_Lua_program">调试Lua程序</a>以继续。
		</p>
		<h2 id="Debugging_a_Lua_program">调试Lua程序</h2>
		<p>请参阅上一节“ <i><a href="Tasks.html#Configuring_debug_sessions">配置调试会话”中的</a></i>如何启动调试。
		</p>
		<h3 id="Breakpoints.2C_code_navigation">断点，代码导航</h3>
		<p>您可以在特定文件或行中设置断点，您可以通过常规双击边距来执行此操作：</p>
		<p>
			<img align="middle" border="0" src="images/Dbg-setbreakpoint.png"> 
		</p>
		<p>您可以选择指示仅在特定情况下停止执行的条件：</p>
		<p>
			<img align="middle" border="0" src="images/Dbg-openproperties.png"> 
		</p>
		<p>
			<img align="middle" border="0" src="images/Dbg-properties.png"> 
		</p>
		<ol>
			<li>全局启用或禁用断点。</li>
			<li>击中次数的条件（仅在第3次击中后停止，每次击中4次等）。</li>
			<li>条件断点：您可以放置任何表达式，每次遇到断点时都会使用局部作用域进行计算，并且只有在表达式求值为true时才会停止。</li>
		</ol>
		<p>一旦断点被击中，并且执行实际上已停止，您可以使用<b>Step Into</b> ， <b>Step Over</b>和<b>Step Return</b>命令。

			<img align="left" border="0" src="images/Idea.png"> <b>协同处理：</b>
		</p>
		<dl>
			<dd>
				<dl>
					<dd>当前指令是<tt>coroutine.yield</tt>或<tt>coroutine.resume</tt>步骤将跳过协程直到下一个恢复或产量，而step into将进入协程并尽快重新打破。}}</dd>
				</dl>
			</dd>
		</dl>
		<h3 id="Environment_inspection">环境检查</h3>
		<p>到达断点时，您可以看到任何堆栈帧（本地，高值和全局变量）中可见的任何变量。您还可以编辑值。</p>
		<p>
			<img align="middle" border="0" src="images/Dbg-variables.png"> 
		</p>
		<p>
			<img align="left" border="0" src="images/Idea.png"> <b>新值是表达式：</b>
		</p>
		<dl>
			<dd>
				<dl>
					<dd>设置新值时，它将作为表达式进行求值，因此<tt>math.sqrt</tt>将被计算为函数，如果要放置文字字符串，请使用Lua语法： <tt>“math.sqrt”</tt> 。特别是，您可以通过另一个表表达式更改整个表。这有时是强大的，有时是危险的， <b>要小心</b> 。
					</dd>
				</dl>
			</dd>
		</dl>
		<p>还可以显示一些<i>特殊</i>值，例如元表或功能环境（如果它与全局环境不同）。您也可以编辑它们。
		</p>
		<h3 id="Interactive_console_and_expressions">交互式控制台和表达</h3>
		<p>除了变量视图之外，还有另外两个有用的工具来评估一些代码片段： <i>表达式视图</i>和<i>交互式控制台</i> 。
		</p>
		<p>
			<img align="middle" title="表达式视图允许您在每个步骤重新评估复杂表达式" alt="表达式视图允许您在每个步骤重新评估复杂表达式" border="1" src="images/Dbg-expressions.png"> 
		</p>
		<p>
			<img align="middle" title="交互式控制台允许您在本地范围下键入语句" alt="交互式控制台允许您在本地范围下键入语句" border="1" src="images/Dbg-repl.png"> 
		</p>
		<p>
			<img align="left" border="0" src="images/warning2.png"> <b>永远在顶级：</b>
		</p>
		<dl>
			<dd>
				<dl>
					<dd>由于DBGp协议的限制，交互式控制台和表达式始终映射到顶部堆栈帧。</dd>
				</dl>
			</dd>
		</dl>
		<h3 id="Unsupported_features">不支持的功能</h3>
		<p>不支持<b>动态代码</b> ，这意味着将不支持使用<tt>load</tt> ， <tt>loadstring</tt>加载的任何代码。调试器将像C函数一样跨越它。
		</p>
		<h2 id="Improve_cdata_display">改善cdata显示</h2>
		<p>如果您正在使用LuaJIT的<i>cdata</i>并希望在调试期间改进它们的显示，只需在应用程序入口点的顶部添加此行（默认情况下为<i>main.lua</i> ）：</p>
		<pre class="source-lua">要求'debugger.plugins.ffi'</pre>
		<p>我们为<i>cdata</i>显示实现了一个<a href="https://wiki.eclipse.org/LDT/User_Area/Debugger/ValueDisplay" target="doc_external">自定义检查</a>器，它将使您能够浏览它们的结构和值。
		</p><hr>
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="以前" border="0" src="../../../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="User-Guide-1.4.html" title="LDT用户指南">
						<img alt="LDT用户指南" border="0" src="../../../../images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">概念</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table>
	</body>
</html><html id="3372.LTTng-UST-Analyses.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass用户指南 -  LTTng-UST分析</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">LTTng-UST分析</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="LTTng-Kernel-Analysis.html" title="LTTng内核分析">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Trace-synchronization.html" title="跟踪同步">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">LTTng内核分析</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">跟踪同步</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="LTTng-UST_Analyses">LTTng-UST分析</h1>
		<p>Userspace跟踪在应用程序级别上进行。使用内核跟踪，您可以知道在域已知和隐藏的情况下您将拥有哪些事件。用户空间跟踪可以包含几乎任何内容。如果启用了某些事件，则会提供一些分析。</p>
		<h2 id="Call_Stack_View">调用堆栈视图</h2>
		<p>如果应用程序和跟踪提供此信息，则“调用堆栈”视图允许用户随时间可视化每个线程的调用堆栈。</p>
		<p>要打开此视图，请转到<b>窗口</b> - &gt; <b>显示视图</b> - &gt; <b>其他...，</b>然后在列表中选择<b>跟踪/调用堆栈</b> 。该视图显示当前所选跟踪的调用堆栈信息。相反，您可以选择跟踪并在<b>Project Explorer中</b>展开它，然后展开<b>LTTng-UST CallStack Analysis</b> （必须加载跟踪）并打开<b>Call Stack</b> 。
		</p>
		<p>视图左侧的表显示了线程和调用堆栈。在所选时间显示调用堆栈的函数名称，深度，进入和退出时间以及持续时间。</p>
		<p>双击表格中的功能条目会将时间图表缩放到所选功能的执行范围。</p>
		<p>视图右侧的时间图以图形方式显示调用堆栈状态。如果大小允许，函数名称在每个调用堆栈事件上都可见。每个调用堆栈事件的颜色根据函数名称随机分配，以便轻松识别对同一函数的重复调用。</p>
		<p>单击时间图将设置当前时间，从而使用当前调用堆栈信息更新表。</p>
		<p>按住Shift键并单击时间图将选择一个时间范围。当选择是时间范围时，开始时间用于更新堆栈信息。</p>
		<p>双击调用堆栈事件会将时间图缩放到所选函数的执行范围。</p>
		<p>单击“ <b>选择下一个状态更改”</b>或“ <b>选择上一个状态更改”</b>或使用向左和向右箭头将导航到下一个或上一个调用堆栈事件，并选择当前位于调用堆栈顶部的函数。请注意，同时按下<b>Shift</b>键将更新当前选择的选择结束时间。
		</p>
		<p>单击<b>配置地址映射到函数名称的方式</b> （ <img border="0" src="images/binaries_obj.gif"> ）图标将打开符号提供程序对话框。根据给定跟踪的可用符号提供程序，您可以指定：1）包含从函数地址到函数名称的映射的文本或二进制文件，或2）跟踪目标的二进制文件的根位置。如果当前跟踪类型的调用堆栈提供程序仅提供函数地址，则需要映射文件来获取视图中的函数名称。有关LTTng-UST跟踪的示例，请参阅以下部分。
		</p>
		<h3 id="Using_the_Callstack_View_with_LTTng-UST_traces">使用带有LTTng-UST跟踪的Callstack视图</h3>
		<p>LTTng-UST集成插件支持显示使用<i>liblttng-ust-cyg-profile.so</i>库跟踪的应用程序的调用堆栈（有关其他信息，请参阅<i>liblttng-ust-cyg-profile</i>手册页）。为此，您需要：</p>
		<ul>
			<li>使用“ <i>-g -finstrument-functions</i> ” <i>重新</i>编译应用程序。
			</li>
			<li>使用<i>vpid</i> ， <i>vtid</i>和<i>procname</i>上下文设置跟踪会话。请参阅<a href="LTTng-Tracer-Control.html#Enabling_UST_Events_On_Session_Level">在会话级别启用UST事件</a>并将<a href="LTTng-Tracer-Control.html#Adding_Contexts_to_Channels_and_Events_of_a_Domain">上下文添加到域的通道和事件</a>部分。或者如果使用命令行：<ul>
					<li><pre>lttng enable-event -u -a</pre></li>
					<li><pre>lttng add-context -u -t vpid -t vtid -t procname</pre></li>
				</ul>
			</li>
			<li>运行程序时预加载<i>liblttng-ust-cyg-profile</i>库：<ul>
					<li><pre>LD_PRELOAD = / usr / lib / liblttng-ust-cyg-profile.so ./myprogram</pre></li>
				</ul>
			</li>
		</ul>
		<p>加载生成的跟踪后，应使用相关信息填充Callstack视图。</p>
		<p>请注意，对于非平凡的应用程序， <i>liblttng-ust-cyg-profile会</i>生成<b>很多</b>事件！您可能需要增加通道的子缓冲区大小以避免丢失事件。请参阅<a href="http://lttng.org/docs/#doc-fine-tuning-channels">LTTng文档</a> 。
		</p>
		<p>对于使用LTTng-UST 2.8或更高版本的跟踪，Callstack View应自动显示函数名称，因为它将使用调试信息statedump事件（使用<i>enable-event -u -a</i>时<i>启用</i> ）。
		</p>
		<p>对于使用以前版本的UST获取的跟踪，您需要设置二进制文件的路径或手动映射：</p>
		<h3 id="Importing_a_binary_or_function_name_mapping_file_.28for_LTTng-UST_.3C2.8_traces.29">导入二进制或函数名称映射文件（对于LTTng-UST &lt;2.8跟踪）</h3>
		<p>
			<i>对于LTTng-UST 2.8+，如果它不自动解析符号，请参阅<a href="#Binary_file_location_configuration">源查找的二进制文件位置配置</a> 。
			</i>
		</p>
		<p>如果您按照上一节中的步骤操作，则应该有一个填充了函数入口和出口的Callstack视图。但是，视图将显示函数地址而不是间隔中的名称，这些名称本身并不是很有用。要获取实际的函数名称，您需要：</p>
		<ul>
			<li>单击<b>配置地址映射到函数名称的方式</b> （ <img border="0" src="images/binaries_obj.gif"> ）在Callstack视图中的按钮。
			</li>
		</ul>
		<p>再一次，多个符号提供者可用于唯一的跟踪。可以通过自己的选项卡配置每个符号提供程序。因此，可以使用多个源将函数名称映射到地址。下面是基本符号提供程序首选项页面的图像，它允许我们导入二进制或函数名称映射文件。</p>
		<p>
			<img border="0" src="images/BasicSymbolProviderPreferencePage.png">
		</p>
		<p>只需单击<b>添加...</b>按钮即可添加一个或多个映射文件。映射文件可以是以下两个选项之一：</p>
		<ul>
			<li>
				<img border="0" src="images/binary_mapping_file.gif"> ：用于获取跟踪的二进制文件。
			</li>
		</ul>
		<ul>
			<li>
				<img border="0" src="images/text_mapping_file.gif"> ：使用<i>nm myprogram&gt; mapping.txt</i>从二进制文件生成的文件。选择刚刚创建的<i>mapping.txt</i>文件。如果您正在处理C ++可执行文件，则可能需要使用<i>nm --demangle</i>来获取可读的函数名称。
			</li>
		</ul>
		<p>现在应该更新视图以显示函数名称。确保用于获取跟踪的二进制文件也是用于此步骤的二进制文件（否则，地址不太可能相同）。</p>
		<p>最后，基本符号提供程序引入了映射文件之间的优先级概念。列表顶部文件中的已解析符号的优先级高于下面列出的文件。可以使用<b>向上</b>和<b>向下</b>按钮移动文件。
		</p>
		<h3 id="Navigation_5">导航</h3>
		<p>请参阅控制流视图<b><a href="LTTng-Kernel-Analysis.html#Using_the_mouse">使用鼠标</a></b> ， <b><a href="LTTng-Kernel-Analysis.html#Using_the_keyboard">使用键盘</a></b>和<b><a href="LTTng-Kernel-Analysis.html#Zoom_region">缩放区域</a></b> 。
		</p>
		<h3 id="Marker_Axis_3">标记轴</h3>
		<p>请参阅控制流视图的<b><a href="LTTng-Kernel-Analysis.html#Marker_Axis">标记轴</a></b> 。
		</p>
		<h2 id="Flame_Graph_View">火焰图视图</h2>
		<p>这是来自<b>Call Stack View</b>的函数调用的聚合视图。这显示了鸟瞰的跟踪应用程序中的主要时间接收器。<b>Flame Graph</b>中的每个条目表示在具有相同调用者的调用堆栈的特定深度中对函数的所有调用的聚合。因此， <b>Flame Graph</b>中的函数由深度和调用者聚合。这使用户可以轻松找到执行最多的代码路径。
		</p>
		<ul>
			<li>在<b>Flame Graph中</b> ，每个条目（框）代表堆栈中的一个函数。
			</li>
			<li>如果在视图中采用单个垂直线，则表示父级调用子级的完整调用堆栈。</li>
			<li><i>x轴</i>表示总持续时间（执行时间）而不是绝对时间，因此它不与其他视图对齐。
			</li>
			<li>条目的宽度是在该函数中花费的总时间，包括调用子项所花费的时间。</li>
			<li>如果程序被抢占并且在其跟踪时间内没有运行，则总时间可以超过最长持续时间。</li>
			<li>跟踪的每个线程都会生成自己的火焰图。</li>
		</ul>
		<p>如果大小允许，函数名称在每个Flame图形事件上都可见。<b>Flame Graph</b>中的每个框与表示<b>调用堆栈中</b>相同功能的框具有相同的颜色。
		</p>
		<p>要打开此视图，请选择一个跟踪，在<b>Project Explorer中</b>展开它，然后展开<b>Call Graph Analysis</b> （必须加载跟踪）并打开<b>Flame Graph</b> 。也可以进入<b>Window</b> - &gt; <b>Show View</b> - &gt; <b>Tracing，</b>然后在列表中选择<b>Flame Graph</b> 。
		</p>
		<p>
			<img title="火焰图视图" alt="火焰图视图" border="0" src="images/Flame_Graph.png">
		</p>
		<p>要使用<b>Flame图表</b> ，可以导航它并找到哪个函数消耗最多的自我时间。这可以看作是一个大的高原。然后可以检查该条目。此时，CPU使用率最差的犯罪者将被突出显示，但是，它不是一次调查，而是所有呼叫的聚合。在该条目上单击鼠标右键将打开一个上下文相关菜单。选择“ <b>转到最小值”</b>或“ <b>转到最大值”</b>将使用户获得跟踪中的最小或最大记录时间。比较和对比这两者很有趣。
		</p>
		<p>将鼠标悬停在某个函数上将显示一个工具提示，其中包含基于每个函数的统计信息。可以看到该函数的总时间和自身时间（ <i>最差情况</i> ， <i>最佳情况</i> ， <i>平均值</i> ， <i>总时间</i> ， <i>标准差</i> ， <i>呼叫数</i> ）。
		</p>
		<p>如果希望在“经典”火焰图视图和调用堆栈视图之间的中等细节级别进行探索，则可以通过选择较粗的菜单并单击<b>内容演示</b>然后单击<b>每线程</b>来获得每线程火焰图视图。要返回默认模式，请返回该菜单并单击<b>Aggregate Threads</b> 。
		</p>
		<h3 id="How_to_use_a_Flame_Graph">如何使用Flame Graph</h3>
		<p>观察每个函数花费的时间可以显示大部分时间花在哪里以及可以优化的位置。上图中的示例：可以看到<i>mp_sort</i>是递归排序函数，它占用程序执行时间的大约40％。这意味着完全并行化可以使2个线程获得20％的增益，3个获得33％的增益，依此类推。查看函数<b>print_current_files</b> ，它占用了大约30％的时间，并且它有一个具有较大自我时间（超过10％）的子<i>print_many_per_line</i> 。这可能是另一个可以针对优化的领域。提前了解这一点可以帮助开发人员了解他们的目标。
		</p>
		<p>在使用<b>Flame Graph时</b> ，建议在实验中使用内核跟踪和用户空间跟踪，因为它将显示导致最大延迟的原因。当将<b>Flame Graph</b>与调用堆栈和内核跟踪一起使用时，一个示例工作流程就是在一个看起来耗时太长的函数所花费的时间内找到最差的犯罪者。然后，使用上下文菜单<b>Go to maximum</b> ，可以导航到最大持续时间，并查看操作系统是否例如抢占该功能的时间过长，或者问题是否在正在执行的代码中。
		</p>
		<h2 id="Function_Duration_Statistics">功能持续时间统计</h2>
		<p>这将显示给定函数的“挂起时间”持续时间的描述性统计信息。它概述了调用函数的频率，花费的总时间，平均持续时间以及最大值，最小值和标准差。</p>
		<p>如果选择了时间范围，它也将显示本地统计信息。</p>
		<p>如果<i>Flame Graph</i>可用，则可以使用此分析。
		</p>
		<h3 id="Using_the_mouse_3">用鼠标</h3>
		<ul>
			<li>
				<b>双击持续时间标尺</b>会将图形缩放到选定的持续时间范围。
			</li>
			<li>
				<b>按住Shift键并单击或拖动</b> ：扩展或缩小选择范围</li>
			<li>
				<b>鼠标滚轮向上/向下</b> ：向上或向下滚动</li>
			<li>
				<b>向上/向下移动鼠标滚轮</b> ：向左或向右滚动</li>
			<li>
				<b>Ctrl-鼠标滚轮向上/向下</b> ：水平放大或缩小</li>
			<li>
				<b>Shift-Ctrl-鼠标滚轮向上/向下</b> ：垂直放大或缩小</li>
		</ul>
		<p>当鼠标光标在条目上时（左窗格）：</p>
		<ul>
			<li>
				<b>-</b> ：折叠所选线程的<b>Flame Graph</b></li>
			<li>
				<b>+</b> ：展开所选线程的<b>Flame Graph</b></li>
		</ul>
		<h3 id="Using_the_keyboard_3">使用键盘</h3>
		<p>可以使用以下键盘快捷键：</p>
		<ul>
			<li>
				<b>向下箭头</b> ：选择下一个堆栈深度</li>
			<li>
				<b>向上箭头</b> ：选择先前的堆栈深度</li>
			<li>
				<b>主页</b> ：选择第一个线程的<b>Flame Graph</b>
			</li>
			<li>
				<b>结束</b> ：选择最后一个线程的<b>Flame Graph</b>的最深深度</li>
			<li>
				<b>输入</b> ：切换树中当前线程的扩展状态</li>
			<li>
				<b>Ctrl + +</b> ：垂直放大</li>
			<li>
				<b>Ctrl +  -</b> ：垂直缩小</li>
			<li>
				<b>Ctrl + 0</b> ：重置垂直缩放</li>
		</ul>
		<h3 id="Toolbar_6">工具栏</h3>
		<table>
			<tr>
				<td>
					<img border="0" src="images/sort_alpha.gif">
				</td>
				<td>按线程名称排序</td>
				<td>按线程名称对线程排序。再次单击该图标将按相反的顺序按名称对线程进行排序，并将图标更改为<img border="0" src="images/sort_alpha_rev.gif">
				</td>
			</tr>
			<tr>
				<td>
					<img border="0" src="images/sort_num.gif">
				</td>
				<td>按线程ID排序</td>
				<td>按线程ID对线程排序。再次单击该图标将按相反的顺序按ID排序线程，并将图标更改为<img border="0" src="images/sort_num_rev.gif"> 。
				</td>
			</tr>
		</table>
		<h3 id="Importing_a_binary_or_function_name_mapping_file_.28for_LTTng-UST_.3C2.8_traces.29_2">导入二进制或函数名称映射文件（对于LTTng-UST &lt;2.8跟踪）</h3>
		<p>请参阅调用堆栈视图的<b><a href="#Call_Stack_View">导入二进制或函数名称映射文件（对于LTTng-UST &lt;2.8跟踪）</a></b> 。
		</p>
		<h2 id="Function_Duration_Density">功能持续时间密度</h2>
		<p>“ <b>功能持续时间密度”</b>视图显示按当前活动时间窗口范围的持续时间显示的功能的持续时间。这对于查找全局异常值很有用。
		</p>
		<p>
			<img title="功能持续时间密度视图" alt="功能持续时间密度视图" border="0" src="images/FunctionDensityView.png">
		</p>
		<p>使用鼠标右键水平拖动它将更新表格和图形，以仅显示所选持续时间的密度。选择范围之外的持续时间将被过滤掉。使用工具栏按钮<img border="0" src="images/zoomout_nav.gif">变焦范围将被重置。
		</p>
		<h2 id="Memory_Usage">内存使用情况</h2>
		<p>如果应用程序和跟踪提供此信息，则“内存使用情况”视图允许用户可视化每个线程的活动内存使用情况。</p>
		<p>该视图显示当前所选跟踪的内存消耗。</p>
		<p>时间图以图形方式绘制堆内存使用情况。每个进程有一行，未分配的内存使用情况映射到“其他”。可以在左侧的树中检查和取消选中进程。</p>
		<p>过滤按钮： <img border="0" src="images/filter_items.gif">可用于仅显示树查看器中的活动线程。默认情况下，仅显示在可见时间范围内具有内存使用量变化的线程，单击该按钮将显示所有线程。
		</p>
		<p>在此实现中，用户需要通过运行<i>LD_PRELOAD = liblttng-ust-libc-wrapper.so</i> <b>&lt;exename&gt;</b>来挂钩<i>liblttng-ust-libc-wrapper</i> 。这将为内存分配添加跟踪点并释放到堆，而不是共享内存或堆栈使用。如果启用了上下文<b>vtid</b>和<b>procname</b> ，则视图会将堆使用情况与进程相关联。如前所述，要启用上下文，请参阅<a href="LTTng-Tracer-Control.html#Adding_Contexts_to_Channels_and_Events_of_a_Domain">向域的通道和事件添加上下文</a>部分。或者如果使用命令行：</p>
		<ul>
			<li><pre>lttng add-context -u -t vtid -t procname</pre></li>
		</ul>
		<p>如果线程信息可用，则视图将如下所示：</p>
		<p>
			<img border="0" src="images/memoryUsage/memory-usage-multithread.png">
		</p>
		<p>如果线程信息不可用，它将如下所示：</p>
		<p>
			<img border="0" src="images/memoryUsage/memory-usage-no-thread-info.png">
		</p>
		<p>时间轴与支持自动时间轴对齐的其他视图对齐（请参阅<a href="Trace-Compass-Main-Features.html#Automatic_Time_Axis_Alignment">自动时间轴对齐</a> ）。
		</p>
		<p>双击时间轴或主页按钮可以完全缩小时间范围。</p>
		<p>请注意，此视图不会显示共享内存或堆栈内存使用情况。</p>
		<h3 id="Navigation_6">导航</h3>
		<p>有关导航，请参阅CPU使用情况视图<b><a href="LTTng-Kernel-Analysis.html#Using_the_mouse_2">使用鼠标</a></b> ， <b><a href="LTTng-Kernel-Analysis.html#Using_the_keyboard_2">使用键盘</a></b>和<b><a href="LTTng-Kernel-Analysis.html#Zoom_region">缩放区域</a></b> 。
		</p>
		<h3 id="Toolbar_7">工具栏</h3>
		<p>视图<b>工具栏</b>位于视图的右上角，具有执行常用操作的快捷按钮。
		</p>
		<p>有关“CPU使用率”视图的<b><a href="LTTng-Kernel-Analysis.html#Toolbar_3">工具栏的</a></b>详细信息。
		</p>
		<h3 id="View_Menu_4">查看菜单</h3>
		<p>内存使用情况视图<b>视图菜单</b>位于<b>视图</b>的右上角，具有执行常用操作的快捷按钮：</p>
		<table>
			<tr>
				<td>新内存使用情况视图</td>
				<td>生成一个新的内存使用情况视图。新视图可以固定到当前跟踪的新实例，固定到任何打开的跟踪或取消固定。</td>
			</tr>
			<tr>
				<td>对齐视图</td>
				<td>禁用并启用基于时间的视图的自动时间轴对齐。在此视图中禁用对齐将在所有视图中禁用此功能，因为它是工作区首选项。</td>
			</tr>
		</table>
		<p>
			<img border="0" src="images/LTTng_CpuUsageViewToolTip.png">
		</p>
		<p>请注意，此视图不会显示共享内存或堆栈内存使用情况。</p>
		<h2 id="Source_Lookup_.28for_LTTng-UST_2.8.2B.29">源查找（适用于LTTng-UST 2.8+）</h2>
		<p>从LTTng 2.8开始，跟踪器现在可以提供足够的信息来将跟踪事件与它们在原始源代码中的位置相关联。</p>
		<p>要使用此功能，首先要确保使用调试信息（-g）编译二进制文件，以便可以将指令指针映射到源代码位置。此查找是使用<i>addr2line</i>命令行实用程序进行的，该实用程序需要安装在运行Trace Compass的系统的<b>$ PATH</b>上。
			<i>addr2line</i>适用于大多数Linux发行版，Mac OS X，使用Cygwin的Windows等。
		</p>
		<p>跟踪中需要存在以下跟踪事件：</p>
		<ul>
			<li>lttng_ust_statedump：启动</li>
			<li>lttng_ust_statedump：结束</li>
			<li>lttng_ust_statedump：bin_info</li>
			<li>lttng_ust_statedump：build_id</li>
		</ul>
		<p>以及以下背景：</p>
		<ul>
			<li>VPID</li>
			<li>IP</li>
		</ul>
		<p>为了便于使用，您可以在设置会话时简单地启用所有UST事件：</p>
		<pre>lttng enable-event -u -a lttng add-context -u -t vpid -t ip</pre>
		<p>请注意，您还可以使用“ <a href="LTTng-Tracer-Control.html#Control_View">控制视图”</a>创建和配置会话。
		</p>
		<p>如果要跟踪应用程序加载的共享库中的源位置，还需要启用“lttng_ust_dl：*”事件，并在运行程序时预加载提供它们的UST库：</p>
		<pre>LD_PRELOAD = / path / to / liblttng-ust-dl.so ./myprogram</pre>
		<p>如果存在所有必需信息，则应相应地填充事件表的<i>源位置</i>列，并且应该可以使用<i>开源代码</i>操作。有关更多详细信息，请参阅<a href="Trace-Compass-Main-Features.html#Event_Source_Lookup">事件源查找</a>部分。
		</p>
		<p>即使原始二进制文件不可用， <i>二进制位置</i>信息也应该存在，因为它只使用跟踪中找到的信息。A <b>+</b>表示相对地址（即对象本身内的偏移），而<b>@</b>表示非位置无关对象的绝对地址。
		</p>
		<p>
			<img border="0" src="images/sourceLookup/trace-with-debug-info.png">
		</p>
		<p>
			<i>包含调试信息和相应的源查找信息的跟踪示例，显示源自共享库的跟踪点</i>
		</p>
		<h3 id="Binary_file_location_configuration">二进制文件位置配置</h3>
		<p>要解析函数名称和源代码位置的地址，分析将使用系统中存在的二进制文件（可执行文件或共享库）。默认情况下，它将查找跟踪中找到的文件路径，这意味着如果跟踪是在运行Trace Compass的同一台计算机上进行的，则它应该是开箱即用的。</p>
		<p>可以配置将用作所有文件路径解析的前缀的<i>根目录</i> 。打开配置对话框的按钮称为<b>配置地址映射到函数名称的方式</b> ，当前位于<a href="#Call_Stack_View">调用堆栈视图中</a> 。请注意，调用堆栈视图还将使用此配置来解析其功能名称。
		</p>
		<p>
			<img border="0" src="images/sourceLookup/symbol-mapping-config-ust28.png">
		</p>
		<p>
			<i>LTTng-UST 2.8+跟踪的符号配置对话框</i>
		</p>
		<p>如果在远程目标上进行跟踪，并且该目标的图像在本地可用，则此功能非常有用。</p>
		<p>如果正在跟踪目标上的二进制文件，则跟踪中的路径将引用目标上的路径。例如，如果它们是：</p>
		<ul>
			<li>在/ usr / bin中/程序</li>
			<li>/usr/lib/libsomething.so</li>
			<li>/usr/local/lib/libcustom.so</li>
		</ul>
		<p>并在<i>/ home / user / project / image</i>系统上本地复制该目标的<i>图像</i> ，这意味着上面的二进制文件最终在：</p>
		<ul>
			<li>/ home / user中/项目/图像的/ usr / bin中/程序</li>
			<li>/home/user/project/image/usr/lib/libsomething.so</li>
			<li>/home/user/project/image/usr/local/lib/libcustom.so</li>
		</ul>
		<p>然后在上面的配置对话框中选择<i>/ home / user / project / image</i>目录将允许Trace Compass正确读取调试符号。
		</p>
		<p>请注意，此路径前缀将应用于二进制文件和源文件位置，这可能是也可能不是。</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="LTTng-Kernel-Analysis.html" title="LTTng内核分析">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="User-Guide.html" title="Trace Compass用户指南">
						<img alt="Trace Compass用户指南" border="0" src="images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Trace-synchronization.html" title="跟踪同步">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">LTTng内核分析</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">跟踪同步</td>
			</tr>
		</table>
	</body>
</html><html id="3853.308_emf_integration.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>与EMF集成</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="emf-integration">与EMF集成</h1>

<p>Xtext在内部严重依赖EMF，但它也可以用作其他基于EMF的工具的序列化后端。在本节中，我们将在Xtext的上下文中介绍<a href="http://www.eclipse.org/modeling/emf/">Eclipse Modeling Framework（EMF）</a>的基本概念。如果您想了解有关EMF的更多信息，我们建议您阅读<a href="http://www.eclipse.org/modeling/emf/">EMF书籍</a> 。</p>

<h2 id="model-metamodel">模型，Ecore模型和Ecore</h2>

<p>Xtext使用EMF模型作为任何已解析文本文件的内存中表示。此内存中对象图称为<em>抽象语法树</em> （AST）。根据社区，这个概念也称为<em>文档对象图（DOM）</em> ， <em>语义模型</em>或简单<em>模型</em> 。我们交替使用<em>模型</em>和<em>AST</em> 。鉴于本<a href="102_domainmodelwalkthrough.html">教程中</a>的示例模型，AST看起来与此类似</p>

<p><img src="images/ast.png" alt="样品AST"></p>

<p><em>AST</em>应包含文本模型的本质。它抽象了语法信息。它由后续处理步骤使用，例如验证，编译或解释。在EMF中，模型由连接的<em>EObjects</em>实例<em>组成</em> ， <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a>是<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EClass.java">EClass</a>的实例。一组<em>EClasses，</em>如果包含在所谓的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">EPackage中</a> ，它们都是<em>Ecore的</em>概念。在Xtext中，元模型可以从语法中推断出来，也可以由用户预定义（有关详细信息，请参阅<a href="301_grammarlanguage.html#package-declarations">包声明</a>部分）。下图显示了我们示例的元模型：</p>

<p><img src="images/metamodel.png" alt="示例元模型"></p>

<p>定义元模型的语言称为<em>Ecore</em> 。换句话说，元模型是您语言的Ecore模型。Ecore是EMF的重要组成部分。您的模型实例化元模型，您的元模型实例化Ecore。为了结束这种递归，Ecore本身就是定义的（它本身的一个实例）。</p>

<p>元模型将语义节点的类型定义为Ecore <em>EClasses</em> 。EClasses在元模型图中显示为框，因此在我们的示例中， <em>Model</em> ， <em>Type</em> ， <em>SimpleType</em> ， <em>Entity</em>和<em>Property</em>是EClasses。EClass可以从其他EClasses继承。Ecore允许多重继承，但当然禁止循环。</p>

<p>EClasses可以为其简单属性提供<em>EAttributes</em> 。这些显示在EClasses节点内。该示例包含两个EAttributes <em>名称</em>和一个EAttribute <em>multi</em> 。EAttribute的值域由其<em>EDataType</em>定义。Ecore附带了一些预定义的<em>EDataTypes</em> ，它们实际上是指Java原始类型和其他不可变类，如<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a> 。为了区分Java类型， <em>EDataTypes</em>以<em>E</em>为前缀。在我们的例子中，那是<em>EString</em>和<em>EBoolean</em> 。</p>

<p>与EAttributes相比， <em>EReferences</em>指向其他EClasses。<em>包含</em>标志指示EReference是<em>包含引用</em>还是<em>交叉引用</em> 。在图中，引用是边和包含引用用菱形标记。在模型级别，每个元素最多可以有一个容器，即带有容器引用的另一个元素。这可以推断模型的树结构，如示例模型图中所示。另一方面， <em>交叉引用</em>是指可以包含在其他任何地方的元素。在示例中， <em>元素</em>和<em>属性</em>是包含引用，而<em>type</em>和<em>extends</em>是交叉引用。出于可读性的原因，我们跳过了示例模型图中的交叉引用。请注意，与其他解析器生成器相比，Xtext创建了带有链接交叉引用的AST。</p>

<p>除了UML中的关联之外，Ecore中的EReferences总是由一个EClass拥有，并且只能在从所有者到该类型的方向上进行导航。必须将双向关联建模为两个引用，彼此相互<em>对立</em>并由关联的任一端拥有。</p>

<p>EAttributes和EReferences的超类是<em>EStructuralFeature</em> ，允许通过设置<em>lowerBound</em>和<em>upperBound</em>来定义名称和基数。将后者设置为-1意味着“无界”。</p>

<p>常见的超类型EDataType和EClass是<em>EClassifier</em> 。<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">EPackage</a>充当<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">EClassifiers</a>的命名空间和容器。</p>

<p>我们在下图中总结了Ecore最相关的概念：</p>

<p><img src="images/ecore.png" alt="Ecore概念"></p>

<h2 id="emf-codegen">EMF代码生成</h2>

<p>EMF还附带了一个代码生成器，可以从Ecore模型生成Java类。代码生成器输入是所谓的<em>EMF生成器模型</em> 。它装饰（引用）Ecore模型，并为Ecore→Java转换添加其他信息。Xtext将自动为所有生成的元模型生成具有合理默认值的生成器模型，并在其上运行EMF代码生成器。</p>

<p>生成的类基于EMF运行时库，它提供了许多基础结构和工具来处理模型，例如持久性，反射，参照完整性，延迟加载等。</p>

<p>除此之外，代码生成器将生成</p>

<ul>
  <li>Ecore模型中每个EClassifier的Java接口和Java类。默认情况下，所有类都将实现接口<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a> ，链接许多运行时功能。</li>
  <li>每个EStructuralFeature（成员变量，访问器方法）的Java bean属性。</li>
  <li>包接口和类，为Ecore模型的所有元素保存单例对象，允许反射。EPackages也注册到<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">注册表</a>以便在运行时使用。</li>
  <li>用于创建实例的工厂接口和类。</li>
  <li>实现访问者模式的抽象switch类，以避免代码中的if-instanceof-cascades。</li>
</ul>

<h2 id="xtext-resource">XtextResource实现</h2>

<p>Xtext提供了EMF资源的实现，即<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a> 。这不仅封装了将文本转换为EMF模型的解析器，还封装了反向工作的<a href="303_runtime_concepts.html#serialization">序列化器</a> 。这样，Xtext模型看起来就像外部的任何其他基于Ecore的模型一样，使其适合其他基于EMF的工具使用。因此，在理想情况下，您可以通过替换其他建模工具使用的资源实现，将模型的序列化格式切换到自定义DSL。</p>

<p><img src="images/emf-integration.png" alt=""></p>

<p>生成器片段<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/resourceFactory/ResourceFactoryFragment2.xtend">ResourceFactoryFragment2</a>将<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a>的工厂注册到EMF的资源工厂注册表，这样所有使用默认机制来解析资源实现的工具都将自动获得该资源实现。</p>

<p>使用自定义文本语法作为主存储格式与默认XMI序列化相比具有许多优点，例如</p>

<ul>
  <li>您可以使用众所周知且易于使用的工具和技术进行操作，例如文本编辑器，正则表达式或流编辑器。</li>
  <li>您可以使用与用于源代码的版本控制相同的工具。比较和合并是在开发人员熟悉的语法中执行的。</li>
  <li>打破模型是不可能的，因为它不能再次在编辑器中重新打开。</li>
  <li>可以使用相同的工具修复模型，即使它们与新版本的Ecore模型不兼容。</li>
</ul>

<p>Xtext目标易于使用，自然感觉语言。它侧重于语言的词汇方面，而不是语义方面。因此，引用的Ecore模型可以包含比Xtext语法实际涵盖的更多的概念。因此，并非所有可能在EMF模型中表达的内容都可以序列化为关于语法的文本表示。因此，如果您想使用Xtext序列化您的模型，如上所述，最好记住以下几点：</p>

<ul>
  <li>首选可选规则调用（基数<em>？</em> 或者<em>*</em> ）强制性的（基数<em>+</em>或默认值），这样缺少的引用不会妨碍序列化。</li>
  <li>您不应在同一模型实例上使用Xtext-Editor作为自同步其他编辑器，例如规范GMF编辑器（有关详细信息，请参阅<a href="308_emf_integration.html#gmf-integration-stage1">EMF集成章节</a> ）。Xtext解析器替换AST的重新解析的子树而不是修改它，因此元素将变得陈旧。当Xtext编辑器不断地根据更改重新解析模型时，这种情况会经常发生。更松散地同步编辑器更安全，例如在文件更改时。</li>
  <li>实现<a href="#fragment-provider">IFragmentProvider</a>以使XtextResource为其包含的元素返回稳定的片段，例如，基于复合名称而不是外观顺序。</li>
  <li>实现<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java">IQualifiedNameProvider</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a> （操作<a href="303_runtime_concepts.html#scoping">方法</a> ），使交叉引用中所有可链接元素的名称唯一。</li>
  <li>提供<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IFormatter.java">IFormatter</a> （操作<a href="303_runtime_concepts.html#formatting">方法</a> ）以提高生成的文本模型的可读性。</li>
  <li>注册<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/IReferableElementsUnloader.java">IReferableElementsUnloader</a>以将已删除/替换的模型元素转换为EMF代理。设计应用程序的其余部分，使其永远不会保留对<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject的</a>引用或处理代理。这将极大地提高应用程序的稳定性。</li>
  <li>Xtext将注册EMF <a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java">Factory</a> ，因此当您使用EMF的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/ResourceSet.java">ResourceSet</a> API加载时，生成Xtext插件时输入的文件扩展名的资源将自动加载到<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource中</a> 。</li>
</ul>

<h2 id="fragment-provider">从EMF引用</h2>

<p>在某些情况下，您可能希望能够从另一个不受Xtext管理的EMF工件引用Xtext模型的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a> 。在这些情况下，使用URI，其由标识资源的部分和指向对象的第二部分组成。资源中包含的每个<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a>都可以通过所谓的<em>片段</em>进行标识。</p>

<p>片段是EMF URI的一部分，每个资源需要是唯一的。</p>

<p>EMF附带的通用资源提供了类似通用路径的片段计算。默认情况下，这些片段路径是唯一的，不必序列化。另一方面，通过重新排序资源中的元素可以很容易地破坏它们。</p>

<p>使用XMI或其他类似二进制的序列化，通常也可以使用UUID。UUID通常是二进制和技术的，因此您不希望以人类可读的表示形式处理它们。</p>

<p>然而，使用文本具体语法，我们希望能够从人类可读信息中计算片段。我们不想强迫人们使用UUID（即合成标识符）或脆弱的相对通用路径来引用<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a> 。</p>

<p>因此，可以为每种语言贡献一个<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java">IFragmentProvider</a> 。它有两个方法： <code>getFragment(EObject, Fallback)</code>计算<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EObject.java">EObject</a>的片段， <code>getEObject(Resource, String, Fallback)</code>朝相反的方向运行。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java">Fallback</a>接口允许委托默认策略 - 通常使用上述的片段路径。</p>

<p>以下代码段显示了如何将限定名称用作片段：</p>

<pre><code class="language-java">public QualifiedNameFragmentProvider实现IFragmentProvider {@Inject private IQualifiedNameProvider qualifiedNameProvider; public String getFragment（EObject obj，Fallback fallback）{String qName = qualifiedNameProvider.getQualifiedName（obj）;返回qName！= null？qName：fallback.getFragment（obj）; public EObject getEObject（资源资源，字符串片段，后备回退）{if（fragment！）= null）{Iterator &lt;EObject&gt; i = EcoreUtil.getAllContents（resource，false）; while（i.hasNext（））{EObject eObject = i.next（）;字符串candidateFragment =（eObject.eIsProxy（））？（（InternalEObject）eObject）.eProxyURI（）。fragment（）：getFragment（eObject，fallback）; if（fragment.equals（candidateFragment））返回eObject; return fallback.getEObject（fragment）; }}</code></pre>

<p>出于性能原因，通常基于片段信息导航资源而不是完全遍历它是一个好主意。如果您知道您的片段是由限定名称计算的，并且您的模型包含类似<em>NamedElements的内容</em> ，则应将片段拆分为这些部分并查询根元素，最佳匹配的子元素等等。</p>

<p>此外，最好有一种冲突解决策略，以便能够区分实际上不同的同名元素，例如属性可能具有与实体完全相同的限定名称。</p>

<h2 id="gmf-integration">与GMF编辑器集成</h2>

<p>我们不再维护GMF示例代码并将其从我们的安装中删除。您仍然可以从<a href="https://github.com/eclipse/xtext/tree/v2.10.0/examples/org.eclipse.xtext.xtext.ui.examples/contents">源代码存储库</a>访问<a href="https://github.com/eclipse/xtext/tree/v2.10.0/examples/org.eclipse.xtext.xtext.ui.examples/contents">源代码的最新版本</a> 。</p>

<p><a href="http://www.eclipse.org/modeling/gmp/?project=gmf">图形建模框架（GMF）</a>允许为Ecore模型创建图形图编辑器。为了说明如何在<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a>之上构建GMF，我们提供了一个示例。您必须在工作台中安装Helios 2.3版本的GMF表示法，运行时和工具及其依赖项才能运行该示例。使用其他版本的GMF，可能会重新生成图表代码。</p>

<p>该示例包含许多插件</p>

<table>
  <thead>
    <tr>
      <th style="text-align:left">插入</th>
      <th style="text-align:left">骨架</th>
      <th style="text-align:left">目的</th>
      <th style="text-align:left">内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">oexexample.gmf</td>
      <td style="text-align:left">的Xtext</td>
      <td style="text-align:left">Xtext运行时插件</td>
      <td style="text-align:left">语法，派生元模型和语言基础设施</td>
    </tr>
    <tr>
      <td style="text-align:left">oexegui</td>
      <td style="text-align:left">的Xtext</td>
      <td style="text-align:left">Xtext UI插件</td>
      <td style="text-align:left">Xtext编辑器和服务</td>
    </tr>
    <tr>
      <td style="text-align:left">oexegedit</td>
      <td style="text-align:left">EMF</td>
      <td style="text-align:left">EMF.edit插件</td>
      <td style="text-align:left">从元模型生成的UI服务</td>
    </tr>
    <tr>
      <td style="text-align:left">oexegmodels</td>
      <td style="text-align:left">GMF</td>
      <td style="text-align:left">GMF设计模型</td>
      <td style="text-align:left">GMF代码生成器的输入</td>
    </tr>
    <tr>
      <td style="text-align:left">oexegdiagram</td>
      <td style="text-align:left">GMF</td>
      <td style="text-align:left">GMF图编辑器</td>
      <td style="text-align:left">纯粹由GMF设计模型生成</td>
    </tr>
    <tr>
      <td style="text-align:left">oexegdextensions</td>
      <td style="text-align:left">GMF和Xtext</td>
      <td style="text-align:left">GMF图编辑器扩展</td>
      <td style="text-align:left">生成的GMF编辑器的手动扩展，用于与Xtext集成</td>
    </tr>
    <tr>
      <td style="text-align:left">oexgmf.glue</td>
      <td style="text-align:left">Xtext和GMF</td>
      <td style="text-align:left">胶水代码</td>
      <td style="text-align:left">集成Xtext和GMF的通用代码</td>
    </tr>
  </tbody>
</table>

<p>我们将分三个阶段详述这个例子。</p>

<h3 id="gmf-integration-stage1">阶段1：使GMF读取和写入语义模型作为文本</h3>

<p>GMF中的图表编辑器默认管理两个资源：一个用于语义模型，即我们实际感兴趣的模型，用于进一步处理。在我们的示例中，它是表示实体和数据类型的模型。第二个资源包含符号模型。它表示您在图表中看到的形状及其图形属性。符号元素引用它们的语义对应物。实体的名称将在语义模型中，而在图中绘制它的字体将存储在符号模型中。请注意，在集成示例中，我们只是尝试将语义资源表示为文本。</p>

<p>为了使语义模型和图模型保持同步，GMF使用所谓的<em>CanonicalEditPolicy</em> 。此组件注册为语义模型的侦听器，并在其语义对应项更改，添加或删除时自动更新图元素。一些符号信息可以通过一些默认映射从语义模型中导出，但通常有很多图形内容，用户想要更改以使图表看起来更好。</p>

<p>在Xtext编辑器中，通过调用方法<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource.update（int，int，String）</a>将文本中的更改传输到底层<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a> ，这将触发脏文本区域的部分解析并替换相应的子树在AST模型（语义模型）中。</p>

<p>因此，在同一资源上使用Xtext编辑器和规范GMF编辑器可能会导致符号信息丢失，因为Xtext编辑器中的更改将删除AST中的子树，导致<em>CanonicalEditPolicy</em>删除所有符号元素，即使它是由用户定制。Xtext重建AST，并使用默认映射恢复表示法模型。因此，不建议让Xtext编辑器和规范GMF编辑器在同一资源上工作。</p>

<p>在此示例中，我们让每个编辑器使用自己的模型内存实例，并仅对文件更改进行同步。两个框架已经与开箱即用的已编辑文件的外部更改同步。在glue代码中，有一个<em>org.eclipse.xtext.gmf.glue.concurrency。如果用户尝试同时使用两个不同的模型编辑器编辑同一文件，则ConcurrentModificationObserver会</em>警告用户。</p>

<p>在该示例中，我们开始为实体语言编写Xtext语法。如上所述，我们首选可选分配，而是覆盖验证器中的强制属性。在讨价还价中，我们添加了一些服务来改进EMF集成，即格式化程序，片段提供程序和卸载程序。然后我们让Xtext生成语言基础结构。从派生的Ecore模型及其生成器模型，我们生成了编辑插件（GMF需要）并添加了一些更漂亮的图标。</p>

<p>从GMF方面，我们遵循默认程序并创建了一个gmfgraph模型，一个gmftool模型和一个gmfmap模型，它引用了从Xtext语法派生的Ecore模型。我们更改了GMF从gmfmap模型派生的gmfgen模型中的一些设置，即启用打印并启用验证和验证装饰器。然后我们生成了图编辑器。</p>

<p>Voilà，我们现在有一个图表编辑器，可以将其语义模型读/写为文本。另请注意，Xtext中的验证器已通过菜单栏集成在图编辑器中。</p>

<h3 id="gmf-integration-stage2">阶段2：调用Xtext解析器来解析GMF标签</h3>

<p>GMF为标签生成的解析器有点差：它只适用于属性，并且对于交叉引用会失败，例如属性的类型。那么为什么不使用Xtext解析器来处理用户的输入呢？</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java">XtextResource</a>通过所谓的节点模型跟踪它的具体语法表示（有关更详细的描述，请参阅<a href="301_grammarlanguage.html#parser-rules">解析器规则部分</a> ）。节点模型表示解析树，并提供有关已经解析以创建语义模型元素的偏移量，长度和文本的信息。节点通过节点适配器附加到它们的语义元素。</p>

<p>我们可以使用节点适配器来访问表示属性的文本块，并调用Xtext解析器来解析用户输入。示例代码包含在<em>org.eclipse.xtext.gmf.glue.edit.part中。AntlrParserWrapper</em> 。<em>SimplePropertyWrapperEditPartOverride</em>显示了如何将其集成到生成的GMF编辑器中。使用<em>EntitiesEditPartFactoryOverride</em>将其实例化，并使用<em>EntitiesEditPartProviderOverride</em>创建重写的工厂，并将后者注册到扩展点。请注意，这是一种扩展生成的GMF编辑器的非侵入性方法。</p>

<p>在测试编辑器时，您会注意到编辑几个标签后节点模型将损坏。这是因为节点模型仅由Xtext解析器更新，而不是由序列化器更新。因此，每次更改语义模型时，我们都需要一种自动调用（部分）解析器的方法。您将在包<em>org.eclipse.xtext.gmf.glue.editingdomain中</em>找到所需的类。要激活节点模型协调，您必须添加一行</p>

<pre><code class="language-java">XtextNodeModelReconciler.adapt（editingDomain）;</code></pre>

<p>在生成的<em>EntitiesDocumentProvider</em>的方法<code>createEditingDomain()</code>中。为避免更改生成的代码，您可以通过设置修改该类的代码生成模板</p>

<pre><code class="language-java">动态模板 - &gt; true Template Directory =“org.eclipse.xtext.example.gmf.models / templates”</code></pre>

<p>在<em>GenEditorGenerator</em>和</p>

<pre><code class="language-java">必需的插件 - &gt;“org.eclipse.xtext.gmf.glue”</code></pre>

<p>在重新生成图编辑器之前，在gmfgen的<em>GenPlugin</em>元素中。</p>

<h3 id="gmf-integration-stage3">第3阶段：弹出式Xtext编辑器（实验性）</h3>

<p><em>SimplePropertyPopupXtextEditorEditPartOverride</em>演示如何生成Xtext编辑器以编辑模型元素。编辑器弹出控件并仅显示所选元素的部分。它是一个完全成熟的Xtext编辑器，支持验证，代码辅助和语法高亮。编辑后的文本只有在没有任何错误的情况下才会传回模型。</p>

<p>请注意，仍然存在同步问题，这就是我们将此标记为实验性的原因。</p>

<hr>

<p><strong><a href="310_eclipse_support.html">下一章：Eclipse支持</a></strong></p>


</body>
</html><html id="0335.org_eclipse_cdt_managedbuilder_core_ManagedBuildInfo.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>托管构建工具2.0（已弃用）</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">托管构建工具2.0（已弃用）</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.cdt.core。ManagedBuildTools<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>1.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>托管构建信息模型描述了构建系统的目标，配置和工具链。<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.target">目标</a> ， <a href="#e.tool">工具</a> ， <a href="#e.configuration">配置</a> ， <a href="#e.dynamicElementProvider">dynamicElementProvider</a> ， <a href="#e.managedBuildRevision">managedBuildRevision</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.tool">工具</a> （ <a href="#e.option">选项</a> ， <a href="#e.optionCategory">optionCategory</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST工具</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">来源CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">输出CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">outputFlag CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">outputPrefix CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">dependencyCalculator CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">headerExtensions CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">natureFilter（cnature | ccnature | both）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">定义构建过程中使用的工具。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 构建模型将使用的工具的唯一标识符。</li>
<li><b>name</b> - 要在UI中使用的工具的可读名称。</li>
<li><b>sources</b> - 工具将为其生成输出的以逗号分隔的文件扩展名列表。</li>
<li><b>outputs</b> - 工具将从给定输入生成的扩展。</li>
<li><b>command</b> - 调用该工具的命令。例如，gn用于Gnu C编译器，g ++用于Gnu C ++编译器。</li>
<li><b>outputFlag</b> - 工具的可选标志，允许用户指定工具工件的名称。例如，GCC编译器和链接器工具通常允许用户使用“-o”标志指定输出的名称，而创建库的存档器则不允许。</li>
<li><b>outputPrefix</b> - 某些工具生成具有必须指定的特殊前缀的文件。例如，POSIX系统上的图书馆员期望输出为lib <target>.a，因此'lib'将是前缀。</target></li>
<li><b>dependencyCalculator</b> - 这是一个可选字段，指定为给定工具提供源文件依赖关系计算的类。您可以使用实现<code>IManagedDependencyGenerator</code>接口的类替换默认计算器。</li>
<li><b>headerExtensions</b> - 用于头文件的以逗号分隔的文件扩展名列表。由于许多其他文件依赖于头文件中定义的接口，因此构建系统需要能够确定头文件已更改为正确重建其依赖项。</li>
<li><b>natureFilter</b> - 根据项目的性质过滤工具的显示（和使用）。选择'cnature'的值可确保工具显示IFF有一个与项目相关的cnature。ccnature将过滤此工具。如果选择“ccnature”，则该工具仅适用于C ++项目。如果选择“两者”，则当存在任何一种性质时，将显示该工具。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.option">选项</a> （ <a href="#e.enumeratedOptionValue">enumeratedOptionValue</a> ， <a href="#e.listOptionValue">listOptionValue</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选项</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">valueType（string | stringList | boolean | enumerated | includePath | definedSymbols | libs | userObjs）“string”</p>
<p class="code SchemaDtdAttlist">类别CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultValue CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">commandFalse CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">browseType（无|文件|目录）</p>
<p class="code SchemaDtdAttlist">helpSupplier CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">提示CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">选项与工具相关联。选项可以包含布尔值，简单文本字符串，枚举列表中的选择或值列表。选项还将它们包含的值映射到命令行标志，例如在调试编译器的符号信息时使用'-g'。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 选项的唯一标识符。</li>
<li><b>name</b> - 选项的描述性名称。</li>
<li><b>valueType</b> - 常规选项可以是以下类型之一; 'string'表示无法轻易定义的选项的catch-all条目，'string list'表示由一系列值组成的条目，如定义的符号或路径，'boolean'表示有两个值的选项，以及对于作为值列表之一的选项，“枚举”。存在其他特殊类型以标记与构建模型特别相关的选项; 'include'，'libs'，'userObjs'和'definedSymbols'。您可以预先填充optionValues，它们将在UI中以与'stringList'选项相同的方式显示。当客户端查询包含路径和预处理器定义时，构建模型将专门查找这些值类型。makefile生成器将以不同于其他stringLists的方式处理libs和userObjs条目。</li>
<li><b>category</b> - 这是此选项的选项类别的ID。id可以是工具的id，也是一个类别。</li>
<li><b>defaultValue</b> - 如果“value”字段为空，则指定选项的默认值。对于枚举选项，将搜索optionEnums的默认值。对于字符串列表选项，所有已定义的optionValues都将被视为默认值。对于布尔值，请使用字符串'true'指定true。所有其他字符串将被视为false。</li>
<li><b>command</b> - 一个可选值，指定将在命令行上传递给工具的实际命令。</li>
<li><b>commandFalse</b> - 一个可选值，仅用于Boolean类型的选项，指定当Boolean选项的值为False时将在命令行<b>上传递给</b>工具的实际命令。</li>
<li><b>browseType</b> - 此值仅用于列表（和相关）选项。如果在添加新值时需要列表选项来提示用户浏览文件或目录，请相应地设置属性的值。默认情况下，该值被视为不需要浏览。</li>
<li><b>helpSupplier</b> - 此字段在2.0中未使用</li>
<li><b>tip</b> - 指定可以在悬停帮助中或属性页面上显示的“提示”。未在2.0中实现。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enumeratedOptionValue">enumeratedOptionValue</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST enumeratedOptionValue</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">isDefault（true | false）</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">定义枚举选项的单个值。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 选项枚举的唯一标识符。</li>
<li><b>name</b> - 枚举的描述性名称。</li>
<li><b>isDefault</b> - 如果用户未更改设置，则将此枚举值标记为应用于该选项的默认值。</li>
<li><b>command</b> - 枚举值转换为命令行的命令。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.configuration">配置</a> （ <a href="#e.toolReference">toolReference</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST配置</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">配置用于将某些默认工具和选项聚集在一起，以某种方式构建目标。例如，“调试”配置可能为工具提供设置为使用调试符号构建的选项，而“发布”配置将为工具提供选项集以创建最佳性能。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 配置的唯一标识符。</li>
<li><b>name</b> - 要在UI中使用的配置的描述性名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.toolReference">toolReference</a> （ <a href="#e.optionReference">optionReference</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST工具参考</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">输出CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">outputPrefix CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">outputFlag CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">这留作将来使用。它目前已实例化以保存工具设置。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 引用所用工具的唯一ID。</li>
<li><b>command</b> - 引用所用工具的重写命令。</li>
<li><b>outputs</b> - 此工具引用将创建的以逗号分隔的扩展列表。这完全覆盖了引用所用工具中的输出扩展。</li>
<li><b>outputPrefix</b> - 将应用于工具输出的前缀。这完全覆盖了引用工具中定义的输出。</li>
<li><b>outputFlag</b> - 覆盖引用工具的输出标志。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.optionReference">optionReference</a> （ <a href="#e.listOptionValue">listOptionValue</a> ， <a href="#e.enumeratedOptionValue">enumeratedOptionValue</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST optionReference</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">defaultValue CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">选项引用保留用户通过UI更改的信息。并非所有字段都将填充，具体取决于引用覆盖的选项类型。例如，'name'字段仅由枚举选项使用。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 引用所用选项的唯一ID。</li>
<li><b>defaultValue</b> - 此字段用于记录用户在构建设置文件中设置的选项的值。例如，如果用户已将verbose标志设置为true，则项目的构建设置文件将包含verbose选项的选项引用，defaultvalue设置为true。
<p>该属性还用于覆盖工具链中配置的默认选项设置。例如，“调试”配置可能会将调试标志的值设置为与工具中定义的默认值不同。</p></li>
<li><b>命令</b> - 该字段在2.0中未使用</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.target">目标</a> （ <a href="#e.tool">工具</a> ， <a href="#e.configuration">配置</a> ， <a href="#e.tool">工具</a> <a href="#e.toolReference">参考</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST目标</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">isAbstract（true | false）“false”</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">artifactName CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultExtension CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">isTest（true | false）</p>
<p class="code SchemaDtdAttlist">cleanCommand CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">makeCommand CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">makeArguments CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">binaryParser CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">osList CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">archList CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">errorParsers CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">scannerInfoCollector CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">makefileGenerator CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">表示作为构建过程目标的资源类型，例如，Linux静态库。目标包含一系列工具定义和配置。目标以继承层次结构排列，其中目标从其父级继承工具列表，并可添加或覆盖此列表中的工具。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 由构建模型用于唯一标识目标。</li>
<li><b>name</b> - 人类可读的目标名称，例如“可执行文件”。这将是用户在UI中显示的名称。</li>
<li><b>isAbstract</b> - 这是一个UI属性。如果设置为true，则用户应该无法创建针对此目标的项目配置。</li>
<li><b>parent</b> - 此工具继承的目标的ID。</li>
<li><b>artifactName</b> - 这是与目标关联的最终构建工件的名称。用户将指定这是UI，因此无需提供默认值。</li>
<li><b>defaultExtension</b> - 这是将应用于目标创建的任何构建工件的扩展。</li>
<li><b>isTest</b> - 一个可选字段，用于将目标标记为仅测试目标。如果为true，则目标不会出现在UI中。</li>
<li><b>cleanCommand</b> - 此属性维护用于删除特定目标文件的命令。例如，在像Linuc，Solaris或Cygwin这样的POSIX目标上，命令将是<code>rm -rf</code>而在Win32平台上，它将是<code>del /F /S /Q</code></li>
<li><b>makeCommand</b> - 指定启动工具链的构建实用程序的默认命令。如果用户通过UI更改此设置，则overriden值将存储在项目构建文件中。如果用户重置更改，则构建模型将默认为此值。</li>
<li><b>makeArguments</b> - 指定构建器调用构建实用程序时将传递给构建实用程序的其他默认参数。如果用户通过UI更改标志，则overriden值将存储在项目构建设置文件中。如果用户重置更改，则构建模型将默认为此值。</li>
<li><b>binaryParser</b> - 将其设置为目标输出格式的二进制解析器的ID。目前只有两种选择：org.eclipse.cdt.core。ELF for * nix目标，以及“org.eclipse.cdt.core。PE“用于为Windows构建的目标，如Cygwin。</li>
<li><b>osList</b> - 托管构建系统使用此字段来决定何时向用户显示目标。该值应为逗号分隔列表。当前值是“win32”，“linux”，“solaris”，“hpux”，“aix”或“any”。</li>
<li><b>archList</b> - 托管构建系统使用此字段来决定何时向用户显示目标。该值应为逗号分隔列表。当前值包括“x86”，“sparc”，“ppc”;或“全部”。</li>
<li><b>errorParsers</b> - 指定从此目标创建的项目要使用的默认错误解析器列表。它是一个有序的，以分号分隔的解析器ID列表。该顺序指定在构建期间调用错误解析器的顺序。</li>
<li><b>scannerInfoCollector</b> - 指定实现<code>IManagedScannerInfoCollector</code>的类，用于收集工具链的内置编译器设置。</li>
<li><b>makefileGenerator</b> - 允许您提供符合<code>IManagedBuilderMakefileGenerator</code>接口的自定义makefile生成器。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.optionCategory">optionCategory</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST optionCategory</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">所有者CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一种可选但有用的机制，用于将选项组合在一起。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 由构建模型用于唯一标识选项类别。</li>
<li><b>name</b> - 人类可读的类别名称，例如“预处理器选项”。这将是用户在UI中显示的名称。</li>
<li><b>所有者</b> - 选项类别可以属于某个工具，也可以嵌套在其他选项类别中。这是该类别所有者的ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.listOptionValue">listOptionValue</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST listOptionValue</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">builtIn（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">用于定义列表选项的各个元素的值。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 列表项的内容。</li>
<li><b>builtIn</b> - 此属性将列表值标记为内置值，而不是用户输入的内容。内置函数不会传递给生成命令行的客户端（如makefile生成器）。但是，需要考虑这些设置的客户端（如索引服务）将收到这些设置。这些值在UI中显示为灰色。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dynamicElementProvider">dynamicElementProvider</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST dynamicElementProvider</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个可选元素，允许工具实现者提供创建一个或多个动态工具链元素的类。例如，类可能会根据特殊文件的内容和使用该引用的新目标创建新的工具引用。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>IManagedConfigElementProvider</code>接口的类。确定元素的逻辑留给实现者，但它们必须正确形成，否则构建模型将无法加载。</li>
<li><b>name</b> - 要提供的元素类型的有意义的名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.managedBuildRevision">managedBuildRevision</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST managedBuildRevision</p>
<p class="code SchemaDtdAttlist">fileVersion CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>托管构建扩展点的版本标识符。它是一个字符串表示形式，由三（3）个由小数点分隔的标记组成。3个令牌是正整数。例如，以下是有效的版本标识符：</p><ul>
  <li><code>0.0.0</code></li>
  <li><code>1.0.1234</code></li>
  <li><code>1.9</code> （解释为<code>1.9.0</code> ）</li>
  <li><code>3</code> （解释为<code>3.0.0</code> ）</li>
 </ul>
</div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>fileVersion</b> - 包含三个版本标记的实际字符串。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是扩展点用法的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension id =</span> <span class="code SchemaCstring">“buildExample”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“Build for Build Example”</span> <span class="code SchemaTag">point =</span> <span class="code SchemaCstring">“org.eclipse.cdt.core。ManagedBuildInfo“</span> <span class="code SchemaTag">&gt; &lt;target makeFlags =</span> <span class="code SchemaCstring">” -  k“</span> <span class="code SchemaTag">isTest =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">cleanCommand =</span> <span class="code SchemaCstring">”rm -rf“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”Executable“</span> <span class="code SchemaTag">defaultExtension =</span> <span class="code SchemaCstring">”。exe“</span> <span class="code SchemaTag">isAbstract =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">makeCommand =</span> <span class="code SchemaCstring">”make“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”example.target .executable“</span> <span class="code SchemaTag">&gt; &lt;tool sources =</span> <span class="code SchemaCstring">”C“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”Compiler“</span> <span class="code SchemaTag">outputFlag =</span> <span class="code SchemaCstring">” -</span> <span class="code SchemaTag">o</span> <span class="code SchemaCstring">“</span> <span class="code SchemaTag">outputs =</span> <span class="code SchemaCstring">”exe“</span> <span class="code SchemaTag">command =</span> <span class="code SchemaCstring">”g ++“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”executable.compiler“</span> <span class="code SchemaTag">&gt; &lt;optionCategory owner =</span> <span class="code SchemaCstring">”executable.compiler“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“Flags”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“compiler.category.flags”</span> <span class="code SchemaTag">&gt; &lt;/ optionCategory&gt; &lt;option defaultValue =</span> <span class="code SchemaCstring">“ -  c”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“Compiler Flags”</span> <span class="code SchemaTag">category =</span> <span class="code SchemaCstring">“compiler.category.flags”</span> <span class="code SchemaTag">valueType =</span> <span class="code SchemaCstring">“string”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“category .flags.comp_flags“</span> <span class="code SchemaTag">&gt; &lt;/ option&gt; &lt;/ tool&gt; &lt;configuration name =</span> <span class="code SchemaCstring">”Default“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”example.config.default“</span> <span class="code SchemaTag">&gt; &lt;/ configuration&gt; &lt;/ target&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6><samp>org.eclipse.cdt.ui中</samp>提供了此扩展点的实现
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2003,2004 IBM Corporation等。本程序及随附的资料根据Eclipse发布的Eclipse Public License 2.0条款提供，可在<a href="http://www.eclipse.org/legal/epl-2.0/">Eclipse</a>网站上找到。

</p>
</body>
</html><html id="1455.ch03s24s05.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>3.24.5。�测试运行后自动向外部存储库报告</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula User Manual"></link>
<link rel="up" href="ch03s24.html" title="3.24.�Working with external task repositories (ALM Integration)"></link>
<link rel="prev" href="ch03s24s04.html" title="3.24.4.�Creating tasks in external repositories from test result reports"></link>
<link rel="next" href="ch03s25.html" title="3.25.�Using the test executor for testing from the command line"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">3.24.5。�测试运行后自动向外部存储库报告</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch03s24s04.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">3.24。�使用外部任务存储库（ALM集成）</th>
<td width="20%" align="right">� <a href="ch03s25.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula用户手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch03.html">任务</a></span> &gt; <span class="breadcrumb-link"><a href="ch03s24.html">使用外部任务存储库（ALM集成）</a></span> &gt; <span class="breadcrumb-node">测试运行后自动向外部存储库报告</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="automatically-reporting-to-external-repositories-after-test-runs"></a> 3.24.5。�测试运行后自动向外部存储库报告</h3></div></div></div>
<a name="automatically-reporting-to-external-repositories-after-test-runs.guidancerPropertiesViewContextId"></a><p>运行测试时，您可以自动更新外部存储库中的任务。您可以通过在外部存储库中的任务上编写注释来报告测试结果，并在ITE中添加指向测试结果的链接。您还可以根据在项目中指定的信息更新任务的字段/属性。
  </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="configuring-a-task-repository"></a> 3.24.5.1。�为项目配置任务存储库</h4></div></div></div>
<p>为工作区配置一个或多个存储库后（ <a class="xref" href="ch03s24s02.html" title="3.24.2。�在工作区中配置任务存储库">Section�3.24.2，“在工作区中配置任务存储库”</a> ），您可以选择其中一个作为项目的测试相关存储库。
    </p>
<p>这将让你：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>将此存储库中的任务ID添加到项目中的测试用例和测试套件，以表示此项目是此任务的测试（ <a class="xref" href="ch03s24s05.html#adding-task-id-alm" title="3.24.5.3。�将任务ID添加到测试套件和测试用例">Section�3.24.5.3，“向测试套件和测试用例添加任务ID”</a> ）。
        </p></li>
<li class="listitem"><p>自动将测试结果报告给测试运行时定义的任务。
        </p></li>
<li class="listitem"><p>查看ITE中相关项目的测试结果，作为任务存储库中的链接。
        </p></li>
</ul></div>
<p>
      <span class="strong"><strong>要为项目配置任务存储库：</strong></span>
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>在Project Properties中，从左侧的树中选择<span class="emphasis"><em>Mylyn ALM</em></span> （图<a class="xref" href="ch03s24s05.html#TasksALMProjectProperties" title="Figure3.31。�ALM设置">�3.31，“ALM设置”</a> ）。
        </p></li>
<li class="listitem"><p>在显示的页面中，您可以从组合框中选择存储库。您可以使用按钮验证存储库设置。
        </p></li>
<li class="listitem"><p>您可以（可选）输入配置为使用正确数据库作为测试结果的ITE的URL。如果您在此处输入其URL，则可以单击任务存储库中的测试结果链接以自动在ITE中打开测试结果。
        </p></li>
</ol></div>
<div class="figure">
<a name="TasksALMProjectProperties"></a><div class="figure-contents"><div class="mediaobject"><img src="../images/almproperties.png" xmlns:d="http://docbook.org/ns/docbook"></div></div>
<div class="figure-title">Figure3.31。�ALM设置</div>
</div>
<br class="figure-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="configuring-reporting-to-tasks-via-properties"></a> 3.24.5.2。�配置任务报告</h4></div></div></div>
<p>测试运行后，您可以使用以下信息更新存储库中的相关任务：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>包含测试运行状态的注释，以及指向该测试结果的链接。</p></li>
<li class="listitem">
<p>您可以根据测试是成功还是失败来更新任务的字段/属性。
  	</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>具有非<span class="emphasis"><em>传递</em></span>状态的测试（例如，失败，停止，仍在测试）被视为失败</strong></span></td>
</tr></tbody>
</table>
</li>
</ul></div>
<p>对于链接到任务的测试运行中的每个项目（测试用例，测试套件）（ <a class="xref" href="ch03s24s05.html#adding-task-id-alm" title="3.24.5.3。�将任务ID添加到测试套件和测试用例">Section�3.24.5.3，“将任务ID添加到测试套件和测试用例”</a> ），您将在项目属性中指定的规则将被执行out将测试结果报告给该任务。
  	</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>在Project Properties中，从左侧的树中选择<span class="emphasis"><em>Mylyn ALM</em></span> 。</p></li>
<li class="listitem"><p>在显示的页面中，您可以配置报告结果的方式。对于成功和失败的操作，您有相同的选择。
	</p></li>
<li class="listitem">
<p>
		</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>您可以激活该复选框，为每个链接的任务添加注释。注释包含有关测试运行（日期，状态）的信息以及测试结果的链接。测试结果可以在指定的ITE中看到（ <a class="xref" href="ch03s24s05.html#configuring-a-task-repository" title="3.24.5.1。�为项目配置任务存储库">Section�3.24.5.1，“为项目配置任务存储库”</a> ）。
			</p></li>
<li class="listitem">
<p>您可以在表中添加规则以更新任务的属性。输入描述性名称（这仅用于“属性”中的显示目的），要更新的属性的ID以及应更新属性的值。作为更新的值，您可以输入：</p>
<p>
				</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>纯文本，例如“通过”</p></li>
<li class="listitem">
<p>此运行的“测试结果摘要视图”中的列的值。通过输入列名作为变量来获取列的值。一些例子是：</p>
<p>$ summary_autHostname，$ summary_testRunState（例如“OK”或“FAILED”），$ summary_testsuiteName，$ summary_testJobName，$ summary_testsuiteEndTime，$ summary_testsuiteDate（完整日期格式），$ summary_statusString（例如“成功测试”或“儿童错误”） ），$ summary_testsuiteDuration，$ summary_testsuiteStartTime，$ summary_date（对于DD.MM.YYYY），$ summary_autOS</p>
<p>但您可以通过输入列名称作为前缀为“summary_”的变量来使用任何列值。
					</p>
</li>
<li class="listitem">
<p>来自执行节点的值。该值作为变量输入，例如</p>
<p>$ node_taskId，$ node_timeStamp，$ node_typeOfNode（例如测试用例），$ node_name，$ node_parameterDescription，$ node_date（用于DD.MM.YYYY），$ node_url（见下文）</p>
<p>使用$ node_url参数接收将链接到ITE中此节点（测试用例或测试套件）的URL（ <a class="xref" href="ch03s24s05.html" title="3.24.5。�测试运行后自动向外部存储库报告">xSection�3.24.5，“测试运行后自动向外部存储库报告”</a> ）。
					</p>
</li>
</ul></div>
<p>
			</p>
</li>
</ul></div>
<p>
		</p>
</li>
<li class="listitem"><p>要查看ALM存储库中可用的属性，可以从任务视图查看各个任务的信息（ <a class="xref" href="ch03s24s05.html#viewing-task-attributes" title="3.24.5.2.1。�查看任务属性">Section�3.24.5.2.1，“查看任务属性”</a> ）</p></li>
</ol></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="viewing-task-attributes"></a> 3.24.5.2.1。�查看任务属性</h4></div></div></div>
<p>为了定义向ALM系统报告的规则，您需要输入要更新的任何属性的ID（ <a class="xref" href="ch03s24s05.html#configuring-reporting-to-tasks-via-properties" title="3.24.5.2。�配置任务报告">Section�3.24.5.2，“配置向任务报告”</a> ）。
	</p>
<p>您可以使用“任务视图”中的“ <span class="menuPath">显示属性”</span>选项<span class="menuPath">查看</span>任务具有哪些属性。
	</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>通过选择以下内容打开任务视图（如果尚未打开）：</p>
<p>
		<span class="menuPath">窗口</span> - &gt; <span class="menuPath">显示视图</span> - &gt; <span class="menuPath">任务视图</span> 。
		</p>
</li>
<li class="listitem"><p>如果尚未为工作区配置存储库，请在“任务存储库”视图中执行此操作（ <a class="xref" href="ch03s24s02.html" title="3.24.2。�在工作区中配置任务存储库">Section�3.24.2，“在工作区中配置任务存储库”</a> ）。
		</p></li>
<li class="listitem">
<p>导航到要查看其属性的任务，然后选择：</p>
<p>
		从上下文菜单中<span class="menuPath">显示属性</span> 。
		</p>
</li>
<li class="listitem"><p>将出现任务属性查看器。在此对话框中，您可以看到此任务的属性的ID，您可以使用这些ID在项目属性中定义测试结果报告的规则（ <a class="xref" href="ch03s24s05.html#configuring-reporting-to-tasks-via-properties" title="3.24.5.2。�配置任务报告">Section�3.24.5.2，“配置向任务报告”</a> ）。您可以使用键盘复制属性。
		</p></li>
</ol></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="adding-task-id-alm"></a> 3.24.5.3。�将任务ID添加到测试套件和测试用例</h4></div></div></div>
<p>您可以在项目中为测试用例和测试套件添加任务ID。
    </p>
<p>任务ID应该是您已指定为此项目的存储库的存储库中的有效ID（ <a class="xref" href="ch03s24s05.html#configuring-a-task-repository" title="3.24.5.1。�为项目配置任务存储库">Section�3.24.5.1，“为项目配置任务存储库”</a> ）。将任务ID添加到项目中的项目意味着此项目是存储库中该任务的相关测试。您将能够报告此项目的测试结果。
    </p>
<p>要将任务ID添加到测试用例或测试套件：</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>双击打开编辑器中的项目。
        </p></li>
<li class="listitem"><p>在“属性视图”的“ <span class="emphasis"><em>任务ID</em></span> ”单元格中，输入外部存储库中的任务ID。您只能在规范位置输入任务ID  - 重复使用该项目时不能覆盖它们。
        </p></li>
<li class="listitem"><p>保存编辑器。
        </p></li>
<li class="listitem">
<p>将任务ID添加到节点后，可以通过选择以下命令从浏览器打开此节点的任务：</p>
<p>
          <span class="menuPath">用</span> - &gt; <span class="menuPath">Mylyn任务编辑器</span> <span class="menuPath">打开</span>
        </p>
</li>
</ol></div>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>您应该确保将任务ID添加到正确的节点级别，以便为存储库中的任务提供相关数量的信息。这通常是测试套件中的用例级别。
    </strong></span></td>
</tr></tbody>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="test-execution-with-reporting-to-external-repositories"></a> 3.24.5.4。�通过向外部存储库报告执行测试</h4></div></div></div>
<p>如果您的项目已加入外部存储库（ <a class="xref" href="ch03s24s05.html#configuring-a-task-repository" title="3.24.5.1。�为项目配置任务存储库">Section�3.24.5.1，“为您的项目配置任务存储库”</a> ），并且您已将任务ID添加到项目中的一个或多个项目（ <a class="xref" href="ch03s24s05.html#adding-task-id-alm" title="3.24.5.3。�将任务ID添加到测试套件和测试用例">Section�3.24.5.3，“添加”）测试套件和测试用例的任务ID“</a> ），然后您将能够在测试运行后将测试结果报告给存储库。测试运行可以通过ITE或命令行<span class="emphasis"><em>testexec进行</em></span> 。
    </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您通过应向ALM系统报告的ITE运行“相关”测试，则在测试运行后会自动触发报告。如果测试运行的报告遇到错误，那么您将能够在以后手动触发报告<a class="xref" href="ch03s24s05.html#test-execution-with-reporting-to-external-repositories" title="3.24.5.4。�通过向外部存储库报告执行测试">Section�3.24.5.4，“使用报告到外部存储库来测试执行”</a> 。要在通过testexec运行测试后向ALM系统报告，还必须手动触发记录（ <a class="xref" href="ch03s24s05.html#test-execution-with-reporting-to-external-repositories" title="3.24.5.4。�通过向外部存储库报告执行测试">Section�3.24.5.4，“测试执行并向外部存储库报告”</a> ）。
    </strong></span></td>
</tr></tbody>
</table>
<p>触发报告时，会发生以下情况：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>与Project属性中配置的ALM系统建立连接。
        </p></li>
<li class="listitem"><p>然后分析测试结果以查看是否需要在外部存储库中添加任何注释。
        </p></li>
<li class="listitem">
<p>如果要进行报告，ITE会将每个必要任务报告为批处理作业。这些批处理作业包含所需的字段更新和注释。虽然这在控制台视图中显示为一个操作，但您将获得<span class="emphasis"><em>N个</em></span>评论/字段更新的<span class="emphasis"><em>N个</em></span>事务。如果一个测试运行中的多个项目引用相同的任务ID，或者在同一个测试运行中多次执行具有任务ID的项目，则只会写入一个注释，但是这个注释将包含有关所有已执行项目的信息。这个ID。但是，链接到任务ID的每个项目都会进行字段更新。</p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>具有非<span class="emphasis"><em>传递</em></span>状态的测试（例如，失败，停止，仍在测试）被视为<span class="emphasis"><em>失败</em></span> 。
        </strong></span></td>
</tr></tbody>
</table>
</li>
<li class="listitem"><p>您可以在控制台视图中查看ALM报告的状态。
        </p></li>
<li class="listitem"><p>报告完成后，您可以在外部存储库中看到更改。如果添加了注释，则可以单击提供的链接以在为项目指定的ITE中打开测试结果报告。ITE必须已经运行才能成功完成此操作。测试结果还必须存在于数据库中（ <a class="xref" href="ch03s22s03.html#re-opening-the-test-result-view-for-a-test-run" title="3.22.3.1。�重新打开测试运行的测试结果视图">Section�3.22.3.1，“重新打开测试运行的测试结果视图”</a> ）。
        </p></li>
<li class="listitem"><p>测试结果报告在引用当前任务ID的节点处打开。</p></li>
<li class="listitem">
<p>您可以在“测试结果摘要视图<a class="xref" href="ch03s24s05.html#test-execution-with-reporting-to-external-repositories" title="3.24.5.4.�Test execution with reporting to external repositories">”中</a>查看报告的状态（ <a class="xref" href="ch03s24s05.html#test-execution-with-reporting-to-external-repositories" title="3.24.5.4。�通过向外部存储库报告执行测试">Section�3.24.5.4，“使用向外部存储库报告的测试执行”</a> ）。
        </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>写入外部存储库的集成可以与Bugzilla 3.6 +，JIRA 5.0+和HP ALM 11+一起使用。其他有Mylyn连接器的存储库也可以使用，但这些尚未经过测试。
        </strong></span></td>
</tr></tbody>
</table>
</li>
</ul></div>
<p>
      <span class="strong"><strong>通过testexec</strong></span>开始<span class="strong"><strong>测试后向ALM存储库报告对于通过testexec</strong></span>启动的测试，报告不会自动发生。相反，您必须选择从“测试结果摘要视图”向ALM报告。
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>在配置为向ALM存储库报告的项目中，当测试通过testexec运行时，您可以打开Reporting Perspective并在“测试结果摘要视图”中找到测试运行。
        </p></li>
<li class="listitem">
<p>在“ <span class="emphasis"><em>ALM报告状态”</em></span>列中，您将看到是否有任何待处理的报告。您可以在此列中看到各种状态：</p>
<div class="variablelist"><dl class="variablelist">
<dt><span class="term">未配置：</span></dt>
<dd><p>如果您尚未为项目配置ALM报告，或者在测试开始时将Test Suite的相关性设置为false。
              </p></dd>
<dt><span class="term">尚未报道：</span></dt>
<dd><p>如果为项目配置了报告，并且有可用于报告的信息尚未报告，例如通过testexec的测试运行。如果您通过ITE运行了由于例如连接问题而无法向ALM系统报告的测试，您也将看到此状态。这使您可以在问题解决后稍后报告测试结果。
              </p></dd>
<dt><span class="term">报道说：</span></dt>
<dd><p>如果您运行了通过ITE配置报告的测试，则会显示此状态，该报告会自动报告。如果您在通过testexec运行测试后选择向ALM系统报告，也会显示它。即使测试运行未链接到任何任务，也会显示此状态，但为项目配置了报告。可以理解， <span class="emphasis"><em>任何必要的报告都已经执行</em></span> 。如果在报告其中一个任务时发生错误，即使并非所有任务都已正确更新，状态仍会显示<span class="emphasis"><em>报告</em></span></p></dd>
<dt><span class="term">报告丢弃：</span></dt>
<dd><p>如果报告信息可用，但信息被丢弃，因此未报告。您可以通过从上下文菜单中选择放弃待处理报告的选项来执行此操作。对于导入的项目中的任何测试运行，也会显示此状态，该项目在导出项目时状态为<span class="emphasis"><em>尚未报告</em></span> 。
              </p></dd>
<dt><span class="term">标记为不相关：</span></dt>
<dd><p>您将在测试开始时标记为相关的任何测试运行中看到此状态，并且具有要报告的信息（状态： <span class="emphasis"><em>尚未报告</em></span> ），但您通过切换测试结果中的相关性将其标记为不相关摘要视图。此状态表示您可以报告或丢弃信息，但前提是您重新切换测试运行是相关的。
              </p></dd>
</dl></div>
</li>
<li class="listitem"><p>选择要向ALM报告其结果的任何测试运行，然后单击工具栏上的“ <span class="emphasis"><em>报告到ALM</em></span> ”按钮。您也可以从上下文相关菜单中选择此选项。如果选择多个测试运行，则每个测试运行将按顺序进行报告。
        </p></li>
<li class="listitem"><p>选择此选项后，将按上述方法触发报告。如果报告成功，则“ <span class="emphasis"><em>ALM报告状态”</em></span>列中的<span class="emphasis"><em>状态</em></span>将从<span class="emphasis"><em>“尚未报告”</em></span>更改为“已<span class="emphasis"><em>报告”</em></span> 。如果发生错误，则状态仍为“ <span class="emphasis"><em>尚未报告”</em></span> 。
        </p></li>
<li class="listitem"><p>如果您不想将测试结果报告给ALM工具，则可以通过从上下文菜单中选择放弃待处理报告的选项来放弃报告信息。这会将<span class="emphasis"><em>ALM报告状态</em></span>列中的<span class="emphasis"><em>状态</em></span>从<span class="emphasis"><em>尚未报告的报告</em></span>更改为已<span class="emphasis"><em>丢弃</em></span> 。
        </p></li>
</ol></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="specific-information-for-hp-alm-users"></a> 3.24.5.5。�HPALM用户的特定信息</h4></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>要使用HP ALM集成，必须为HP ALM使用单独的连接器，这可能会产生许可证成本。访问Tasktop网站了解更多详情<a class="link" href="http://www.tasktop.com" target="_top">http://www.tasktop.com</a> 。</p></li>
<li class="listitem">
<p>如果您已在HP ALM安装中更改了缺陷和/或要求的属性ID（相对默认值）（ <span class="emphasis"><em>BG_DEV_COMMENTS</em></span>和<span class="emphasis"><em>REQ_DEV_COMMENTS</em></span> ），或者您更改了连接器的ID，则必须在<span class="input">almAccess.properties中</span>修改这些属性包含在jar中的文件：</p>
<p>
          <span class="emphasis"><em>org.eclipse.jubula.client.alm.mylyn.core</em></span>
        </p>
</li>
<li class="listitem"><p>由于HP ALM中的任务只有一个注释字段，因此结果信息将附加到注释字段，而不是每次都添加为新注释。
        </p></li>
<li class="listitem"><p>要在默认HP ALM安装中写入需求，必须使用前缀<span class="emphasis"><em>REQ</em></span> ，例如REQ100。要写入默认HP ALM安装中的缺陷，必须使用前缀<span class="emphasis"><em>DEF</em></span> ，例如DEF42。
        </p></li>
</ul></div>
</div>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="2928.org_eclipse_ui_propertyPages.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>物业页面</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">物业页面</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.propertyPages<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于为给定类型的对象添加其他属性页。定义后，这些属性页将出现在该类型对象的“属性”对话框中。
<p>属性页是用户友好的方式与对象的属性进行交互。与限制可用于编辑对象属性的空间的“属性”视图不同，属性页可以从使用标签，图标等定义更大，更复杂的控件的自由中受益。逻辑上一起使用的属性也可以聚集在页面中，而不是分散在属性表中。但是，在大多数应用程序中，通过属性表公开某些对象的属性是合适的，有些则通过属性页公开。
</p>

<p>属性页显示在对话框中，当在对象的弹出菜单上选择“属性”菜单项时，该对话框通常是可见的。除了对象类之外，还可以选择提供名称过滤器来仅为特定对象类型注册属性页。
</p>

<p>如果这些过滤机制不合适，则属性页可以使用过滤机制。在这种情况下，目标对象的属性在一系列键值对中描述。适用于选择的属性是特定于类型的，超出了工作台本身的域，因此工作台会将此级别的过滤委派给实际选择。
</p><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.page">第</a> * <a href="#e.page">页</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.page">页面</a> （ <a href="#e.filter">filter</a> *， <a href="#e.keywordReference">keywordReference</a> *， <a href="#e.enabledWhen">enabledWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST页面</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">objectClass CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">nameFilter CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">适应性（真|假）</p>
<p class="code SchemaDtdAttlist">类别IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">selectionFilter（single | multi）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该页面是页面实现和外观的规范。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 将用于标识此页面的唯一名称</li>
<li><b>name</b> - 将在此页面的UI中使用的可翻译名称</li>
<li><b>icon</b> - 除了页面名称之外，将在UI中使用的图标的相对路径</li>
<li><i style="color:red">不推荐使用的</i> <b>objectClass</b> - 为其注册页面的类的完全限定名称。该类不需要实现<tt>IAdaptable</tt> 。不是<tt>IAdaptable</tt>实例的对象在被发送到属性页面的实例（ <tt>org.eclipse.ui）之前将被包装在<tt>IAdaptable中</tt> <tt>。IWorkbenchPropertyPage</tt> ）。

<p>在Eclipse 3.3中不推荐使用。改为使用enabledOhen元素的instanceOf或adapt元素。如果以前使用重复页面定义来为多个objectClass类型注册页面，则应使用组合在一个或元素内的多个instanceOf元素将这些定义组合成一个页面定义</p></li>
<li><b>class</b> - 实现<tt>org.eclipse.ui的类的完全限定名称<tt>。IWorkbenchPropertyPage</tt> 。</li>
<li><b>nameFilter</b> - 一个可选属性，允许在应用于目标对象名称的通配符匹配条件下进行注册。</li>
<li><i style="color:red">不推荐使用的</i> <b>adaptable</b> - 一个标志，指示适应IResource的类型是否应使用此属性页。如果objectClass适应IResource，则使用此标志。默认值为false。

<p>在Eclipse 3.3中不推荐使用。请改用enabledWhen元素的adapt子元素</p>

<strong>注意：</strong> adaptable属性将尝试使对象适应<code>org.eclipse.core.resources.IResource</code>在引用在<code>Platform#getAdaptorManager</code>注册的类型之前。enabledWhen元素没有<code>org.eclipse.core.resources.特殊案例测试<code>org.eclipse.core.resources.IResource</code>并使用<code>Platform#getAdaptorManager</code>查找适应性类型。这些可以使用<code>org.eclipse.core.runtime.adaptors</code>扩展点进行注册。</li>
<li><b>category</b> - 指示属性树中页面位置的路径。路径可以是父节点ID或由'/'分隔的ID序列，表示来自根节点的完整路径。</li>
<li><b>selectionFilter</b> - 这是一个可选属性。如果未指定，则假定属性页仅支持单个选择（仅包含单个对象的选择）。
<p>将此属性设置为“multi”以指示属性页支持多个选定对象。支持此模式的属性页必须实现接口<tt>org.eclipse.ui。IWorkbenchPropertyPageMulti</tt> 。对于多选页面，“enabledWhen”条件将与填充了所选项目的Container一起提供（即使选择仅包含一个项目）。在这样的页面上“enabledWhen”表达式应该使用“iterate”来访问选择的元素。
</p><p>将此属性设置为“single”以指示属性页仅支持单个选择。
</p><p>默认值：单</p>自3.7以来。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.filter">过滤器</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST过滤器</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。仅当选择中的每个对象具有指定的属性状态时才会发生匹配。选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。</li>
<li><b>value</b> - 对象属性的值。结合name属性，名称值对用于定义属性页的目标对象。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.keywordReference">keywordReference</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST keywordReference</p>
<p class="code SchemaDtdAttlist">id IDREF #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">属性页面对关键字的引用。请参阅关键字扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 要引用的关键字的ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">或</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">enabled when元素指定将此属性页面添加到属性对话框的条件。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是属性页定义的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.propertyPages”</span> <span class="code SchemaTag">&gt; &lt;page id =</span> <span class="code SchemaCstring">“com.xyz.projectPage”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“XYZ Java Properties”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.ppages。JavaPropertyPage“</span> <span class="code SchemaTag">nameFilter =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;instanceof value =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">&gt; &lt;/ instanceof&gt; &lt;/ enabledWhen&gt; &lt;filter name =</span> <span class="code SchemaCstring">”readOnly“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;/ page&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>属性<samp>类</samp>必须指定实现<samp>org.eclipse.ui的类的完全限定名称<samp>。IWorkbenchPropertyPage</samp>或<samp>org.eclipse.ui。IWorkbenchPropertyPageMulti</samp> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>工作台提供的某些对象可能已注册了属性页。允许插件为这些对象添加更多属性页。属性页不限于工作台资源：工作台中显示的所有对象（甚至是由插件创建的特定于域的对象）都可以具有属性页，并且允许其他插件为它们注册属性页。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2010 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0164.sg-DisplayTheNumberOfCustomersTextOnOneLine.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>格式化报告</title>
    <link rel="StyleSheet" href="css/grouping.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="sg-DisplayTheTotalNumberOfCustomersInTheReport.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="sg-PreviewTheReportInTheBIRTReportViewer.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h3 class="N_TutorialTask">任务8： <a name="192407">格式化报告</a></h3>
      <p class="b1i_Bullet1-intro"><a name="192410">既然报告显示了正确的数据，请专注于改进报告的外观。您在本节中执行以下任务：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a href="#379361" title="格式化报告" name="192414">调整列宽</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a href="#385344" title="格式化报告" name="378129">从详细信息行中删除信用额度数据</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a href="#192443" title="格式化报告" name="192418">在每个组的第一行显示组标题</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a href="#192489" title="格式化报告" name="379355">用一条线分开每个组</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a href="#336470" title="格式化报告" name="379359">在一行上显示客户文本数</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <h4 class="N_h3_Head3"><a name="379361">调整列宽</a></h4>
      <p class="b_Body"><a name="379365">插入表时，BIRT会创建宽度相等的列。在此报表中，您可以通过减小信用额度列的宽度并增加客户列的宽度来改进布局。如果查看整个报表，您会看到某些客户名称扩展到列的边缘，并且一个名称被截断。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="379366">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="379367">选择表格。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="425139">选择第一列并通过拖动列边界或设置其Width属性将其宽度减小到1.25英寸。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="425140">通过减小第一列的宽度，第二列的宽度增加。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="425225">预览报告。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="425127">数据间距得到改善，</a> <a href="#389672" title="格式化报告">如图7-21</a> <a name="425127">所示</a> 。</div>
      <p class="i2_Image2"><a name="389670"><img class="Default" src="images/grpt_output5b.png" alt="图7-21显示调整列宽的报告预览" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-21</b> <a name="389672">显示调整列宽的报告预览</a></div>
      <h4 class="N_h3_Head3"><a name="385344">从详细信息行中删除信用额度数据</a></h4>
      <p class="b_Body"><a name="411013">要验证数据是否显示在正确的信用限额组中，显示每个客户的信用额度非常有用。现在您已验证了数据，请从报告中删除单个信用额度信息。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="411014">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192427">从详细信息行中删除[CREDITLIMIT]数据元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192431">预览报告。它应该</a> <a href="#211789" title="格式化报告">如图7-22</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="192440"><img class="Default" src="images/grpt_output6.png" alt="图7-22报告预览显示每行删除的信用额度数据" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-22</b> <a name="211789">报告预览显示每行删除的信用限额数据</a></div>
      <h4 class="N_h3_Head3"><a name="192443">在每个组的第一行显示组标题</a></h4>
      <p class="b_Body"><a name="192447">信用限额组标题显示在各自的行中，位于每个组的详细信息行上方。在此过程中，删除组标题，使它们出现在每个组的第一个详细信息行中。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192448">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="378351">选择包含组标题的单元格，</a> <a href="#211805" title="格式化报告">如图7-23</a> <a name="378351">所示</a> 。请务必选择单元格而不是单元格中的数据元素。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="378355"><img class="Default" src="images/grpt_layout6.png" alt="图7-23选中的组标题单元格" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-23</b> <a name="211805">选中的组标题单元格</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="195026">在Property Editor的General属性中，将Drop设置为Detail。在报表设计中，组标题仍显示在详细信息行上方，因为从技术上讲，该元素仍位于组标题行中。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="211822">预览报告。组标题出现在每组的第一行，</a> <a href="#211831" title="格式化报告">如图7-24</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="211829"><img class="Default" src="images/grpt_output7.png" alt="图7-24报告预览显示已删除的组标题" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-24</b> <a name="211831">报告预览显示已删除的组标题</a></div>
      <h4 class="N_h3_Head3"><a name="192489">用一条线分开每个组</a></h4>
      <p class="b_Body"><a name="192493">绘制一条线来分隔每个组可以更容易地查看每个数据组。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192494">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192495">选择组页脚行中的所有单元格。要选择多个单元格，请在单击每个单元格时按Shift键。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192498">在“属性编辑器”的“属性”下，选择“边框”，然后设置边框属性，如下所示：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="192499">将样式设置为实线。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="345589">将颜色设置为黑色。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="336452">将宽度设置为细。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="N_si_ScanIcon"><a name="192503"><img class="Default" src="images/bottomborderbutton.png" alt="底部边框按钮" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="b2_Bullet2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b2_Bullet2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b2_Bullet2_inner"><a name="192505">选择显示底部边框的按钮。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192507">在行上方和文本之间添加更多空格。在单元格仍处于选中状态时，在Property Editor中选择Padding属性，并将Bottom设置为6.0点，</a> <a href="#304282" title="格式化报告">如图7-25</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="304268"><img class="Default" src="images/grpt_padding.png" alt="图7-25属性编辑器显示所选单元格的填充值" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-25</b> <a name="304282">属性编辑器显示所选单元格的填充值</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="412493">预览报告。每个组末尾都会出现一条线，</a> <a href="#221760" title="格式化报告">如图7-26</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="412502"><img class="Default" src="images/grpt_output8.png" alt="图7-26报告预览显示组之间的行" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-26</b> <a name="221760">报告预览显示组之间的行</a></div>
      <h4 class="N_h3_Head3"><a name="336470">在一行上显示客户文本数</a></h4>
      <p class="b_Body"><a name="336484">表格顶部的文本显示在第一列的中心。在此过程中，您将格式化文本，使其显示为左对齐并在一行上。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="336505">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="336534">使用Shift键单击，选择顶部表标题行中的第一个和第二个单元格，</a> <a href="#336591" title="格式化报告">如图7-27</a> <a name="336534">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="336545"><img class="Default" src="images/grpt_selectcells.png" alt="图7-27选中顶表标题行中的两个单元格" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-27</b> <a name="336591">选中顶表标题行中的两个单元格</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="336523">右键单击选定的单元格，然后选择“合并单元格”。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="336618">选择合并单元格中的[CUSTOMER_TOTAL]元素，然后在属性编辑器的常规属性中，选择B按钮和左按钮。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="336636">预览报告。它应该</a> <a href="#336715" title="格式化报告">如图7-28</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="336661"><img class="Default" src="images/grpt_output8b.png" alt="图7-28显示客户数量的报告预览：一行122个" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-28</b> <a name="336715">显示客户数量的报告预览：一行122个</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3840.204_activeannotations.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>主动注释</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="active-annotations">主动注释</h1>

<p><em>Active注释</em>允许开发人员通过库参与Xtend源代码到Java代码的转换过程。这在Java需要手动编写大量样板的情况下很有用。例如，许多好的旧设计模式都属于这一类。使用<em>活动注释，</em>您不再需要记住应如何实现<a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>或<a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer</a>模式。在Xtend中，您可以在库中实现此类模式的扩展，并让编译器为您完成繁重的工作。</p>

<p><em>活动注释</em>只是在Java或Xtend中声明的注释，它本身使用<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/Active.java">Active</a>注释。<code>@Active</code>将类型文字作为指向处理器的参数。</p>

<p>IDE插件附带了一个示例项目，您可以轻松地将其实现到工作区中。为此，请使用新项目向导，并在类别<em>Xtend示例中</em>选择活动注释示例。这些示例包含三个不同的注释，我们将用它们进一步解释。</p>

<p>例如， <code>@Extract</code>是一个提取类的接口的注释。注释声明如下所示：</p>

<pre><code class="language-xtend">@Active（ExtractProcessor）注释提取{}</code></pre>

<h2 id="active-annotations-processor">注释处理器</h2>

<p>处理器类必须实现编译器提供的一个或多个生命周期回调接口。这个接口是：</p>

<ul>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">RegisterGlobalsParticipant</a>第一次回电。仅在创建全局符号表（即索引）时调用以注册类型名称。见<a href="204_activeannotations.html#active-annotations-register-globals">第1阶段</a> 。</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationParticipant.java">TransformationParticipant</a>此回调通常是最有用的，因为它允许通过添加，删除或更改成员来更改已翻译的Java结构。请参阅<a href="204_activeannotations.html#active-annotations-transformation-phase">阶段2</a> 。</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/ValidationParticipant.java">ValidationParticipant</a>虽然您已经可以在转换期间进行验证，但您只能在此回调期间完全解析任何类型。见<a href="204_activeannotations.html#active-annotations-validation-phase">第3阶段</a> 。</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/CodeGenerationParticipant.java">CodeGenerationParticipant</a>如果你想生成一些额外的文本，例如XML，这个钩子适合你。见<a href="204_activeannotations.html#active-annotations-code-generation">第4阶段</a> 。</li>
</ul>

<p>有一些基类可以实现所有回调接口。您应该根据注释目标对其中一个进行子类化：</p>

<ul>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractClassProcessor.java">AbstractClassProcessor</a>是类注释的基类</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractInterfaceProcessor.java">AbstractInterfaceProcessor</a>是接口注释的基类</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractAnnotationTypeProcessor.java">AbstractAnnotationTypeProcessor</a>是注释类型注释的基类</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractEnumerationTypeProcessor.java">AbstractEnumerationTypeProcessor</a>是枚举类型注释的基类</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractMethodProcessor.java">AbstractMethodProcessor</a>是方法注释的基类</li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/AbstractFieldProcessor.java">AbstractFieldProcessor</a>是字段注释的基类</li>
</ul>

<p>如果要注释其他元素（如参数或构造函数），则应该查看基类并相应地调整它们的实现（基本上是类型参数）。通过使用<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/declaration/Declaration.java">Declaration</a> ，所有声明的元素的超类型，也可以拥有一个非常通用的处理器。</p>

<h3 id="active-annotations-register-globals">第1阶段：注册全局</h3>

<p>编译器生命周期的第一个阶段是将类型索引为全局可用符号。通过实现<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">RegisterGlobalsParticipant，</a>您可以在此阶段创建和注册新的Java类型。在第一阶段执行此操作非常重要，以便稍后编译器可以查找和访问这些类型。</p>

<p>例如，ExtractProcessor为每个带注释的类添加一个接口：</p>

<pre><code class="language-xtend">class ExtractProcessor扩展AbstractClassProcessor {override doRegisterGlobals（ClassDeclaration annotatedClass，RegisterGlobalsContext context）{context.registerInterface（annotatedClass.interfaceName）} def getInterfaceName（ClassDeclaration annotatedClass）{annotatedClass.qualifiedName +“Interface”} ...}</code></pre>

<p><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/RegisterGlobalsContext.java">RegisterGlobalsContext</a>提供此编译步骤中可用的所有服务。它被传递到方法<code>doRegisterGlobals()</code>以及带注释的源元素的只读表示。对于使用<code>@Extract</code>注释的所有类，都会调用此示例中的AbstractClassProcessor。</p>

<p>编译器每个编译单元调用一次<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">RegisterGlobalsParticipant</a> ，并提供对使用此处理器注册的<em>活动注释</em>进行注释的所有元素的访问。因此，调用<code>ExtractProcessor</code>会显示在同一Xtend文件中为正在编译的所有文件定义的所有类的列表。</p>

<h3 id="active-annotations-transformation-phase">阶段2：转型</h3>

<p>在第二阶段，开发人员可以修改已编译的Java类和Java代码。实现<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationParticipant.java">TransformationParticipant的</a>注释处理器参与此编译步骤。与<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/RegisterGlobalsParticipant.java">RegisterGlobalsParticipant</a>接口类似，编译器提供两个参数：带注释的已翻译和现在可变的Java元素列表以及<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationContext.java">TransformationContext</a> 。上下文提供特定于第二步的服务。</p>

<p>转换参与者可以访问和修改可变Java元素。这些是生成的Java代码的内存表示。它们通常与源元素非常相似，但可以进行修改，并且可以添加新的方法，字段或构造函数。在转换步骤中无法创建新类型。另请注意，其他注释处理器可能已经更改了模型。</p>

<p><code>ExtractProcessor</code>实现方法<code>doTransform</code>如下所示：</p>

<pre><code class="language-xtend">class ExtractProcessor扩展AbstractClassProcessor {override doRegisterGlobals（ClassDeclaration annotatedClass，RegisterGlobalsContext context）{context.registerInterface（annotatedClass.interfaceName）} def getInterfaceName（ClassDeclaration annotatedClass）{annotatedClass.qualifiedName +“Interface”} override doTransform（MutableClassDeclaration annotatedClass，extension TransformationContext context）{val interfaceType = findInterface（annotatedClass.interfaceName）//将接口添加到已实现接口列表annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces +＃[interfaceType.newTypeReference] //将公共方法添加到接口（method：annotatedClass.declaredMethods） {if（method.visibility == Visibility。PUBLIC）{interfaceType.addMethod（method.simpleName）[docComment = method.docComment returnType = method.returnType for（p：method.parameters）{addParameter（p.simpleName，p.type）} exceptions = method.exceptions]}} }}</code></pre>

<p>在第一行中， <code>findInterface</code>检索在第一阶段注册全局符号期间注册的接口：该方法在<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationContext.java">TransformationContext</a>中定义，该文件用作<a href="202_xtend_classes_members.html#extension-provider">扩展提供程序</a> 。</p>

<p>接下来，新创建的接口将添加到现有的已实现接口列表中。</p>

<pre><code class="language-xtend">annotatedClass.implementedInterfaces = annotatedClass.implementedInterfaces +＃[interfaceType.newTypeReference]</code></pre>

<p>代码在带注释的类上调用<code>setImplementedInterfaces(Iterable&lt;TypeReference&gt;)</code> 。赋值的右侧是现有实现的接口和指向新创建的接口的类型引用的串联。</p>

<p>可以使用<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/declaration/TypeReference.java">TypeReferenceProvider</a>中的各种方法之一创建<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/services/TypeReferenceProvider.java">TypeReference</a> ， <a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/services/TypeReferenceProvider.java">TypeReferenceProvider</a>是<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationContext.java">TransformationContext</a>的超类型。这些实用程序也可作为扩展。</p>

<h3 id="active-annotations-validation-phase">阶段3：验证</h3>

<p>第三个生命周期允许参与验证。您可以在转换期间甚至在registerGlobals期间进行验证，但现在只能完全解析所有内容，包括推断的类型引用。</p>

<h3 id="active-annotations-code-generation">第4阶段：代码生成</h3>

<p>编译器生命周期的最后一个阶段允许您参与编写和更新文件。在IDE中，此阶段仅在保存时执行，而前两个在编辑器中进行少量编辑后执行。为了参与您的处理器需要实现<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/CodeGenerationParticipant.java">CodeGenerationParticipant</a> 。提取接口示例不使用此挂钩，但另外包含的国际化示例生成* .properties文件，如下所示：</p>

<pre><code class="language-xtend">class ExternalizedProcessor扩展AbstractClassProcessor {...override doGenerateCode（List &lt;？扩展ClassDeclaration&gt; annotatedSourceElements，扩展CodeGenerationContext上下文）{for（clazz：annotatedSourceElements）{val filePath = clazz.compilationUnit.filePath val file = filePath.targetFolder.append（clazz.qualifiedName.replace（'。'，'/'）+“ .properties“）file.contents ='''«FOR field：clazz.declaredFields»«field.simpleName»=«field.initializerAsString»«ENDFOR»'''}}}</code></pre>

<p><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/CodeGenerationContext.java">CodeGenerationContext</a>提供此阶段可用的所有服务。有关更多详细信息，请查看Java文档。</p>

<h2 id="active-annotations-expression">关于表达和陈述</h2>

<p>大多数生成的Java代码以内存中元素的形式表示。基本上所有结构元素都表示为专用<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/declaration/Element.java">元素</a> 。如果要生成方法的主体或字段的初始值设定项，则有两个选项。</p>

<h3 id="active-annotations-compilation-strategies">生成Blackbox Java代码</h3>

<p>第一个选择是分配编译策略并自己处理Java代码。作为示例，可观察实例的setter方法的主体由以下代码片段实现：</p>

<pre><code class="language-xtend">observableType.addMethod（'set'+ fieldName.toFirstUpper）[addParameter（fieldName，fieldType）body ='''«fieldType»_oldValue = this。«fieldName»;这个。«fieldName»=«fieldName»; _propertyChangeSupport.firePropertyChange（“«fieldName»”，_ oldValue，«fieldName»）; ''']</code></pre>

<p>模板表达式用于实现主体。尽管此代码在转换期间执行，但实际的连接仅在代码生成期间发生。它是字符串连接的一种特殊形式，在连接TypeReference，java.lang时会自动添加导入。类或TypeDeclaration。它会考虑现有的进口，并在必要时即时添加新的进口。</p>

<h3 id="active-annotations-assigning-expressions">分配表达式</h3>

<p>第二种方法是将Xtend源中的表达式放入生成的Java元素的上下文中。这允许直接使用源文件中编写的代码。将字段转换为延迟初始化属性的注释<code>@Lazy</code>可以像这样使用：</p>

<pre><code class="language-xtend">class MyClass {@Lazy String myField = expensiveComputation（）}</code></pre>

<p>此<em>活动注释</em>的处理器可以推断合成初始化方法并添加getter方法，如果该字段仍为<code>null</code> ，则调用初始化方法。因此，字段的初始化表达式必须成为合成初始化方法的方法体。以下代码执行此转换：</p>

<pre><code class="language-xtend">override doTransform（MutableFieldDeclaration field，extension TransformationContext context）{// add synthetic init-method field.declaringType.addMethod（'_ init'+ field.simpleName）[visibility = Visibility。PRIVATE returnType = field.type //将初始化表达式重新分配为init方法的主体//这会自动删除表达式，因为字段的初始化器主体= field.initializer] //添加一个懒惰地初始化字段field.declaringType的getter方法。 addMethod（'get'+ field.simpleName.toFirstUpper）[returnType = field.type body = ['''if（«field.simpleName»== null）«field.simpleName»= _init«field.simpleName»（）; return«field.simpleName»; ''']]}</code></pre>

<h2 id="active-annotations-validation">自定义编译器检查</h2>

<p>前面的示例要求每个带注释的字段都有一个初始化程序。否则，将无法使用延迟初始化来分配其值。另外，对<code>null</code>引用的简单检查可能会导致原始值出现问题。对该案例的验证也是明智的。为了引导用户，如果违反这些约束，则应引发专用编译错误。</p>

<p><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/TransformationContext.java">TransformationContext</a>从<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/services/ProblemSupport.java">ProblemSupport</a>服务继承了用于此目的的<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib.macro/src/org/eclipse/xtend/lib/macro/services/ProblemSupport.java">方法</a> 。</p>

<p>由于<code>context</code>被声明为<a href="202_xtend_classes_members.html#extension-provider">扩展提供程序</a> ，因此这些方法可以用作扩展，并允许相应地实现约束检查：</p>

<pre><code class="language-xtend">override doTransform（MutableFieldDeclaration field，extension TransformationContext context）{if（field.type.primitive）field.addError（“@Lazy不支持带基元的字段”）if（field.initializer == null）field.addError（“A懒字段必须有一个初始化器。“）...}</code></pre>

<p>这可确保向用户通知<em>活动注释</em> <code>@Lazy</code>无效应用程序。</p>

<h2 id="active-annotation-classpath">类路径设置和测试</h2>

<p><em>活动注释</em>不能在声明它的同一项目中使用，但必须驻留在上游项目中。或者，它可以在jar中编译和部署。注释和处理器本身仅依赖于<code>org.eclipse.xtend.lib.macro</code>中定义的接口，该接口是Xtend的小型标准库的一部分。</p>

<p>另请注意，宏库以及处理器严格来说只是编译时依赖项。因此，如果重要，例如在Android设备上，则无需在运行时发送它们。</p>

<p>在IDE中使用时，编译的注释处理器在IDE过程中即时加载和执行。</p>

<p>因此，仔细测试和调试处理器至关重要。最好在单元测试中完成。这样的测试需要类路径上的整个Xtend编译器，您可以通过OSGi bundle依赖或Maven获取。maven依赖是</p>

<pre><code>&lt;dependency&gt; &lt;groupId&gt; org.eclipse.xtend &lt;/ groupId&gt; &lt;artifactId&gt; org.eclipse.xtend.core &lt;/ artifactId&gt; &lt;version&gt; 2.17.0 &lt;/ version&gt; &lt;scope&gt; test &lt;/ scope&gt; &lt;/ dependency &gt; &lt;dependency&gt; &lt;groupId&gt; org.eclipse.xtext &lt;/ groupId&gt; &lt;artifactId&gt; org.eclipse.xtext.xbase.testing &lt;/ artifactId&gt; &lt;version&gt; 2.17.0 &lt;/ version&gt; &lt;scope&gt; test &lt;/ scope&gt; &lt;/依赖性&gt;</code></pre>

<p>等效的OSGI包是<code>org.eclipse.xtend.core</code> 。</p>

<h3 id="active-annotation-compiler-tester">测试</h3>

<p><code>XtendCompilerTester</code>是一个方便的辅助类，用于测试处理和编译。它允许通过使用String比较或通过检查生成的Java元素来比较生成的Java源来测试活动注释处理器。此外，您甚至可以将生成的Java源代码编译为Java类，并反射性地创建和测试它的实例。</p>

<p>示例项目包含几个测试用例：</p>

<pre><code class="language-xtend">class LazyTest {extension XtendCompilerTester compilerTester = XtendCompilerTester.newXtendCompilerTester（Lazy.classLoader）@Test def void testLazy（）{'''import lazy。懒类Person {@Lazy String name ='foo'}'''。hassertCompilesTo（'''import lazy。懒; @SuppressWarnings（“all”）公共类Person {@Lazy private String name; private String _initname（）{return“foo”; public String getName（）{if（name == null）name = _initname（）;返回名称; }}'''}}}</code></pre>

<p>这是一个基本的字符串比较。这是开始开发新注释处理器的好方法。稍后对生成的元素和语法树（AST）的断言可能是更好的选择，因为它们对格式化的更改不是那么脆弱。<code>@Extract</code> -example使用这种技术：</p>

<pre><code class="language-xtend">@Test def void testExtractAnnotation（）{'''@ extraxt。Extract类MyClass {override String doStuff（String myParam）throws IllegalArgumentException {return myParam}}'''。compile [//将转换上下文声明为本地扩展名val扩展名ctx = transformationContext //查找接口和类val interf = findInterface（'MyClassInterface'）val clazz = findClass（'MyClass'）//断言assertEquals（interf，clazz.implementedInterfaces.head.type）interf.declaredMethods.head =&gt; [assertEquals（'doStuff'，simpleName）assertEquals（ string，returnType）assertEquals（IllegalArgumentException.newTypeReference，exceptions.head）]]}</code></pre>

<h3 id="wrap-up">包起来</h3>

<p><em>Active Annotations</em>是一个强大而独特的概念，可以解决以前必须以繁琐的方式解决的大量问题。IDE向导，许多代码生成器或手动编写样板代码不再是最先进的。主动注释基本上<em>是</em>代码生成的一种手段，但它与现有项目的简单集成和快速开发转向减少了代码生成的典型缺点。</p>

<h2 id="existing-active-annotations">现有的活动注释</h2>

<p>Xtend附带了针对常见代码模式的即用型活动注释。它们驻留在<code>org.eclipse.xtend.lib.annotations</code>插件/ jar中，该插件必须位于包含Xtend文件的项目的类路径中。</p>

<h2 id="property-annotation">@Accessors</h2>

<p>如果你想为你的字段添加getter和/或setter方法<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/annotations/Accessors.xtend"><code>@Accessors</code></a>是你的朋友。这是一个基本的例子。</p>

<pre><code class="language-xtend">@Accessors字符串名称</code></pre>

<p>将编译为Java代码</p>

<pre><code class="language-java">私有字符串名称; public String getName（）{return this.name; public void setName（final String name）{this.name = name; }</code></pre>

<p>因此，默认情况下会创建公共getter和public setter方法。<code>@Accessors</code>可以配置为告诉您只需要一个或另一个并更改可见性。这是通过<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/annotations/Accessors.xtend">AccessorType</a>完成的。您还可以使用类级别的注释对所有字段执行相同操作。</p>

<p>这是一个更复杂的示例，它显示了它的工作原理：</p>

<pre><code class="language-xtend">@Accessors类Person {String name String firstName @Accessors（PUBLIC_GETTER，PROTECTED_SETTER）int age @Accessors（NONE）String internalField}</code></pre>

<p>将编译为Java代码</p>

<pre><code class="language-java">@Accessors public class Person {private String name private String firstName @Accessors（PUBLIC_GETTER，PROTECTED_SETTER）private int age @Accessors（NONE）private String internalField public String getName（）{return this.name; public void setName（final String name）{this.name = name; public String getFirstName（）{return this.firstName; public void setFirstName（final String firstName）{this.firstName = firstName; public int getAge（）{return this.age; } protected void setAge（final int age）{this.age = age; }}</code></pre>

<h2 id="data-annotation">@数据</h2>

<p>注释<a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/annotations/Data.xtend"><code>@Data</code></a>将把带注释的类转换为值对象类。根据以下规则处理使用<code>@Data</code>注释的类：</p>

<ul>
  <li>所有领域都是最终的，</li>
  <li>将生成getter方法（如果它们尚不存在），</li>
  <li>将生成具有所有非初始化字段的参数的构造函数（如果它不存在），</li>
  <li>将生成equals（Object）/ hashCode（）方法（如果它们不存在），</li>
  <li>将生成一个toString（）方法（如果它不存在）。</li>
</ul>

<p>例：</p>

<pre><code class="language-xtend">@Data class Person {String firstName String lastName def static void main（String [] args）{val p = new Person（args.get（0），args.get（1））println（p.getFirstName（）+'' + p.lastName）}}</code></pre>

<h2 id="delegate-annotation">@代表</h2>

<p><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtend.lib/src/org/eclipse/xtend/lib/annotations/Delegate.xtend"><code>@Delegate</code></a>注释自动为委托与当前实现的类之间共享的所有接口生成委托方法。您可以选择将其限制为明确声明的接口。</p>

<p>让我们从一个基本的例子开始：</p>

<pre><code class="language-xtend">class MyClass实现SomeInterface {//生成List的所有方法并委托给该字段@Delegate SomeSubTypeOfSumInterface myDelegate}</code></pre>

<p>它不仅可以委托给字段，还可以委托给方法，因此您可以懒得创建委托对象或每次使用不同的委托对象。如果您使用方法，您还可以声明其他参数，这将告诉您应该调用的方法。</p>

<p>这是另一个例子：</p>

<pre><code class="language-xtend">class MyClass实现SomeInterface {SomeInterface myDelegate; @Delegate def List &lt;？extends String&gt; provideDelegate（String methodName，Class [] paramTypes，Object [] actualArguments）{if（！canHandle（methodName，paramTypes，actualArguments）{throw new UnsupportedOperationException（“方法”+ methodName +“不受支持。”）; } return myDelegate}}</code></pre>



</body>
</html><html id="2298.OCLInterpreterTutorial.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>使用经典OCL</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="Tutorials.html" title="Tutorials"></link>
<link rel="prev" href="ValidationTutorial.html" title="Validation tutorial"></link>
<link rel="next" href="Extensions.html" title="Extensions (in the Unified/Pivot OCL prototype)"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">使用经典OCL</h1>
<div class="section" title="使用经典OCL">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OCLInterpreterTutorial"></a>使用经典OCL</h2>
</div>
</div>
</div>
<div class="section" title="概观">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Overview4"></a>概观</h3>
</div>
</div>
</div>
<p>本教程演示了Classic Eclipse OCL实现提供的各种服务。</p>
</div>
<div class="section" title="参考">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="References3"></a>参考</h3>
</div>
</div>
</div>
<p>本教程假定读者熟悉Eclipse扩展点体系结构。对于那些不熟悉扩展点的人来说，Eclipse中有大量的在线帮助。</p>
<p>要查看本教程中显示的示例的完整源代码，请将<a class="link" href="OCLInterpreterExample.html" title="OCL解释器示例">OCL Interpreter Example</a>插件安装到工作区中。
				</p>
<p>其他参考：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>有关测试将在本教程中创建的OCL表达式的环境，请安装<a class="ulink" href="../references/examples/exampleOverview.html" target="_new">Library Metamodel</a>示例。
						</p>
</li>
<li class="listitem">
<p>
							
<a class="ulink" href="http://www.omg.org/spec/OCL" target="_new">OCL 2.0</a>规范。
						</p>
</li>
</ul>
</div>
</div>
<div class="section" title="解析OCL表达式">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ParsingOCLExpressions"></a>解析OCL表达式</h3>
</div>
</div>
</div>
<p>OCL解释器的第一个职责是解析OCL表达式。解析表达式的目的之一是验证它：如果它可以被解析，它就是格式良好的（解析器根据语义良构规则自动验证表达式）。</p>
<p>进入OCL API的主要入口是<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html" target="_new">OCL</a>类。<code class="code">OCL</code>提供自治的OCL解析环境。它跟踪在此环境中解析的所有约束，包括其他操作和属性的定义。<code class="code">OCL.newInstance()</code>工厂方法用于创建具有<code class="code">EnvironmentFactory</code>的新OCL， <code class="code">EnvironmentFactory</code>提供对特定元模型（Ecore或UML）的绑定。在本教程中，我们将使用Ecore绑定。
				</p>
<p>为了解析查询表达式，我们将使用<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html" target="_new"><code class="code">OCLHelper</code></a>对象，该对象为解析查询和约束（用于处理模型中嵌入的约束）提供了方便的操作。
				</p>
<div class="literallayout">
<p>
<code class="code">布尔有效;<br>OCLExpression &lt;EClassifier&gt; query = null;<br>

<br>尝试{<br>//为Ecore创建一个OCL实例<br>OCL &lt;？，EClassifier，？，？，？，？，？，？，？，Constraint，EClass，EObject&gt; ocl;<br>ocl = OCL.newInstance（EcoreEnvironmentFactory。实例）;<br>
    <br>//创建一个OCL助手对象<br>OCLHelper &lt;EClassifier，？，？，Constraint&gt; helper = ocl.createOCLHelper（）;<br>
    <br>//设置OCL上下文分类器<br>helper.setContext（EXTLibraryPackage。文字。作家）;<br>
    <br>query = helper.createQuery（“self.books-&gt; collect（b：Book | b.category） - &gt; asSet（）”）;<br>
    <br>//记录成功<br>有效=真;<br>} catch（ParserException e）{<br>//记录解析失败<br>有效=假;<br>通信System.err.println（e.getLocalizedMessage（））;<br>}<br>

</code>
</p>
</div>
<p></p>
<p>上面的示例解析了一个表达式，该表达式计算与<code class="code">Writer</code>关联的<code class="code">Book</code>的不同类别。它无法解析的可能原因（在这种情况下抛出<code class="code">ParserException</code> ）包括：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>语法问题：错位或缺少结构，如结束</p>
</li>
</ul>
</div>
<p>括号，变量声明，类型表达式等</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>语义问题：上下文的未知属性或操作</p>
</li>
</ul>
</div>
<p>类型或引用类型，未知包，类等。</p>
</div>
<div class="section" title="解析OCL约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ParsingOCLConstraints"></a>解析OCL约束</h3>
</div>
</div>
</div>
<p>OCL主要用于<span class="emphasis"><em>约束</em></span> s的规范。与查询不同，在模型中的不同位置使用各种不同类型的约束。这些包括分类器不变量，操作约束和属性派生约束。<code class="code">OCLHelper</code>可以为我们解析这些问题。
				</p>
<p>让我们想象一下，一个拥有多本同名书籍的图书馆产生的混乱（我们不打算为模型复制）。我们将为@ Book @ s创建一个不变约束，规定不允许这样做：</p>
<div class="literallayout">
<p>
<code class="code">约束不变= null;<br>

<br>尝试{<br>//设置OCL上下文分类器<br>helper.setContext（EXTLibraryPackage。文字。图书馆）;<br>
    <br>invariant = helper.createInvariant（<br>“Library.allInstances（） - &gt; forAll（b1，b2 | b1 &lt;&gt; b2暗示b1.title &lt;&gt; b2.title）”）;<br>} catch（ParserException e）{<br>//记录解析失败<br>通信System.err.println（e.getLocalizedMessage（））;<br>}<br>

</code>
</p>
</div>
<p></p>
<p>解析约束与解析查询表达式不同，因为它们具有解析器检查的其他格式良好规则。例如，不变约束必须是布尔值，属性派生约束必须符合属性的类型，并且诸如@pre和<code class="code">oclIsNew()</code>类的构造只能用于操作条件后约束。
				</p>
</div>
<div class="section" title="评估OCL表达式和约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="EvaluatingOCLExpressionsandConstraints"></a>评估OCL表达式和约束</h3>
</div>
</div>
</div>
<p>比解析OCL表达式或约束更有趣的是在某个对象上进行评估。<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Query.html" target="_new"><code class="code">Query</code></a>接口提供了两种评估表达式的方法。查询由<code class="code">OCL</code>类上的工厂方法构造。
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Query.html#evaluate(org.eclipse.emf.ecore.EObject)" target="_new">
								<code class="code">对象评估（对象）</code>
							</a> 
						
</p>
</li>
</ul>
</div>
<p>计算指定对象上的表达式，返回结果。调用者应该知道结果类型，它可以是原始类型， <code class="code">EObject</code>或集合。此方法的变体用于评估多个对象上的查询，而根本没有任何对象（对于不需要“自我”上下文的查询）。
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/Query.html#check(org.eclipse.emf.ecore.EObject)" target="_new">
								<code class="code">布尔值（对象）</code>
							</a> 
						
</p>
</li>
</ul>
</div>
<p>此方法计算一种称为<span class="emphasis"><em>约束</em></span>的特殊OCL表达式。通过使用布尔值将约束与其他OCL查询区分开来;因此，它们可用于实现不变或前/后条件约束。存在用于检查多个对象以及用于选择/拒绝满足约束的列表的元素的变体。
				</p>
<p>为了支持OCL类型的<code class="code">allInstances()</code>操作， <code class="code">OCL</code> API提供了</p>
<p>
					
<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/OCL.html#setExtentMap(java.util.Map)" target="_new">
						<code class="code">setExtentMap（Map &lt;CLS ,?扩展Set &lt;？extends E&gt;&gt; extentMap)</code></a>方法。这将类（在Ecore绑定中， <code class="code">EClass</code> es）的映射分配给它们的实例集。默认情况下， <code class="code">OCL</code>提供动态映射，根据<code class="code">Resource</code>的内容按需计算扩展区。可以在<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/opposites/ExtentMap.html" target="_new"><code class="code">org.eclipse.ocl.ecore.opposites.找到替代范围映射<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/opposites/ExtentMap.html" target="_new"><code class="code">org.eclipse.ocl.ecore.opposites.ExtentMap</code></a> 。我们将在评估查询表达式时使用自定义范围映射，该查询表达式查找与指定书籍具有相同标题的书籍：</p>
<div class="literallayout">
<p>
<code class="code">//创建一个范围图<br>地图&lt;EClass，Set &lt;？扩展EObject &gt;&gt; extents = new HashMap &lt;EClass，Set &lt;？扩展EObject &gt;&gt;（）;<br>设置&lt;Book&gt; books = new HashSet &lt;Book&gt;（）;<br>extents.put（EXTLibraryPackage。文字。书，书）;<br>

<br>//告诉OCL环境我们的分类器范围是什么<br>ocl.setExtentMap（跨越）;<br>

<br>库库= EXTLibraryFactory.eINSTANCE.createLibrary（）;<br>

<br>预订myBook = EXTLibraryFactory.eINSTANCE.createBook（）;<br>myBook.setTitle（“David Copperfield”）;<br>books.add（myBook）;<br>

<br>//这本书在我们的图书馆<br>library.add（myBook）;<br>

<br>作家狄更斯= EXTLibraryFactory.eINSTANCE.createWriter（）;<br>dickens.setName（“查尔斯狄更斯”）;<br>

<br>预订aBook = EXTLibraryFactory.eINSTANCE.createBook（）;<br>aBook.setTitle（“匹克威克论文”）;<br>aBook.setCategory（BookCategory。MYSTERY_LITERAL）;<br>books.add（ABOOK）;<br>aBook = EXTLibraryFactory.eINSTANCE.createBook（）;<br>aBook.setTitle（“David Copperfield”）;<br>aBook.setCategory（BookCategory。BIOGRAPHY_LITERAL）; //当然不是！<br>books.add（ABOOK）;<br>aBook = EXTLibraryFactory.eINSTANCE.createBook（）;<br>aBook.setTitle（“Nicholas Nickleby”）;<br>aBook.setCategory（BookCategory。BIOGRAPHY_LITERAL）; // 并不是的<br>books.add（ABOOK）;<br>

<br>dickens.addAll（书籍）; //狄更斯写了这些书<br>library.addAll（书籍）; //他们都在我们的图书馆里<br>

<br>//使用之前解析的查询表达式来创建查询<br>查询&lt;EClassifier，EClass，EObject&gt; eval = ocl.createQuery（query）;<br>

<br>集&lt;？&gt; result =（收藏&lt;？&gt;）eval.evaluate（狄更斯）;<br>的System.out.println（结果）;<br>

</code>
</p>
</div>
<p></p>
<p>相同的<code class="code">Query</code> API用于检查约束。使用上面的<code class="code">library</code>和<code class="code">extents</code>映射以及先前解析的约束：</p>
<div class="literallayout">
<p>
<code class="code">eval = ocl.createQuery（约束）;<br>

<br>boolean ok = eval.check（library）;<br>

<br>的System.out.println（OK）;<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="实施内容辅助">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ImplementingContentAssist"></a>实施内容辅助</h3>
</div>
</div>
</div>
<p><code class="code">OCLHelper</code>接口提供了一种操作，以抽象形式计算内容辅助提议，如<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/Choice.html" target="_new"><code class="code">Choice</code></a> 。然后，应用程序的UI可以将这些转换为JFace的<code class="code">ICompletionProposal</code>类型。
				</p>
<p>获取完成选择包括向<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html#getSyntaxHelp(org.eclipse.ocl.helper.ConstraintKind" target="_new"><code class="code">OCLHelper::getSyntaxHelp(ConstraintKind, String)</code></a> ，java.lang提供部分OCL表达式（直到UI编辑器中的光标位置<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/helper/OCLHelper.html#getSyntaxHelp(org.eclipse.ocl.helper.ConstraintKind" target="_new"><code class="code">OCLHelper::getSyntaxHelp(ConstraintKind, String)</code></a> 。String）方法。此方法需要<code class="code">ConstraintKind</code>枚举，指示要解析的约束类型（某些OCL构造在可以使用它们的约束类型中受到限制）。
				</p>
<div class="literallayout">
<p>
<code class="code">helper.setContext（EXTLibraryPackage。文字。书）;<br>

<br>List &lt;Choice&gt; choices = helper.getSyntaxHelp（<br>ConstraintKind。不变的，<br>“Book.allInstances（） - &gt;不包括（个体）。”）;<br>

<br>for（选择下一个：选择）{<br>switch（next.getKind（））{<br>案例操作：<br>案例信号：<br>//描述已经完成<br>的System.out.println（next.getDescription（））;<br>案件财产：<br>案例ENUMERATION_LITERAL：<br>案例变量：<br>System.out.println（next.getName（）+“：”+ next.getDescription（）;<br>打破;<br>默认：<br>的System.out.println（next.getName（））;<br>打破;<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
<p>输出示例如下：</p>
<div class="literallayout">
<p>
<code class="code">作者：作家<br>title：字符串<br>oclIsKindOf（typespec：OclType）<br>oclAsType（typespec：OclType）：T<br>...<br>

</code>
</p>
</div>
<p></p>
<p>这些选择还提供了它们所代表的模型元素，更复杂的应用程序可以从中构建适当的JFace完成，包括上下文信息，文档等。</p>
</div>
<div class="section" title="使用AST">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="WorkingwiththeAST"></a>使用AST</h3>
</div>
</div>
</div>
<p>OCL Interpreter使用EMF的Ecore对OCL语言进行建模，支持Java风格的泛型类型。这个用于Ecore和UML的通用抽象语法模型的绑定将这些元模型的构造替换为泛型类型参数，插入OCL词汇表的“分类器”，“操作”，“约束”等定义。然后，这些绑定支持Ecore和UML模型中的持久性或作为辅助。</p>
<p>为了处理从OCL文本解析的抽象语法树（AST），API提供了一个<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/utilities/Visitor.html" target="_new"><code class="code">Visitor</code></a>接口。通过实现此接口（或扩展建议使用的<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/utilities/AbstractVisitor.html" target="_new"><code class="code">AbstractVisitor</code></a>类），我们可以使用OCL表达式的AST来以某种方式对其进行转换。这正是解释器本身对表达式求值的作用：它只是使用评估访问者来表达。例如，我们可以计算表达式中引用特定属性的次数：</p>
<div class="literallayout">
<p>
<code class="code">helper.setContext（EXTLibraryPackage。文字。书）;<br>

<br>OCLExpression &lt;EClassifier&gt; query = helper.parseQuery（<br>“Book.allInstances（） - &gt; select（b：Book | b &lt;&gt; self和b.title = self.title）”）;<br>

<br>AttributeCounter visitor = new AttributeCounter（<br>EXTLibraryPackage。文字。书名）;<br>

<br>的System.out.println（<br>“访问'Book :: title'属性的次数：”+ query.accept（visitor））;<br>

</code>
</p>
</div>
<p></p>
<p>这样定义了访问者：</p>
<div class="literallayout">
<p>
<code class="code">class AttributeCounter扩展AbstractVisitor &lt;Integer，<br>EClassifier，EOperation，EStructuralFeature，EEnumLiteral，<br>EParameter，EObject，EObject，EObject，Constraint&gt; {<br>private final EAttribute属性;<br>
    <br>AttributeCounter（EAttribute属性）{<br>超级（0）; //将AST访问的结果初始化为零<br>this.attribute = attribute;<br>}<br>
    <br>protected Integer handlePropertyCallExp（PropertyCallExp &lt;EClassifier，EStructuralFeature&gt; callExp，<br>Integer sourceResult，List &lt;Integer&gt; sourceResults）{<br>if（callExp.getReferredProperty（）== attribute）{<br>//算一个<br>结果++;<br>}<br>
        <br>返回结果;<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="序列化">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Serialization"></a>序列化</h3>
</div>
</div>
</div>
<p>因为OCL表达式AST是EMF对象的图形，所以我们可以将它序列化为XMI文件并在以后再次反序列化。为了保存我们的示例表达式，我们重新开始使用一个资源来初始化我们的<code class="code">OCL</code>实例，在该资源中它将持久保存环境并且我们将在其中持久保存解析的表达式。关键在于环境的持久性：OCL通过模板实例化动态定义了各种类。这些包括集合类型，元组类型和消息类型。需要持久化的其他元素是可以在本地环境中定义的附加操作和属性。
				</p>
<div class="literallayout">
<p>
<code class="code">//创建一个资源，用于存储我们解析的OCL表达式和约束<br>资源res = resourceSet.createResource（<br>URI.createPlatformResourceURI（“/ MyProject / myOcl.xmi”，true）;<br>

<br>//初始化一个新的OCL环境，保留在此资源中<br>ocl = OCL.newInstance（EcoreEnvironmentFactory。INSTANCE，res）;<br>

<br>//对于新的OCL环境，创建一个新的帮助器<br>helper = OCL.createOCLHelper（）;<br>

<br>helper.setContext（EXTLibraryPackage。文字。书）;<br>

<br>//尝试一个非常简单的表达式<br>OCLExpression &lt;EClassifier&gt; query = helper.createQuery（“self.title”）;<br>

<br>//将我们的查询存储在此资源中。所有必要的环境都有<br>//已经存储了，所以我们将查询作为第一个资源根插入<br>res.getContents（）。add（0，query）;<br>

<br>res.save（Collections.emptyMap（））;<br>res.unload（）;<br>

</code>
</p>
</div>
<p></p>
<p>加载保存的OCL表达式同样简单：</p>
<div class="literallayout">
<p>
<code class="code">资源res = resourceSet.getResource（<br>URI.createPlatformResourceURI（“/ MyProject / myOcl.xmi”，true），<br>真正;<br>

<br>@SuppressWarnings（ “未登记”）<br>OCLExpression &lt;EClassifier&gt; query =（OCLExpression &lt;EClassifier&gt;）res.getContents（）。get（0）;<br>

<br>System.out.println（ocl.evaluate（myBook，query））;<br>

</code>
</p>
</div>
<p></p>
<p>在上面的代码片段中，我们使用<code class="code">OCL</code>的便捷方法对查询进行一次性评估。查看我们保存的XMI文档的内容，我们看到<code class="code">self</code>变量声明不归查询表达式所有，而是独立的。<code class="code">ExpressionInOCL</code>元类通过提供包含上下文变量声明的属性（包括<code class="code">self</code>和（在操作上下文中）操作参数）来解决此问题。
				</p>
<div class="literallayout">
<p>
<code class="code">&lt;？xml version =“1.0”encoding =“ASCII”？&gt;<br>&lt;xmi：XMI xmi：version =“2.0”xmlns：xmi =“http://www.omg.org/XMI”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xmlns ：ecore =“http://www.eclipse.org/emf/2002/Ecore”xmlns：ocl.ecore =“http://www.eclipse.org/ocl/1.1.0/Ecore”&gt;<br>&lt;ocl.ecore：PropertyCallExp xmi：id =“_ 897fVPfmEduCQ48h829a5g”&gt;<br>&lt;eType xsi：type =“ocl.ecore：PrimitiveType”href =“http://www.eclipse.org/ocl/1.1.0/oclstdlib.ecore#/0/String”/&gt;<br>&lt;source xsi：type =“ocl.ecore：VariableExp”xmi：id =“_ 897fVvfmEduCQ48h829a5g”name =“self”referencedVariable =“_ 897fUvfmEduCQ48h829a5g”&gt;<br>&lt;eType xsi：type =“ecore：EClass”href =“http：///org/eclipse/emf/examples/library/extlibrary.ecore/1.0.0#//Book”/&gt;<br>&lt;/源&gt;<br>&lt;referencedProperty xsi：type =“ecore：EAttribute”href =“http：///org/eclipse/emf/examples/library/extlibrary.ecore/1.0.0#//Book/title”/&gt;<br>&lt;/ocl.ecore:PropertyCallExp&gt;<br>&lt;ocl.ecore：变量xmi：id =“_ 897fUvfmEduCQ48h829a5g”name =“self”&gt;<br>&lt;eType xsi：type =“ecore：EClass”href =“http：///org/eclipse/emf/examples/library/extlibrary.ecore/1.0.0#//Book”/&gt;<br>&lt;/ocl.ecore:Variable&gt;<br>&lt;/ XMI：XMI&gt;<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="摘要">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Summary3"></a>摘要</h3>
</div>
</div>
</div>
<p>为了说明如何使用OCL API，我们</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>经过验证和验证的OCL表达式和约束。</p>
</li>
<li class="listitem">
<p>评估OCL查询表达式和约束。</p>
</li>
<li class="listitem">
<p>获得完成OCL表达式的内容辅助建议。</p>
</li>
<li class="listitem">
<p>使用<span class="emphasis"><em>访问者</em></span>模式转换OCL表达式AST。
						</p>
</li>
<li class="listitem">
<p>将OCL表达式保存到XMI资源或从XMI资源加载。</p>
</li>
</ul>
</div>
</div>
</div>
</body>
</html><html id="0007.language.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content=""></meta>
    <meta name="author" content="Stéphane Bégaudeau"></meta>    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet"></link>
    <link href="../../assets/css/docs.css" rel="stylesheet"></link>
    
    <title>Acceleo</title>
  </head>
  <body dir="ltr">
    <div class="container">
      <section id="project">
        <div class="page-header">
          <h1>Acceleo项目<small>，其中包含所有内容</small></h1>
        </div>
        <p>由于“文件 - &gt;新建 - &gt;项目...”菜单中提供了新的Acceleo项目向导，因此可以创建Acceleo项目。Acceleo项目是一个Java项目和一个Eclipse插件项目，因此Acceleo项目默认包含一个名为“src”的源文件夹和一个名为“bin”的匹配输出文件夹。建议遵循Eclipse插件项目的命名约定来命名您的Acceleo项目（例如：org.eclipse.acceleo.examples.uml2java），源文件的根包应使用此项目名称（例如：org。 eclipse.acceleo.examples.uml2java）。
        </p>
        <p>在Acceleo项目中，用于生成的文件（名为“modules”）应该像Java类一样放在Java包中。此行为是Acceleo向导的默认行为。
        </p>
      </section>
      
      <section id="module">
        <div class="page-header">
          <h1>模块化<small>发电机的文件</small></h1>
        </div>
        <p>Acceleo生成器由几个名为modules的文件组成。模块由元模型的URI参数化，实例化您要从中生成代码的模型。在这里，您可以看到由Ecore元模型的URI参数化的模块。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/]</pre>
        <p>Acceleo模块可以扩展另一个模块，以便访问其公共和受保护元素。Acceleo模块包含两种元素：生成代码的模板和用于封装复杂表达式的查询。Acceleo仅支持单继承。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）扩展了org :: eclipse :: acceleo :: examples :: uml2java :: otherModule /]</pre>
        <p>模块还可以导入其他模块以访问其公共元素。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [import org :: eclipse :: acceleo：examples :: uml2java :: otherModule /]</pre>
        
        <p>建议主要使用“导入”并保持“扩展”以进行动态覆盖，这将在下面详述。
        </p>
        <br>
      </section>
      
      <section id="template">
        <div class="page-header">
          <h1><small>生成代码的</small>模板</h1>
        </div>
        <p>模板是Acceleo中最常用的结构，因为它们用于直接生成代码。您可以使用一个模板查看Acceleo模块的基本签名。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [/ template]</pre>
        <p>正如您所看到的，模板具有可见性（public | protected | private），其范围类似于面向对象编程语言中的可见性。在可见性之后，您可以找到模板的名称及其参数。参数按照此约定“&lt;name&gt;：&lt;type&gt;”声明。建议使用以下约定“a &lt;Type&gt;”命名参数。参数的类型必须是以下之一：</p>
        <ul>
          <li>元模型提供的类型（例如：类，属性，操作...用于UML）</li>
          <li>来自OCL的默认类型，如Boolean，String，Integer，OclAny（所有概念的常见超类型）</li>
        </ul>
        <p>在模板内部，您可以使用两种表达式来生成代码，第一种是在没有任何转换的情况下生成的静态表达式，以及使用模型元素计算生成文本的Acceleo表达式。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）]这是一段静态代码[aParam.name/] [/ template ]</pre>
        <p>在前面的示例中，您可以看到静态代码段和Acceleo表达式，它将使用在执行生成器期间作为参数传递的EClass实例的名称生成一些文本。
        </p>
        <p>模板也可以有一个保护，只有在保护被验证时才能确保模板被执行。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [模板public genMyTemplate（aParam：EClass）？（不是aParam.isAbstract）] [/ template]</pre>
        <p>模板还可以具有将在执行模板的结果上执行的后置条件。例如，您可以轻松修剪模板的执行结果。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）post（trim（））] [/ template]</pre>
        <p>模板还可以让您初始化新变量，以创建更丰富的上下文。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）{aName：String = aParam.name; abstract：Boolean = aParam.isAbstract;}] [/ template]</pre>
        <p>最后，如果此模板来自当前模块扩展的模块，模板也可以覆盖另一个模板。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）扩展org :: eclipse :: acceleo :: examples :: uml2java :: otherModule /] [template public genMyTemplate（aParam：EClass）覆盖myTemplate] [/ template]</pre>
        <p>在Acceleo重写<b>不会</b>以同样的方式表现，这在大多数面向对象编程做（Acceleo是不是面向对象的）。如果模块A导入扩展C的模块B，并且如果模块C定义了模块B中覆盖的模板tC，则模块C还定义了调用tC的模板tC1。如果从模块A我们调用tC1，在Java和大多数面向对象的编程中，这个对tC1的调用会调用模块B中的tC，因为它被覆盖，即使tC1只位于模块C中，我们仍然在上下文中模块B但在Acceleo中，重写机制不提供额外的调度。它只确保如果可以访问两个模板并且如果一个模板覆盖另一个模板，则调用重写模板。重写机制应主要用于动态覆盖（稍后解释）。
        </p>
        
        <br>
        
        <h2>主要模板</h2>
        <p>主模板是代的入口点，其特征在于其主体中存在注释“@main”。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [comment @ main /] [aParam.doSomething（）/] [/模板]</pre>
        <p>此注释的存在将使Acceleo生成Java类，以便使用此模板开始生成。如果需要，Acceleo向导允许您使用主模板创建新模块。如果要将模板“转换”为主模板，只需添加此注释即可。如果删除它，生成的Java类将不再与Acceleo模块同步，因此如果您更改模板的名称并尝试再次使用Java启动程序，它将无法工作。
        </p>
        <p>我们将尝试在与主模板参数所需类型匹配的所有模型元素上启动模板生成，在前一个主模板需要“EClass”实例的示例中，我们将在整体中导航模型查找所有可用的“EClass”以将它们用作参数。虽然功能强大，但这种机制对这代人的表现并没有任何影响。我们建议您使用主模板参数的类型作为模型根元素的类型。在为元模型Ecore定义模块的情况下，我们将使用概念EPackage并转换以下模块中的前一个模块</p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EPackage）] [comment @ main /] [aParam.eAllContents（EClass）.doSomething（ ）/] [/ template]</pre>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>已创建生成的Java启动程序，以便您几乎覆盖其行为的每个部分，因此您可以更改先前解释的机制的所有详细信息。
        </div>
        <p>如果需要，您可以在一个或多个模块中定义多个主模板，即使我们建议仅在模型的根类型上定义一个主模板。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>主要模块应位于“.main”包中</div>
        
        <br>
        
        <h2>生成文件</h2>
        <p>某些模板可以使用“文件块”来生成文件。
        </p>
        <pre>[module randomJavaFile（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genRandomJavaFile（aParam：EPackage）] [file（'myFile.java'，false，'UTF-8' ）] Hello World [/ file] [/ template]</pre>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>只有模板可以创建文件。
        </div>
        <p>文件块包含三个参数：</p>
        <ul>
          <li>一个表达式，返回文件名的字符串</li>
          <li>一个布尔值，指示是否应覆盖现有文件，或者是否应将新生成的内容附加到现有文件的末尾</li>
          <li>文件的编码</li>
        </ul>
        <p>计算文件名的表达式可以是静态字符串（'myFile.txt'），也可以是使用模型元素（aParam.name +'。txt'）的更复杂的表达式，甚至是模板或查询的结果（返回一个字符串）。我们建议使用模板来定义文件的名称，因为您甚至需要从一个文件到另一个文件进行引用，并且能够使用模板来计算为给定对象生成的文件的路径可以提供帮助。
        </p>
        <pre>[module randomJavaFile（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genRandomJavaFile（aParam：EPackage）] [file（aParam.genRandomJavaFilePath（），false，'UTF-8' ）] Hello World [/ file] [/ template] [模板public genRandomJavaFilePath（aParam：EPackage）] src / [aParam.genPackagePath（）/] / [aParam.name.toUpperFirst（）/]。java [/ template]</pre>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>您可以使用前缀轻松地将您的公共模板和查询与您的私有模板和受保护模板分开。在这里，我们经常对公共模板使用前缀“gen”，对公共查询使用“req”。尽量使用最多的私有和受保护的模板和查询来保持API最小化，因为它有助于维护，生成器的发展和性能。
        </div>
        
        <p>文件块的第二个参数是布尔值，用于确定是否应覆盖现有文件。如果设置为false（默认行为），将覆盖现有文件，如果设置为true，则将在现有文件的末尾生成内容。
        </p>
        
        <p>我们<b>强烈</b>建议只有一个模板在给定模块中生成文件，因为我们建议让一个模块生成一种文件。这并不意味着，您应该有一个模块来生成所有Java文件，但是您应该将模块分开以保持域名分离并具有以下内容：</p>
        <ul>
          <li>有机::蚀:: acceleo ::模块::样品::主:: mainModule</li>
          <li>组织::日食:: acceleo ::模块::样品::文件:: userInterfaceJavaFile</li>
          <li>组织::日食:: acceleo ::模块::样品::文件:: databaseAdapterJavaFile</li>
          <li>组织::日食:: acceleo ::模块::样品::文件:: controllerfaceJavaFile</li>
          <li>组织::日食:: acceleo ::模块::样品::文件:: defaultPropertiesFile</li>
          <li>组织::日食:: acceleo ::模块::样品::文件:: adminJsFile</li>
        </ul>
        <p>我们建议您按照此命名约定来生成文件的名称：“&lt;goal&gt; &lt;extension&gt; File”。通过此约定，新手更容易帮助您维护和使用您的生成器，因为很容易弄清楚给定模块生成的内容。
        </p>
        
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>生成文件的模块应位于“.files”包中。如果您需要，请不要犹豫，在内部创建子包。
        </div>
        
        <br>
        
        <h2>结构</h2>
        <p>Acceleo模板可以使用Acceleo表达式来操作模型元素。Acceleo表达式基于OCL语言的超集。为了改进Acceleo生成器的开发，Acceleo模板可以包含多种结构。
        </p>
        
        <br>
        
        <h3>如果</h3>
        <p>Acceleo模板可以使用if块来指定仅在满足给定条件时才应执行的代码块。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [if（aParam.isAbstract）] [elseif（not aParam.isAbstract） ] [else] [/ if] [/ template]</pre>
        
        <h3>对于</h3>
        <p>for块也可用于迭代集合。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [for（anAttribute：EAttribute | aParam.eAllAttributes（））] [anAttribute .name /] [/ for] [/ template]</pre>
        <p>对于块，还可以定义分隔符以在每次迭代之间生成代码以及前缀和后缀。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [for（anAttribute：EAttribute | aParam.eAllAttributes（））before（'前缀'）分隔符（'，'）后（'后缀'）] [anAttribute.name/] [/ for] [/ template]</pre>
        <p>对于块，还定义了名为“i”的变量。该变量是块的迭代器。此变量只能在for块的主体和分隔符表达式中访问。在body表达式中，此变量的值始终为“1”，在after表达式中，该值始终是初始化迭代的表达式的大小。由于此变量表示初始化循环迭代器的集合中元素的索引，因此其值始终为<strong>1</strong> 。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [for（anAttribute：EAttribute | aParam.eAllAttributes（））]名称： [anAttribute.name/]索引：[i /] [/ for] [/ template]</pre>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>只有在转弯前一个转弯时，才会在每次转弯前调用分隔符中的代码。如果在分隔符表达式中使用变量“i”，则“i”的第一个值将为“2”，因为它将在第二个回合开始时调用。它不会在转弯结束时调用，而是在下一次迭代开始时调用。
        </div>
        
        <h3>让</h3>
        <p>let块可以让您在模板中定义变量。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [let anAttribute：EAttribute = aParam.eAllAttributes（） - &gt; first（） ] [anEAttribute.name/] [/ let] [/ template]</pre>
        <p>let块仅在当且仅当表达式的结果（此处为“aParam.eAllAttributes（） - &gt; first（）”可能会影响初始化变量时执行，此处为“anAttribute：EAttribute”。要测试多种可能性，可以使用elselet块</p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [template public genMyTemplate（aParam：EClass）] [let anAttribute：EAttribute = aParam.eAllAttributes（） - &gt; first（） ] [elselet aReference：EReference = aParam.eAllReferences（） - &gt; first（）] [else] [/ let] [/ template]</pre>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong> Acceleo中的let块可以看作是Java代码的等价物“if（x instanceof Type）{Type var =（Type）x; ...}”</div>
        
        <br>
      </section>
      
      <section id="query">
        <div class="page-header">
          <h1>查询<small>封装实用程序表达式</small></h1>
        </div>
        <p>查询用于定义可在生成器中的多个位置快速使用的复杂表达式。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [query reqMyQuery（aParam：EClass）：String = aParam.name/]</pre>
        <p>查询的结果存储在缓存中，这样您可以使用相同的参数多次调用相同的查询，结果将只计算一次。
        </p>
        <div class="alert alert-info">
          <strong>提示和技巧：</strong>在查询中使用类似“eAllContents（OclType）”的“eAllContents”之类的操作可以显着提高性能，而不是在模板中多次使用它，因为这两个操作实际上是在模型中包含的每个元素上导航的。调用这些操作的元素。
        </div>
      </section>
      
      <section id="additional">
        <div class="page-header">
          <h1>其他Concepts <small>元素可以改善您的生成器</small></h1>
        </div>
        <p>Acceleo具有其他机制，如动态覆盖，属性文件甚至是调用Java服务的能力。
        </p>
        
        <h2>动态覆盖</h2>
        <p>Acceleo允许您注册可以动态覆盖现有生成器的生成器，使用此机制，您可以更改已部署的生成器的行为，而无需对此生成器进行任何更改。要动态覆盖模板，请按照以下步骤操作：</p>
        <ul>
          <li>创建一个新的发电机</li>
          <li>将原始生成器添加为MANIFEST.MF的依赖项选项卡中的依赖项</li>
          <li>创建一个从原始生成器扩展模块的新模块</li>
          <li>覆盖其中一个模板</li>
          <li>打开MANIFEST.MF转到扩展选项卡，使用扩展点“org.eclipse.acceleo.engine.dynamic.templates”添加扩展名</li>
          <li>如果您不想使用新生成器中的所有模块，请单击浏览按钮并选择源文件夹（src）或子文件夹</li>
          <li>右键单击标签“org.eclipse.acceleo.engine.dynamic.templates”并添加“生成器”</li>
          <li>在此处输入要动态覆盖的生成器的插件ID（例如：org.eclipse.acceleo.examples.uml2java）</li>
          <li>在包含旧实例和完成的Eclipse实例中部署新生成器</li>
        </ul>
        
        <h2>属性文件</h2>
        <p>属性文件是标准的Java“.properties”文件，可以由Acceleo生成器加载以自定义生成。要在生成器中使用属性文件，必须在Java启动程序的“getProperties（）”方法中引用它，然后使用生成器中的已加载属性。
        </p>
        <p>在方法“getProperties（）”中，您必须返回要使用的属性文件的路径集合。引用属性文件有四种方法：</p>
        <a href="../../assets/img/reference/propertiesFiles.png"><img src="../../assets/img/reference/propertiesFiles.png"></a>
        <ul>
          <li>您只需返回属性文件的名称，例如：“default_0.properties”。有了这个，Acceleo将在生成器中查找名为default_0.properties的任何文件，并从使用此名称找到的第一个文件中加载属性。
          </li>
          <li>您还可以输入生成器中特定属性文件的路径，例如：“/ org/eclipse/acceleo/module/sample/properties/default_1.properties”。使用此路径，Acceleo将在您的生成器的“/ org / eclipse / acceleo / module / sample / properties /”文件夹中查找名为“default_1.properties”的属性文件。
          </li>
          <li>您还可以使用另一个插件中的属性文件的url引用位于另一个Eclipse插件中的属性文件。为此，您需要使用以下约定构造路径：“platform：/ plugin / <plugin name="">/ <path in="" the="" plugin="">”。示例：“platform：/plugin/org.eclipse.module.sample2/org/eclipse/acceleo/module/sample2/default_3.properties”。另一个插件需要在Eclipse中部署，或者它需要是第一个生成器的依赖项。
          </path></plugin></li>
          <li>最后，您还可以在文件系统中使用绝对路径作为属性文件的引用。示例：“C：\ Users \ sbegaudeau \ Desktop \ default_4.properties”。您还可以使用实用程序方法org.eclipse.acceleo.engine.utils。AcceleoEngineUtils＃getPropertiesFilesNearModel用于计算与模型位于同一文件夹中的属性文件的绝对路径。使用此方法，我们可以获得文件default_5.properties的路径。
          </li>
        </ul>
        <p>为了使用位于Eclipse插件中的属性文件（所有Acceleo生成器都是Eclipse插件），您必须确保该文件包含在生成器的构建中，方法是将其放在源文件夹中或将其添加到您在build.properties文件中的构建位于生成器的根目录下。
        </p>
        <p>现在您已了解如何加载属性文件，您需要在生成器中使用它。为此，您可以使用以下四种操作之一：</p>
        <a href="../../assets/img/reference/propertiesFilesUse.png"><img src="../../assets/img/reference/propertiesFilesUse.png"></a>
        <ul>
          <li>“getProperty（'myProperty'）”将使用键“myProperty”返回属性的值。多个属性文件可以具有共享相同键的属性，只有找到的第一个属性文件将使用此方法返回。
          </li>
          <li>“getProperty（'default_1.properties'，'myProperty'）”将使用文件“default_1.properties”中的键“myProperty”返回属性的值。
          </li>
          <li>“getProperty（'myProperty'，Sequence {'my name'}）”将返回属性的值，其中键“myProperty”参数化为序列中的值。
          </li>
          <li>“getProperty（'default_3.properties'，'myProperty'，Sequence {'my name'}）”将返回属性的值，其中键“myProperty”参数化为文件“default_3.properties”中序列中的值。
          </li>
        </ul>
        <p>您可以在以下屏幕截图中看到生成的结果。
        </p>
        <a href="../../assets/img/reference/propertiesFilesResult.png"><img src="../../assets/img/reference/propertiesFilesResult.png"></a>
        
        <br>
        <br>
        
        <h2>Java服务</h2>
        <p>您可以从模板或查询中调用Java服务，但建议从查询中调用它们。以下是从查询中调用Java服务的示例。
        </p>
        <pre>[module moduleName（'http：//www.eclipse.org/emf/2002/Ecore'）/] [query reqMyQuery（aParam：EClass）：String = invoke（'org.eclipse.acceleo.examples.uml2java。MyJavaClass'，'myMethod（org.eclipse.emf.ecore。EClass）'，序列{aParam}）/]</pre>
        <p>您可以看到我们将使用参数“aParam”从类“MyJavaClass”调用操作“myMethod”。
        </p>
        <p>如果Java服务正在返回集合，则查询的返回类型应与集合的返回类型匹配。我们建议在Java服务返回ArrayList的情况下<type>，应该使用Sequence（Type），如果返回LinkedHashSet <type>，则应该使用OrderedSet（Type）。
        </type></type></p>
        
        <br>
        <br>
      </section>
      
      <footer class="footer">
        <p>这些指南中的材料是版权所有（c）2008,2012 Obeo。该材料可在Eclipse Public License v1.0下获得</p>
      </footer>
    </div>
  </body>
</html><html id="2896.org_eclipse_ui_handlers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>处理程序</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">处理程序</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.handlers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>处理程序扩展点是Eclipse 3.0中定义的实验<code>handlerSubmission</code>元素的详细说明。处理程序是特定时间点的命令行为。命令可以有零个或多个与之关联的处理程序。但是，在任何一个时间点，命令都将没有活动的处理程序或一个活动的处理程序。活动处理程序是当前负责执行命令行为的处理程序。这与动作处理程序和可重定向动作的概念非常相似。
</p>
<p>处理程序扩展点允许插件开发人员指定在某些条件下应该变为活动和/或启用的处理程序。如果处理程序处于非活动状态，则没有命令会将其行为委派给处理程序。如果禁用处理程序，则不会要求处理程序执行;执行处理程序被阻止。使用3.0期间添加的表达式语言工具定义条件。它们使用<code>activeWhen</code>和<code>enabledWhen</code>子句表示。
</p>
<p>工作台提供了这些表达式可以依赖的一些变量。在activeWhen和enabled中有效的变量可以在<code>org.eclipse.ui.找到表达式<code>org.eclipse.ui.ISources</code> 。变量的类型由<code>org.eclipse.ui.确定<code>org.eclipse.ui.提供它们的ISourceProvider</code> 。
</p>
<p>指定无条件的处理程序是默认处理程序。如果没有其他处理程序满足其所有条件，则默认处理程序仅处于活动状态。如果两个处理程序仍然满足条件，则比较条件。我们的想法是选择条件更具体或更局部的处理程序。为此，请查看条件引用的变量。引用最具体变量“胜利”的条件。<code>org.eclipse.ui.建议了特异性的顺序（从最不具体到最具体） <code>org.eclipse.ui.ISources</code> 。
</p>
<p>如果仍然无法解决冲突，则没有处理程序处于活动状态。如果启用了特定的跟踪选项，则会在日志中生成一条消息。如果有两个默认处理程序，也会发生冲突。插件开发人员和集成测试人员有责任确保不会发生这种情况。
</p>
<p>这些条件用于避免不必要的插件加载。这些处理程序定义包含在代理中。对于加载其底层处理程序的代理，必须发生两件事：必须满足代理的条件才能使其变为活动状态，并且必须要求命令执行必须委托的操作（例如，execute（），isEnabled（ ））。
</p><p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.handler">处理程序</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.handler">处理程序</a> （ <a href="#e.activeWhen">activeWhen</a> ?, <a href="#e.class">class</a> ?, <a href="#e.enabledWhen">enableWhen</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST处理程序</p>
<p class="code SchemaDtdAttlist">commandId IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>将命令与处理程序实现相关联。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>commandId</b> -<p>与此处理程序实现关联的命令的id。</p></li>
<li><b>课程</b> -<p>处理<code>org.eclipse.core.commands.的处理程序类<code>org.eclipse.core.commands.IHandler</code>或扩展<code>org.eclipse.core.commands.AbstractHandler</code> 。</p></li>
<li><b>helpContextId</b> -<p>与此特定处理程序相关的帮助上下文的标识符。虽然命令可以提供命令行为的一般描述，但有时处理程序可以提供更具体的实现帮助。
</p>
<p><em>自：3.2</em></p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.activeWhen">activeWhen</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">或</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>包含<code>IHandlerService</code>用于确定此处理程序何时处于活动状态的核心表达式。</p></div>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enabledWhen">enabledWhen</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">或</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>包含工作台处理程序代理使用的核心表达式，以确定何时启用此处理程序而不加载它。</p></div>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>在使用命名参数或多个参数创建<code>IExecutableExtension</code>使用。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>课程</b> -<p>处理<code>org.eclipse.core.commands.的处理程序类<code>org.eclipse.core.commands.IHandler</code>或扩展<code>org.eclipse.core.commands.AbstractHandler</code> 。</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p><code>IExecutableExtension</code>的参数。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>名字</b> -<p>参数名称。</p></li>
<li><b>价值</b> -<p>参数值。</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>在activeWhen和enabled中有效的变量可以在<code>org.eclipse.ui.找到表达式<code>org.eclipse.ui.ISources</code> 。变量的类型由<code>org.eclipse.ui.确定<code>org.eclipse.ui.提供它们的ISourceProvider</code> 。
</p>
<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.handlers”</span> <span class="code SchemaTag">&gt; &lt;handler commandId =</span> <span class="code SchemaCstring">“commandId”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse.compare。命令“</span> <span class="code SchemaTag">&gt; &lt;activeWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”selection“</span> <span class="code SchemaTag">&gt; &lt;count value =</span> <span class="code SchemaCstring">”1“</span> <span class="code SchemaTag">/&gt; &lt;iterate operator =</span> <span class="code SchemaCstring">”and“</span> <span class="code SchemaTag">&gt; &lt;adapt type =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;/ activeWhen&gt; &lt;/ handler&gt; &lt;handler commandId =</span> <span class="code SchemaCstring">”other.commandId“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”org.eclipse.ui。TalkToMe“</span> <span class="code SchemaTag">&gt; &lt;activeWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”activePartId“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.ui.views。SampleView“</span> <span class="code SchemaTag">/&gt; &lt;/ with&gt; &lt;/ activeWhen&gt; &lt;/ handler&gt; &lt;/ extension&gt;</span></pre>
<p>为了进一步避免插件加载，可以指定何时启用处理程序。如果代理尚未加载处理程序，则仅使用表达式语法来确定是否启用了处理程序。如果代理已加载处理程序，则首先查询表达式语法。如果表达式语法的计算结果为true，则会询问处理程序是否已启用。（这是表达式语法和处理程序启用状态之间的短路布尔“和”操作。）
</p>
<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.handlers”</span> <span class="code SchemaTag">&gt; &lt;handler commandId =</span> <span class="code SchemaCstring">“commandId”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“org.eclipse。处理程序“</span> <span class="code SchemaTag">&gt; &lt;enabledWhen&gt; &lt;with variable =</span> <span class="code SchemaCstring">”activeContexts“</span> <span class="code SchemaTag">&gt; &lt;iterator operator =</span> <span class="code SchemaCstring">”或“</span> <span class="code SchemaTag">&gt; &lt;equals value =</span> <span class="code SchemaCstring">”org.eclipse.ui.contexts.window“</span> <span class="code SchemaTag">/&gt; &lt;/ iterator&gt; &lt;/ with&gt; &lt;/ enabledWhen &gt; &lt;/ handler&gt; &lt;/ extension&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>所有处理程序都实现了<code>org.eclipse.core.commands.IHandler</code> ，可以使用<code>org.eclipse.core.commands.AbstractHandler</code>作为基类。在工作台中，可以使用<code>org.eclipse.ui.handlers.激活和停用处理程序<code>org.eclipse.ui.handlers.IHandlerService</code>接口。可以从支持的工作台对象（例如<code>IWorkbench</code>本身，工作台窗口或部件站点）检索此接口。要检索服务，您可以像<code>IWorkbench.getService(IHandlerService.class)</code>一样进行调用。
</p>
<p>还可以使用工作台中的遗留代码激活和取消激活处理程序。这可以通过下面显示的遗留机制来完成。此机制对使用操作提供菜单或工具栏的客户非常有用。这是不推荐使用的，不推荐使用。
</p>
<pre class="Example"><span class="code SchemaTag">IWorkbenchPartSite mySite;执法我的行动; myAction.setActionDefinitionId（commandId）; IKeyBindingService service = mySite.getKeyBindingService（）; service.registerAction（myAction）;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2007 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3444.custom_composites.html" dir="ltr"></html><html dir="ltr">
<head>
<title>定制复合材料和面板</title>
<meta content="text/html; charset=windows-1252" http-equiv="Content-Type"></meta>
<link href="../../book.css" rel="stylesheet" type="text/css"></link>
<style></style>
</head>
<body bgcolor="#FFFFFF" dir="ltr">
    <h1>定制复合材料和面板</h1>
	<table border="0" cellpadding="5" cellspacing="0" id="table1" width="800">
		<tr>
			<td valign="top">该工具支持创建自定义<b>复合材料</b> （SWT）和<b>JPanels</b> （Swing）。这是创建自定义可重用组件的理想方法。支持以下功能：<ul>
				<li>在另一个窗口中嵌入任何<b>JPanel</b>子类的<b>复合</b></li>
				<li><b>Composite</b> / <b>JPanel</b>中定义的所有小部件在它们使用的窗口中都可见</li>
				<li>访问通过公共访问器公开的任何小部件</li>
				<li>访问公开的自定义属性</li>
				<li>暴露的小部件出现在树中，带有“暴露” <img src="../userinterface/images/exposed_decorator.gif" alt="" width="6" height="6">装饰</li>
			</ul></td>
		</tr>
		<tr>
			<td>
			<p>以下是随后在窗口中使用的自定义<b>Composites</b>的示例。<b>Composite</b>使用<b>GridLayout</b>并具有两个<b>Labels</b> ，两个<b>Text</b>小部件，一个<b>Button</b>和一个内部<b>Composite</b>小部件。</p>
			<p>
			<img border="0" src="images/custom_composite.png" align="top"></p>
			<p>使用<b><a href="../userinterface/context_menu.html">Expose Component</a></b>命令将内部<b>Composite</b>窗口小部件公开为公共组件。
			<b><a href="../userinterface/context_menu.html">Expose Component</a></b>将<b><a href="../userinterface/context_menu.html">组件</a></b>转换为字段并为其添加公共访问器。最后，使用<b><a href="../userinterface/property_pane_context_menu.html">Expose Property</a></b>命令将第一个<b>Text</b>小部件的<b>background</b> color属性和<b>Button</b>的<b>text</b>属性公开为<b>Composite</b>的公共属性。
			<b><a href="../userinterface/property_pane_context_menu.html">Expose Property</a></b>添加了一对访问器，用于获取和设置目标窗口小部件的所需属性。</p>
			<p>
			<img border="0" src="images/visual_inheritance_expose_component_menu.png" align="top"> 
			<img border="0" src="images/visual_inheritance_expose_property_menu.png" align="top"></p>
			<blockquote><font size="2" color="#7f0055"><b>
				<dl>
					<dd><font face="Courier">进口</font></dd></dl></b></font> <font size="2" face="Courier">org.eclipse.swt。SWT;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.graphics。颜色;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.layout。*;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">是org.eclipse.swt.widgets。*;</font> <font size="2" color="#7f0055"><b>
					<font face="Courier"><br> </font><dd>
					<font face="Courier">上市</font></dd></b></font> <font face="Courier"><font size="2">
					</font> <font size="2" color="#7f0055"><b>class</b></font> <font size="2">CustomComposite</font> <font size="2" color="#7f0055"><b>扩展</b></font></font> <font size="2"><font face="Courier">Composite {</font><dl>
						<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">按钮</font> <font size="2" color="#0000c0">browseButton</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">复合</font> <font size="2" color="#0000c0">材料</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">secondField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">firstField</font></font> <font size="2"><font face="Courier">;<br> </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>public</b></font> <font size="2">CustomComposite（Composite parent，</font> <font size="2" color="#7f0055"><b>int</b></font></font> <font size="2"><font face="Courier">style）{</font><dl>
							<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>超级</b></font> <font size="2"><font face="Courier">（父母，风格）;</font><dd><font face="Courier">createContents（）;</font></dd>
						
						<dd><font face="Courier">}<br> </font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>上市</b></font> <font size="2">
						</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">createContents（）{</font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>final</b></font> <font size="2">GridLayout gridLayout =</font> <font size="2" color="#7f0055"><b>new</b></font></font> <font size="2"><font face="Courier">GridLayout（）;</font><dd><font face="Courier">网格布局。</font></dd></font> <font size="2" color="#0000c0" face="Courier">numColumns</font> <font size="2"><font face="Courier">= 3;</font><dd><font face="Courier">的setLayout（GridLayout的）;<br> </font></dd>
							<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签firstFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">firstFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第一场”</font> <font size="2"><font face="Courier">）;<br> </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">firstField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_firstField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">firstField</font> <font size="2"><font face="Courier">.setLayoutData（gd_firstField）;<br> </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">按钮（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton</font> <font size="2"><font size="2"><font size="2">.setLayoutData（。</font></font></font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2" color="#0000c0"><i><font size="2">FILL，SWT</font></i></font> <font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，FALSE，FALSE））;</font></b></font></font></b></font></font></i></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton .setText</font> <font size="2">（</font> <font size="2" color="#2a00ff">“Browse ...”</font></font> <font size="2"><font face="Courier">）;<br> </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签secondFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">secondFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第二场”</font> <font size="2"><font face="Courier">）;<br> </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">secondField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_secondField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE，2，1）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">secondField</font> <font size="2"><font face="Courier">.setLayoutData（gd_secondField）;<br> </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">复合</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">复合物（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">复合</font> <font size="2">.setLayoutData（</font> <font size="2"><font size="2" color="#7f0055"><b>新</b></font>的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">FILL，FALSE，TRUE，3，1））;</font></b></font></font></b></font></font></i></font></font></font><dd><font face="Courier">}<br> </font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">Composite getComposite（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">复合材料</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br> </span></font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">String getBrowseButtonText（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">browseButton</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.getText（）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br> </span></font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">上市</span></b></font> <font size="2"><span style="background-color:#ffff99">
						</span></font> <font size="2" color="#7f0055"><b><span style="background-color:#ffff99">void</span></b></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">setBrowseButtonText（String text）{</span></font><dl>
							<dd></dd></dl></font> <font size="2" color="#0000c0" face="Courier"><span style="background-color:#ffff99">browseButton .setText</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">（text）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br> </span></font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">Color getFirstFieldBackground（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">firstField</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.getBackground（）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br> </span></font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">上市</span></b></font> <font size="2"><span style="background-color:#ffff99">
						</span></font> <font size="2" color="#7f0055"><b><span style="background-color:#ffff99">void</span></b></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">setFirstFieldBackground（Color background）{</span></font><dl>
							<dd></dd></dl></font> <font size="2" color="#0000c0" face="Courier"><span style="background-color:#ffff99">firstField</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.setBackground（background）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}</span></font></dd>
					
					<dd><font face="Courier">}</font></dd>
				</font>
			</blockquote>
			<p>该窗口使用<b>FillLayout</b>并嵌入自定义<b>Composite</b> 。该窗口通过在自定义<b>Composite中</b>公开的访问器设置内部<b>Composite的</b>布局管理器，然后向内部<b>Composite</b>添加几个新的窗口小部件。最后，它使用嵌入式Composite中定义的访问器覆盖第一个<b>Text</b>小部件的<b>背景</b>颜色和<b>Button</b>的文本设置。<br><br>请注意，从自定义<b>复合</b>暴露的内部<b>复合材料</b>显示了组件树用小<img src="../userinterface/images/exposed_decorator.gif" alt="" width="6" height="6">叠加图标。嵌入式<b>Composite中</b>定义的其他小部件不会显示在树中，因为它们是该<b>Composite的</b>私有小部件。</p>
			<p>
			<img border="0" src="images/custom_composite_used.png" align="top"></p>
			<font size="2" color="#7f0055"><b>
			<dl>
				<dd><font face="Courier">进口</font></dd></dl></b></font> <font size="2" face="Courier">org.eclipse.swt。SWT;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">是org.eclipse.swt.widgets。*;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.layout。*;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">com.swtdesigner。SWTResourceManager;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.layout。网格布局;<br>
 
				</font><font size="2" color="#7f0055"><b>
				<dd><font face="Courier">上市</font></dd></b></font> <font face="Courier"><font size="2"> </font> <font size="2" color="#7f0055"><b>class</b></font></font> <font size="2"><font face="Courier">WindowUsingComposite {</font><dl>
					<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>受保护的</b></font> <font size="2">Shell</font> <font size="2" color="#0000c0">shell</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">清单</font> <font size="2" color="#0000c0">列表</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">thirdField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">fourthField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>上市</b></font> <font size="2">
					</font> <font size="2" color="#7f0055"><b>静态的</b></font> <font size="2">
					</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">main（String [] args）{</font><dl>
						<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>尝试</b></font> <font size="2"><font face="Courier">{</font><dl>
							<dd><font face="Courier">WindowUsingComposite window =</font> </dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>新的</b></font> <font size="2"><font face="Courier">WindowUsingComposite（）;</font><dd><font face="Courier">window.open（）;</font></dd>
						
						
						<dd><font face="Courier">}</font> </dd></font> <font size="2" color="#7f0055" face="Courier"><b>catch</b></font> <font size="2"><font face="Courier">（例外e）{</font><dl>
							<dd><font face="Courier">e.printStackTrace（）;</font></dd>
						</dl>
						
						<dd><font face="Courier">}</font></dd>
					
					
					<dd><font face="Courier">}</font></dd>
					<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>上市</b></font> <font size="2">
					</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">open（）{</font><dl>
						<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>final</b></font> <font size="2"><font face="Courier">显示=显示。 <i>getDefault</i> （）;</font><dd><font face="Courier">createContents（）;</font></dd>
						<dd></dd></font> <font size="2" color="#0000c0" face="Courier">shell</font> <font size="2"><font face="Courier">.open（）;</font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">shell</font> <font size="2"><font face="Courier">.layout（）;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>而</b></font> <font size="2">（！</font><font size="2" color="#0000c0">shell</font></font> <font size="2"><font face="Courier">.isDisposed（））{</font><dl>
							<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>如果</b></font> <font size="2"><font face="Courier">（！display.readAndDispatch（））{</font><dl>
								<dd><font face="Courier">display.sleep（）;</font></dd>
							</dl>
							
							<dd><font face="Courier">}</font></dd>
						
						
						<dd><font face="Courier">}</font></dd>
					
					
					<dd><font face="Courier">}</font></dd>
					<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>保护</b></font> <font size="2">
					</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">createContents（）{</font><dl>
						<dd></dd></dl></font> <font face="Courier"><font size="2" color="#0000c0">shell</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>new</b></font> <font size="2">Shell（</font> <font size="2" color="#0000c0"><i>SWT.SHELL_TRIM</i></font></font> <font size="2"><font face="Courier">）;</font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">壳</font> <font size="2">.setLayout（</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">FillLayout的（SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">HORIZONTAL）。）;</font></i></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">shell</font> <font size="2"><font face="Courier">.setSize（450,384）;</font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">shell</font> <font size="2">.setText（</font> <font size="2" color="#2a00ff">“Window Using Composite”</font></font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd><font face="Courier">CustomComposite customComposite =</font> </dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>新</b></font> <font size="2">CustomComposite（</font> <font size="2" color="#0000c0">壳</font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</i></font></font></font><br>
 </font>
						<dd><font face="Courier"><span style="background-color:#ffff99">customComposite.setBrowseButtonText（</span></font></dd></font> <font size="2" color="#2a00ff" face="Courier"><span style="background-color:#ffff99">“找......”</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">customComposite.setFirstFieldBackground（SWTResourceManager。 <i>的getColor（SWT。</i></span></font></dd></font> <font size="2" color="#0000c0" face="Courier"><i><span style="background-color:#ffff99">COLOR_YELLOW</span></i></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">））;</span><br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>final</b></font> <font size="2">GridLayout gridLayout =</font> <font size="2" color="#7f0055"><b>new</b></font></font> <font size="2"><font face="Courier">GridLayout（）;</font><dd><font face="Courier">网格布局。</font></dd></font> <font size="2" color="#0000c0" face="Courier">numColumns</font> <font size="2"><font face="Courier">= 2;</font><dd><font face="Courier"><span style="background-color:#ffff99">。customComposite.getComposite（）的setLayout（GridLayout的）;<br>
 </span></font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签thirdFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（customComposite.getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">thirdFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第三场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">thirdField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（customComposite.getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_thirdField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">thirdField</font> <font size="2"><font face="Courier">.setLayoutData（gd_thirdField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签fourthFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（customComposite.getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">fourthFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第四场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">fourthField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（customComposite.getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_fourthField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">fourthField</font> <font size="2"><font face="Courier">.setLayoutData（gd_fourthField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">名单</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">名单（customComposite.getComposite（），SWT</font> <font size="2" color="#0000c0"><i>的边界</i></font> <font size="2"><font size="2"><font face="Courier">。）;</font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">list</font> <font size="2">.setItems（</font> <font size="2" color="#7f0055"><b>new</b></font> <font size="2">String [] {</font> <font size="2" color="#2a00ff">“First Item”</font> <font size="2">，</font> <font size="2" color="#2a00ff">“Second Item”</font></font> <font size="2"><font face="Courier">}）;</font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">列出</font> <font size="2">.setLayoutData（</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">FILL，FALSE，TRUE，2，1））;</font></b></font></font></b></font></font></i></font></font></font></font><dd><font face="Courier">}</font></dd>
				
				
				<dd><font face="Courier">}</font></dd>
			
			</font></td>
		</tr>
	</table>
	<p class="pnoall"> </p>
	<p class="pnoall"> </p>
          	<p class="pnoall">
			 </p>
			<p class="pnoall"> </p>
			<p class="pnoall">
	 </p>
			<p class="pnoall"> </p>
			<p class="pnoall">
			 
          </p></body>
</html><html id="3689.ix01.html" dir="ltr"></html><html dir="ltr">
<head>
<title>指数</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="Xpand Documentation"></link>
<link rel="up" href="index.html" title="Xpand Documentation"></link>
<link rel="prev" href="xsd_tutorial_execute_workflow.html" title="Step 6: Execute Workflow aka Generate Code"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"></h1>
<div class="index" title="指数">
<div class="titlepage">
<div>
<div>
<h2 class="title">
<a name="N1324A"></a>指数</h2>
</div>
</div>
</div>
<div class="index">
<div class="indexdiv">
<h3>符号</h3>
<dl>
<dt>.chk， <a class="indexterm" href="Check_language.html#Check_language_description">检查语言的描述</a>
</dt>
<dt>.xpt， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_template_files_and_ecoding">模板文件和编码</a>
</dt>
<dt>* .ext， <a class="indexterm" href="Xtend_language.html#N10DE7">Xtend文件</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>一个</h3>
<dl>
<dt><a class="indexterm" href="Xtend_language.html#N1107E">Xtend中的</a>建议， <a class="indexterm" href="Xtend_language.html#N1107E">面向方面编程</a>
</dt>
<dt>AdviceContext， <a class="indexterm" href="Xtend_language.html#N110D9">Proceeding</a>
</dt>
<dt><a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_aspect-oriented_programming_in_xpand">XOP中的</a> AOP， <a class="indexterm" href="Xtend_language.html#N1107E">面向</a> <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_aspect-oriented_programming_in_xpand">方面编程，Xpand中面向方面编程</a>
</dt>
<dd>
<dl>
<dt>加入点， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_join_point_and_cut_syntax">加入点和点切割语法</a>
</dt>
<dt>点剪切， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_join_point_and_cut_syntax">连接点和点剪切语法</a>
</dt>
<dt>工作流程， <a class="indexterm" href="xpand_reference_introduction.html#aop_template_example_workflow_file">工作流程文件</a>
</dt>
<dt>Xpand， <a class="indexterm" href="xpand_reference_introduction.html#aop_template_introduction">在Xpand中使用面向方面编程的示例</a>
</dt>
</dl>
</dd>
<dt>另外， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_aspect-oriented_programming_in_xpand">Xpand中的面向方面编程</a> ， <a class="indexterm" href="xpand_reference_introduction.html#aop_template_example_templates">模板</a> ， <a class="indexterm" href="xpand_reference_introduction.html#aop_template_more_ao">更多面向方面</a>
</dt>
<dt>面向<a class="indexterm" href="Xtend_language.html#N1107E">方面编程，Xtend中面向方面编程</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>乙</h3>
<dl>
<dt>布尔类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_simple">简单类型（数据类型）</a>
</dt>
<dt>内置式， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes">内置式</a>
</dt>
<dd>
<dl>
<dt>集合类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_collections">集合类型</a>
</dt>
<dt>对象， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_object">对象</a> ， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_builtin_object">对象</a>
</dt>
<dt>简单类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_simple">简单类型（数据类型）</a>
</dt>
<dt>虚空， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_void">虚空</a> ， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_builtin_object">物体</a>
</dt>
</dl>
</dd>
</dl>
</div>
<div class="indexdiv">
<h3>C</h3>
<dl>
<dt>缓存， <a class="indexterm" href="Xtend_language.html#N10EC5">缓存扩展</a>
</dt>
<dt>盒式磁带， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_aspect-oriented_programming_in_xpand">Xpand中面向方面的编程</a>
</dt>
<dt>铸造， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_casting">铸造</a>
</dt>
<dt>CEND， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">PROTECT</a>
</dt>
<dt>校验</dt>
<dd>
<dl>
<dt>文件扩展名， <a class="indexterm" href="Check_language.html#Check_language_description">Check语言的描述</a>
</dt>
<dt>语言，使用<a class="indexterm" href="emf_tutorial_checking_contraints_with_check.html">检查</a>语言<a class="indexterm" href="emf_tutorial_checking_contraints_with_check.html">检查约束，检查语言的</a> <a class="indexterm" href="Check_language.html#Check_language_description">描述</a>
</dt>
</dl>
</dd>
<dt>Classpath， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_extension">EXTENSION</a>
</dt>
<dt>收集，收集， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_collect">收集的</a> <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_collect_shorthand">速记（以及更多）</a>
</dt>
<dt>集合， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_collections">集合类型</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_foreach">FOREACH</a>
</dt>
<dt>集合类型， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_collection_typenames">集合类型名称</a>
</dt>
<dt>集合类型， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_for_vs_foreach">FOR与FOREACH</a>
</dt>
<dt>约束， <a class="indexterm" href="emf_tutorial_checking_contraints_with_check.html#emf_tutorial_defining_the_constraint">定义约束</a> ， <a class="indexterm" href="Check_language.html#Check_language_description">检查语言的描述</a>
</dt>
<dt>创建， <a class="indexterm" href="Xtend_language.html#create_extension">创建扩展（模型转换）</a>
</dt>
<dt>创建扩展， <a class="indexterm" href="Xtend_language.html#xtend_example_the_transformation">转换</a>
</dt>
<dt>CSTART， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">保护</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>d</h3>
<dl>
<dt>DEFINE， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_define">DEFINE</a>
</dt>
<dt>DirectoryCleaner， <a class="indexterm" href="uml2example_codegen.html#uml2example_codegen_workflow">定义工作流程</a>
</dt>
<dt>动态EMF， <a class="indexterm" href="emf_tutorial_dynamic_emf.html">使用动态EMF</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>Ë</h3>
<dl>
<dt>EClassifiers， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_typenames">类型名称</a>
</dt>
<dt>ELSEIF， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_if">IF</a>
</dt>
<dt>EMF， <a class="indexterm" href="emf_tutorial.html">入门</a>
</dt>
<dt>EmfMetaModel， <a class="indexterm" href="emf_tutorial_generating_code.html#emf_tutorial_templates">模板</a> ， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_typenames">类型名称</a> ， <a class="indexterm" href="r10_typesystem.html#emf_metamodel">EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）</a>
</dt>
<dd>
<dl>
<dt>metaModelPackage， <a class="indexterm" href="emf_tutorial_dynamic_emf.html">使用动态EMF</a>
</dt>
</dl>
</dd>
<dt>EMF元模型， <a class="indexterm" href="r10_typesystem.html#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a>
</dt>
<dt>EMF项目， <a class="indexterm" href="emf_tutorial_define_metamodel.html#emf_tutorial_creating_emf_project">创建EMF项目</a>
</dt>
<dt>EmfRegistryMetaModel， <a class="indexterm" href="r10_typesystem.html#emfregistry_metamodel">EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）</a>
</dt>
<dt>EMF UML2 XMI， <a class="indexterm" href="uml2example_profiles.html#uml2example_profiles_codegen">生成代码</a>
</dt>
<dt>编码， <a class="indexterm" href="emf_tutorial_setting_generator_project.html">设置生成器项目</a> （请参阅文件编码）</dt>
<dt>ENDIF， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_if">IF</a>
</dt>
<dt>列举</dt>
<dd>
<dl>
<dt>Literal， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_builtin_staticproperties">StaticProperty文字</a>
</dt>
</dl>
</dd>
<dt>枚举（UML2）， <a class="indexterm" href="uml2example_profiles.html">配置文件支持</a>
</dt>
<dt>包装， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_typenames">类型名称</a>
</dt>
<dt>错误， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_error">错误</a>
</dt>
<dt>ExecutionContext， <a class="indexterm" href="Xtend_language.html#N10F22">IExecutionContextAware</a>
</dt>
<dt>存在， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_exists">存在</a>
</dt>
<dt>EXPAND， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_expand">EXPAND</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_metamodel">Metamodel</a>
</dt>
<dt>表达， <a class="indexterm" href="r10_expressions_language.html">表达</a>
</dt>
<dd>
<dl>
<dt>缓存， <a class="indexterm" href="Xtend_language.html#create_extension">创建扩展（模型转换）</a>
</dt>
<dt>调用， <a class="indexterm" href="Xtend_language.html#N11023">从Java调用扩展</a>
</dt>
<dt>链， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_chain">链表达</a>
</dt>
<dt>创造， <a class="indexterm" href="Xtend_language.html#xtend_example_the_transformation">转型</a>
</dt>
<dt>如果， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_if">如果表达</a>
</dt>
<dt>新的， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_create">新的表达</a>
</dt>
<dt>分隔符， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_specifying_a_separator">指定分隔符</a>
</dt>
<dt>切换， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_switch">切换表达式</a>
</dt>
</dl>
</dd>
<dt>表达式语言， <a class="indexterm" href="r10_expressions_language.html">表达式</a>
</dt>
<dt>扩展， <a class="indexterm" href="emf_tutorial_extensions.html">扩展</a> ， <a class="indexterm" href="Xtend_language.html#N10E26">扩展导入声明</a>
</dt>
<dd>
<dl>
<dt>缓存， <a class="indexterm" href="Xtend_language.html#N10EC5">缓存扩展</a>
</dt>
<dt>创建， <a class="indexterm" href="Xtend_language.html#create_extension">创建扩展（模型转换）</a> ， <a class="indexterm" href="Xtend_language.html#xtend_example_the_transformation">转换</a>
</dt>
<dt>调用， <a class="indexterm" href="Xtend_language.html#N10E50">扩展调用</a>
</dt>
<dt>Java， <a class="indexterm" href="Xtend_language.html#N10EF3">Java扩展</a>
</dt>
<dt>私人， <a class="indexterm" href="Xtend_language.html#N10EE0">私人扩展</a>
</dt>
<dt>递归， <a class="indexterm" href="Xtend_language.html#N10EB3">递归</a>
</dt>
</dl>
</dd>
<dt>扩展， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_extension">扩展</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>F</h3>
<dl>
<dt>文件， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_file">文件</a>
</dt>
<dt>文件编码</dt>
<dd>
<dl>
<dt>编码， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_template_files_and_ecoding">模板文件和编码</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_encoding">编码</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_output_configuration">输出配置</a>
</dt>
</dl>
</dd>
<dt>文件扩展名</dt>
<dd>
<dl>
<dt>.xpt， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_template_files_and_ecoding">模板文件和编码</a>
</dt>
</dl>
</dd>
<dt>FOR， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_for_vs_foreach">FOR vs. FOREACH</a>
</dt>
<dt>forAll， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_forall">forAll</a>
</dt>
<dt>FOREACH， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_for_vs_foreach">FOR FOR FOR FORACH</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>G</h3>
<dl>
<dt>发电机</dt>
<dd>
<dl>
<dt>fileEncoding属性， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_encoding">编码</a>
</dt>
<dt>Metamodel配置， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_metamodel">Metamodel</a>
</dt>
<dt>工作流组件， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_generator_workflow_component">生成器工作流组件</a>
</dt>
</dl>
</dd>
<dt>Genmodel， <a class="indexterm" href="emf_tutorial_generate_emf_tooling.html">生成EMF工具</a>
</dt>
<dt>GLOBALVAR， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_globalvar">'GLOBALVAR'表达</a>
</dt>
<dt>全局变量， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_globalvar_workflow">使用GLOBALVARS配置工作流程</a>
</dt>
<dt>守卫条件， <a class="indexterm" href="Check_language.html#Guard_conditions">守卫条件</a>
</dt>
<dt>Guillemet， <a class="indexterm" href="emf_tutorial_generating_code.html#emf_tutorial_templates">模板</a> ， <a class="indexterm" href="xpand_reference_introduction.html">Xpand2</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_encoding">编码</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>一世</h3>
<dl>
<dt>IExecutionContextAware， <a class="indexterm" href="Xtend_language.html#N10F22">IExecutionContextAware</a>
</dt>
<dt>IF， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_if">IF</a>
</dt>
<dt>导入， <a class="indexterm" href="Xtend_language.html#N10E15">导入语句</a>
</dt>
<dt>进口， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_import">进口</a>
</dt>
<dt>整数类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_simple">简单类型（数据类型）</a>
</dt>
<dt>ITERATOR， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_foreach">FOREACH</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>Ĵ</h3>
<dl>
<dt>JavaBeansMetaModel， <a class="indexterm" href="Xtend_language.html#N11023">从Java调用扩展</a>
</dt>
<dt>JavaBeansStrategy， <a class="indexterm" href="Xtend_language.html#N11023">从Java调用扩展</a>
</dt>
<dt>JavaBeautifier， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_javabeautifier">JavaBeautifier</a>
</dt>
<dt>Java扩展， <a class="indexterm" href="emf_tutorial_extensions.html#emf_tutorial_java_extensions">Java扩展</a> ， <a class="indexterm" href="Xtend_language.html#N10EF3">Java扩展</a>
</dt>
<dt>JavaMetaModel， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_example_java">示例JavaMetaModel</a> ， <a class="indexterm" href="r10_typesystem.html#java_metamodel">Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）</a> ， <a class="indexterm" href="Xtend_language.html#N11023">从Java调用扩展</a>
</dt>
<dt>连接点， <a class="indexterm" href="Xtend_language.html#N1109F">连接点和点剪切语法</a> ， <a class="indexterm" href="Xtend_language.html#N110FA">工作流配置</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_join_point_and_cut_syntax">连接点和点剪切语法</a>
</dt>
<dt>加入点， <a class="indexterm" href="xpand_reference_introduction.html#aop_template_example_templates">模板</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>ķ</h3>
<dl>
<dt>关键词</dt>
<dd>
<dl>
<dt>属性， <a class="indexterm" href="r10_expressions_language.html#N10CD6">Xpand关键字和元模型属性</a>
</dt>
</dl>
</dd>
</dl>
</div>
<div class="indexdiv">
<h3>大号</h3>
<dl>
<dt>让， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_let">让我们</a>
</dt>
<dt>列表， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_collections">集合类型</a>
</dt>
<dt>文字， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_builtin">文字和内置类型的特殊运算符</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>中号</h3>
<dl>
<dt>元元模型， <a class="indexterm" href="emf_tutorial_generate_emf_tooling.html">生成EMF工具</a>
</dt>
<dt>MetaModel， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_typenames">类型名称</a>
</dt>
<dt>Metamodel， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_contributors">Eclipse IDE MetaModelContributors</a> ， <a class="indexterm" href="r10_typesystem.html#r10_using_different_metamodels">使用不同的Metamodel实现（也称为Meta-Metamodels）</a> ， <a class="indexterm" href="r10_typesystem.html#metamodel_reference">Metamodel参考</a>
</dt>
<dd>
<dl>
<dt>（非侵入性）扩展， <a class="indexterm" href="Xtend_language.html">Xtend</a>
</dt>
<dt>EMF， <a class="indexterm" href="r10_typesystem.html#emf_metamodel">EMF元模型（org.eclipse.xtend.typesystem.emf。EmfMetaModel）</a>
</dt>
<dt>EMF注册表， <a class="indexterm" href="r10_typesystem.html#emfregistry_metamodel">EMF注册表元模型（org.eclipse.xtend.typesystem.emf。EmfRegistryMetaModel）</a>
</dt>
<dt>实现元模型， <a class="indexterm" href="r10_typesystem.html#implementing_metamodels">实现自己的元模型</a>
</dt>
<dt>Java， <a class="indexterm" href="r10_typesystem.html#java_metamodel">Java Metamodel（org.eclipse.internal.xtend.type.impl.java。JavaMetaModel）</a>
</dt>
<dt>UML2， <a class="indexterm" href="r10_typesystem.html#uml2_metamodel">UML2元模型（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）</a> ， <a class="indexterm" href="r10_typesystem.html#uml2profile_metamodel">UML2 Profile Metamodel（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）</a>
</dt>
<dt>XSD， <a class="indexterm" href="r10_typesystem.html#xsd_metamodel">XSD元模型（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）</a>
</dt>
</dl>
</dd>
<dt>MetamodelContributor， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_contributors">Eclipse IDE MetaModelContributors</a>
</dt>
<dt>Metamodel撰稿人， <a class="indexterm" href="uml2example_setup_project.html">设置项目</a>
</dt>
<dt>元模型实现， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_implementations">元模型实现（也称为元元模型）</a>
</dt>
<dt><a class="indexterm" href="Xtend_language.html#xtend_example_introduction">使用Xtend进行模型</a>到模型的转换， <a class="indexterm" href="Xtend_language.html#xtend_example_introduction">模型到模型的转换</a>
</dt>
<dt>模型转换， <a class="indexterm" href="Xtend_language.html#create_extension">创建扩展（模型转换）</a>
</dt>
<dt>多种调度， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_multidispatch">多种方式（多次调度）</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>ñ</h3>
<dl>
<dt>命名空间</dt>
<dd>
<dl>
<dt>导入， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_names">名称</a>
</dt>
</dl>
</dd>
<dt>换行， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_controlling_generation_of_white_space">控制空白的生成</a>
</dt>
<dt>NoChangesVetoStrategy， <a class="indexterm" href="xpand_reference_introduction.html#N11709">VetoStrategy</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>Ø</h3>
<dl>
<dt>OCL， <a class="indexterm" href="r10_expressions_language.html">表达式</a>
</dt>
<dt>ONFILECLOSE， <a class="indexterm" href="xpand_reference_introduction.html#N11325">懒惰的评价</a>
</dt>
<dt>操作， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_implementations">元模型实现（也称为元元模型）</a>
</dt>
<dt>插座， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_file">文件</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_output_configuration">输出配置</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>P</h3>
<dl>
<dt>点切割， <a class="indexterm" href="Xtend_language.html#N1109F">连接点和点切割语法</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_join_point_and_cut_syntax">连接点和切割点语法</a>
</dt>
<dt>多态性， <a class="indexterm" href="Xtend_language.html#N10E66">类型推断</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_define">DEFINE</a>
</dt>
<dt>PostProcessor， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_beautifier">PostProcessor</a>
</dt>
<dt>私人， <a class="indexterm" href="Xtend_language.html#N10EE0">私人扩展</a>
</dt>
<dt>出发， <a class="indexterm" href="Xtend_language.html#N110D9">出发</a>
</dt>
<dt>ProfileMetaModel， <a class="indexterm" href="r10_typesystem.html#uml2profile_metamodel">UML2配置文件元模型（org.eclipse.xtend.typesystem.uml2.profile。ProfileMetaModel）</a>
</dt>
<dt>属性， <a class="indexterm" href="r10_typesystem.html#r10_metamodel_implementations">元模型实现（也称为Meta-Metamodels）</a>
</dt>
<dt>保护， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">保护</a>
</dt>
<dt>受保护区域， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">PROTECT</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protected_region_configuration">受保护区域配置</a>
</dt>
<dd>
<dl>
<dt>禁用， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">保护</a>
</dt>
<dt>启用， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protect">保护</a>
</dt>
</dl>
</dd>
<dt>prSrcPaths， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_protected_region_configuration">受保护区域配置</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>[R</h3>
<dl>
<dt>真实类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_simple">简单类型（数据类型）</a>
</dt>
<dt>递归扩展， <a class="indexterm" href="Xtend_language.html#N10EB3">递归</a>
</dt>
<dt>Reexport， <a class="indexterm" href="Xtend_language.html#N10E35">Reexporting Extensions</a>
</dt>
<dt>拒绝， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_reject">拒绝</a>
</dt>
<dt>REM， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_comments">评论</a>
</dt>
<dt>返回类型， <a class="indexterm" href="Xtend_language.html#N10E66">类型推断</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>小号</h3>
<dl>
<dt>选择， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_select">选择</a>
</dt>
<dt><a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_specifying_a_separator">分离器</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_specifying_a_separator">指定分隔符</a>
</dt>
<dt>设置类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_collections">集合类型</a>
</dt>
<dt>SlotCopier， <a class="indexterm" href="ch04s03.html#N12879">SlotCopier</a>
</dt>
<dt>SlotListAdder， <a class="indexterm" href="ch04s03.html#N128C4">SlotListAdder</a>
</dt>
<dt>SlotPrinter， <a class="indexterm" href="ch04s03.html#N12913">SlotPrinter</a>
</dt>
<dt>sortBy， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_sortby">sortBy</a>
</dt>
<dt>刻板印象， <a class="indexterm" href="uml2example_profiles.html">配置文件支持</a>
</dt>
<dt>字符串类型， <a class="indexterm" href="r10_typesystem.html#r10_builtintypes_simple">简单类型（数据类型）</a>
</dt>
<dt>SystemCommand， <a class="indexterm" href="ch04s03.html#N12816">SystemCommand</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>Ť</h3>
<dl>
<dt>标记值， <a class="indexterm" href="uml2example_profiles.html">配置文件支持</a>
</dt>
<dt>模板</dt>
<dd>
<dl>
<dt>文件， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_template_files_and_ecoding">模板文件和编码</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_define">DEFINE</a>
</dt>
<dt>多态性， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_define">DEFINE</a>
</dt>
</dl>
</dd>
<dt>转型， <a class="indexterm" href="Xtend_language.html#xtend_example_the_transformation">转型</a>
</dt>
<dt>类型</dt>
<dd>
<dl>
<dt>数据类型， <a class="indexterm" href="r10_typesystem.html">类型系统</a>
</dt>
<dt>操作， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_features">功能</a>
</dt>
<dt>参数， <a class="indexterm" href="Xtend_language.html#N110C9">参数类型</a>
</dt>
<dt>参数化类型， <a class="indexterm" href="r10_typesystem.html">类型系统</a>
</dt>
<dt>财产， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_features">特点</a>
</dt>
<dt>静态属性， <a class="indexterm" href="r10_typesystem.html#r10_typesystem_features">功能</a> ， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_builtin_staticproperties">StaticProperty文字</a>
</dt>
</dl>
</dd>
<dt>类型推断， <a class="indexterm" href="Xtend_language.html#N10E66">类型推断</a>
</dt>
<dt>typeSelect， <a class="indexterm" href="r10_expressions_language.html#r10_expressions_collection_typeselect">typeSelect</a> ， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_metamodel">Metamodel</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>ü</h3>
<dl>
<dt>UML2， <a class="indexterm" href="uml2example.html#uml2example_setup_eclipse">设置Eclipse</a>
</dt>
<dt>UML2MetaModel， <a class="indexterm" href="r10_typesystem.html#uml2_metamodel">UML2 Metamodel（org.eclipse.xtend.typesystem.uml2。UML2MetaModel）</a> ， <a class="indexterm" href="uml2example_codegen.html#uml2example_codegen_workflow">定义工作流程</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>V</h3>
<dl>
<dt>VetoStrategy， <a class="indexterm" href="xpand_reference_introduction.html#N11709">VetoStrategy</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>w ^</h3>
<dl>
<dt>编织建议， <a class="indexterm" href="Xtend_language.html#N1107E">Xtend中面向方面的编程</a>
</dt>
<dt>空白</dt>
<dd>
<dl>
<dt>省略， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_controlling_generation_of_white_space">控制空白的生成</a>
</dt>
</dl>
</dd>
<dt>WorkflowComponent， <a class="indexterm" href="Xtend_language.html#N11067">WorkflowComponent</a>
</dt>
</dl>
</div>
<div class="indexdiv">
<h3>X</h3>
<dl>
<dt>XMI， <a class="indexterm" href="emf_tutorial_define_metamodel.html#emf_tutorial_defining_metamodel">定义（meta）模型</a>
</dt>
<dt>XMIReader， <a class="indexterm" href="r10_typesystem.html#xmi_reader">XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）</a>
</dt>
<dt>XmiReader， <a class="indexterm" href="uml2example_codegen.html#uml2example_codegen_workflow">定义工作流程</a>
</dt>
<dt>XMI阅读器， <a class="indexterm" href="r10_typesystem.html#xmi_reader">XMI阅读器（org.eclipse.xtend.typesystem.uml2.profile。ProfilingExtensions。XmiReader）</a>
</dt>
<dt>XPAND</dt>
<dd>
<dl>
<dt>评论， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_comments">评论</a>
</dt>
<dt>表达式语句， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_expression_statement">表达式语句</a>
</dt>
<dt>语言， <a class="indexterm" href="xpand_reference_introduction.html">Xpand2</a>
</dt>
</dl>
</dd>
<dt>XpandException， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_error">ERROR</a>
</dt>
<dt>XSDMetaModel， <a class="indexterm" href="r10_typesystem.html#xsd_metamodel">XSD Metamodel（org.eclipse.xtend.typesystem.xsd。XSDMetaModel）</a>
</dt>
<dt>Xtend， <a class="indexterm" href="xpand_reference_introduction.html#xpand_reference_extension">EXTENSION</a>
</dt>
<dd>
<dl>
<dt>评论， <a class="indexterm" href="Xtend_language.html#N10E05">评论</a>
</dt>
<dt>文件扩展名， <a class="indexterm" href="Xtend_language.html#N10DE7">Xtend文件</a>
</dt>
<dt>语言， <a class="indexterm" href="Xtend_language.html">Xtend</a>
</dt>
</dl>
</dd>
<dt>XtendComponent， <a class="indexterm" href="Xtend_language.html#N11067">WorkflowComponent</a>
</dt>
<dd>
<dl>
<dt>建议， <a class="indexterm" href="Xtend_language.html#N110FA">工作流程配置</a>
</dt>
</dl>
</dd>
<dt>XtendFacade， <a class="indexterm" href="Xtend_language.html#N11023">从Java调用扩展</a>
</dt>
</dl>
</div>
</div>
</div>
</body>
</html><html id="0514.Contributing-Patches.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>EGit贡献者指南 - 贡献补丁</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">贡献补丁</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Website.html" title="网站">
						<img alt="以前" border="0" src="../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Gerrit-Code-Review-Cheatsheet.html" title="Gerrit Code Review Cheatsheet">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">网站</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">Gerrit Code Review Cheatsheet</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Contributing_Patches">贡献补丁</h1>
		<h2 id="Using_Gerrit_at_Eclipse">在Eclipse上使用Gerrit</h2>
		<p>EGit和JGit项目正在使用<a href="https://www.gerritcodereview.com/" target="egit_external">Gerrit Code Review</a>进行基于Git的补丁提交和审核。
		</p>
		<p>本章的部分内容也可以在<a href="http://wiki.eclipse.org/Gerrit#Doing_Code_Reviews_with_Gerrit" target="egit_external">Eclipse Gerrit wiki中找到</a> 。
		</p>
		<h3 id="User_Account">用户帐号</h3>
		<ul>
			<li>为了做出贡献，您需要在eclipse.org上使用<a href="https://dev.eclipse.org/site_login/createaccount.php" target="egit_external">Eclipse用户帐户</a> ，在创建新帐户时，您必须同意贡献者协议。
			</li>
		</ul>
		<h3 id="Legal_Paperwork">法律文书</h3>
		<p>在您的第一个贡献被接受之前，您需要以电子方式签署<a href="https://www.eclipse.org/legal/ECA.php" target="egit_external">Eclipse贡献者协议</a> （ECA）。ECA有效期为三年。在<a href="https://www.eclipse.org/legal/ecafaq.php" target="egit_external">ECA常见问题解答中</a>查找更多信息。</p>
		<p>最低限度，您贡献的所有Git提交必须具备以下条件：</p>
		<ul>
			<li>注释字段中的单行摘要，后跟更详细的描述性段落;</li>
			<li>您在“作者”字段中捕获的凭据（电子邮件地址）;和</li>
			<li>注释中具有匹配凭据的“签名”条目。</li>
			<li>需要输入“Signed-off-by”条目。通过包括此，您确认您符合<a href="https://www.eclipse.org/legal/DCO.php" target="egit_external">开发人员原产地证书</a> 。
			</li>
		</ul>
		<p>另外确保</p>
		<ul>
			<li>贡献的代码是根据项目许可证授予的（EGPL的EPL 2.0和JGit的EDL 1.0）。这是通过将<a href="http://www.eclipse.org/legal/copyrightandlicensenotice.php" target="egit_external">版权和许可证标题</a>放入每个新的java文件来完成的。请参阅其他现有项目源文件以获取正确的内容。
			</li>
		</ul>
		<p>凭借有效的ECA文件，签署的提交以及版权和许可证标头，我们将能够立即接受小补丁（&lt;1000 LoC）。对于更大的补丁，我们还必须创建一个供Eclipse IP团队审核的贡献问卷，但这通常不需要您的其他操作。</p>
		<p>要验证贡献是否<a href="https://dev.eclipse.org/mhonarc/lists/eclipse.org-committers/msg00973.html" target="egit_external">需要CQ</a> ，请使用以下git命令之一来检查：</p>
		<ul>
			<li>如果它已提交：git log --shortstat</li>
			<li>如果没有提交：git diff --stat</li>
		</ul>
		<p>这些命令告诉您插入（+）和删除（ - ）的数量。如果贡献中插入（例如添加）的总行数大于1000（是，这包括注释）则需要CQ。</p>
		<p>有关如何<a href="http://wiki.eclipse.org/Development_Resources/Contributing_via_Git" target="egit_external">通过Git</a>贡献<a href="http://wiki.eclipse.org/Development_Resources/Contributing_via_Git" target="egit_external">贡献（针对贡献者）</a>和<a href="http://wiki.eclipse.org/Development_Resources/Handling_Git_Contributions" target="egit_external">处理Git贡献（针对提交者）的</a>更多详细信息。
		</p>
		<h3 id="Logon">登录</h3>
		<h4 id="Gerrit_Web_UI">Gerrit Web UI</h4>
		<p>使用您在Eclipse（和Bugzilla）帐户中注册的电子邮件地址和Eclipse密码登录<code><a href="https://git.eclipse.org/r/" target="egit_external">https://git.eclipse.org/r/</a></code>上的Gerrit Web UI。
		</p>
		<h4 id="Git_over_SSH">Git over SSH</h4>
		<p>当从混帐访问格里特通过SSH或使用例如：It显示的用户名<a href="https://git.eclipse.org/r/#/settings/" target="egit_external">在这里</a>并上传您的SSH公钥来格里特<a href="https://git.eclipse.org/r/#/settings/ssh-keys" target="egit_external">这里</a> 。
		</p>
		<p>Gerrit SSH URl： <code>ssh://username@git.eclipse.org:29418/egit/egit.git</code></p>
		<h4 id="Git_over_HTTPS">Git over HTTPS</h4>
		<p>从git或EGit通过HTTPS访问Gerrit时，请使用<a href="https://git.eclipse.org/r/#/settings/http-password" target="egit_external">此处</a>显示的用户名和HTTP密码
		</p>
		<p>Gerrit HTTPS URl： <code><a href="https://git.eclipse.org/r/p/egit/egit.git" target="egit_external">https://git.eclipse.org/r/p/egit/egit.git</a></code> ：//git.eclipse.org/r/p/egit/egit.git
		</p>
		<h3 id="SSH_Keys">SSH密钥</h3>
		<ul>
			<li><a href="https://git.eclipse.org/r/#/settings/ssh-keys" target="egit_external">在这里</a>向<a href="https://git.eclipse.org/r/#/settings/ssh-keys" target="egit_external">Gerrit</a>添加一个或多个公共SSH密钥。
			</li>
			<li>如果您<b>完全确定</b>您没有密钥，则必须创建一对公钥和私钥SSH密钥。强烈建议您<a href="http://help.github.com/working-with-key-passphrases" target="egit_external">使用密码。</a>
			</li>
			<li>
				<b>在命令行上生成SSH密钥对</b>
			</li>
		</ul>
		<pre><pre style="width:60em">ssh-keygen -t rsa -C“your_email@youremail.com”</pre>
</pre>
		<ul>
			<li>执行一次SSH以接受主机密钥（或从注册网页复制它）</li>
		</ul>
		<pre style="width:60em">ssh -p 29418 username@git.eclipse.org</pre>
		<p> </p>
		<ul>
			<li>
				<a href="http://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration" target="egit_external">在Eclipse中生成SSH密钥对</a>
			</li>
		</ul>
		<h3 id="Doing_Code_Reviews_with_Gerrit">使用Gerrit进行代码评估</h3>
		<ul>
			<li>访问<a href="https://git.eclipse.org/r/" target="egit_external">Eclipse Gerrit Code Review实例</a>以开始审核，</li>
			<li>
				如果您希望通过电子邮件通知推送审核的新更改或更新更改，请<a href="https://git.eclipse.org/r/#/settings/projects" target="egit_external">注册以观看项目</a></li>
			<li>调整<a href="https://git.eclipse.org/r/#/settings/preferences" target="egit_external">Gerrit首选项</a>以根据您的需要进行自定义</li>
			<li>有关使用Gerrit的更多信息，请参阅<a href="https://git.eclipse.org/r/Documentation/index.html#_user_guide" target="egit_external">Gerrit用户指南</a> 。
			</li>
			<li><a href="http://wiki.eclipse.org/EGit/User_Guide#EGit_Tutorial_.28EclipseCon_Europe_Nov_2011.29" target="egit_external">EGit教程</a>将<a href="http://wiki.eclipse.org/EGit/User_Guide#EGit_Tutorial_.28EclipseCon_Europe_Nov_2011.29" target="egit_external">指导</a>您完成使用Gerrit和EGit的基本步骤。
			</li>
			<li>使用<a href="https://git.eclipse.org/r/Documentation/user-search.html" target="egit_external">Gerrit查询</a>过滤审阅列表以查找您感兴趣的更改：<ul>
					<li>
						<a href="https://git.eclipse.org/r/#/q/status:open+project:egit/egit,n,z" target="egit_external">EGIT在审核中有待更改</a>
					</li>
					<li>
						<a href="https://git.eclipse.org/r/#/q/status:open+project:jgit/jgit,n,z" target="egit_external">JGit在审核中更改待定</a>
					</li>
				</ul>
			</li>
		</ul>
		<h3 id="Using_Gerrit_with_git_command_line:">使用Gerrit和git命令行：</h3>
		<ul>
			<li>将补丁从Git上传到目标项目：</li>
		</ul>
		<p>
			<b>JGit</b>
		</p>
		<pre style="width:60em">git push ssh：//username@git.eclipse.org:29418/jgit/jgit.git HEAD：refs / for / master</pre>
		<p> 

			<b>例如：It</b>
		</p>
		<pre style="width:60em">git push ssh：//username@git.eclipse.org:29418 / egit / egit.git HEAD：refs / for / master</pre>
		<p> </p>
		<ul>
			<li>访问<a href="https://git.eclipse.org/r/" target="egit_external">Eclipse Gerrit Code Review服务器</a>以开始查看</li>
		</ul>
		<h4 id="Adding_a_dedicated_remote">添加专用遥控器</h4>
		<p>由于git可以有多个遥控器，因此您可以定义一个用于引用Gerrit以保存键入的遥控器。在以前签出的存储库中，您可以运行：</p>
		<pre>cd path / to / jgit git config remote.review.url ssh：//username@git.eclipse.org:29418/jgit/jgit.git git config remote.review.push HEAD：refs / for / master cd path / to / egit git config remote.review.url ssh：//username@git.eclipse.org:29418 / egit / egit.git git config remote.review.push HEAD：refs / for / master</pre>
		<p>您现在可以使用以下方式从任一存储库提交审核请</p>
		<pre>git推特评论</pre>
		<h3 id="Using_Gerrit_with_EGit:">使用Gerrit和EGit：</h3>
		<p>Eclipse将在“常规”&gt;“网络连接”&gt;“SSH2首选项”页面中指定的SSH2 Home位置中查找您的私钥。如果你的<code>id_rsa</code>私钥使用AES-128-CBC算法（将文件视为要确认的文本），Eclipse至少需要<code>com.jcraft.jsch 0.1.44</code>才能使用它。</p>
		<ul>
			<li>
				<a href="../../EGit/User_Guide/Tasks.html#Cloning_Remote_Repositories" title="例如：It / User_Guide＃Cloning_Remote_Repositories">克隆JGit和EGit存储库</a>并在Git存储库视图中远程“origin”的上下文菜单中选择<b>Gerrit Configuration ...</b>以<a href="http://wiki.eclipse.org/EGit/User_Guide#Gerrit_Configuration" target="egit_external">配置推送到代码审查队列</a> 。
			</li>
			<li>替代方法：在Git Repositories视图中添加一个新的评论远程，并在远程的上下文菜单中选择<b>Gerrit Configuration ....</b><ul>
					<li>从相应的Remotes节点，创建New Remote并选择Configure for Push。应选择唯一的名称，建议进行<i>审核</i> 。
					</li>
					<li>现在可以使用<i>查看</i> Remote将提交到本地克隆的更改推送到Gerrit。如果Eclipse在正确的位置查找它，系统将提示您输入私钥的密码。
					</li>
				</ul>
			</li>
			<li>您可以手动执行配置步骤，而不是使用<b>Gerrit Configuration ...</b>向导：<ul>
					<li>更改主URI或添加推送URI（此处必须使用您的Gerrit用户名）<ul>
							<li><code>SSH：//username@git.eclipse.org：29418 /（项目）的.git</code>  </li>
						</ul>
					</li>
					<li>在Ref mapping部分中，添加<code>HEAD:refs/for/master</code>的refSpec规范<code>HEAD:refs/for/master</code></li>
				</ul>
			</li>
		</ul>
		<ul>
			<li>访问我们的<a href="https://git.eclipse.org/r/" target="egit_external">Gerrit Code Review实例</a>以开始审核</li>
		</ul>
		<h3 id="Using_the_Mylyn_Gerrit_Connector">使用Mylyn Gerrit连接器</h3>
		<p>Mylyn Gerrit Connector可以从Mylyn p2存储库安装，例如从<a href="http://download.eclipse.org/mylyn/releases/juno" target="egit_external">http://download.eclipse.org/mylyn/releases/juno</a>安装到juno。</p>
		<p>它包含几个有用的功能：</p>
		<ul>
			<li>从Gerrit克隆并自动配置<ul>
					<li>向导“从Git导入项目”和“克隆Git存储库”将提供浏览Gerrit服务器上的存储库列表和克隆选定存储库的可能性。克隆后，Gerrit配置将自动完成。</li>
				</ul>
			</li>
			<li>导入Gerrit更改为Mylyn任务</li>
			<li>直接从任务编辑器中获取补丁集</li>
			<li>查看任务编辑器中的更改</li>
			<li>从任务编辑器提交更改</li>
		</ul>
		<h2 id="Granularity_of_Changes">变化的粒度</h2>
		<ul>
			<li>做一些小的提交，尽可能小。这使他们易于查看。</li>
			<li>每个提交都应该有一个提交消息，该消息非常清楚地解释了提交要实现的内容（除非代码本身非常清楚，这基本上只是普通补丁的情况）。此外，当您修复错误时，请报告您修复的错误。如果有更深层次的理由按照提交的方式做事，那么也要解释这些。这一切都是为了审稿人和你自己：提交的上下文是完全清楚的。</li>
			<li>不要在提交中混淆问题：让提交做一件事。这使得他们可以“孤立地”进行审核。提交的目的很明确，审稿人和您自己都可以轻松理解。</li>
			<li>不要破坏<b>任何提交</b>的构建和测试：这对于错误搜寻非常重要。
			</li>
			<li>将您的工作分成多个较小的工作（如果可能），并在一系列提交中实现这些工作。</li>
			<li>一系列提交应以明确的方式处理“功能”，并且仅在系列的最后一次提交中“启用”该功能。</li>
			<li>在一系列提交中，首先要奠定基础，然后在功能上进行构建。</li>
		</ul>
		<h3 id="Branches">分行</h3>
		<p>使用Gerrit时，您可以根据需要创建本地分支。当您准备好推送您的更改时，只会推送您的分支机构的提交并转换为Gerrit上的评论。分支名称本身在Gerrit上不可见。</p>
		<p>不要在分支中混合不相关的更改：当您在处理某些内容时遇到错误，然后创建一个新分支来修复该错误。确保将其基于您希望修复的远程分支的状态，例如<i>origin / master</i> 。如果您有其他更改取决于要修复的错误，请在新分支上重新设置您的工作。
		</p>
		<p>Merge / Rebase：如果您希望分支包含来自远程存储库的新提交，请重新绑定本地分支。这样做的原因是，在Gerrit中，一次审核一次提交的更改，并进行修改，直到所有审核反馈都得到解决。这与拉取请求工作流程不同，拉取请求工作流程将审核组合的更改，并通过其他提交来解决反馈。</p>
		<h2 id="Coding_standards">编码标准</h2>
		<p>Eclipse有如何编写代码的标准。</p>
		<p>
			<a href="http://wiki.eclipse.org/Coding_Conventions" title="Coding_Conventions" target="egit_external">编码惯例</a>
		</p>
		<p>
			<a href="http://wiki.eclipse.org/User_Interface_Guidelines" title="User_Interface_Guidelines" target="egit_external">使用界面指南</a>
		</p>
		<p>这些文件包含其他文件的链接。浏览它们而不期望学习所有内容，只是让您大致了解它们隐藏的细节区域和类型。当您不确定如何编写代码或设计用户界面时，这些是第一个要查看的地方。</p>
		<p>此外，世界上有关于如何编写闪耀程序的集体知识。当存在冲突时，Eclipse指南行和约定优先。</p>
		<p>如果有一个很好的理由你可以告诉我们这个原因是什么，打破规则是可以的。</p>
		<p>除了这些一般规则外，我们还认为性能很高。如果EGit插件在任何方面都很慢，那就是一个bug，应该报告并修复。Java并不慢，但是Java代码很慢。</p>
		<h3 id="Braces_for_one-line_statements">用于一行陈述的大括号</h3>
		<p>在JGit和EGit中的3.7.0之前，首选的编码风格是在一行语句周围留下大括号（这条规则有一些例外），例如：</p>
		<pre>if（condition）doSomething（）;</pre>
		<p>从3.7.0开始，大括号在行数上是独立的，没有例外。旧代码将保持原样，但新更改应使用以下样式：</p>
		<pre>if（condition）{doSomething（）; }</pre>
		<p>更改的主要原因是简化审核流程，编码指南并使其与Eclipse代码格式化程序更加一致，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=457592" target="egit_external">错误457592</a> 。
		</p>
		<h3 id="Removing_trailing_whitespace">删除尾随空格</h3>
		<p>在JGit和EGit中，我们为Java源启用了保存操作“删除所有行上的尾随空格”。除了空注释行之外，这有效，请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=414421" target="egit_external">错误414421</a> 。
		</p>
		<p>要解决此问题，请在Java编辑器中使用以下命令序列来欺骗保存操作：</p>
		<ul>
			<li>删除有问题的尾随空格</li>
			<li>保存操作重新添加尾随空格</li>
			<li>CTRL-Z（Mac上的CMD-Z）删除重新添加的空格而不再触发保存操作</li>
		</ul>
		<p>另一种解决方法是使用命令行中的<a href="http://stackoverflow.com/questions/10413922/convert-spaces-to-tabs-in-lines-i-changed-in-a-commit?answertab=active#tab-top" target="egit_external">这个</a>小脚本来编辑更改行的尾随空格。
		</p>
		<h3 id="Use_of_the_.22final.22_modifier">使用“最终”修饰符</h3>
		<p>新代码在以下情况下使用“final”修饰符<a href="https://gerrit-review.googlesource.com/c/gerrit/+/61701/" target="egit_external">https://gerrit-review.googlesource.com/c/gerrit/+/61701/</a> 。</p>
		<p>总是：</p>
		<ul>
			<li>最终字段：将字段标记为最终强制它们在构造函数或声明中初始化</li>
			<li>最终静态字段：清楚地传达意图</li>
			<li>必要时在内部匿名类中使用final变量</li>
		</ul>
		<p>可选的：</p>
		<ul>
			<li>最终类：适当时使用，例如API限制</li>
			<li>最终方法：类似于最终类</li>
		</ul>
		<p>决不：</p>
		<ul>
			<li>局部变量：它使代码混乱，并使代码可读性降低。将旧代码复制到新位置时，应删除决赛</li>
			<li>方法参数：类似于局部变量</li>
		</ul>
		<h2 id="Commit_message_guidelines">提交消息指南</h2>
		<ul>
			<li>提交消息头应该适合一行，并且应该以大写字母开头。空行将其与邮件正文分开。</li>
			<li>第一行应该是关于变化的清晰简洁的描述，不应该以点结尾。</li>
			<li>如果发布没有bugzilla条目的工程任务，则提交消息头可能看起来像“[findbugs] Fix String XYZ for String constructor”。括号中的前缀表示为什么没有相应的错误。</li>
			<li>在提供有关更改的更详细说明之前输入换行符。</li>
			<li>将提交消息格式化为每60-70个字符后有换行符。</li>
			<li>在<a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="egit_external">“关于Git提交消息的注意事项”中</a>查找有关提交消息格式的更多推理
			</li>
			<li>
				<i>Key：value</i>格式的<i>提交消息页脚</i> （ <i>提交消息中</i>最后一个空白行后面的所有内容）用于其他提交元数据。一些工具尤其是<i>Gerrit</i>解析此元数据以提供其他功能。
				<ul>
					<li>如果Bugzilla中有关于它的相关错误号，它应该在Gerrit的Change-Id条目（如果可用）之前或者在结尾之前作为<i>Bug：</i> footer。使用大写“Bug”，因为bug数据库的自动链接机制区分大小写。
					</li>
					<li>如果已发布<i>贡献问卷</i>以启动和跟踪Eclipse Foundation的IP团队对贡献的更改的审核，则应将IPZilla错误号添加为<i>CQ：</i> footer，格式如下所示</li>
					<li>对于推送到Gerrit的所有更改都需要<i>Gerrit Change-Id</i>页脚（为了能够为同一个更改推送新的补丁集），它应该以下面显示的格式添加。使用<a href="Gerrit-Code-Review-Cheatsheet.html#Install_the_commit-msg_hook_in_your_repository" title="例如：It / Contributor_Guide＃Install_the_commit，msg_hook_in_your_repository">Gerrit提交消息挂钩或EGit</a>添加<i>Change-Id</i> 。
					</li>
					<li>可以在提交消息的末尾添加“Signed-off-by”（参见下面的示例）。注意：目前，提交者不需要此页脚，而是非提交者贡献者。它可用于列出所有修改（修改，重新定位，挑选）此更改的人员。</li>
				</ul>
			</li>
		</ul>
		<pre>修复提交对话框以尊重工作台的选择最初，提交对话框将自动检查对话框中的所有文件。此行为与用户的期望相矛盾，因为他们在工作台中的选择被完全忽略。代码已更正为仅预选用户实际选择的内容。错误：12345 CQ：6031更改ID：I71ac4844ab9d2f848352eba9252090c586b4146a签名：您的姓名&lt;your.email@example.org&gt;</pre>
		<p>如果您使用Mylyn从bugzilla中获取错误，然后激活该任务，则提交消息将自动完全按照上面的请求进行格式化。</p>
		<h2 id="License_Header">许可标题</h2>
		<p>JGit根据<a href="https://www.eclipse.org/org/documents/edl-v10.php" target="egit_external">Eclipse Distribution License</a>获得许可，该<a href="https://www.eclipse.org/org/documents/edl-v10.php" target="egit_external">许可证</a>是<a href="https://opensource.org/licenses/BSD-3-Clause" target="egit_external">新BSD许可证的</a>一种形式。Eclipse项目使用此许可证需要得到Eclipse基金会董事会的一致批准，该基金会<a href="https://www.eclipse.org/org/foundation/boardminutes/2009_09_16_Minutes.php" target="egit_external">于2009年9月在董事会会议上</a>获得批准。
		</p>
		<p>用于JGit的许可证头是（请参阅<a href="https://www.eclipse.org/lists/jgit-dev/msg00127.html" target="egit_external">jgit-dev列表中的</a>此<a href="https://www.eclipse.org/lists/jgit-dev/msg00127.html" target="egit_external">邮件线程</a> ）：</p>
		<pre>/ * *版权所有©年份，贡献者* [版权所有©年份，贡献者...]*和项目的IP日志中记录的其他版权所有者。* *本程序及随附材料根据Eclipse Distribution License v1.0的条款提供* *本发行版随附*，转载如下，并且*可从<a href="http://www.eclipse.org/org/documents/edl-v10.php" target="egit_external">http://www.eclipse.org/org/获取documents / edl-v10.php</a> * *保留所有权利。* *如果满足以下*条件，则允许以源代码和二进制形式重新分发和使用*或*无需修改：* *  - 源代码的重新分发必须保留上述版权*声明，此条件列表和以下内容免责声明。* *  - 二进制形式的再分发必须在随分发提供的文档和/或其他材料中复制上述*版权声明，此条件列表和以下*免责声明。* *  - 未经事先*书面许可，不得使用Eclipse Foundation，Inc。的名称或其贡献者的*名称来支持或宣传从该软件派生的*产品。* *本软件由版权所有者和*贡献者按“原样”提供，并提供任何明示或暗示的担保，*包括但不限于暗示的担保* *适销性和特定用途的适用性*，我们不承担任何责任。在任何情况下，版权所有者或*贡献者均不对任何直接，间接，偶然，*特殊，惩戒或后果性损害负责（包括但不限于采购替代商品或服务; *使用损失，数据，或者是利润;或业务中断）但是*引起任何责任理论，无论是合同，*严格责任，还是侵权（包括疏忽或其他）*以任何方式使用本软件，即使*建议这种损害的可能性。 * /</pre>
		<p>有关更多信息，请参见<a href="http://www.eclipse.org/legal/copyrightandlicensenotice.php" target="egit_external">http://www.eclipse.org/legal/copyrightandlicensenotice.php</a> 。
		</p>
		<h2 id="Copyright">版权</h2>
		<p>在提供补丁时，您必须更新文件开头的版权部分（如果有）。请遵循文件中已存在的样式。一些例子如下。</p>
		<p>当只有一个版权（来自个人或公司）时，如下：</p>
		<pre>版权所有（C）2010,2011 Some name &lt;some@example.org&gt;</pre>
		<p>像这样改变它（注意更新的年份）：</p>
		<pre>版权所有（C）2010，YEAR Some Name &lt;some@example.org&gt;和其他。
</pre>
		<p>如果有一个部分<tt>贡献者：</tt>在法律文本下面并且您的更改超过几行，您可以在那里添加您的名字，并可选择描述更改并链接到错误编号。如果您做出了重大改变，也可以开始这样的部分。</p>
		<p>如果有多个版权条目，请将您的作为单独的行添加。所以，鉴于此：</p>
		<pre>版权所有（C）2010 Some name &lt;some@example.org&gt; Copyright（C）2011 Other Name &lt;other@example.org&gt;</pre>
		<p>添加另一行：</p>
		<pre>Copyright（C）2010 Some name &lt;some@example.org&gt; Copyright（C）2011 Other name &lt;other@example.org&gt; Copyright（C）YEAR Your Name &lt;you@example.org&gt;</pre>
		<p>对于新文件，请复制其中一个现有标题，并使用您的姓名启动版权部分。</p>
		<h2 id="Test_before_submitting">提交前进行测试</h2>
		<p>有关如何测试自己的工作的一些建议，请参见<a href="#Manual_alpha_testing">手册alpha测试</a>部分。
		</p>
		<ul>
			<li>添加自动化测试以增强功能和修复错误，以确保功能正确并避免回归</li>
			<li>运行所有现有测试。这不需要很长时间。</li>
			<li>注意Java和Eclipse SDK基线。EGit仅需要Java 8和Eclipse 4.4。您不能使用更新的API。</li>
		</ul>
		<h2 id="Sending_patches_by_mail">通过邮件发送补丁</h2>
		<p>虽然通过邮件发送补丁是批准的与Git项目交互并向Git项目提出反馈的方式，但请不要通过<a href="http://www.kernel.org/pub//software/scm/git/docs/git-send-email.html" target="egit_external">git send-email</a>发送补丁。相反，请使用<a href="http://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="egit_external">git format-patch</a>生成<code>mbox</code> ，然后根据上面的SUBMITTING_PATCHES指南将其附加到bugzilla中的项目。
		</p>
		<p>如果您要为审核发送正在进行的工作，请注意您还可以将工作进度（或RFC）项附加到Bugzilla;它不仅适用于已完成的补丁。</p>
		<p>
			<b>但是</b> ，通常首选您根据<a href="#Contributing_Patches">Contributing_Patches</a>通过Gerrit发送您想要注释的项目，因为Gerrit允许在线添加注释，并允许在更改后发送多个版本的修补程序。一旦将更改提交给Gerrit，您就可以向开发人员邮件列表发送邮件，请求通过URL审核您的更改，或让Gerrit代表您发送邮件。
		</p>
		<p>
			<br>
		</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Website.html" title="网站">
						<img alt="以前" border="0" src="../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="Contributor-Guide.html" title="EGit贡献者指南">
						<img alt="EGit贡献者指南" border="0" src="../../images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Gerrit-Code-Review-Cheatsheet.html" title="Gerrit Code Review Cheatsheet">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">网站</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">Gerrit Code Review Cheatsheet</td>
			</tr>
		</table>
	</body>
</html><html id="0021.ScriptingReference.24.5.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>BirtDuration</title>
    <link rel="StyleSheet" href="css/ScriptingReference.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ScriptingReference.24.4.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="ScriptingReference.24.6.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h2 class="RH1_Class"><a name="322273">BirtDuration</a>类</h2>
      <p class="b_Body"><a name="322274">BirtDuration类提供了获取XML文档中使用的部分时间段或持续时间的函数。持续时间以下列形式指定：</a></p>
      <div class="cfb_CodeFirst_Break"><a name="317618">P</a> <em class="Italic">n</em> Y <em class="Italic">n</em> M <em class="Italic">n</em> DT <em class="Italic">n</em> H <em class="Italic">n</em> M <em class="Italic">n</em> S.</div>
      <p class="b_Body"><a name="317629">哪里：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="317218">P表示期间（必填）</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="317235">n</a></em>表示年数</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="317242">n</a></em>表示月数</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="317249">n</a></em>表示天数</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="317256">T表示时间段的开始（如果持续时间包括小时，分钟或秒，则需要）</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="317263">n</a></em> H表示小时数</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="321336">n</a></em> M表示分钟数</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><em class="Italic" style="font-family:&quot;Microsoft Sans Serif&quot;;font-size:9.0pt"><a name="321337">n</a></em> S表示秒数</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="321338">例如，以下值表示持续时间为2年，3个月和5天：</a></p>
      <div class="cfb_CodeFirst_Break"><a name="317581">P2Y3M5D</a></div>
      <p class="b_Body"><a name="317652">以下值表示持续时间为10小时：</a></p>
      <div class="cfb_CodeFirst_Break"><a name="317608">PT10H</a></div>
      <p class="b_Body"><a name="317674">BirtDuration类是静态的。应用程序无法创建该类的实例。</a></p>
      <h3 class="RH2_Method"><a name="349842">BirtDuration.add</a></h3>
      <p class="b_Body"><a name="349843">此函数将两个持续时间加在一起，并返回总和。</a></p>
      <p class="N_sb_ScanBold"><a name="349844">句法</a></p>
      <div class="rs_RSyntax"><a name="349845">string BirtDuration.add（string lexicalDuration1，string lexicalDuration2）</a></div>
      <p class="N_sb_ScanBold"><a name="349846">参数</a></p>
      <p class="RParameter"><a name="349847">lexicalDuration1</a></p>
      <p class="bn_BodyNoLead"><a name="349848">串。添加的第一个持续时间。</a></p>
      <p class="RParameter"><a name="349849">lexicalDuration2</a></p>
      <p class="bn_BodyNoLead"><a name="349850">串。要添加的第二个持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="349851">返回</a></p>
      <p class="b_Body"><a name="349852">串。两个输入持续时间的总和。</a></p>
      <p class="N_sb_ScanBold"><a name="349853">例子</a></p>
      <p class="b_Body"><a name="349854">以下示例添加两个持续时间：</a></p>
      <div class="cf_CodeFirst"><a name="349855">BirtDuration.add（“P1Y3M”，“P13M”）//返回P2Y4M</a></div>
      <h3 class="RH2_Method"><a name="350314">BirtDuration.addTo</a></h3>
      <p class="b_Body"><a name="350315">此函数将持续时间添加到指定的Date对象。</a></p>
      <p class="N_sb_ScanBold"><a name="350316">句法</a></p>
      <div class="rs_RSyntax"><a name="350317">Date BirtDuration.add（string lexicalDuration，Date date）</a></div>
      <p class="N_sb_ScanBold"><a name="350318">参数</a></p>
      <p class="RParameter"><a name="350319">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="350320">串。要添加的持续时间。</a></p>
      <p class="RParameter"><a name="350321">日期</a></p>
      <p class="bn_BodyNoLead"><a name="350322">日期对象。修改的日期和时间。</a></p>
      <p class="N_sb_ScanBold"><a name="350323">返回</a></p>
      <p class="b_Body"><a name="350324">日期对象。持续时间提前的日期。</a></p>
      <p class="N_sb_ScanBold"><a name="350325">例子</a></p>
      <p class="b_Body"><a name="350413">以下示例将今年的日期和时间添加一年：</a></p>
      <div class="cf_CodeFirst"><a name="350414">var today = new Date（）;</a></div>
      <div class="co_Code"><a name="350420">var annualDate = BirtDuration.addTo（今天，“P1Y”）</a></div>
      <h3 class="RH2_Method"><a name="350439">BirtDuration.compare</a></h3>
      <p class="b_Body"><a name="350440">此函数测试持续时间是否与另一持续时间相同，大于或小于另一持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="350441">句法</a></p>
      <div class="rs_RSyntax"><a name="350442">整数BirtDuration.compare（字符串lexicalDuration1，字符串lexicalDuration2）</a></div>
      <p class="N_sb_ScanBold"><a name="350443">参数</a></p>
      <p class="RParameter"><a name="350444">lexicalDuration1</a></p>
      <p class="bn_BodyNoLead"><a name="350445">串。在比较中使用的第一个持续时间。</a></p>
      <p class="RParameter"><a name="350446">lexicalDuration2</a></p>
      <p class="bn_BodyNoLead"><a name="350447">串。在比较中使用的第二个持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="350448">返回</a></p>
      <p class="b_Body"><a name="350449">整数。两个持续时间之间的偏序关系。如果第一个持续时间更长则返回1，如果它们相等则返回0，如果第二个持续时间更长则返回-1。</a></p>
      <p class="N_sb_ScanBold"><a name="350450">例子</a></p>
      <p class="b_Body"><a name="350451">以下表达式比较特定持续时间的长度：</a></p>
      <div class="cf_CodeFirst"><a name="350452">BirtDuration.compare（“P1Y”，“P12M”）; //返回0</a></div>
      <div class="co_Code"><a name="350453">BirtDuration.compare（“P3M”，“P100D”）//返回-1</a></div>
      <div class="co_Code"><a name="350454">BirtDuration.compare（“PT25H”，“P1D”）//返回1</a></div>
      <h3 class="RH2_Method"><a name="316868">BirtDuration.day</a></h3>
      <p class="b_Body"><a name="316869">此函数返回给定持续时间的天数值。</a></p>
      <p class="N_sb_ScanBold"><a name="316870">句法</a></p>
      <div class="rs_RSyntax"><a name="316871">整数BirtDuration.day（字符串lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="316872">参数</a></p>
      <p class="RParameter"><a name="316873">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="316874">串。获取日期值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="316877">返回</a></p>
      <p class="b_Body"><a name="316878">一个整数，表示指定持续时间的天数值。</a></p>
      <p class="N_sb_ScanBold"><a name="316879">例子</a></p>
      <p class="b_Body"><a name="317732">以下示例显示特定持续时间返回的日期值：</a></p>
      <div class="cf_CodeFirst"><a name="317733">BirtDuration.day（“P1Y15DT12H”）//返回15</a></div>
      <div class="co_Code"><a name="320246">BirtDuration.day（“P5Y2M”）//返回0</a></div>
      <h3 class="RH2_Method"><a name="356229">BirtDuration.getSign</a></h3>
      <p class="b_Body"><a name="356230">此函数返回持续时间的符号。</a></p>
      <p class="N_sb_ScanBold"><a name="356231">句法</a></p>
      <div class="rs_RSyntax"><a name="356232">整数BirtDuration.getSign（string lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="356233">参数</a></p>
      <p class="RParameter"><a name="356234">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="356235">串。分析的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="356238">返回</a></p>
      <p class="b_Body"><a name="356239">整数。持续时间的符号作为乘数。对于正持续时间返回1，对于负持续时间返回-1，对于null或0值返回0。</a></p>
      <p class="N_sb_ScanBold"><a name="356240">例子</a></p>
      <p class="b_Body"><a name="356241">以下表达式分析特定持续时间的唱歌：</a></p>
      <div class="cf_CodeFirst"><a name="356242">BirtDuration.getSign（ “P0Y”）; //返回0</a></div>
      <div class="co_Code"><a name="356868">BirtDuration.getSign（ “ -  P8Y2M3D”）; //返回-1</a></div>
      <h3 class="RH2_Method"><a name="320437">BirtDuration.hour</a></h3>
      <p class="b_Body"><a name="320438">此函数返回给定持续时间的小时值。</a></p>
      <p class="N_sb_ScanBold"><a name="320439">句法</a></p>
      <div class="rs_RSyntax"><a name="320440">整数BirtDuration.hour（string lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="320441">参数</a></p>
      <p class="RParameter"><a name="320442">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="320443">串。获取小时值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="320444">返回</a></p>
      <p class="b_Body"><a name="320445">一个整数，表示指定持续时间的小时值。</a></p>
      <p class="N_sb_ScanBold"><a name="320446">例子</a></p>
      <p class="b_Body"><a name="320447">以下示例显示特定持续时间返回的小时值：</a></p>
      <div class="cf_CodeFirst"><a name="320448">BirtDuration.hour（“P1Y15DT12H”）//返回12</a></div>
      <div class="co_Code"><a name="320449">BirtDuration.hour（“P5Y2M”）//返回0</a></div>
      <h3 class="RH2_Method"><a name="321505">BirtDuration.isLongerThan</a></h3>
      <p class="b_Body"><a name="321506">此函数测试持续时间是否长于另一持续时间。有时，某些持续时间之间的订单关系无法确定，例如，一个月（P1M）和30天（P30D），或一年（P1Y）和365天（P365D）。在这些情况下，函数返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="321507">句法</a></p>
      <div class="rs_RSyntax"><a name="321508">boolean BirtDuration.isLongerThan（string lexicalDuration1，string lexicalDuration2）</a></div>
      <p class="N_sb_ScanBold"><a name="321509">参数</a></p>
      <p class="RParameter"><a name="321510">lexicalDuration1</a></p>
      <p class="bn_BodyNoLead"><a name="321511">串。在比较中使用的第一个持续时间。</a></p>
      <p class="RParameter"><a name="321512">lexicalDuration2</a></p>
      <p class="bn_BodyNoLead"><a name="321513">串。在比较中使用的第二个持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="321514">返回</a></p>
      <p class="b_Body"><a name="322015">布尔。如果第一个持续时间长于第二个持续时间，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="322016">例子</a></p>
      <p class="b_Body"><a name="322017">以下表达式比较特定持续时间的长度：</a></p>
      <div class="cf_CodeFirst"><a name="321518">BirtDuration.isLongerThan（“P1Y3M”，“P13M”）//返回true</a></div>
      <div class="co_Code"><a name="321519">BirtDuration.isLongerThan（“P2M”，“P62D”）//返回false</a></div>
      <div class="co_Code"><a name="321520">BirtDuration.isLongerThan（“PT25H”，“P1D”）//返回true</a></div>
      <h3 class="RH2_Method"><a name="322168">BirtDuration.isShorterThan</a></h3>
      <p class="b_Body"><a name="322169">此功能测试持续时间是否短于另一个持续时间。有时，某些持续时间之间的订单关系无法确定，例如，一个月（P1M）和30天（P30D），或一年（P1Y）和365天（P365D）。在这些情况下，函数返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="322170">句法</a></p>
      <div class="rs_RSyntax"><a name="322171">boolean BirtDuration.isShorterThan（string lexicalDuration1，string lexicalDuration2）</a></div>
      <p class="N_sb_ScanBold"><a name="322172">参数</a></p>
      <p class="RParameter"><a name="322173">lexicalDuration1</a></p>
      <p class="bn_BodyNoLead"><a name="322174">串。在比较中使用的第一个持续时间。</a></p>
      <p class="RParameter"><a name="322175">lexicalDuration2</a></p>
      <p class="bn_BodyNoLead"><a name="322176">串。在比较中使用的第二个持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="322177">返回</a></p>
      <p class="b_Body"><a name="322178">布尔。如果第一个持续时间短于第二个持续时间，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="322179">例子</a></p>
      <p class="b_Body"><a name="322180">以下表达式比较特定持续时间的长度：</a></p>
      <div class="cf_CodeFirst"><a name="322181">BirtDuration.isShorterThan（“P1Y3M”，“P13M”）//返回false</a></div>
      <div class="co_Code"><a name="322182">BirtDuration.isShorterThan（“P2M”，“P62D”）//返回false</a></div>
      <div class="co_Code"><a name="322183">BirtDuration.isShorterThan（“PT25H”，“P1D”）//返回false</a></div>
      <div class="co_Code"><a name="322228">BirtDuration.isShorterThan（“P27D”，“P1M”）//返回true</a></div>
      <h3 class="RH2_Method"><a name="320752">BirtDuration.minute</a></h3>
      <p class="b_Body"><a name="320753">此函数返回给定持续时间的分钟值。</a></p>
      <p class="N_sb_ScanBold"><a name="320754">句法</a></p>
      <div class="rs_RSyntax"><a name="320755">整数BirtDuration.minute（字符串lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="320756">参数</a></p>
      <p class="RParameter"><a name="320757">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="320758">串。获取分钟值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="320759">返回</a></p>
      <p class="b_Body"><a name="320760">整数。一个数字，表示指定持续时间的分钟值。</a></p>
      <p class="N_sb_ScanBold"><a name="320761">例子</a></p>
      <p class="b_Body"><a name="320762">以下示例显示了特定持续时间返回的分钟值：</a></p>
      <div class="cf_CodeFirst"><a name="320763">BirtDuration.minute（“P1Y15DT12H30M45S”）//返回30</a></div>
      <div class="co_Code"><a name="320849">BirtDuration.minute（“P5Y2M8DT15H”）//返回0</a></div>
      <h3 class="RH2_Method"><a name="320850">BirtDuration.month</a></h3>
      <p class="b_Body"><a name="320851">此函数返回给定持续时间的月份值。</a></p>
      <p class="N_sb_ScanBold"><a name="320852">句法</a></p>
      <div class="rs_RSyntax"><a name="320817">整数BirtDuration.month（字符串lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="320818">参数</a></p>
      <p class="RParameter"><a name="320819">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="320820">串。获取月份值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="320821">返回</a></p>
      <p class="b_Body"><a name="320822">整数。一个数字，表示指定持续时间的月份值。</a></p>
      <p class="N_sb_ScanBold"><a name="320823">例子</a></p>
      <p class="b_Body"><a name="320824">以下示例显示了特定持续时间返回的月份值：</a></p>
      <div class="cf_CodeFirst"><a name="320825">BirtDuration.month（“P1Y3M15DT12H30M45S”）//返回3</a></div>
      <div class="co_Code"><a name="320826">BirtDuration.month（“P5Y8DT15H”）//返回0</a></div>
      <h3 class="RH2_Method"><a name="356432">BirtDuration.multiply</a></h3>
      <p class="b_Body"><a name="356433">此函数返回持续时间和常规数的乘积。</a></p>
      <p class="N_sb_ScanBold"><a name="356434">句法</a></p>
      <div class="rs_RSyntax"><a name="356435">string BirtDuration.multiply（string lexicalDuration，integer factor）</a></div>
      <p class="N_sb_ScanBold"><a name="356436">参数</a></p>
      <p class="RParameter"><a name="356437">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="356438">串。一个加倍的持续时间。</a></p>
      <p class="RParameter"><a name="356501">因子</a></p>
      <p class="bn_BodyNoLead"><a name="356502">整数。一个常数来乘。</a></p>
      <p class="N_sb_ScanBold"><a name="356477">返回</a></p>
      <p class="b_Body"><a name="356478">串。输入持续时间和因子的乘积。</a></p>
      <p class="N_sb_ScanBold"><a name="356441">例子</a></p>
      <p class="b_Body"><a name="356442">以下示例显示了具体持续时间和因素返回的产品：</a></p>
      <div class="cf_CodeFirst"><a name="356443">BirtDuration.multiply（“P1Y3M15DT12H30M45S”，1）</a></div>
      <div class="co_Code"><a name="356539">//返回P1Y3M15DT12H30M45S</a></div>
      <div class="co_Code"><a name="356444">BirtDuration.multiply（“P5Y8DT15H”，0）//返回P0Y0DT0H</a></div>
      <h3 class="RH2_Method"><a name="356559">BirtDuration.negate</a></h3>
      <p class="b_Body"><a name="356560">此函数返回持续时间的负值。</a></p>
      <p class="N_sb_ScanBold"><a name="356561">句法</a></p>
      <div class="rs_RSyntax"><a name="356562">string BirtDuration.negate（string lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="356563">参数</a></p>
      <p class="RParameter"><a name="356564">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="356565">串。否定的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="356568">返回</a></p>
      <p class="b_Body"><a name="356569">串。输入持续时间的负值。</a></p>
      <p class="N_sb_ScanBold"><a name="356570">例子</a></p>
      <p class="b_Body"><a name="356571">以下示例显示特定持续时间的否定结果：</a></p>
      <div class="cf_CodeFirst"><a name="356572">BirtDuration.negate（“P1Y3M15DT12H30M45S”）</a></div>
      <div class="co_Code"><a name="356573">//返回-P1Y3M15DT12H30M45S</a></div>
      <h3 class="RH2_Method"><a name="320871">BirtDuration.second</a></h3>
      <p class="b_Body"><a name="320872">此函数返回给定持续时间的秒值。</a></p>
      <p class="N_sb_ScanBold"><a name="320873">句法</a></p>
      <div class="rs_RSyntax"><a name="320874">整数BirtDuration.second（string lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="320875">参数</a></p>
      <p class="RParameter"><a name="320876">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="320877">串。获取秒值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="320878">返回</a></p>
      <p class="b_Body"><a name="320879">整数。一个数字，表示指定持续时间的秒值。</a></p>
      <p class="N_sb_ScanBold"><a name="320880">例子</a></p>
      <p class="b_Body"><a name="320881">以下示例显示了特定持续时间返回的秒值：</a></p>
      <div class="cf_CodeFirst"><a name="320882">BirtDuration.second（“P1Y3M15DT12H30M45S”）//返回5</a></div>
      <div class="co_Code"><a name="320883">BirtDuration.second（“P5Y8DT15H”）//返回0</a></div>
      <h3 class="RH2_Method"><a name="356891">BirtDuration.subtract</a></h3>
      <p class="b_Body"><a name="356892">此函数从另一个持续时间中减去持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="356893">句法</a></p>
      <div class="rs_RSyntax"><a name="356894">string BirtDuration.subtract（string lexicalDuration1，string lexicalDuration2）</a></div>
      <p class="N_sb_ScanBold"><a name="356895">参数</a></p>
      <p class="RParameter"><a name="356896">lexicalDuration1</a></p>
      <p class="bn_BodyNoLead"><a name="356897">串。要减去的持续时间。</a></p>
      <p class="RParameter"><a name="356898">lexicalDuration2</a></p>
      <p class="bn_BodyNoLead"><a name="356899">串。持续时间从lexicalDuration1中减去。</a></p>
      <p class="N_sb_ScanBold"><a name="356900">返回</a></p>
      <p class="b_Body"><a name="356901">串。两个输入持续时间的差异。</a></p>
      <p class="N_sb_ScanBold"><a name="356902">例子</a></p>
      <p class="b_Body"><a name="356903">以下示例减去两个持续时间：</a></p>
      <div class="cf_CodeFirst"><a name="356904">BirtDuration.subtract（“P1Y3M”，“P13M”）//返回P0Y2M</a></div>
      <h3 class="RH2_Method"><a name="321357">BirtDuration.timeInMills</a></h3>
      <p class="b_Body"><a name="321358">此函数返回指定开始日期内给定持续时间内的毫秒数。持续时间中的毫秒数可能会根据开始日期而改变。例如，一个月的持续时间可以是28天，29天，30天或31天，具体取决于开始日期。如果开始日期是1月1日，则该函数计算1月1日到2月1日（不包括2月1日）之间的毫秒数，等于2678400000毫秒或31天。如果开始日期是2009年2月1日（闰年），则该函数计算2月1日到3月1日之间的毫秒数，等于2505600000毫秒或29天。</a></p>
      <p class="N_sb_ScanBold"><a name="321359">句法</a></p>
      <div class="rs_RSyntax"><a name="321360">Number BirtDuration.timeInMills（string lexicalDuration，Date startDate）</a></div>
      <p class="N_sb_ScanBold"><a name="321361">参数</a></p>
      <p class="RParameter"><a name="321362">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="321363">串。获取持续时间的长度（以毫秒为单位）。</a></p>
      <p class="RParameter"><a name="321405">开始日期</a></p>
      <p class="bn_BodyNoLead"><a name="321415">日期对象。表示开始日期。</a></p>
      <p class="N_sb_ScanBold"><a name="321364">返回</a></p>
      <p class="b_Body"><a name="321365">数字对象。指定持续时间内的毫秒数。</a></p>
      <p class="N_sb_ScanBold"><a name="321366">例子</a></p>
      <p class="b_Body"><a name="321367">以下示例显示了特定持续时间和开始日期返回的毫秒数：</a></p>
      <div class="cf_CodeFirst"><a name="321368">BirtDuration.timeInMills（“P1Y3M10D”，“2009-01-01”）//返回40172400000</a></div>
      <div class="co_Code"><a name="321369">BirtDuration.timeInMills（“P1Y3M10D”，“2008-01-01”）//返回40258800000</a></div>
      <div class="co_Code"><a name="321467">BirtDuration.timeInMills（“PT6H45M20S”，“2009-01-01”）//返回24320000</a></div>
      <h3 class="RH2_Method"><a name="321213">BirtDuration.year</a></h3>
      <p class="b_Body"><a name="321214">此函数返回给定持续时间的年份值。</a></p>
      <p class="N_sb_ScanBold"><a name="321215">句法</a></p>
      <div class="rs_RSyntax"><a name="321216">整数BirtDuration.year（字符串lexicalDuration）</a></div>
      <p class="N_sb_ScanBold"><a name="321217">参数</a></p>
      <p class="RParameter"><a name="321218">lexicalDuration</a></p>
      <p class="bn_BodyNoLead"><a name="321219">串。获取年份值的持续时间。</a></p>
      <p class="N_sb_ScanBold"><a name="321220">返回</a></p>
      <p class="b_Body"><a name="321221">整数。一个数字，表示指定持续时间的年份值。</a></p>
      <p class="N_sb_ScanBold"><a name="321222">例子</a></p>
      <p class="b_Body"><a name="321223">以下示例显示特定持续时间返回的年份值：</a></p>
      <div class="cf_CodeFirst"><a name="321224">BirtDuration.year（“P1Y3M15DT12H30M45S”）//返回1</a></div>
      <div class="co_Code"><a name="321225">BirtDuration.year（“P8DT15H”）//返回0</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3453.visual_inheritance.html" dir="ltr"></html><html dir="ltr">
<head>
<title>可视化继承</title>
<meta content="text/html; charset=windows-1252" http-equiv="Content-Type"></meta>
<link href="../../book.css" rel="stylesheet" type="text/css"></link>
<style></style>
</head>
<body bgcolor="#FFFFFF" dir="ltr">
    <h1>可视化继承</h1>
	<div align="left">
		<table border="0" cellpadding="5" cellspacing="0" id="table1" width="850">
			<tr>
				<td valign="top">该工具支持SWT <b>壳</b>和<b>复合材料</b> ，摇摆<b><b><b>JFrames，JDialogs，JApplets</b></b></b>和<b>JPanels</b>的可视化继承。可视继承支持以下功能：<ul>
	<li>从任何<b>Shell</b> ， <b>Composite</b> ， <b>JFrame</b> ， <b>JDialog</b> ， <b>JApplet</b>或<b>JPanel</b>子类继承</li>
	<li>所有继承的小部件都是可见的</li>
	<li>访问通过公共访问者或受保护访问者公开的继承小部件</li>
	<li>访问继承的自定义属性</li>
	<li>继承的小部件出现在树中，带有“暴露” <img src="../userinterface/images/exposed_decorator.gif" alt="" width="6" height="6">装饰</li>
</ul>
			<p>以下是继承层次结构中两个<b>Composites</b>的示例。第一个<b>Composite</b>使用<b>GridLayout</b> ，有两个<b>Labels</b> ，两个<b>Text</b>小部件，一个<b>Button</b>和一个内部<b>Composite</b>小部件。</p>
			<p>
			<img border="0" src="images/visual_inheritance_parent.png" align="top"></p>
			<p>使用<b><a href="../userinterface/context_menu.html">Expose Component</a></b>命令将内部<b>Composite</b>窗口小部件公开为公共组件。<b><a href="../userinterface/context_menu.html">Expose Component</a></b>将<b><a href="../userinterface/context_menu.html">组件</a></b>转换为字段并为其添加公共访问器。最后，使用<b><a href="../userinterface/property_pane_context_menu.html">Expose Property</a></b>命令将第一个<b>Text</b>小部件的<b>background</b> color属性和<b>Button</b>的<b>text</b>属性公开为<b>Composite</b>的公共属性。<b><a href="../userinterface/property_pane_context_menu.html">Expose Property</a></b>添加了一对访问器，用于获取和设置目标窗口小部件的所需属性。</p>
			<p>
			<img border="0" src="images/visual_inheritance_expose_component_menu.png" align="top"> 
			<img border="0" src="images/visual_inheritance_expose_property_menu.png" align="top"></p>
			<blockquote>
				<font size="2" color="#7f0055"><b>
				<dl>
					<dd><font face="Courier">进口</font></dd></dl></b></font> <font size="2" face="Courier">org.eclipse.swt。SWT;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.graphics。颜色;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.layout。*;</font> <font size="2" color="#7f0055"><b>
					<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">是org.eclipse.swt.widgets。*;</font> <font size="2" color="#7f0055"><b><font face="Courier">
					<br>
 </font><dd><font face="Courier">上市</font></dd></b></font> <font face="Courier"><font size="2"> </font> <font size="2" color="#7f0055"><b>class</b></font> <font size="2">ParentComposite</font> <font size="2" color="#7f0055"><b>扩展</b></font></font> <font size="2"><font face="Courier">Composite {</font><dl>
						<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">按钮</font> <font size="2" color="#0000c0">browseButton</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">复合</font> <font size="2" color="#0000c0">材料</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">secondField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">firstField</font></font> <font size="2"><font face="Courier">;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>public</b></font> <font size="2">ParentComposite（Composite parent，</font> <font size="2" color="#7f0055"><b>int</b></font></font> <font size="2"><font face="Courier">style）{</font><dl>
							<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>超级</b></font> <font size="2"><font face="Courier">（父母，风格）;</font><dd><font face="Courier">createContents（）;</font></dd>
						
						
						<dd><font face="Courier">}<br>
 </font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>上市</b></font> <font size="2">
						</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">createContents（）{</font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>final</b></font> <font size="2">GridLayout gridLayout =</font> <font size="2" color="#7f0055"><b>new</b></font></font> <font size="2"><font face="Courier">GridLayout（）;</font><dd><font face="Courier">网格布局。</font></dd></font> <font size="2" color="#0000c0" face="Courier">numColumns</font> <font size="2"><font face="Courier">= 3;</font><dd><font face="Courier">的setLayout（GridLayout的）;<br>
 </font></dd>
							<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签firstFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">firstFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第一场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">firstField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_firstField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">firstField</font> <font size="2"><font face="Courier">.setLayoutData（gd_firstField）;<br>
 </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">按钮（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton</font> <font size="2"><font size="2"><font size="2">.setLayoutData（。</font></font></font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2" color="#0000c0"><i><font size="2">FILL，SWT</font></i></font> <font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，FALSE，FALSE））;</font></b></font></font></b></font></font></i></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">browseButton .setText</font> <font size="2">（</font> <font size="2" color="#2a00ff">“Browse ...”</font></font> <font size="2"><font face="Courier">）;<br>
 </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签secondFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">secondFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第二场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">secondField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_secondField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE，2，1）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">secondField</font> <font size="2"><font face="Courier">.setLayoutData（gd_secondField）;<br>
 </font>
							<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">复合</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">复合物（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">复合</font> <font size="2">.setLayoutData（</font> <font size="2"><font size="2" color="#7f0055"><b>新</b></font>的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">FILL，FALSE，TRUE，3，1））;</font></b></font></font></b></font></font></i></font></font></font><dd><font face="Courier">}<br>
 </font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">Composite getComposite（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">复合材料</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br>
 </span></font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">String getBrowseButtonText（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">browseButton</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.getText（）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br>
 </span></font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">上市</span></b></font> <font size="2"><span style="background-color:#ffff99">
						</span></font> <font size="2" color="#7f0055"><b><span style="background-color:#ffff99">void</span></b></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">setBrowseButtonText（String text）{</span></font><dl>
							<dd></dd></dl></font> <font size="2" color="#0000c0" face="Courier"><span style="background-color:#ffff99">browseButton .setText</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">（text）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br>
 </span></font></dd>
						<dd></dd></font> <font size="2" color="#7f0055" face="Courier"><b><span style="background-color:#ffff99">public</span></b></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">Color getFirstFieldBackground（）{</span></font><dl>
							<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">返回</span></b></font> <font size="2"><span style="background-color:#ffff99">
							</span></font> <font size="2" color="#0000c0"><span style="background-color:#ffff99">firstField</span></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.getBackground（）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}<br>
 </span></font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b><span style="background-color:#ffff99">上市</span></b></font> <font size="2"><span style="background-color:#ffff99">
						</span></font> <font size="2" color="#7f0055"><b><span style="background-color:#ffff99">void</span></b></font></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">setFirstFieldBackground（Color background）{</span></font><dl>
							<dd></dd></dl></font> <font size="2" color="#0000c0" face="Courier"><span style="background-color:#ffff99">firstField</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">.setBackground（background）;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">}</span></font></dd>
					
					
					<dd><font face="Courier">}</font></dd>
				
				</font></blockquote>
			<p>第二个<b>Composite</b>继承自第一个，并通过其来自超类的访问器设置内部<b>Composite的</b>布局管理器，然后向内部<b>Composite</b>添加几个新的小部件。它还添加了几个在继承的小部件之后出现的新小部件，并使用从超类继承的<b>GridLayout</b>布局管理器。最后，它使用第一个Composite中定义的访问器覆盖第一个<b>Text</b>小部件的<b>背景</b>颜色和<b>Button</b>的文本设置。<br>
			<br>请注意，来自超类的公开和继承的内部<b>Composite</b>在组件树中显示为一个小的<img src="../userinterface/images/exposed_decorator.gif" alt="" width="6" height="6">叠加图标。第一个<b>Composite中</b>定义的其他小部件不会显示在树中，因为它们是该<b>Composite的</b>私有。</p>
			<p>
			<img border="0" src="images/visual_inheritance_child.png" width="754" height="427" align="top"></p>
			<font size="2" color="#7f0055"><b>
			<dl>
				<dd><font face="Courier">进口</font></dd></dl></b></font> <font size="2" face="Courier">org.eclipse.swt。SWT;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">org.eclipse.swt.layout。*;</font> <font size="2" color="#7f0055"><b>
				<dd><font face="Courier">进口</font></dd></b></font> <font size="2" face="Courier">是org.eclipse.swt.widgets。*;</font> <font size="2" color="#7f0055"><b><font face="Courier">
				<br>
 </font><dd><font face="Courier">上市</font></dd></b></font> <font face="Courier"><font size="2"> </font> <font size="2" color="#7f0055"><b>class</b></font> <font size="2">ChildComposite</font> <font size="2" color="#7f0055"><b>扩展</b></font></font> <font size="2"><font face="Courier">ParentComposite {</font><dl>
					<dd></dd></dl></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">清单</font> <font size="2" color="#0000c0">列表</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>私人</b></font> <font size="2">文字</font> <font size="2" color="#0000c0">第六场</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">FifthField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">fourthField</font></font> <font size="2"><font face="Courier">;</font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>private</b></font> <font size="2">Text</font> <font size="2" color="#0000c0">thirdField</font></font> <font size="2"><font face="Courier">;<br>
 </font>
					<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>public</b></font> <font size="2">ChildComposite（Composite parent，</font> <font size="2" color="#7f0055"><b>int</b></font></font> <font size="2"><font face="Courier">style）{</font><dl>
						<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>超级</b></font> <font size="2"><font face="Courier">（父母，风格）;</font><dd><font face="Courier">}<br>
 </font></dd>
					<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>上市</b></font> <font size="2">
					</font> <font size="2" color="#7f0055"><b>void</b></font></font> <font size="2"><font face="Courier">createContents（）{</font><dl>
						<dd></dd></dl></font> <font size="2" color="#7f0055" face="Courier"><b>super</b></font> <font size="2"><font face="Courier">.createContents（）;<br>
 </font>
						<dd><font face="Courier"><span style="background-color:#ffff99">setFirstFieldBackground（显示<i>。getCurrent（）.getSystemColor（SWT。</i></span></font></dd></font> <font size="2" color="#0000c0" face="Courier"><i><span style="background-color:#ffff99">COLOR_YELLOW</span></i></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">））;</span></font><dd><font face="Courier"><span style="background-color:#ffff99">setBrowseButtonText（</span></font></dd></font> <font size="2" color="#2a00ff" face="Courier"><span style="background-color:#ffff99">“找......”</span></font> <font size="2"><font face="Courier"><span style="background-color:#ffff99">）;</span><br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>final</b></font> <font size="2">GridLayout gridLayout =</font> <font size="2" color="#7f0055"><b>new</b></font></font> <font size="2"><font face="Courier">GridLayout（）;</font><dd><font face="Courier">网格布局。</font></dd></font> <font size="2" color="#0000c0" face="Courier">numColumns</font> <font size="2"><font face="Courier">= 2;</font><dd><font face="Courier"><span style="background-color:#ffff99">。getComposite（）的setLayout（GridLayout的）;</span><br>
 </font></dd>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签thirdFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">thirdFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第三场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">thirdField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_thirdField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">thirdField</font> <font size="2"><font face="Courier">.setLayoutData（gd_thirdField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签fourthFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">fourthFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第四场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">fourthField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（getComposite（），SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_fourthField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">fourthField</font> <font size="2"><font face="Courier">.setLayoutData（gd_fourthField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">名单</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">名单（getComposite（），SWT</font> <font size="2" color="#0000c0"><i>的边界</i></font> <font size="2"><font size="2"><font face="Courier">。）;</font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">list</font> <font size="2">.setItems（</font> <font size="2" color="#7f0055"><b>new</b></font> <font size="2">String [] {</font> <font size="2" color="#2a00ff">“First Item”</font> <font size="2">，</font> <font size="2" color="#2a00ff">“Second Item”</font></font> <font size="2"><font face="Courier">}）;</font><dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">列出</font> <font size="2">.setLayoutData（</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">FILL，FALSE，TRUE，2，1））;</b></font></font></b></font></font></i></font></font></font></font><br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签fifthFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">fifthFieldLabel.setLayoutData（</font></dd></font> <font size="2" color="#7f0055" face="Courier"><b>new</b></font> <font size="2"><font face="Courier">GridData（））;</font><dd><font face="Courier">fifthFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第五场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">fifthField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_fifthField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE，2，1）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">fifthField</font> <font size="2"><font face="Courier">.setLayoutData（gd_fifthField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">标签sixthFieldLabel =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">标签（在</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">sixthFieldLabel.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“第六场”</font> <font size="2"><font face="Courier">）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#0000c0">sixthField</font> <font size="2">=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">文本（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">BORDER）;</font></i></font></font></font><dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">的GridData gd_sixthField =</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">的GridData（SWT</font> <font size="2"><font size="2" color="#0000c0"><i>FILL，SWT</i></font> <font size="2"><font size="2" color="#0000c0"><i><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font size="2" color="#7f0055"><b><font size="2"><font face="Courier">CENTER，TRUE，FALSE）;</font></b></font></font></b></font></font></i></font></font></font></font><dd></dd></font> <font size="2" color="#0000c0" face="Courier">sixthField</font> <font size="2"><font face="Courier">.setLayoutData（gd_sixthField）;<br>
 </font>
						<dd></dd></font> <font face="Courier"><font size="2" color="#7f0055"><b>最终</b></font> <font size="2">按钮搜索按钮=</font> <font size="2" color="#7f0055"><b>新</b></font> <font size="2">按钮（</font> <font size="2" color="#7f0055"><b>此</b></font> <font size="2">，SWT <font size="2" color="#0000c0"><i><font size="2"><font face="Courier">NONE）;</font></i></font></font></font><dd><font face="Courier">searchButton.setText（</font></dd></font> <font size="2" color="#2a00ff" face="Courier">“搜索......”</font> <font size="2"><font face="Courier">）;</font><dd><font face="Courier">}</font></dd>
				
				
				<dd><font face="Courier">}</font></dd>
			
			</font>
				</td>
			</tr>
			</table>
	</div>
          </body>
</html><html id="2920.org_eclipse_ui_navigator_viewer.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>通用查看器配置</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">通用查看器配置</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.navigator.viewer<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p><b>viewer</b>元素定义了公共查看器的配置。扩展可以提供自定义弹出菜单id，覆盖查看者是否提供与编辑器支持的链接，提供过滤器对话框，和/或提供“过滤器和定制”对话框。此外，嵌套配置元素可以完全控制弹出上下文菜单的结构和行为。
</p><p>
<b>viewerContentBinding</b>将定义的内容扩展（通过<b>navigatorContent</b>扩展点）绑定到查看者。 <b>viewerContentBinding</b>还将<b>linkHelper</b>扩展点绑定到查看器。绑定到查看器的任何内容扩展都被描述为<i>可见</i> 。内容服务（ <code>org.eclipse.ui.navigator.INavigatorContentService</code> ）不会返回任何对其查看者ID不可见的扩展名。</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.viewer">viewer</a> *， <a href="#e.viewerContentBinding">viewerContentBinding</a> *， <a href="#e.viewerActionBinding">viewerActionBinding</a> *， <a href="#e.dragAssistant">dragAssistant</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewer">查看器</a> （ <a href="#e.popupMenu">popupMenu</a> ?, <a href="#e.options">选项</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST观众</p>
<p class="code SchemaDtdAttlist">viewerId CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">popupMenuId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">inheritBindingsFromViewer IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContext CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">提供基本配置以建立查看器的特征。客户端还必须定义<b>org.eclipse.ui.views</b>扩展以创建视图部件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>viewerId</b> - 公共查看器的ID。如果查看器位于公共导航器中，则id必须与其<b>org.eclipse.ui.views</b>扩展中定义的导航器ID相匹配。</li>
<li><b>popupMenuId</b> - 已定义查看器的popupMenuId。如果未指定，则popupMenuId默认为查看器的id。客户端可以仅指定“popupMenuId”或<b>popupMenu</b>元素，但不能同时指定两者。插入点的默认列表在<b>popupMenu</b>元素的文档中声明。</li>
<li><b>inheritBindingsFromViewer</b> - 使此查看器使用指定查看器的所有操作和内容绑定。</li>
<li><b>helpContext</b> - 与与查看器关联的Control关联的帮助上下文ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewerContentBinding">viewerContentBinding</a> （ <a href="#e.includes">包括</a> ？， <a href="#e.excludes">排除</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST viewerContentBinding</p>
<p class="code SchemaDtdAttlist">viewerId CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">客户端必须定义一个或多个<b>viewerContentBinding</b>元素，以描述查看器<i>可以看到</i>哪些内容扩展，常用过滤器和链接助手。如果内容扩展或公共过滤器的id与<b>viewerContentBinding</b>下的<b>includes</b>语句匹配<b>且未</b>被<b>excludes</b>语句排除，则<i>可以看到</i>内容扩展或公共过滤器。如果内容扩展或公共过滤器对于查看者不<i>可见</i> ，则该扩展将永远不会被该查看者的内容服务请求内容，或者在可用过滤器对话框中呈现给用户。
<br><br>客户端可以定义<b>包含</b>元素以选择哪些扩展对于查看者<i>可见</i> ，并且类似地<b>排除</b>了<b>不</b>应该使查看者<i>可见的</i>扩展的元素。客户端可以进一步定义应该通过“isRoot”属性显式查询根元素（通过ITreeContentProvider.getElements（））的扩展。如果一个或多个<b>contentExtension</b>元素在<b>includes</b>语句中将“isRoot”设置为true，则只会查询那些根元素的扩展名。“isRoot”属性对排除项没有影响。
<br><br>查看器可以定义多个viewerContentBindings，并且它们的includes / exludes语句将被聚合以产生最终行为。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>viewerId</b> - 公共查看器的ID。如果查看器位于公共导航器中，则id必须与其<b>org.eclipse.ui.views</b>扩展中定义的导航器ID相匹配。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewerActionBinding">viewerActionBinding</a> （ <a href="#e.includes">包括</a> ？， <a href="#e.excludes">排除</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST viewerActionBinding</p>
<p class="code SchemaDtdAttlist">viewerId CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">客户端必须定义哪些操作提供者对其查看者可见。客户端可以定义<b>包含</b>元素以选择哪些扩展对于查看者可见，并且类似地<b>排除</b>了<b>不</b>应该使查看者可见的扩展的元素。
<br><br>查看器可能定义了多个<b>viewerActionBinding</b> ，并且它们的<b>includes</b> / <b>excludes</b>语句将被聚合以产生最终行为。
<br><br>对于未嵌套在<b>navigatorContent</b>定义下的<b>actionProvider</b>定义，客户端可以指定自定义ID。如果客户端未指定id，则id默认为“org.eclipse.ui.navigator.actionProvider。X”。对于希望<b>获取</b>没有特定id的<b>actionProvider的</b>客户端，客户端必须为默认id定义<b>viewerActionBinding</b> 。有关如何完成此操作，请参阅示例部分。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>viewerId</b> - 公共查看器的ID。如果查看器位于公共导航器中，则id必须与其<b>org.eclipse.ui.views</b>扩展中定义的导航器ID相匹配。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.includes">包括</a> （（ <a href="#e.contentExtension">contentExtension</a> +）|（ <a href="#e.actionExtension">actionExtension</a> +））&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">定义一组正则表达式，在查找与“viewerId”属性匹配的查看器的内容扩展时应包含这些正则表达式。当包含和排除语句相交时，exludes语句将优先。

<p>注意：这些是正则表达式而不是通配符。因此，如果要包含<code>com.mycompany.content*</code> ，则表达式为<code>com\.mycompany\.content.*</code> 。</p></div>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.excludes">排除</a> （（ <a href="#e.contentExtension">contentExtension</a> +）|（ <a href="#e.actionExtension">actionExtension</a> +））&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">定义一组正则表达式，在查找与“viewerId”属性匹配的查看器的内容扩展时应排除这些正则表达式。当包含和排除语句相交时，exludes语句将优先。为了有意义，这将是包含模式的一个子集。
            
<p>注意：这些是正则表达式而不是通配符。因此，如果要包含<code>com.mycompany.content*</code> ，则表达式为<code>com\.mycompany\.content.*</code> 。</p></div>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.contentExtension">contentExtension</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST contentExtension</p>
<p class="code SchemaDtdAttlist">模式CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">isRoot（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">表示内容扩展的id（或匹配模式），应由<code>ITreeContentProvider.getElements()</code>或<code>ITreeContentProvider.getChildren()</code>查询内容扩展，以供查看者的根目录或“可用过滤器”中用户可用的常用过滤器对话。
<br><br>客户端可以指定“isRoot”来选择特定的根扩展来覆盖扩展，否则这些扩展将为查看器输入元素启用（基于查看器输入元素的匹配的<b>triggerPoints</b>表达式）。
<br><br>有关更多信息，请参阅<b>viewerContentBinding</b>的文档。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>模式</b> - 可以使用其内容扩展ID精确选择内容扩展。客户端还可以使用正则表达式模式来选择具有与模式匹配的ID的任何内容扩展。
<p>模式是与唯一标识符匹配的正则表达式。请参阅<code>java.util.regex.的Java（tm）平台文档<code>java.util.regex.进一步细节的Pattern</code> 。</p></li>
<li><b>isRoot</b> - 值true表示内容扩展将提供根内容，并覆盖给定查看器的绑定内容扩展中定义的默认<b>triggerPoints</b>表达式。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.actionExtension">actionExtension</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST actionExtension</p>
<p class="code SchemaDtdAttlist">模式CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">表示应该给予上下文菜单和操作栏的贡献的操作扩展。
<br><br>有关更多信息，请参阅<b>viewerActionBinding</b>的文档。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>模式</b> - 可以使用其内容扩展ID精确选择内容扩展。客户端还可以使用正则表达式模式来选择具有与模式匹配的ID的任何内容扩展。
<p>模式是与唯一标识符匹配的正则表达式。请参阅<code>java.util.regex.的Java（tm）平台文档<code>java.util.regex.进一步细节的Pattern</code> 。</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.popupMenu">popupMenu</a> （ <a href="#e.insertionPoint">insertionPoint</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST popupMenu</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">allowsPlatformContributions（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">如果未指定<b>viewer</b>元素的“popupMenuId”属性，则只能定义popupMenu元素。
<br><br><b>popupMenu</b>元素允许进一步自定义与查看器关联的上下文菜单。要正确应用选项，查看器的实例必须委托给<code>org.eclipse.ui.navigator.NavigatorActionService</code> ，其行为类似于普通的<code>org.eclipse.ui.ActionGroup</code> 。有关利用此功能的更多信息，请参阅此API类的文档。对于使用<code>org.eclipse.ui.navigator.实例的客户端<code>org.eclipse.ui.navigator.CommonNavigator</code>不需要做任何额外的工作。
<br><br><b>popupMenu</b>声明一个或多个<b>insertPoints</b> ，供贡献者使用它们将其贡献组织成一个有意义的，更加用户友好的，一致的列表。
<br>如果客户端只指定<b>观众</b>元素的“popupMenuId”属性，然后设置的上下文菜单中使用<b>insertionPoints</b>的将默认为给定的顺序如下表：<br>
</p><pre class="Example"><span class="code SchemaTag">“group.new”separator =“true”“group.goto”“group.open”separator =“true”“group.openWith”“group.show”separator =“true”“group.edit”separator =“true” “group.reorganize”“group.port”“group.generate”separator =“true”“group.search”separator =“true”“group.build”separator =“true”“additions”separator =“true”“group” .properties“separator =”true“</span></pre>
<br><br>希望以编程方式引用这些值的客户端可以使用<code>org.eclipse.ui.navigator.的相应常量<code>org.eclipse.ui.navigator.ICommonMenuConstants</code> 。
<br><br>我们鼓励希望自定义菜单的客户端从此列表开始，并根据需要添加或删除插入点。还鼓励客户遵循以“组”开始每个组名的模式。
<br><br>如果指定了<b>popupMenu</b>元素并且包含NO <b>insertionPoint</b>子元素，则上下文菜单将没有已发布的插入点。当然，程序化客户端不会在必要时添加自己的插入点。鼓励定义查看者的客户端发布其插入点以用于文档目的，并明确其查看者/导航器的下游扩展，或明确记录哪些插入点被视为API以及哪些插入点被视为内部。
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 菜单的ID。具有与<b>查看器</b>的“popupMenuId”属性相同的功能，但如果使用<b>popupMenu</b>嵌套元素，则必须使用此“popupMenuId”属性，而不指定<b>查看器</b>的“popupMenuId”。</li>
<li><b>allowsPlatformContributions</b> - 值为<b>true</b>将为<b>org.eclipse.ui.popupMenus</b>扩展点声明的对象或查看器贡献注册声明的<b>popupMenu</b> （按id）。值为<b>false</b>会将popupMenu限制为<code>org.eclipse.ui.navigator.声明的编程贡献<code>org.eclipse.ui.navigator.CommonActionProviders</code> （请参阅<b>org.eclipse.ui.navigator.navigatorContent / actionProvider</b>和<b>org.eclipse.ui.navigator.navigatorContent / navigatorContent / actionProvider</b> ）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.insertionPoint">insertionPoint</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST插入点</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">separator（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">定义上下文菜单的插入点。包含客户端要引用的点的名称，以及插入点是应该呈现为分隔符还是组标记。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 表示插入点的名称。当通过<code>org.eclipse.ui.navigator.提供程序化贡献时，客户端将使用该名称将插入点称为菜单路径的一部分<code>org.eclipse.ui.navigator.CommonActionProvider</code>或通过<b>org.eclipse.ui.popupMenus</b>扩展点的声明性贡献。</li>
<li><b>separator</b> - 值true将导致插入点在菜单中表示为条形。这允许客户端根据它们与用户的相关性在上下文菜单中可视地对项目进行分组。默认情况下，该值为<b>false</b> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.options">选项</a> （ <a href="#e.property">属性</a> +）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">为查看者提供选项，以自定义如何向用户显示。请参阅<code>org.eclipse.ui.navigator.INavigatorViewerDescriptor</code>获取可用属性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.property">属性</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST财产</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">提供名称=值对。该值将按原样提供给查看器（因此空字符串将作为空字符串传播）。请参阅<code>org.eclipse.ui.navigator.INavigatorViewerDescriptor</code>获取可用属性及其描述。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>名字</b> -</li>
<li><b>价值</b> -</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dragAssistant">dragAssistant</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST dragAssistant</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">viewerId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">拖放助手提供轻量级挂钩，以提供额外的传输类型和逻辑来设置拖动数据。该元素不是基本的<b>org.eclipse.ui.navigator。CommonViewer</b>提供了一个<b>org.eclipse.jface.util。LocalSelectionTransfer</b>类型。
<br><br>
<b>客户端应该只在具有浅依赖树的轻量级插件中定义此扩展。在创建查看器时，必须预先加载拖动助手，这将强制受影响的插件加载。
</b></p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 提供<code>org.eclipse.ui.navigator.的实现<code>org.eclipse.ui.navigator.CommonDragAdapterAssistant</code> 。</li>
<li><b>viewerId</b> - 将此拖动助手与特定的查看者ID相关联。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>以下示例配置查看器的弹出菜单ID。
</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewer id =</span> <span class="code SchemaCstring">“org.eclipse.testViewer”</span> <span class="code SchemaTag">popupMenuId =</span> <span class="code SchemaCstring">“org.eclipse.testViewer＃PopupMenu”</span> <span class="code SchemaTag">/&gt; &lt;/ extension&gt;</span></pre>

<p>由于上面的示例中未使用查看器的<b>popupMenu</b>子元素，因此将使用默认的<b>insertPoints</b>集。该组定义如下。有关更多信息，请参阅<b>popupMenu</b>元素的文档。
</p><p>
</p><pre class="Example"><span class="code SchemaTag">“group.new”separator =“true”“group.goto”“group.open”separator =“true”“group.openWith”“group.show”separator =“true”“group.edit”separator =“true” “group.reorganize”“group.port”“group.generate”separator =“true”“group.search”separator =“true”“group.build”separator =“true”“additions”separator =“true”“group” .properties“separator =”true“</span></pre>

<p>以下示例演示了一个查看器配置，该配置声明了自定义<b>popupMenu / insertionPoints</b> ，但使用“allowsPlatformContributions”属性限制了对象和查看器的贡献。客户端可能只通过<code>org.eclipse.ui.navigator.对定义的菜单做出贡献<code>org.eclipse.ui.navigator.为查看器声明的CommonActionProvider</code> （顶级或与内容扩展相关联）。
</p><p>请注意，不会使用<b>popupMenu</b>元素同时指定“popupMenuId”属性。只有一个或另一个，但不是两个，都是有效的配置。
</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewer viewerId =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.resourceContent”</span> <span class="code SchemaTag">&gt; &lt;popupMenu allowsPlatformContributions =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator。 resourceContent＃PopupMenu“</span> <span class="code SchemaTag">&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”group.new“</span> <span class="code SchemaTag">/&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”group.open“</span> <span class="code SchemaTag">separator =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”group.openWith“</span> <span class="code SchemaTag">/&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”group。 port“</span> <span class="code SchemaTag">separator =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">separator =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;insertionPoint name =</span> <span class="code SchemaCstring">”group.properties“</span> <span class="code SchemaTag">separator =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;/ popupMenu&gt; &lt;/ viewer&gt; &lt;viewerContentBinding viewerId =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.resourceContent”</span> <span class="code SchemaTag">&gt; &lt;includes&gt; &lt;contentExtension pattern =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.resourceContent”</span> <span class="code SchemaTag">/&gt; &lt;/ includes&gt; &lt;/ viewerContentBinding&gt; &lt;/ extension&gt;</span></pre>


<p>以下示例声明一个内容扩展（id：“org.eclipse.ui.navigator.resourceContent”）绑定到与id“org.eclipse.ui.navigator.resourceContent”匹配的查看器。（在此示例中，内容扩展和查看器ID匹配，但这不是必需的。）
</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewerContentBinding viewerId =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.resourceContent”</span> <span class="code SchemaTag">&gt; &lt;includes&gt; &lt;contentExtension pattern =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.resourceContent”</span> <span class="code SchemaTag">/&gt; &lt;/ includes&gt; &lt;/ viewerContentBinding&gt; &lt;/ extension&gt;</span></pre>

<p>以下示例为所有与正则表达式“org.acme.actions。*”匹配但不是“org.acme.actions.tests。*”的<b>actionProvider</b> （未嵌套在<b>navigatorContent</b>扩展<b>名下）</b>声明了<b>viewerActionBinding</b> 。该表达式将使任何以“org.acme.actions”开头的<b>actionProvider</b> 。但不是“org.acme.actions.tests。”使用id“org.acme.viewer”对查看器<i>可见</i> 。当然， <b>viewerActionBindings</b>仅适用于未嵌套在<b>navigatorContent</b>元素下的<b>actionProvider</b>元素。嵌套的<b>actionProvider</b>元素的<i>可见性</i>由封闭的<b>navigatorContent</b>元素的<b>viewerContentBindings</b>控制。
</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewerActionBinding viewerId =</span> <span class="code SchemaCstring">“org.acme.viewer”</span> <span class="code SchemaTag">&gt; &lt;includes&gt; &lt;actionExtension pattern =</span> <span class="code SchemaCstring">“org.acme.actions。*”</span> <span class="code SchemaTag">/&gt; &lt;/ includes&gt; &lt;excludes&gt; &lt;actionExtension pattern =</span> <span class="code SchemaCstring">“org.acme.actions.tests。*”</span> <span class="code SchemaTag">/&gt; &lt;/ excludes&gt; &lt;/ viewerActionBinding&gt; &lt;/ extension&gt;</span></pre>

<p>以下示例使任何没有“id”属性的actionProvider对查看器“org.acme.viewer” <i>可见</i> 。没有“id”属性的<b>actionProvider</b>的默认id为“org.eclipse.ui.navigator.actionProvider”。X”。当然， <b>viewerActionBindings</b>仅适用于未嵌套在<b>navigatorContent</b>元素下的<b>actionProvider</b>元素。嵌套的<b>actionProvider</b>元素的<i>可见性</i>由<b>viewerContentBinding</b>控制，用于封闭的<b>navigatorContent</b>元素。

</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewerActionBinding viewerId =</span> <span class="code SchemaCstring">“org.acme.viewer”</span> <span class="code SchemaTag">&gt; &lt;includes&gt; &lt;actionExtension pattern =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.actionProvider。*”</span> <span class="code SchemaTag">/&gt; &lt;/ includes&gt; &lt;/ viewerActionBinding&gt; &lt;/ extension&gt;</span></pre>


<p>以下示例演示了查看器可用的标准属性。
</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.viewer”</span> <span class="code SchemaTag">&gt; &lt;viewer popupMenuId =</span> <span class="code SchemaCstring">“org.eclipse.ui.tests.navigator。TestView＃PopupMenu“</span> <span class="code SchemaTag">viewerId =</span> <span class="code SchemaCstring">”org.eclipse.ui.tests.navigator。TestView“</span> <span class="code SchemaTag">&gt; &lt;options&gt; &lt;！ - 隐藏</span> <span class="code SchemaCstring">”过滤器和自定义“</span> <span class="code SchemaTag">对话框中</span> <span class="code SchemaTag">的</span> <span class="code SchemaCstring">”可用扩展“</span> <span class="code SchemaTag">选项卡</span> <span class="code SchemaTag">（可从</span> <span class="code SchemaCstring">”过滤器“</span> <span class="code SchemaTag">操作 - &gt; &lt;属性名称=</span> <span class="code SchemaCstring">”org.eclipse.ui.navigator.hideAvailableExtensionsTab获得“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;！ - 完全隐藏</span> <span class="code SchemaCstring">”过滤器和自定义“</span> <span class="code SchemaTag">对话框。这包括隐藏过滤器和可用的内容扩展。 - &gt; &lt;property name =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.hideAvailableCustomizationsDialog”</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">/&gt; &lt;！ -</span> <span class="code SchemaTag">从查看器的工具栏中</span> <span class="code SchemaTag">隐藏</span> <span class="code SchemaCstring">“使用编辑器链接”</span> <span class="code SchemaTag">操作 - &gt; &lt;property name =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator.hideLinkWithEditorAction”</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">/&gt; &lt;！ - 隐藏</span> <span class="code SchemaTag">查看器工具栏中</span> <span class="code SchemaTag">的</span> <span class="code SchemaCstring">“全部折叠”</span> <span class="code SchemaTag">操作 - &gt; &lt;property name =</span> <span class="code SchemaCstring">“org.eclipse.ui.navigator .hideCollapseAllAction“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;/ options&gt; &lt;/ viewer&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2009 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="1755.Overview-of-the-Atlas-Transformation-Language.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>ATL用户指南 -  Atlas转换语言概述</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">Atlas转换语言概述</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Installation.html" title="安装">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="The-ATL-Language.html" title="ATL语言">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">安装</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">ATL语言</td>
			</tr>
		</table><hr>
		<h1 id="Overview_of_the_Atlas_Transformation_Language">Atlas转换语言概述</h1>
		<p>ATL语言为ATL开发人员提供了不同类型的ATL单元。ATL单元，无论其类型如何，都在其自己独特的ATL文件中定义。ATL文件的特征是<i>.atl</i>扩展名。
		</p>
		<p>作为<a href="http://www.omg.org/docs/formal/02-04-03.pdf">OMG MOF</a> / <a href="http://www.omg.org/docs/ad/02-04-10.pdf">QVT RFP</a>的答案，ATL主要关注模型转换模型。可以通过ATL <i>模块</i>指定这种模型操作。除了模块之外，ATL转换语言还使开发人员能够为原始数据类型程序创建模型。这些单位称为ATL <i>查询</i> 。查询的目的是从源模型计算<a href="The-ATL-Language.html#Primitive_data_types" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃Primitive_data_types">原始</a>值，例如字符串或整数。最后，ATL语言还提供了开发独立ATL <i>库</i>的可能性，这些<i>库</i>可以从不同类型的ATL单元导入，包括库本身。这提供了一种方便的方法来分解在多个ATL单元中使用的ATL代码。请注意，三个ATL单元种类相同，共享<i>.atl</i>扩展名。
		</p>
		<p>这些不同的ATL单元在以下小节中详述。本节介绍了每种单元的用途，并概述了这些不同单元的内容。</p>
		<h2 id="Examples_metamodels">示例元模型</h2>
		<p>本节提供了两个简单的元模型，这些元模型将在本指南中用于演示ATL语法和用法。</p>
		<h3 id="Author_metamodel">作者元模型</h3>
		<p>
			<img border="0" src="images/Author_metamodel.png">
		</p>
		<h3 id="Person_metamodel">人元模型</h3>
		<p>
			<img border="0" src="images/Person_metamodel.png">
		</p>
		<h3 id="Biblio_metamodel">Biblio元模型</h3>
		<p>
			<img border="0" src="images/Biblio_metamodel.png">
		</p>
		<h2 id="ATL_module">ATL模块</h2>
		<p>ATL模块对应于模型转换的模型。这种ATL单元使ATL开发人员能够指定从一组源模型生成一组目标模型的方法。ATL模块的源模型和目标模型都必须由它们各自的元模型“键入”。此外，ATL模块接受固定数量的模型作为输入，并返回固定数量的目标模型。因此，ATL模块不能生成未知数量的类似目标模型（例如，符合相同元模型的模型）。</p>
		<h3 id="Structure_of_an_ATL_module">ATL模块的结构</h3>
		<p>ATL模块定义了模型转换模型。它由以下元素组成：</p>
		<ul>
			<li>标题部分，定义了与转换模块相关的一些属性;</li>
			<li>一个可选的导入部分，可以导入一些现有的<a href="Overview-of-the-Atlas-Transformation-Language.html#ATL_Library">ATL库</a> ;</li>
			<li>一组帮助程序，可以被视为与Java方法等效的ATL;</li>
			<li>一组规则，用于定义从源代码模型生成目标模型的方式。</li>
		</ul>
		<p>助手和规则不属于ATL转换中的特定部分。它们可以根据某些条件以任何顺序声明（有关详细信息，请参阅<a href="The-ATL-Language.html#ATL_Helpers" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃ATL_Helpers">ATL助手</a>部分）。现在将在以下小节中详细介绍这四种不同的元素类型。
		</p>
		<h4 id="Header_section">标题部分</h4>
		<p>标题部分定义转换模块的名称以及与源模型和目标模型对应的变量的名称。它还编码模块的执行模式。标题部分的语法定义如下：</p>
		<pre>module module_name; create output_models [from | refining] input_models;</pre>
		<p>关键字<i>模块</i>引入了<i>模块</i>的名称。请注意，包含模块代码的ATL文件的名称必须与此模块的名称相对应。例如，必须将ModelA2ModelB转换模块定义到<i>ModelA2ModelB</i> .atl文件中。目标模型声明由<i>create</i>关键字引入，而源模型由关键字<i>from</i> （在正常模式下）或<i>精炼</i> （在精炼转换的情况下）引入。模型的声明（源输入或目标<i>模型）</i>必须符合方案<i>model_name：metamodel_name</i> 。通过简单地用声码分隔声明的模型，可以声明多个输入或输出模型。请注意，声明的模型的名称将用于标识它们。因此，每个声明的模型名称必须在声明的模型集（输入和输出模型）中是唯一的。以下ATL源代码表示<i>Book2Publication.atl</i>文件的标头，例如，用于从Book元模型到Publication元模型的<a href="http://www.eclipse.org/m2m/atl/atlTransformations/#Book2Publication">转换</a>的ATL标头：</p>
		<pre>模块Book2Publication;创建OUT：从IN出版：书籍;</pre>
		<h4 id="Import_section">导入部分</h4>
		<p>可选的导入部分允许声明必须导入哪些<a href="Overview-of-the-Atlas-Transformation-Language.html#ATL_Library">ATL库</a> 。ATL库的声明如下：</p>
		<pre>使用extensionless_library_file_name;</pre>
		<p>例如，要导入字符串库，可以写：</p>
		<pre>使用字符串;</pre>
		<p>请注意，可以通过使用多个连续使用指令来声明几个不同的库。</p>
		<h4 id="Helpers">助手</h4>
		<p>可以将ATL帮助程序视为与Java方法等效的ATL。它们使得可以定义可以从ATL变换的不同点调用的分解ATL代码。ATL帮助程序由以下元素定义：</p>
		<ul>
			<li>名称（对应于方法的名称）;</li>
			<li>上下文类型。上下文类型定义了定义此属性的上下文（与在对象编程中给定类的上下文中定义方法的方式相同）;</li>
			<li>返回值类型。请注意，在ATL中，每个帮助程序必须具有返回值;</li>
			<li>表示ATL帮助程序代码的ATL表达式;</li>
			<li>一组可选参数，其中参数由一对（参数名称，参数类型）标识。</li>
		</ul>
		<p>例如，可以考虑一个返回最多两个整数值的辅助函数：上下文整数和作为参数传递的附加整数值。这样一个帮助器的声明看起来像（帮助代码的详细信息在这个阶段没有意义，请参阅<a href="The-ATL-Language.html#ATL_Helpers" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃ATL助手">ATL Helpers</a>部分了解更多详情）：</p>
		<pre>helper context Integer def：max（x：Integer）：Integer = ...;</pre>
		<p>也可以声明不接受任何参数的帮助程序。例如，这是一个帮助器只是将整数值乘以2的情况：</p>
		<pre>helper context Integer def：double（）：Integer = self * 2;</pre>
		<p>在某些情况下，能够在没有任何特定上下文的情况下声明ATL帮助程序可能会很有趣。这在ATL中是不可能的，因为每个帮助器必须与给定的上下文相关联。但是，ATL语言允许ATL开发人员在默认上下文（对应于ATL模块）中声明帮助程序。这是通过简单地省略辅助定义的上下文部分来实现的。通过这种方式，可以提供上面定义的max helper的新版本：</p>
		<pre>helper def：max（x1：Integer，x2：Integer）：Integer = ...;</pre>
		<p>请注意，在单个转换中，多个帮助程序可能具有相同的名称。但是，具有相同名称的帮助程序必须具有可由ATL引擎区分的不同签名（有关详细信息，请参阅<a href="The-ATL-Language.html#ATL_Helpers" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃ATL助手">ATL帮助程序</a>部分）。ATL语言还可以定义属性。属性助手是一种特定类型的助手，它不接受任何参数，并且在ATL模块或模型元素的上下文中定义。在本文件的剩余的，术语<i>属性</i>进行具体用于指代属性助手，而<i>辅助</i>的通用术语将是指官能帮手。因此，上面定义的双辅助器的属性版本将声明如下：</p>
		<pre>helper context Integer def：double：Integer = self * 2;</pre>
		<p>声明没有参数或属性的功能助手可能看起来是等效的。因此，从功能的角度来看，它是等同的。但是，在考虑执行语义时，这两种方法之间存在显着差异。实际上，与每次调用辅助函数时计算的函数帮助器的结果相比，ATL属性的返回值仅在第一次需要该值时计算一次。因此，声明ATL属性比定义将被执行多次的ATL帮助程序更有效。请注意，在ATL模块的上下文中定义的ATL属性按照它们在ATL文件中声明的顺序进行初始化（在<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics">初始化阶段</a> ）。这意味着这种属性的声明顺序非常重要：在ATL模块的上下文中定义的属性必须在它依赖于其初始化的其他ATL模块属性之后声明。ATL模块属性声明中的错误顺序将在ATL程序执行的初始化阶段引发错误。
		</p>
		<h4 id="Rules">规则</h4>
		<p>在ATL中，存在三种不同类型的规则，它们对应于ATL提供的两种不同的编程模式（例如声明性和命令式编程）：匹配规则（声明性编程），惰性规则和被调用规则（命令式编程）。</p>
		<p>
			<b>匹配规则</b> 。匹配的规则构成了ATL声明性转换的核心，因为它们可以指定：</p>
		<p>1）必须生成哪些源元素目标元素，</p>
		<p>2）必须初始化生成的目标元素的方式。</p>
		<p>匹配的规则由其名称标识。它匹配给定类型的源模型元素，并生成一种或多种目标模型元素。该规则指定必须从每个匹配的源模型元素初始化生成的目标模型元素的方式。关键字<i>规则</i>引入匹配<i>规则</i> 。它由两个强制（源和目标模式）和两个可选（局部变量和命令）部分组成。定义时，关键字<i>using使用</i>引入局部变量部分。它允许在本地声明和初始化许多局部变量（只在当前规则的范围内可见）。匹配规则的源模式在关键字<i>from</i>之后定义。它允许指定与规则必须匹配的源元素类型相对应的模型元素变量。此类型对应于转换的源元模型的实体。这意味着该规则将为符合此匹配类型的每个源模型元素生成目标元素。在许多情况下，开发人员只对匹配符合匹配类型的源元素的子集感兴趣。这可以通过在规则源模式中指定可选条件（表示为ATL表达式，请参阅<a href="The-ATL-Language.html#OCL_Declarative_Expressions" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃OCL_Declarative_Expressions">OCL声明表达式</a>部分以获取更多详细信息）来实现。通过这种方式，规则将仅生成源模型元素的目标元素，这些元素既符合匹配类型又验证指定条件。
		</p>
		<p>匹配规则的目标模式由关键字<i>to</i>引入。它旨在指定在匹配规则的源模式时生成的元素，以及如何初始化这些生成的元素。因此，匹配规则的目标模式为规则在其源模式匹配时必须生成的每个目标模型元素指定不同的目标模式元素。目标模式元素对应于与其对应的初始化绑定集相关联的模型元素变量声明。此模型元素变量声明必须对应于转换的目标元模型的实体。
		</p>
		<p>最后，由关键字<i>do</i>引入的可选命令部分使得可以指定将在规则生成的目标元素的初始化之后执行的一些命令性代码。例如，考虑两个元模型<a href="Overview-of-the-Atlas-Transformation-Language.html#Author_metamodel">MMAuthor</a>和<a href="Overview-of-the-Atlas-Transformation-Language.html#Person_metamodel">MMPerson</a>之间的以下简单ATL匹配规则：</p>
		<pre>规则作者{来自：MMAuthor！作者：p：MMPerson！人（姓名&lt; -  a.name，姓氏&lt; -  a.surname）}</pre>
		<p>此规则称为Author，旨在将作者源模型元素（从MMAuthor源模型）转换为MMPerson目标模型中的Person目标模型元素。此规则仅包含强制源和目标模式。源模式不定义过滤器，这意味着源MMAuthor模型的所有Author类都将与规则匹配。规则目标模式包含单个简单目标模式元素（称为<i>p</i> ）。此目标模式元素旨在为源模式匹配的每个源模型元素分配MMPerson目标模型的Person类。生成的模型元素的特征用匹配的源模型元素的相应特征初始化。请注意，ATL转换的源模型元素不应与多个ATL匹配规则匹配。这意味着要仔细设计匹配规则的源模式以尊重此约束。此外，ATL匹配规则不能生成ATL原始类型值。
		</p>
		<p>
			<b>懒惰的规则</b> 。延迟规则与匹配规则类似，但仅在其他规则调用时应用</p>
		<p>
			<b>被称为规则</b> 。被调用的规则为ATL开发人员提供了方便的命令式编程工具。被调用的规则可以被视为特定类型的帮助程序：它们必须被显式调用才能执行，并且它们可以接受参数。但是，与帮助程序相反，被调用的规则可以生成匹配规则的目标模型元素。必须从命令性代码部分调用被调用的规则，该规则来自匹配规则或另一个被调用的规则。
		</p>
		<p>作为匹配规则，关键字规则引入被调用规则。作为匹配的<i>规则</i> ，被调用的规则可以包括可选的局部变量部分。但是，由于它不必匹配源模型元素，因此被调用的规则不包括源模式。此外，其可以生成目标模型元素的目标模式也是可选的。请注意，由于被调用规则与任何源模型元素都不匹配，因此目标模式生成的目标模型元素的初始化必须基于局部变量，参数和模块属性的组合。被调用规则的目标模式的定义方式与匹配规则的目标模式相同。它还通过关键字<i>来</i>介绍。被调用的规则也可以有一个命令性部分，类似于可以在匹配规则中定义的部分。请注意，此命令性代码部分不是必需的：可以指定仅包含目标模式部分或命令性代码部分的被调用规则。为了说明被调用的规则结构，请考虑以下简单示例：</p>
		<pre>规则NewPerson（na：String，s_na：String）{to p：MMPerson！人（姓名&lt; -  na）做{p.surname &lt; -  s_na}}</pre>
		<p>这个名为NewPerson的调用规则旨在生成Person目标模型元素。该规则接受两个参数，这两个参数对应于将由规则执行创建的Person模型元素的名称和姓氏。该规则具有目标模式（称为<i>p''）和命令性代码部分。每次调用规则时，目标模式都会分配一个Person类，并初始化</i>已分配模型元素的'name</i>属性。命令性代码部分在已分配元素的初始化之后执行（有关<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics">执行语义</a>的更多详细信息，请参阅<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics">缺省模式执行语义</a>部分）。在此示例中，命令性代码将生成的Person模型元素的<i>surname</i>属性设置为参数<i>s_na</i>的值。
		</p>
		<h3 id="Module_execution_modes">模块执行模式</h3>
		<p>ATL执行引擎为ATL模块定义了两种不同的执行模式。使用默认执行模式，ATL开发人员必须明确指定必须从源模型元素生成目标模型元素的方式。在这个范围内，旨在通过一些修改来复制其源模型的转换设计可能会非常令人厌烦。因此，在默认执行模式下设计此转换需要开发人员指定将生成修改后的模型元素的规则，还要求所有规则仅复制目标模型元素，而不进行任何修改。精炼执行模式是针对这种情况设计的：它使ATL开发人员只能指定必须在转换源和目标模型之间执行的修改。这两种执行模式将在以下小节中介绍。</p>
		<h4 id="Normal_execution_mode">正常执行模式</h4>
		<p>正常执行模式是ATL模块的默认执行模式。它与模块<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section">标题中</a>的关键字<i>from</i>相关联。在默认执行模式下，ATL开发人员必须通过匹配或调用规则指定生成每个预期目标模型元素的方法。此执行模式适用于大多数ATL转换，其中目标模型与源模型不同。
		</p>
		<h4 id="Refining_execution_mode">精炼执行模式</h4>
		<p>引入了精炼执行模式以简化类似源模型和目标模型之间的精炼转换的编程。通过精炼模式，ATL开发人员可以专注于专用于生成修改后的目标元素的ATL代码。其他模型元素（例如，在源模型和目标模型之间保持不变的模型元素）由ATL引擎从源模式隐式复制到目标模型。精炼模式与ATL模块的<a href="Overview-of-the-Atlas-Transformation-Language.html#Header_section">标题</a>中的关键字<i>精炼</i>相关联。精炼模式的粒度在模型元素级别定义。这意味着一旦转换修改了其中一个特征（属性或引用），开发人员就必须指定如何生成模型元素。另一方面，开发人员不需要指定与未更改的模型元素的副本对应的ATL代码。该特征可以导致ATL代码的重要保存，这最终使得改进ATL变换的编程更简单和容易。目前，精炼模式只能用于将单个源模型转换为单个目标模型。源模型和目标模型都必须符合相同的元模型。
		</p>
		<h3 id="Module_execution_semantics">模块执行语义</h3>
		<p>本节介绍ATL执行语义的基础知识。虽然设计ATL转换不需要任何关于ATL执行语义的特定知识，但理解ATL引擎处理ATL转换的方式在某些情况下（特别是在调试转换时）可能会有所帮助。</p>
		<p>两个可用的ATL执行模式（正常模式和精炼模式）的语义在以下小节中介绍。</p>
		<h4 id="Default_mode_execution_semantics">默认模式执行语义</h4>
		<p>ATL模块的执行分为三个连续阶段：</p>
		<ul>
			<li>模块初始化阶段，</li>
			<li>源模型元素的匹配阶段，</li>
			<li>目标模型元素初始化阶段。</li>
		</ul>
		<p>模块初始化步骤对应于ATL模块的执行的第一阶段。在此阶段，初始化在转换模块的上下文中定义的属性。请注意，这些模块属性的初始化可以使用在源模型元素的上下文中定义的属性。这意味着在模块初始化阶段也要初始化这些新属性。如果在ATL模块的范围内定义了<a href="The-ATL-Language.html#Called_Rules" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃被叫规则">称为规则</a>的入口点，则在初始化ATL模块属性之后执行该规则的代码（包括目标模型元素生成）。
		</p>
		<p>在源模型元素匹配阶段期间，使用模块源模型的模型元素测试声明的匹配规则的匹配条件。当满足匹配规则的匹配条件时，ATL引擎分配对应于规则中声明的目标模式元素的一组目标模型元素。请注意，在此阶段，仅分配目标模型元素：它们在目标模型元素初始化阶段初始化。</p>
		<p>执行ATL模块的最后阶段对应于在前一步骤期间生成的目标模型元素的初始化。在此阶段，通过执行与元素来自的目标模式元素相关联的绑定的代码来初始化每个分配的目标模型元素。请注意，此阶段允许调用在ATL模块的上下文中定义的<a href="The-ATL-Language.html#The_ATL_Module_data_type" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃The_ATL_Module_data_type">resolveTemp（）</a>操作。在规则初始化步骤完成后，将执行可在匹配规则范围内指定的命令性代码部分。此命令性代码可以触发已在ATL模块范围内定义的某些被调用规则的执行。
		</p>
		<h4 id="Refining_mode_execution_semantics">精炼模式执行语义</h4>
		<p>ATL'2006编译器实现了精炼模式的就地版本。这意味着不会发生复制，并且更改将直接应用于源模型。</p>
		<h2 id="ATL_Query">ATL查询</h2>
		<p>ATL查询包含模型到<a href="The-ATL-Language.html#Primitive_data_types" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language＃原始数据类型">基元类型</a>值转换。可以将ATL查询视为从一组源模型计算原始值的操作。ATL查询的最常见用途是从一组源模型生成文本输出（编码为字符串值）。但是，ATL查询不仅限于字符串值的计算，还可以返回数值或布尔值。
		</p>
		<p>以下小节分别描述了ATL查询的结构和执行语义。</p>
		<h3 id="Structure_of_an_ATL_query">ATL查询的结构</h3>
		<p>在可选的<a href="Overview-of-the-Atlas-Transformation-Language.html#Import_section">导入</a>部分之后，ATL查询必须定义查询实例化。查询实例化由关键字查询引入，并指定必须通过ATL表达式计算其结果的方式：</p>
		<pre>query query_name = exp;</pre>
		<p>除了查询实例化之外，ATL查询还可以包括许多帮助器或属性定义。请注意，尽管ATL查询不是严格意义上的模块，但它定义了自己的默认模块上下文。因此，对于ATL开发人员，可以在ATL查询范围内声明在模块上下文中定义的帮助程序和属性。</p>
		<h3 id="Query_execution_semantics">查询执行语义</h3>
		<p>作为ATL模块，ATL查询的执行在几个连续阶段中组织。第一阶段是初始化阶段。它对应于ATL模块的<a href="Overview-of-the-Atlas-Transformation-Language.html#Default_mode_execution_semantics">初始化阶段</a> ，专用于初始化在ATL模块的上下文中定义的属性。
		</p>
		<p>执行ATL查询的第二阶段是计算阶段。在此阶段期间，通过执行ATL查询的查询元素的声明性代码来计算查询的返回值。请注意，可以在初始化和计算阶段调用已在查询文件中定义的帮助程序。</p>
		<h2 id="ATL_Library">ATL图书馆</h2>
		<p>最后一种类型的ATL单元是ATL库。开发ATL库可以定义一组ATL帮助程序，可以从不同的ATL单元（模块，还有查询和库）调用它们。</p>
		<p>作为其他类型的ATL单元，ATL库可以包括可选的<a href="Overview-of-the-Atlas-Transformation-Language.html#Import_section">导入部分</a> 。除了这个导入部分之外，ATL库定义了许多ATL帮助程序，这些辅助程序将在将导入库的ATL单元中提供。
		</p>
		<p>与ATL模块相比，ATL库没有默认模块元素。因此，在库中，不可能声明在模块的默认上下文中定义的帮助程序。这意味着ATL库中定义的所有助手必须与给定的上下文显式关联。</p>
		<p>与模块和查询相比，ATL库不能独立执行。这当前意味着库在执行时不与任何初始化步骤相关联（如<a href="Overview-of-the-Atlas-Transformation-Language.html#Module_execution_semantics">模块执行语义中所述</a> ）。由于缺少初始化步骤，无法在ATL库中定义属性助手。
		</p>
		<p></p><div style="display:none">=另见=</div>
<div style="display:none">* <a href="ATL User Guide.html#Introduction" title="ATL / ___ ATLPAGENAME ____-_简介">简介</a>
</div>
<div style="display:none">* <a href="Installation.html#Installation" title="ATL / ___ ATLPAGENAME ____-_安装">安装</a>
</div>
<div style="display:none">* <a href="The-ATL-Language.html#The_ATL_Language" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Language">ATL语言</a>
</div>
<div style="display:none">* <a href="The-ATL-Tools.html#The_ATL_Tools" title="ATL / ___ ATLPAGENAME ____-_ The_ATL_Tools">ATL工具</a>
</div>
		<hr>
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Installation.html" title="安装">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="ATL User Guide.html" title="ATL用户指南">
						<img alt="ATL用户指南" border="0" src="images/images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="The-ATL-Language.html" title="ATL语言">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">安装</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">ATL语言</td>
			</tr>
		</table>
	</body>
</html><html id="3175.Client.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 客户</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">输入客户端</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">基本客户端检测实现。

      </p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Client.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Client.html#constructor">客户</a></b> （）</div>
              <div class="description">版本名称遵循维基百科方案：major.minor [.revision [.build]]，网址为http://en.wikipedia.org/wiki/Software_version，可以从<a href="../symbols/rap.html#.getClient">rap.getClient</a>获取对象。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Client.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getBasePath">getBasePath</a></b> （）</div>
                <div class="description">返回应用程序基路径。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getBrowser">getBrowser</a></b> （）</div>
                <div class="description">返回浏览器的名称，例如“chrome”或“firefox”。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getBuild">getBuild</a></b> （）</div>
                <div class="description">返回浏览器引擎版本的内部版本号。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getDefaultLocale">getDefaultLocale</a></b> （）</div>
                <div class="description">返回浏览器默认语言环境。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getEngine">getEngine</a></b> （）</div>
                <div class="description">返回浏览器引擎的名称 - “trident”，“gecko”，“webkit”或“blink”。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getLanguage">getLanguage</a></b> （）</div>
                <div class="description">从浏览器语言环境返回语言部分。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getLocale">getLocale</a></b> （）</div>
                <div class="description">返回http://www.ietf.org/rfc/bcp/bcp47.txt中定义的浏览器语言环境。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getMajor">getMajor</a></b> （）</div>
                <div class="description">返回浏览器引擎版本的主要数量。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getMinor">getMinor</a></b> （）</div>
                <div class="description">返回浏览器引擎版本的次要编号。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getPlatform">getPlatform</a></b> （）</div>
                <div class="description">返回客户端平台，例如Windows，Android。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getRevision">getRevision</a></b> （）</div>
                <div class="description">返回浏览器引擎版本的修订版号。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getTerritory">getTerritory</a></b> （）</div>
                <div class="description">从浏览器区域设置返回区域部分。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getTimezoneOffset">getTimezoneOffset</a></b> （）</div>
                <div class="description">返回客户端时区。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.getVersion">getVersion</a></b> （）</div>
                <div class="description">返回浏览器引擎版本。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isAndroidBrowser">isAndroidBrowser</a></b> （）</div>
                <div class="description">如果浏览器是默认的Android浏览器，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isBlink">isBlink</a></b> （）</div>
                <div class="description">返回true是浏览器引擎“闪烁”（Chrome / Opera），否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isGecko">isGecko</a></b> （）</div>
                <div class="description">返回true是浏览器引擎是“gecko”（Firefox），否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isMobileChrome">isMobileChrome</a></b> （）</div>
                <div class="description">如果浏览器是移动Chrome，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isMobileFirefox">isMobileFirefox</a></b> （）</div>
                <div class="description">如果浏览器是移动Firefox，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isMobileSafari">isMobileSafari</a></b> （）</div>
                <div class="description">如果浏览器是移动Safari，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isTrident">isTrident</a></b> （）</div>
                <div class="description">返回true是浏览器引擎是“trident”（IE / Edge），否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.isWebkit">isWebkit</a></b> （）</div>
                <div class="description">返回true是浏览器引擎是“webkit”（Safari），否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.supportsCss3">supportsCss3</a></b> （）</div>
                <div class="description">如果浏览器支持CSS3，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.supportsFileDrop">supportsFileDrop</a></b> （）</div>
                <div class="description">如果浏览器支持文件丢弃，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.supportsTouch">supportsTouch</a></b> （）</div>
                <div class="description">如果浏览器支持触摸事件，则返回true，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes">&lt;静电&gt;</td>
              <td class="nameDescription">
                <div class="fixedFont">客户。 <b><a href="../symbols/Client.html#.usesDefaultLocale">usesDefaultLocale</a></b> （）</div>
                <div class="description">如果当前浏览器语言环境是默认语言环境，则返回true，否则返回false。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
      
<!-- ============================== events summary ======================== -->
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>客户</b> （）</div>

        <div class="description">版本名称遵循维基百科方案：major.minor [.revision [.build]]，网址为http://en.wikipedia.org/wiki/Software_version，可以从<a href="../symbols/rap.html#.getClient">rap.getClient</a>获取对象。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>3.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name=".getBasePath"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getBasePath</b> （）</div>
          <div class="description">返回应用程序基路径。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getBrowser"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getBrowser</b> （）</div>
          <div class="description">返回浏览器的名称，例如“chrome”或“firefox”。如果无法检测到浏览器名称，则此函数返回“unknown”。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getBuild"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getBuild</b> （）</div>
          <div class="description">返回浏览器引擎版本的内部版本号。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getDefaultLocale"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getDefaultLocale</b> （）</div>
          <div class="description">返回浏览器默认语言环境。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getEngine"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getEngine</b> （）</div>
          <div class="description">返回浏览器引擎的名称 - “trident”，“gecko”，“webkit”或“blink”。如果无法检测到浏览器引擎名称，则此函数返回“unknown”。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getLanguage"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getLanguage</b> （）</div>
          <div class="description">从浏览器语言环境返回语言部分。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getLocale"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getLocale</b> （）</div>
          <div class="description">返回http://www.ietf.org/rfc/bcp/bcp47.txt中定义的浏览器语言环境。</div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getMajor"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getMajor</b> （）</div>
          <div class="description">返回浏览器引擎版本的主要数量。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getMinor"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getMinor</b> （）</div>
          <div class="description">返回浏览器引擎版本的次要编号。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getPlatform"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getPlatform</b> （）</div>
          <div class="description">返回客户端平台，例如Windows，Android。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getRevision"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getRevision</b> （）</div>
          <div class="description">返回浏览器引擎版本的修订版号。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getTerritory"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getTerritory</b> （）</div>
          <div class="description">从浏览器区域设置返回区域部分。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getTimezoneOffset"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getTimezoneOffset</b> （）</div>
          <div class="description">返回客户端时区。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".getVersion"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>getVersion</b> （）</div>
          <div class="description">返回浏览器引擎版本。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isAndroidBrowser"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isAndroidBrowser</b> （）</div>
          <div class="description">如果浏览器是默认的Android浏览器，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isBlink"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isBlink</b> （）</div>
          <div class="description">返回true是浏览器引擎“闪烁”（Chrome / Opera），否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isGecko"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isGecko</b> （）</div>
          <div class="description">返回true是浏览器引擎是“gecko”（Firefox），否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isMobileChrome"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isMobileChrome</b> （）</div>
          <div class="description">如果浏览器是移动Chrome，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isMobileFirefox"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isMobileFirefox</b> （）</div>
          <div class="description">如果浏览器是移动Firefox，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isMobileSafari"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isMobileSafari</b> （）</div>
          <div class="description">如果浏览器是移动Safari，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isTrident"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isTrident</b> （）</div>
          <div class="description">返回true是浏览器引擎是“trident”（IE / Edge），否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".isWebkit"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>isWebkit</b> （）</div>
          <div class="description">返回true是浏览器引擎是“webkit”（Safari），否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".supportsCss3"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>supportsCss3</b> （）</div>
          <div class="description">如果浏览器支持CSS3，则返回true，否则返回false。注意：如果浏览器充分实现border-radius，drop-shadow和linear-gradient，则返回true。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".supportsFileDrop"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>supportsFileDrop</b> （）</div>
          <div class="description">如果浏览器支持文件丢弃，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".supportsTouch"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>supportsTouch</b> （）</div>
          <div class="description">如果浏览器支持触摸事件，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          <hr>
        
          <a name=".usesDefaultLocale"> </a>
          <div class="fixedFont">&lt;static&gt; <span class="light">客户端。</span> <b>usesDefaultLocale</b> （）</div>
          <div class="description">如果当前浏览器语言环境是默认语言环境，则返回true，否则返回false。
            
          </div>

          

            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="3857.330_web_support.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>Web编辑器支持</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="web-integration">Web编辑器支持</h1>

<p>从版本2.9开始，Xtext提供了一个用于在Web应用程序中集成文本编辑器的界面。文本编辑器以JavaScript实现，并且通过对服务器端组件的HTTP请求实现与代码完成等语言相关的服务。</p>

<h2 id="client">客户端</h2>

<p>Xtext支持三个JavaScript文本编辑器库：</p>

<ul>
  <li><a href="http://eclipse.org/orion/">猎户座</a></li>
  <li><a href="http://ace.c9.io">高手</a></li>
  <li><a href="http://codemirror.net">CodeMirror</a></li>
</ul>

<p>受支持的语言相关服务集取决于选择的编辑器库，如下表所示。</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th></th>
      <th>猎户座</th>
      <th>高手</th>
      <th>CodeMirror</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#content-assist">内容辅助</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="303_runtime_concepts.html#validation">验证</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="#syntax-highlighting">语法突出显示</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="#semantic-highlighting">语义突出显示</a></td>
      <td><div class="supported"></div></td>
      <td><div class="not-supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="#mark-occurrences">标记出现</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="#hover-info">悬停信息</a></td>
      <td><div class="supported"></div></td>
      <td><div class="not-supported"></div></td>
      <td><div class="not-supported"></div></td>
    </tr>
    <tr>
      <td><a href="303_runtime_concepts.html#formatting">格式化</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="303_runtime_concepts.html#code-generation">代码生成器</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
    <tr>
      <td><a href="#persistence">坚持</a></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
      <td><div class="supported"></div></td>
    </tr>
  </tbody>
</table>

<p>Xtext的JavaScript集成使用<a href="http://requirejs.org">RequireJS</a>来管理模块及其依赖项。主模块是<code>xtext/xtext-orion</code> ， <code>xtext/xtext-ace</code>或<code>xtext/xtext-codemirror</code> ，具体取决于使用的编辑器库。通过设置选项<code>generateHtmlExample = true</code>可以通过<code>WebIntegrationFragment</code>生成将这些库与Xtext一起加载的示例（请参阅<a href="302_configuration.html#generator">语言生成器</a> ）。基于<a href="http://webjars.org">WebJars的</a>最小设置显示在以下列表中。</p>

<h4 id="orion">猎户座</h4>

<pre><code class="language-javascript">require.config（{paths：{“text”：“webjars / requirejs-text / &lt;version&gt; / text”，“jquery”：“webjars / jquery / &lt;version&gt; /jquery.min”，“xtext / xtext-orion” “：”xtext / &lt;version&gt; / xtext-orion“}}）; require（[“orion / code_edit / built-codeEdit-amd”]，function（）{require（[“xtext / xtext-orion”]，function（xtext）{xtext.createEditor（）;}）;}）;</code></pre>
<p>由于Orion在WebJars上不可用，因此必须在download.eclipse.org上手动<a href="http://download.eclipse.org/orion/">下载</a> 。</p>

<h4 id="ace">高手</h4>

<pre><code class="language-javascript">require.config（{paths：{“jquery”：“webjars / jquery / &lt;version&gt; /jquery.min”，“ace / ext / language_tools”：“webjars / ace / &lt;version&gt; / src / ext-language_tools”， “xtext / xtext-ace”：“xtext / &lt;version&gt; / xtext-ace”}}）; require（[“webjars / ace / &lt;version&gt; / src / ace”]，function（）{require（[“xtext / xtext-ace”]，function（xtext）{xtext.createEditor（）;}）;}） ;</code></pre>

<h4 id="codemirror">CodeMirror</h4>

<pre><code class="language-javascript">require.config（{paths：{“jquery”：“webjars / jquery / &lt;version&gt; /jquery.min”，“xtext / xtext-codemirror”：“xtext / &lt;version&gt; / xtext-codemirror”}，包：[ {name：“codemirror”，location：“webjars / codemirror / &lt;version&gt;”，main：“lib / codemirror”}]}）; require（[“xtext / xtext-codemirror”]，function（xtext）{xtext.createEditor（）;}）;</code></pre>

<h3 id="javascript-api">JavaScript API</h3>

<h4 id="xtextcreateeditoroptions"><code>xtext.createEditor（选项）</code></h4>

<p>创建一个或多个编辑器实例并为它们初始化Xtext服务。可用选项如下所述。如果只创建了一个编辑器，则返回值是创建的编辑器，否则返回值是编辑器数组：</p>

<pre><code class="language-javascript">var editor = xtext.createEditor（）;</code></pre>

<p>对于Orion，编辑器不会直接返回，而是通过<em>承诺</em> ：</p>

<pre><code class="language-javascript">xtext.createEditor（）。done（function（editorViewer）{...}）;</code></pre>

<p>如果未通过选项指定编辑器的父元素，则此函数将查找<code>id="xtext-editor"</code>的元素。如果不存在，则该函数使用<code>class="xtext-editor"</code>查找元素。</p>

<h4 id="xtextcreateserviceseditor-options"><code>xtext.createServices（编辑器，选项）</code></h4>

<p>为已创建的编辑器初始化Xtext服务。如果要完全控制编辑器创建，请使用此变体。</p>

<h4 id="xtextremoveserviceseditor"><code>xtext.removeServices（编辑）</code></h4>

<p>从给定编辑器中删除所有服务和关联的侦听器。基于JavaScript的语法突出显示不受此操作的影响。</p>

<h3 id="options">选项</h3>

<p>可以使用传递给<code>createEditor</code>或<code>createServices</code>函数的对象指定选项：</p>

<pre><code class="language-javascript">xtext.createEditor（{resourceId：“example.statemachine”，syntaxDefinition：“xtext / ace-mode-statemachine”}）;</code></pre>

<p>或者，如果使用<code>createEditor</code> ，则可以将选项设置为创建编辑器的HTML元素的属性。通过将CamelCase转换为连字符分隔和使用<code>data-editor-</code> <code>data-editor-resource-id</code>前缀来从JavaScript选项名称派生属性名称，例如<code>resourceId</code>变为<code>data-editor-resource-id</code> ：</p>

<pre><code class="language-html">&lt;div id =“xtext-editor”data-editor-resource-id =“example.statemachine”data-editor-syntax-definition =“xtext / ace-mode-statemachine”&gt; &lt;/ div&gt;</code></pre>

<p>有关<a href="#options-reference">可用选项</a>的<a href="#options-reference">完整列表，</a>请参见下文。</p>

<h3 id="getting-text-content">获取文本内容</h3>

<p>文本内容可以从Xtext服务器加载，也可以通过JavaScript提供。在任何一种情况下，Xtext服务器都需要识别您正在使用的语言，以便处理任何请求。通常使用文件扩展名或内容类型来标识语言。可以使用<code>xtextLang</code>选项指定文件扩展名，而使用<code>contentType</code>选项指定内容类型。</p>

<h4 id="loading-text-from-the-server">从服务器加载文本</h4>

<p>如果为<code>resourceId</code>选项指定值，则可以从该id中包含的文件扩展名中标识该语言。在这种情况下，没有必要提供<code>xtextLang</code>选项。使用<code>resourceId</code>另一个影响是服务器将尝试从其持久层加载相应的资源。Xtext服务器没有定义任何默认持久性，因此您必须按照<a href="#persistence">持久性</a>中的描述对其进行自定义，以便使用此方法。</p>

<p><code>resourceId</code>字符串可能包含识别服务器上特定文本内容所需的任何信息。通常使用<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>语法，但这不是必需的。</p>

<h4 id="providing-text-through-javascript">通过JavaScript提供文本</h4>

<p>Xtext服务器的持久层完全是可选的，因此您可以使用任何您喜欢的方式来获取内容，例如在客户端生成它或通过您自己的服务请求它。如果创建编辑器的DOM元素已包含一些文本，则此文本将用作初始内容。否则编辑器最初是空的，您可以使用所选编辑器框架的API随时更改内容。</p>

<p>如果要在不使用Xtext附带的持久性服务的情况下指定<code>resourceId</code> ，可以通过将选项<code>loadFromServer</code>设置为<code>false</code> 。</p>

<h3 id="operation-modes">操作模式</h3>

<p>Xtext的Web集成支持两种操作模式，如下所述。</p>

<h4 id="stateful-mode">有状态模式</h4>

<p>当<code>sendFullText</code>为<code>false</code> ，此模式处于活动状态，这是默认设置。在有状态模式下，只要编辑器的文本内容发生变化，就会向服务器发送更新请求。使用此方法，文本的副本保留在服务器的会话状态中，并且许多与Xtext相关的服务（例如AST解析和验证）与该副本一起缓存。这意味着服务在服务器上运行得更快，并且大多数请求的消息大小非常小。使用此模式可以优化服务请求的响应时间。</p>

<h4 id="stateless-mode">无状态模式</h4>

<p>当<code>sendFullText</code>设置为<code>true</code>时，此模式处于活动状态。在这种情况下，当文本内容发生更改时，不需要更新请求，但是全文内容将附加到所有其他服务请求。这意味着必须为每个请求再次解析文本，并且消息大小与文本内容的大小成比例。仅当您要避免服务器端会话和存储在cookie中的相应会话ID时，才使用此模式。</p>

<h3 id="syntax-highlighting">语法突出显示</h3>

<p>与<a href="#semantic-highlighting">语义突出显示相比</a> ，语法突出显示可以纯粹在JavaScript中计算，而无需连接到服务器。这是通过所用编辑器库的突出显示功能实现的。这三个库都提供了一个用于指定突出显示规则的JavaScript API。Xtext语言生成器的<code>WebIntegrationFragment</code>能够生成突出显示规范，其中包括关键字和一些基本标记，如数字和注释（请参阅<a href="302_configuration.html#generator">语言生成器</a> ）。如果以这种方式生成的突出显示不够，您仍然可以按照所选编辑器库的文档自行实现规范。</p>

<p>在设置Xtext编辑器时，使用<code>syntaxDefinition</code>选项设置突出显示规范的路径。如果没有为该选项指定值，则使用<code>xtextLang</code>选项以<code>'xtext-resources/{xtextLang}-syntax'</code> （Orion）或<code>'xtext-resources/mode-{xtextLang}'</code> （Ace）的形式<code>'xtext-resources/mode-{xtextLang}'</code> 。对于CodeMirror语法突出显示是通过注册<em>模式</em>并相应地设置<code>mode</code>选项来配置的（默认模式名称： <code>'xtext/{xtextLang}'</code> ）。</p>

<h3 id="invoking-services">调用服务</h3>

<p><code>createEditor</code>和<code>createServices</code>函数为编辑器事件设置侦听器，以便在使用编辑器时自动调用大多数服务。但是，也可以使用附加到每个编辑器实例的<code>xtextServices</code>对象以编程方式调用所有服务。例如，当单击带有id <code>save-button</code>的按钮时，以下代码会保存与编辑器关联的资源：</p>

<pre><code class="language-javascript">var editor = xtext.createEditor（）; $（“＃save-button”）。click（function（）{editor.xtextServices.saveResource（）;}）;</code></pre>

<p>如果所使用的编辑器库启用并支持相应的服务，则可以使用以下功能。所有函数都返回一个最终解析为请求数据的<em>promise</em> 。此外，所有这些函数都可以提供一个<code>options</code>参数来覆盖构建编辑器时声明的一些选项。</p>

<ul>
  <li><code>getContentAssist（）</code><br>以“ <a href="#content-assist">内容辅助”一</a>节中说明的格式返回内容辅助提议。</li>
  <li><code>验证（）</code><br>返回验证结果。返回的对象有一个属性<code>issues</code> ，它是一个具有以下属性的对象数组：<ul>
      <li><code>description</code> ：要向用户显示的描述。</li>
      <li><code>severity</code> ： <code>'error'</code> ， <code>'warning'</code>或<code>'info'</code></li>
      <li><code>line</code> ：发生问题的行（从1开始）</li>
      <li><code>column</code> ：发生问题的列（从一开始）</li>
      <li><code>offset</code> ：文档中的字符偏移量（从零开始）</li>
      <li><code>length</code> ：受影响的文本区域的长度</li>
    </ul>
  </li>
  <li><code>computeHighlighting（）</code><br>返回语义突出显示的文本样式数据（请参见<a href="#semantic-highlighting">Semantic Highlighting一</a>节）。</li>
  <li><code>getOccurrences（）</code><br>返回当前光标位置处元素的<a href="#mark-occurrences">出现次数</a> （请参见章节<a href="#mark-occurrences">标记出现次数</a> ）。</li>
  <li><code>getHoverInfo（）</code><br>返回当前光标位置的<a href="#hover-info">悬停信息</a> （请参阅<a href="#hover-info">悬停信息部分</a> ）。</li>
  <li><code>格式（）</code><br>格式化当前选择（如果选择的长度为零，则为整个文档）并返回格式化文本。</li>
  <li><code>生成（）</code><br>返回从关联资源生成的文档。如果生成了多个<code>documents</code>则返回具有属性<code>documents</code>的对象，该对象是具有属性<code>name</code> ， <code>contentType</code>和<code>content</code>的对象数组。</li>
  <li><code>loadResource（）</code><br>加载关联的资源并返回属性为<code>fullText</code>和<code>dirty</code>的对象。如果在当前会话期间修改了资源，则即使重新加载页面，也会返回修改后的版本。</li>
  <li><code>saveResource（）</code><br>保存资源的当前状态。</li>
  <li><code>revertResource（）</code><br>将资源还原到上次保存的状态，并返回属性为<code>fullText</code>和<code>dirty</code>的对象。</li>
  <li><code>更新（）</code><br>计算当前编辑器内容与已提交到服务器的最新版本之间的差异。如果存在差异，则发送更新请求以刷新服务器状态。返回值具有单个属性<code>stateId</code> ，它是新服务器状态的标识符。所有请求必须包括最后获得的状态标识符才能成功。</li>
</ul>

<h3 id="options-reference">完整的选项列表</h3>

<ul>
  <li><code>的baseUrl</code><br>找到Xtext服务的路径段（默认值： <code>'/'</code> ）。请参阅<code>serviceUrl</code>选项。</li>
  <li><code>contentAssistCharTriggers</code><br>键入时调用内容辅助服务的字符（仅限Orion）。</li>
  <li><code>contentAssistExcludedStyles</code><br>字符触发器的排除样式（仅限Orion）。</li>
  <li><code>内容类型</code><br>对Xtext服务器的请求中包含的内容类型。如果未给出内容类型，则使用<code>resourceId</code>选项中的文件扩展名来确定语言。</li>
  <li><code>dirtyElement</code><br>编辑器标记为脏时写入脏状态类的元素;它可以是DOM元素，也可以是DOM元素的id。</li>
  <li><code>dirtyStatusClass</code><br>编辑器标记为脏时写入dirtyElement的CSS类名称（默认值为<code>'dirty'</code> ）。</li>
  <li><code>文献</code><br>该文件;如果未指定，则使用全局文档。</li>
  <li><code>enableContentAssistService</code><br>是否应启用内容辅助（默认值： <code>true</code> ）。</li>
  <li><code>enableCors</code><br>是否应为服务请求启用CORS（默认值： <code>false</code> ）。</li>
  <li><code>enableFormattingAction</code><br>是否应将格式化操作绑定到标准按键<kbd>Ctrl</kbd> + <kbd>⇧</kbd> + <kbd>F</kbd> （CodeMirror上的<kbd>Ctrl</kbd> + <kbd>⇧</kbd> + <kbd>S</kbd> ）/ <kbd>⌘</kbd> + <kbd>⇧</kbd> + <kbd>F</kbd> （默认值： <code>false</code> ）。</li>
  <li><code>enableFormattingService</code><br>是否应启用文本格式（默认值： <code>true</code> ）。</li>
  <li><code>enableGeneratorService</code><br>是否应启用代码生成（默认值： <code>true</code> ）。没有为发生器绑定默认击键，因此必须通过JavaScript代码触发它。</li>
  <li><code>enableHoverService</code><br>是否应启用鼠标悬停信息（默认值： <code>true</code> ）。</li>
  <li><code>enableHighlightingService</code><br>是否应启用语义突出显示（默认值： <code>true</code> ）。与<a href="#syntax-highlighting">语法突出显示</a>相反，在服务器上计算语义突出显示。</li>
  <li><code>enableOccurrencesService</code><br>是否应启用标记出现（默认值： <code>true</code> ）。</li>
  <li><code>enableSaveAction</code><br>是否应将保存操作绑定到标准按键<kbd>Ctrl</kbd> + <kbd>S</kbd> / <kbd>⌘</kbd> + <kbd>S</kbd> （默认值： <code>false</code> ）。</li>
  <li><code>enableValidationService</code><br>是否应启用验证（默认值： <code>true</code> ）。</li>
  <li><code>loadFromServer</code><br>是否从服务器加载编辑器内容。如果设置了<code>resourceId</code>选项，则默认值为<code>true</code> ，否则为<code>false</code> 。</li>
  <li><code>mouseHoverDelay</code><br>显示信息工具提示之前鼠标悬停后等待的毫秒数（默认值：500）。</li>
  <li><code>亲</code><br>应该在其中创建编辑器的父元素。它可以是DOM元素，也可以是DOM元素的id（默认值： <code>'xtext-editor'</code> ）。</li>
  <li><code>父类</code><br>如果未给出<code>parent</code>选项，则此选项用于查找与给定类名匹配的元素（默认<code>'xtext-editor'</code> ： <code>'xtext-editor'</code> ）。</li>
  <li><code>RESOURCEID</code><br>文本编辑器中显示的资源的标识符。此选项被发送到服务器以传递相应资源上的所需信息。</li>
  <li><code>selectionUpdateDelay</code><br>在调用Xtext服务之前选择更改之后等待的毫秒数（默认值：550）。</li>
  <li><code>sendFullText</code><br>是否应将每个请求的全文发送到服务器（默认值： <code>false</code> ）。如果希望服务器以无状态模式运行，请使用此选项。如果该选项处于非活动状态，则会定期更新服务器状态。</li>
  <li><code>的serviceUrl</code><br>Xtext servlet的URL。如果没有给出值，则使用<code>{location.protocol}//{location.host}{baseUrl}xtext-service</code>形式的<code>baseUrl</code>选项构造它。</li>
  <li><code>showErrorDialogs</code><br>是否应在弹出对话框中显示错误（默认值： <code>false</code> ）。</li>
  <li><code>syntaxDefinition</code><br>包含语法定义的JS文件的路径。将此选项设置为<code>'none'</code>可禁用语法突出显示。有关更多详细信息，请参见<a href="#syntax-highlighting">语法突出显示</a> 。</li>
  <li><code>textUpdateDelay</code><br>调用Xtext服务之前文本更改后等待的毫秒数（默认值：500）。</li>
  <li><code>xtextLang</code><br>语言名称（通常是为该语言配置的文件扩展名）。如果尚未指定<code>resourceId</code>和<code>syntaxDefinition</code>选项，则用于设置它们。</li>
</ul>

<h2 id="server">服务器</h2>

<p>特定于语言的资源是通过<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web.servlet/src/main/java/org/eclipse/xtext/web/servlet/XtextServlet.xtend">XtextServlet</a>处理的HTTP请求提供的。该类还负责管理语言<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Injector.html">Injector</a>的生命周期（请参阅<a href="302_configuration.html#dependency-injection">依赖注入</a> ）。默认方法是在servlet启动时创建一个注入器并在<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java">IResourceServiceProvider中注册它<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java">。登记处</a> 。要覆盖默认行为，您可以在<code>&lt;LanguageName&gt;WebModule</code>的<code>&lt;LanguageName&gt;WebModule</code>或<code>&lt;LanguageName&gt;IdeModule</code>中更改或添加绑定。</p>

<p>在服务器应用程序中包含Xtext servlet的常用方法是创建<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web.servlet/src/main/java/org/eclipse/xtext/web/servlet/XtextServlet.xtend">XtextServlet</a>的子类，重写<code>init()</code>和<code>destroy()</code>以管理运行时资源，并使用<code>urlPatterns = "/xtext-service/*"</code>添加<a href="https://docs.oracle.com/javaee/7/api/javax/servlet/annotation/WebServlet.html">WebServlet</a>注释。作为参数。有关<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web.example.jetty/src/main/java/org/eclipse/xtext/web/example/jetty/MyXtextServlet.xtend">示例</a> ，请参阅<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web.example.jetty/src/main/java/org/eclipse/xtext/web/example/jetty/MyXtextServlet.xtend">MyXtextServlet</a> 。</p>

<p>如果要在不使用XtextServlet的情况下实现自己的通信通道来提供特定于语言的服务，可以通过注入<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/XtextServiceDispatcher.xtend">XtextServiceDispatcher</a>实例并调用<code>getService(IServiceContext)</code> 。此方法的输入是<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/IServiceContext.xtend">IServiceContext</a> ，必须实现该提供以提供请求参数和客户端会话。返回值是可用于调用实际服务的描述符。此外，可以对<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/XtextServiceDispatcher.xtend">XtextServiceDispatcher</a>进行子类化，以添加对文档AST和所有相关Xtext API的访问权限的自定义服务。</p>

<p>以下部分介绍如何为Web编辑器自定义标准服务。</p>

<h3 id="content-assist">内容辅助</h3>

<p>交叉引用的内容辅助提议由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeCrossrefProposalProvider.xtend">IdeCrossrefProposalProvider</a>创建，而对于其他语法元素，则使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.xtend">IdeContentProposalProvider</a> 。要自定义提议，请创建这些提供程序的子类并在IDE Guice模块中注册它们。</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.xtend">IdeContentProposalProvider</a>为每种类型的语法元素都有一个<code>_createProposals(...)</code>调度方法。在大多数情况下，最好的选择是覆盖<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/emf-gen/org/eclipse/xtext/Assignment.java">Assignments</a>的方法，并通过将它们与您生成的语言GrammarAccess中的实例进行比较来过滤正确的赋值。通过创建和配置<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/ContentAssistEntry.xtend">ContentAssistEntry</a>的实例并将其传递给给定的接受者来提交提议。此条目类包含在Web浏览器中显示提议并将其应用于文档所需的所有信息。通常它以JSON格式发送到客户端。</p>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeCrossrefProposalProvider.xtend">IdeCrossrefProposalProvider</a>的典型定制点是<code>createProposal(...)</code>方法，它为范围提供程序找到的每个元素调用。在这里，您可以微调要放入<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/ContentAssistEntry.xtend">ContentAssistEntry</a>的信息。</p>

<h3 id="semantic-highlighting">语义突出显示</h3>

<p>Xtext编辑器的默认行为是没有语义突出显示（例如，对于关键字和字符串， <a href="#syntax-highlighting">语法突出显示</a>在客户端完成，如<a href="#syntax-highlighting">语法突出显示中所述</a> ）。为了在文本中添加样式，请创建<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/syntaxcoloring/DefaultSemanticHighlightingCalculator.java">DefaultSemanticHighlightingCalculator</a>的子类并覆盖<code>highlightElement(...)</code> 。在这里，您可以通过向给定的接受器提交文本偏移量，长度和CSS类名称来标记具有CSS类的文本区域。您可以在包含Xtext编辑器的网页包含的CSS文件中指定实际文本样式。</p>

<h3 id="mark-occurrences">Mark Occurrences</h3>

<p>用于标记所选元素的出现的服务由<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/occurrences/OccurrencesService.xtend">OccurrencesService</a>处理。在这里，您可以覆盖<code>filter(EObject)</code>以从此服务中排除某些元素。要标记的实际文本区域是从模型中存在的交叉引用自动计算的。</p>

<h3 id="hover-info">悬停信息</h3>

<p>为鼠标悬停弹出窗口显示的信息以HTML格式创建，由两部分组成：标题和描述。</p>

<p>标题由文本标签和图像组成。标签由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/labels/INameLabelProvider.xtend">INameLabelProvider</a>计算，默认值是元素的<code>name</code>属性的值（如果存在）。图像由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/labels/IImageDescriptionProvider.xtend">IImageDescriptionProvider</a>的实现确定。默认行为是生成<code>&lt;div&gt;</code>并使用<code>&lt;class&gt;-icon</code>形式的CSS类对其进行注释，其中<code>&lt;class&gt;</code>是相应元素的EClass的名称。可以使用<code>background-image</code> CSS属性在CSS文件中将实际图像分配给这些类。</p>

<p>悬停弹出窗口的描述部分由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/documentation/IEObjectDocumentationProvider.java">IEObjectDocumentationProvider</a>确定。对于此部分，默认内容是从文档中的注释中获取的：如果元素的定义前面有多行注释（例如<code>/* ... */</code> ），则该注释的内容将用作描述。</p>

<h3 id="persistence">坚持</h3>

<p>如果不进一步调整，Xtext服务器不提供任何持久性功能。如<a href="#getting-text-content">获取文本内容中所述</a> ，有多种方法可以使用文本填充Web编辑器。如果要使用Xtext服务器中包含的持久性服务，则需要实现<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/persistence/IServerResourceHandler.xtend">IServerResourceHandler</a> 。在该接口中声明的<code>get</code>和<code>put</code>操作应该委托给您想要连接的持久层。有关简单示例，请参阅<a href="https://github.com/eclipse/xtext-web/blob/master/org.eclipse.xtext.web/src/main/java/org/eclipse/xtext/web/server/persistence/FileResourceHandler.xtend">FileResourceHandler</a> 。</p>

<hr>

<p><strong><a href="350_continuous_integration.html">下一章：持续集成</a></strong></p>


</body>
</html><html id="3356.Network-Tracing.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass开发人员指南 - 网络跟踪</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">网络追踪</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Performance-Tests.html" title="性能测试">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Markers.html" title="标记">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">性能测试</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">标记</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Network_Tracing">网络追踪</h1>
		<h2 id="Adding_a_protocol">添加协议</h2>
		<p>在TMF中支持新的网络协议非常简单。支持新协议需要很少的努力。在本教程中，UDP协议将添加到支持的协议列表中。</p>
		<h3 id="Architecture">建筑</h3>
		<p>所有与TMF pcap相关的代码分为三个项目（不考虑测试插件）：</p>
		<ul>
			<li>
				<b>org.eclipse.tracecompass.pcap.core</b> ，它包含将读取pcap文件并从ByteBuffer构造不同数据包的解析器。它还包含构建数据包流的方法，数据包流是两个端点之间的会话（数据包列表）。要添加协议，几乎所有工作都将在该项目中。
			</li>
			<li>
				<b>org.eclipse.tracecompass.tmf.pcap.core</b> ，它包含特定于TMF的概念，并充当TMF和pcap解析库之间的包装器。它只依赖于org.eclipse.tracecompass.tmf.core和org.eclipse.tracecompass.pcap.core。要添加协议，必须在此项目中编辑一个文件。
			</li>
			<li>
				<b>org.eclipse.tracecompass.tmf.pcap.ui</b> ，它包含所有TMF pcap UI特定的概念，例如视图和透视图。该项目不需要任何工作。
			</li>
		</ul>
		<h3 id="UDP_Packet_Structure">UDP数据包结构</h3>
		<p>UDP是传输层协议，不保证消息传递也不保证有序消息接收。UDP包（数据报）具有以下<a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure">结构</a> ：</p>
		<table class="wikitable" style="margin:0 auto;text-align:center">
			<tr>
				<th style="border-bottom:none;border-right:none">
					<i>偏置</i>
				</th>
				<th style="border-left:none">八重奏</th>
				<th colspan="8">0</th>
				<th colspan="8">1</th>
				<th colspan="8">2</th>
				<th colspan="8">3</th>
			</tr>
			<tr>
				<th style="border-top:none">八重奏</th>
				<th><tt>位</tt></th>
				<th><tt>0</tt></th>
				<th><tt>1</tt></th>
				<th><tt>2</tt></th>
				<th><tt>3</tt></th>
				<th><tt>4</tt></th>
				<th><tt>五</tt></th>
				<th><tt>6</tt></th>
				<th><tt>7</tt></th>
				<th><tt>8</tt></th>
				<th><tt>9</tt></th>
				<th><tt>10</tt></th>
				<th><tt>11</tt></th>
				<th><tt>12</tt></th>
				<th><tt>13</tt></th>
				<th><tt>14</tt></th>
				<th><tt>15</tt></th>
				<th><tt>16</tt></th>
				<th><tt>17</tt></th>
				<th><tt>18</tt></th>
				<th><tt>19</tt></th>
				<th><tt>20</tt></th>
				<th><tt>21</tt></th>
				<th><tt>22</tt></th>
				<th><tt>23</tt></th>
				<th><tt>24</tt></th>
				<th><tt>25</tt></th>
				<th><tt>26</tt></th>
				<th><tt>27</tt></th>
				<th><tt>28</tt></th>
				<th><tt>29</tt></th>
				<th><tt>三十</tt></th>
				<th><tt>31</tt></th>
			</tr>
			<tr>
				<th>0</th>
				<th><tt>0</tt></th>
				<td colspan="16" style="background:#fdd">源端口</td>
				<td colspan="16">目的端口</td>
			</tr>
			<tr>
				<th>4</th>
				<th><tt>32</tt></th>
				<td colspan="16">长度</td>
				<td colspan="16" style="background:#fdd">校验</td>
			</tr>
		</table>
		<p>知道了，我们可以定义一个包含这些字段的UDPPacket类。</p>
		<h3 id="Creating_the_UDPPacket">创建UDPPacket</h3>
		<p>首先，在org.eclipse.tracecompass.pcap.core中，创建一个名为<b>org.eclipse.tracecompass.pcap.core.protocol.name</b>的新包，其名称是新协议的名称。在我们的例子中，name是udp，因此我们创建了包<b>org.eclipse.tracecompass.pcap.core.protocol.udp</b> 。我们所有的工作都在这个包中。
		</p>
		<p>在这个包中，我们创建了一个名为UDPPacket的新类，它扩展了Packet。所有新协议都必须定义扩展抽象类Packet的数据包类型。我们还添加了不同的字段：</p>
		<ul>
			<li>
				<i>数据包</i> <b>fChildPacket</b> ，它是由此UDP数据包封装的数据包（如果存在）。该字段将由findChildPacket（）初始化。
			</li>
			<li>
				<i>ByteBuffer</i> <b>fPayload</b> ，这是该数据包的有效负载。基本上，它是没有标头的UDP数据包。
			</li>
			<li>
				<i>int</i> <b>fSourcePort</b> ，它是一个无符号的16位字段，包含数据包的源端口（请参阅数据包结构）。
			</li>
			<li>
				<i>int</i> <b>fDestinationPort</b> ，它是一个无符号的16位字段，包含数据包的目标端口（请参阅数据包结构）。
			</li>
			<li>
				<i>int</i> <b>fTotalLength</b> ，它是一个无符号的16位字段，包含数据包的总长度（标头+有效负载）。
			</li>
			<li>
				<i>int</i> <b>fChecksum</b> ，一个无符号的16位字段，包含校验和以验证数据的完整性。
			</li>
			<li>
				<i>UDPEndpoint</i> <b>fSourceEndpoint</b> ，包含<b>UDPPacket</b>的源端点。UDPEndpoint类将在本教程后面创建。
			</li>
			<li>
				<i>UDPEndpoint</i> <b>fDestinationEndpoint</b> ，包含<b>UDPPacket</b>的目标端点。
			</li>
			<li>
				<i>ImmutableMap &lt;String，String&gt;</i> <b>fFields</b> ，它是一个包含所有数据包字段（参见数据结构）的映射，它为字段名称赋值。这些值将显示在UI上。</li>
		</ul>
		<p>我们还创建了UDPPacket（PcapFile文件，@ Nullable Packet父，ByteBuffer包）构造函数。参数是：</p>
		<ul>
			<li>
				<i>PcapFile</i> <b>文件</b> ，该数据包所属的pcap文件。
			</li>
			<li>
				<i>数据包</i> <b>父</b> ，即包含此UDPPacket的数据包</li>
			<li>
				<i>ByteBuffer</i> <b>数据包</b> ，它是一个ByteBuffer，包含初始化此UDPPacket字段所需的所有数据。我们将在对象构造期间从中检索字节。
			</li>
		</ul>
		<p>获得以下课程：</p>
		<pre>package org.eclipse.tracecompass.pcap.core.protocol.udp; import java.nio。字节缓冲区; import java.util。地图; import org.eclipse.tracecompass.internal.pcap.core.endpoint。ProtocolEndpoint; import org.eclipse.tracecompass.internal.pcap.core.packet。BadPacketException; import org.eclipse.tracecompass.internal.pcap.core.packet。包; public class UDPPacket扩展Packet {private final @Nullable Packet fChildPacket;私人决赛@Nullable ByteBuffer fPayload; private final int fSourcePort; private final int fDestinationPort; private final int fTotalLength;私人决赛int fChecksum; private @Nullable UDPEndpoint fSourceEndpoint; private @Nullable UDPEndpoint fDestinationEndpoint; private @Nullable ImmutableMap &lt;String，String&gt; fFields; / ** * UDP Packet类的构造函数。* * @param file *包含此数据包的文件。* @param parent *此数据包的父数据包（封装数据包）。* @param packet *整个数据包（标头和有效负载）。* @throws BadPacketException *在数据包错误时抛出。* / public UDPPacket（PcapFile文件，@ Nullable Packet parent，ByteBuffer数据包）抛出BadPacketException {super（文件，父，PcapProtocol。UDP）; // TODO自动生成的构造函数stub} @Override public Packet getChildPacket（）{// TODO自动生成的方法存根返回null; } @Override public ByteBuffer getPayload（）{// TODO自动生成的方法存根返回null; } @Override public boolean validate（）{// TODO自动生成的方法存根返回false; } @Override protected Packet findChildPacket（）抛出BadPacketException {// TODO自动生成的方法存根返回null; } @Override public ProtocolEndpoint getSourceEndpoint（）{// TODO自动生成的方法存根返回null; } @Override public ProtocolEndpoint getDestinationEndpoint（）{// TODO自动生成的方法存根返回null; } @Override public Map &lt;String，String&gt; getFields（）{// TODO自动生成的方法存根返回null; } @Override public String getLocalSummaryString（）{// TODO自动生成的方法存根返回null; } @Override protected String getSignificationString（）{// TODO自动生成的方法存根返回null; } @Override public boolean equals（Object obj）{// TODO自动生成的方法存根返回false; } @Override public int hashCode（）{// TODO自动生成的方法存根返回0; }}</pre>
		<p>现在，我们实现构造函数。它分四步完成：</p>
		<ul>
			<li>我们将fSourceEndpoint，fDestinationEndpoint和fFields初始化为null，因为它们是延迟加载的。这允许更快地构造分组并因此更快地解析。</li>
			<li>我们使用ByteBuffer包初始化fSourcePort，fDestinationPort，fTotalLength，fChecksum。由于数据包数据结构，我们可以简单地检索packet.getShort（）来获取值。由于Java中没有未签名，因此要特别注意避免负数。我们使用实用程序方法ConversionHelper.unsignedShortToInt（）将其转换为整数，并初始化字段。</li>
			<li>既然已经解析了头部，我们将使剩余的ByteBuffer数据包初始化有效载荷（如果有的话）。为此，我们只需从当前位置开始生成一个新的ByteBuffer。</li>
			<li>我们使用findChildPacket（）方法初始化字段fChildPacket</li>
		</ul>
		<p>获得以下构造函数：</p>
		<pre>public UDPPacket（PcapFile文件，@ Nullable Packet parent，ByteBuffer数据包）抛出BadPacketException {super（文件，父，协议。UDP）; //端点和fField是延迟加载的。它们在get * Endpoint（）//方法中定义。fSourceEndpoint = null; fDestinationEndpoint = null; fFields = null; //初始化ByteBuffer packet.order中的字段（ByteOrder。BIG_ENDIAN）; packet.position（0）; fSourcePort = ConversionHelper.unsignedShortToInt（packet.getShort（））; fDestinationPort = ConversionHelper.unsignedShortToInt（packet.getShort（））; fTotalLength = ConversionHelper.unsignedShortToInt（packet.getShort（））; fChecksum = ConversionHelper.unsignedShortToInt（packet.getShort（））; //初始化有效负载if（packet.array（）。length  -  packet.position（）&gt; 0）{byte [] array = new byte [packet.array（）。length  -  packet.position（）]; packet.get（数组）; ByteBuffer payload = ByteBuffer.wrap（array）; payload.order（字节顺序。BIG_ENDIAN）; payload.position（0）; fPayload = payload; } else {fPayload = null; } //查找子fChildPacket = findChildPacket（）; }</pre>
		<p>然后，我们实现以下方法：</p>
		<ul>
			<li>
				<i>public Packet</i> <b>getChildPacket（）</b> ：fChildPacket的简单getter</li>
			<li>
				<i>public ByteBuffer</i> <b>getPayload（）</b> ：fPayload的简单getter</li>
			<li>
				<i>public boolean</i> <b>validate（）</b> ：检查数据包是否有效的方法。在我们的例子中，如果检索到的校验和fChecksum和真实校验和（我们可以使用UDPPacket的字段和有效负载计算）相同，则数据包有效。
			</li>
			<li>
				<i>protected Packet</i> <b>findChildPacket（）</b> ：如果找到封装协议，则创建新数据包的方法。例如，基于fDestinationPort，它可以确定封装协议是什么并创建新的数据包对象。
			</li>
			<li>
				<i>public ProtocolEndpoint</i> <b>getSourceEndpoint（）</b> ：初始化并返回源端点的方法。
			</li>
			<li>
				<i>public ProtocolEndpoint</i> <b>getDestinationEndpoint（）</b> ：初始化并返回目标端点的方法。
			</li>
			<li>
				<i>public Map &lt;String，String&gt;</i> <b>getFields（）</b> ：初始化并返回包含与其值匹配的字段的映射的方法。
			</li>
			<li>
				<i>public String</i> <b>getLocalSummaryString（）</b> ：返回总结数据包最重要字段的字符串的方法。无需列出所有字段，只需列出最重要的字段。这将显示在UI上。</li>
			<li>
				<i>protected String</i> <b>getSignificationString（）</b> ：返回描述数据包含义的字符串的方法。如果没有特殊含义，则可以返回getLocalSummaryString（）。
			</li>
			<li>public boolean''equals <b>（Object obj）</b> ：Object的equals方法。
			</li>
			<li>public <b>int''hashCode（）</b> ：Object的hashCode方法。
			</li>
		</ul>
		<p>我们得到以下代码：</p>
		<pre>@Override public @Nullable Packet getChildPacket（）{return fChildPacket; } @Override public @Nullable ByteBuffer getPayload（）{return fPayload; } / ** *返回UDP源端口的Getter方法。* * @return源端口。* / public int getSourcePort（）{return fSourcePort; } / ** *返回UDP目标端口的Getter方法。* * @return目的地港口。* / public int getDestinationPort（）{return fDestinationPort; } / ** * {@inheritDoc} * *请参阅http://www.iana.org/assignments/service-names-port-numbers/service- * names-port-numbers.xhtml或* http：// en。 wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers * / @Override protected @Nullable数据包findChildPacket（）抛出BadPacketException {//当实现更多协议时，我们可以简单地在fDestinationPort字段上切换以查找子数据包。//例如，如果目标端口是80，则很可能封装了HTTP协议。我们可以创建一个新的HTTP //数据包（经过一些验证，它确实是HTTP协议）。ByteBuffer payload = fPayload; if（payload == null）{return null; } return new UnknownPacket（getPcapFile（），this，payload）; } @Override public boolean validate（）{//尚未实现。ATM，我们认为所有数据包都是有效的。// TODO实现它。我们可以计算真实的校验和并将其与fChecksum进行比较。返回true; } @Override public UDPEndpoint getSourceEndpoint（）{@ Nonvalable UDPEndpoint endpoint = fSourceEndpoint; if（endpoint == null）{endpoint = new UDPEndpoint（this，true）; } fSourceEndpoint = endpoint; return fSourceEndpoint; } @Override public UDPEndpoint getDestinationEndpoint（）{@ Nonvalable UDPEndpoint endpoint = fDestinationEndpoint; if（endpoint == null）{endpoint = new UDPEndpoint（this，false）; } fDestinationEndpoint = endpoint; return fDestinationEndpoint; } @Override public Map &lt;String，String&gt; getFields（）{ImmutableMap &lt;String，String&gt; map = fFields; if（map == null）{@SuppressWarnings（“null”）@NonNull ImmutableMap &lt;String，String&gt; newMap = ImmutableMap。&lt;String，String&gt; builder（）。output（“Source Port”，String.valueOf（fSourcePort）） // $ NON-NLS-1 $ .put（“Destination Port”，String.valueOf（fDestinationPort））// $ NON-NLS-1 $ .put（“Length”，String.valueOf（fTotalLength）+“bytes” ）// $ NON-NLS-1 $ // $ NON-NLS-2 $ .put（“Checksum”，String.format（“％s％04x”，“0x”，fChecksum））// $ NON-NLS -1 $ // $ NON-NLS-2 $ // $ NON-NLS-3 $ .build（）; fFields = newMap;返回newMap; } return map; } @Override public String getLocalSummaryString（）{return“Src Port：”+ fSourcePort +“，Dst Port：”+ fDestinationPort; // $ NON-NLS-1 $ // $ NON-NLS-2 $} @Override protected String getSignificationString（）{return“Source Port：”+ fSourcePort +“，Destination Port：”+ fDestinationPort; // $ NON-NLS-1 $ // $ NON-NLS-2 $} @Override public int hashCode（）{final int prime = 31; int result = 1; result = prime * result + fChecksum; final Packet child = fChildPacket;如果（孩子！= null）{result = prime * result + child.hashCode（）; } else {result = prime * result; } result = prime * result + fDestinationPort; final ByteBuffer payload = fPayload;如果（有效载荷！= null）{result = prime * result + payload.hashCode（）; } else {result = prime * result; } result = prime * result + fSourcePort; result = prime * result + fTotalLength;返回结果; } @Override public boolean equals（@Nullable Object obj）{if（this == obj）{return true; } if（obj == null）{return false; if（getClass（）！= obj.getClass（））{return false; UDPPacket other =（UDPPacket）obj;如果（fChecksum！= other.fChecksum）{return false; } final Packet child = fChildPacket;如果（孩子！= null）{if（！）child.equals（other.fChildPacket））{return false; } else {if（other.fChildPacket！= null）{return false; if（fDestinationPort！）= other.fDestinationPort）{return false; } final ByteBuffer payload = fPayload;如果（有效载荷！= null）{if（！）payload.equals（other.fPayload））{return false; } else {if（other.fPayload！= null）{return false; if（fSourcePort！= other.fSourcePort）{return false; } if（fTotalLength！= other.fTotalLength）{return false; } return true; }</pre>
		<p>UDPPacket类已实现。我们现在定义了UDPEndpoint。</p>
		<h3 id="Creating_the_UDPEndpoint">创建UDPEndpoint</h3>
		<p>对于UDP协议，端点将是其源或其目标端口，具体取决于它是源端点还是目标端点。知道了，我们可以创建UDPEndpoint类。</p>
		<p>我们在包中创建了一个名为UDPEndpoint的新类，它扩展了ProtocolEndpoint。我们还添加了一个字段：fPort，其中包含源或目标端口。我们最后添加一个构造函数public ExampleEndpoint（Packet packet，boolean isSourceEndpoint）：</p>
		<ul>
			<li>
				<i>数据</i> <b>包</b> <i>数据</i> <b>包</b> ：构建端点的数据包。
			</li>
			<li>
				<i>boolean</i> <b>isSourceEndpoint</b> ：端点是源端点还是目标端点。
			</li>
		</ul>
		<p>我们获得以下未实现的类：</p>
		<pre>package org.eclipse.tracecompass.pcap.core.protocol.udp; import org.eclipse.tracecompass.internal.pcap.core.endpoint。ProtocolEndpoint; import org.eclipse.tracecompass.internal.pcap.core.packet。包;公共类UDPEndpoint扩展了ProtocolEndpoint {private final int fPort; public UDPEndpoint（Packet packet，boolean isSourceEndpoint）{super（packet，isSourceEndpoint）; // TODO自动生成的构造函数stub} @Override public int hashCode（）{// TODO自动生成的方法存根返回0; } @Override public boolean equals（Object obj）{// TODO自动生成的方法存根返回false; } @Override public String toString（）{// TODO自动生成的方法存根返回null; }}</pre>
		<p>对于构造函数，我们只需初始化fPort。如果isSourceEndpoint为true，那么我们采用packet.getSourcePort（），否则我们采用packet.getDestinationPort（）。</p>
		<pre>/ ** * {@link UDPEndpoint}类的构造函数。它需要一个数据包来获取其端点。由于每个数据包都有两个端点（源和*目标），因此isSourceEndpoint参数用于指定要采用的*端点。* * @param packet *包含端点的数据包。* @param isSourceEndpoint *是否获取*数据包的源端点或目标端点。* / public UDPEndpoint（UDPPacket packet，boolean isSourceEndpoint）{super（packet，isSourceEndpoint）; fPort = isSourceEndpoint？packet.getSourcePort（）：packet.getDestinationPort（）; }</pre>
		<p>然后我们实现方法：</p>
		<ul>
			<li>
				<i>public int</i> <b>hashCode（）</b> ：基于字段值返回整数的方法。在我们的例子中，它将返回一个取决于fPort的整数，以及我们可以使用getParentEndpoint（）检索的父端点。
			</li>
			<li>
				<i>public boolean</i> <b>equals（Object obj）</b> ：如果两个对象相等则返回true的方法。在我们的例子中，如果两个UDPEndpoints都具有相同的fPort并且具有我们可以使用getParentEndpoint（）检索的相同父端点，则它们是相等的。
			</li>
			<li>
				<i>public String</i> <b>toString（）</b> ：将UDPEndpoint的描述作为字符串返回的方法。在我们的例子中，它将是父端点的字符串和作为字符串的fPort的串联。
			</li>
		</ul>
		<pre>@Override public int hashCode（）{final int prime = 31; int result = 1; ProtocolEndpoint endpoint = getParentEndpoint（）; if（endpoint == null）{result = 0; } else {result = endpoint.hashCode（）; } result = prime * result + fPort;返回结果; } @Override public boolean equals（@Nullable Object obj）{if（this == obj）{return true; if（！（obj instanceof UDPEndpoint））{return false; UDPEndpoint other =（UDPEndpoint）obj; //检查图层boolean localEquals =（fPort == other.fPort）;如果（！localEquals）{return false; } //检查上面的图层。ProtocolEndpoint endpoint = getParentEndpoint（）; if（端点！= null）{return endpoint.equals（other.getParentEndpoint（））; } return true; } @Override public String toString（）{ProtocolEndpoint endpoint = getParentEndpoint（）; if（endpoint == null）{@SuppressWarnings（“null”）@NonNull String ret = String.valueOf（fPort）;返回; } return endpoint.toString（）+'/'+ fPort; }</pre>
		<h3 id="Registering_the_UDP_protocol">注册UDP协议</h3>
		<p>最后一步是注册新协议。协议必须注册的地方有三个。首先，解析器必须知道已添加新协议。这在enum org.eclipse.tracecompass.internal.pcap.core.protocol中定义。PcapProtocol。只需在此处添加协议名称以及一些参数：</p>
		<ul>
			<li>
				<i>String</i> <b>longname</b> ，是协议名称的长版本。在我们的例子中，它是“用户数据报协议”。
			</li>
			<li>
				<i>String</i> <b>shortName</b> ，它是协议的缩写名称。在我们的例子中，它是“UDP”。
			</li>
			<li>
				<i>层</i> <b>层</b> ，这是该协议在OSI模型中所属的层。在我们的例子中，这是第4层。
			</li>
			<li>
				<i>boolean</i> <b>supportsStream</b> ，定义协议是否支持数据包流。在我们的例子中，这被设置为true。
			</li>
		</ul>
		<p>因此，在PcapProtocol枚举中添加以下行：</p>
		<pre>UDP（“用户数据报协议”，“udp”，层。LAYER_4，真），</pre>
		<p>此外，TMF必须了解新协议。这在org.eclipse.tracecompass.internal.tmf.pcap.core.protocol中定义。TmfPcapProtocol。我们只需添加它，并引用PcapProtocol中的相应协议。因此，在TmfPcapProtocol枚举中添加以下行：</p>
		<pre>UDP（PcapProtocol。UDP），</pre>
		<p>您还必须更新<i>ProtocolConversion</i>类以在switch语句中注册协议。因此，对于UDP，我们添加：</p>
		<pre>case UDP：返回TmfPcapProtocol。UDP;</pre>
		<p>和</p>
		<pre>case UDP：返回PcapProtocol。UDP;</pre>
		<p>最后，必须通知所有可能是新协议（在我们的例子中为IPv4和IPv6）的父协议的协议。这是通过修改这些协议的数据包类的findChildPacket（）方法来完成的。例如，在IPv4Packet中，如果协议号与网络层的UDP协议号匹配，我们在findChildPacket的switch语句中添加一个案例：</p>
		<pre>@Override protected @Nullable数据包findChildPacket（）抛出BadPacketException {ByteBuffer payload = fPayload; if（payload == null）{return null; } switch（fIpDatagramProtocol）{case IPProtocolNumberHelper。PROTOCOL_NUMBER_TCP：返回新的TCPPacket（getPcapFile（），this，payload）; case IPProtocolNumberHelper。PROTOCOL_NUMBER_UDP：返回新的UDPPacket（getPcapFile（），this，payload）; default：return new UnknownPacket（getPcapFile（），this，payload）; }}</pre>
		<p>新协议已被添加。运行TMF应该可以正常工作，现在可以识别新协议。</p>
		<h2 id="Adding_stream-based_views">添加基于流的视图</h2>
		<p>要添加基于流的视图，只需在视图中监视TmfPacketStreamSelectedSignal。它包含可以使用signal.getStream（）检索的新流。然后，您必须向当前跟踪发出事件请求以获取事件，并使用该流过滤感兴趣的事件。因此，您还必须监视TmfTraceOpenedSignal，TmfTraceClosedSignal和TmfTraceSelectedSignal。基于流的视图的示例包括将分组表示为序列图的视图，或者基于分组SYN / ACK / FIN / RST标记示出TCP连接状态的视图。可以在<a href="https://git.eclipse.org/r/#/c/31054/">https://git.eclipse.org/r/#/c/31054/</a>找到这种观点的（非常非常非常早期的）草案。</p>
		<h2 id="TODO_2">去做</h2>
		<ul>
			<li>添加更多协议。目前，仅支持四种协议。需要实现以下协议：ARP，SLL，WLAN，USB，IPv6，ICMP，ICMPv6，IGMP，IGMPv6，SCTP，DNS，FTP，HTTP，RTP，SIP，SSH和Telnet。其他VoIP协议会很好。</li>
			<li>添加网络图表视图。生成对网络工程师有意义且可以使用的图表（例如用于演示目的）将是有用的。我们可以使用基于XML的分析来做到这一点！</li>
			<li>添加流图视图。该视图将流表示为序列图。抛出TmfNewPacketStreamSignal时会更新它。很容易看到数据包交换和每个数据包之间的时间差。此外，在流图中选择数据包时，应在事件表中选择该数据包，其内容应显示在“属性”视图中。有关此类视图的草稿，请参见<a href="https://git.eclipse.org/r/#/c/31054/">https://git.eclipse.org/r/#/c/31054/</a> 。
			</li>
			<li>例如，通过扩展点使添加协议更多“plugin-ish”。这样可以更轻松地支持新协议，而无需修改源代码。</li>
			<li>直接从eclipse控制dumpcap，类似于在Control View中控制LTTng的方式。</li>
			<li>支持pcapng。有关文件格式，请参阅： <a href="http://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html">http</a> ： <a href="http://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html">//www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html</a> 。
			</li>
			<li>将SWTBOT测试添加到org.eclipse.tracecompass.tmf.pcap.ui</li>
			<li>添加Raw Viewer，类似于Wireshark。我们可以在事件编辑器中使用“Show Raw”来做到这一点。</li>
			<li>在org.eclipse.tracecompass.pcap.core中外化字符串。目前，所有字符串都是硬编码的。将它们全部外化会很好。</li>
		</ul><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Performance-Tests.html" title="性能测试">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="Developer-Guide.html" title="Trace Compass开发人员指南">
						<img alt="Trace Compass开发人员指南" border="0" src="images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Markers.html" title="标记">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">性能测试</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">标记</td>
			</tr>
		</table>
	</body>
</html><html id="3405.transformations.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8"></meta>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
<meta name="generator" content="Asciidoctor 1.5.6.1"></meta>
<title>VIATRA转换语言</title>
<link rel="stylesheet" href="asset?aid=0"></link>
<link rel="stylesheet" href="./asciidoctor.css"></link>
</head>
<body class="article" dir="ltr">
<div id="header">
<h1>VIATRA转换语言</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA的转换语言是通过<a href="https://eclipse.org/xtend/">Xtend语言</a>开发的一组内部DSL，利用其扩展方法和闭包支持等功能。这些DSL的目标是支持在<a href="evm.html">EVM上</a>创建专门的转换，同时保持结构简单。</p>
</div>
<div class="paragraph">
<p>所有语言都基于类似的概念，并具有相同的一般结构。在VIATRA 1.7中，有两种可用的语言： <strong>批量转换</strong> ，其中控制流，例如规则的触发由转换开发者指导，以及<strong>事件驱动的转换</strong> ，其中转换对各种模型改变事件作出反应。</p>
</div>
<div class="paragraph">
<p>有关转换语言的介绍，请参阅<a href="tutorial.html">入门教程</a> ;本文档更侧重于转换子语言的功能而不是基本结构。</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#batch-transformations">1。批量转换</a>
<ul class="sectlevel2">
<li><a href="#_batch_transformation_rules">1.1。批量转换规则</a></li>
</ul>
</li>
<li><a href="#event-driven-transformations">2。事件驱动的转换</a>
<ul class="sectlevel2">
<li><a href="#_the_event_driven_transformation_rule_eventdriventransformationrule">2.1。事件驱动的转换规则（EventDrivenTransformationRule）</a></li>
<li><a href="#_the_essential_ideology_behind_the_api_structure">2.2。API结构背后的基本思想</a></li>
<li><a href="#_example_model_transformations_for_automaton_simulation">2.3。示例：自动机仿真的模型转换</a></li>
</ul>
</li>
<li><a href="#model-manipulation">3。模型操纵基元</a></li>
<li><a href="#transformation-debugger">4。允许调试和其他适配器</a>
<ul class="sectlevel2">
<li><a href="#_viatra_transformation_debugger">4.1。VIATRA转换调试器</a></li>
<li><a href="#_trace_coder_listener">4.2。跟踪编码器听众</a></li>
<li><a href="#_trace_executor_adapter">4.3。跟踪执行器适配器</a></li>
<li><a href="#_usage_examples">4.4。用法示例</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="batch-transformations"><a class="link" href="#batch-transformations">1。批量转换</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>用于转换的三个扩展类：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BatchTransformation</dt>
<dd>
<p>隐藏ViatraQueryEngine和RuleEngine;管理规则的组初始化 - 而不是扩展方法，这也可以用作基类</p>
</dd>
<dt class="hdlist1">BatchTransformationStatements</dt>
<dd>
<p>控制结构</p>
</dd>
<dt class="hdlist1">IModelManipulations</dt>
<dd>
<p>通用模型操作原语;隐藏EditingDomains的详细信息（如有必要）;实现不具体的批量转换</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_batch_transformation_rules"><a class="link" href="#_batch_transformation_rules">1.1。批量转换规则</a></h3>
<div class="ulist">
<ul>
<li>
<p>特殊规则类型</p>
<div class="ulist">
<ul>
<li>
<p>先决条件+行动</p>
</li>
<li>
<p>生命周期：</p>
<div class="ulist">
<ul>
<li>
<p>无状态</p>
<div class="ulist">
<ul>
<li>
<p>规则不保持状态是否激活了激活</p>
</li>
<li>
<p>生命周期：射击：主动→主动</p>
</li>
</ul>
</div>
</li>
<li>
<p>有状态</p>
<div class="ulist">
<ul>
<li>
<p>规则维护激活是否已触发</p>
</li>
<li>
<p>生命周期：射击：主动→射击</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表格1。批量转换语句</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fireOne</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">批量转换规则，（选择：过滤器）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">触发一次激活</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fireAllCurrent</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">批量转换规则，（选择：过滤器）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">触发所有当前激活。如果射击改变了激活集，它将不会改变激活的激活集。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fireWhilePossible</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">批量转换规则，（选择：过滤器）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个接一个地激活激活。对于迭代选择方案很有用。使用Match Predicates实现中断条件 - 将Match实例作为参数接收的函数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fireUntil</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">批量转换规则，中断条件，（opt：filter）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在第一次激活后，它会检查断裂条件是否成立;如果是，则退出，如果不是，则重新启动。它不存储初始激活集。对于迭代选择方案很有用。使用Match Predicates实现中断条件 - 将Match实例作为参数接收的函数。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="event-driven-transformations"><a class="link" href="#event-driven-transformations">2。事件驱动的转换</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>事件驱动的API旨在以事件驱动的方式定义和执行模型转换。在这种情况下，以增量方式（使用VIATRA查询）检查每个相关模型更改的单个转换的前提条件，并且一旦满足前提条件就触发操作。模型更改被捕获为事件，因此命名为以下基本概念。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">EventDrivenTransformation</dt>
<dd>
<p>与<code>BatchTransformation</code>类似，它隐藏了ViatraQueryEngine和RuleEngine，并作为此部分API的基本概念。</p>
</dd>
<dt class="hdlist1">EventContext</dt>
<dd>
<p>我们区分两种类型或事件的上下文：点和间隔。前者在时间线上以单点出现进行描述;后者的特点是它在时间轴上的出现<em>和</em>消失。由用户选择转换是否与点或间隔上下文的事件相关联。在后台，事件上下文被转换为EVM激活生命周期，如果需要，可以由用户覆盖。这个概念有点类似于<em>无状态</em>和<em>有状态</em>生命周期的批量转换规则的概念。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_the_event_driven_transformation_rule_eventdriventransformationrule"><a class="link" href="#_the_event_driven_transformation_rule_eventdriventransformationrule">2.1。事件驱动的转换规则（EventDrivenTransformationRule）</a></h3>
<div class="paragraph">
<p>与批处理模式相比，在增量模式下，没有任意组合的局部冲突集;相反：每个转换规则都在全局冲突集中处理。<em>EventDrivenTransformationRuleFactory</em>是一个用于实例化规则的工厂。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_essential_ideology_behind_the_api_structure"><a class="link" href="#_the_essential_ideology_behind_the_api_structure">2.2。API结构背后的基本思想</a></h3>
<div class="paragraph">
<p>在设计API时，我们重用了<em>流畅的界面</em>和<em>构建器模式</em>的概念。它大量利用Xtend的功能，从而为定义规则，转换和转换组提供了一种简洁的方法，如下所示。</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_model_transformations_for_automaton_simulation"><a class="link" href="#_example_model_transformations_for_automaton_simulation">2.3。示例：自动机仿真的模型转换</a></h3>
<div class="listingblock">
<div class="title">定义事件驱动的转换规则</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">val createEnabledTransitionRule = ruleFactory.createRule。前提（EnabledTransitionMatcher.querySpecification）。action [eventModelManager.strategy.fireTransition（t，et）]。build</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是您转型的先决条件。上面的代码段假定要定义<em>EnabledTransition</em> VIATRA查询模式，已生成<em>EnabledTransitionMatcher</em> 。闭包中的表达式是动作，完全取决于您定义。（在这种情况下，维护模型的管理器类将触发转换。）您还可以提供规则的名称以及覆盖默认事件上下文（点）。</p>
</div>
<div class="listingblock">
<div class="title">（可选）将规则分组为规则组</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">def getRules（）{new EventDrivenTransformationRuleGroup（createEnabledTransitionRule，createFinishedStateMachineRule，createTokenInTrapStateRule）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个很简单;只需在闭包中枚举您的规则。请记住，这些规则只有一个全局冲突可以产生冲突。您是否对规则进行分组并不重要，尽管它可以使代码的其他部分更简洁。</p>
</div>
<div class="listingblock">
<div class="title">注册转换规则</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">def registerRules（）{EventDrivenTransformation。forSource（eventModelManager.resourceSet）。的addRules（规则）。build（）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>获得转换规则后，只需执行几个步骤即可将规则注册到执行模式中。我们来看看这个片段：</p>
</div>
<div class="paragraph">
<p>流畅的API方法的好处在这里是显而易见的。注意方法链尾部的强制<code>build()</code>方法是构建器模式的本质。此方法链将处理以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它实例化一个EventDrivenTransformation;</p>
</li>
<li>
<p>将执行转换的资源或资源集传递给转换（ <code>forSource()</code> ）;</p>
</li>
<li>
<p>转换规则已注册（ <code>addRules()</code> ）;</p>
</li>
<li>
<p>在后台，选择默认冲突解决程序（任意ConflictResolver）来处理全局冲突。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">使用冲突解决程序</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">def registerRulesWithCustomPriorities（）{val resolver = ConflictResolvers.createFixedPriorityResolver（）; resolver.setPriority（createEnabledTransitionRule.ruleSpecification，100）resolver.setPriority（createFinishedStateMachineRule.ruleSpecification，50）resolver.setPriority（createTokenInTrapStateRule.ruleSpecification，0）EventDrivenTransformation。forSource（eventModelManager.resourceSet）。的addRules（规则）。setConflictResolver（分解）。build（）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，作为一个有用的功能，API能够根据移交给EventDrivenTransformation <em>的规则</em>的<em>顺序</em>构建固定优先级解析器。因此，上述代码的结果可以通过以下方法实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">def registerRulesWithAutomatedPriorities（）{val resolver = new RuleOrderBasedFixedPriorityResolver（）resolver.setPrioritiesFromScratch（new ArrayList（rules.ruleSpecifications））EventDrivenTransformation。forSource（eventModelManager.resourceSet）。的addRules（规则）。setConflictResolver（分解）。创建（） }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="model-manipulation"><a class="link" href="#model-manipulation">3。模型操纵基元</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>模型操作原语由IModelManipulations接口的实例实现。目前，有两种实现方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SimpleModelManipulations  - 使用普通的EMF API</p>
</li>
<li>
<p>ModelManipulationsWithEditingDomain  - 在EditingDomain实例上使用EMF Edit命令</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果某些转换需要特定的原语（例如事务支持），则新实例可以根据需要引入额外的方法。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2。模型操纵基元</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">资源;的EClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建具有相应EClass类型的对象，并将其放入所选资源的根目录中</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">createChild所</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（容器）;的EReference;的EClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建具有相应EClass类型的对象，并将其放入选定的引用中;引用必须是包含类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（容器）; EStructuralFeature;宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用引用将现有对象添加到相应的容器中;如果使用引用，则<strong>不得</strong>为包含类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">去掉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从模型中删除EObject</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">去掉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（容器）; EStructuralFeature;宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从所选容器中删除对象;使用包含EReference时，也会将其从资源集中删除</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">去掉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（容器）; EStructuralFeature</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从多值功能中删除所有对象;使用包含EReference时，也会从资源集中删除它们</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（容器）; EStructuralFeature;宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置单值要素的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">搬去</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EObject（s），EObject（新容器），EStructuralFeature</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将元素移动到新容器，并将其从旧容器中删除。<strong>备注</strong> ：此处的实现是特定的，因为它依赖于索引的功能。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="transformation-debugger"><a class="link" href="#transformation-debugger">4。允许调试和其他适配器</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了VIATRA转换调试器之外，VIATRA转换适配器框架还包含许多默认适配器实现，它们实现了与模型转换相关的用例：</p>
</div>
<div class="sect2">
<h3 id="_viatra_transformation_debugger"><a class="link" href="#_viatra_transformation_debugger">4.1。VIATRA转换调试器</a></h3>
<div class="paragraph">
<p>VIATRA转换调试器实现了基于断点的调试方法（类似于JDT）。它利用了Eclipse Debug框架，以及一些与调试相关的自定义视图。它包含在断点条件匹配时停止转换执行的逻辑，并更新转换调试模型，根据该模型显示当前转换状态。为了支持各种调试用例，调试器也支持各种断点实现。调试器包含两个主要组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>VIATRA Debugger Runtime</em> ：它包含与正在运行的模型转换实例关联的调试器元素。这些元素负责检测转换实例并将收集的信息传播到工具元素。它们还使工具元素能够控制已检测的转换实例。</p>
</li>
<li>
<p><em>VIATRA Debugger Tooling</em> ：它包含与扩展<em>Eclipse Debug Framework</em>相关的元素。它们允许运行时元素提供的信息显示在Eclipse调试UI上，并使用户能够在调试时控制转换。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/transformation_debugger.png" alt="调试器概述">
</div>
<div class="title">图1。调试适配器</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>调试器运行时</em></p>
<div class="ulist">
<ul>
<li>
<p><em>转换调试器</em> ：观察并操纵VIATRA转换的执行。</p>
</li>
<li>
<p><em>运行时通信代理</em> ：负责编排工具和运行时组件之间的通信。使用基于JMX的通信。</p>
</li>
<li>
<p><em>调试信息</em> ：在运行时和工具组件之间传播的数据。我包含有关调试下转换状态的信息，以及相关的模型实例。此信息由调试器工具组件显示。</p>
<div class="ulist">
<ul>
<li>
<p><em>转换状态</em> ：它包含有关调试下的转换的信息。包括转换冲突集的状态和要执行的下一个激活。</p>
</li>
<li>
<p><em>模型实例表示</em> ：使用通用的可序列化元模型表示与转换关联的模型实例。</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>调试操作</em> ：从工具发送到运行时组件的用户操作。</p>
<div class="ulist">
<ul>
<li>
<p><em>断点</em> ：调试器框架支持一组不同的转换断点。</p>
<div class="ulist">
<ul>
<li>
<p><em>规则激活断点</em> ：标识转换规则激活。如果即将触发给定的激活，则将停止转换执行。</p>
</li>
<li>
<p><em>条件断点</em> ：这些断点能够定义不仅受当前激活影响的全局约束。Eclipse Java开发工具（JDT）中提供了类似的概念。约束是使用VIATRA查询语言定义的。</p>
</li>
<li>
<p><em>规则断点</em> ：这些断点标识给定的VIATRA转换规则。如果即将触发此规则的激活，则暂停执行。</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>调试器命令</em> ：从工具组件发送到运行时组件的用户命令。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><em>调试器工具</em></p>
<div class="ulist">
<ul>
<li>
<p><em>VIATRA调试器UI元素</em> ：显示特定于转换的信息的UI元素，这些信息无法通过使用Eclipse调试UI元素进行可视化。</p>
<div class="ulist">
<ul>
<li>
<p><em>VIATRA转换浏览器</em> ：显示模型转换的当前状态。显示要触发的激活集，并允许用户控制转换的执行或定义断点。显示的激活可以按其父规则分组，也可以按变换冲突集中的位置进行分组。</p>
</li>
<li>
<p><em>VIATRA转换模型实例查看器</em> ：使用具有属性支持的树视图显示与转换相关的模型实例的当前状态。</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Eclipse调试器UI元素</em> ：Eclipse调试器UI元素，显示与调试器相关的转换信息。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_trace_coder_listener"><a class="link" href="#_trace_coder_listener">4.2。跟踪编码器听众</a></h3>
<div class="paragraph">
<p>转换调试配置包含一个遵循基于断点的方法的转换调试器。然而，基于VIATRA的事件驱动模型转换的执行顺序通常是非确定性的。跟踪编码器负责记录转换执行序列（即：转换规则激活启动的顺序）。稍后可以在重新执行转换期间分析或使用此<strong>转换跟踪</strong> 。</p>
</div>
<div class="paragraph">
<p>转换跟踪是旨在存储转换执行序列的分层对象结构。转换跟踪由激活和规则参数跟踪组成。激活跟踪标识已触发的规则，规则参数跟踪指定哪些元素已触发执行给定规则。基于该信息，可以重新执行转换以进行进一步评估，或者可以在死后分析期间检测到错误的规则。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/coder_adapter.png" alt="跟踪编码器适配器" width="1000">
</div>
</div>
<div class="paragraph">
<p>与之前介绍的组件类似，跟踪编码器侦听器使用可互换的子组件：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">激活编码器</dt>
<dd>
<p>使用从激活对象中提取的参数创建激活跟踪对象。</p>
</dd>
<dt class="hdlist1">跟踪模型序列化器</dt>
<dd>
<p>负责保存和加载跟踪模型</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_trace_executor_adapter"><a class="link" href="#_trace_executor_adapter">4.3。跟踪执行器适配器</a></h3>
<div class="paragraph">
<p>该适配器负责重新执行跟踪编码器适配器记录的转换序列。在调试期间特别有用，因为它允许确定VIATRA事件驱动的转换的其他随机执行序列。它按以下方式操作：在执行转换时，将手头的激活与先前加载的转换跟踪中的即将进入的条目进行比较。如果激活与跟踪记录匹配，则执行它，否则执行程序找到匹配的记录。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/transformation/executor_adapter.png" alt="跟踪执行器适配器" width="1000">
</div>
</div>
<div class="paragraph">
<p>如此处所示，跟踪执行器组件使用与跟踪编码器相同的子组件。</p>
</div>
<div class="paragraph">
<p>有关跟踪执行程序的可读信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>此适配器的使用对转换性能有很大影响，建议仅在小规模测试模型上使用它。</p>
</li>
<li>
<p>还要记住，跟踪执行程序需要一个已经存在的转换跟踪，因此它不应与跟踪编码器同时使用。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_usage_examples"><a class="link" href="#_usage_examples">4.4。用法示例</a></h3>
<div class="paragraph">
<p>可以以简单直接的方式将适配器和侦听器添加到新的或现有的VIATRA转换中。VIATRA转换API允许转换开发人员将这些适配器和侦听器直接附加到模型转换，而无需更改转换代码本身。转换API类创建一个支持背景结构的修改后的适配器，但是这一步对转换开发人员来说是完全透明的。支持批处理和事件驱动的VIATRA转换，并将在本节中介绍。此处显示的示例使用VIATRA CPS示例模型转换来强调，添加适配器仅需要更改转换设置，但不需要对转换代码本身进行任何更改。</p>
</div>
<div class="paragraph">
<p>请注意，这些示例仅显示了向VIATRA转换添加适配器的方法。如果一起使用，这些示例中使用的适配器将不起作用（尤其是跟踪编码器和执行器组件）。为了确保适配器不会相互产生不利影响，请使用预定义的适配器配置或单个适配器。</p>
</div>
<div class="listingblock">
<div class="title">将适配器添加到批转换</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">transformation = BatchTransformation.forEngine（engine）//创建跟踪编码器监听器//该监听器负责存储转换执行序列（即：转换规则激活启动的顺序）//此转换跟踪可以在以后进行分析或使用执行//转换跟踪 - &gt;分层对象结构 - &gt;旨在存储转换执行序列。//由激活和规则参数跟踪组成 - &gt;激活跟踪标识已触发的规则，并指定哪些元素已触发执行给定规则。.addListener（new TraceCoder（URI.createURI（“transformationtrace / batchtrace.transformationtrace”）））//创建跟踪执行器适配器//此适配器负责重新执行跟踪编码器适配器记录的转换序列。//在调试期间特别有用，因为它允许确定VIATRA事件驱动转换的其他随机执行序列。//请注意，此适配器的使用对转换性能有很大影响，建议仅在小规模测试模型上使用它。//还要记住，跟踪执行程序需要一个已经存在的转换跟踪，因此它不应与跟踪编码器同时使用。.addAdapter（new TraceExecutor（URI.createURI（“transformationtrace / trace.transformationtrace”）））//此侦听器实现基本的日志记录功能.addListener（new LoggingEVMListener（logger））。build</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">将适配器添加到事件驱动的转换中</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">transformation = EventDrivenTransformation.forEngine（engine）.setConflictResolver（createConflictResolver）.addRule（hostRule）.addRule（applicationRule）.addListener（new TraceCoder（URI.createURI（“transformationtrace / trace.transformationtrace”）））。addAdapter（new TraceExecutor（URI） .createURI（“transformationtrace / edtrace.transformationtrace”）））。addListener（new LoggingEVMListener（logger））。build</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html><html id="3168.org_eclipse_ui_viewActions.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>查看菜单，工具栏和操作</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">查看菜单，工具栏和操作</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>的org.eclipse.ui.viewActions<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>此扩展点用于向下拉菜单和工具栏添加操作，以便其他插件注册的视图。每个视图都有一个本地下拉菜单，通常通过单击右上角的三角形按钮激活。其他插件可以为此菜单提供子菜单和操作。插件也可以为视图工具栏提供操作。视图所有者首先有机会填充这些区域。附加了其他插件的可选添加项。</p>
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.viewContribution">viewContribution</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewContribution">viewContribution</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST viewContribution</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">targetID IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素用于定义一组视图动作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符。</li>
<li><b>targetID</b> - 作为此贡献的目标的已注册视图的唯一标识符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">disabledIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">hoverIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在下拉菜单中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在下拉菜单中。</li>
<li><b>toolbarPath</b> - 目标视图的本地工具栏中的命名组。如果该组不存在，则将创建该组。如果省略，则操作不会显示在本地工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件的位置。图标将显示在工具栏中，但不会显示在下拉菜单中。</li>
<li><b>disabledIcon</b> - 用于在禁用操作时直观地表示其上下文中的操作的图标的相对路径。如果省略，则普通图标将显示为灰色。该路径相对于贡献插件的plugin.xml文件的位置。禁用的图标将显示在工具栏中，但不会显示在下拉菜单中。</li>
<li><b>hoverIcon</b> - 用于在鼠标指针悬停在操作上时可视地表示其上下文中的操作的图标的相对路径。如果省略，将使用普通图标。该路径相对于贡献插件的plugin.xml文件的位置。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。在某些平台上，如果操作显示为菜单项，则在菜单项突出显示时按相应的帮助键将显示帮助。并非所有平台都支持此行为。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的可选属性。如果已定义，则属性值将为以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- 作为下拉工具项目。初始值由<samp>state</samp>属性指定。</td>
      </tr>    </table></li>
<li><b>state</b> - 一个可选属性，指示初始状态（ <samp>true</samp>或<samp>false</samp> ），当<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的完全限定类的名称<samp>。IViewActionDelegate</samp> 。</li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定了此属性并且满足条件，则启用该操作。如果不满足条件，则禁用该操作。如果未指定任何属性，则会为所选的任意数量的项启用该操作。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IViewActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是视图操作扩展的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.viewActions”</span> <span class="code SchemaTag">&gt; &lt;viewContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzViewC1”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“org.eclipse.ui.views.navigator。ResourceNavigator“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / group1”</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">“Normal / additions”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“toggle”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ.gif”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“Run XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunXYZ“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;/ viewContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作仅启用单个选择（ <samp>enableFor</samp>属性）。此外，选择中的对象必须是Java文件资源。
</p>
<p>以下是视图操作扩展的另一个示例：</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.viewActions”</span> <span class="code SchemaTag">&gt; &lt;viewContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzViewC1”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“org.eclipse.ui.views.navigator。ResourceNavigator“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ2 Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / group1”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ2.gif”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行XYZ2工具”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz.run_action_context2”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.actions。RunXYZ2“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;/ viewContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为菜单项。如果选择不包含Java文件资源，则启用该操作。
</p><p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>class</samp>属性的值必须是实现<samp>org.eclipse.ui的Java类的完全限定名<samp>。IViewActionDelegate</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。
<p>接口<samp>org.eclipse.ui。IViewActionDelegate</samp>扩展了<samp>org.eclipse.ui。IActionDelegate</samp>并添加了一个额外的方法，允许委托使用它所贡献的视图实例进行初始化。
</p>
<p>此扩展点可用于将操作提供给先前由目标视图创建的菜单。省略菜单路径属性将导致在下拉菜单末尾添加新菜单或操作。
</p>
<p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p>
<p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>每个视图通常在下拉菜单和本地工具栏上都有许多标准项。来自其他插件的添加内容将附加到标准补充中。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2007 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html>