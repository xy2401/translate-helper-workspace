<html id="2299.OCLinEcore.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>OCLinEcore语言</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="UsersGuide.html" title="Users Guide"></link>
<link rel="prev" href="EssentialOCL.html" title="The Essential OCL Language"></link>
<link rel="next" href="CompleteOCL.html" title="The Complete OCL Language"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">OCLinEcore语言</h1>
<div class="section" title="OCLinEcore语言">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OCLinEcore"></a> OCLinEcore语言</h2>
</div>
</div>
</div>
<p>Ecore Abstract Syntax支持使用嵌入在EAnnotations中的OCL。</p>
<p>OCLinEcore语言提供了一个文本的具体语法，使用户可以访问Ecore和OCL。可以在<a class="link" href="Tutorials.html#OCLinEcoreMetamodel" title="将Ecore模型编辑为OCLinEcore">OCLinEcore Library Metamodel</a>和<a class="link" href="Tutorials.html#OCLinEcoreTutorialHelpers" title="帮手功能和操作">OCLinEcore Helpers中</a>找到示例。
			</p>
<p>OCLinEcore工具提供了基于Xtext的丰富编辑环境，具有强大的语义检查功能。</p>
<p>OCLinEcore不仅仅是Ecore的OCL编辑器，它非常有用</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>提供Ecore元模型的连贯文本视图</p>
</li>
<li class="listitem">
<p>为某些Ecore约定提供语法糖</p>
</li>
<li class="listitem">
<p>编辑和验证OCL</p>
</li>
<li class="listitem">
<p>将OCL整合到Ecore中</p>
</li>
</ul>
</div>
<p>计划进一步采用语法糖并为所有与类相关的UML概念提供全面支持。因此，语言尽可能使用UML作为其参考点。</p>
<p>OCLinEcore工具可以直接在* .ecore文件上使用，也可以在* .oclinecore文本对应文件上使用。</p>
<p>请按照<a class="link" href="Tutorials.html#OCLinEcoreTutorial" title="OCLinEcore教程">OCLinEcore教程</a>了解该语言及其工具的介绍。
			</p>
<div class="section" title="句法">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Syntax2"></a>句法</h3>
</div>
</div>
</div>
<p>OCLinEcore语法具有一致的结构，受OMG规范中的非正式定义和Ecore层次结构的影响。大多数Ecore概念由表单的语法表示：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可选的主要形容词</p>
</li>
<li class="listitem">
<p>强制关键字</p>
</li>
<li class="listitem">
<p>强制名称方面</p>
</li>
<li class="listitem">
<p>进一步的方面</p>
</li>
<li class="listitem">
<p>次要形容词的可选括号</p>
</li>
<li class="listitem">
<p>元素的可选括号子句</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>组成元素</p>
</li>
<li class="listitem">
<p>注释</p>
</li>
<li class="listitem">
<p>限制</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>因此在：</p>
<div class="literallayout">
<p>
<code class="code">abstract class示例extends Base {interface} {...}<br>

</code>
</p>
</div>
<p></p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">abstract</code>是一个主要的形容词</p>
</li>
<li class="listitem">
<p>
							
<code class="code">class</code>是一个关键字</p>
</li>
<li class="listitem">
<p>
							
<code class="code">Example</code>是名称facet</p>
</li>
<li class="listitem">
<p>
							
<code class="code">extends Base</code>是另一个方面</p>
</li>
<li class="listitem">
<p>
							
<code class="code">{ interface }</code>支持二级界面形容词。
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">{ ... }</code>为类内容提供嵌套上下文。
						</p>
</li>
</ul>
</div>
<div class="section" title="语法实现">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="GrammarImplementation2"></a>语法实现</h4>
</div>
</div>
</div>
<p>Xtext编辑器使用的语法可以在以下位置找到：</p>
<p>/src/org/eclipse/ocl/examples/xtext/oclinecore/OCLinEcore.xtext</p>
<p>在org.eclipse.ocl.xtext.oclinecore插件中。OCLinEcore语法扩展了Essential OCL语法。</p>
</div>
<div class="section" title="模">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Module"></a>模</h4>
</div>
</div>
</div>
<p>Module语法支持Ecore文件的整体结构</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-rootpackage.png"></div>
<p>
					
</p>
<p>该模块的定义包括</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可选模块声明</p>
</li>
<li class="listitem">
<p>OCL标准库的可选规范</p>
</li>
<li class="listitem">
<p>可选导入引用的Ecore或UML或OCLinEcore资源</p>
</li>
<li class="listitem">
<p><a class="link" href="OCLinEcore.html#OCLinEcore-Package" title="包">包</a>的层次结构
							
</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-library.png"></div>
<p>
					
</p>
<p>可以导入零个或多个外部库，以便合并它们的定义，以形成基本和扩展评估功能的复合库。</p>
<p>如果导入了任何库，则会禁止隐式导入默认OCL标准库。可以通过将默认库指定为第一个库导入来扩展默认库。</p>
<div class="literallayout">
<p>
<code class="code">library ocl：'http：//www.eclipse.org/ocl/3.1.0/OCL.oclstdlib'<br>

</code>
</p>
</div>
<p></p>
<p>第一个库包的名称空间URI定义了复合库的名称空间URI。后续库导入的名称空间URI可能不会冲突，但可能为null。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-import.png"></div>
<p>
					
</p>
<p>可以导入零个或多个外部元模型。</p>
</div>
<div class="section" title="包">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Package"></a>包</h4>
</div>
</div>
</div>
<p>Package语法支持包和分类器的嵌套层次结构</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-package1.png"></div>
<p>
					
</p>
<p>包具有名称和可选的名称空间前缀和名称空间URI。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-package2.png"></div>
<p>
					
</p>
<p>包的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Package" title="包">包</a> ， <a class="link" href="OCLinEcore.html#OCLinEcore-Classifier" title="分类">分类器</a>和<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> 。
					</p>
</div>
<div class="section" title="分类">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Classifier"></a>分类</h4>
</div>
</div>
</div>
<p>Classifier语法支持<a class="link" href="OCLinEcore.html#OCLinEcore-Package" title="包">Package</a>中类型的定义。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-classifiers.png"></div>
<p>
					
</p>
<p>分类器可以是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一<a class="link" href="OCLinEcore.html#OCLinEcore-Class" title="类">类</a>
							
</p>
</li>
<li class="listitem">
<p>一个<a class="link" href="OCLinEcore.html#OCLinEcore-DataType" title="数据类型">DataType</a>
							
</p>
</li>
<li class="listitem">
<p>一个<a class="link" href="OCLinEcore.html#OCLinEcore-Enumeration" title="列举">枚举</a>具有相关<a class="link" href="OCLinEcore.html#OCLinEcore-EnumerationLiteral" title="EnumerationLiteral">EnumerationLiterals</a>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="数据类型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-DataType"></a>数据类型</h4>
</div>
</div>
</div>
<p>DataType语法支持EDataType的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-datatype1.png"></div>
<p>
					
</p>
<p>DataType具有名称和可选的模板参数以及实例类名称。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-datatype2.png"></div>
<p>
					
</p>
<p>DataType可以是可序列化的;默认情况下不是。</p>
<p>DataType的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">不变量</a>和<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> 。
					</p>
</div>
<div class="section" title="列举">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Enumeration"></a>列举</h4>
</div>
</div>
</div>
<p>Enumeration语法支持EEnum的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-enumeration1.png"></div>
<p>
					
</p>
<p>Enumeration具有名称和可选的模板参数以及实例类名称。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-enumeration2.png"></div>
<p>
					
</p>
<p>枚举可以是可序列化的;默认情况下不是。</p>
<p>枚举的内容可以包括枚举文字， <a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">不变量</a>和<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> 。
					</p>
</div>
<div class="section" title="EnumerationLiteral">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-EnumerationLiteral"></a> EnumerationLiteral</h4>
</div>
</div>
</div>
<p>EnumerationLiteral语法支持EEnumLiteral的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-enumerationliteral.png"></div>
<p>
					
</p>
<p>EnumerationLiteral具有名称和可选值。</p>
<p>EnumerationLiteral的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">Annotations</a> 。
					</p>
</div>
<div class="section" title="类">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Class"></a>类</h4>
</div>
</div>
</div>
<p>Class语法支持EClass的定义。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可选的抽象前缀</p>
</li>
<li class="listitem">
<p>其他分类器的可选扩展</p>
</li>
<li class="listitem">
<p>可选的不变量，注释，功能和操作</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-class1.png"></div>
<p>
					
</p>
<p>一个类可以是抽象的，具有名称和可选的模板参数。</p>
<p>（注意，'abstract'前缀是可选的，即使该图表明它是必需的。）</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-class2.png"></div>
<p>
					
</p>
<p>类可以使用模板参数扩展可以专门化的一个或多个其他<a class="link" href="OCLinEcore.html#OCLinEcore-TypeRef" title="类型">类</a> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-class3.png"></div>
<p>
					
</p>
<p>Class可以具有实例类名称，也可以声明为接口。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-class4.png"></div>
<p>
					
</p>
<p>类的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> ， <a class="link" href="OCLinEcore.html#OCLinEcore-Operation" title="手术">操作</a> ， <a class="link" href="OCLinEcore.html#OCLinEcore-StructuralFeature" title="StructuralFeature">结构特征</a>和<a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">不变量</a> 。
					</p>
</div>
<div class="section" title="StructuralFeature">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-StructuralFeature"></a> StructuralFeature</h4>
</div>
</div>
</div>
<p>StructuralFeature语法支持StructuralFeatures的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-features.png"></div>
<p>
					
</p>
<p>结构特征可能是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><a class="link" href="OCLinEcore.html#OCLinEcore-Attribute" title="属性">属性</a>
							
</p>
</li>
<li class="listitem">
<p><a class="link" href="OCLinEcore.html#OCLinEcore-Reference" title="参考">参考</a>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="属性">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Attribute"></a>属性</h4>
</div>
</div>
</div>
<p>Attribute语法支持EAttribute的定义;具有DataType值的属性。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-attribute1.png"></div>
<p>
					
</p>
<p>属性可以是静态的并且具有名称。</p>
<p><code class="code">static</code>限定符支持UML和OCL支持的静态属性声明。请注意，Ecore不支持静态属性。
					</p>
<p><code class="code">definition</code>限定符是完整OCL定义的过时实验语法。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-attribute2.png"></div>
<p>
					
</p>
<p>属性可以具有<a class="link" href="OCLinEcore.html#OCLinEcore-TypeRef" title="类型">类型</a>和多重性。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-attribute3.png"></div>
<p>
					
</p>
<p>Attribute可以是一个简单的初始化程序和各种限定符：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">derived</code>指定派生属性（默认值<code class="code">!derived</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">id</code>指定该属性提供其类的标识符（默认值<code class="code">!id</code> ））</p>
</li>
<li class="listitem">
<p>
								
<code class="code">ordered</code>指定属性元素是有序的（默认<code class="code">!ordered</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">readonly</code>指定属性元素是只读的（不可更改）（默认<code class="code">!readonly</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">transient</code>指定属性元素是动态计算的（默认值<code class="code">!transient</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unique</code>指定没有重复的属性元素（默认<code class="code">unique</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unsettable</code>指定属性元素可能没有值（默认值<code class="code">!unsettable</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">volatile</code>指定属性元素不是持久化的（默认值<code class="code">!volatile</code> ）</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-attribute4.png"></div>
<p>
					
</p>
<p>属性的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> ，初始和派生<a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">约束</a> 。
					</p>
<p>可以使用初始化器定义简单的常量值。计算值需要使用约束。如果存在初始约束和派生约束，则忽略初始约束。</p>
<p>多重性下限和上限以及<code class="code">ordered</code>和<code class="code">unique</code>的默认值遵循UML规范，因此对应于单个元素集<code class="code">[1] {unique,!ordered}</code> 。请注意，UML默认值与Ecore默认值不同，后者对应于可选元素OrderedSet，即<code class="code">[?]{ordered,unique}</code> 。
					</p>
</div>
<div class="section" title="参考">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Reference"></a>参考</h4>
</div>
</div>
</div>
<p>Reference语法支持EReference的定义;具有类值的属性。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-reference1.png"></div>
<p>
					
</p>
<p>引用可以是静态的，并且具有名称和可选的相反名称。</p>
<p><code class="code">static</code>限定符支持UML和OCL支持的静态属性声明。请注意，Ecore不支持静态属性。
					</p>
<p><code class="code">definition</code>限定符是完整OCL定义的过时实验语法。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-reference2.png"></div>
<p>
					
</p>
<p>参考可以具有<a class="link" href="OCLinEcore.html#OCLinEcore-TypeRef" title="类型">类型</a>和多重性。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-reference3.png"></div>
<p>
					
</p>
<p>Reference可以是一个简单的初始化器和各种限定符：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">composes</code>指定一个撰写（包含）引用（默认<code class="code">!composes</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">derived</code>指定派生引用（默认<code class="code">!derived</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">ordered</code>指定参考元素是有序的（默认<code class="code">!ordered</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">readonly</code>指定引用元素是只读的（不可更改）（默认值<code class="code">!readonly</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">resolve</code>指定参考元素代理可能需要解析（默认<code class="code">!resolve</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">transient</code>指定参考元素是动态计算的（默认值<code class="code">!transient</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unique</code>指定没有重复的引用元素（默认<code class="code">unique</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unsettable</code>指定引用元素可能没有值（默认值<code class="code">!unsettable</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">volatile</code>指定不保留引用元素（默认值<code class="code">!volatile</code> ）</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-reference4.png"></div>
<p>
					
</p>
<p>Reference的内容可以包括键， <a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> ，初始和派生<a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">约束</a> 。
					</p>
<p>可以使用初始化器定义简单的常量值。计算值需要使用约束。如果存在初始约束和派生约束，则忽略初始约束。</p>
<p>多重性下限和上限以及<code class="code">ordered</code>和<code class="code">unique</code>的默认值遵循UML规范，因此对应于单个元素集<code class="code">[1] {unique,!ordered}</code> 。请注意，UML默认值与Ecore默认值不同，后者对应于可选元素OrderedSet，即<code class="code">[?]{ordered,unique}</code> 。
					</p>
</div>
<div class="section" title="手术">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Operation"></a>手术</h4>
</div>
</div>
</div>
<p>Operation语法支持EOperation的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation1.png"></div>
<p>
					
</p>
<p>操作可以是静态的，并且具有名称和可选的模板参数。</p>
<p><code class="code">static</code>限定符支持UML和OCL支持的静态操作的声明。请注意，Ecore不支持静态操作。
					</p>
<p><code class="code">definition</code>限定符是完整OCL定义的过时实验语法。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation2.png"></div>
<p>
					
</p>
<p>操作具有零个更多<a class="link" href="OCLinEcore.html#OCLinEcore-Parameter" title="参数">参数</a> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation3.png"></div>
<p>
					
</p>
<p>操作可以具有返回<a class="link" href="OCLinEcore.html#OCLinEcore-TypeRef" title="类型">类型</a>和多重性。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation4.png"></div>
<p>
					
</p>
<p>操作可以声明零次或多次抛出<a class="link" href="OCLinEcore.html#OCLinEcore-TypeRef" title="类型">异常</a> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation5.png"></div>
<p>
					
</p>
<p>操作可能有多种限定符：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">derived</code>指定派生操作（默认<code class="code">!derived</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">ordered</code>指定返回的元素是有序的（默认<code class="code">!ordered</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unique</code>指定没有重复的返回元素（默认<code class="code">unique</code> ）</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-operation6.png"></div>
<p>
					
</p>
<p>操作的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> ，前提条件，后置条件和身体<a class="link" href="OCLinEcore.html#OCLinEcore-Constraint" title="约束">约束</a> 。
					</p>
<p><code class="code">static</code>限定符支持UML和OCL支持的静态操作的声明。请注意，Ecore不支持静态操作。
					</p>
<p><code class="code">definition</code>限定符是完整OCL定义的过时实验语法。
					</p>
<p>多重性下限和上限以及<code class="code">ordered</code>和<code class="code">unique</code>的默认值遵循UML规范，因此对应于单个元素集<code class="code">[1] {unique,!ordered}</code> 。请注意，UML默认值与Ecore默认值不同，后者对应于可选元素OrderedSet，即<code class="code">[?]{ordered,unique}</code> 。
					</p>
</div>
<div class="section" title="参数">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Parameter"></a>参数</h4>
</div>
</div>
</div>
<p>Parameter语法支持EParameter的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-parameter1.png"></div>
<p>
					
</p>
<p>参数有一个名称，可选“Type：＃OCLinEcore-TypeRef和multiplicity</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-parameter2.png"></div>
<p>
					
</p>
<p>参数可以有多种限定符：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">ordered</code>指定返回的元素是有序的（默认<code class="code">!ordered</code> ）</p>
</li>
<li class="listitem">
<p>
								
<code class="code">unique</code>指定没有重复的返回元素（默认<code class="code">unique</code> ）</p>
</li>
</ul>
</div>
<p>参数的内容可以包括<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a> 。
					</p>
<p>多重性下限和上限以及<code class="code">ordered</code>和<code class="code">unique</code>的默认值遵循UML规范，因此对应于单个元素集<code class="code">[1] {unique,!ordered}</code> 。请注意，UML默认值与Ecore默认值不同，后者对应于可选元素OrderedSet，即<code class="code">[?]{ordered,unique}</code> 。
					</p>
</div>
<div class="section" title="类型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-TypeRef"></a>类型</h4>
</div>
</div>
</div>
<p>Type语法支持EType和EGenericType的定义以及ETypedElement。语法与Java非常相似。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-types.png"></div>
<p>
					
</p>
<p>
						
<span class="emphasis"><em>PrimitiveTypeRefCS</em></span>提供对内置OCL类型及其相应的Ecore对应类型的访问</p>
<table id="N10D05">
<tr>
							
<th>OCL类型</th>
							<th>Ecore类型</th>
						
</tr>
<tr>
							
<td>布尔</td>
							<td>EBoolean</td>
						
</tr>
<tr>
							
<td>整数</td>
							<td>EBigInteger</td>
						
</tr>
<tr>
							
<td>真实</td>
							<td>EBigDecimal</td>
						
</tr>
<tr>
							
<td>串</td>
							<td>为EString</td>
						
</tr>
<tr>
							
<td>UnlimitedNatural</td>
							<td>EBigInteger</td>
						
</tr>
</table>
<p>
						
<span class="emphasis"><em>TypedTypeRefCS</em></span>提供用户定义的类型及其模板参数化。
					</p>
</div>
<div class="section" title="AnnotationElement">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Annotations"></a> AnnotationElement</h4>
</div>
</div>
</div>
<p>AnnotationElement语法支持使用详细信息，引用和内容定义EAnnotation层次结构。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-annotations.png"></div>
<p>
					
</p>
<p>AnnotationElement可以是<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a>或<a class="link" href="OCLinEcore.html#OCLinEcore-Documentation" title="文档">文档</a> 。
					</p>
</div>
<div class="section" title="注解">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Annotation"></a>注解</h4>
</div>
</div>
</div>
<p>Annotation语法支持使用详细信息，引用和内容定义EAnnotation层次结构。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-annotation1.png"></div>
<p>
					
</p>
<p>Annotation具有源URI，如果URI只是名称，则可以不带引号指定。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-annotation2.png"></div>
<p>
					
</p>
<p>注释可能包含<a class="link" href="OCLinEcore.html#OCLinEcore-Detail" title="详情">详细信息</a> 。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-annotation3.png"></div>
<p>
					
</p>
<p>注释的内容可以包括</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="OCLinEcore.html#OCLinEcore-Annotation" title="注解">注释</a>
							
</p>
</li>
<li class="listitem">
<p>内容要素</p>
</li>
<li class="listitem">
<p>引用其他元素的名称</p>
</li>
</ul>
</div>
</div>
<div class="section" title="详情">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Detail"></a>详情</h4>
</div>
</div>
</div>
<p>Detail语法支持EAnnotation细节的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-detail.png"></div>
<p>
					
</p>
<p>细节包括细节键和可选值。</p>
</div>
<div class="section" title="文档">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Documentation"></a>文档</h4>
</div>
</div>
</div>
<p>Documentation语法是genmodel注释的实验性语法糖。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-annotations.png"></div>
<p>
					
</p>
<p>它可能会被一个Javadoc风格的评论所取代，该评论将持续存在于Ecore中。</p>
</div>
<div class="section" title="约束">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinEcore-Constraint"></a>约束</h4>
</div>
</div>
</div>
<p>Constraints语法支持将OCL表达式嵌入为类的不变量，作为前提条件，后置条件或操作主体以及属性的初始值或派生值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-constraints.png"></div>
<p>
					
</p>
<p>通过调用<a class="link" href="EssentialOCL.html#EssentialOCL-Exp" title="OCL Expression">ExpCS</a>的<span class="emphasis"><em>SpecificationCS</em></span>规则进行<a class="link" href="EssentialOCL.html#EssentialOCL-Exp" title="OCL表达">集成</a> 。 （替代<span class="emphasis"><em>UnquotedString</em></span>是一个实现细节，支持从Ecore导入，其中OCL是未解析的文本形式而不是分析的语法树。）
					</p>
<p>可以<code class="code">callable</code>类不变量来指定Ecore表示将使用EOperation而不是EAnnotation表示。
					</p>
<p>类不变量可选地支持第二个OCL表达式作为不变名称的括号。当不变量失败以便提供用户定义的失败消息时，将调用此带括号的表达式。此消息是错误还是警告取决于对不变量的评估：</p>
</div>
<div class="section" title="码头">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Terminals"></a>码头</h4>
</div>
</div>
</div>
<p>OCLinEcore语法扩展了Esstial OCL语法，应该参考INT语法和ExpCS的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1200-terminals.png"></div>
<p>
					
</p>
</div>
<div class="section" title="名称">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Names"></a>名称</h4>
</div>
</div>
</div>
<p>Unrestricted name是OCL保留关键字以外的任何名称。请参见<a class="link" href="EssentialOCL.html#EssentialOCL-UnrestrictedName" title="UnrestrictedName">UnrestrictedName</a> 。
					</p>
<p>未保留的名称是除上述OCL保留关键字或OCL保留类型之外的任何名称。请参见<a class="link" href="EssentialOCL.html#EssentialOCL-UnreservedName" title="UnreservedName">UnreservedName</a> 。
					</p>
<p>如果需要使用任何这些名称或非字母数字名称，则必须使用转义字符串语法作为名称：例如<code class="code">_'true'</code> 。除了八进制外，支持通常的Java反斜杠转义： <code class="code">_'new-lines\n\x0a\u000a'</code>
					
</p>
</div>
<div class="section" title="评论">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Comments"></a>评论</h4>
</div>
</div>
</div>
<p>忽略以下所有文本支持单行注释<code class="code">--</code> 。
					</p>
<p>忽略<code class="code">/* ...所有文本支持多行注释*/</code> 。
					</p>
<p><code class="code">/** ...所有文本都支持文档注释<code class="code">/** ...*/</code> 。遗憾的是，目前没有创建文档EAnnotation。
					</p>
</div>
</div>
<div class="section" title="限制">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Limitations"></a>限制</h3>
</div>
</div>
</div>
<p>OCLinEcore支持Ecore的全部功能，但是对泛型类型的上限和下限的支持尚未得到充分测试。</p>
<p>OCLinEcore为一些Ecore约定提供了主要语法，例如genmodel注释和约束;功能图需要更多支持。</p>
</div>
</div>
</body>
</html><html id="3153.org_eclipse_ui_menus.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>菜单</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">菜单</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.menus<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.3<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>此扩展点允许插件开发人员向eclipse框架添加（贡献）各种自定义添加：</p><ul>
  <li>主菜单</li>
  <li>主要工具栏</li>
  <li>查看菜单/工具栏：<ul>
    <li>查看下拉菜单</li>
    <li>查看工具栏</li>
    <li>上下文菜单</li>
  </ul>
  </li>
  <li>修剪</li>
</ul>

<p>它提供了一个通用实现，并作为以下（传统）eclipse扩展点的替代：</p><ul>
<li>org.eclipse.ui。ActionSets</li>
<li>org.eclipse.ui。EditorActions</li>
<li>org.eclipse.ui.popupMenus（包括'objectContributions'）</li>
<li>的org.eclipse.ui.viewActions</li>
</ul>

<p>此机制的一般策略是将应该插入贡献的“位置”与元素的可见性和启用状态分开。每个贡献首先通过菜单'URI'定义其插入位置，这是一个根据jave.net格式化的字符串（松散）。URI格式：</p><p>
<b>“[方案]：[ID] [ArgList中]？“</b>
</p><ul>
<li><b>Scheme</b> - 要添加贡献的UI组件的“类型”。它可以是“菜单”，“弹出窗口”或“工具栏”。虽然'popup'确实是一种菜单形式，但是它允许区分视图的'V形'菜单（我们使用“菜单”方案）和它的默认上下文菜单，按照惯例，它应该使用“弹出”计划。</li>
<li><b>ID</b> - 这是应添加贡献的菜单或工具栏的ID。按照惯例，视图应使用其视图ID作为其V形符号和默认弹出菜单的根ID。请注意，支持编辑器的贡献与菜单菜单或工具栏中的“正常”贡献之间没有明确的区别;全局贡献和编辑器贡献都将使用“org.eclipse.ui.main.menu”id或“org.eclipse.ui.main.toolbar”。与popup：，“org.eclipse.ui.popup.any”一起使用的特殊id被保留用于处理在任何（顶级）上下文菜单中出现的候选者。请注意，这些贡献应该实现一个'visibleWhen'表达式，足以限制它们对适当菜单的可见性</li>
<li><b>查询</b> - 此字段允许<i>在</i>给定菜单中对特定位置进行细粒度定义。它具有“[placement] = [id]”形式，其中placement是“before”，“after”或“endof”之一，并且id应该是菜单中某个IContributionItem的id。</li>
</ul> 
<p>这将定义贡献在eclipse UI中出现的位置。一旦定义了插入点，其余贡献将描述将在该位置添加的UI元素。每个元素都支持'visibleWhen'表达式，该表达式在运行时根据系统的当前状态（选择，活动视图/编辑器，上下文...）确定特定项是否应出现在菜单中。请参阅<code>org.eclipse.ui.用于当前支持的变量列表的ISources</code> 。
</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.group">组</a> *， <a href="#e.widget">小部件</a> *， <a href="#e.menuContribution">menuContribution</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> -  org.eclipse.ui.menus</li>
<li><b>id</b> - 扩展实例的可选标识符。</li>
<li><b>name</b> - 扩展实例的可选名称。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>group</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.group">组</a> （ <a href="#e.location">位置</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST集团</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">separatorsVisible（true | false）“true”&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>一个逻辑组。它可以是可见的（例如，分隔符在适当之前和之后绘制）或不可见。默认情况下，逻辑组是可见的。
</p>
<p>组可以包含菜单，项目和其他组。
</p>
<p>不推荐使用此元素。组现在表示为id'd'separator'元素。菜单插入URI可用于在<b>任何</b> id'd元素“之前”或“之后”定义插入点，并将其放置在分隔符与将其贡献给组之后相同。</p>
<p>有关如何定义插入点以及它们与菜单结构的关系的更多详细信息，请参阅“menuAddition”的“locationURI”属性的文档。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 该组的唯一标识符。建议标识符以插件名称为前缀，以保证唯一性。例如， <code>org.eclipse.ui</code>提供的组可能被称为<code>org.eclipse.ui.group1</code> 。</li>
<li><b>separatorsVisible</b> - 是否应在组周围绘制分隔符。工作台将负责决定是否需要在顶部或底部绘制分隔符 - 考虑菜单的顶部和底部以及重复的分隔符。默认情况下，分隔符是可见的。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>widget</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.widget">小部件</a> （ <a href="#e.location">位置</a> *， <a href="#e.class">类</a> ？， <a href="#e.visibleWhen">visibleWhen</a> ?, <a href="#e.layout">布局</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST小部件</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">可以直接访问窗口小部件的菜单或修剪元素。例如，这可以用于呈现组合框。<b>注意：</b>如果窗口小部件元素在用户界面中可见，则会导致插件加载。<strong>请谨慎使用此元素，因为它可能会导致性能问题。</strong>当用作修剪时，窗口小部件只会在UI中显示插件时加载。<p>
<b>注意：</b>不推荐使用此元素。客户应该为其中一个修剪区域贡献一个工具栏，并在其中放置一个控制贡献。有关详细信息，请参阅修剪贡献示例。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此窗口小部件的唯一标识符。建议标识符以插件名称为前缀，以保证唯一性。例如， <code>org.eclipse.ui</code>提供的小部件可能被称为<code>org.eclipse.ui.widget1</code> 。
<p>如果已定义，那么它可以在位置的Query部分中用作参考，用于定义添加是在此元素之前还是之后（或者在包含此元素的逻辑组的末尾使用'endof'值）。
</p></li>
<li><b>class</b> - 加载此类以填充菜单中的适当位置或显示时修剪。严格来说，这个类必须实现<code>IWorkbenchWidget</code>你应该使用默认实现; <code>AbstractWorkbenchTrimWidget</code>作为派生窗口小部件实现的基础。此实现处理'init'方法并通过其<code>getWorkbenchWindow</code>方法缓存结果以供使用。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>layout</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.layout">布局</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST布局</p>
<p class="code SchemaDtdAttlist">fillMajor（true | false）</p>
<p class="code SchemaDtdAttlist">fillMinor（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素可用于为添加到<code>trim</code>位置的元素指定各种布局选项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>fillMajor</b> - 小部件将拉伸以消耗组区域中其<b>主要</b>维度上可用的任何其他空间（即，它将使用额外的水平空间用于水平定向的修剪区域）。默认值为<code>false</code> 。</li>
<li><b>fillMinor</b> -小部件将伸展在该集团的区域使用了可用的任何额外的空间，沿着它的<b>小</b>尺寸（即，它会使用水平方向的微调地区额外的垂直空间）。默认值为<code>false</code> 。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>location</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.location">位置</a> （ <a href="#e.order">订单</a> ？，（ <a href="#e.bar">栏</a> | <a href="#e.part">部分</a> | <a href="#e.popup">弹出</a> ））&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST位置</p>
<p class="code SchemaDtdAttlist">imageStyle CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">可以显示<code>menu</code> ， <code>group</code> ， <code>item</code>或<code>widget</code> 。此元素用于控制特定于位置的信息。
<p>不推荐使用此元素。此扩展点的用户现在应使用“locationURI”规范定义其贡献应出现的位置。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不</i> <b>推荐</b> <i style="color:red">使用的</i> <b>imageStyle</b> - 与此位置关联的图像样式。命令可能具有与之关联的不同样式的图像。例如，可以为工具栏和菜单选择不同的图标。这对于使用工具栏中的下拉工具项的开发人员尤为重要，因为他们可能希望显示更适合下拉列表的图标。</li>
</ul>
<br><div style="color:red;font-style:italic"><b>bar</b>元素已弃用</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.bar">bar</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST吧</p>
<p class="code SchemaDtdAttlist">类型（菜单|修剪）</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">位置内的叶元素。这可以是菜单栏或修剪区域。如果不合格，则表示顶级菜单栏或修剪。如果使用<code>part</code>元素限定，则表示该部件的菜单或修剪。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">弃用</i> <b>类型</b> -<p>
<b>注意：</b>这不仅被弃用，而且在当前实现中没有值（唯一可接受的值是'trim'，这是默认值。您可以安全地从任何声明中删除它。
</p>
<p>什么类型的酒吧贡献。这可以是<code>menu</code>或<code>trim</code> 。如果对菜单有贡献，那么该项目将成为某些小部件结构的父级。通常，这意味着使用窗口小部件元素没有多大意义，并且项目命令的图标不是必需的。默认值为<code>menu</code> 。
</p>
<p>
</p><p>如果对<code>trim</code>有贡献，那么条形图通常不需要命令或图标，它应该填充显示修剪信息的小部件。
</p><p>在修剪中，工作台定义了五个通用组，它们对应于窗口周围的各种位置：</p><ul>
<li><b>command1</b> - 表示主工具栏放置的（水平）修剪区域。</li>
<li><b>command2</b> - 这表示Perspective Switcher默认处于的（水平）修剪区域。</li>
<li><b>vertical1</b> - 这表示当文本方向为Left-&gt; Right时左侧（垂直）修剪区域，右侧为Right-&gt; Left文本。</li>
<li><b>vertical2</b> - 这表示工作台与<code>vertical1</code>相对的（垂直）修剪区域。</li>
<li><b>status</b> - 表示沿工作台底边的（水平）修剪区域。</li>
</ul>通过将修剪贡献定位在这些组内或相对于这些组，该位置由工作台推断。
</li>
<li><i style="color:red">不推荐使用的</i> <b>路径</b> - 这表示要将窗口小部件放入的组的ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">支持<code>widget</code>和<code>dynamic</code>元素的可执行扩展解析语法的类元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 要作为<code>IExecutableExtension</code>加载的类。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibleWhen">visibleWhen</a> （ <a href="#e.not">not</a> | <a href="#e.or">或</a> | <a href="#e.and">and</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）？&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST可见时</p>
<p class="code SchemaDtdAttlist">checkEnabled（true | false）“false”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个核心表达式，用于控制给定元素的可见性。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>checkEnabled</b> - 如果此属性设置为<code>true</code> ，则应该没有子元素。这只是检查命令的启用状态，并在启用命令时使相应的元素可见。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>part</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.part">部分</a> （ <a href="#e.popup">弹出</a> | <a href="#e.bar">栏</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST部分</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>位置内的元素。这使位置可以引用特定的工作台部件。这可以是视图或编辑器。限定可以使用部件的类名（包括继承），也可以引用视图或编辑器的标识符。
</p>
<p>只能指定<code>id</code>和<code>class</code>一个。
</p>
<p>
<b>注意：</b>不推荐使用此元素。它已被用于添加修剪元素的先前技术。相反，客户应该将工具栏贡献给其中一个修剪区域，并在其中放置一个控制贡献。有关详细信息，请参阅修剪贡献示例。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 视图或编辑器的标识符。</li>
<li><b>class</b> - 部分的类。这可以是部件的超类，接口或超接口，它仍然匹配。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">可执行扩展或命令的参数 - 取决于它在扩展中的显示位置。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 名称是要传递给可执行扩展的参数的名称，或者是命令的参数的标识符。</li>
<li><b>value</b> - 要为此参数传递的值。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>order</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.order">命令</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST订单</p>
<p class="code SchemaDtdAttlist">位置（开始|结束|之前|之后）</p>
<p class="code SchemaDtdAttlist">relativeTo CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<b>注意：</b>不推荐使用此元素，而是使用'locationURI'来指定应该放置贡献的位置。
<p>控制特定组中窗口小部件的位置。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>职位</b> -<p>此属性接受以下值： <code>start</code> （将元素放在容器的开头）; <code>end</code> （将元素放在容器的末尾）; <code>after</code> （将元素放在id与<code>ref</code>匹配的兄弟元素之后）;并且， <code>before</code> （将元素放在id与<code>ref</code>匹配的兄弟元素之前）。相对排序可以应用于任何类型的菜单元素。
</p>
<p>如果发生冲突，Eclipse将选择任意顺序。唯一的保证是，如果发生冲突，只要满足以下条件，订单将保持不变：</p>
<ul>
<li>Eclipse版本是一样的。</li>
<li>元素列表是相同的（即，没有动态元素，没有添加或删除插件）。</li>
</ul></li>
<li><b>relativeTo</b> - 此位置相对的元素的标识符。如果<code>position</code>位于<code>before</code>或<code>after</code>则需要此值。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>popup</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.popup">popup</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST弹出窗口</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">部分位置。它表示菜单，组，项目或小部件应出现在弹出菜单中。
<p>
</p><p>
<b>注意：</b>不推荐使用此元素。它已被用于添加修剪元素的先前技术。相反，客户应该将工具栏贡献给其中一个修剪区域，并在其中放置一个控制贡献。有关详细信息，请参阅修剪贡献示例。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 弹出菜单的标识符。如果未指定，则它将出现在所有弹出菜单中。</li>
<li><b>path</b> - 弹出菜单中放置元素的路径。如果未指定，则将其添加到“添加”组。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menuContribution">menuContribution</a> （ <a href="#e.menu">menu</a> *， <a href="#e.command">command</a> *， <a href="#e.separator">separator</a> *， <a href="#e.dynamic">dynamic</a> *， <a href="#e.toolbar">toolbar</a> *， <a href="#e.control">control</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST menuContribution</p>
<p class="code SchemaDtdAttlist">locationURI CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">allPopups（true | false）“false”&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>定义命令UI结构的有序添加集。定义的元素将添加到<code>locationURI</code>元素指定的<code>locationURI</code>的命令UI结构中。
</p><p>这应该是菜单，工具栏或修剪中<i>所有</i>贡献的起点，无论它们出现在UI中。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>locationURI</b> - 一个<code>URI</code>规范，用于定义添加包含的添加项的插入点。URI的格式由三个基本部分组成：Scheme：“菜单”，“弹出窗口”或“工具栏”之一。指示用于处理贡献的管理器的类型Id：这是现有菜单的id，视图ID或编辑器'类型'的ID查询：查询格式为&lt;placement&gt; = &lt;id&gt;其中： &lt;placement&gt;是“before”，“after”或“endof”，&lt;id&gt;是现有菜单项的id。处理此贡献时将执行放置修改器。以下贡献可能会在处理菜单时更改菜单的最终形状。</li>
<li><b>class</b> - 如果指定了此可选属性，则将实例化提供的类并用于在此位置提供菜单贡献。如果提供，则将忽略所有子元素。</li>
<li><b>allPopups</b> - 默认情况下，弹出式贡献不会提供给不包含<b>添加</b>标记的上下文菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.visibleWhen">可见时</a> ？，（ <a href="#e.menu">菜单</a> ？| <a href="#e.command">命令</a> ？| <a href="#e.separator">分隔符</a> ？| <a href="#e.dynamic">动态</a> ？）*）？&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">commandId IDREF #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">在给定插入点处定义新的菜单贡献。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>label</b> - 将此元素放置在菜单或工具栏中时要显示的标签。该值应该是可翻译的。</li>
<li><b>id</b> - 此菜单贡献的“id”。如果已定义，则可以通过其他“menuAddition”元素进行扩展，或者可以将id用作位置的“查询”部分中的引用，以定义添加是在此元素之前还是之后。</li>
<li><b>icon</b> - 图像的插件相对路径，用作菜单或工具栏中此菜单的图标。</li>
<li><b>tooltip</b> - 将此元素放置在工具栏中时要显示的工具提示。该值应该是可翻译的。</li>
<li><b>commandId</b> -  Th commandId用于使用键盘快捷方式更新子菜单文本。该命令应该有一个处理程序，可以启动此菜单的quickmenu版本。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.command">命令</a> （ <a href="#e.visibleWhen">visibleWhen</a> ？， <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令</p>
<p class="code SchemaDtdAttlist">标签CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">commandId IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）“push”</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">在定义的插入点定义新的命令贡献。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>label</b> - 将此元素放置在菜单中时要显示的标签。该值应该是可翻译的。</li>
<li><b>commandId</b> - 这是要绑定到此元素的Command的id。这是命令/处理程序/键绑定服务的钩子，如果选择此项，它实际上就可以完成工作。在许多情况下，此命令将在先前的扩展声明中定义。</li>
<li><b>id</b> - 此贡献的“id”。如果已定义，则可以将其用作位置的“查询”部分中的引用，以定义添加是在此元素之前还是之后。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件或<code>ISharedImages</code>常量的位置。</li>
<li><b>tooltip</b> - 将此元素放置在工具栏中时要显示的工具提示。该值应该是可翻译的。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。如果操作显示为菜单项，则在菜单项突出显示时按F1将显示帮助。这将覆盖活动处理程序或命令提供的帮助上下文ID。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的属性。如果省略，则默认为<samp>推送</samp> 。属性值将是以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- （仅限ToolBar）使用SWT.DROP_DOWN可供件创建<code>SWT.DROP_DOWN</code> 。菜单的URI是“menu：”+此项目的ID。</td>
      </tr>
    </table></li>
<li><b>mode</b> - 对于出现在工具栏中的命令，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅CommandContributionItem。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">visible（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">在当前插入点插入分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 此贡献的“id”。如果已定义，那么它可以在位置的Query部分中用作参考，用于定义添加是在此元素之前还是之后（或者在包含此元素的逻辑组的末尾使用'endof'值）。
<p>具有id的分隔符贡献定义逻辑组的开始，因此使用'endof'值进行放置的结果是在当前菜单中向前搜索以找到下一个分隔符并将插入的元素放在该元素之前。如果未找到尾随分隔符，则项目将放置在菜单的末尾。
</p></li>
<li><b>visible</b> - 指示分隔符是否应在UI中可见。默认为<code>false</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.toolbar">工具栏</a> （ <a href="#e.visibleWhen">visibleWhen</a> ？，（ <a href="#e.command">命令</a> ？| <a href="#e.separator">分隔符</a> ？| <a href="#e.dynamic">动态</a> ？| <a href="#e.control">控制</a> ？）*）？&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST工具栏</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">在当前插入点处提供新的ToolBar。此元素目前仅对CoolBarManagers有效，CoolBarManagers可以包含工具栏。例如， <code>org.eclipse.ui.menus.指定的修剪位置URI <code>org.eclipse.ui.menus.MenuUtil</code> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此工具栏贡献的“id”。如果已定义，则可以通过其他“menuAddition”元素进行扩展，或者可以将id用作位置的“查询”部分中的引用，以定义添加是在此元素之前还是之后。</li>
<li><b>label</b> - 在自定义透视对话框中显示此元素时要显示的标签。该值应该是可翻译的。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.control">控件</a> （ <a href="#e.visibleWhen">可见时</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST控制</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">用于为工作台中的ToolBars提供控件。'class'属性必须是WorkbenchWindowControlContribution基类的衍生物。
<p>
<b>注意：</b>由于平台限制，控制贡献仅支持工具栏;尝试将控件提供给菜单或弹出窗口将被视为NO-OP。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此菜单贡献的“id”。如果已定义，则可以将其用作位置的“查询”部分中的引用，以定义添加是在此元素之前还是之后。</li>
<li><b>class</b> - 将用于创建要在ToolBar中托管的控件的类。这必须是WorkbenchWindowControlContribution的子类，它提供有关控件位置的信息（即它所托管的工作台窗口以及当前显示在其上的窗口的一侧。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dynamic">动态</a> （ <a href="#e.class">类</a> ？， <a href="#e.visibleWhen">可见时</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST动态</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素提供了一种机制，该机制将回调到已定义的类，以提供在构建菜单或工具栏时显示的IContributionItem。定义的类必须是org.eclipse.jface.action的衍生物。ContributionItem基类。它也可以使用org.eclipse.ui.action。CompoundContributionItem并为抽象<code>getContributionItems</code>方法提供实现，以提供动态菜单项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此贡献的唯一标识符。建议标识符以插件名称为前缀，以保证唯一性。例如， <code>org.eclipse.ui</code>提供的小部件可能被称为<code>org.eclipse.ui.widget1</code> 。
<p>如果已定义，那么它可以在位置的Query部分中用作参考，用于定义添加是在此元素之前还是之后（或者在包含此元素的逻辑组的末尾使用'endof'值）。
</p></li>
<li><b>class</b> - 此类应该是ContributionItem的子类。该项可以实现IWorkbenchContribution以提供IServiceLocator。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>基本扩展看起来像这样。
</p>
<pre class="Example"><span class="code SchemaTag">&lt;extension id =</span> <span class="code SchemaCstring">“add.item”</span> <span class="code SchemaTag">point =</span> <span class="code SchemaCstring">“org.eclipse.ui.menus”</span> <span class="code SchemaTag">&gt; &lt;menuContribution locationURI =</span> <span class="code SchemaCstring">“menu：someorg.somemenu.id？after = additions“</span> <span class="code SchemaTag">&gt; &lt;command commandId =</span> <span class="code SchemaCstring">”someorg.someid.someCommand“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / anything.gif“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”someorg.someid。BasicCmdItem“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”Simple Item“</span> <span class="code SchemaTag">mnemonic =</span> <span class="code SchemaCstring">”S“</span> <span class="code SchemaTag">&gt; &lt;/ command&gt; &lt;/ menuContribution&gt; &lt;/ extension&gt;</span></pre>
<p>这是最简单的例子;在现有菜单的添加组之后添加命令贡献。
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>最好在<code>plugin.xml</code>添加菜单贡献。插件可以使用<code>org.eclipse.ui.menus.编程方式添加自己的菜单贡献<code>org.eclipse.ui.menus.IMenuService</code>和<code>org.eclipse.ui.menus.AbstractContributionFactory</code> ，但如果插件被卸载，应该确保删除它们。可以通过任何<code>IServiceLocators</code> ，工作台，工作台窗口或零件站点检索<code>IMenuService</code> 。
</p>
<p>见<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a>定义命令和<a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>定义命令的实现。
</p>
<p>要注册上下文菜单，请使用<code>IWorkbenchPartSite.registerContextMenu</code>方法。</p>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2007 IBM Corporation和其他。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="2719.introContentFileSpec.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>简介内容文件XML格式</title>
<style></style>
<style></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">简介内容文件XML格式</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>简介内容文件XML格式..<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>本文档将介绍内容文件结构描述为一系列DTD片段。<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.introContent">introContent</a> （（ <a href="#e.page">page</a> | <a href="#e.group">group</a> ）+ |（ <a href="#e.extensionContent">extensionContent</a> | <a href="#e.replacementContent">replacementContent</a> ））&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">introContent元素定义了简介内容文件的主体。内容文件由页面，可包含在多个页面中的共享组，在其他配置中定义的锚点的扩展或现有元素的替换组成。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.page">页面</a> （ <a href="#e.group">组</a> | <a href="#e.link">链接</a> | <a href="#e.text">文本</a> | <a href="#e.head">head</a> | <a href="#e.img">img</a> | <a href="#e.include">include</a> | <a href="#e.html">html</a> | <a href="#e.title">title</a> | <a href="#e.anchor">anchor</a> | <a href="#e.contentProvider">contentProvider</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST页面</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">url CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">风格CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">alt-style CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）</p><p class="code SchemaDtdAttlist">内容CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">共享风格（true | false）</p><p class="code SchemaDtdAttlist">bgImage CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>此元素用于描述要显示的页面。介绍可以显示动态页面和静态页面。动态页面的内容是从页面的子元素生成的，如下所述。将根据演示文稿应用样式或alt样式。可以通过引用id或class-id进一步增强样式。
</p>
<p>静态页面允许在一个人的介绍中重用现有的HTML文档，并且可以从任何静态或动态页面链接到。静态页面未在页面元素中定义，它们只是可以由其他页面链接的html文件。
</p>
<p>主页（其id在intro配置扩展点的presentation元素中指定）可以具有指示它是静态页面的url。如果未指定url，则假定主页是动态的。使用页面元素描述的所有其他页面都是动态的。另请注意，使用SWT演示文稿并显示静态页面时，将启动外部浏览器，并且当前页面仍然可见。
</p>
<p>动态页面中使用的子元素如下： <b>组</b>子元素用于对相关内容进行分组，并在分组内容中应用样式。<b>链接</b>子元素定义了一个链接，该链接可用于链接到静态或动态页面并运行介绍操作/命令。通常在页面级别定义链接，以在主页面与页面内的链接之间导航。<b>文本</b>子元素在页面级别定义文本内容。<b>头部</b>子元素仅适用于基于Web的演示文稿，并允许将其他html添加到HTML <b>头</b>部分。这对于添加java脚本或额外的样式表非常有用。<b>img</b>子元素定义页面级别的图像内容。<b>include</b>子元素允许重用除页面之外的任何元素。<b>html</b>子元素仅适用于基于Web的演示文稿，并允许将html嵌入或包含在页面的内容中。嵌入允许通过引用html文件将完全定义的html文件嵌入HTML <b>对象中</b> 。包含允许直接从html文件中包含html片段。<b>标题</b>子元素定义页面的标题。<b>锚</b>子元素定义了一个点，其中外部贡献可以由&lt;extensionContent&gt;元素进行。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于标识此页面的唯一名称。</li>
<li><b>url</b> -  HTML文件的可选相对路径。使用基于Web的演示文稿时，将显示此HTML文件，而不是为此页面定义的任何内容。此属性仅适用于主页，该主页在intro配置扩展点的presentation元素中标识。所有其他页面都会被忽略。</li>
<li><b>style</b> -  CSS文件的相对路径，仅在使用基于Web的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。这些样式将按照样式属性中列出的顺序注入HTML HEAD元素。</li>
<li><b>alt-style</b> -  SWT演示文稿属性文件的相对路径，仅在使用基于SWT的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。创建欢迎页面的SWT演示文稿时将使用这些样式。</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
<li><b>content</b> - 一个可选属性，可以定义表示此页面内容的introContent.xml文件的位置。定义此属性后，将忽略此页面元素中除id之外的所有子项和属性。这是因为现在假定此页面的内容驻留在内容文件属性指向的xml文件中。解析此文件的内容时，将选择id与此页面元素中定义的id匹配的页面。当性能成为问题时，可以使用页面的分离，因为页面的内容现在更加懒惰地加载。<br>从3.1开始，如果外部文件的内容是XHTML 1.0，那么页面将按原样呈现。</li>
<li><b>style-id</b> - 将页面分类为给定类别的方法，以便可以应用通用样式。</li>
<li><b>shared-style</b> - 一个布尔标志，用于控制将共享样式添加到此页面的样式列表中。如果为<code>true</code> （默认值），则将共享样式添加到此页面的样式中。如果为<code>false</code> ，则Intro配置中定义的共享样式将不会注入此页面的样式。</li>
<li><b>bgImage</b> - 要用作此组背景的图像的可选URL</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.group">group</a> （ <a href="#e.group">group</a> | <a href="#e.link">link</a> | <a href="#e.text">text</a> | <a href="#e.img">img</a> | <a href="#e.include">include</a> | <a href="#e.html">html</a> | <a href="#e.anchor">anchor</a> | <a href="#e.contentProvider">contentProvider</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST集团</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">标签CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）</p><p class="code SchemaDtdAttlist">computed（true | false）“false”</p><p class="code SchemaDtdAttlist">bgImage CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">expandable（true | false）“false”</p><p class="code SchemaDtdAttlist">expanded（true | false）“false”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">用于对相关内容，应该应用类似样式的内容或将在其他页面中包含在一起的内容进行分组。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 组的唯一标识符</li>
<li><b>label</b> - 此组的标签或标题</li>
<li><b>style-id</b> - 将此组分类为给定类别的方法，以便可以应用共同样式。</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
<li><b>computed</b> - 如果为<code>true</code> ，则此组的子项将在运行时由intro configurer提供。建议在这种情况下不要静态定义任何孩子。</li>
<li><b>bgImage</b> - 要用作此组背景的图像的可选URL</li>
<li><b>expandable</b> - 指定是否可以展开和折叠组。如果未指定，则默认为false。如果为true，则将查询展开的属性以确定是否应该默认扩展该组。</li>
<li><b>expanded</b> - 指定是否应在默认情况下展开可展开组。如果未指定，则默认为false（折叠）。这仅适用于可扩展组（其中expandable设置为true）。否则没有效果。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.head">head</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST负责人</p>
<p class="code SchemaDtdAttlist">src CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">编码CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">直接HTML以包含在页面的HEAD内容区域中。它允许将额外的html添加到HTML HEAD部分。这对于添加java srcipts或额外样式表非常有用。如果内容包含$ plugin：plugin_id $形式的替换段，那么它们将被替换为带有id plugin_id的插件的绝对路径。此标记仅用于基于HTML的介绍部件实现。在UI Forms实现的情况下，它被简单地忽略。页面可以有多个头元素。实现可以只有一个头元素（因为它是所有页面共享的）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>src</b> - 包含HTML的文件的相对或绝对URL，以直接包含在HTML头部分中。如果内容包含$ plugin：plugin_id $形式的替换段，那么它们将被替换为带有id plugin_id的插件的绝对路径。</li>
<li><b>encoding</b> - 一个可选属性，用于指定包含头部片段的内联文件的编码。默认值为UTF-8。从3.0.1开始</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.title">标题</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST头衔</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一段文本，可以选择包含转义的HTML标记。它仅用作页面标题，因此给定页面最多可以包含一个标题元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此标题的唯一标识符。</li>
<li><b>style-id</b> - 将此元素分类为给定类别的方法，以便可以应用通用样式</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.link">链接</a> （ <a href="#e.text">文字</a> ？， <a href="#e.img">img</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST链接</p>
<p class="code SchemaDtdAttlist">url CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">标签CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">可以链接到静态HTML文件，外部网站，也可以运行简介URL操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>url</b> - 外部网站的有效URL，静态html文件或表示简介操作的简介URL。所有介绍URL都具有以下形式：http：//org.eclipse.ui.intro/ &lt;action name&gt;？param1 = value1＆param2 = value2，将由介绍框架处理。<br>将使用以下格式描述预定义的操作：<br>
<p style="margin-left:15px">
<b>动作名称</b> - 动作描述<br>
<i>action parameter1</i> - <i>参数</i>说明<br>
<i>action parameter2（可选）</i> - 参数说明<br>
<i>action parameter3（可选）=（“true”“false”）“false”</i> - 参数说明，选择true或false和“false”是默认值<br>
</p>

<br>介绍框架中包含以下预定义操作：<p style="margin-left:15px">
<b>关闭</b> - 关闭介绍部分<br>不需要参数<br>
<br>

<b>导航</b> - 在给定方向上浏览介绍页面或返回主页<br>
<i>direction =（“向后”“向前”“主”）</i> - 指定导航方向<br>
<br>

<b>openBrowser</b> - 在外部浏览器中打开url。从3.1开始，此操作依赖于工作台浏览器支持。这意味着将为浏览器设置的任何用户首选项都将受到尊重。<br>
<i>url</i> - 外部网站或本地HTML文件的有效URL<br>
<i>pluginId（可选）</i> - 如果url是相对的，那么它是相对于插件的。在此处指定包含该文件的插件的ID。<br>
<br>

<b>openURL</b> - 打开欢迎页面中嵌入的URL。在SWT演示的情况下，URL显示在外部浏览器中（类似于上面的openBrowser操作）。从3.1开始<br>
<i>url</i> - 外部网站或本地HTML文件的有效URL<br>
<i>pluginId（可选）</i> - 如果url是相对的，则指定包含该文件的插件的id。<br>
<br>

<b>runAction</b> - 运行指定的操作<br>
<i>class</i> - 实现<code>org.eclipse.ui.intro.config.之一的<i>类</i>的完全限定类名<code>org.eclipse.ui.intro.config.IIntroAction</code> ， <code>org.eclipse.jface.actino.IAction</code> ，或<code>org.eclipse.ui.IActionDelegate的</code><br>
<i>pluginId</i> - 包含该类的插件的id。<br>
<i>待机（可选）=（“true”“false”）“false”</i> - 指示在执行操作后是否将介绍设置为待机模式<br>其他参数 - 将任何其他参数传递给实现<code>org.eclipse.ui.intro.config.IIntroAction</code><br>
<br>

<b>execute</b> - 执行指定的命令。请参阅<code>org.eclipse.core.command.上的<code>serialize()</code>方法<code>org.eclipse.core.command.ParameterizedCommand</code>有关命令序列化格式的详细信息。自3.2。<br>
<i>command</i> - 序列化的<code>ParameterizedCommand</code><br>
<i>standby（可选）=（“true”|“false”）“false”</i> - 指示在执行命令后是否将介绍设置为待机模式<br>
<br>

<b>setStandbyMode</b> - 设置介绍部分的状态<br>
<i>standby =（“true”“false”）</i> - 将介绍部分置于其部分可见的标准模式中为true，为false使其完全可见<br>
<br>

<b>showHelp</b> - 打开帮助系统。<br>不需要参数<br>
<br>

<b>showHelpTopic</b> - 打开帮助主题。<br>
<i>id</i> - 帮助资源的URL。（请参阅<code>org.eclipse.ui.help. Javadoc <code>org.eclipse.ui.help.WorkbenchHelp.displayHelpResource）</code><br>
<i>embed（可选）=（“true”“false”）</i> “true” - 表示需要在欢迎页面中嵌入显示帮助资源。默认值为false。在SWT演示的情况下，该标志被忽略。这相当于openURL（）命令，但对于帮助系统主题。嵌入的URL占用当前页面的完整空间。从3.1开始<br>
<i>embedTarget（可选）</i> - 当前“欢迎”页面中div的路径，该页面将包含“帮助”主题的内容。如果指定，则默认情况下<i>embed</i>为true，嵌入的URL将插入具有指定路径的div内。该路径相对于页面，因此它不应以页面ID开头。div的子节点被URL的内容替换。每页只能使用一个div作为嵌入目标。在SWT演示的情况下，该标志被忽略。使用XHTML作为介绍内容时也不受支持。从3.1开始<br>
<br>

<b>showMessage</b> - 使用标准信息对话框向用户显示消息。<br>
<i>message</i> - 显示用户的消息<br>
<br>

<b>showStandby</b> - 将介绍部分设置为待机模式，并显示具有给定输入的standbyContentPart<br>
<i>partId</i> - 要显示的standbyContentPart的id<br>
<i>input</i> - 要在standbyContentPart上设置的输入<br>
<br>

<b>showPage</b> - 显示具有给定id的介绍页面<br>
<i>id</i> - 要显示的介绍页面的ID<br>
<i>待机（可选）=（“true”“false”）“false”</i> - 指示在显示页面后是否将介绍设置为待机模式<br><br>如果传递给这些操作的任何参数都有特殊字符（即：URL中非法的字符），则应使用UTF-8 url编码对它们进行编码。为了在解码状态下接收这些参数，可以使用特殊参数<i>decode =（“true”“false”）</i>在Intro框架处理它们时强制解码这些参数。<br>例如，以下介绍网址：<br><i>HTTP：//org.eclipse.ui.intro/showMessage消息=此是+ A +消息</i><br>将消息参数处理为“This + is + a + message”<br>而<br><i>？HTTP：//org.eclipse.ui.intro/showMessage消息=此是+ A +消息和;解码=真</i><br>将消息参数处理为“这是一条消息”。<br>


<br></p></li>
<li><b>id</b> - 可用于标识此链接的唯一ID</li>
<li><b>label</b> - 此链接的文本名称</li>
<li><b>style-id</b> - 将此链接分类为给定类别的方法，以便可以应用通用样式。</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.text">text</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST文本</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一段文本，可以选择包含转义的HTML标记。它可以包括b和li标签。它还可以包含网址的锚点。如果需要多个段落，则可以将文本分成多个部分，每个部分以p标签开始和结束。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此文本的唯一标识符。</li>
<li><b>style-id</b> - 将此元素分类为给定类别的方法，以便可以应用通用样式</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.img">img</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST img</p>
<p class="code SchemaDtdAttlist">src CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">alt CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">表示内容而非演示的图像（与样式中定义的装饰图像相对）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>src</b> - 从中加载图像的文件</li>
<li><b>id</b> - 此图像的唯一标识符</li>
<li><b>alt</b> - 无法加载图像时使用的替代文本，以及图像的工具提示文本。</li>
<li><b>style-id</b> - 将此图像分类为给定类别的方法，以便可以应用通用样式。</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.html">html</a> （ <a href="#e.img">img</a> | <a href="#e.text">text</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST html</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">src CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">type（inline | embed）</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）</p><p class="code SchemaDtdAttlist">编码CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过嵌入整个文档或在内嵌HTML内容来直接在页面中包含HTML。必须为替代swt演示文稿渲染定义后备图像或文本。如果内容包含$ plugin：plugin_id $形式的替换段，那么它们将被替换为带有id plugin_id的插件的绝对路径。
<br>嵌入允许将完全定义的html文件嵌入到动态页面的内容中。创建一个引用html文件的HTML <b>对象</b>元素。
<br>包含允许直接从文件中将html片段包含到动态html页面中。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此HTML元素的唯一标识符</li>
<li><b>src</b> - 包含HTML的文件的相对或绝对URL。如果内容包含$ plugin：plugin_id $形式的替换段，那么它们将被替换为带有id plugin_id的插件的绝对路径。</li>
<li><b>type</b> - 如果'embed'，将使用HTML'OBJECT'标记嵌入有效（完整）HTML文档。如果是'inline'，'src'的值将被视为HTML的片段以“就地”发出。 （如果未指定type，则介绍配置将忽略此html对象）。</li>
<li><b>style-id</b> - 将此HTML元素分类为给定类别的方法，以便可以应用通用样式。</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
<li><b>encoding</b> - 一个可选属性，用于指定内联文件的编码（在指定type = inline的情况下）。如果未指定，则默认值为UTF-8。从3.0.1开始</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.include">包括</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST包括</p>
<p class="code SchemaDtdAttlist">路径CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">configId CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">merge-style（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">扩展给定路径和可选configId属性所针对的元素。路径应唯一地寻址指定配置中的元素。它可以指向在配置级别定义的共享组，或页面中的任何元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>path</b> - 唯一表示配置中目标元素的路径（例如page / group1 / group2）。它可以是组元素，也可以是组中可能包含的任何元素。您不能包含页面。</li>
<li><b>configId</b> - 定义包含元素的配置的标识符。如果指定，则假定要包含的元素在另一个配置中指定，而不是在封闭配置中指定。在这种情况下，将加载该外部配置，并从该新配置中解析该元素。如果未指定，则假定包含此包含的（父）配置。</li>
<li><b>merge-style</b> - 如果为<code>true</code> ，则属于拥有包含元素的页面的样式将添加到包含页面的样式列表中。如果为<code>false</code> （默认值），则包含页面负责控制所包含元素的属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.anchor">锚</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST主播</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">anchor是用于声明可扩展性的元素。它是configurtaion中允许外部贡献的位置。只有锚点是extensionContent中path属性的有效目标值</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 标识此锚点的唯一ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extensionContent">extensionContent</a> （ <a href="#e.text">text</a> | <a href="#e.group">group</a> | <a href="#e.link">link</a> | <a href="#e.html">html</a> | <a href="#e.include">include</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展内容</p>
<p class="code SchemaDtdAttlist">路径CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">风格CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">alt-style CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">内容CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要添加到目标锚点的内容。在给定的configExtension中只允许一个<code>extensionContent</code>或<code>replacementContent</code> ，因为如果无法解析此扩展（如果找不到配置，或者找不到目标锚），那么扩展中的页面和/或组必须是ingnored。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>path</b> - 唯一表示锚点路径的路径。 （例如page / group1 / group2 / anchorId）在要扩展的目标配置中。它只能是可以位于任何页面或组中的锚点，包括配置级别的共享组。</li>
<li><b>style</b> -  CSS文件的相对路径，仅在使用基于Web的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。这些样式将按照样式属性中列出的顺序注入HTML HEAD元素。</li>
<li><b>alt-style</b> -  SWT演示文稿属性文件的相对路径，仅在使用基于SWT的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。创建欢迎页面的SWT演示文稿时将使用这些样式。</li>
<li><b>content</b> - 如果定义了内容，则假定扩展内容是在外部XHTML文件中定义的。在这种情况下，将加载此内容属性指向的资源，并在此外部文件中解析路径属性。从3.1开始</li>
<li><b>id</b> - （自3.2起）与intro configurer一起使用时需要此扩展的唯一标识符。</li>
<li><b>name</b> - （自3.2起）当与intro配置器一起使用时，需要此扩展名的可翻译名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.replacementContent">replacementContent</a> （ <a href="#e.text">text</a> | <a href="#e.group">group</a> | <a href="#e.link">link</a> | <a href="#e.html">html</a> | <a href="#e.include">include</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST replacementContent</p>
<p class="code SchemaDtdAttlist">路径CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">风格CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">alt-style CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">内容CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">（自3.3起）替换目标元素的内容。在给定的configExtension中只允许一个<code>extensionContent</code>或<code>replacementContent</code> ，因为如果无法解析此扩展（如果找不到配置，或者找不到目标元素），那么扩展中的页面和/或组必须是忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>path</b> - 唯一表示要替换的元素的路径的路径。 （例如page / group1 / group2 / elementId）在要扩展的目标配置中。要替换<code>extensionContent</code>内容，您可以使用表单<code>pageId/@extension_id/path_in_extension</code>的路径，它将被解析为指定的扩展名。</li>
<li><b>style</b> -  CSS文件的相对路径，仅在使用基于Web的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。这些样式将按照样式属性中列出的顺序注入HTML HEAD元素。</li>
<li><b>alt-style</b> -  SWT演示文稿属性文件的相对路径，仅在使用基于SWT的演示文稿时应用于页面。该路径相对于此xml内容文件的位置。<br>从3.1开始，样式也可以是逗号分隔的样式列表。创建欢迎页面的SWT演示文稿时将使用这些样式。</li>
<li><b>content</b> - 如果定义了内容，则假定扩展内容是在外部XHTML文件中定义的。在这种情况下，将加载此内容属性指向的资源，并在此外部文件中解析路径属性。从3.1开始</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.contentProvider">contentProvider</a> （ <a href="#e.text">文字</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST contentProvider</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">pluginId CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">介绍内容提供程序的代理，允许介绍页面动态地从各种源（例如，web，eclipse等）提取数据，并基于此动态数据在运行时提供内容。如果无法加载在class属性中指定的IIntroContentProvider类，则将呈现文本元素的内容。这是html intro标签的动态版本。虽然html标记允许将静态html内容嵌入或嵌入到生成的html介绍页面中，但contentProvider标记允许在运行时动态创建该内容。标签之间的另一个区别是html标签仅支持HTML演示文稿，而HTML和SWT演示文稿支持此contentProvider标签。从3.0.1开始</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此内容提供程序元素的唯一标识符。它是必需属性，因为具有唯一ID是阻止介绍框架重新实例化此内容提供程序类并重新创建其内容的原因。</li>
<li><b>class</b> - 实现IContentProvider接口的类</li>
<li><b>pluginId</b> - 包含由class属性指定的IContentProvider类的插件的id。这是一个可选属性，如果该类不是来自定义标记的同一插件，则应使用该属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.hr">hr</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST小时</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">style-id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">filteredFrom（swt | html）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">横向规则。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此hr的唯一标识符</li>
<li><b>style-id</b> - 将此元素分类为给定类别的方法，以便可以应用通用样式</li>
<li><b>filteredFrom</b> - 一个可选属性，允许从特定实现中过滤给定元素。例如，如果某个组具有filteredFrom = swt，则表示该组不会在swt实现中显示为内容。</li>
</ul>
<br><br>
<p class="note SchemaCopyright">版权所有（c）2004,2006 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可在<a href="https://www.eclipse.org/legal/epl-2.0/">https://www.eclipse.org/legal/epl-2.0/</a> SPDX-License-Identifier：EPL获取。 -2.0</p>
</body>
</html><html id="1789.acquiringheapdump.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<meta name="DC.Type" content="task"></meta>
<meta name="DC.Title" content="Acquiring Heap Dumps"></meta>
<meta name="copyright" type="primary" content="Copyright (c) 2008, 2018 SAP AG and IBM Corporation. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Rights.Owner" type="primary" content="Copyright (c) 2008, 2018 SAP AG and IBM Corporation. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Format" content="XHTML"></meta>
<meta name="DC.Identifier" content="task_acquiringheapdump"></meta>
<meta name="DC.Language" content="en-us"></meta>
<link rel="stylesheet" type="text/css" href="../styles/commonltr.css"></link>
<title>获取堆转储</title>
</head>
<body id="task_acquiringheapdump" dir="ltr">


	<h1 class="title topictitle1">获取堆转储</h1>

	

	<div class="body taskbody">
		<div class="section context">
		
			
		    <p class="p"><strong class="ph b">HPROF二元堆转储</strong></p>

		    <p class="p"><em class="ph i">在OutOfMemoryError上获取堆转储</em></p>

			<p class="p">可以在Sun JVM（1.4.2_12或更高版本和1.5.0_07或更高版本），Oracle JVM，OpenJDK JVM，HP-UX JVM（1.4.2_11或更高版本）和SAP JVM（以下版本）的OutOfMemoryError上获得HPROF二进制堆转储1.5.0）通过设置以下JVM参数：</p>

			<div class="p">
				<pre class="pre codeblock">-XX：+ HeapDumpOnOutOfMemoryError</pre>

			</div>

			<p class="p">堆转储将写入工作目录。</p>

			
			<p class="p"><em class="ph i">交互式触发堆转储</em></p>

			<p class="p">要按需获取堆转储，可以将以下参数添加到JVM，并在首选时按CTRL + BREAK：</p>

			<div class="p">
				<pre class="pre codeblock">-XX：+ HeapDumpOnCtrlBreak</pre>

			</div>

			<p class="p"><em class="ph i">HPROF代理</em></p>

			<p class="p">要在执行结束时使用HPROF代理生成转储，或者在SIGQUIT信号上使用以下JVM参数：</p>

			<div class="p">
				<pre class="pre codeblock">-agentlib：HPROF =堆=转储，格式= B</pre>

			</div>

			<p class="p">或者，可以使用其他工具来获取堆转储：</p>

			<ul class="ul">
				<li class="li">
					<span class="keyword cmdname">jmap -dump：format = b，file = &lt;filename.hprof&gt; &lt;pid&gt;</span>
				</li>

				<li class="li">JConsole（参见<a class="xref" href="../gettingstarted/basictutorial.html">Basic Tutorial中的</a>示例用法）</li>

				<li class="li">内存分析器（见页面底部）</li>

			</ul>

				
			
			<p class="p"><strong class="ph b">IBM虚拟机的系统转储和堆转储</strong></p>

			<div class="p">Memory Analyzer还可以从IBM系统转储和Portable Heap Dump（PHD）文件中读取与内存相关的信息。为此，只需将IBM DTFJ功能安装到Memory Analyzer中即可。遵循<a class="xref" href="installDTFJ.html">IBM DTFJ功能安装说明</a> 。成功安装DTFJ功能后， <span class="ph menucascade"><span class="ph uicontrol">File</span> &gt; <span class="ph uicontrol">Open Heap Dump</span></span>菜单还应为文件类型提供以下选项：<ul class="ul">
				<li class="li">所有已知的格式</li>

				<li class="li">HPROF二进制堆转储</li>

				<li class="li">IBM 1.4.2 SDFF <a name="fnsrc_1" href="#fntarg_1"><sup>1</sup></a></li>

				<li class="li">IBM Javadumps</li>

				<li class="li">IBM SDK for Java（J9）系统转储</li>

				<li class="li">IBM SDK for Java便携式堆转储</li>

			</ul>

			</div>

			
			<p class="p">有关转储类型的比较，请参阅<a class="xref" href="http://www.ibm.com/developerworks/library/j-memoryanalyzer/#table1">从转储调试</a> 。系统转储只是操作系统核心转储;因此，它们是便携式堆转储的超集。系统转储远优于PHD，特别是对于更准确的GC根，基于线程的分析，与PHD不同，系统转储包含HPROF等内存内容。
			</p>

			
			<p class="p">较旧版本的IBM Java（例如&lt;5.0SR12，&lt;6.0SR9）需要在操作系统核心转储上运行jextract，该转储生成包含核心转储，XML或SDFF文件和共享库的zip文件。虽然IBM DTFJ功能版本1.12.29003.201808011034及更高版本无法读取IBM Java 1.4.2 SDFF文件，但IBM DTFJ功能仍支持读取这些提取的拉链，因此MAT也无法读取它们。来自较新版本的IBM Java的转储不需要jextract用于MAT，因为DTFJ能够直接读取每个支持的操作系统的核心转储格式。只需确保操作系统核心转储文件以<strong class="ph b">.dmp</strong>后缀结尾，以便在MAT Open Heap Dump选项中显示。压缩核心转储也很常见，因为它们非常大并且压缩得非常好。如果使用<strong class="ph b">.zip</strong>压缩核心转储，则MAT中的IBM DTFJ功能可以解压缩ZIP文件并从内部读取核心（就像提取的zip文件一样）。系统转储超过PHD的唯一重要缺点是它们要大得多，它们通常需要更长时间才能生成，如果它们是在操作底层Java堆的独占事件（例如垃圾收集）中手动获取的话，它们可能毫无用处。 ，它们有时需要操作系统配置（ <a class="xref" href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.80.doc/diag/problem_determination/linux_setup.html">Linux</a> ， <a class="xref" href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.80.doc/diag/problem_determination/aix_setup_full_core.html">AIX</a> ）以确保不截断。
			</p>

			
			<div class="p">在最新版本的IBM Java（&gt; 6.0.1）中，默认情况下，当抛出OutOfMemoryError时，IBM Java会在该进程首次出现时生成系统转储，PHD，javacore和Snap文件（尽管核心转储通常是在Linux等操作系统上被默认的0核心ulimit抑制。对于接下来的三次出现，它只生成一个PHD，javacore和Snap。如果您只打算使用系统转储，并且已根据上面的链接（特别是核心和文件ulimits）正确配置了操作系统，那么您可以使用-Xdump：heap：none禁用PHD生成。对于早于6.0.1的IBM Java版本，您可以使用从PHD切换到系统转储<pre class="pre codeblock">-Xdump：system：events = systhrow，filter = java / lang / OutOfMemoryError，request = exclusive + prepwalk -Xdump：heap：none</pre>

			</div>


			<p class="p">除了OutOfMemoryError之外，系统转储可以使用操作系统工具（例如，用于Linux的gdb中的gcore，用于AIX的gencore，用于Windows的任务管理器，用于z / OS的SVCDUMP等），使用<a class="xref" href="https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.api.80.doc/com.ibm.jvm.ras/index.html">IBM Java API</a> ，使用<a class="xref" href="http://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/tools/dump_agents.html">-Xdump的</a>各种选项，使用<a class="xref" href="https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=7d3dc078-131f-404c-8b4d-68b3b9ddd07a">Java Surgery</a>等。
			</p>


			<p class="p">已知早于IBM JDK 1.4.2 SR12,5.0 SR8a和6.0 SR2的IBM Java版本会产生不准确的GC根信息。
			</p>

			
			
			
			<p class="p"><strong class="ph b">从Memory Analyzer中获取堆转储</strong></p>

			<p class="p">如果要从中获取堆转储的Java进程与Memory Analyzer位于同一台机器上，则可以直接从Memory Analyzer获取堆转储。以这种方式获得的转储在工具中直接解析和打开。
			</p>

			
			<p class="p">获取堆转储是特定于VM的。Memory Analyzer附带了几个所谓的堆转储提供程序 - 用于基于Oracle和Sun的VM（需要带有jmap的Oracle或Sun JDK）和用于IBM VM（需要IBM JDK或JRE）。此外，还为使用者提供了扩展点，以插入他们自己的堆转储提供程序。
			</p>


	<p class="p">要从Memory Analyzer中触发堆转储，请打开<span class="ph menucascade"><span class="ph uicontrol">File</span> &gt; <span class="ph uicontrol">Acquire Heap Dump ...</span></span>菜单项。
	</p>


	<p class="p">根据具体的执行环境，预安装的堆转储提供程序可以使用其默认设置，在这种情况下，应显示正在运行的Java进程列表：为了使选择更容易，可以通过单击更改Java进程的顺序。 <span class="ph uicontrol">pid</span>或<span class="ph uicontrol">堆转储提供程序的</span>列标题。
	</p>

	<img class="image" src="../mimes/acquire.png" alt="选择要转储的进程">
	<p class="p">现在可以选择应从哪个进程获取堆转储，为堆转储提供首选位置，然后按<span class="ph uicontrol">Finish</span>以获取转储。一些堆转储提供程序可能允许（或要求）设置其他参数（例如，堆转储的类型）。这可以通过使用“ <span class="ph menucascade"><span class="ph uicontrol">下一步”</span></span>按钮进入向导的“ <span class="keyword wintitle">配置堆转储提供程序参数”</span>页面来完成。
	</p>

	<p class="p">
		<em class="ph i">配置堆转储提供程序</em>
	</p>

	<p class="p">如果进程列表为空，请尝试配置可用的堆转储提供程序。要执行此操作，请按<span class="ph uicontrol">配置...</span>，从列表中选择匹配的提供程序，然后单击它。您可以看到所需的设置是什么并指定它们。
		<span class="ph menucascade"><span class="ph uicontrol">接下来</span></span>将应用任何更改的设置，并在任何设置更改后刷新JVM列表。
		<span class="ph menucascade"><span class="ph uicontrol">Prev</span></span>将返回当前JVM列表而不应用任何更改的设置。然后应用更改的设置重新输入并退出<span class="keyword wintitle">配置堆转储提供程序...</span>页面如下： <span class="ph menucascade"><span class="ph uicontrol">配置...</span> &gt; <span class="ph uicontrol">下一步</span></span>
	</p>

	<p class="p">如果在按下<span class="ph uicontrol">配置</span>之前选择了一个过程<span class="ph uicontrol">...</span>然后在进入<span class="keyword wintitle">配置堆转储提供程序时</span>选择相应的转储提供<span class="keyword wintitle">程序...</span>页。
	</p>

	<div class="p">
		<dl class="dl">
			
				<dt class="dt dlterm" id="task_acquiringheapdump__1">HPROF jmp转储提供程序</dt>

				<dd class="dd">此提供程序使用随Oracle或基于OpenJDK的JDK提供的<span class="keyword cmdname">jps</span>命令列出系统上正在运行的JVM。然后，提供程序使用<span class="keyword cmdname">jmap</span>命令获取所选JVM以生成HPROF转储。此提供程序需要JDK（Java开发工具包），而不是这两个命令的JRE（Java运行时环境）。IBM JDK没有<span class="keyword cmdname">jps</span>或<span class="keyword cmdname">jmap</span>命令。OpenJ9 JDK上的命令可能无法很好地使此提供程序与这些JVM一起使用。</dd>

			
			
				<dt class="dt dlterm"><a name="task_acquiringheapdump__2"><!-- --></a>附加API</dt>

				<dd class="dd">这使用<a class="xref" href="https://docs.oracle.com/javase/8/docs/jdk/api/attach/spec/com/sun/tools/attach/package-summary.html"><span class="keyword apiname">com.sun.tools.attach</span></a>或<a class="xref" href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/user/attachapi.html"><span class="keyword apiname">com.ibm.tools.attach</span></a> API列出JVM，然后附加到选定的JVM以生成转储。Attach API作为IBM JDK和JRE的一部分提供，但仅作为Oracle或OpenJDK JDK的一部分提供在<samp class="ph codeph">tools.jar中，</samp>而不是作为JRE的一部分提供。因此，如果Memory Analyzer与Oracle JRE一起运行，则此转储提供程序将不可用。<span class="keyword apiname">com.sun.tools.attach</span> API可用于Oracle和OpenJDK JDK，OpenJ9 JDK和JRE以及IBM JDK和JRE版本Java 8 SR5或更高版本。<span class="keyword apiname">com.ibm.tools.attach</span> API在早期的IBM JDK和JRE上可用。Attach API转储提供程序自动使用任何可用的Attach API，并在需要时加载<samp class="ph codeph">tools.jar</samp> 。使用Java 9或更高版本的Attach API不允许Java进程连接到自身，因此MemoryAnalyzer无法使用Attach API转储提供程序生成自身的转储。请改用其他转储提供程序。
				</dd>

			
			
				<dt class="dt dlterm"><a name="task_acquiringheapdump__3"><!-- --></a>使用帮助程序JVM附加API</dt>

				<dd class="dd">如果Memory Analyzer与Oracle JRE一起运行，则此转储提供程序可以通过提供<span class="keyword cmdname">java</span>可执行文件的路径与Oracle JDK一起使用。如果需要，转储提供程序将加载<samp class="ph codeph">tools.jar</samp> 。这样<span class="keyword apiname">com.sun.tools.attach</span> API是可访问的。此提供程序还可用于列出与用于运行Memory Analyzer的JVM不同类型的JVM。例如，即使Memory Developer与Oracle JVM一起运行，也可以通过指定IBM JVM <span class="keyword cmdname">java</span>命令的路径来生成来自IBM JVM的转储。</dd>

			
		</dl>

	</div>

	<p class="p">
		<em class="ph i">选项</em>
	</p>

	<div class="p">
		<dl class="dl">
			
				<dt class="dthd"><strong>转储类型</strong></dt>

			
			
				<dt class="dt dlterm">系统</dt>

				<dd class="dd">使用<span class="keyword apiname">com.ibm.jvm生成这些进程核心转储<span class="keyword apiname">。倾倒。由Memory Analyzer生成并加载到目标JVM中的代理库调用的SystemDump（）</span>方法。这些转储可以由IBM和OpenJ9 JVM生成。</dd>

			
			
				<dt class="dt dlterm">堆</dt>

				<dd class="dd">这些便携式堆转储是使用<span class="keyword apiname">com.ibm.jvm生成的<span class="keyword apiname">。倾倒。由Memory Analyzer生成并加载到目标JVM中的代理库调用的HeapDump（）</span>方法。这些转储可以由IBM和OpenJ9 JVM生成。</dd>

			
			
				<dt class="dt dlterm">Java的</dt>

				<dd class="dd">这些Javacore转储是使用<span class="keyword apiname">com.ibm.jvm生成的<span class="keyword apiname">。倾倒。由Memory Analyzer生成并加载到目标JVM中的代理库调用的JavaDump（）</span>方法。这些转储可以由IBM和OpenJ9 JVM生成。</dd>

			
			
				<dt class="dt dlterm">HPROF</dt>

				<dd class="dd">这些HPROF转储是使用在Memory Analyzer中生成并加载到目标JVM中的代理库中调用的<span class="keyword apiname">com.sun.management:type=HotSpotDiagnostic</span> MXBean生成的。这些转储可以由Oracle和OpenJDK JVM生成。</dd>

			
		</dl>

		<dl class="dl">
			
				<dt class="dthd"><strong>其他选择</strong></dt>

			
			
				<dt class="dt dlterm">压缩</dt>

				<dd class="dd">可以使用压缩转储的<a class="xref" href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/tools/dump_viewer_dtfjview/jextract.html"><span class="keyword cmdname">jextract</span></a>处理系统转储，还可以添加额外的系统信息，以便将转储移动到另一台计算机。使用Heap选项生成的便携式堆转储（PHD）文件可以使用gzip压缩器进行压缩，以减小文件大小。
				</dd>

			
			
				<dt class="dt dlterm">生活</dt>

				<dd class="dd">在IBM JVM上，这会在转储之前强制进行垃圾回收。这可能会影响在目标JVM上运行的程序的性能，但可能会减小PHD堆转储的大小。在Oracle和OpenJDK JVM上，这只会将活动对象转储到HPROF文件中，并且应该减小其大小。默认情况下，Memory Analyzer会在转储索引转储并构建快照时从转储中删除非活动对象，并将有关这些对象的信息放入无法访问的对象直方图中。如果使用此直方图或设置了“保持不可达对象”选项，则不应设置实时选项，因为它将删除所需信息。</dd>

			
			
				<dt class="dt dlterm">listattach</dt>

				<dd class="dd">在使用Attach API列出JVM时使用此方法。然后，转储提供程序将附加到列表中的每个正在运行的JVM，并提取更多信息以提供更好的描述。这可能需要更长时间，因此如果取消列表操作，则禁用此选项，以便下一个列表更快。如果需要，可以重新启用该选项。</dd>

			
			
				<dt class="dt dlterm">DUMPDIR</dt>

				<dd class="dd">IBM JVM在目标JVM指定的目录中生成转储，而不是由Memory Analyzer生成。Memory Analyzer需要查找导致生成的转储，并在目标JVM <samp class="ph codeph">user.dir中</samp>查找转储文件。如果这不是正确的地方，那么Memory Analyzer将无法找到gnerated dump，因此用户必须在之后手动找到它。如果用户知道目标JVM将在何处生成转储，则可以使用此选项输入。
				</dd>

			
			
				<dt class="dt dlterm">dumptemplate</dt>

				<dd class="dd">这给出了用于转储的示例文件名。使用替换变量0将时间和日期插入名称，例如<samp class="ph codeph">{0，date，yyyyMMdd。HHmmss}</samp> 。使用替换变量1插入进程标识符，例如<samp class="ph codeph">{1，number，0}</samp> 。使用替换变量2插入用于使转储文件唯一的实例编号，例如<samp class="ph codeph">{2，number，0000}</samp> 。额外的0000是标准的MessageFormat修饰符，它提供了要使用的最小位数。
				</dd>

			
		</dl>

	</div>

			<p class="p"><strong class="ph b">一个堆转储中的多个快照</strong></p>

			<div class="p">有时，可以生成包含多个堆转储快照的堆转储文件。如果使用生成HPROF转储<pre class="pre codeblock">-agentlib：HPROF =堆=转储，格式= B</pre>然后，如果多次触发堆转储，则所有堆转储都将写入一个文件。IBM z / OS系统转储可以包含来自多个地址空间和进程的数据。因此，转储文件可能包含来自多个Java运行时的堆转储快照。
			</div>

			<p class="p">Memory Analyzer 1.2及更早版本通过选择找到的第一个堆转储快照来处理这种情况，除非通过环境变量或MAT DTFJ配置选项选择了另一个。
			</p>

			<p class="p">Memory Analyzer 1.3通过检测多个转储来处理这种情况，然后呈现一个对话框供用户选择所需的快照。
			</p>

			<img class="image" src="../mimes/multiple_snapshots.png" alt="选择要分析的快照">
			<p class="p">生成的索引文件在快照标识符的文件名中包含一个组件，因此可以区分每个快照的索引文件。这意味着可以在Memory Analyzer中同时检查来自一个堆转储文件的多个快照。该文件的堆转储历史记录会记住为该文件选择的最后一个快照，但是当通过历史记录重新打开快照时，索引文件也会显示在历史记录中。要在转储中打开另一个快照，请关闭第一个快照，然后使用“文件”菜单重新打开堆转储文件，并选择另一个快照进行解析。然后可以使用历史记录中的索引文件重新打开第一个快照，并且可以立即查看这两个快照。
			</p>



			<p class="p">
				<strong class="ph b">摘要</strong>
			</p>

			<p class="p">下表显示了各种平台上VM选项和工具的可用性：</p>

			
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" class="table" border="1" summary="" frame="border" rules="all">
					
					
					
					
					
					
					
					
					
					
					<thead class="thead" align="left">
						<tr class="row">
							<th class="entry" valign="top" width="6.25%" id="d8192e575">供应商</th>

							<th class="entry" valign="top" width="12.5%" id="d8192e578">发布</th>

							<th class="entry" colspan="3" valign="top" id="d8192e581">VM参数</th>

							<th class="entry" colspan="2" valign="top" id="d8192e584">太阳工具</th>

							<th class="entry" valign="top" width="6.25%" id="d8192e587">SAP工具</th>

							<th class="entry" valign="top" width="12.5%" id="d8192e591">连接</th>

							<th class="entry" valign="top" width="12.5%" id="d8192e594">垫</th>

						</tr>

					</thead>

					<tbody class="tbody">
						<tr class="row">
							<td class="entry" valign="top" width="6.25%" headers="d8192e575 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">内存不足</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">在Ctrl + Break上</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">代理人</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">JMAP</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">JConsole的</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">JVMMon</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">API</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">获取堆转储</td>

						</tr>

						<tr class="row">
							<td class="entry" rowspan="3" valign="top" width="6.25%" headers="d8192e575 ">太阳，惠普</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.4.2_12</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 "> </td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 "> </td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">没有</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.5.0_07</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是（自1.5.0_15起）</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">是（仅限Solaris和Linux）</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 "> </td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是（仅限Solaris和Linux）</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.6.0_00</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" rowspan="2" valign="top" width="6.25%" headers="d8192e575 ">Oracle，OpenJDK，HP</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.7.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.8.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="6.25%" headers="d8192e575 ">树液</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">任何1.5.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">是（仅限Solaris和Linux）</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 "> </td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 "> </td>

						</tr>

						<tr class="row">
							<td class="entry" rowspan="7" valign="top" width="6.25%" headers="d8192e575 ">IBM</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.4.2 SR12</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 "> </td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">没有</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.5.0 SR8a</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.ibm.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">没有</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.6.0 SR2</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.ibm.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">没有</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.6.0 SR6</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.ibm.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.7.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.ibm.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.8.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.ibm.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.8.0 SR5</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

						<tr class="row">
							<td class="entry" valign="top" width="6.25%" headers="d8192e575 ">OpenJ9</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e578 ">1.8.0</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e581 ">是</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e581 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e584 ">没有</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e584 ">是（仅限PHD）</td>

							<td class="entry" valign="top" width="6.25%" headers="d8192e587 ">没有</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e591 ">com.sun.tools.attach</td>

							<td class="entry" valign="top" width="12.5%" headers="d8192e594 ">是</td>

						</tr>

					</tbody>

				</table>
</div>

		</div>

	</div>

<div class="fn"><a name="fntarg_1" href="#fnsrc_1"><sup>1</sup></a> IBM DTFJ功能版本&gt; = 1.12.29003.201808011034没有此选项</div>
</body>
</html><html id="2440.Refactoring.html" dir="ltr"></html><html dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="iso-8859-1"></meta>
    <title>重构</title>
    <link rel="stylesheet" type="text/css" href="../help.css"></link>
  </head>
<body dir="ltr">
<div><h1>介绍</h1><h2>什么是重构？
</h2><p><i>重构</i>是对程序的改变，改进其内部设计但不改变其行为。这些包括次要的编码样式更改（如使用IMPLICIT NONE语句），代码可读性改进（如将名为N的变量替换为名为NUM_POINTS的变量），性能改进（如在某些条件下交换循环），甚至更大规模的设计更改（比如将程序从一个模块移动到另一个模块。虽然这些类型的更改可以手工完成，但制作它们通常很乏味且容易出错。Photran <i>自动化了</i>许多这样的重构。例如，Refactor&gt; Rename命令可以自动定位特定子例程的声明和使用，并在所有这些位置更改其名称。它也“聪明”;如果在不同的上下文中名为<i>d</i>子程序和变量命名为<i>d，</i>它不会将两者混淆。此外，在进行此类更改之前，Photran将尝试<i>验证</i>更改是否安全。例如，子程序<i>A</i>不能，如果已经有一个地方是调用子程序上下文中的变量称为<i>b</i>重命名为<i>B中</i> 。有关重构的更多信息，请参阅M. Fowler， <i>Refactoring：改进现有代码的设计，</i> Addison-Wesley，1999。
</p><h2>在Photran中重构</h2><p>大多数重构都可以通过菜单栏中的Refactor菜单访问，如下所述。但是，最常见的重构也有热键（例如，Alt + Shift + R用于重命名;热键列在每个命令旁边的重构菜单中）。此外，通过在编辑器中单击鼠标右键并从弹出菜单中选择“重构”，可以访问大多数重构。一些重构（例如，引入隐式无和替换过时运算符）可以同时应用于多个文件。如下所述，这涉及在Fortran项目视图中选择一个或多个文件，然后右键单击任何选定的文件名并从弹出菜单中选择Refactor。
</p><ul>
<li>单击Fortran Projects视图中的文件名将选择该文件（并且仅选择该文件）。
</li><li>按住Ctrl键并单击（在Mac OS X上按住Command键并单击）可用于选择或取消选择其他文件。
</li><li>要选择一系列文件，请单击一个文件名，然后按住Shift并单击以后的文件名;这些文件以及介于两者之间的所有文件也将被选中。
</li></ul>
<i><b>注意：</b> <b>Photran只能重构自由格式的Fortran源代码。无法重构固定格式代码。</b>确保仅选择自由格式的Fortran文件。</i>  如果任何文件是固定格式或非Fortran文件，则重构菜单可能不可用。
<h1>改名</h1><p></p><ul>
<li><b>说明：</b>重命名本质上是一种“智能”搜索和替换：它允许您更改变量，子程序等的名称。它正确地观察范围和阴影规则也可以跨文件重命名子程序和模块实体。
</li><li><b>适用于：</b>
<ol>
<li>局部变量<sup>1,2</sup>
</li><li>子程序<sup>3</sup> （包括外部和接口声明）</li><li>派生类型</li><li>模块实体（变量和子程序）</li><li>主要计划</li><li>名称列表</li><li>常见的块</li><li>块数据子程序</li></ol>
</li><li><b>操作：</b>
<ol>
<li>单击局部变量，子程序等的名称。</li><li>单击重构&gt;重命名...将出现“重命名”对话框。<br>
<center>
<img src="../images/Photran-rename-dialog.png" alt="重命名对话框"></center>
</li><li>输入变量/子程序/等的新名称。</li><li>如果要重命名外部子程序或接口块中声明的子程序，您可能需要（取消）选中标记为<i>使用接口和外部声明匹配外部子程序</i>的框<i>。</i>  如果选中此选项，则重构将尝试在具有给定名称的INTERFACE块中查找<i>所有</i>外部子程序，EXTERNAL语句和子程序声明，并且它们都将被重命名。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-rename-1.png" alt="重命名重构的简单示例"></center>
</li></ul>
<p>
<small>1。无法重命名虚拟子程序参数</small><br>
<small>2。无法重命名派生类型的组件</small><br>
<small>3。无法重命名内部子程序和类型绑定过程（Fortran 2003）</small>
</p>
<h1>提取程序</h1><p></p><ul>
<li><b>描述：</b> Extract Procedure从过程中删除一系列语句，将它们放入一个新的子例程中，并用对该子例程的调用替换原始语句。这些语句使用的任何局部变量都将作为参数传递给新过程。这种重构通常用于缩短程序。
</li><li><b>适用于：</b>过程或主程序中的一个或多个操作语句的序列。
</li><li><b>操作：</b>
<ol>
<li>在编辑器中选择一个或多个操作语句的序列。请务必在选择中的最后一个语句后面添加换行符。
</li><li>单击“重构”&gt;“提取过程”...将出现“提取过程”对话框。<br>
<center>
<img src="../images/Photran-extract-proc-dialog.png" alt="“提取过程”对话框"></center>
</li><li>输入将要创建的新过程的名称。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-extract-proc-1.png" alt="提取过程重构的简单示例"></center>
</li></ul>
<h1>提取局部变量</h1><p></p><ul>
<li><b>说明：</b> Extract Local Variable从较大的表达式中删除子表达式，并将该子表达式赋值给局部变量，将原始子表达式替换为对该变量的引用。此重构通常用于消除重复的子表达式或将解释变量名称引入复杂表达式。
</li><li><b>警告：</b>如果提取子表达式将保留原始表达式的关联性和优先级，则只允许重构。这种重构假定提取的表达式没有副作用;它<b>不</b>检查是否移动所提取的表达式的计算会改变程序的行为。
</li><li><b>操作：</b>
<ol>
<li>在编辑器中选择一个表达式。
</li><li>单击“重构”&gt;“提取局部变量”...将出现“提取局部变量”对话框。
</li><li>输入将要创建的新局部变量的类型和名称。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li></ul>
<h1>子程序重构</h1><h2>添加子程序参数</h2><p></p><ul>
<li><b>说明：</b>此重构将向子例程添加参数。
</li><li><b>适用于：</b>子程序。
</li><li><b>操作：</b>
<ol>
<li>选择子例程名称或子例程语句</li><li>单击重构&gt;子程序&gt;添加子例程参数（或按Shift + Alt + P）</li><li>使用输入页面选择参数的类型，意图和名称。
</li><li>输入默认值和位置的数字。
</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/Add Subroutine Parameter.png" alt="添加子例程参数重构的示例。"></center>
</li></ul>
<h2>置换子程序参数</h2><p></p><ul>
<li><b>说明：</b>此重构将更改参数的顺序到子例程并相应地调整所有调用站点。
</li><li><b>适用于：</b>调用所选子例程的所有文件。
</li><li><b>操作：</b>
<ol>
<li>选择子例程名称或子例程语句</li><li>单击重构&gt;子程序&gt;更改子例程签名。
</li><li>使用输入页面的向上和向下按钮重新排列子例程的参数顺序。
</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/Change Subroutine Signature.png" alt="更改子例程签名重构的示例。"></center>
</li></ul>
<h2>安全删除</h2><p></p><ul>
<li><b>说明：</b>此重构将从给定主机中删除所有内部子程序。如果对子程序有任何引用，则重构失败。
</li><li><b>适用于：</b>文件。
</li><li><b>操作：</b>
<ol>
<li>选择要删除的子例程名称或子例程语句</li><li>单击重构&gt;子程序&gt;安全删除</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/Safe-Delete Internal Subprograms.png" alt="安全删除内部子程序重构的示例。"></center>
</li></ul>
<h1>模块重构</h1><h2>让私人实体公开</h2><ul><li><b>说明：</b>将模块变量或子程序从PRIVATE更改为PUBLIC可见性，并检查它是否与该模块为USEd的任何现有名称冲突。</li><li><b>适用于：</b>变量，子程序，函数。
</li><li><b>不适用于：</b>内在函数，外部，接口。
</li><li><b>操作：</b><ol><li>选择您要公开的私有实体的名称。
</li><li>选择“重构”&gt;“模块”&gt;“将私有实体设为公共”。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol></li><li><b>例</b><br> <center>
<img src="../images/Photran-priv-to-public.PNG" alt="make私有实体公共重构的示例。"></center>
</li></ul><p><br> <center>
<img src="../images/Photran-priv-to-public2.PNG" alt="make私有实体公共重构的示例2。"></center>
</p><h2>封装变量</h2><p></p><ul>
<li><b>描述：</b> Encapsulate变量为定义它的模块中的选定变量创建getter和setter方法，并将变量的可见性更改为<b>private</b> 。它还替换了所有文件中该变量的所有用法，以使用getter和setter方法调用<sup>1</sup> 。
</li><li><b>适用于：</b>
<ol>
<li>模块中定义的变量。
</li><li>所有基本类型和用户定义类型的变量</li></ol>
</li><li><b>不适用于：</b>
<ol>
<li>数组</li><li>未在模块中定义的变量</li><li>参数（即<b>整数，参数:: CANNOT_ENCAPSULATE</b> ）</li><li>指针（即<b>真实，指针:: CANNOT_ENCAPSULATE</b> ）</li><li>目标（即<b>整数，目标:: CANNOT_ENCAPSULATE</b> ）</li></ol>
</li><li><b>操作：</b>
<ol>
<li>单击或选择要封装的变量的名称。
</li><li>单击“重构”&gt;“模块”&gt;“封装变量”。将出现“封装变量”对话框。<br>
<center>
<img src="../images/GetterSetterNames.jpg" alt="用于封装变量&lt;b&gt; temp &lt;/ b&gt;的getter和setter名称菜单"></center>
</li><li>输入getter和setter方法的名称。如果要分配给getter和setter方法的名称与任何涉及的文件中的某些其他标识符冲突，将会收到警告。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/EncapsulateVariablesPart1.jpg" alt="Encapsulate Variable重构的简单示例&lt;b&gt; temp &lt;/ b&gt;"></center>
<br>
<center>
<img src="../images/EncapsulateVariablesPart2.jpg" alt="Encapsulate Variable重构的简单示例&lt;b&gt; temp &lt;/ b&gt;"></center>
</li></ul>
<p>
<small>1。如果变量用作函数/子例程调用的参数，并且该函数将变量的值更改为副作用，则不会保留该更改。
</small><br>
</p>
<h1>使用Statement Refactorings</h1><h2>仅添加USE声明的条款</h2><ul><li><b>描述：</b>创建模块中正在使用的符号列表，并将其添加到USE语句中。
</li><li><b>适用于：</b>包含公共定义的所有模块。
</li><li><b>不适用于：</b>仅包含私有实体的空模块或模块。
</li><li><b>操作：</b><ol><li>在要添加ONLY子句的USE语句中选择模块的名称。
</li><li>选择“重构”&gt;“使用语句”&gt;“仅添加子句”以使用语句。
</li><li>选择要包含在ONLY列表中的模块实体。现有ONLY列表中的任何实体都已被选中，可以取消选择以删除。<br><center>
<img src="../images/Photran-add-only-dialog.PNG" alt="仅添加到USE对话框"></center>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol></li><li><b>例</b><br> <center>
<img src="../images/Photran-add-only-list.PNG" alt="向USE语句重构添加ONLY子句的示例。"></center>
</li></ul><h2>最小化仅限列表</h2><ul><li><b>描述：</b>从USE语句中的ONLY列表中删除未使用的符号。
</li><li><b>适用于：</b>带有ONLY子句的USE语句。
</li><li><b>操作：</b><ol><li>在USE语句中选择要最小化其唯一列表的模块名称。
</li><li>选择“重构”&gt;“使用语句”&gt;“仅最小化列表”。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol></li><li><b>例</b><br> <center>
<img src="../images/Photran-min-only-list.PNG" alt="最小化ONLY列表重构的示例。"></center>
</li></ul><h1>常见的块重构</h1><h2>使公共块变量名一致</h2><ul><li><b>描述：</b> Fortran允许COMMON块的不同定义为相同的变量赋予不同的名称。这令人困惑。此重构为COMMON块的所有定义中的变量赋予相同的名称。
</li><li><b>适用于：</b>具有有效名称的所有COMMON块。
</li><li><b>不适用于：</b>具有NULL名称的COMMON块。
</li><li><b>操作：</b><ol><li>在编辑器中选择要使变量名一致的COMMON块的名称。
</li><li>选择“重构”&gt;“公共块”&gt;“使公共块变量名称保持一致”。
</li><li>输入您希望提供COMMON变量的新名称。默认新名称是所选块中的原始名称，并附加“_common”。<br><center>
<img src="../images/Photran-make-common-var-names-consist-dialog.PNG" alt="使常见的var名称一致对话框"></center>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol></li><li><b>例</b><br> <center>
<img src="../images/Photran-make-common-var-names-consist.PNG" alt="使COMMON变量名一致重构的示例。"></center> <center>
<img src="../images/Photran-make-common-var-names-consist-1.PNG" alt="使COMMON变量名一致重构的示例。"></center>
</li></ul><h2>将保存的变量移动到公共块</h2><p></p><ul>
<li><b>说明：</b>将保存的变量移动到公共块为子程序的所有“已保存”变量创建公共块。子程序中这些变量的声明被转换，使得它们不再被“保存”。生成的公共块在主PROGRAM和受影响的子程序中都被声明。放置在公共块中的变量被重命名，使得它们不会冲突或影响其他变量。目前的实施假定该子程序位于计划的CONTAINS部分。</li><li><b>适用于：</b>子程序。
</li><li><b>操作：</b>
<ol>
<li>单击子程序的声明语句。
</li><li>单击“重构”&gt;“公共块”&gt;“将保存的变量移动到公共块”。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/MoveSavedToCommonBlock.PNG" alt="引入隐式无重构的示例"></center>
</li></ul>
<h1>循环重构</h1><h2>交换循环</h2><p></p><ul>
<li><b>描述：</b>交换所选嵌套do循环<sup>1的</sup>内部和外部循环。这种重构只是切换内部和外部的do-header。它不会对循环体进行任何更改。
</li><li><b>适用于：</b>选定的嵌套do循环</li><li><b>操作：</b>
<ol>
<li>选择要交换的嵌套循环</li><li>单击“重构”&gt;“执行循环”&gt;“交换循环”。将出现“交换循环”对话框。<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/InterchangeLoops.png" alt="交换循环重构的简单示例"></center>
</li></ul>
<p>
<small>1。为了使重构正常工作，在第二个循环之前必须没有语句。如果存在这样的陈述，则无法保证重构的正确性。
</small>
</p>
<h2>保险丝圈</h2><p></p><ul>
<li><b>描述：</b>采用两个do循环，规范化它们的边界，最后将循环体放在一个do循环中。
</li><li><b>适用于：</b>找到要融合的两个do-loops，并仅选择第一个<sup>1</sup> 。如果两个循环之间有任何语句，则语句将保留在融合的do循环之后。为了使循环兼容，循环需要具有相同的迭代次数（边界不需要相同，只需要访问循环体的次数）。
</li><li><b>操作：</b>
<ol>
<li>选择要融合的第一个do-loop。
</li><li>单击“重构”&gt;“执行循环”&gt;“熔丝循环”。
</li><li>单击“预览”以查看所做更改的比较视图，单击“确定”以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/FusionRefactoringExample.jpg" alt="具有不同边界的循环的循环融合示例"></center>
</li></ul>
<p>
<small>1。重构将在您的代码中找到下一个列出的do循环（即使它们之间有其他代码行）。
</small>
</p>
<h2>反向循环</h2><p></p><ul>
<li><b>描述：</b>采用递增或递减循环，交换下限和上限，并取消步骤。
</li><li><b>适用于：</b>选定的do-loop</li><li><b>操作：</b>
<ol>
<li>选择完整的do-loop或do-loop标头</li><li>单击“重构”&gt;“执行循环”&gt;“反向循环”。
</li><li>单击“预览”以查看所做更改的比较视图，单击“确定”以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/ReverseLoopExample.jpg" alt="反向环路重构的示例"></center>
</li></ul>
<h2>瓷砖循环</h2><p></p><ul>
<li><b>说明：</b>此重构采用双嵌套do循环，并创建具有四个深度级别的嵌套do循环。它不是通过遍历每一行来迭代二维数组（例如），而是遍历较小的块块</li><li><b>适用于：</b>双嵌套do循环，其中两个步长值均为1。
</li><li><b>输入：</b>
<ul>
<li>平铺大小：访问块或平铺的大小。因此，如果图块大小为3，则将以3x3块访问数组。
</li><li>平铺偏移：调整块开始的位置（无论在何处开始，所有数据都将被覆盖）。
</li></ul>
</li><li><b>操作：</b>
<ol>
<li>选择整个嵌套的do循环，或顶部嵌套do循环的标题。
</li><li>单击重构&gt;执行循环&gt;平铺循环。
</li><li>输入切片步骤和切片偏移，然后单击预览以查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/TilingExample.jpg" alt="循环平铺示例，平铺大小为20，平铺偏移为5。"></center>
</li></ul>
<h2>展开循环</h2><ul><li><b>描述：</b>采用选定的do循环，并完全或部分展开它。这也可以选择包含一个条件语句，以确保循环保持在边界内。
</li><li><b>适用于：</b>不包含标签的do循环，从不写入索引变量（例如：read（*，*）indexVar）</li><li><b>操作：</b><ol><li>选择要展开的循环（或只是标题）。
</li><li>单击“重构”&gt;“执行循环”&gt;“展开循环”。
</li><li>选择要展开循环的次数，或选中“完全展开”框。如果您不希望条件语句确保编号循环展开中的正确循环边界，请取消选中“包含边界检查”框。
</li><li>单击“预览”以查看此重构将进行的更改，然后单击“确定”以进行更改。
</li></ol></li><li><b>实施例（编号）：</b> <center>
<img src="../images/NumLoopUnrollWBoundsCheck.jpg" alt="预览展开循环四次，包括边界检查"></center>
</li><li><b>实施例（完成）：</b> <center>
<img src="../images/CompleteLoopUnrolling.jpg" alt="预览完全展开循环"></center>
</li></ul><h1>重构删除过时的语言功能</h1><h2>删除算术If</h2><p></p><ul>
<li><b>说明：</b>此重构将从单个文件或项目中的所有文件中删除所有算术if语句，这是Fortran 90中已过时的功能。
</li><li><b>适用于：</b>项目或文件。
</li><li><b>操作：</b>
<ol>
<li>选择要删除的算术if语句的项目或文件。
</li><li>单击重构&gt;过时语言功能&gt;删除算法如果语句</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/RemoveArithmeticIf.png" alt="删除算术的示例如果语句重构。"></center>
</li></ul>
<h2>删除已分配转到</h2><p></p><ul>
<li><b>描述：</b>此重构将删除所有已分配的goto语句，并将其替换为大小写块。
</li><li><b>适用于：</b>所有已分配的goto语句。
</li><li><b>操作：</b>
<ol>
<li>单击重构&gt;&gt;过时的语言功能&gt;删除已分配的转到。
</li><li>如果要添加默认大小写，请选择“是”，否则选择“否”。</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/Remove Assigned Goto.png" alt="删除算术的示例如果语句重构。"></center>
</li></ul>
<h2>删除分支结束If</h2><p></p><ul>
<li><b>描述：</b>删除分支到END IF语句。GOTO声明具有分支功能。分支结束if将替换为紧跟在END IF语句之后的分支到CONTINUE语句。
</li><li><b>适用于：</b>选择结束if语句</li><li><b>操作：</b>
<ol>
<li>选择带有语句标签的end if语句</li><li>单击“重构”&gt;“废弃语言功能”&gt;“删除分支结束”<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Remove Branch to End If.png" alt="删除分支结束的简单示例如果重构"></center>
</li></ul>
<p>
</p>
<h2>用Character替换Character *（len =）</h2><p></p><ul>
<li><b>描述：</b>用字符（len = n）声明替换字符* n声明。
</li><li><b>适用于：</b>所有字符声明</li><li><b>操作：</b>
<ol>
<li>选择一个字符声明语句</li><li>单击“重构”&gt;“过时语言功能”&gt;“使用字符替换字符*”（len =）...将出现带字符的替换字符*（len =）。<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Replace CharacterStar with Character(len=).png" alt="使用Character（len =）重构替换Character *的简单示例"></center>
</li></ul>
<p>
</p>
<h2>删除Computed Goto</h2><p></p><ul>
<li><b>描述：</b>用select case语句替换计算的goto语句</li><li><b>适用于：</b>选定的计算goto语句</li><li><b>操作：</b>
<ol>
<li>选择要删除的计算goto语句</li><li>单击“重构”&gt;“过时的语言功能”&gt;“删除已计算的转到”。将出现“删除计算的转到”对话框。<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/RemoveComputedGoto.png" alt="删除Computed Goto重构的简单示例"></center>
</li></ul>
<p>
</p>
<h2>替换过时的运算符</h2><p></p><ul>
<li><b>描述：</b>替换过时运算符替换旧式比较运算符的所有用法（例如。LT。和。EQ。）及其较新的等价物（符号如&lt;和==）。并为之前隐式声明的所有变量添加显式声明。
</li><li><b>适用于：</b>以下运算符在一个或多个文件中的所有使用：。LT。 。LE。 。EQ。 。NE。 。GT。 。GE。</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要在单个文件中替换过时的运算符，请</i>在编辑器中打开该文件，然后从菜单栏中选择“重构”&gt;“过时的语言功能”&gt;“替换过时的运算符”。
</li><li> <i>要在多个文件中替换过时的运算符，请</i>在“Fortran项目”视图中选择文件，右键单击任何选定的文件名，然后从弹出菜单中选择“重构”&gt;“过时的语言功能”&gt;“替换过时的运算符”。
</li></ul>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-replace-obsolete-1.png" alt="替换过时运算符重构的示例"></center>
</li></ul>
<h2>替换旧式Do循环</h2><p></p><ul>
<li><b>描述：</b>用现代风格的do循环替换旧式do循环</li><li><b>适用于：</b>所有旧式do循环</li><li><b>操作：</b>
<ol>
<li>单击“重构”&gt;“过时语言功能”&gt;“删除旧式操作循环”。<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Replace Old-Style Do Loops.png" alt="删除旧式Do循环重构的简单示例"></center>
</li></ul>
<p>
</p>
<h2>删除暂停声明</h2><p></p><ul>
<li><b>描述：</b>用空打印和读取语句替换pause语句</li><li><b>适用于：</b>选定的暂停语句</li><li><b>操作：</b>
<ol>
<li>选择要删除的暂停语句</li><li>单击“重构”&gt;“过时语言功能”&gt;“删除暂停语句”。<br>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Remove Pause Statement.png" alt="删除暂停声明重构的简单示例"></center>
</li></ul>
<p>
</p>
<h2>删除实/双精度循环计数器</h2><p></p><ul>
<li><b>描述：</b>通过控制将do或do while循环转换为do或do while循环而无需控制。
</li><li><b>适用于：</b>选定循环</li><li><b>操作：</b>
<ol>
<li>选择要转换的循环</li><li>单击“重构”&gt;“废弃语言功能”&gt;“删除实时/双精度循环计数器”。<br>
</li><li>选择do loop或do while循环。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Remove Real or Double Precision Loop Counter.png" alt="删除实/双精度循环计数器重构的简单示例"></center>
</li></ul>
<p>
</p>
<h1>重构改进编码风格</h1><h2>将标识符添加到结束语句</h2><p></p><ul>
<li><b>描述：</b>此重构将程序/子程序名称添加到结束语句。
</li><li><b>适用于：</b>文件或项目。
</li><li><b>操作：</b>
<ol>
<li>选择文件或项目。
</li><li>单击重构&gt;编码样式&gt;将标识符添加到结束语句</li><li>单击预览可在不应用的情况下查看更改，或单击确定以应用更改。
</li></ol>
</li><li><b>例：</b>
<center>
<img src="../images/Add Identifier to END.png" alt="向END语句重构添加标识符的示例。"></center>
</li></ul>
<h2>更改关键字案例</h2><p></p><ul>
<li><b>描述：</b>在所选的Fortran程序文件中使所有适用的关键字具有相同的大小写。
</li><li><b>适用于：</b>除下列关键字以外的所有关键字。
</li><li><b>不适用于：</b>
<ol>
<li>身份标识</li><li>除整数常量和实常数之外的所有常量</li></ol>
</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要在单个文件中更改关键字大小写，请</i>在编辑器中打开该文件，然后从菜单栏中选择“重构”&gt;“编码样式”&gt;“更改关键字大小写”。
</li><li> <i>要在多个文件中引入隐式无，请</i>在“Fortran项目”视图中选择文件，右键单击任何选定的文件名，然后从弹出菜单中选择“重构”&gt;“编码样式”&gt;“更改关键字大小写”。
</li></ul>
</li><li>选择大写或小写<br>
<center>
<img src="../images/Photran-canonicalize-keyword-cap-dialog.PNG" alt="Canonicalize关键字大写对话框。"></center>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例</b><br>
<center>
<img src="../images/Photran-canonicalize-keyword-cap-1.PNG" alt="Canonicalize Keyword Capitalization重构的示例。"></center>
</li></ul>
<h2>在If语句和If构造之间转换</h2><p></p><ul>
<li><b>描述：</b>将简单的if语句转换为带有then块和else else块的if结构。
</li><li><b>适用于：</b>选择if语句。
</li><li><b>操作：</b>
<ol>
<li>重构&gt;编码样式&gt;在If语句和If构造之间转换</li><li>选择是否需要空的else块。
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Convert Between If Statement and If Construct.png" alt="转换If语句和If构造重构的示例"></center>
</li></ul>
<h2>将数据语句转换为参数语句</h2><p></p><ul>
<li><b>描述：</b>当在DATA语句中声明的变量是常量时，可以使用Data to Parameter将其更改为具有PARAMETER属性的变量。使用PARAMETER属性可以更清楚地知道哪些变量是常量，哪些变量不是常量;它还可以带来性能提升，因为它可以允许优化编译器用常量值替换一些变量访问。
</li><li><b>适用于：</b>一个或多个文件中的所有主程序，子程序和模块。
</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要将在参数属性中声明的变量中声明为变量的变量转换为单个文件，请</i>在编辑器中打开该文件，然后从菜单栏中选择“重构”&gt;“编码样式”&gt;“将数据语句转换为参数语句”。
</li><li> <i>要转换在多个文件中使用参数属性声明的变量中声明为数据的变量，请</i>在“Fortran项目”视图中选择文件，右键单击任何选定的文件名，然后选择“重构”&gt;“编码样式”&gt;“将数据语句转换为参数语句”。弹出菜单。
</li></ul>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-Data-To-Parameter.png" alt="数据到参数重构的示例"></center>
</li></ul>
<h2>引入隐含无</h2><p></p><ul>
<li><b>描述：</b>向文件添加IMPLICIT NONE语句，并为之前隐式声明的所有变量添加显式声明。
</li><li><b>适用于：</b>一个或多个文件中的所有主程序，子程序和模块。
</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要在单个文件中引入Implicit None，请</i>在编辑器中打开文件，然后从菜单栏中选择Refactor&gt; Coding Style&gt; Introduce Implicit None。
</li><li> <i>要在多个文件中引入Implicit None，请</i>在Fortran Projects视图中选择文件，右键单击任何选定的文件名，然后从弹出菜单中选择Refactor&gt; Coding Style&gt; Introduce Implicit None。
</li></ul>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-intro-implicit-1.png" alt="引入隐式无重构的示例"></center>
</li></ul>
<h2>使保存属性显式</h2><p></p><ul>
<li><b>描述：</b>使保存属性显式。
</li><li><b>适用于：</b>整个程序。
</li><li><b>操作：</b>
<ol>
<li>重构&gt;编码样式&gt;使保存属性显式</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Make Save Attributes Explicit.png" alt="Make Save Attributes的示例显式重构"></center>
</li></ul>
<h2>删除未引用的标签</h2><p></p><ul>
<li><b>描述：</b>删除所有未引用的标签。
</li><li><b>适用于：</b>所有未引用的标签。
</li><li><b>操作：</b>
<ol>
<li>重构&gt;编码样式&gt;删除未引用的标签</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Remove Unreferenced Labels.png" alt="删除未引用标签重构的示例"></center>
</li></ul>
<h2>删除未使用的局部变量</h2><p></p><ul>
<li><b>描述：</b>删除未使用的变量删除从未使用过的局部变量的声明。
</li><li><b>适用于：</b>一个或多个文件中的所有主程序，子程序和模块。
</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要在单个文件中删除未使用的变量，请</i>在编辑器中打开该文件，然后从菜单栏中选择“重构”&gt;“编码样式”&gt;“删除未使用的局部变量”。
</li><li> <i>要在多个文件中删除未使用的变量，请</i>在“Fortran项目”视图中选择文件，右键单击任何选定的文件名，然后从弹出菜单中选择“重构”&gt;“编码样式”&gt;“删除未使用的局部变量”。
</li></ul>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-Remove-Unused-Variables.png" alt="删除未使用的变量重构的示例"></center>
</li></ul>
<h2>标准化声明</h2><p></p><ul>
<li><b>说明：</b>标准化语句重写所有变量声明，以便<ul>
<li>每行只有一个变量声明，和</li><li>每个变量声明都包含一个双冒号（：:)。
</li></ul>这旨在使代码更具可读性。
</li><li><b>适用于：</b>一个或多个文件中的所有主程序，子程序和模块。
</li><li><b>操作：</b>
<ol>
<li>这是一个多文件重构。
<ul>
<li> <i>要在单个文件中标准化语句，请</i>在编辑器中打开文件，然后从菜单栏中选择“重构”&gt;“编码样式”&gt;“标准化语句”。
</li><li> <i>要标准化多个文件中的语句，请</i>在“Fortran项目”视图中选择文件，右键单击任何选定的文件名，然后从弹出菜单中选择“重构”&gt;“编码样式”&gt;“标准化语句”。
</li></ul>
</li><li>单击“预览”以查看将进行的更改，然后单击“确定”以应用它们。
</li></ol>
</li><li><b>例：</b><br>
<center>
<img src="../images/Photran-Standardize-Statements.png" alt="重构标准化语句的示例"></center>
</li></ul>
</div>
</body>
</html><html id="2716.cheatSheetContentFileSpec.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>备忘单内容文件XML格式</title>
<style></style>
<style></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">备忘单内容文件XML格式</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.cheatsheets.cheat_sheet_schema<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>该文档将备忘单内容文件结构描述为一系列DTD片段（ <a href="cheatSheetContentFileSpec.exsd">机器可读XML模式</a> ）。</p>

<p>备忘单由一系列必须按顺序完成的项目（步骤）组成。项目可以划分为子项目，并可以启动将为用户执行某些步骤的命令或操作。</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.cheatsheet">cheatsheet</a> （ <a href="#e.intro">介绍</a> ， <a href="#e.item">项目</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST备忘单</p>
<p class="code SchemaDtdAttlist">标题CDATA #REQUIRED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">备忘单的根元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>title</b> - 这个备忘单的标题。当打开备忘单时，标题将显示在备忘单视图的头部。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.intro">介绍</a> （ <a href="#e.description">介绍</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST介绍</p>
<p class="code SchemaDtdAttlist">contextId CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">href CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">&lt;intro&gt;元素用于定义打开备忘单时要显示的介绍性文本。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>contextId</b> - 此备忘单文档的可选帮助上下文ID。如果提供，则当用户单击介绍的帮助链接时，将向用户显示给定的完全限定上下文ID的上下文帮助（通常在小弹出窗口中）。如果提供了此属性，则不应提供<b>href</b>属性（如果两者都存在，则将忽略<b>href</b> ）。</li>
<li><b>href</b> - 描述此备忘单的可选帮助文档。如果提供，则在单击介绍的帮助链接时，将向用户显示此帮助文档（通常在单独窗口中显示的帮助浏览器中）。如果提供了此属性，则不应提供<b>contextId</b>属性（如果两者都存在，则将忽略<b>href</b> ）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！元素<a name="e.description">描述</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">&lt;description&gt;元素包含备忘单或备忘单项目的描述。描述由散布有<a href="../../../org.eclipse.platform.doc.isv/guide/forms_controls_text_markup.htm">表单文本标记</a>的文本<a href="../../../org.eclipse.platform.doc.isv/guide/forms_controls_text_markup.htm">组成</a> 。备忘单自动格式化并布置文本，使其在UI中合理显示。内的文本，平衡<b>的&lt;b&gt;</b> ... <b>&lt;/ b&gt;的</b>标签造成封闭文本用粗体字来呈现，并且<b>&lt;BR/&gt;</b>元件可以用来强制换行。这些是目前唯一支持的格式化标签（但是，将来可能会添加其他标签）。文本中的某些字符对XML解析器具有特殊意义;特别地，写“&lt;”，“&gt;”，“＆”，“'”和“”“（引号）而不是写”＆lt;“，”＆gt;“，”＆amp;“，”'“和“和”分别。空格（空格和换行符）被视为单词分隔符;相邻空格和换行符被视为单个单元，并呈现为单个空格或换行符。忽略&lt; <b>description</b> &gt;和&lt;br <b>/&gt;</b>标记之后的空格，就像&lt; <b>/ description</b> &gt;标记之前的空格一样。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.item">项目</a> （ <a href="#e.description">描述</a> ，（ <a href="#e.action">action</a> | <a href="#e.command">command</a> | <a href="#e.perform-when">perform-when</a> |（ <a href="#e.subitem">subitem</a> | <a href="#e.conditional-subitem">conditional-subitem</a> | <a href="#e.repeated-subitem">repeated-subitem</a> ）*）， <a href="#e.onCompletion">onCompletion</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST项目</p>
<p class="code SchemaDtdAttlist">标题CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">对话框（true | false）“false”</p><p class="code SchemaDtdAttlist">跳过（true | false）“false”</p><p class="code SchemaDtdAttlist">contextId CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">href CDATA #IMPLIED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;item&gt;元素描述备忘单中的一个顶级步骤。&lt;item&gt;可以包含&lt;subitem&gt;元素。

</p><p>org.eclipse.ui.cheatsheets.cheatSheetItemExtension允许在UI中显示项目的其他自定义控件。对此扩展点的贡献声明了可能出现在&lt;item&gt;元素上的其他字符串值属性的名称。</p>
<p>简单项具有描述和可选操作或命令。在典型的演示中，大部分时间都向用户显示备忘单项目的标题。仅在步骤处于执行过程中时才显示项目的描述。&lt;action&gt;，&lt;command&gt;或&lt;perform-when&gt;）元素的存在与用户可以按下以执行步骤的操作或命令的按钮相关联。如果不存在动作或命令，则该步骤是用户必须手动执行的步骤，然后明确表示他们已成功完成该步骤。</p>
<p>步骤可以分解为&lt;subitem&gt;子元素指定的子步骤。与用户必须严格遵循的项目不同，给定项目的子项目可以按任何顺序执行。在进入下一个项目之前，必须尝试（或跳过）项目中的所有子项目。（这意味着必须以所需顺序执行的操作不能表示为子项。）</p>
<p>&lt;conditional-subitem&gt;子元素允许步骤基于在先前步骤中获取其值的备忘单变量来定制子步骤的呈现。&lt;repeated-subitem&gt;子元素允许步骤包括一组类似的子步骤。同样，确切的子步骤集可以基于在先前步骤中获取其值的备忘单变量。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>title</b> - 此步骤的标题。</li>
<li><b>对话框</b> - 如果“true”表示此步骤涉及打开模态对话框。这是系统的一个提示，它应该允许用户在模态对话框中继续使用备忘单。此属性仅影响从命令或操作启动的对话框。</li>
<li><b>skip</b> - 如果“true”表示可以跳过整个步骤; UI通常显示一个按钮，用户可以按下该按钮以指示他们正在跳过此步骤</li>
<li><b>contextId</b> - 此备忘单步骤的文档的可选帮助上下文ID。如果提供，则当用户单击步骤的帮助链接时，将向用户显示给定的完全限定上下文ID的上下文帮助（通常在小弹出窗口中）。如果提供了此属性，则不应提供<b>href</b>属性（如果两者都存在，则将忽略<b>href</b> ）。</li>
<li><b>href</b> - 描述此备忘单步骤的可选帮助文档。如果提供，则在单击步骤的帮助链接时，将向用户显示此帮助文档（通常在单独窗口中显示的帮助浏览器中）。如果提供了此属性，则不应提供<b>contextId</b>属性（如果两者都存在，则将忽略<b>href</b> ）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.subitem">子项</a> （ <a href="#e.description">描述</a> ，（？ <a href="#e.action">动作</a> | <a href="#e.command">命令</a> | <a href="#e.perform-when">执行-时</a> ）？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST子项目</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">跳过（true | false）“false”</p><p class="code SchemaDtdAttlist">当CDATA #IMPLIED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;subitem&gt;元素描述备忘单中的子步骤。&lt;subitem&gt;带有一个简单的文本标签，但既没有冗长的描述也没有其他子项。
</p><p>子项可以具有可选的动作或命令。&lt;action&gt;，&lt;command&gt;或&lt;perform-when&gt;元素的存在与用户可以按下以执行子步骤的操作或命令的按钮相关联。如果不存在动作或命令，则子步骤是用户必须手动执行的子步骤，然后明确指示他们已成功完成该步骤。</p>
<p>与必须严格遵循的项目不同，给定项目的子项目可以按任何顺序执行。在进入下一个项目之前，必须完成或跳过项目中的所有子项目。（这意味着必须按所需顺序执行的操作不应表示为子项。）</p>
<p>自版本3.4以来，在子项目中允许描述代替label属性，这允许使用格式化标签。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>label</b> - 备忘单子项的标题。如果字符串包含“$ { <i>var</i> }”形式的子字符串出现，则它们被视为对备忘单变量的引用。字符串值中的所有此类出现将由作弊表执行上下文中相应变量的值替换，或者替换为未绑定变量的空字符串。变量的值是主步骤执行开始时（详细说明&lt;item&gt;元素时），而不是运行单个子步骤时的值。子项可以具有标签或描述元素，但不能同时具有两者。描述元素可以包含格式化标记，例如&lt;b&gt;，&lt;/ b&gt;或&lt;br/&gt;。</li>
<li><b>skip</b> - 如果“true”，则可以跳过此子步骤。UI通常显示一个按钮，用户可以按下该按钮以指示他们正在跳过此子步骤。</li>
<li><b>when</b> - 表示当且仅当包含&lt;conditional-subitem&gt;元素的condition属性的值与此字符串值匹配时才使用此子项。如果&lt;subitem&gt;元素不是&lt;conditional-subitem&gt;元素的子元素，则忽略此属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.conditional-subitem">有条件子项目</a> （ <a href="#e.subitem">子项目</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST条件子项</p>
<p class="code SchemaDtdAttlist">条件CDATA #REQUIRED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;conditional-subitem&gt;元素描述一个子步骤，其形式可以根据项目展开时已知的条件而不同。
</p><p>&lt;conditional-subitem&gt;元素的<b>condition</b>属性提供了一个字符串值（总是这个值来自一个备忘单变量）。每个&lt;subitem&gt;子项都必须带有一个具有不同字符串值的<b>when</b>属性。展开项时，&lt;conditional-subitem&gt;元素将替换为具有匹配值的&lt;subitem&gt;元素。如果没有具有匹配值的&lt;subitem&gt;元素，则认为是错误。</p>
<p>例如，如果名称为“v1”的备忘单变量在展开以下项目时具有值“b”</p>
<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;conditional-subitem condition =</span> <span class="code SchemaCstring">“$ {v1}”</span> <span class="code SchemaTag">&gt; &lt;subitem when =</span> <span class="code SchemaCstring">“a”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“Step for A.”</span> <span class="code SchemaTag">/&gt; &lt;subitem when =</span> <span class="code SchemaCstring">“b”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“B步骤”</span> <span class="code SchemaTag">/&gt; &lt;/ conditional-subitem&gt; &lt;/ item&gt;</span></pre>然后选择第二个子项目，项目扩展到相当于的东西<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“B的步骤”</span> <span class="code SchemaTag">/&gt; &lt;/ item&gt;</span></pre></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>condition</b> - 用于选择将使用哪个子&lt;subitem&gt;的任意字符串值。如果属性字符串的格式为“$ { <i>var</i> }”，则认为它是对备忘单变量<i>var</i>的引用，条件的值将是在包含执行时的备忘单变量的值&lt;item&gt;元素（如果变量在那时未绑定，则为空字符串）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.repeated-subitem">重复-子项</a> （ <a href="#e.subitem">子项目</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST重复 - 子项目</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;repeated-subitem&gt;元素描述扩展为0,1或更多类似子步骤的子项。
  
</p><p><b>values</b>属性提供逗号分隔的字符串列表; &lt;subitem&gt;子项提供模板。当项目展开时，&lt;repeated-subitem&gt;元素被&lt;subitem&gt;元素的副本替换，变量“this”的出现被相应的字符串值替换。</p>
<p>例如，如果名称为“v1”的备忘单变量在扩展以下项目时具有值“1，b，3”</p>
<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;repeated-subitem values =</span> <span class="code SchemaCstring">“$ {v1}”</span> <span class="code SchemaTag">&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“Step $ {this}。”</span> <span class="code SchemaTag">&gt; &lt;action class =</span> <span class="code SchemaCstring">“com.xyz.myaction”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz”</span> <span class="code SchemaTag">param1 =</span> <span class="code SchemaCstring">“$ {this}”</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;/ repeated-subitem&gt; &lt;/ item&gt;</span></pre>然后项目扩展到相当于：<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“Step 1”</span> <span class="code SchemaTag">&gt; &lt;action class =</span> <span class="code SchemaCstring">“com.xyz.myaction”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz”</span> <span class="code SchemaTag">param1 =</span> <span class="code SchemaCstring">“1”</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“步骤b。”</span> <span class="code SchemaTag">&gt; &lt;action class =</span> <span class="code SchemaCstring">“com.xyz.myaction”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz”</span> <span class="code SchemaTag">param1 =</span> <span class="code SchemaCstring">“b”</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“第三步。”</span> <span class="code SchemaTag">&gt; &lt;action class =</span> <span class="code SchemaCstring">“com.xyz.myaction”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz”</span> <span class="code SchemaTag">param1 =</span> <span class="code SchemaCstring">“three”</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;/ item&gt;</span></pre></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>values</b> - 包含以逗号分隔的值列表的字符串。如果属性字符串的格式为“$ { <i>var</i> }”，则认为它是对备忘单变量<i>var</i>的引用，条件的值将是在包含执行时的备忘单变量的值&lt;item&gt;元素（如果变量在那时未绑定，则为空字符串）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">pluginId CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">paramN CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">确认（true | false）“false”</p><p class="code SchemaDtdAttlist">当CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">required（true | false）“true”</p><p class="code SchemaDtdAttlist">翻译CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">每个&lt;action&gt;元素都描述了备忘单中的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.jface.action.的Java类的完全限定名称<code>org.eclipse.jface.action.IAction</code> 。如果此操作也实现了<code>org.eclipse.ui.cheatsheets.ICheatSheetAction</code>将通过其run（String []，ICheatSheetManager）方法调用它并传递备忘单管理器和动作参数。只要存在此属性，就必须存在pluginId属性。如果运行操作可能会失败（可能是因为用户从其对话框中取消操作），强烈建议从备忘单调用的操作应报告成功/失败结果。（参见org.eclipse.jface.action。Action.notifyResult（boolean）了解详情。）</li>
<li><b>pluginId</b> - 包含操作类的Java类的插件的id。必须存在此属性。</li>
<li><b>paramN</b> - 对于也实现<code>org.eclipse.ui.cheatsheets.动作类<code>org.eclipse.ui.cheatsheets.ICheatSheetAction</code> ，属性<b>param1</b> ， <b>param2</b>到<b>param9</b>的字符串值在调用时传递给动作。您可以将最多9个参数传递给备忘单操作等。提供的参数必须以参数1开头并且是连续的;也就是说，在没有<b>param1</b>存在的情况下指定<b>param2</b>是违法的。如果属性字符串的格式为“$ { <i>var</i> }”，则认为它是对备忘单变量<i>var</i>的引用，条件的值将是在包含执行时的备忘单变量的值&lt;item&gt;元素（如果变量在那时未绑定，则为空字符串）。</li>
<li><b>确认</b> - 如果“true”表示此步骤（或子步骤）要求用户手动确认操作已完成。</li>
<li><b>when</b> - 表示当且仅当包含&lt;perform-when&gt;元素的condition属性的值与此字符串值匹配时才使用此操作。如果&lt;action&gt;元素不是&lt;perform-when&gt;元素的子元素，则忽略此属性。</li>
<li><b>required</b> - 如果“true”，则只能通过执行此操作来完成此项目或子项目（如果skip =“true”，它仍可能被跳过）。如果“false”将创建两个按钮，一个用于执行任务，另一个用于将其标记为完成，将完成此步骤或子步骤。</li>
<li><b>translate</b> - 以逗号分隔的可翻译参数列表。不在列表中的任何参数都被认为是不可翻译的。虽然此属性是可选的，但强烈建议将其提供给可能最终被翻译的任何作弊者。如果未指定此属性，则表示没有转换提示。
<br>例子：<br>
<code>translate = "param2, param3"</code>表示仅翻译param2和param3。
<br>
<code>translate = ""</code>表示不转换此操作的任何参数。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.command">命令</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令</p>
<p class="code SchemaDtdAttlist">序列化CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">返回CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">确认（true | false）“false”</p><p class="code SchemaDtdAttlist">当CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">required（true | false）“true”</p><p class="code SchemaDtdAttlist">翻译CDATA #IMPLIED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;command&gt;元素描述一个备忘单中的命令。
</p><p>下面是一个带有命令的项目示例，该命令打开一个对话框并将结果存储在备忘单变量“result”中。</p>
<pre class="Example"><span class="code SchemaTag">&lt;item title =</span> <span class="code SchemaCstring">“View Selection”</span> <span class="code SchemaTag">&gt; &lt;description&gt;选择将在下一步打开的视图。&lt;/ description&gt; &lt;command returns =</span> <span class="code SchemaCstring">“result”</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">“org.eclipse.ui.dialogs.openMessageDialog（title =选择View，buttonLabel0 = Package Explorer，message =选择一个视图，buttonLabel1 = Search View）“</span> <span class="code SchemaTag">/&gt; &lt;onCompletion&gt;选择$ {result}。 &lt;/ onCompletion&gt; &lt;/ item&gt;</span></pre></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>serialization</b> - 序列化的<a href="../api/org/eclipse/core/commands/ParameterizedCommand.html">ParameterizedCommand</a> ，它是一个包含命令名称和参数的字符串。有关此格式的完整详细信息，请参阅<a href="../api/org/eclipse/core/commands/ParameterizedCommand.html#serialize()">ParameterizedCommand.serialize（）</a>方法。</li>
<li><b>returns</b> - 一个可选属性，指定一个备忘单变量的名称，该变量将用于存储命令的返回值。这允许命令设置在稍后的&lt;perform-when&gt;，&lt;conditional-subitem&gt;或&lt;repeated-subitem&gt;中使用的备忘单变量。</li>
<li><b>确认</b> - 如果“true”表示此步骤（或子步骤）要求用户手动确认命令已完成。</li>
<li><b>when</b> - 表示当且仅当包含&lt;perform-when&gt;元素的condition属性的值与此字符串值匹配时才使用此命令。如果&lt;command&gt;元素不是&lt;perform-when&gt;元素的子元素，则忽略此属性。</li>
<li><b>required</b> - 如果“true”，则只能通过执行此命令来完成此项目或子项目（如果skip =“true”，它仍可能被跳过）。如果“false”将创建两个按钮，一个用于执行任务，另一个用于将其标记为完成，将完成此步骤或子步骤。</li>
<li><b>translate</b> - 以逗号分隔的可翻译参数列表。不在列表中的任何参数都被认为是不可翻译的。虽然此属性是可选的，但强烈建议将其提供给可能最终被翻译的任何作弊者。如果未指定此属性，则表示没有转换提示。
<br>例子：<br>
<code>translate = "param2, param3"</code>表示仅翻译param2和param3。
<br>
<code>translate = ""</code>表示不翻译此命令的任何参数。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.onCompletion">onCompletion</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">包含项目完成时将显示的文本。这在备忘单的最后一步中特别有用，以确认完成整个任务。该描述包含散布有<a href="../../../org.eclipse.platform.doc.isv/guide/forms_controls_text_markup.htm">表单文本标记</a>的<a href="../../../org.eclipse.platform.doc.isv/guide/forms_controls_text_markup.htm">文本，</a>遵循与&lt;description&gt;元素相同的规则。&lt;onCompletion&gt;元素还可以包含对“$ { <i>var</i> }”形式的备忘单变量的引用，该变量将在此步骤完成时使用备忘单变量<i>var</i>的实际值进行扩展。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.perform-when">perform-when</a> （ <a href="#e.action">动作</a> | <a href="#e.command">命令</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST表演时间</p>
<p class="code SchemaDtdAttlist">条件CDATA #REQUIRED</p>&gt;<p></p>
<div class="ConfigMarkupElementDesc">
<p>每个&lt;perform-when&gt;元素描述备忘单中的动作。
</p><p>&lt;conditional-subitem&gt;元素的<b>condition</b>属性提供了一个字符串值（总是这个值来自一个备忘单变量）。每个&lt;subitem&gt;子项都必须带有一个具有不同字符串值的<b>when</b>属性。展开项时，&lt;conditional-subitem&gt;元素将替换为具有匹配值的&lt;subitem&gt;元素。如果没有具有匹配值的&lt;subitem&gt;元素，则认为是错误。</p>
<p>例如，如果名称为“v1”的备忘单变量在展开以下项目时具有值“b”</p>
<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“Main step”</span> <span class="code SchemaTag">&gt; &lt;perform-when condition =</span> <span class="code SchemaCstring">“$ {v1}”</span> <span class="code SchemaTag">&gt; &lt;action when =</span> <span class="code SchemaCstring">“a”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.action1”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz “</span> <span class="code SchemaTag">/&gt; &lt;action when =</span> <span class="code SchemaCstring">”b“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.action2“</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">”com.xyz“</span> <span class="code SchemaTag">/&gt; &lt;command when =</span> <span class="code SchemaCstring">”c“</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">”org.eclipse.search.ui.views。SearchView“</span> <span class="code SchemaTag">/&gt; &lt;/ perform-when&gt; &lt;/ subitem&gt; &lt;/ item&gt;</span></pre>然后选择第二个动作，项目扩展到相当于的东西<pre class="Example"><span class="code SchemaTag">&lt;item ...&gt; &lt;subitem label =</span> <span class="code SchemaCstring">“Main step”</span> <span class="code SchemaTag">&gt; &lt;action class =</span> <span class="code SchemaCstring">“com.xyz.action2”</span> <span class="code SchemaTag">pluginId =</span> <span class="code SchemaCstring">“com.xyz”</span> <span class="code SchemaTag">/&gt; &lt;/</span> <span class="code SchemaCstring">subitem</span> <span class="code SchemaTag">&gt; &lt;/ item&gt;</span></pre></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>condition</b> - 用于选择将执行哪个子&lt;action&gt;或&lt;command&gt;的任意字符串值。如果属性字符串的格式为“$ { <i>var</i> }”，则认为它是对备忘单变量<i>var</i>的引用，条件的值将是在包含执行时的备忘单变量的值&lt;item&gt;元素（如果变量在那时未绑定，则为空字符串）。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>以下是一个简单的备忘单内容文件的示例，该文件演示了命令，执行时和条件子项的使用。</p>

<pre class="Example"><span class="code SchemaTag">&lt;？xml version =</span> <span class="code SchemaCstring">“1.0”</span> <span class="code SchemaTag">encoding =</span> <span class="code SchemaCstring">“UTF-8”</span> <span class="code SchemaTag">？&gt; &lt;cheatsheet title =</span> <span class="code SchemaCstring">“样品</span> <span class="code SchemaTag">备忘</span> <span class="code SchemaCstring">单”</span> <span class="code SchemaTag">&gt; &lt;intro&gt; &lt;description&gt;一个备忘单，演示了使用perform-when和条件子项&lt;/ description&gt; &lt;/ intro&gt; &lt;item title =</span> <span class="code SchemaCstring">“View Selection”</span> <span class="code SchemaTag">&gt; &lt;description &gt;选择将在以下步骤中打开的视图。&lt;/ description&gt; &lt;command returns =</span> <span class="code SchemaCstring">“result”</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">“org.eclipse.ui.dialogs.openMessageDialog（title = Select View，buttonLabel0 = Package Explorer，message = Select视图，buttonLabel1 =搜索视图）“</span> <span class="code SchemaTag">/&gt; &lt;onCompletion&gt;选择$ {result}。 &lt;/ onCompletion&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">“Close Views”</span> <span class="code SchemaTag">&gt; &lt;description&gt;关闭搜索视图和包浏览器，如果打开&lt;/ description&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">“打开视图中的执行时项目“</span> <span class="code SchemaTag">skip =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;description&gt;用于执行何时打开先前选择的视图。&lt;/ description&gt; &lt;perform-when condition =</span> <span class="code SchemaCstring">”$ {result}“</span> <span class="code SchemaTag">&gt; &lt;command when =</span> <span class="code SchemaCstring">”Package Explorer“</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">”org。 eclipse.ui.views.showView（org.eclipse.ui.views.showView.viewId = org.eclipse.jdt.ui。PackageExplorer）“</span> <span class="code SchemaTag">/&gt; &lt;command when =</span> <span class="code SchemaCstring">”Search View“</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">”org.eclipse.ui.views.showView（org.eclipse.ui.views.showView.viewId = org.eclipse.search.ui.views。SearchView）“</span> <span class="code SchemaTag">/&gt; &lt;/ perform-when&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">”Close Views“</span> <span class="code SchemaTag">&gt; &lt;description&gt;关闭搜索视图和打包浏览器，如果打开&lt;/ description&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">”打开当subitem“</span> <span class="code SchemaTag">&gt; &lt;description&gt;使用时执行的视图执行何时打开之前选择的视图。&lt;/ description&gt; &lt;subitem label =</span> <span class="code SchemaCstring">”子项时执行“</span> <span class="code SchemaTag">skip =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;perform-when condition =</span> <span class="code SchemaCstring">”$ {结果}“</span> <span class="code SchemaTag">&gt; &lt;command when =</span> <span class="code SchemaCstring">”Package Explorer“</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">”org.eclipse.jdt.ui。PackageExplorer“</span> <span class="code SchemaTag">/&gt; &lt;command when =</span> <span class="code SchemaCstring">”Search View“</span> <span class="code SchemaTag">serialization =</span> <span class="code SchemaCstring">”org.eclipse.search.ui.views。SearchView“</span> <span class="code SchemaTag">/&gt; &lt;/ perform-when&gt; &lt;/ subitem&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">”Close Views“</span> <span class="code SchemaTag">&gt; &lt;description&gt;关闭搜索视图和包浏览器，如果打开&lt;/ description&gt; &lt;/ item&gt; &lt;item title =</span> <span class="code SchemaCstring">“从条件子项打开视图”</span> <span class="code SchemaTag">&gt; &lt;description&gt;使用执行何时打开先前选择的视图。&lt;/ description&gt; &lt;conditional-subitem condition =</span> <span class="code SchemaCstring">“$ {result}”</span> <span class="code SchemaTag">&gt; &lt;subitem when =</span> <span class="code SchemaCstring">“Package Explorer”</span> <span class="code SchemaTag">标签=</span> <span class="code SchemaCstring">“打开包资源管理器。”</span> <span class="code SchemaTag">&gt; &lt;command serialization =</span> <span class="code SchemaCstring">“org.eclipse.jdt.ui。PackageExplorer“</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;subitem when =</span> <span class="code SchemaCstring">”Search View“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”Open Search View“</span> <span class="code SchemaTag">&gt; &lt;command serialization =</span> <span class="code SchemaCstring">”org.eclipse.search.ui.views。SearchView“</span> <span class="code SchemaTag">/&gt; &lt;/ subitem&gt; &lt;/ conditional-subitem&gt; &lt;/ item&gt; &lt;/ cheatsheet&gt;</span></pre>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2004,2007 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可在<a href="https://www.eclipse.org/legal/epl-2.0/">https://www.eclipse.org/legal/epl-2.0/</a> SPDX-License-Identifier：EPL获取。 -2.0</p>
</body>
</html><html id="0598.jet_tutorial1.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<title>JET教程第1部分（JET简介）</title>
<link rel="stylesheet" href="images/../../../css/book.css" type="text/css"></link>
<link rel="stylesheet" href="images/../../../css/emf-book.css" type="text/css"></link>
</head>

<body lang="EN-US" dir="ltr" xml:lang="EN-US">

<div align="right">©版权所有<a href="http://www.azzurri.co.jp">Azzurri Ltd.</a> 2003  -  2005。版权所有<table border="0" cellspacing="0" cellpadding="2" width="100%">

    <tr> 
      <td align="left" valign="top" colspan="2" bgcolor="#0080C0"><strong><font face="Arial,Helvetica"><font color="#FFFFFF">Eclipse Corner文章</font></font></strong></td>
    </tr>
  </table>
</div>
<div align="left"> 
  <h1><img src="http://www.eclipse.org/images/Idea.jpg" align="middle" width="120" height="86" alt=""></h1>
</div>

<h1 align="center">JET教程第1部分（JET简介）</h1>

<blockquote>
<strong>摘要</strong>

<br>
<p>生成源代码可以节省您的项目时间，并可以减少繁琐的冗余编程。生成源代码可能很强大，但编写代码的程序很快就会变得非常复杂且难以理解。降低复杂性和提高可读性的一种方法是使用模板。</p>
  <p>Eclipse Modeling Framework（ <a href="http://www.eclipse.org/emf/" target="_blank">EMF</a> ）项目包含两个非常强大的生成源代码的工具：JET（Java Emitter Templates）和JMerge（Java Merge）。使用JET，您可以使用类似JSP的语法（实际上是JSP语法的一个子集），这样可以轻松编写表达您要生成的代码的模板。JET是一个通用模板引擎，可用于从模板生成SQL，XML，Java源代码和其他输出。它位于org.eclipse.emf.codegen插件中，作为EMF运行时下载的一部分。</p>

  <p>在本文中，您将学习如何创建JET模板，如何使用JET Nature和JET Builder自动将模板转换为Java类，以及如何使用这些类生成源代码。本文还提供了对JET语法的简短参考。
  </p>
  <p>供稿人：Remko Popma，Azzurri Ltd.，remko.popma，azzurri dot jp，2003年7月30日。经许可使用。最后更新：2007年1月3日。</p>
</blockquote>

<hr width="100%">

<h2>内容</h2>
<p><a href="#introduction">入门</a><br>
<a href="#model">JET模型</a><br>
<a href="#directives">指令</a><br>
<a href="#scripting">JET脚本元素</a><br>
<a href="#resources">资源</a></p>

<h2><a name="introduction">入门</a></h2>
<p>在创建第一个模板之前，您需要EMF插件。如果尚未安装，请在继续本教程之前立即安装。</p>

  <p>屏幕截图基于Eclipse SDK的3.1.0 RC2版本和EMF版本2.1.0 I200506160200。但是，使用Java 5.0构造（例如Generics）的最低要求是Eclipse 3.3M4和EMF 2.3.0M4。</p>

<p>JET模板是一个文件名，文件名以“jet”结尾。我将按照EMF约定将“jet”附加到生成的代码的文件扩展名，因此<i>.javajet</i>意味着模板生成.java文件， <i>.xmljet</i>模板生成XML，生成SQL的模板具有<i>.sqljet</i>扩展等。</p>
<h3>JET Nature和JET Builder</h3>

<p>让我们遵循传统，从一个创建消息“Hello，world”的模板开始。我们将使用以下四个步骤创建我们的第一个模板：</p>
<ol>
  <li>创建一个新的Java项目并为其提供一个“ <i>src</i> ”源文件夹</li>
  <li>将JET Nature添加到项目中。这将在项目根目录下创建一个名为“ <i>templates</i> ”的文件夹</li>

  <li>更改项目的JET属性以确保将模板转换为项目的“ <i>src</i> ”源文件夹</li>
  <li>创建一个名为“ <i>helloworld.txtjet</i> ”的新文件并将其保存在<i>templates</i>文件夹中</li>

</ol>

<h4>步骤1。创建一个项目</h4>
<p>从工作台菜单中，选择“文件”&gt;“新建”&gt;“项目”以打开“新建项目”向导。创建一个新的Java项目并为其添加一个名为<i>src</i>的源文件夹。</p>

<p><img src="images/img001.gif" alt="带有src文件夹的新Java项目"></p>


<h4>第2步。将项目转换为JET项目</h4>
<p>创建项目后，在Package Explorer或Hierarchy视图中右键单击它，然后选择New&gt; Other ...&gt; Java Emitter Templates&gt;将项目转换为JET Projects。
</p>
  
<p><img src="images/img002.gif" alt="带有src文件夹的新Java项目"></p>

  <p>按“下一步”按钮后，选择您已创建的项目，然后单击“完成”。</p>

<p><img src="images/img003.gif" alt="将JET Nature添加到Java项目中"></p>

<p>该向导将JET Nature添加到项目中，在项目根目录下创建<i>模板</i>文件夹，如下图所示。此外，JET Builder将添加到项目中，该项目将自动将templates文件夹中的每个文件转换为以“jet”结尾的文件名到Java类。</p>

<p> <img src="images/img004.gif" alt="模板文件夹已创建"></p>

<h4>第3步。更改JET设置</h4>
<p>在创建第一个模板之前，让我们确保项目的<i>src</i>源文件夹是已翻译模板的目标文件夹。右键单击项目，然后从弹出菜单中选择“属性”。在“项目属性”对话框中，选择左侧菜单上的“JET设置”，然后在“源容器”文本字段中输入“src”（源文件夹的名称）。下图显示了“项目属性”对话框的“JET设置”属性页面。</p>

<p><img src="images/img005.gif" alt="添加源容器文件夹"></p>

<p> <em><img src="images/tip.gif" width="62" height="13" alt="小费：">注意：您可以在“模板容器”字段中指定多个文件夹，以空格或分号分隔。但是，如果不同文件夹中的模板具有相同的文件名，则JET Builder将仅自动翻译第一个文件夹中的模板。如果要翻译所有模板，请确保它们具有不同的文件名。</em></p>

<h4>第4步。创建JET模板文件</h4>

<p>JET构建器现在将所有模板转换为项目的<i>src</i>文件夹中的Java源文件。</p>
  
<p>首先，为避免构建问题，请关闭自动构建。从“项目”菜单中，取消选中“自动构建”。</p>

  <p><img src="images/img006.gif" alt="项目菜单显示“全部构建”和“自动构建”项"></p>现在我们创建第一个模板。从工作台菜单中，选择“文件”&gt;“新建”&gt;“文件”以打开“新建文件”向导。选择<i>templates</i>目录作为父文件夹，然后调用<i>helloworld.txtjet</i>文件。
  
<p><img src="images/img007.gif" alt="创建空helloworld.txtjet文件"></p>

<p>禁用“自动构建”时，按完成按钮时<em>不会</em>出现以下错误：“第1行第1列'helloworld.txtjet'中缺少'jet'指令”，如下图所示。</p>

<p><img src="images/img008.gif" alt="在空的.txtjet文件上运行JetBuilder时出错"></p>

<p>启用自动构建后，您将收到上述错误消息。幸运的是，这并不意味着存在真正的问题，只是JET Builder在创建模板时尝试翻译我们的模板，并发现它仍然是空的。按“确定”关闭错误对话框。如果未打开<i>helloworld.txtjet</i>文件，请打开该文件，然后在编辑器中键入或剪切并粘贴以下内容。</p>
<pre>
 <span class="highlight">&lt;％@ jet package =“hello”class =“HelloWorldTemplate”％&gt;</span>你好，世界！</pre>
<p>保存模板文件时，如果您选中“自动构建”，它将由JET Builder自动翻译。如果没有，请从“项目”菜单中选择“构建项目”。</p>
  
<p>因为我们在模板的第一行指定了包<i>hello</i>和类<i>HelloWorldTemplate</i> ，所以构建器在<i>src</i>文件夹中创建一个<i>hello</i>包，并在此包中保存一个Java文件<i>HelloWorldTemplate.java</i> ，如下图所示。</p>

<p> <img src="images/img009.gif" alt="包hello现在包含类文件HelloWorldTemplate.java"> 
</p>
<p>此Java类是转换模板的结果，称为<dfn>模板实现类</dfn> 。这个类有一个叫做<tt class="code">generate</tt>的方法。这是生成模板中指示的代码的方法。</p>
<p><img src="images/tryit.gif" width="61" height="13" alt="试试吧！">我们可以创建一个<tt class="code">HelloWorldTemplate</tt>模板实现类的实例，并调用它的<tt class="code">generate</tt>方法，如下所示：</p>

<p>要实现上述功能，请创建一个名为HelloWorldImpl的新类。在Package Explorer或Hierarchy视图中右键单击包hello，然后选择New&gt; Class。</p>

<p><img src="images/img010.gif" alt="创建新类"> </p>

<p>将类命名为“HelloWorldImpl”并确保选中public static void main（String [] args）存根。</p>

<p><img src="images/img011.gif" alt="使用main方法stub创建新的HelloWorldImpl类"> </p>

<p>现在将以下代码复制到main（）方法中：</p>

<pre>HelloWorldTemplate helloworld = new HelloWorldTemplate（）; String result = helloworld.generate（null）;的System.out.println（结果）;</pre>

<p><img src="images/img012.gif" alt="带有示例main方法的HelloWorldImpl类"> </p>

<p>要运行它，请从“运行”工具栏下拉列表中选择“运行方式/ Java应用程序”。你应该看到“Hello，world！“打印到控制台。</p>
<h3>将参数传递给模板</h3>
<p>回顾一下，我们刚刚创建了第一个模板并用它生成了一些代码。结果可能不是很令人印象深刻，但现在我们都已经建立起来，我们可以开始探索JET可以为您做些什么。下一步是将参数传递给模板。</p>
<p><img src="images/tryit.gif" width="61" height="13" alt="试试吧！">添加新的JET模板文件或将现有文件更改为以下内容：</p>
<pre>

 <span class="highlight">&lt;％@ jet package =“hello”class =“GreetingTemplate”％&gt;</span> Hello， <span class="highlight">&lt;％= argument％&gt;</span> ！
</pre>
<p>JET Builder将此模板转换为<tt class="code">hello</tt>包中的<tt class="code">GreetingTemplate</tt>类。我们再次创建此模板类的实例（或更改现有的HelloWorldImpl），但这次我们将一个字符串参数传递给<tt class="code">generate</tt>方法：</p>
<pre>GreetingTemplate sayHello = new GreetingTemplate（）; String result = sayHello.generate（“Tutorial Reader”）;的System.out.println（结果）;</pre>
<p>上面的代码将打印“Hello，Tutorial Reader！”“到控制台。
</p>
<h3>导入包</h3>
<p>传递给模板的参数可以是任何对象。在前面的示例中，我们将一个字符串作为参数传递给generate方法，但在您的应用程序中，您可能希望传入自己的模型对象。如果参数不在<tt class="code">java.lang</tt>包中，或者模板使用<tt class="code">java.lang</tt>包中没有的任何其他类，则需要在模板<tt class="code">jet</tt>指令中导入这些类。带有<tt class="code">喷气机的喷气机</tt>指令<img src="images/tag_1.gif" width="24" height="13" alt="标签1"> <i>imports</i>属性如下所示：</p>

<pre>&lt;％@ jet包=“你好” <strong><img src="images/tag_1.gif" width="24" height="13" alt="标签1"> imports =“java.util。*”</strong> class =“ImportDemoTemplate”％&gt;</pre>
<p>本文的JET语法参考部分提供了有关<tt class="code">jet</tt>指令及其属性的更多详细信息。</p>

<p>在下一个示例中，我们将创建一个生成XML代码的模板。为了坚持EMF约定将“jet”附加到生成的代码的文件扩展名，我们将此模板保存到名为<i>importdemo.xmljet</i>的文件中。请注意，我们将模板传递给<tt class="code">java.util。列出</tt>包含生成XML时要使用的数据的对象。</p>
<pre>
   <span class="highlight">&lt;％@ jet包=“你好” <img src="images/tag_1.gif" width="24" height="13" alt="标签1"> <strong>imports =“java.util。*”</strong> class =“XMLDemoTemplate”％&gt;</span> <span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> <strong class="highlight">&lt;％List &lt;？&gt; elementList =（List &lt;？&gt;）论点; ％&gt;</strong> &lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;demo&gt; <span class="highlight">&lt;％for（Iterator &lt;？&gt; i = elementList.iterator（）; i.hasNext（）; ）{％&gt;</span> &lt;element&gt; <span class="highlight">&lt;％= i.next（）。toString（）％&gt;</span> &lt;/ element&gt; <span class="highlight">&lt;％}％&gt;</span> &lt;/ demo&gt;</pre>
<p>下面的代码显示了如何调用模板实例。我们创造了一个<img src="images/tag_2.gif" width="24" height="13" alt="标签2">列表和<img src="images/tag_3.gif" width="24" height="13" alt="标签3">将它传递给模板实现类的<tt class="code">generate</tt>方法：</p>

<pre>包你好; import java.util。数组列表; public class XMLDemoImpl {public static void main（String [] args）{ <span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> List &lt;String&gt; data = new ArrayList &lt;String&gt;（）; data.add（ “第一”）; data.add（ “第二”）; data.add（ “第三”）; XMLDemoTemplate generateXml = new XMLDemoTemplate（）;字符串结果= generateXml.generate（ <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span>数据）;的System.out.println（结果）; }}</pre>
<p>这会将以下XML结果输出到控制台：</p>
<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;demo&gt; &lt;element&gt; first &lt;/ element&gt; &lt;element&gt; second &lt;/ element&gt; &lt;element&gt; third &lt;/ element&gt; &lt;/ demo&gt;</pre>
<p>这是一个非常简单的示例，可以创建非常简单的XML。当然，您可以使用JET来创建更复杂的XML，使用属性和命名空间。执行此操作时，您可能会发现创建一个比<tt class="code">java.util更好的XML文档模型的特殊类更方便<tt class="code">。ArrayList</tt> 。通常，JET模板越复杂，您希望将更多逻辑推送到传递给模板的模型对象中，以保持模板的可读性。我们将在本教程的第2部分中进一步探讨这一点。</p>
<h3>更改标签</h3>
<p>JET的一个优点是您可以更改标记模板文件中的scriptlet的标记。当您生成的代码的语法与默认的JET语法非常相似时，这非常方便，例如，如果您使用JET生成JSP页面。</p>
<p>在下一个示例中，我们将使用JET生成一个简单的JSP页面。我们将更改JET标记以使用“&lt;$”字符序列来启动模板标记，并使用“$&gt;”来结束模板标记。模板仍然包含“&lt;％”和“％&gt;”字符串，但JET引擎不再将它们视为特殊字符串，并且它们将像任何其他字符序列一样写入结果。</p>

<p></p>
<p> <img src="images/tryit.gif" width="61" height="13" alt="试试吧！">要更改标记标记，请添加<i><img src="images/tag_1.gif" width="24" height="13" alt="标签1"> startTag</i>和一个<i><img src="images/tag_2.gif" width="24" height="13" alt="标签2"> endTag</i>属性为模板第一行的JET指令，如下例所示。</p>
<pre>
 <span class="highlight">&lt;％@ jet package =“tags.demo”class =“JspTemplate” <img src="images/tag_1.gif" width="24" height="13" alt="标签1"> <strong>STARTTAG = “&lt;$” <img src="images/tag_2.gif" width="24" height="13" alt="标签2"> endTag =“$&gt;”</strong> ％&gt;</span> <strong><span class="highlight">&lt;$</span></strong> <span class="highlight">String paramName =（String）参数; / *这是一个执行的scriptlet * / <strong>$&gt;</strong></span> <strong><span class="highlight">&lt;$</span></strong> <span class="highlight">if（paramName！= null）{ <strong>$&gt;</strong></span> <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span> &lt;％= request.getParameter（“ <strong><span class="highlight">&lt;$ =</span></strong> <span class="highlight">paramName <strong>$&gt;</strong></span> ”）％&gt; &lt;！ - 这是生成的JSP  - &gt; <strong><span class="highlight">&lt;$</span></strong> <span class="highlight">} <strong>$&gt;</strong></span>
</pre>
<p>同样，我们使用字符串参数调用此实现类，如下所示：</p>
<pre>System.out.println（new tags.demo。。JspTemplate（）生成（ “链接”））;</pre>控制台上将显示以下输出。请注意，输出包含完整的JSP标记：“&lt;％”和“％&gt;”字符串不会被解释为JET scriptlet，而只是插入生成的代码中。

<pre>
 <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span> &lt;％= request.getParameter（“button”）％&gt; &lt;！ - 这是生成的JSP  - &gt;</pre>
<h1>在引擎盖下</h1>
<p>在上一节中，我们研究了如何创建JET模板，如何设置JET Nature以自动将模板转换为Java实现类，以及如何使用这些Java实现类来生成代码。
</p>
<p>在本节中，我们将仔细研究翻译模板的结果的Java实现类。我们将看到为什么我们可以在模板中使用隐式对象<tt class="code">参数</tt>和<tt class="code">stringBuffer</tt> ，还可以通过提供自定义“骨架”来查看自定义翻译的实现类。</p>

<h3>翻译的模板</h3>
<p>JET模板被转换为Java实现类。Java实现类中有一些对象可以直接在JET模板中引用。以下示例演示了如何在模板中使用隐式对象<tt class="code">参数</tt>和<tt class="code">stringBuffer</tt> 。</p>
<pre>
 <span class="highlight">&lt;％@ jet package =“hello”class =“TranslationDemoTemplate”％&gt;</span> <span><img src="images/tag_1.gif" width="24" height="13" alt="标签1"></span>您好， <span class="highlight">&lt;％= <strong>参数</strong> ％&gt;</span> ！
<span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> <span class="highlight">&lt;％ <strong>stringBuffer.append（“再次问好！“）;</strong> ％&gt;</span>
</pre>
<p>上面的模板被转换为Java实现类，如下所示：</p>
<pre>包你好; public class TranslationDemoTemplate {protected static String nl; <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span> public static synchronized TranslationDemoTemplate create（String lineSeparator）{nl = lineSeparator; TranslationDemoTemplate result = new TranslationDemoTemplate（）; nl = null;返回结果; } final final String NL = nl == null？（System.getProperties（）。getProperty（“line.separator”））：nl; protected final String TEXT_1 =“Hello，”; protected final String TEXT_2 =“！“; public String generate（Object <strong>argument</strong> ）{StringBuffer <strong>stringBuffer</strong> = new StringBuffer（）; stringBuffer.append（TEXT_1）; <span><img src="images/tag_1.gif" width="24" height="13" alt="标签1"></span> stringBuffer.append（ <strong>argument</strong> ）;的StringBuffer.append（文本_2）; <span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> <strong>stringBuffer.append（“再次问好！“）;</strong> return stringBuffer.toString（）;}}</pre>
<p>请注意，Java实现类的<tt class="code">generate</tt>方法采用名为<tt class="code">argument</tt>的<tt class="code">Object</tt>参数。这是与之相同的对象<tt class="code"><img src="images/tag_1.gif" width="24" height="13" alt="标签1"></tt>模板第二行中的<tt class="code">参数</tt> 。另外，请注意Java实现类如何使用<tt class="code">StringBuffer</tt>对象来收集生成的代码。这个对象可以<img src="images/tag_2.gif" width="24" height="13" alt="标签2">通过名称<tt class="code">stringBuffer</tt>直接在模板中<tt class="code">引用</tt> 。</p>
<p>静态方法<tt class="code"><img src="images/tag_3.gif" width="24" height="13" alt="标签3"> create</tt>允许应用程序实例化使用特定字符串作为行分隔符的<tt class="code">TranslationDemoTemplate</tt> 。</p>

<h3>改变翻译实现类的骨架</h3>
<p>上面的<tt class="code">TranslationDemoTemplate</tt>类的<tt class="code">generate</tt>方法被认为是实现类“skeleton”的一部分。JET引擎使用的默认框架如下所示：</p>
<pre>public class CLASS {public String generate（Object argument）{return“”; }}</pre>
<p>除了类名之外，框架定义看起来几乎像普通的Java类。类名（ <tt class="code">CLASS</tt> ）将替换为<tt class="code">jet</tt>指令中<i>class</i>属性的值。此外，骨架定义具有我们之前看到的<tt class="code">生成</tt>方法。通过更改骨架，您可以自定义模板实现类，例如使其实现接口，或更改类的任何其他功能。</p>
<p> <img src="images/tryit.gif" width="61" height="13" alt="试试吧！">例如，假设您希望所有模板实现类都实现一个接口。界面看起来像这样：</p>

<pre>public interface IGenerator {String generate（Object argument）; }</pre>
<p>我们可以通过在模板文件的第一行设置<tt class="code">jet</tt>指令的<i>skeleton</i>属性来告诉JET引擎我们想要使用自定义框架。skeleton属性的值是一个URI，指向可以找到自定义框架定义的文件。</p>
<p>要尝试此操作，请首先从“文件”&gt;“新建”菜单或工具栏创建一个新的无标题文本文件。</p> 

  <p><img src="images/img013.gif" alt="从文件 - 新菜单创建新的无标题文本文件"></p>

<p>打开类型或剪切并粘贴其中的以下内容：</p>
<pre>公共课CLASS <span><img src="images/tag_1.gif" width="24" height="13" alt="标签1"></span>实现IGenerator { <span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> / *（非javadoc）* @see IGenerator＃generate（Object）* / <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span> public String generate（Object argument）{return“”; }}</pre>

<p>现在将此文件保存为templates目录中的<i>generator.skeleton</i> ，如下图所示。</p>
  <p><img src="images/img014.gif" alt="模板文件夹中的文本文件generator.skeleton"></p>

<p>这个文件是我们的自定义骨架。使用此框架的所有模板都将转换为实现<tt class="code">IGenerator</tt>接口的类。要使用此骨架，请将属性<i>框架</i>添加到模板的<tt class="code">jet</tt>指令中，如下所示：</p>

<pre>
 <span class="highlight">&lt;％@ jet package =“hello”class =“GreetingTemplate” <strong>skeleton =“generator.skeleton”</strong> ％&gt;</span> Hello， <span class="highlight">&lt;％= argument％&gt;</span> ！当前时间是<span class="highlight">&lt;％= new java.util。日期（）％&gt;</span> 。

</pre>
<p>在JET Builder转换模板之后，实现类如下所示：</p>
<pre>包你好;公共课GreetingTemplate <span><img src="images/tag_1.gif" width="24" height="13" alt="标签1"></span>实现IGenerator {protected final String NL = System.getProperties（）。getProperty（“line.separator”）; protected final String TEXT_1 =“Hello，”; protected final String TEXT_2 =“！“+ NL +”当前时间为“; protected final String TEXT_3 =”。“; protected final String TEXT_4 = NL; <span><img src="images/tag_2.gif" width="24" height="13" alt="标签2"></span> / *（非javadoc）* @see IGenerator＃generate（Object）* / <span><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></span> public String generate（Object argument）{StringBuffer stringBuffer = new StringBuffer（）;的StringBuffer.append（文字_1）;的StringBuffer.append（参数）;的StringBuffer.append（文本_2）; stringBuffer.append（new java.util。日期（））;的StringBuffer.append（TEXT_3）;的StringBuffer.append（TEXT_4）; return stringBuffer.toString（）; }}</pre>
<p>请注意现在翻译的模板<img src="images/tag_1.gif" width="24" height="13" alt="标签1">实现<tt class="code">IGenerator</tt>接口，以及<tt class="code"><img src="images/tag_3.gif" width="24" height="13" alt="标签3"></tt>现在<tt class="code">生成</tt>方法了<img src="images/tag_2.gif" width="24" height="13" alt="标签2">我们在<i>generator.skeleton</i>文件中指定的注释。这是如何使用骨架定义自定义翻译模板的一个示例。骨架定义还可以包含额外的方法，内部类等。您需要进行一些实验，看看还有什么是可能的。</p>
<h1>JET语法参考</h1>

<p>如果您之前使用过JSP技术，那么JET语法可能对您来说非常熟悉。JET语法是JSP语法的一个子集，因此这里可能没有太多新的东西。</p>
<p>本节提供了JET语法的半正式描述和参考。
</p>
<h2><a name="model">JET模型</a></h2>
<p>JET模板被转换为Java实现类。此实现类有一个方法可以调用以获取结果字符串。此方法通常称为<tt class="code">generate</tt> （另请参见<tt class="code">jet</tt>指令的<i>skeleton</i>属性）。</p>

<p>如果在<tt class="code">jet</tt>伪指令中没有指定<i>skeleton</i>属性，则Java实现类具有以下隐式对象，可以在JET模板中引用它们：</p>
<ul>
  <li> <strong>stringBuffer</strong> <tt class="code">java.lang。StringBuffer</tt>对象，用于在调用<tt class="code">generate</tt>方法时构建结果字符串</li>

  <li> <strong>参数</strong> <tt class="code">java.lang。传递给<tt class="code">generate</tt>方法的对象</tt></li>
</ul>

<h2><a name="directives">指令</a></h2>

<p>指令是发往JET引擎的消息。指令具有以下语法：</p><p>
<i>&lt;％@ directive {attr =“value”} *％&gt;</i> 
</p><p>“&lt;％@”之后和“％&gt;”之前可能有可选的空格。
</p><p>指令会影响模板的转换方式，但在调用模板时不会在生成的String中生成任何输出。
</p>

<h3>喷射指令</h3>
<p><tt class="code">jet</tt>指令定义了许多属性并将它们传递给JET引擎。JET模板文件必须在文件的第一行包含<tt class="code">jet</tt>指令，否则无法转换模板文件。任何后续的<tt class="code">喷射</tt>指令都会被忽略。无法识别的属性会导致致命的翻译错误。</p>
<p>以下指令指示应将模板转换为包<i>hello中</i>名为<i>HelloWorldTemplate.java</i>的Java实现类。实现类应该导入java.io. *和java.util。*包。</p>

<pre>&lt;％@ jet package =“hello”class =“HelloWorldTemplate”imports =“java.io. * java.util。*”％&gt;</pre>
<p><tt class="code">jet</tt>指令属性的详细信息如下：</p>
<table border="1" cellpadding="3" cellspacing="0">
  <tr>
    <th>属性</th>
    <th>值</th>
  </tr>
  <tr>
    <td valign="top">包</td>

    <td>模板转换为的Java实现类的包名称。如果此属性不存在，则在默认包中创建Java实现类。</td>
  </tr>
  <tr>
    <td height="40" valign="top">类</td>
    <td height="40">模板转换为的Java实现类的类名。如果不存在，则Java实现类称为<tt class="code">CLASS</tt> 。</td>
  </tr>

  <tr>
    <td valign="top">进口</td>
    <td>要在Java模板类中导入的以空格分隔的包和/或类的列表</td>
  </tr>
  <tr>
    <td valign="top">STARTTAG</td>
    <td>JET模板中的字符串，用于表示scriptlet，expression或<tt class="code">include</tt>指令的开头。默认值为“&lt;％”。当生成的代码的语法类似于默认的JET语法时，此属性及其表兄<i>endTag</i>非常方便，例如，如果您使用JET生成JSP页面。</td>

  </tr>
  <tr>
    <td valign="top">ENDTAG</td>
    <td>JET模板中的字符串，表示scriptlet，表达式或<tt class="code">include</tt>指令的结束。默认值为“％&gt;”。另见<i>startTag</i> 。</td>

  </tr>
  <tr>
    <td valign="top">骨架</td>
    <td>具有模板转换为的Java实现类的框架定义的文件的URI。将解析此URI，类似于在<tt class="code">include</tt>指令中解析<i>文件</i>属性值的方式。如果未指定框架定义文件，则JET引擎将使用“ <tt class="code">public class CLASS \ n {\ n public String generate（Object argument）\ n {\ n return \”\“; \ n}</tt>形式的默认框架<tt class="code">n} \ n</tt> “。此骨架类定义中的类名必须为<tt class="code">CLASS</tt> 。</td>

  </tr>
  <tr>
    <td valign="top">nlString</td>
    <td>要在Java模板类中使用的换行符字符串。默认值为“System.getProperties（）。getProperty（\”line.separator \“）”</td>
  </tr>
</table>

<h3>包含指令</h3>
<p><tt class="code">include</tt>伪指令用于在模板转换时替换文本和/或代码。<tt class="code">&lt;％@ include file =“urlSpec”％&gt;</tt>指令将指定资源的文本插入到jet模板文件中。包含的文件可能具有JET脚本元素，这些元素也将被处理。
</p>
<p>该指令只有一个属性<i>file</i> 。此属性的值是要包括的文件的位置的URI。此URI可以是绝对路径或相对路径。相对URI始终被解释为相对于包含include指令的模板的文件夹。</p>

<p>例：</p>
<p>以下示例请求在翻译时包含版权文件。</p>
<pre>&lt;％@ include file =“copyright.jet”％&gt;</pre>
<p><em><img src="images/tip.gif" width="62" height="13" alt="小费：">注意：JET支持覆盖模板路径的概念。可以将JET引擎配置为使用多个模板容器。在这种情况下，第一个容器优先于第二个容器，第二个容器优先于第三个容器，依此类推。这意味着如果多个模板容器中存在模板文件或包含相同文件名的文件，则将使用第一个文件夹中的文件，而忽略其他文件。基于JET的应用程序的客户端可以使用此机制来提供覆盖原始包含文件的自定义包含文件，而无需修改原始应用程序的模板。</em><br>
</p>
<h2><a name="scripting">JET脚本元素</a></h2>

<p>JET有两个脚本语言元素：scriptlet和表达式。scriptlet是一个语句片段，一个表达式是一个完整的Java表达式。
</p><p>每个脚本元素都有一个基于“&lt;％”的语法，如下所示：</p>
<pre>&lt;％这是一个scriptlet％&gt; &lt;％=这是一个表达式％&gt;</pre>
<p>在“&lt;％”和“&lt;％=”之后，以及“％&gt;”之前，空格是可选的。
</p><p>如果要在scriptlet中使用％&gt;字符序列作为文字字符，而不是结束scriptlet，可以通过键入％\&gt;来转义它们。同样，&lt;％字符序列可以使用&lt;\％进行转义。
</p>
<h3>小脚本</h3>
<p>Scriptlet可以包含任何有效的Java代码片段。</p>
<p>Scriptlet在模板调用时执行。它们是否在结果字符串中产生任何输出取决于scriptlet中的实际代码。Scriptlet可以有副作用，修改它们中可见的对象。</p>

<p>当给定转换单元中的所有scriptlet片段按它们在JET模板中出现的顺序组合时，它们应该生成有效的Java语句或语句序列。</p>例：<pre>&lt;％if（Calendar.getInstance（）。get（日历。AM_PM）==日历。AM）{％&gt;早安&lt;％}否则{％&gt;下午好&lt;％}％&gt;</pre>

<h4>句法</h4>
<p> <i>&lt;％scriptlet％&gt;</i> </p>
<h3>表达式</h3>
<p>JET表达式元素是一个Java表达式，它被计算并将结果附加到<tt class="code">generate</tt>方法返回的<tt class="code">StringBuffer</tt>对象。表达式在模板调用时进行评估。</p>

<p>如果表达式的结果无法附加到<tt class="code">StringBuffer，</tt>则会发生转换时间错误。JET表达式的内容必须是完整的Java表达式。</p>
<p>支持表达式中的副作用。它们在评估JET表达式时生效。JET表达式在JET模板中从左到右进行计算。</p>
<p>在下一个示例中，当前日期将附加到<tt class="code">StringBuffer</tt>结果中。</p>
<pre>&lt;％=（new java.util。Date（））。toLocaleString（）％&gt;</pre>

<h4>句法</h4>
<p><i>&lt;％=表达式％&gt;</i> </p>
<h2><a name="resources">资源</a></h2>
<p><a href="http://www.javaworld.com/javaworld/jw-11-2001/jw-1102-codegen.html" target="_blank">http://www.javaworld.com/javaworld/jw-11-2001/jw-1102-codegen.html</a> 
</p>
<p> <a href="http://www.eclipse.org/emf/" target="_blank">http://www.eclipse.org/emf/</a> 
</p>
<br>
</body>

</html><html id="2255.sB.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="sB">
            <div class="headl">
               <div class="headr">
                  <h1>§B版本之间的变化</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sB.html">§B版本之间的变化</a></li>
                  <li><a href="#sB.1">§B.1版本之间的段落发生了变化</a></li>
                  <li><a href="#sB.2">§B.2版本之间的增加</a></li>
               </ul>
            </div>
            <div class="sect depth2" id="sB.1">
               <h2 class="sect">§B.1版本之间的段落发生了变化<a class="img" href="sB.1.html" title="PermaLinkto§B.1版本之间的段落发生了变化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.1.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.1.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s3.2.a.html" title="§3.2。（a）with clause" class="sect">§3.2。（a）</a> ： <strong>参数映射</strong><p>禁止角色接口中的参数映射。
                           			
                        </p>
                     </li>
                     <li><a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ： <strong>替换绑定</strong><p>禁止不安全地使用多态和原始类型转换。
                           			
                        </p>
                     </li>
                     <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法的签名</strong><p>使两个方法通用，以便可以使用返回值而无需进行转换。
                           				
                        </p>
                     </li>
                     <li><a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ：受<strong>限制的角色</strong><p>改进的解释。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.1.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.1.e.html" title="§1.2.1。（e）角色特征" class="sect">§1.2.1。（e）</a> ： <strong>角色特征的可见性</strong><p>添加了澄清说明角色可以始终访问其封闭团队有权访问的所有功能。
                           				
                        </p>
                     </li>
                     <li><a href="s2.1.2.e.html" title="§2.1.2。（e）没有自由类型参数" class="sect">§2.1.2。（e）</a> ： <strong>通用角色/基础</strong><p>放宽了有关通用绑定角色的规则。这种变化也包含了先前在<a href="s4.1.b.html" title="§4.1.(b) Prerequisite: Class binding" class="sect">§4.1中</a>的具体限制<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">。（b）</a> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.i.html" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a>和<a href="s3.5.f.html" title="§3.5。（f）速记定义" class="sect">§3.5。（f）</a> ： <strong>速记标注的可见性</strong><p>由速记标注绑定定义的角色方法现在可以指定可见性修饰符（另请参见<a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ），否则它将继承其绑定基本方法/字段的可见性修饰符。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断标注的可见性</strong><p>推断为标注绑定的角色方法是<code>public</code> （通过接口推断）或从自我调用/字段访问推断的<code>private</code> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>没有明确使用推断的字段</strong><p>已添加澄清说明，无法显式调用为推断的字段调用生成的访问器方法。
                           				
                        </p>
                     </li>
                     <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>没有通用角色的callin</strong><p>已经明确规定，通用角色无法定义callin绑定。
                           				
                        </p>
                     </li>
                     <li><a href="s4.2.d.html" title="§4.2。（d）Callin方法" class="sect">§4.2。（d）</a> ： <strong>Callin方法</strong><p>稍微改写并扩展规则以明确表示使用第二级callin绑定确实可以拦截callin方法。
                           				
                        </p>
                     </li>
                     <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法<code>getAllRoles</code></strong><p>更高精度：仅回答<em>绑定</em>角色。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.1.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字的语法</strong><p>以前，不支持语法<code>R&lt;@t&gt;.class</code> 。此限制已被删除。
                           					
                        </p>
                     </li>
                     <li><a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ： <strong>团队扩展非团队类</strong><p>以前， <code>org.objectteams.Team</code>是所有团队课程的超级班级。因此，团队无法扩展非团队类。通过引入所有团队的新超类型，界面<code>org.objectteams. ，已经消除了这一限制<code>org.objectteams.ITeam</code> 。当成员被移动到新界面时，此更改也会影响<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中的</a>某些段落。
                           					
                        </p>
                     </li>
                     <li><a href="s1.5.e.html" title="§1.5。（e）不同超级之间的优先权" class="sect">§1.5。（e）</a> ： <strong>不同隐式超级之间的优先权</strong><p>纠正了不同超级中优先级规则的不一致性：主要规则一直是隐式继承比显式继承更强，但是，对于不同隐式超级中的优先级，定义了不同的规则。<br>这已被改变，使得不同的隐<em>式</em>超级优先于其封闭团队的优先级，使得来自<em>隐式</em>超级团队的角色与来自<em>显式</em>超级团队的角色更紧密相关。
                           					
                        </p>
                     </li>
                     <li><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）</a> ： <strong>放宽了对基类循环的规则</strong><p><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）中</a>定义的基类循环不再是错误，而是可配置警告。但是，在存在基类循环的情况下，不允许调用（第<a href="s2.4.2.html" title="§2.4.2 Role creation via a regular constructor" class="sect">3.1节</a> <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">（a）</a> ）和基本构造函数调用（第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2节</a> ）。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ： <strong>更改了角色绑定歧义的处理</strong><p>明确的绑定歧义不再是（可抑制的）编译器错误，而是由声明<code>org.objectteams.的需要发出信号<code>org.objectteams.LiftingFailedException</code> 。通过这种方式，诊断可以从团队中非常不特定的位置移动到那些在运行时可能因提升失败而受到影响的应用程序。虽然通常不建议忽略任何<code>LiftingFailedException</code>但在<a href="s2.3.4.b.html" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4。（b）中</a>提到的一些<a href="s2.3.4.b.html" title="§2.3.4。（b）明确的歧义" class="sect">极端</a>情况下，捕获此异常仍然有意义。
                           					
                        </p>
                     </li>
                     <li><a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ： <strong>进一步限制callin绑定后的结果映射</strong><p>澄清<code>after</code> callin绑定<code>after</code>无法使用<code>-&gt;</code>标记来映射结果值。
                           					
                        </p>
                     </li>
                     <li><a href="s4.8.a.html" title="§4.8。（a）优先权声明" class="sect">§4.8。（a）</a> ： <strong>影响callin绑定<code>after</code>优先声明。</strong><p>虽然以前优先声明的效果不明确，但已经定义优先声明中元素的顺序会影响它们的<em>优先级，</em>类似于<a href="s5.1.html" title="§5.1团队激活的影响" class="sect">§5.1</a> 。这意味着与先前的实现相比， <code>after</code>绑定的执行顺序现在是颠倒的。为了在程序中可视化，现在必须使用关键字<code>after</code>标记后绑定的优先声明。
                           					
                        </p>
                     </li>
                     <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ， <a href="s4.10.a.html" title="§4.10。（a）新鲜型参数" class="sect">§4.10。（a）</a> ： <strong>通用的callin绑定</strong><p><a href="s4.10.e.html" title="§4.10.(e) Propagating type parameters" class="sect">稍作</a>修改，为新段落<a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）留出</a>空间。
                        </p>
                     </li>
                     <li><a href="s5.4.1.a.html" title="§5.4.1。（a）方法绑定警卫" class="sect">§5.4.1。（a）</a> ： <strong>定期装订守卫的范围</strong><p>在常规方法绑定防护中删除了关于特殊标识符<code>result</code>的错误句子。由于在评估保护之前应用了参数映射，因此可以通过结果映射（ <a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ）访问结果值。此外，这句话实际上混淆了基础和角色方面。
                           	
                        </p>
                     </li>
                     <li><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ， <a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="sect">§A.3.3</a> ： <strong>语法：泛型方法绑定</strong><p>方法绑定中可能的类型参数的位置已经明确。</p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.4">
                  <h4 class="subsect">（4） <span class="title">在OTJLD 1.3和OTJLD 1.4之间</span><a class="img" href="sB.1.4.html" title="PermaLink to（4）OTJLD 1.3和OTJLD 1.4之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ： <strong>没有按需基础进口</strong><p>已经澄清，基础进口不能是按需进口（使用通配符） <code>.*</code> ）。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="sB.2">
               <h2 class="sect">§B.2版本之间的增加<a class="img" href="sB.2.html" title="PermaLinkto§B.2版本之间的增加"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.2.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.2.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字</strong><p>使现有功能显式化并为外化角色引入新的限定类文字。
                           				
                        </p>
                     </li>
                     <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断出的标注</strong><p>新功能。
                           				
                        </p>
                     </li>
                     <li><a href="s4.6.a.html" title="§4.6。（a）超级班的私人方法" class="sect">§4.6。（a）</a> ： <strong>来自超级类的Callin绑定私有方法</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                     <li><a href="s4.9.html" title="§4.9Callin继承" class="sect">§4.9</a> ： <strong>Callin继承</strong><p>澄清了指定不充分或解释不充分的问题，具体而言：</p>
                        <ul>
                           <li>callin绑定对遗传或被覆盖的基本方法的影响（ <a href="s4.9.1.html" title="§4.9.1基础侧继承" class="sect">§4.9.1</a> ）。
                           </li>
                           <li>callin绑定和基本方法与协变返回类型的<a href="s4.9.3.html" title="§4.9.3 Covariant return types" class="sect">相互作用</a> （ <a href="s4.9.3.html" title="§4.9.3协变返回类型" class="sect">§4.9.3</a> ）</li>
                        </ul>
                     </li>
                     <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ： <strong>通用替换绑定</strong><p>通过使用类型参数调整<a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）中</a>引入的替换绑定的类型安全性，并具有所需的灵活性。
                           				
                        </p>
                     </li>
                     <li><a href="s7.2.b.html" title="§7.2。（b）受限阵列" class="sect">§7.2。（b）</a> ： <strong>受限制的阵列</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.2.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.2.2.h.html" title="§1.2.2。（h）外化创作" class="sect">§1.2.2。（h）</a> ： <strong>外化创作</strong><p>使用值参数和更改的标题添加了替代语法。</p>
                     </li>
                     <li><a href="s1.2.5.f.html" title="§1.2.5。（f）进口角色档案" class="sect">§1.2.5。（f）</a> ： <strong>角色文件中的导入</strong><p>添加了缺少的规则，用于定义角色文件中的导入效果。</p>
                     </li>
                     <li><a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">§1.3.1。（c）</a> ： <strong>@</strong> <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">Override</a> <strong>角色注释</strong><p>常规的<code>@Override</code>注释（Java≥5）也已扩展为适用于角色类。
					
                        </p>
                     </li>
                     <li><a href="s1.3.1.k.html" title="§1.3.1。（k）协变返回类型" class="sect">§1.3.1。（k）</a> ： <strong>协变返回类型</strong><p>在存在隐式和显式继承的情况下协变返回类型的必要约束。
                           					
                        </p>
                     </li>
                     <li><a href="s2.1.2.c.html" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ： <strong>绑定到最终基类</strong><p>已经补充说，绑定到最终基类现在也被视为解封装。
                           					
                        </p>
                     </li>
                     <li><a href="s2.2.f.html" title="§2.2。（f）模糊降低" class="sect">§2.2。（f）</a> ： <strong>模糊降低</strong><p>添加了一个诊断来检测可能意图降低但由于声明的类型是<code>java.lang.而失败的情况<code>java.lang.Object</code> ，这使得潜在的降低翻译变得不必要并且因此是模糊的。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.2.e.html" title="§2.3.2。（e）通用宣布解除" class="sect">§2.3.2。（e）</a> ： <strong>通用声明提升</strong><p>支持将不相关的基类型传递到声明提升的相同方法中。
                           					
                        </p>
                     </li>
                     <li><a href="s2.6.g.html" title="§2.6。（g）通过基准参考进行解封装" class="sect">§2.6。（g）</a> ： <strong>通过基准参考进行解封装</strong><p>将解封装扩展到两个以上的位置。
                           					
                        </p>
                     </li>
                     <li><a href="s4.3.f.html" title="§4.3。（f）基本超级电话" class="sect">§4.3。（f）</a> ： <strong>基本超级呼叫</strong><p>支持base直接调用绑定基本方法的超级版本，从而绕过精确绑定的基本方法以及与此基本方法或其超级版本相关的任何其他callins。
                           					
                        </p>
                     </li>
                     <li><a href="s5.4.b.html" title="§5.4。（b）无副作用" class="sect">§5.4。（b）</a> ： <strong>守卫谓词的副作用</strong><p>将有关未来功能的先前注释迁移到常规段落。</p>
                     </li>
                     <li><a href="s5.4.c.html" title="§5.4。（c）例外情况" class="sect">§5.4。（c）</a> ： <strong>守卫谓词的例外情况</strong><p>澄清从保护谓词抛出的异常的影响。</p>
                     </li>
                     <li><strong>§6.2</strong> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ： <strong>LiftingVetoException</strong><p>添加了大部分内部<code>LiftingVetoException</code>文档以及它如何在客户端代码中实际使用。
                           				    
                        </p>
                     </li>
                     <li><a href="s6.2.e.html" title="§6.2。（e）角色迁移" class="sect">§6.2。（e）</a> ： <strong>角色迁移</strong><p>添加了两个接口，以将迁移功能添加到角色类。
                           				    
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.2.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a> ：将<strong>角色绑定到基接口</strong><p><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a>中提到的实施限制已被大部分删除。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.1.d.html" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> ： <strong>微调角色实例化</strong><p>已经定义了注释用于修改提升的语义以便提高性能。此外，还添加了一个新的部分作为<a href="s6.3.html" title="§6.3注释" class="sect">§6.3，</a>以总结本文档中定义的注释类型。
                           					
                        </p>
                     </li>
                     <li><a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ： <strong>解除问题的后果</strong><p>在<a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a>澄清了<code>LiftingFailedException</code> （ <code>LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）确实是一个经过检查的异常之后，又添加了一个子节来定义这种异常在各种程序情况下的后果。
                           					
                        </p>
                     </li>
                     <li><a href="s3.1.k.html" title="§3.1。（k）通用方法的标注" class="sect">§3.1。（k）</a> ： <strong>通用方法的标注</strong><p>添加了关于callout绑定如何引用泛型基本方法的规则。
                           					
                        </p>
                     </li>
                     <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>Callin以“不可授予的”角色进行约束</strong><p>现在甚至可以在“unliftable”角色中定义Callin绑定。
                           	
                        </p>
                     </li>
                     <li><a href="s4.1.h.html" title="§4.1。（h）封闭类的方法" class="sect">§4.1。（h）</a> ： <strong>绑定团队方法</strong><p>callin绑定<code>before</code>和<code>after</code>现在也可以绑定到封闭类的方法。
                           	
                        </p>
                     </li>
                     <li><a href="s4.8.d.html" title="§4.8。（d）多个优先权陈述" class="sect">§4.8。（d）</a> ： <strong>合并优先声明时的顺序</strong><p>阐明了如何合并多个优先级声明，这是未指定的，因为C3算法需要有序输入，但未指定此顺序。
                           					
                        </p>
                     </li>
                     <li><a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ： <strong>在callin绑定中传播类型参数</strong><p>除了捕获协变返回类型之外，callin绑定还可以声明类型参数，以便将通用性从其基本方法传播到角色方法。
                           	
                        </p>
                     </li>
                     <li><a href="s5.3.d.html" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> ： <strong>配置隐式激活</strong><p>添加了用于配置隐式团队激活的机制。默认值已更改为不应用隐式激活。<a href="s5.3.html" title="§5.3隐式团队激活" class="sect">§5.3中</a>也增加了相应的注释</p>
                     </li>
                     <li><a href="s9.2.1.a.html" title="§9.2.1。（a）实例约束类型参数" class="sect">§9.2.1。（a）</a> ： <strong>实例约束类型参数</strong><p>类型锚现在也可以应用于类型参数，从而在类型参数上表达一种新的约束。
                           	
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.4">
                  <h4 class="subsect">（4） <span class="title">OTJLD 1.3之后</span><a class="img" href="sB.2.4.html" title="PermaLink至（4）OTJLD 1.3之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s4.1.i.html" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ： <strong>致电建设者</strong><p>绑定后的callin现在也可以应用于基类的构造函数。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html><html id="3349.Developer-Guide.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass开发人员指南</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">Trace Compass开发人员指南</th>
			</tr>
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Introduction.html" title="介绍">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">介绍</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Table_of_Contents">目录</h1>
		<ol style="list-style:none">
			<li>
				<a href="#Table_of_Contents">目录</a>
			</li>
			<li>
				<a href="Introduction.html#Introduction">介绍</a>
			</li>
			<li>
				<a href="Implementing-a-New-Trace-Type.html#Implementing_a_New_Trace_Type">实现新的跟踪类型</a>
				<ol style="list-style:none">
					<li>
						<a href="Implementing-a-New-Trace-Type.html#Event_Aspects">事件方面</a>
						<ol style="list-style:none">
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Base_and_custom_aspects">基础和自定义方面</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Creating_event_aspects_programmatically">以编程方式创建事件方面</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Implementing-a-New-Trace-Type.html#Optional_Trace_Type_Attributes">可选的跟踪类型属性</a>
						<ol style="list-style:none">
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Default_Editor">默认编辑器</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Events_Table_Type">事件表类型</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Perspective">透视</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Implementing-a-New-Trace-Type.html#Other_Considerations">其他考虑因素</a>
						<ol style="list-style:none">
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Collapsing_of_repetitive_events">折叠重复事件</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Implementing-a-New-Trace-Type.html#Best_Practices">最佳实践</a>
					</li>
					<li>
						<a href="Implementing-a-New-Trace-Type.html#An_Example:_Nexus-lite_parser">示例：Nexus-lite解析器</a>
						<ol style="list-style:none">
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Description_of_the_file">文件描述</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#NexusLite_Plug-in">NexusLite插件</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Trace_Event">跟踪事件</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Trace_Reader">跟踪阅读器</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Trace_Context">跟踪上下文</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#Trace_Location">跟踪位置</a>
							</li>
							<li>
								<a href="Implementing-a-New-Trace-Type.html#The_.27.27org.eclipse.linuxtools.tmf.core.tracetype.27.27_and_.27.27org.eclipse.linuxtools.tmf.ui.tracetypeui.27.27_plug-in_extension_points">''org.eclipse.linuxtools.tmf.core.tracetype''和''org.eclipse.linuxtools.tmf.ui.tracetypeui''插件扩展点</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="View-Tutorial.html#View_Tutorial">查看教程</a>
				<ol style="list-style:none">
					<li>
						<a href="View-Tutorial.html#Prerequisites">先决条件</a>
					</li>
					<li>
						<a href="View-Tutorial.html#Creating_an_Eclipse_UI_Plug-in">创建Eclipse UI插件</a>
					</li>
					<li>
						<a href="View-Tutorial.html#Creating_a_View">创建视图</a>
					</li>
					<li>
						<a href="View-Tutorial.html#Implementing_a_view">实现视图</a>
						<ol style="list-style:none">
							<li>
								<a href="View-Tutorial.html#Adding_an_Empty_Chart">添加空图表</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Signal_Handling">信号处理</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Requesting_Data">请求数据</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Transferring_Data_to_the_Chart">将数据传输到图表</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Adjusting_the_Range">调整范围</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Formatting_the_Time_Stamps">格式化时间戳</a>
							</li>
							<li>
								<a href="View-Tutorial.html#Pin_feature">引脚功能</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="View-Tutorial.html#TMF_Built-in_Views_and_Viewers">TMF内置视图和查看器</a>
					</li>
					<li>
						<a href="View-Tutorial.html#Timing_Analysis_Views_and_Viewers">时序分析视图和查看器</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Component-Interaction.html#Component_Interaction">组件交互</a>
				<ol style="list-style:none">
					<li>
						<a href="Component-Interaction.html#Sending_Signals">发送信号</a>
					</li>
					<li>
						<a href="Component-Interaction.html#Receiving_Signals">接收信号</a>
					</li>
					<li>
						<a href="Component-Interaction.html#Signal_Throttling">信号限制</a>
					</li>
					<li>
						<a href="Component-Interaction.html#Ignoring_inbound.2Foutbound_signals">忽略入站/出站信号</a>
					</li>
					<li>
						<a href="Component-Interaction.html#Signal_Reference">信号参考</a>
						<ol style="list-style:none">
							<li>
								<a href="Component-Interaction.html#TmfStartSynchSignal">TmfStartSynchSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfEndSynchSignal">TmfEndSynchSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceOpenedSignal">TmfTraceOpenedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceSelectedSignal">TmfTraceSelectedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceClosedSignal">TmfTraceClosedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceRangeUpdatedSignal">TmfTraceRangeUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceUpdatedSignal">TmfTraceUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfSelectionRangeUpdatedSignal">TmfSelectionRangeUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfWindowRangeUpdatedSignal">TmfWindowRangeUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfEventFilterAppliedSignal">TmfEventFilterAppliedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfEventSearchAppliedSignal">TmfEventSearchAppliedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTimestampFormatUpdateSignal">TmfTimestampFormatUpdateSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfStatsUpdatedSignal">TmfStatsUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfPacketStreamSelected">TmfPacketStreamSelected</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfStartAnalysisSignal">TmfStartAnalysisSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfCpuSelectedSignal">TmfCpuSelectedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfThreadSelectedSignal">TmfThreadSelectedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfSymbolProviderUpdatedSignal">TmfSymbolProviderUpdatedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfTraceSynchronizedSignal">TmfTraceSynchronizedSignal</a>
							</li>
							<li>
								<a href="Component-Interaction.html#TmfMarkerEventSourceUpdatedSignal">TmfMarkerEventSourceUpdatedSignal</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Component-Interaction.html#Debugging">调试</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Generic-State-System.html#Generic_State_System">通用国家制度</a>
				<ol style="list-style:none">
					<li>
						<a href="Generic-State-System.html#Introduction_2">介绍</a>
					</li>
					<li>
						<a href="Generic-State-System.html#High-level_components">高级组件</a>
					</li>
					<li>
						<a href="Generic-State-System.html#Definitions">定义</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#Attribute">属性</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Attribute_Tree">属性树</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Quark">夸克</a>
							</li>
							<li>
								<a href="Generic-State-System.html#State_value">国家价值</a>
							</li>
							<li>
								<a href="Generic-State-System.html#State_change">国家变化</a>
							</li>
							<li>
								<a href="Generic-State-System.html#State_interval">状态间隔</a>
							</li>
							<li>
								<a href="Generic-State-System.html#State_history">国家历史</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Construction_phase">施工阶段</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Queries">查询</a>
								<ol style="list-style:none">
									<li>
										<a href="Generic-State-System.html#Full_queries">完整查询</a>
									</li>
									<li>
										<a href="Generic-State-System.html#Single_queries">单个查询</a>
									</li>
									<li>
										<a href="Generic-State-System.html#2D_queries">2D查询</a>
									</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
						<a href="Generic-State-System.html#Relevant_interfaces.2Fclasses">相关接口/类</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#Main_classes_in_org.eclipse.tracecompass.tmf.core.statesystem">org.eclipse.tracecompass.tmf.core.statesystem中的主要类</a>
								<ol style="list-style:none">
									<li>
										<a href="Generic-State-System.html#ITmfStateProvider_.2F_AbstractTmfStateProvider">ITmfStateProvider / AbstractTmfStateProvider</a>
									</li>
									<li>
										<a href="Generic-State-System.html#TmfStateSystemFactory">TmfStateSystemFactory</a>
									</li>
									<li>
										<a href="Generic-State-System.html#ITmfStateSystem">ITmfStateSystem</a>
										<ol style="list-style:none">
											<li>
												<a href="Generic-State-System.html#getQuarkAbsolute.28.29.2FgetQuarkRelative.28.29">getQuarkAbsolute（）/ getQuarkRelative（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#optQuarkAbsolute.28.29.2FoptQuarkRelative.28.29">optQuarkAbsolute（）/ optQuarkRelative（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#getQuarks.28.29">getQuarks（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#waitUntilBuilt.28.29">waitUntilBuilt（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#queryFullState.28.29">queryFullState（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#querySingleState.28.29">querySingleState（）</a>
											</li>
										</ol>
									</li>
									<li>
										<a href="Generic-State-System.html#ITmfStateSystemBuilder">ITmfStateSystemBuilder</a>
										<ol style="list-style:none">
											<li>
												<a href="Generic-State-System.html#getQuark*AndAdd.28.29">getQuark * AndAdd（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#modifyAttribute.28.29">modifyAttribute（）</a>
											</li>
											<li>
												<a href="Generic-State-System.html#closeHistory.28.29">closeHistory（）</a>
											</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
								<a href="Generic-State-System.html#Other_relevant_interfaces">其他相关接口</a>
								<ol style="list-style:none">
									<li>
										<a href="Generic-State-System.html#ITmfStateValue">ITmfStateValue</a>
									</li>
									<li>
										<a href="Generic-State-System.html#ITmfStateInterval">ITmfStateInterval</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Generic-State-System.html#Exceptions">例外</a>
								<ol style="list-style:none">
									<li>
										<a href="Generic-State-System.html#AttributeNotFoundException">AttributeNotFoundException</a>
									</li>
									<li>
										<a href="Generic-State-System.html#StateValueTypeException">StateValueTypeException</a>
									</li>
									<li>
										<a href="Generic-State-System.html#TimeRangeException">TimeRangeException</a>
									</li>
									<li>
										<a href="Generic-State-System.html#StateSystemDisposedException">StateSystemDisposedException</a>
									</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
						<a href="Generic-State-System.html#Comparison_of_state_system_backends">国家系统后端的比较</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#Full_history">完整的历史</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Null_history">空的历史</a>
							</li>
							<li>
								<a href="Generic-State-System.html#In-memory_history">记忆中的历史</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Partial_history">部分历史</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Generic-State-System.html#State_System_Operations">国家系统运作</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#queryRangeMax.28.29">queryRangeMax（）</a>
							</li>
							<li>
								<a href="Generic-State-System.html#queryRangeMin.28.29">queryRangeMin（）</a>
							</li>
							<li>
								<a href="Generic-State-System.html#queryRangeAverage.28.29">queryRangeAverage（）</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Generic-State-System.html#Code_example">代码示例</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#State_Provider">国家提供者</a>
							</li>
							<li>
								<a href="Generic-State-System.html#Analysis_module_definition">分析模块定义</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Generic-State-System.html#Mipmap_feature">Mipmap功能</a>
						<ol style="list-style:none">
							<li>
								<a href="Generic-State-System.html#AbstractTmfMipmapStateProvider">AbstractTmfMipmapStateProvider</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="UML2-Sequence-Diagram-Framework.html#UML2_Sequence_Diagram_Framework">UML2序列图框架</a>
				<ol style="list-style:none">
					<li>
						<a href="UML2-Sequence-Diagram-Framework.html#TMF_UML2_Sequence_Diagram_Extensions">TMF UML2序列图扩展</a>
					</li>
					<li>
						<a href="UML2-Sequence-Diagram-Framework.html#Management_of_the_Extension_Point">扩展点的管理</a>
					</li>
					<li>
						<a href="UML2-Sequence-Diagram-Framework.html#Sequence_Diagram_View">序列图视图</a>
						<ol style="list-style:none">
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Supported_Widgets">支持的小部件</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Zooming">缩放</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Printing">印花</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Key_Bindings">关键绑定</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Preferences">喜好</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Callback_hooks">回调挂钩</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="UML2-Sequence-Diagram-Framework.html#Tutorial">教程</a>
						<ol style="list-style:none">
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Prerequisites_2">先决条件</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Creating_an_Eclipse_UI_Plug-in_2">创建Eclipse UI插件</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Creating_a_Sequence_Diagram_View">创建序列图视图</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Defining_the_uml2SDLoader_Extension">定义uml2SDLoader扩展</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Implementing_the_Loader_Class">实现Loader类</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Adding_time_information">添加时间信息</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Default_Coolbar_and_Menu_Items">默认的Coolbar和菜单项</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Implementing_Optional_Callbacks">实现可选的回调</a>
								<ol style="list-style:none">
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Paging_Provider_Interface">使用分页提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Find_Provider_Interface">使用查找提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Filter_Provider_Interface">使用过滤器提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Extended_Action_Bar_Provider_Interface">使用扩展操作栏提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Properties_Provider_Interface">使用属性提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Collapse_Provider_Interface">使用折叠提供程序接口</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Using_the_Selection_Provider_Service">使用选择提供程序服务</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Printing_a_Sequence_Diagram">打印序列图</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Using_one_Sequence_Diagram_View_with_Multiple_Loaders">使用一个序列图视图与多个加载器</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Downloading_the_Tutorial">下载教程</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="UML2-Sequence-Diagram-Framework.html#Integration_of_Tracing_and_Monitoring_Framework_with_Sequence_Diagram_Framework">跟踪和监控框架与序列图框架的集成</a>
						<ol style="list-style:none">
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Reference_Implementation">参考实施</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Used_Sequence_Diagram_Features">使用的序列图功能</a>
								<ol style="list-style:none">
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Advanced_paging">高级分页</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Basic_finding">基本发现</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Basic_filtering">基本过滤</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#Selection_Service">选择服务</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Used_TMF_Features">使用的TMF功能</a>
								<ol style="list-style:none">
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#TMF_Experiment_and_Trace_for_accessing_traces">用于访问跟踪的TMF实验和跟踪</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#TMF_Event_Request_Framework">TMF事件请求框架</a>
									</li>
									<li>
										<a href="UML2-Sequence-Diagram-Framework.html#TMF_Signal_Framework">TMF信号框架</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Supported_Traces">支持的跟踪</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Trace_Format">跟踪格式</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#How_to_use_the_Reference_Implementation">如何使用参考实施</a>
							</li>
							<li>
								<a href="UML2-Sequence-Diagram-Framework.html#Extending_the_Reference_Loader">扩展Reference Loader</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="CTF-Parser.html#CTF_Parser">CTF Parser</a>
				<ol style="list-style:none">
					<li>
						<a href="CTF-Parser.html#CTF_Format">CTF格式</a>
						<ol style="list-style:none">
							<li>
								<a href="CTF-Parser.html#Metadata">元数据</a>
							</li>
							<li>
								<a href="CTF-Parser.html#Event_Streams">事件流</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="CTF-Parser.html#Reading_a_trace">阅读踪迹</a>
					</li>
					<li>
						<a href="CTF-Parser.html#Seeking_in_a_trace">寻求一丝</a>
					</li>
					<li>
						<a href="CTF-Parser.html#Interfacing_to_TMF">连接到TMF</a>
						<ol style="list-style:none">
							<li>
								<a href="CTF-Parser.html#CtfLocation">CtfLocation</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfTmfTrace">CtfTmfTrace</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfIterator">CtfIterator</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfIteratorManager">CtfIteratorManager</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfTmfContext">CtfTmfContext</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfTmfTimestamp">CtfTmfTimestamp</a>
							</li>
							<li>
								<a href="CTF-Parser.html#CtfTmfEvent">CtfTmfEvent</a>
							</li>
							<li>
								<a href="CTF-Parser.html#Other">其他</a>
							</li>
							<li>
								<a href="CTF-Parser.html#Limitations">限制</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="Event-matching-and-trace-synchronization.html#Event_matching_and_trace_synchronization">事件匹配和跟踪同步</a>
				<ol style="list-style:none">
					<li>
						<a href="Event-matching-and-trace-synchronization.html#Event_matching_interfaces">事件匹配接口</a>
					</li>
					<li>
						<a href="Event-matching-and-trace-synchronization.html#Implementation_details_and_how_to_extend_it">实现细节以及如何扩展它</a>
						<ol style="list-style:none">
							<li>
								<a href="Event-matching-and-trace-synchronization.html#ITmfEventMatching_interface_and_derived_classes">ITmfEventMatching接口和派生类</a>
							</li>
							<li>
								<a href="Event-matching-and-trace-synchronization.html#ITmfMatchEventDefinition_interface_and_its_derived_classes">ITmfMatchEventDefinition接口及其派生类</a>
							</li>
							<li>
								<a href="Event-matching-and-trace-synchronization.html#IMatchProcessingUnit_interface_and_derived_classes">IMatchProcessingUnit接口和派生类</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Event-matching-and-trace-synchronization.html#Code_examples">代码示例</a>
						<ol style="list-style:none">
							<li>
								<a href="Event-matching-and-trace-synchronization.html#Using_network_packets_matching_in_an_analysis">在分析中使用网络数据包匹配</a>
							</li>
							<li>
								<a href="Event-matching-and-trace-synchronization.html#Match_events_from_UST_traces">匹配来自UST痕迹的事件</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Event-matching-and-trace-synchronization.html#Trace_synchronization">跟踪同步</a>
						<ol style="list-style:none">
							<li>
								<a href="Event-matching-and-trace-synchronization.html#Synchronization_algorithm">同步算法</a>
							</li>
							<li>
								<a href="Event-matching-and-trace-synchronization.html#Timestamp_transforms">时间戳转换</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Event-matching-and-trace-synchronization.html#Todo">去做</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Analysis-Framework.html#Analysis_Framework">分析框架</a>
				<ol style="list-style:none">
					<li>
						<a href="Analysis-Framework.html#Creating_a_new_module">创建一个新模块</a>
						<ol style="list-style:none">
							<li>
								<a href="Analysis-Framework.html#Example">例</a>
							</li>
							<li>
								<a href="Analysis-Framework.html#Available_base_analysis_classes_and_interfaces">可用的基本分析类和接口</a>
							</li>
							<li>
								<a href="Analysis-Framework.html#How_it_works">这个怎么运作</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Analysis-Framework.html#Telling_TMF_about_the_analysis_module">告诉TMF关于分析模块</a>
					</li>
					<li>
						<a href="Analysis-Framework.html#Attaching_outputs_and_views_to_the_analysis_module">将输出和视图附加到分析模块</a>
						<ol style="list-style:none">
							<li>
								<a href="Analysis-Framework.html#Using_the_extension_point_to_add_outputs">使用扩展点添加输出</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Analysis-Framework.html#Providing_help_for_the_module">为模块提供帮助</a>
					</li>
					<li>
						<a href="Analysis-Framework.html#Using_analysis_parameter_providers">使用分析参数提供者</a>
						<ol style="list-style:none">
							<li>
								<a href="Analysis-Framework.html#Example_parameter_provider">示例参数提供程序</a>
							</li>
							<li>
								<a href="Analysis-Framework.html#Register_the_parameter_provider_to_the_analysis">将参数提供程序注册到分析中</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Analysis-Framework.html#Providing_requirements_to_analyses">提供分析要求</a>
						<ol style="list-style:none">
							<li>
								<a href="Analysis-Framework.html#Analysis_requirement_provider_API">分析需求提供者API</a>
							</li>
							<li>
								<a href="Analysis-Framework.html#Requirement_values">要求价值</a>
							</li>
							<li>
								<a href="Analysis-Framework.html#Example_of_providing_requirements">提供要求的示例</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Analysis-Framework.html#TODO">去做</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="TMF-Remote-API.html#TMF_Remote_API">TMF远程API</a>
				<ol style="list-style:none">
					<li>
						<a href="TMF-Remote-API.html#Prerequisites_3">先决条件</a>
					</li>
					<li>
						<a href="TMF-Remote-API.html#TmfRemoteConnectionFactory">TmfRemoteConnectionFactory</a>
						<ol style="list-style:none">
							<li>
								<a href="TMF-Remote-API.html#Accessing_the_remote_services_manager_.28OSGI_service.29">访问远程服务管理器（OSGI服务）</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Obtaining_a_IRemoteConnection">获取IRemoteConnection</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Creating_an_IRemoteConnection_instance">创建IRemoteConnection实例</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Providing_a_connection_factory">提供连接工厂</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="TMF-Remote-API.html#RemoteSystemProxy">RemoteSystemProxy</a>
						<ol style="list-style:none">
							<li>
								<a href="TMF-Remote-API.html#Creating_a_RemoteSystemProxy">创建RemoteSystemProxy</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Opening_the_remote_connection">打开远程连接</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Closing_the_remote_connection">关闭远程连接</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Disposing_the_remote_connection">处理远程连接</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Checking_the_connection_state">检查连接状态</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Retrieving_the_IRemoteConnection_instance">检索IRemoteConnection实例</a>
							</li>
							<li>
								<a href="TMF-Remote-API.html#Obtaining_a_command_shell">获取命令shell</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="Performance-Tests.html#Performance_Tests">性能测试</a>
				<ol style="list-style:none">
					<li>
						<a href="Performance-Tests.html#Add_performance_tests">添加性能测试</a>
						<ol style="list-style:none">
							<li>
								<a href="Performance-Tests.html#Where">哪里</a>
							</li>
							<li>
								<a href="Performance-Tests.html#How">怎么样</a>
							</li>
							<li>
								<a href="Performance-Tests.html#Run_a_performance_test">运行性能测试</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Performance-Tests.html#ABC_of_performance_testing">性能测试的ABC</a>
						<ol style="list-style:none">
							<li>
								<a href="Performance-Tests.html#Determine_what_to_test">确定要测试的内容</a>
							</li>
							<li>
								<a href="Performance-Tests.html#Metrics_descriptions_and_considerations">度量标准描述和注意事项</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="Network-Tracing.html#Network_Tracing">网络追踪</a>
				<ol style="list-style:none">
					<li>
						<a href="Network-Tracing.html#Adding_a_protocol">添加协议</a>
						<ol style="list-style:none">
							<li>
								<a href="Network-Tracing.html#Architecture">建筑</a>
							</li>
							<li>
								<a href="Network-Tracing.html#UDP_Packet_Structure">UDP数据包结构</a>
							</li>
							<li>
								<a href="Network-Tracing.html#Creating_the_UDPPacket">创建UDPPacket</a>
							</li>
							<li>
								<a href="Network-Tracing.html#Creating_the_UDPEndpoint">创建UDPEndpoint</a>
							</li>
							<li>
								<a href="Network-Tracing.html#Registering_the_UDP_protocol">注册UDP协议</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Network-Tracing.html#Adding_stream-based_views">添加基于流的视图</a>
					</li>
					<li>
						<a href="Network-Tracing.html#TODO_2">去做</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Markers.html#Markers">标记</a>
				<ol style="list-style:none">
					<li>
						<a href="Markers.html#Trace-specific_markers">跟踪特异性标记</a>
					</li>
					<li>
						<a href="Markers.html#View-specific_markers">视图特定标记</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Virtual-Machine-Analysis.html#Virtual_Machine_Analysis">虚拟机分析</a>
			</li>
			<li>
				<a href="JUL-Logging.html#JUL_Logging">JUL记录</a>
				<ol style="list-style:none">
					<li>
						<a href="JUL-Logging.html#Use_a_static_logger_for_each_class">为每个类使用静态记录器</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Use_a_message_supplier">使用消息供应商</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Choose_the_appropriate_log_level">选择适当的日志级别</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Log_message_format">记录消息格式</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Logging_to_populate_Callstacks_and_Callgraph_analyses">记录以填充Callstacks和Callgraph分析</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Logging_to_track_Object_life_cycles">记录以跟踪对象生命周期</a>
					</li>
					<li>
						<a href="JUL-Logging.html#Logging_to_track_Asynchronous_operations">记录以跟踪异步操作</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="XML-schema-extension.html#XML_schema_extension">XML架构扩展</a>
				<ol style="list-style:none">
					<li>
						<a href="XML-schema-extension.html#Extending_the_schema">扩展架构</a>
					</li>
					<li>
						<a href="XML-schema-extension.html#Parsing_the_schema">解析模式</a>
					</li>
					<li>
						<a href="XML-schema-extension.html#Adding_the_extension_point">添加扩展点</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="OS-Execution-Graph-Extension.html#OS_Execution_Graph_Extension">OS执行图扩展</a>
				<ol style="list-style:none">
					<li>
						<a href="OS-Execution-Graph-Extension.html#Write_the_graph_extension">写下图表扩展名</a>
					</li>
					<li>
						<a href="OS-Execution-Graph-Extension.html#Adding_the_extension_point_2">添加扩展点</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Data-Providers.html#Data_Providers">数据提供商</a>
				<ol style="list-style:none">
					<li>
						<a href="Data-Providers.html#Data_provider_types">数据提供者类型</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-Providers.html#Tree_XY">树XY</a>
							</li>
							<li>
								<a href="Data-Providers.html#Time_Graph">时间图</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Data-Providers.html#Data_provider_management">数据提供者管理</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-Providers.html#Extension_point">延伸点</a>
							</li>
							<li>
								<a href="Data-Providers.html#Experiments">实验</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Data-Providers.html#Utilities">公用事业</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-Providers.html#Example_Tree_XY_code">示例树XY代码</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Introduction.html" title="介绍">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">介绍</td>
			</tr>
		</table>
	</body>
</html><html id="3339.Modeling Project.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>建模项目</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="ModelingProjectsandRepresentations">建模项目和表示</h1>
		<p>在本文档中，您将学习如何创建和管理建模项目，这些项目在Sirius中用于组织模型及其表示（图表，表格等）。</p>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#ModelingProjectsandRepresentations">建模项目和表示</a>
				<ol style="list-style:disc">
					<li>
						<a href="#Introduction">介绍</a>
					</li>
					<li>
						<a href="#FormerUsers">对先前版本的用户的注意</a>
						<ol style="list-style:disc">
							<li>
								<a href="#Migration">迁移现有的表示文件</a>
							</li>
							<li>
								<a href="#UICHanges">用户界面更改</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#ModelingPerspective">建模视角</a>
						<ol style="list-style:disc">
							<li>
								<a href="#ModelExplorer">Model Explorer视图</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#MP">建模项目</a>
						<ol style="list-style:disc">
							<li>
								<a href="#MPCreation">创建一个新的建模项目</a>
							</li>
							<li>
								<a href="#MPConversion">将现有项目转换为建模项目</a>
							</li>
							<li>
								<a href="#MPConversionReverse">从项目中删除建模性质</a>
							</li>
							<li>
								<a href="#ViewpointSelection">选择要启用的视点</a>
							</li>
							<li>
								<a href="#ProjectDependencies">项目依赖性</a>
							</li>
							<li>
								<a href="#ModelsInMP">建模项目中的模型</a>
							</li>
							<li>
								<a href="#ModelActions">模型元素可用的操作</a>
							</li>
							<li>
								<a href="#AirdFiles">表示文件</a>
							</li>
							<li>
								<a href="#AirdStructure">_Representations文件_的结构</a>
							</li>
							<li>
								<a href="#repair">修复动作</a>
							</li>
							<li>
								<a href="#MPConstraints">约束</a>
							</li>
							<li>
								<a href="#Lifecycle">建模项目生命周期</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#Representations">交涉</a>
						<ol style="list-style:disc">
							<li>
								<a href="#ReprCreation">创建表示</a>
							</li>
							<li>
								<a href="#ReprManagement">管理表示</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#LegacyMode">遗留模式</a>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="Introduction">介绍</h2>
		<p>Sirius系统用于使用称为<em>建模</em>器的交互式编辑器创建，可视化和编辑<em>模型</em> 。这些建模器可以是不同类型的，具体取决于可视表示的类型。开箱即用，Sirius支持三种不同的<em>方言</em> （各种表示） <em>图</em> （图形建模器）， <em>表</em>和<em>树</em> （层次表示）。可以通过编程添加新方言。
		</p>
		<p>提供了正确的配置文件（简称为<em>Viewpoint规范模型</em>或<em>VSM</em> ），Sirius可以代表任何与EMF兼容的模型（Eclipse世界中建模工具的事实标准）。这包括UML，SysML，TOGAF等标准，以及您可以创建的任何<em>域特定模型</em> （ <em>DSM</em> ），以更好地满足您的特定需求。对于一种模型（例如，用于描述企业架构的TOGAF），可以创建几个Sirius配置，每个配置特定于特定<em>视点</em> 。因此，不同类型的用户可以通过不同的观点看到相同的模型，每个观点都适应他的关注点：从同一个TOGAF模型中， <acronym title="首席执行官">CEO</acronym>将希望看到公司如何组织的一般概述， <acronym title="首席运营官">首席运营官</acronym>可能希望视图更加面向对于流程，系统管理员需要仅查看与软件系统相关的部分以实现这些流程。
		</p>
		<p>Sirius使建筑师可以轻松创建适用于任何类型模型的<em>Viewpoint规范</em>模型。然后将它们打包为Eclipse插件，您可以安装它们以使用它们的建模器。请注意，还必须安装Sirius本身才能运行视点（它们不能自给自足）。
		</p>
		<p>作为最终用户，您将使用已经配置的建模器，专门根据您的需求进行调整。如果要创建自己的建模器，请参阅<a href="../../specifier/Sirius Specifier Manual.html">Sirius说明手册</a> 。简单的建模器不需要任何编程来创建，一旦您了解了基础知识，就可以在不到一个小时的时间内从头开始创建新的图形建模器。
		</p>
		<p>要使用现有的建模器（假设安装了提供它们的插件），您需要知道以下概念（另请参阅<a href="../../Glossary.html">词汇表</a> ）：</p>
		<ul>
			<li><em>资源</em>是包含模型的文件（在工作区中或插件内）;</li>
			<li><em>语义模型</em>是包含业务数据的模型（或模型）。它可以存储在可以相互引用的多个资源（文件）之一中。每个用户的语义模型类型可以不同。它可以基于标准（例如UML模型的<code>.uml</code>文件）或基于<em>特定</em>于您的需求创建的<em>域特定模型</em> （有时称为<em>域特定语言</em> ）。
			</li>
			<li><em>方言</em>是天狼星支持的一种表达方式。开箱即用，Sirius支持三种方言：图表，表格和树木。序列图和交叉表（它们是特殊类型的图表（分别表）也可以被视为方言，尽管从技术上讲它们不是。
			</li>
			<li><em>表示</em>是您在语义模型上创建的特定图表，表或树。它只是一个比“图”更通用的术语，也可用于其他方言。
			</li>
			<li><em>表示文件</em>是一个文件，其中Sirius存储与您创建的表示，它们上显示的内容，元素的位置和颜色等相关的所有信息。此文件具有<code>.aird</code>扩展名（通常为<code>representations.aird</code> ）。表示文件引用它们包含的语义模型表示，但您的语义模型不会发现（和未受污染）任何Sirius特定的数据。
			</li>
			<li><em>视点</em>是一组表示描述，它提供了某种语义模型的特定观点。例如，我们可以有一个<em>UML Structural</em>视点，它描述了所有标准UML图的子集，它只处理UML模型的结构方面（与行为或需求方面相对）。视点在<em>Viewpoint Specification Models</em>中定义并打包为Eclipse插件。一旦安装了这样的插件，它所定义的视点将可用于所有兼容的语义模型（包括它们定义的所有表示）。
			</li>
			<li><em>建模项目</em>是工作区中的一种特殊项目，可以以一致的方式轻松操作表示文件和语义模型。
			</li>
		</ul>
		<p>本文档的其余部分介绍了如何使用Sirius UI创建和操作语义模型的表示。每个观点和表示都是具体的。我们将使用<em>Family</em>示例进行说明，但请注意，并非所有特征都适用于所有类型的模型和所有视点。
		</p>
		<h2 id="FormerUsers">对先前版本的用户的注意</h2>
		<p>新用户可以安全地跳过此部分。对于具有现有模型的先前版本的用户，本节介绍了将此模型与此版本一起使用所需的步骤，并概述了主要的UI更改。有关更多详细信息，另请参阅<a href="../../Release_Notes.html">发行说明</a> 。
		</p>
		<h3 id="Migration">迁移现有的表示文件</h3>
		<p>默认情况下，表示和设计文件现在会在打开时自动迁移。此迁移对最终用户是透明的。虽然未保存表示文件，但将在下次打开时重播自动迁移。</p>
		<p>迁移完成后，您可以激活要求保存资源的首选项。它可以在Sirius首选项页面中找到：</p> 
		<img border="0" src="images/migrationPreference.png">
		<p>选中后，如果需要迁移，则在以下情况下会显示一个要求您保存迁移资源的对话框：</p>
		<ul>
			<li>当您打开或展开尚未加载的建模项目时。</li>
			<li>通过双击aird或VSM或<em>打开</em>上下文菜单<em>打开</em>会话。
			</li>
			<li>当您打开捆绑包时，先前打开了Sirius编辑器。</li>
		</ul>
		<p>此操作的副作用是您的模型在以前版本的产品中无法打开。因此，如果您仍希望能够在之前的版本中打开它，则应备份模型。</p>
		<h3 id="UICHanges">用户界面更改</h3>
		<p>您会注意到用户界面发生了一些根本性的变化。最重要的变化是<em>模型内容</em>视图的消失。它已被替换为简化的UI，它直接集成到Eclipse资源管理器视图中。“本地会话”的概念已从用户界面中消失;它的管理尽可能透明，除非在某些非常具体的情况下，否则你不必处理它。
		</p>
		<p>现在使用Sirius的推荐方法是使用下面描述的<em>Modeling Project</em>的新概念。如果您已有现有的Sirius表示文件（ <code>aird</code>文件），则需要进行<a href="#MPConversion">转换</a> 。建模项目对文件的组织方式有一些限制。如果您不希望或不能将模型转换为新推荐的方式，则提供<a href="#LegacyMode">遗留模式</a> ，不需要对项目组织进行任何更改（除了文件迁移之外）。请注意，不保证在所有未来版本的Sirius中都能保留对此传统模式的支持。
		</p>
		<h2 id="ModelingPerspective">建模视角</h2>
		<p>当您第一次启动Sirius时，它会在<em>Modeling</em>透视图中打开。这个新视角提供了所有必需的视图，向导和菜单，可以将设计人员作为最终用户。
		</p> 
		<img border="0" src="images/modeling_perspective.png">
		<p>Modeling透视图默认提供以下视图：</p>
		<ul>
			<li><a href="#ModelExplorer"><em>模型资源管理器</em></a> ，它是与模型交互的主要UI。（对于以前版本的用户，此资源管理器直接包含之前在“模型内容”视图中找到的所有功能）。
			</li>
			<li>“ <em>大纲”</em>视图，提供当前打开的文档或模型的结构概述。对于图表，它显示了整个图表的微缩视图，您可以在其中轻松导航到大图的其他部分。
			</li>
			<li>“ <em>属性”</em>视图提供有关当前所选元素的详细信息。根据所选元素的性质，可以直接在“ <em>属性”</em>视图中编辑其中一些<em>属性，</em>并立即生效。
			</li>
			<li>“ <em>问题”</em>视图包含不同严重性的信息标记（仅限信息，警告或错误）。您可以在此处找到模型上的验证错误。
			</li>
		</ul>
		<p>此透视图还通过右键单击视图<a href="#ModelExplorer"><em>模型资源管理器中</em></a>提供的有用操作。
		</p>
		<p>像往常一样，在Eclipse中，可以通过添加，移动或删除视图，快捷方式等随意自定义此透视图。</p>
		<h3 id="ModelExplorer">Model Explorer视图</h3>
		<p><em>Model Explorer</em>视图显示工作区中的所有项目及其包含的文件。它为<em>Modeling Projects</em>添加了一些特殊功能，允许您直接在资源管理器中查看和操作语义模型及其Sirius表示。
		</p>
		<p>例如，在<em>Model Explorer中</em> ，可以扩展作为<em>Modeling Project</em>或模型文件一部分的语义模型和表示文件，以直接显示其内容：</p> 
		<img border="0" src="images/model_explorer_view.png">
		<p>在上面的示例中， <code>example</code>建模项目（注意项目图标上的蓝色“M”装饰器）包含单个语义模型， <code>example.ecore</code>文件和单个表示文件<code>representations.aird</code> 。两者都可以直接从<em>Model Explorer</em>视图中扩展，以发现语义模型的结构和已经存在的图形表示。
		</p>
		<p><em>Model Explorer</em>支持“Link with Editor”功能，可以通过按下视图右上角的图标（带有两个水平箭头的图标，在上面的屏幕截图中按下）来启用。启用此模式后，如果打开了表示，单击其上的任意位置将自动选择<em>模型资源管理器中</em>的相应语义元素（如有必要，可扩展项目和文件）。相反，如果从“ <em>模型资源管理器”</em>视图中的某个语义模型中选择一个或多个语义元素，并且这些元素在打开的编辑器上的某处显示，则会自动选择它们。当您有许多项目和表示或大型表示以避免迷路时，这可能非常有用。
		</p>
		<p><em>模型资源管理器</em>还支持从<em>建模项目</em>内部过滤元素（并且仅支持这些元素）：如果在视图顶部的搜索框中输入一些文本，视图将过滤掉与文本不匹配的所有元素。例如，如果在搜索框中输入<code>Element</code> ，则仅显示名称以<code>Element</code>开头的模型元素。你可以使用<code>*</code>和<code>?</code> 搜索字符串中的特殊字符分别表示“任何文本”（包括无）和“任何单个字符”。例如，搜索字符串<code>*Element</code>将显示名称中<em>包含</em>字符串<code>Element</code>所有元素。
		</p>
		<p><em>Model Explorer</em>允许使用中间级别对树项目进行分组。此功能显着增强了大型机型的扩展时间。
			<br>  
			<img border="0" src="images/groupItems.png">
			<br>您可以使用三个首选项自定义此功能：</p>
		<ul>
			<li>全局启用/禁用此功能</li>
			<li>增加/减少触发中间级别的阈值</li>
			<li>增加/减少组大小</li>
		</ul> 
		<img border="0" src="images/groupItems_1.png">
		<p>
			<strong>注意：</strong>我们看到需要启用此功能并且具有高于阈值的层次结构上下文才能被触发。
			<br>另一方面，为了保持一致性，阈值和组大小值需要遵循以下规则：</p>
		<ul>
			<li>阈值需要高于或等于组大小。否则，将忽略阈值，而是使用组大小值。</li>
			<li>组大小值必须高于零。</li>
		</ul>
		<p>更新这些首选项时，需要对已扩展的所有资源进行刷新（F5）以获取更新的树项。</p>
		<p>
			<img border="0" src="images/groupItems_2.png">
		</p>
		<p>在Sirius图表工具中的树选择向导上也启用了此功能。</p>
		<p>
			<img border="0" src="images/groupItems_3.png">
		</p>
		<h2 id="MP">建模项目</h2>
		<p>建模项目，在Sirius中用于组织和管理模型及其表示（图表，表格等）。</p>
		<p>建模项目负责将表示数据（图表，表格等） <em>存储</em>在扩展名为<code>.aird</code>特殊<em>表示文件中</em> 。建模项目也可用于存储模型的语义数据，但这不是强制性的。语义数据可以存储在任何地方，但是表示数据<strong>必须存储在建模项目中的<code>aird</code>文件中</strong> （唯一的例外是支持与以前版本兼容的<a href="#LegacyMode">传统模式</a> ）。
		</p>
		<p>此外，建模项目提供<em>了管理视点和表示的操作</em> ：视点与建模项目相关联，因此可用于给定建模项目表示的视点是附加到此项目的视点。通过右键单击建模项目并选择“ <em>视点选择”</em>来进行<em>视点选择</em> 。
		</p>
		<h3 id="MPCreation">创建一个新的建模项目</h3>
		<p>要创建新的<em>建模项目</em> ，只需在<a href="#ModelExplorer">Model Explorer中</a>右键单击（或使用<em>File&gt; New ...</em>菜单），然后选择<em>New&gt; Modeling Project</em> 。
		</p> 
		<img border="0" src="images/new_project1.png">
		<p>将打开一个向导，询问是否必需的项目名称。输入无效的项目名称将导致错误消息。默认情况下，建模项目将在工作空间的位置创建，但可以更改：只需取消选中“使用默认位置”，然后输入要创建建模项目的位置的路径。</p> 
		<img border="0" src="images/new_project2.png">
		<p>完成后，单击“ <em>完成”</em>以实际创建建模项目。它将出现在<em>Model Explorer中</em> ，默认情况下包含两个元素：</p>
		<ul>
			<li>
				<em>项目依赖项</em> ，您可以在其中添加您依赖的外部依赖项，即您将依赖的模型，但存储在项目中的外部项;</li>
			<li>
				<code>representations.aird</code> ，它是项目的顶级表示文件。
			</li>
		</ul> 
		<img border="0" src="images/new_project3.png">
		<h3 id="MPConversion">将现有项目转换为建模项目</h3>
		<p>将现有项目转换为建模项目可能很有用，因为例如必须能够在其中创建表示。可以执行此操作。右键单击任何项目，然后选择<em>配置...&gt;转换为建模项目</em> 。
		</p> 
		<img border="0" src="images/convert_to_modeling_project1.png">
		<p>此操作不会以任何方式改变项目的性质。例如，如果项目是Java项目，那么之后它仍然是一个Java项目。该操作只是将<em>建模项目</em>性质添加到所选项目。
		</p> 
		<img border="0" src="images/convert_to_modeling_project2.png">
		<p>如果有合适的表示文件，则将其视为已转换项目的顶级表示文件。否则，将在项目的根目录自动创建名为<em>representations.aird</em>的新表示文件。
		</p>
		<h3 id="MPConversionReverse">从项目中删除建模性质</h3>
		<p>如果由于某种原因您希望将项目转换为<em>建模项目</em> ，则可以在<em>项目</em>的上下文菜单中使用“ <em>配置...”&gt;“删除建模项目自然”</em>操作。
		</p>
		<p>该操作将简单地从项目本身中删除性质，但不会删除或更改存储在其中的表示文件。您仍然可以使用<a href="#LegacyMode">传统模式</a>使用您的表示。
		</p>
		<h3 id="ViewpointSelection">选择要启用的视点</h3>
		<p>每个建模项目都有一组<em>启用</em>的视点。这可以控制您可以在项目内的语义模型上创建哪种表示形式。您可以使用的视点集取决于您安装的插件以及建模项目中的语义模型类型。例如，即使您已安装<a href="http://marketplace.obeonetwork.com/module/uml" target="_blank">UML Designer</a> ，如果项目包含UML模型（ <code>.uml</code>文件），您也只能启用相应的视点。
		</p>
		<p>要选择在项目中启用哪些视点，只需在项目本身的上下文菜单中使用“ <em>视点选择”</em>操作。将打开一个对话框，其中将显示与项目兼容的所有视点（取决于其包含的模型类型）。您可以单独检查或取消选中每个视点以启用或禁用它，然后单击“ <em>确定”</em>以验证您的选择。请注意，某些视点取决于其他视点（尤其是扩展其他视点的视点）。如果您选择的视点不包含所有必需的依赖项，则将显示一条消息，指示未解析哪些依赖项。然后，您可以调整您的选择并重新验证它。
		</p> 
		<img border="0" src="images/viewpoint_selection1.png"> 
		<img border="0" src="images/viewpoint_selection2.png">
		<h3 id="ProjectDependencies">项目依赖性</h3>
		<p>建模项目将始终具有一个名为<em>Project Dependencies</em>的元素。这用于导入外部模型，外部模型存储在建模项目之外但在其中使用，例如用于项目的某些表示。
		</p>
		<p>要使用存储在当前建模项目之外的语义模型，必须将其添加到项目依赖项中。这不会改变它的位置，但只会允许访问其内容。
			<br>要将外部模型添加到建模项目，请右键单击“ <em>项目依赖项”，</em>然后选择“ <em>添加模型”</em> 。
			<br>项目依赖项可以包含语义模型和图形模型（ <em>即表示文件</em> ）</p> 
		<img border="0" src="images/project_dependencies1.png">
		<p>将打开一个向导页面，允许您输入要添加的模型的URI。如果模型位于工作区中，则可以使用“ <em>浏览工作区</em> ”按钮进行查找。如果模型在文件系统中，则可以使用按钮<em>浏览文件系统...</em>来查找它。否则，您必须手动输入模型的URI。
		</p> 
		<img border="0" src="images/project_dependencies2.png">
		<p>输入模型的URI后，单击“ <em>确定”</em> 。在<em>Project Dependencies</em>下添加模型，并显示一个弹出窗口，允许您选择所需的视点。只需选择或取消选择所需的视点，完成后单击“ <em>确定”</em> 。
		</p> 
		<img border="0" src="images/project_dependencies3.png">
		<p>如果未使用参考模型，则可以将其删除，只需右键单击<em>模型依赖项</em>中的<em>模型，</em>然后选择<em>删除</em> 。
		</p> 
		<img border="0" src="images/remove_dependencies1.png">
		<p>
			<strong>注意：</strong>如果引用的模型是工作空间中的非建模项目，则相应的文件将使用右上角的<em>M</em>进行修饰，以指示此模型在建模项目中使用。如果关闭使用此模型的建模项目，则此装饰器将消失。
		</p> 
		<img border="0" src="images/decorated_model1.png">
		<h3 id="ModelsInMP">建模项目中的模型</h3>
		<p>建模项目中可用的任何模型，无论是物理上位于建模项目中还是仅由其引用（ <em>通过</em> <em>项目依赖项</em> ），都是可扩展的。这意味着可以在<a href="#ModelExplorer">模型资源管理器</a>视图中直接在建模项目中浏览建模项目中使用或引用的任何模型的内容。
		</p> 
		<img border="0" src="images/models_content1.png">
		<h3 id="ModelActions">模型元素可用的操作</h3>
		<p>在建模项目中浏览模型时，可以通过右键单击模型元素来访问多个操作：</p>
		<ul>
			<li>
				<em>New Representation</em>允许您创建新的表示。此操作的可用性取决于模型的类型和选定的视点，仅在有意义时才显示操作;</li>
			<li>
				<em>将图表导出为图像</em>允许您在图像文件中导出与此元素相关的图表（直接在此元素下显示的图表）。
			</li>
		</ul>
		<h3 id="AirdFiles">表示文件</h3>
		<p>表示文件用于存储表示。他们有扩展名<code>.aird</code> 。
			<br>这些文件包含显示图表（或其他类型的表示）所需的数据，但它们不包含由模型本身存储的语义数据。
			<br>可以展开位于建模项目中的表示文件以浏览其内容。
		</p>
		<h3 id="AirdStructure"><em>表示文件的</em>结构
		</h3>
		<p><em>表示文件</em>的内容分为三个级别：</p>
		<ul>
			<li>观点1<ul>
					<li>表示类型1.1<ul>
							<li>代表1.1.1</li>
							<li>代表1.1.2</li>
						</ul>
					</li>
					<li>表示类型1.2<ul>
							<li>代表1.2.1</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>观点2<ul>
					<li>表示类型2.1<ul>
							<li>代表2.1.1</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
		<p>第一级显示可用的视点，这些视点与<em>建模项目中</em>选择的视点相匹配。
			<br>在给定视点内的第二级显示<em>表示类型</em> 。仅显示存在至少一个表示的<em>表示类型</em> 。
			<br>第三级，在<em>表示类型中</em> ，显示实际为此类型提供的表示。
		</p> 
		<img border="0" src="images/aird_unfolded1.png">
		<h3 id="repair">修复动作</h3>
		<p>表示文件上下文菜单中提供了修复操作<br>在某些情况下，您需要对表示文件执行修复操作，尤其是在修改了VSM（odesign文件）时。
		</p>
		<h4 id="Operationsdoneduringrepairexecution">在修复执行期间完成的操作</h4>
		<ul>
			<li>删除没有语义目标的表示。</li>
			<li>停用VSM中不再存在的行为，过滤器和规则。</li>
			<li>保存所有图表元素状态（例如样式，边界，折叠节点的扩展边界）。</li>
			<li>删除将通过刷新重新创建的图元素。</li>
			<li>刷新所有表示。</li>
			<li>恢复图元素状态。</li>
		</ul>
		<h4 id="Caseswhereusingrepairaction">使用修复动作的情况</h4>
		<ul>
			<li>删除行为，规则或过滤到VSM后。</li>
			<li>删除或更新一些映射后。</li>
			<li>删除一些语义元素后。</li>
		</ul>
		<p>在大多数情况下，简单刷新表示就足够了。请注意，修复操作可能需要一些时间，具体取决于表示文件大小。</p>
		<h3 id="MPConstraints">约束</h3>
		<p>关于<em>建模项目</em>有一个重要的限制因素。它们只能包含<strong>一个</strong>顶级<em>表示文件</em> 。
		</p>
		<p>顶级<em>表示文件</em>是存储表示的文件。这些文件可以模块化，这意味着它们可以分成几个文件，但总有一个<em>主</em>文件引用其他文件，并且没有引用。此文件是顶级文件，每个<em>建模项目</em>只能有一个文件。
			<br>换句话说：如果你想拥有几个独立的<em>表示文件</em> ，每个<em>文件</em>都必须放在自己的<em>建模项目中</em> 。
		</p>
		<h3 id="Lifecycle">建模项目生命周期</h3>
		<p>如前所述， <em>建模项目</em>中的<em>模型</em>会在首次需要时自动加载。它们不会自动卸载。如果希望卸载它们（并检索相关的内存），则必须关闭建模项目本身。
		</p>
		<p>此外，给定<em>建模项目的</em>所有表示都是同一模型的一部分。对这些表示之一的任何修改都将导致所有这些表示变脏（这意味着编辑器标题中将显示一个小*符号，表示该文件包含未保存的修改）。相反，保存<em>建模项目的</em>任何表示都可以保存所有这些表示。实际保存的是<em>表示文件</em> ，其中包含所有表示。
		</p>
		<h2 id="Representations">交涉</h2>
		<p>表示存储在<code>*.aird</code>文件中。<code>*.aird</code>文件称为<a href="#AirdFiles"><strong>表示文件</strong></a> 。
			<br>表示可以是图表，表格，交叉表格，树等。</p>
		<p>
			<strong>注意：</strong>位于<em>建模项目</em>中的<em>表示文件</em>会自动加载。
		</p>
		<h3 id="ReprCreation">创建表示</h3>
		<p>有两种创建表示的方法。两者都发生在<em>Model Explorer中</em> 。
		</p>
		<p>创建表示的第一种方法是在模型中导航到您知道有可用<em>表示类型</em>的元素。右键单击此元素，然后选择<em>New Representation&gt; &lt;Representation type&gt;</em> 。
		</p> 
		<img border="0" src="images/create_representation1.png">
		<p>另一种方法是右键单击<em>Modeling Project</em>本身。选择“ <em>创建表示”</em> 。
		</p> 
		<img border="0" src="images/create_representation1_alt.png">
		<p>这将打开一个向导，在这些视点中显示可用的视点和可用的<em>表示类型</em> 。
			<br>只需选择要创建的表示类型，然后单击<em>下一步&gt;</em> 。
		</p> 
		<img border="0" src="images/create_representation2.png">
		<p>然后，向导将显示可用模型（当前建模项目中的模型和导入的模型）。当您浏览这些模型的内容时，您会注意到它们的内容被过滤以仅显示与所选表示类型相关的元素。
			<br>选择要为其创建表示的元素，然后单击“ <em>完成”</em> 。
		</p> 
		<img border="0" src="images/create_representation3.png">
		<p>无论哪种方式，都会出现一个弹出窗口，您可以在其中输入新表示的名称。建议使用默认名称。单击<em>确定</em> 。</p> 
		<img border="0" src="images/create_representation4.png">
		<p>如果当前<em>建模项目中</em>有多个<em>表示文件</em> ，则会在实际创建之前显示一个弹出窗口，以允许您选择将包含该表示的<em>表示文件</em> 。
		</p> 
		<img border="0" src="images/create_representation5.png">
		<p>然后创建并打开表示。</p>
		<h3 id="ReprManagement">管理表示</h3>
		<p>可以通过将<em>表示文件</em>浏览到第三级来访问可用表示。右键单击表示然后提供几个操作：</p> 
		<img border="0" src="images/managing_representation1.png">
		<ul>
			<li>
				<strong>Open</strong>在相关编辑器中打开表示。您也可以通过双击打开表示;</li>
			<li>
				<strong>删除</strong>删除表示：Del键可用作快捷方式（ <strong>警告：</strong>此操作无法撤消）;</li>
			<li>
				<strong>重命名会</strong>打开一个弹出窗口，您可以在其中输入表示的新名称：F2键可用作快捷方式;</li>
			<li>
				<strong>复制</strong>复制表示，打开一个弹出窗口，您可以在其中输入副本的名称;</li>
			<li>
				<strong>移动</strong> （仅当当前<em>建模项目中</em>有多个<em>表示文件</em>时）允许您将表示移动到另一个<em>表示文件</em> ;</li>
			<li>
				<strong>提取到.aird文件...</strong>将所选元素提取到另一个<em>表示文件</em> ，该<em>文件</em>将位于工作区中。将打开一个弹出窗口，允许您选择目标文件，如果需要，新文件将自动添加到项目的依赖项中;</li>
			<li>
				<strong>将图表导出为图像</strong>允许您在一次操作中导出存储在表示文件中的所有图表。您可以选择目标文件夹和图像格式..
			</li>
		</ul>
		<h2 id="LegacyMode">遗留模式</h2>
		<p>旧版UI模式可供以前版本的Sirius用户使用，他们无法或不想将其项目转换为<em>建模项目</em> 。因此，它适用于所有现有的表示文件（前提是它们已根据需要进行迁移），即使它们位于非建模项目内，或者同一项目中有多个顶级表示文件。
		</p>
		<p>使用旧模式时，必须使用文件上下文菜单中的“ <em>打开”</em>操作显式<em>打开</em>表示文件。这相当于在先前版本的Sirius中打开<em>会话</em> 。表示文件打开后，您可以展开它，在里面您将找到在正常<em>建模项目中</em>找到的所有相同元素：与表示文件关联的语义模型以及表示本身。
		</p> 
		<img border="0" src="images/legacy_mode1.png">
		<p>通常在建模项目上执行的所有操作（如选择启用哪些视点）都可以在表示文件本身的上下文菜单中使用：</p> 
		<img border="0" src="images/legacy_mode2.png">
		<p>请注意， <em>Project dependencies</em>条目在传统模式下不可用。要将新语义模型与表示文件相关联，请直接在表示文件上使用“ <em>添加模型”</em>操作。
		</p>
		<p>完成模型和/或表示的使用后，必须使用顶级表示文件上的“ <em>关闭”</em>操作将其<em>关闭</em> （相当于在先前版本中关闭<em>会话</em> ）。
		</p>
	</body>
</html><html id="0587.git-commands-involving-models.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>涉及模型的Git命令</title>
		<style type="text/css">.info {
  border: 1px solid #3c78b5;
  background-color: #d8e4f1;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.note {
  border: 1px solid #f0c000;
  background-color: #ffffce;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.panel {
  border: 1px solid #ccc;
  background-color: #ffffce;
  margin: 10px;
  padding: 0px 6px 0px 6px;
}
.tip {
  border: 1px solid #090;
  background-color: #dfd;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.warning {
  border: 1px solid #c00;
  background-color: #fcc;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
</style>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="Git_commands_involving_models">涉及模型的Git命令</h1>
		<p>当用户想要从git命令行界面比较或合并EMF模型时，操作是以文本方式进行的。如果他想以逻辑方式比较或合并EMF模型的需求，他需要在类似于他用来创建这些模型的Eclipse环境中这样做。因此，环境需要安装一些插件，但它也可能需要设置一些首选项，一些要激活的视角等。在这些插件中，有一些强制性插件用于进行比较/合并操作：EMF Compare和EGit。</p>
		<p>EMF Compare提供了额外的git命令，以便在命令行上比较和合并模型。这些命令将使用Eclipse作为无头应用程序（无图形用户界面），包括EMF Compare和Egit，以逻辑方式比较模型。要配置这样的Eclipse环境，新的git命令将使用Oomph调用程序。</p>
		<p>Oomph <a href="https://wiki.eclipse.org/Eclipse_Oomph_Installer">Oomph</a>是一种在Eclipse IDE中提供一组插件的技术，克隆Git存储库，将Git存储库绑定到此IDE，检查项目，设置工作区首选项......配置是模型驱动的，文件称为Oomph设置模型文件。
		</p>
		<h2 id="Add_new_Git_commands_in_your_system">在系统中添加新的Git命令</h2>
		<p>基本的git命令不允许以逻辑方式比较或合并EMF模型。必须在系统中添加其他git命令。每个git命令都是一个描述其行为的shell脚本。因此，要添加新的git命令，必须开发一个新脚本。与git命令对应的新脚本是：</p>
		<ul>
			<li>git logicalmerge：git merge命令的“模型兼容”版本</li>
			<li>git logicaldiff：git diff命令的“模型兼容”版本</li>
			<li>git logicalmergetool：git mergtool命令的“模型兼容”版本</li>
		</ul>
		<p>必须在需要从命令行界面执行“模型兼容”git操作的每台计算机上添加这些脚本，以启用它们。</p>
		<p>您可以在以下地址找到脚本： <a href="https://hudson.eclipse.org/emfcompare/job/cli-master-nightly/lastSuccessfulBuild/artifact/packaging/org.eclipse.emf.compare.git.pgm.scripts/scripts/">EMF比较Git脚本</a> 。
		</p>
		<p>请注意，这些脚本的位置必须位于PATH环境变量中。此外，他们必须具有执行权限。</p>
		<p>这些脚本将执行名为<i>emfcompare-git-pgm的程序</i> 。您还必须在系统上检索此程序。检索后，您必须将名为EMF_COMPARE_GIT_PGM_PATH的变量导出为包含程序<i>emfcompare-git-pgm</i>的文件夹路径作为值。
		</p>
		<p>您可以在以下地址找到该程序： <a href="https://hudson.eclipse.org/emfcompare/job/cli-master-nightly/lastSuccessfulBuild/artifact/packaging/org.eclipse.emf.compare.git.pgm.products/target/products/">EMF比较Git PGM</a> 。下载与您的系统对应的那个。
		</p>
		<h2 id="Create_a_setup_file">创建一个安装文件</h2>
		<h3 id="Installation">安装</h3>
		<p>安装文件将允许您配置命令使用的无头应用程序。要创建安装文件，您需要一个Eclipse环境，其中安装了EMF Compare的Git命令向导插件的安装模型。在更新管理器中添加以下p2存储库（update-site）（在Eclipse中， <i>帮助菜单&gt;安装新软件...</i> ，在右上角<i>添加...</i>按钮）： <a href="https://hudson.eclipse.org/emfcompare/job/cli-master-nightly/lastSuccessfulBuild/artifact/packaging/org.eclipse.emf.compare.git.pgm.update/target/repository/">EMF Compare的Git命令向导插件更新站点</a>
		</p>
		<p>然后，选择<i>EMF Compare Git PGM Wizards&gt; EMF Compare Git PGM Oomph Wizard Feature</i>并单击<i>Finish</i> 。
		</p>
		<p>此工具需要Oomph 1.0.0或更高版本。您可能需要将Oomph更新站点添加到可用更新站点列表中，以便能够安装和/或更新Oomph： <a href="http://download.eclipse.org/oomph/updates">http</a> ： <a href="http://download.eclipse.org/oomph/updates">//download.eclipse.org/oomph/updates</a>
		</p>
		<h3 id="Basic_usage">基本用法</h3>
		<p>要为EMF Compare的git命令创建新的设置模型，请选择<i>File&gt; New&gt; Other ...&gt; Oomph&gt; EMF Compare的Git命令的Setup Model</i> 。然后单击<i>Next&gt;</i> 。
		</p>
		<p>
			<img align="middle" title="EMF Compare的Git命令向导的设置模型" alt="EMF Compare的Git命令向导的设置模型" border="0" src="./../images/EMF_Compare_GitPGM_NewWizard_01.png">
		</p>
		<p>向导的第一页要求您选择将包含设置模型的项目，并命名该设置模型。然后单击<i>Next&gt;</i> 。
		</p>
		<p>
			<img align="middle" title="EMF Compare的Git命令向导的设置模型" alt="EMF Compare的Git命令向导的设置模型" border="0" src="./../images/EMF_Compare_GitPGM_NewWizard_02.png">
		</p>
		<p>向导的最后一页要求您设置：</p>
		<ul>
			<li>模型的根对象名称。</li>
			<li>工作空间位置（绝对或相对于安装文件）。如果选中“ <i>默认”</i>复选框，则将在系统的临时文件夹中创建工作空间。
			</li>
			<li>安装位置（绝对或相对于安装文件）。如果选择“ <i>默认”</i>复选框，则将在系统的临时文件夹中创建Eclipse环境。
			</li>
			<li>要在工作区中导入的项目。您必须在工作区中导入要在其中执行的git命令中保存<a href="./../developer/logical-model.html#What_is_a_logical_model_.3F" title="。/../developer/logical-model.html#What_is_a_logical_model_.3F">互连模型的</a>所有项目。默认情况下，选中“ <i>在当前存储库中找到导入所有项目”</i>复选框。如果取消选中它，则必须在设置模型中指定要导入的项目。
			</li>
		</ul>
		<p>设置<i>完</i>所有参数后，单击“ <i>完成”</i> 。
		</p>
		<p>
			<img align="middle" title="EMF Compare的Git命令向导的设置模型" alt="EMF Compare的Git命令向导的设置模型" border="0" src="./../images/EMF_Compare_GitPGM_NewWizard_03.png">
		</p>
		<p>创建后，您将能够修改设置模型。如果您愿意，还可以从头开始创建安装模型文件。此设置模型可以包含：</p>
		<ul>
			<li>将创建工作空间的路径（绝对或相对于安装文件）。它对应于设置模型编辑器中的<i>变量任务</i> 。要创建<i>Variable任务</i> ，请右键单击<i>Project元素</i> （根元素），然后选择<i>New Child&gt; Variable</i> 。在属性查看，你必须填写<i>名称</i>字段值为“workspace.location”和<i>值</i>字段与路径。如果在安装模型中未提供此类<i>可变任务</i> ，则将在系统的临时文件夹中创建工作空间。
			</li>
		</ul>
		<ul>
			<li>将配置Eclipse环境的路径（绝对或相对于安装文件）。要创建<i>Variable任务</i> ，请右键单击<i>Project元素</i> （根元素），然后选择<i>New Child&gt; Variable</i> 。在属性查看，你必须填写<i>名称</i>字段值为“installation.location”和<i>值</i>字段与路径。如果在安装模型中未提供此类<i>可变任务</i> ，则将在系统的临时文件夹中创建Eclipse环境。
			</li>
		</ul>
		<ul>
			<li>要执行的git命令中涉及的项目的路径（绝对或相对于安装文件）。这些项目将导入工作区。首先，您必须创建“ <i>项目导入”任务</i> 。右键单击根元素，然后选择“ <i>新建子项”&gt;“项目导入”</i> 。然后，右键单击新创建的“ <i>项目导入”任务</i> ，然后选择“ <i>新建子项”&gt;“源定位器”</i> 。在“属性视图”中，必须使用要导入的项目的路径填充“ <i>根文件夹”</i>字段。如果您不提供任何项目，那么在git存储库中找到的所有项目都将在工作区中导入。在下面的示例中，将导入两个项目： <i>/ your / project / location</i>和<i>/ another / project / location</i> 。请注意， <i>Locate Nested Projects</i>允许导入在给定位置下找到的每个项目。“</li>
		</ul>
		<p>
			<img align="middle" title="EMF Compare的Git命令向导的设置模型" alt="EMF Compare的Git命令向导的设置模型" border="0" src="./../images/EMF_Compare_GitPGM_Edit_01.png">
		</p>
		<ul>
			<li>要在配置的Eclipse环境中安装的其他插件。默认情况下，在Eclipse环境中仅配置EMF Compare和EGit，因为它是执行git命令所需的最小且必需的插件集。但是，您可能需要添加额外的插件/功能集。例如，您可能需要GMF来合并图表，UML2或任何特定的元模型实现，Papyrus等...为此，您必须创建<i>P2 Director任务</i> 。右键单击根元素，然后选择<i>New Child&gt; P2 Director</i> 。然后，右键单击新创建的<i>P2 Director任务</i> ，然后选择<i>New Child&gt; Repository</i>以添加新存储库或<i>New Child&gt; Requirement</i>以添加新插件/功能。在下面的示例中，存储库<i><a href="http://download.eclipse.org/releases/luna/201406250900">http://download.eclipse.org/releases/luna/201406250900</a></i>允许添加<i>org.eclipse.uml2.feature.group</i>和<i>org.eclipse.papyrus.sdk.feature.feature.group</i> （UML2）和纸莎草纸）。已添加存储库<i><a href="http://download.eclipse.org/modeling/emf/compare/updates/nightly/latest/">http://download.eclipse.org/modeling/emf/compare/updates/nightly/latest/</a></i> 。它允许添加<i>org.eclipse.emf.compare.uml2.feature.group</i>和<i>org.eclipse.emf.compare.diagram.papyrus.feature.group</i>特性（EMF比较的扩展来处理UML2模型和Papyrus图）。
			</li>
		</ul>
		<p>
			<img align="middle" title="EMF Compare的Git命令向导的设置模型" alt="EMF Compare的Git命令向导的设置模型" border="0" src="./../images/EMF_Compare_GitPGM_Edit_02.png">
		</p>
		<p>有关Oomph的详细信息，请访问<a href="http://www.eclipse.org/oomph">Oomph网站</a> 。
		</p>
		<p>您可以在此处找到EMF compare的Git命令的设置模型文件<a href="http://git.eclipse.org/c/emfcompare/org.eclipse.emf.compare-cli.git/tree/examples/SetupExamples">示例</a> ： <a href="http://git.eclipse.org/c/emfcompare/org.eclipse.emf.compare-cli.git/tree/examples/SetupExamples">设置示例</a>此示例包含要编辑的工作空间位置，要编辑的安装位置以及要执行git命令时要考虑的其他插件。这些额外的插件是Papyrus，UML2，GMF和EMF Compare扩展。
		</p>
		<h2 id="Git_diff_command_with_models_:_git_logicaldiff">带模型的Git diff命令：git logicaldiff</h2>
		<p>logicaldiff命令是git diff命令的“模型兼容”版本。要查看git diff命令的完整说明，请访问<a href="http://git-scm.com/docs/git-diff">http://git-scm.com/docs/git-diff</a> 。</p>
		<p>该命令指定如下：</p>
		<p><span style="background:#dcdcdc">git logicaldiff [--git-dir <i>&lt;path&gt;</i> ] <i>&lt;setup&gt;</i> <i>&lt;commit&gt;</i> [ <i>&lt;commit&gt;</i> ] [ - <i>&lt;path&gt;</i> ]</span>
		</p>
		<p>要查看修订版和HEAD修订版之间的更改，您应该省略第二次提交。</p>
		<p><span style="background:#dcdcdc">git logicaldiff [--git-dir <i>&lt;path&gt;</i> ] <i>&lt;setup&gt;</i> <i>&lt;commit&gt;</i> [ - ] [ <i>&lt;path&gt;</i> ...]
</span>
		</p>
		<p>在所有情况下， <i>&lt;commit&gt;</i>都可以引用分支名称或提交ID。在所有情况下，[ - <i>&lt;path&gt;</i> ]选项仅允许对与&lt;path&gt;匹配的文件过滤diff命令。在所有情况下，[--git-dir <i>&lt;path&gt;</i> ]选项允许指定git存储库（如果命令未在存储库中运行）</p>
		<h3 id="Others_options_available">其他选择</h3>
		<p><span style="background:#dcdcdc">[--show-栈跟踪]</span></p>
		<p>使用此选项可在出错时显示控制台中的Java堆栈跟踪。</p>
		<p><span style="background:#dcdcdc">[--help（或-h）]</span></p>
		<p>Dispays有助于此命令。</p>
		<h2 id="Git_merge_command_with_models_:_git_logicalmerge">Git merge命令与模型：git logicalmerge</h2>
		<p>logicalmerge命令是git merge命令的“模型兼容”版本。要查看git merge命令的完整说明，请访问<a href="http://git-scm.com/docs/git-merge">http://git-scm.com/docs/git-merge</a> 。</p>
		<p>该命令指定如下：</p>
		<p><span style="background:#dcdcdc">git logicalmerge [--git-dir <i>&lt;path&gt;</i> ] <i>&lt;setup&gt;</i> <i>&lt;commit&gt;</i>
</span>
		</p>
		<p>假设存在以下历史记录，并且当前分支是master：</p>
		<p><span style="background:#dcdcdc"></span></p>
		<pre>A --- B --- C主题/ D --- E --- F --- G主人</pre>
		<p></p>
		<p>然后git logicalmerge mySetupModel.setup主题将重放在主题分支上所做的更改，因为它从master（即E）分离，直到它在master上的当前commit©，并将结果记录在新的commit中以及两个父提交和来自用户的描述更改的日志消息。</p>
		<p><span style="background:#dcdcdc"></span></p>
		<pre>A --- B --- C主题/ \ D --- E --- F --- G --- H主人</pre>
		<p></p>
		<p>您还可以通过其提交ID替换主题分支名称：</p>
		<p><span style="background:#dcdcdc">git logicalmerge <i>mySetupModel.setup</i> <i>87ad5ff</i>
</span>
		</p>
		<p>在所有情况下， <i>&lt;commit&gt;</i>都可以引用分支名称或提交ID。在所有情况下，[--git-dir <i>&lt;path&gt;</i> ]选项允许指定git存储库（如果命令未在存储库中运行）</p>
		<h3 id="Others_options_available_2">其他选择</h3>
		<p><span style="background:#dcdcdc">[-m留言]</span></p>
		<p>设置要用于合并提交的提交消息（如果创建了一个）。</p>
		<p><span style="background:#dcdcdc">[--show-栈跟踪]</span></p>
		<p>使用此选项可在出错时显示控制台中的Java堆栈跟踪。</p>
		<p><span style="background:#dcdcdc">[--help（或-h）]</span></p>
		<p>Dispays有助于此命令。</p>
		<h2 id="Git_mergetool_command_with_models_:_git_logicalmergetool">Git mergetool命令与模型：git logicalmergetool</h2>
		<p>logicalmergetool命令是git mergetool命令的“模型兼容”版本。要查看git mergetool命令的完整说明，请访问<a href="http://git-scm.com/docs/git-mergetool">http://git-scm.com/docs/git-mergetool</a> 。</p>
		<p>这是git logicalmergetool允许的结构：</p>
		<p><span style="background:#dcdcdc">git logicalmergetool <i>&lt;setup&gt;</i>
</span>
		</p>
		<p>运行逻辑合并冲突解决工具以解决逻辑合并冲突。在我们的例子中，它将启动一个Eclipse平台，其中包含解决合并引发的冲突所需的所有工具。为此，在Eclipse环境中，选择冲突的文件并打开上下文菜单<i>Team&gt; Merge Tool</i> 。解决冲突后，将文件添加到索引（暂存区域）。然后提交。
		</p>
		<h2 id="Git_cherry-pick_with_models_:_git_logicalcherry-pick">Git樱桃挑选模特：git logicalcherry-pick</h2>
		<p><i>logicalcherry-pick</i>命令是git cherry pick命令的逻辑版本。要查看git cherry-pick命令的完整说明，请访问<a href="http://git-scm.com/docs/git-cherry-pick">http://git-scm.com/docs/git-cherry-pick</a> 。</p>
		<p>该命令指定如下：</p>
		<p><span style="background:#dcdcdc">git logicalcherry-pick <i>&lt;setup&gt;</i> <i>&lt;commit&gt; ...</i>
</span>
		</p>
		<p>假设存在以下历史记录，并且当前分支是<i>master</i> ：<code><pre>A --- B --- C主题/</pre></code></p>
		<pre>D --- E --- F --- G大师，HEAD</pre>

		<p>然后<code>git logicalcherry-pick mySetupModel.setup ABC</code>将在当前HEAD之上选择A，B和C提交（按命令定义的顺序）。<code><pre>A --- B --- C主题/</pre></code></p>
		<pre>D --- E --- F --- G --- A --- B --- C大师，HEAD</pre>

		<p>在所有情况下， <i>&lt;commit&gt;</i>都可以引用分支名称或提交ID。
		</p>
		<h3 id="Conflicts">冲突</h3>
		<h4 id="Resolve_a_conflict">解决冲突</h4>
		<p>如果挑选提交引入了冲突，则必须选择如何处理它。第一个选项是使用以下方法解决它：</p>
		<p><span style="background:#dcdcdc">git logicalmergetool <i>&lt;setup&gt;</i>
</span>
		</p>
		<p>它打开了一个Eclipse平台，您可以在其中使用合并工具合并差异（请参阅<a href="#Git_mergetool_command_with_models_:_git_logicalmergetool">Git mergetool命令和models：git logicalmergetool</a> ）。解决所有冲突后，将相关文件添加到索引并关闭平台。为此，您可以：</p>
		<ul>
			<li>使用上下文菜单“团队&gt;添加到索引”</li>
		</ul>
		<dl>
			<dd>
				<img border="0" src="../images/AddToIndexMenu.png">
			</dd>
		</dl>
		<ul>
			<li>将文件从“未暂存的更改”区域拖放到“Git Staging”视图中的“Staged changes”区域。</li>
		</ul>
		<dl>
			<dd>
				<img border="0" src="../images/StagedChanges.png">
			</dd>
		</dl>
		<p>顺便说一句，你可以注意到右上角有一个<b>Abort</b> ， <b>Skip Commit</b>和<b>Continue</b>按钮。这只是意味着正在进行交互式rebase。实际上，在EGit中，挑选樱桃提交相当于仅使用挑选操作进行交互式变换。从现在开始，您可以选择继续使用UI模式（也就是说使用这些按钮），或者通过关闭Eclipse平台返回命令行工具。本文档仅介绍命令行工具的机制。
		</p>
		<h4 id="Continue">继续</h4>
		<p>解决所有冲突后，请点击：</p>
		<p><span style="background:#dcdcdc">git logicalcherry-pick <i>&lt;setup&gt;  -</i> <i>继续</i>
</span>
		</p>
		<p>这个命令将继续进行挑选。在使用此命令之前，请务必解决所有冲突，否则您可能会收到以下消息：<code><pre>致命：有些文件存在冲突：project / file.ecore project / file2.ecore hint：您必须编辑所有合并冲突，然后提示：使用git add将它们标记为已解决。</pre></code></p>
		<p>合并工作流程存在一个主要差异。挑选樱桃时，你不应该自己提交文件，而只是将它们添加到索引中。如果这样做，则在使用<i>--continue</i>选项时可能会收到以下消息。
<code>
		</code></p>
		<pre>没有检测到任何变化如果没有任何东西可以上台，很可能其他东西已经引入了相同的变化;你可能想要使用git logicalcherry-pick --quit跳过这个补丁</pre>
		<p></p>
		<p>您可以简单地使用<i>--quit</i>选项继续您的挑选操作（请参阅<a href="#Quit">退出选项</a> ）。
		</p>
		<h3 id="Abort">退出</h3>
		<p>遇到冲突时的第二个解决方案是中止整个樱桃挑选操作。为此，请点击：</p>
		<p><span style="background:#dcdcdc">git logicalcherry-pick <i>&lt;setup&gt;</i> <i>--abort</i>
</span>
		</p>
		<p>它会恢复所有已经挑选过的提交，以便在cherry-pick命令之前检索状态。</p>
		<h3 id="Quit">放弃</h3>
		<p>面对冲突时的最后一个解决方案是“跳过”当前提交并继续进行剩余的提交。为此，请点击：</p>
		<p><span style="background:#dcdcdc">git logicalcherry-pick <i>&lt;setup&gt;</i> '' -  not'</span>
		</p>
		<p><i>--quit</i>选项与<i>CGit</i>中的cherry-pick命令的<i>--quit</i>选项完全不同。它不会退出正在进行的挑选，而是跳过当前的提交。实际上，正如上面提到的，在EGit中，樱桃选择被替换为交互式rebase。这就是为什么<i>--quit</i>选项更像是交互式rebase的<i>--skip</i>选项。
		</p>
		<h3 id="Others_options_available_3">其他选择</h3>
		<p><span style="background:#dcdcdc">[--git-dir <i>&lt;path&gt;</i> ]</span>
		</p>
		<p>指定存储库的.git文件夹。这可以用于在git存储库外执行命令。</p>
		<p><span style="background:#dcdcdc">[--show-栈跟踪]</span></p>
		<p>使用此选项可在出错时显示控制台中的Java堆栈跟踪。</p>
		<p><span style="background:#dcdcdc">[--help（或-h）]</span></p>
		<p>支持此命令的支持。</p>
		<p><span style="background:#dcdcdc">[--debug（或-d）]</span></p>
		<p>提供将远程调试器连接到逻辑樱桃选择应用程序的机会（使用端口8123）。</p>
		<h2 id="Git_rebase_with_models_:_git_logicalrebase">使用模型git rebase：git logicalrebase</h2>
		<p><i>logicalrebase</i>命令是git rebase命令的逻辑版本。要查看git rebase命令的完整说明，请访问<a href="http://git-scm.com/docs/git-rebase">http://git-scm.com/docs/git-rebase</a> 。</p>
		<p>该命令指定如下：</p>
		<p><span style="background:#dcdcdc">git logicalrebase <i>[&lt;upstream&gt;]</i> <i>[&lt;branch&gt;]</i>
</span>
		</p>
		<p><span style="background:#dcdcdc">[&lt;上游&gt;]</span></p>
		<p>用于引用目标提交的可选参数，在该目标提交的基础上将对分支<i>[&lt;branch&gt;]</i>进行重新分配。它可以是分支的名称，提交的id或标记的名称。如果只给出一个参数，软件会将其视为上游参数并将<i>[&lt;branch&gt;]设置</i>为<i>HEAD</i> 。</p>
		<p>假设存在以下历史记录，并且当前分支是<i>主题</i> ：<code><pre>A --- B --- C主题，HEAD /</pre></code></p>
		<pre>D --- E --- F --- G大师</pre>

		<p>然后<code>git rebase mySetupModel.setup master</code>将在<i>master</i>之上重新分支分支<i>主题</i> 。<code><pre>
		</pre></code></p>
		<pre>D --- E --- F --- G --- A --- B --- C大师，主题，HEAD</pre>

		<p><span style="background:#dcdcdc">[&lt;分支&gt;]</span></p>
		<p>可选参数用于引用将要重新定义的内容。它可以是分支的名称，提交的id或标记的名称。</p>
		<p>例如，假设存在以下历史记录，并且当前分支是<i>master</i> ：<code><pre>A --- B --- C主题/</pre></code></p>
		<pre>D --- E --- F --- G大师，HEAD</pre>

		<p>然后<code>git rebase mySetupModel.setup master topic</code>将检查分支<i>主题</i>并将其重<code>git rebase mySetupModel.setup master topic</code>为<i>master</i> 。<code><pre>
		</pre></code></p>
		<pre>D --- E --- F --- G --- A --- B --- C大师，主题，HEAD</pre>

		<p>提示要记住参数顺序：</p>
		<ul>
			<li><code>git rebase mySetupModel.setup master</code> = Rebase on <i>master</i> the HEAD</li>
			<li><code>git rebase mySetupModel.setup master topic</code> =在<i>master上</i>的Rebase分支<i>主题</i>
			</li>
			<li><code>git rebase mySetupModel.setup master topic</code>等效于<code>git rebase mySetupModel.setup master</code>如果HEAD在同一个提交而不是主题上。</li>
		</ul>
		<p>如果你没有指定任何分支， <code>git rebase mySetupModel.setup</code>将尝试在其远程跟踪分支之上<code>git rebase mySetupModel.setup</code>当前分支（请参阅分支。&lt;name&gt; .remote和branch。&lt;name&gt; .merge选项在<a href="http://git-scm.com/docs/git-config" title="http://git-scm.com/docs/git-config">git-config中</a> ） 。
		</p>
		<p>例如，假设存在以下历史记录。当前分支是<i>master</i> ，它跟踪远程分支<i>origin / master</i> ：<code><pre>
		</pre></code></p>
		<pre>A --- B --- C原点/主/ D --- E --- F --- G主，HEAD</pre>

		<p>然后<code>git rebase mySetupModel.setup</code>将变基<i>原产/主</i>的顶尖<i>高手</i> 。<code><pre>
		</pre></code></p>
		<pre>D --- E --- A --- B --- C --- F --- G主，起源/主，HEAD</pre>

		<h3 id="Conflicts_2">冲突</h3>
		<h4 id="Resolve_a_conflict_2">解决冲突</h4>
		<p>如果重新定位提交会引入冲突，则必须选择如何处理它。第一个选项是使用以下方法解决它：</p>
		<p><span style="background:#dcdcdc">git logicalmergetool <i>&lt;setup&gt;</i>
</span>
		</p>
		<p>它打开了一个Eclipse平台，您可以在其中使用合并工具合并差异（请参阅<a href="#Git_mergetool_command_with_models_:_git_logicalmergetool">Git mergetool命令和models：git logicalmergetool</a> ）。解决所有冲突后，将相关文件添加到索引并关闭平台。为此，您可以：</p>
		<ul>
			<li>使用上下文菜单“团队&gt;添加到索引”</li>
		</ul>
		<dl>
			<dd>
				<img border="0" src="../images/AddToIndexMenu.png">
			</dd>
		</dl>
		<ul>
			<li>将文件从“未暂存的更改”区域拖放到“Git Staging”视图中的“Staged changes”区域。</li>
		</ul>
		<dl>
			<dd>
				<img border="0" src="../images/StagedChanges.png">
			</dd>
		</dl>
		<p>顺便说一句，你可以注意到右上角有一个<b>Abort</b> ， <b>Skip Commit</b>和<b>Continue</b>按钮。这只是意味着正在进行交互式rebase。实际上，在EGit中，即使是正常的rebase操作也相当于只使用pick操作进行交互式rebase。从现在开始，您可以选择继续使用UI模式（也就是说使用这些按钮），或者通过关闭Eclipse平台返回命令行工具。本文档仅介绍命令行工具的机制。
		</p>
		<h4 id="Continue_2">继续</h4>
		<p>解决所有冲突后，请点击：</p>
		<p><span style="background:#dcdcdc">git logicalrebase <i>&lt;setup&gt;  -</i> <i>继续</i>
</span>
		</p>
		<p>此命令将继续进行rebase。在使用此命令之前，请务必解决所有冲突，否则您可能会收到以下消息：<code><pre>致命：有些文件存在冲突：project / file.ecore project / file2.ecore hint：您必须编辑所有合并冲突，然后提示：使用git add将它们标记为已解决。</pre></code></p>
		<p>合并工作流程存在一个主要差异。在重新定位时，您不应该自己提交文件，而只是将它们添加到索引中。如果这样做，则在使用<i>--continue</i>选项时可能会收到以下消息。
<code>
		</code></p>
		<pre>没有变化 - 你忘了使用'git add'吗？如果没有任何东西可以上台，那么其他东西可能已经引入了同样的变化;你可能想跳过这个补丁。解决此问题后，运行“git logicalrebase --continue”。如果您想跳过此补丁，请改为运行“git logicalrebase --skip”。要检出原始分支并停止重新定位，请运行“git logicalrebase --abort”。
</pre>
		<p></p>
		<p>您只需使用<i>--skip</i>选项继续您的rebase操作（请参阅<a href="#Skip">跳过选项</a> ）。
		</p>
		<h3 id="Abort_2">退出</h3>
		<p>遇到冲突时的第二个解决方案是中止整个rebase操作。为此，请点击：</p>
		<p><span style="background:#dcdcdc">git rebase <i>&lt;setup&gt;</i> <i>--abort</i>
</span>
		</p>
		<h3 id="Skip">跳跃</h3>
		<p>面对冲突时的最后一个解决方案是“跳过”当前提交并继续进行rebase的其余提交。为此，请点击：</p>
		<p><span style="background:#dcdcdc">git rebase <i>&lt;setup&gt;</i> <i>--quit</i>
</span>
		</p>
		<h3 id="Others_options_available_4">其他选择</h3>
		<p><span style="background:#dcdcdc">[--git-dir <i>&lt;path&gt;</i> ]</span>
		</p>
		<p>指定存储库的.git文件夹。这可以用于在git存储库外执行命令。</p>
		<p><span style="background:#dcdcdc">[--show-栈跟踪]</span></p>
		<p>使用此选项可在出错时显示控制台中的Java堆栈跟踪。</p>
		<p><span style="background:#dcdcdc">[--help（或-h）]</span></p>
		<p>支持此命令的支持。</p>
		<h2 id="Git_pull_with_models_:_git_logicalpull">Git pull with models：git logicalpull</h2>
		<p><i>logicalpull</i>命令是git pull命令的逻辑版本。要查看git pull命令的完整说明，请访问<a href="http://git-scm.com/docs/git-pull">http://git-scm.com/docs/git-pull</a> 。</p>
		<p>该命令指定如下：</p>
		<p><span style="background:#dcdcdc">git logicalpull <i>&lt;setup&gt;</i>
</span>
		</p>
		<p>假设存在以下历史记录，并且当前分支是master：</p>
		<p><span style="background:#dcdcdc"></span></p>
		<pre>A --- B --- C master on origin / D --- E --- F --- G master ^ origin / master在你的知识库中</pre>
		<p></p>
		<p>基本上<i>git logicalpull</i>是<i>git fetch，</i>后跟获取的分支的<i>git logicalmerge</i> 。所以<i>git logicalpull mySetupModel.setup</i>将从远程<i>主</i>分支获取并重放更改，因为它从本地<i>主服务器</i> （即<i>E</i> ）分离，直到它在<i>master</i>之上的当前提交（ <i>C</i> ），并将结果记录在新的提交中使用两个父提交的名称和来自用户的描述更改的日志消息。
		</p>
		<p><span style="background:#dcdcdc"></span></p>
		<pre>A --- B --- C原点/主控/ \ D --- E --- F --- G --- H主控</pre>
		<p></p>
		<p>如果该命令引入了冲突，则必须启动<a href="#Git_mergetool_command_with_models_:_git_logicalmergetool">git logicalmergetool</a>来解决它们。
		</p>
		<h3 id="Others_options_available_5">其他选择</h3>
		<p><span style="background:#dcdcdc">[--show-栈跟踪]</span></p>
		<p>使用此选项可在出错时显示控制台中的Java堆栈跟踪。</p>
		<p><span style="background:#dcdcdc">[--help（或-h）]</span></p>
		<p>Dispays有助于此命令。</p>
		<h2 id="Known_bugs_.26_limitations">已知的错误和限制</h2>
		<h3 id="First_use">首次使用</h3>
		<p>产品第一次启动时，控制台中会显示堆栈跟踪（参见下文）。此错误不会阻止使用该产品，但这可能会误导用户。第一次启动后，此错误消失。</p>
		<pre class="source-java">org.osgi.framework。BundleException：无法解析模块：org.eclipse.equinox.ds [2]未解决的要求：Import-Package：org.eclipse.equinox.internal.util.event; org.eclipse.osgi.container上的version =“1.0.0”。在org.eclipse.osgi.container上的Module.start（Module.java:434）。在org.eclipse.osgi.container的ModuleContainer $ ContainerStartLevel.incStartLevel（ModuleContainer.java:1582）。在org.eclipse.osgi.container的ModuleContainer $ ContainerStartLevel.incStartLevel（ModuleContainer.java:1562）。在org.eclipse.osgi.container的ModuleContainer $ ContainerStartLevel.doContainerStartLevel（ModuleContainer.java:1533）。SystemModule.startWorker（SystemModule.java:242）位于org.eclipse.osgi.container。在org.eclipse.osgi.container上的Module.doStart（Module.java:571）。在org.eclipse.osgi.container上的Module.start（Module.java:439）。SystemModule.start（SystemModule.java:172）位于org.eclipse.osgi.internal.framework。EquinoxBundle.start（EquinoxBundle.java:393）位于org.eclipse.osgi.internal.framework。EquinoxBundle.start（EquinoxBundle.java:412）位于org.eclipse.osgi.launch。Equinox.start（Equinox.java:115）位于org.eclipse.core.runtime.adaptor。EclipseStarter.startup（EclipseStarter.java:318）位于org.eclipse.core.runtime.adaptor。sun.reflect上的EclipseStarter.run（EclipseStarter.java:231）。sun.reflect中的NativeMethodAccessorImpl.invoke0（本机方法）。sun.reflect中的NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:62）。在java.lang.reflect中委托MethodAethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:43）。在org.eclipse.equinox.launcher上的Method.invoke（Method.java:483）。Main.invokeFramework（Main.java:648）位于org.eclipse.equinox.launcher。Main.basicRun（Main.java:603）位于org.eclipse.equinox.launcher。Main.run（Main.java:1465）位于org.eclipse.equinox.launcher。Main.main（Main.java:1438）</pre>
		<p>已报告有关此错误的错误： <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=453432">https</a> ： <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=453432">//bugs.eclipse.org/bugs/show_bug.cgi？id = 453432</a>
		</p>
		<h3 id="Merge_tool">合并工具</h3>
		<p>合并工具在逻辑模型上无法正常工作。问题已知并且已经修补了它。由于问题涉及EGit和EMF Compare，我们需要让EGit团队整合以下贡献：</p>
		<ul>
			<li>
				<a href="https://git.eclipse.org/r/#/c/36026/">https://git.eclipse.org/r/#/c/36026/</a>
			</li>
		</ul>
		<p>集成后，还将集成以下EMF比较贡献：</p>
		<ul>
			<li>
				<a href="https://git.eclipse.org/r/#/c/35541/">https://git.eclipse.org/r/#/c/35541/</a>
			</li>
			<li>
				<a href="https://git.eclipse.org/r/#/c/36025/">https://git.eclipse.org/r/#/c/36025/</a>
			</li>
		</ul>
		<p>然后，合并工具将正常工作。</p>
		<h3 id="Cherry-pick_empty_commit">樱桃挑选空提交</h3>
		<p>如果您尝试选择一个引入已经属于工作树的更改的提交，则操作可能会停止在脏状态。例如，如果您已经选择了属于HEAD祖先树的提交。这种脏状态的特征是：</p>
		<ol>
			<li>HEAD的错误立场。</li>
			<li>工作树中的一些修改过的文件（使用<i>git status</i>命令）。
			</li>
		</ol>
		<p>这个问题来自EGit / JGit问题（参见<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=451159" title="https://bugs.eclipse.org/bugs/show_bug.cgi?id=451159">bug 451159</a> ）。解决方法是使用<i>git reflog</i>命令找到HEAD的先前位置。然后，使用<i>git reset --hard {$ CommitId}</i> 。这会将HEAD重置为之前的位置（ <i>谨慎使用</i> ）。
		</p>
	</body>
</html><html id="3330.Writing_Queries.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Writing_Queries</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="WritingQueriesandInterpretedExpressions">编写查询和解释表达式</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#WritingQueriesandInterpretedExpressions">编写查询和解释表达式</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#general">通用规则</a>
					</li>
					<li>
						<a href="#specialized">使用专业口译员</a>
					</li>
					<li>
						<a href="#aql">使用AQL</a>
					</li>
					<li>
						<a href="#acceleo">使用Acceleo</a>
					</li>
					<li>
						<a href="#ocl">使用原始OCL</a>
					</li>
					<li>
						<a href="#custom">提供自定义语言</a>
					</li>
					<li>
						<a href="#service_methods">编写Java服务</a>
					</li>
					<li>
						<a href="#service_navigation">从解释表达式或Java扩展访问Java服务实现</a>
					</li>
					<li>
						<a href="#standard_services">标准服务</a>
						<ol style="list-style:disc">
							<li>
								<a href="#editing_domain_services">编辑域服务和EMF编辑集成</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p><em>VSM的</em>许多部分都要求您提供<em>解释表达式</em> ，这些<em>表达式</em>将在运行时进行评估，以提供特定于您的域和表示的行为。其中一些表达式返回模型元素（在这种情况下我们称之为<em>查询</em> ），而其他表达式只是生成文本（例如用于标签的表达式），但原则保持不变。
		</p>
		<p>Sirius不会强制使用特定语言来编写这些查询。目前，默认情况下提供三种不同的语言，如果您有特定需求，可以扩展系统并<a href="#custom">提供自己的语言</a> 。您可以在同一个VSM中使用多种不同的语言（但每个表达式中只有一种语言）。
		</p>
		<p>无论您使用哪种语言，因为从Sirius的角度来看它们都是可选的，请确保包含VSM的Viewpoint规范项目明确依赖于为这些语言提供支持的Sirius插件。否则，当您将建模者部署到最终用户时，您无法确定是否有适当的支持。使用标准向导创建的<em>视点规范项目</em>已预先配置为使用AQL（ <em>加速查询语言</em> ），这是Sirius 3.1的推荐语言。有关Sirius支持插件名称的每种标准语言，请参阅以下部分，以确定是否使用该语言。
		</p>
		<h2 id="general">通用规则</h2>
		<p>一些通用规则独立于语言细节。</p>
		<p>
			<strong>自动完成。</strong> 首先，在<em>VSM</em>编辑器中，属性视图中具有黄色背景的任何字段都是解释表达式。在这些字段中，可以通过<em>按Ctrl + Space</em>来触发自动完成。
		</p>
		<p>
			<img border="0" src="images/emptyFieldAutoCompletion.jpg">
		</p>
		<p>完成将对应于已安装的查询语言的空表达式（例如<b>aql：</b> for AQL）。它还会将光标放在准备开始键入表达式的预期位置。
		</p>
		<p>
			<img border="0" src="images/emptyExpressionCursor.jpg">
		</p>
		<p>在空表达式上执行自动完成时，第一个完成提议将对应于表达式上下文中可用的变量，其余对应于当前元素上可用的所有功能，服务等。</p>
		<p>
			<img border="0" src="images/emptyExpressionAutoCompletion.jpg">
		</p>
		<p>有时，Sirius无法静态地确定要对其进行求值的模型元素的精确类型。在这种情况下，它假定一个简单的<em>EObject</em> 。这意味着您将无法获得特定于您的自定义类型的完成建议，并且如果您使用<em>EObject</em>上不可用的功能或服务，则VSM的验证将失败。为了防止这种情况，如果你知道元素的确切类型并且语言支持它，那么添加一个<code>aql:filter(packageName::ExpectedType).theRestOfTheExpression</code>操作来告诉Sirius实际的类型（例如<code>aql:filter(packageName::ExpectedType).theRestOfTheExpression</code>如果使用AQL， <code>aql:filter(packageName::ExpectedType).theRestOfTheExpression</code> 。
		</p>
		<p>
			<strong>解释器视图。</strong> <em>Interpreter</em>视图可用于以交互方式开发复杂表达式。视图可以在本机<em>Acceleo</em>模式（对应于Acceleo 3 / MTL）或<em>Sirius</em>模式下工作。在<em>Sirius</em>模式下，您可以使用Sirius支持的任何语言，但是您将失去语法着色的好处。
		</p>
		<p>要使用<em>Interpreter</em>视图，只需打开Sirius表示，在其中选择和元素（例如图表上的形状），然后在视图的上部文本字段中键入一些表达式。表达式的结果（一组模型元素或字符串）将出现在视图的下半部分。如果选择其他元素，则会在新元素的上下文中自动重新计算结果。
		</p>
		<p>
			<img border="0" src="images/viewpoint_interpreter.png">
		</p>
		<p>
			<em>警告：</em>当使用Sirius表示中选择的元素的<em>Interpreter</em>视图时，表达式的上下文<strong>不是</strong> <em>语义</em>元素，而是Sirius内部使用的<em>视图</em>模型元素。要访问语义元素，您必须使用视图的<code>target</code>引用。更具体地说，假设您有一个Sirius图表示带有节点的UML类。如果选择一个类并在解释器视图中输入<code>aql:self</code> ，则结果将不是UML <code>Class</code>元素，而是<code>DNode</code> （Sirius内部用于表示图形节点的类型）。要获取UML类，必须输入<code>aql:self.target</code> （或其他语言中的等效项）。在使用<em>Interpreter</em>视图开发要在VSM中使用的表达式时，请记住这一点：VSM中定义的大多数表达式将在语义元素的上下文中进行评估，因此在切换时需要添加/删除<code>target</code>引用他们俩。
		</p>
		<p>
			<strong>确定性。</strong> 通常，您应该尝试确保您的查询是确定性的，即从相同的输入模型，它们应始终返回相同的结果，并以相同的顺序（如果返回元素集合）。否则，每次刷新一个表示时，它可能会变脏（因为Sirius会将顺序差异视为一个变化）或甚至视觉上不稳定（即元素以不同的顺序显示）。为了确保查询中的确定性，有几件事需要注意：</p>
		<ul>
			<li>在元模型级别，如果您控制它，请确保任何派生特征始终以相同的顺序返回其值。如果您不控制元模型并且它具有可能导致问题的无序引用（UML是一个示例），则可以通过在元素在Sirius查询中使用时对元素进行排序来强制执行自己的排序。</li>
			<li>在Sirius查询级别，请确保仅调用您使用的查询语言中具有确定性的操作。不幸的是，这些信息通常不会在查询语言语义中记录，因此现在需要进行一些试验和错误实验。</li>
			<li>在服务级别，如果您创建自己的<a href="#service_methods">Java服务</a> ，请确保使用确保固定迭代顺序的数据结构，例如<code>LinkedHashSet</code>而不是<code>HashSet</code> 。
			</li>
		</ul>
		<h2 id="specialized">使用专业口译员</h2>
		<p>Sirius提供了几种专门的解释器来更有效地处理某些形式的简单表达式，这些表达式在典型的VSM中经常出现。每个解释器都侧重于非常有限的情况，并且没有一个支持复杂的表达式。这允许它们非常快，但它要求您尽可能明确地使用它们。默认情况下，Sirius中提供了所有这些解释器，您无需在VSM项目中声明其他依赖项即可使用它们。</p>
		<ul>
			<li>
				<strong><code>var:</code></strong>此解释器只能直接访问命名变量的值。例如，使用专用解释器而不是<code>aql:containerView</code> （使用AQL），而不是使用<code>var:containerView</code> 。作为一种特殊情况，伪变量<code>self</code>可用于访问当前元素（评估上下文）： <code>var:self</code>等同于AQL中的<code>aql:self</code> 。</li>
			<li>
				<strong><code>feature:</code></strong>此解释器只能直接访问当前元素的命名特征。例如，代替<code>aql:self.name</code> ，使用此解释器的等效项将是<code>feature:name</code> 。请注意，如果生成的元模型生成的代码是将特征委托设置为Reflective，则功能解释器将返回属性的原始值（如<code>eGet</code> ），绕过您提供的任何自定义getter实现。此解释器还支持以下伪特征：<ul>
					<li>
						<code>feature:eContainer</code>返回当前元素的容器（如果没有则返回<code>null</code> ）。这相当于<code>aql:self.eContainer()</code> 。
					</li>
					<li>
						<code>feature:eContents</code>返回当前元素的直接内容（如果没有，则返回空集合）。这相当于<code>aql:self.eContents()</code> 。
					</li>
					<li>
						<code>feature:eAllContents</code>返回直接和间接包含在当前元素内的所有元素（如果没有，则返回空集合）。这相当于<code>aql:self.eAllContents()</code> 。
					</li>
					<li>
						<code>feature:eCrossReferences</code>返回当前元素直接引用的所有模型元素（如果没有，则返回空集合）。这相当于<code>[self.eCrossReferences()/] using Acceleo 3/MTL</code> 。</li>
				</ul>
			</li>
			<li>
				<strong><code>service:</code></strong>此解释器可用于直接调用当前元素上的服务方法（即遵循<a href="#service_methods">服务方法</a>约定的Java <a href="#service_methods">方法</a> ）。例如，假设服务类<a href="#ecore_services"><code>EcoreServices</code></a>已在VSM中正确注册，则表达式<code>service:getEClasses</code> （注意缺少括号）将调用当前元素上的<code>getEClasses</code> （如果它是<code>EPackage</code>的实例）。
				<ul>
					<li>服务解释器支持参数，但只有变量可用作参数（无文字或复杂表达式），例如： <code>service:serviceName(view, diagram)</code> 。
					</li>
					<li>您不仅可以在调用服务之前使用变量名称在当前上下文中使用服务解释器，例如： <code>service:myVariableName.serviceName</code> 。</li>
					<li>出于效率原因，如果多个服务与表达式匹配，则使用找到的第一个服务。没有真正的多态性管理。</li>
				</ul>
			</li>
		</ul>
		<h2 id="aql">使用AQL</h2>
		<p>从Sirius 3.1开始， <em>AQL</em> （Acceleo查询语言，首次在Sirius 3.0中引入）是编写查询/解释表达式的推荐语言。AQL类似于Acceleo 3 / MTL，但更简单，并且在Sirius环境中提供了更好的性能。AQL表达式以<code>aql:</code>前缀开头，其语法类似于Acceleo（没有括号<code>[../]</code>括号）。这两种语言的主要区别是：</p>
		<ul>
			<li>即使目标是<code>self</code> ，功能访问也必须<strong>始终</strong>显式指定目标对象。这意味着像<code>[name/]</code>这样的Acceleo表达式访问当前元素的<code>name</code>属性，在AQL中将<code>aql:self.name</code>转换为<code>aql:self.name</code> 。没有显式接收器的表达式<code>aql:name</code>将始终被解释为对<code>name</code>变量的访问，如果未定义相关变量，则可能导致错误。
			</li>
			<li>“Lambda”表达式必须始终声明其参数并明确使用它们。同样，在这样的背景下没有隐含的<code>self</code> 。例如： <code>[self.eContents()-&gt;select(name.startsWith('A'))/]</code>成为<code>aql:self.eContents()-&gt;select(i | i.name.startsWith('A'))</code> with在AQL中明确声明和使用<code>i</code> 。</li>
			<li>就复杂表达式中的缺失/空中间结果而言，AQL更加持久： <code>aql:self.anEmptyReference.somethingElse</code>不会像等效的Acceleo（或OCL）表达式那样导致错误，而只是返回一个空结果。
			</li>
			<li>与Acceleo相比，AQL默认提供不同的服务/方法。通常，AQL中的默认服务集更适合于Sirius中遇到的典型用例。</li>
		</ul>
		<p>有关语言本身，标准服务的完整列表以及与Acceleo / MTL的差异的更多详细信息，请参阅<a href="https://www.eclipse.org/acceleo/documentation/aql.html" target="_blank">AQL文档</a> 。</p>
		<p>
			<em>注意：</em>使用默认向导创建的视点规范项目将已设置为使用它。否则，您需要向<code>org.eclipse.sirius.common.acceleo.aql</code>插件添加依赖项，以确保在使用建模器的任何地方都可以使用AQL支持。在<strong>开发</strong>使用AQL的新VSM时，建议安装<code>org.eclipse.sirius.common.acceleo.aql.ide</code>插件，因为它提供了表达式完成等规范时间功能。但是，运行时不需要<code>org.eclipse.sirius.common.acceleo.aql.ide</code>来生成建模器。
		</p>
		<p>
			<em>注意：</em>像olcIsKindOf（）或filter（）这样的服务使用类型文字，并且需要显式引用已知的元模型作为依赖项才能工作。建议将相应的元模型插件添加到Viewpoint Specific Project的依赖项中。
		</p>
		<h2 id="acceleo">使用Acceleo</h2>
		<p>Acceleo 3实现了MTL标准，并提供了类似于OCL的查询语言（带有一些扩展）。在编辑表达式时，它提供了相对较好的静态验证和自动完成，但AQL更好，更快。对于新的建模者，更喜欢AQL而不是Acceleo / MTL。如果您有使用Acceleo / MTL的现有建模器，将它们转换为使用AQL相对简单，请参阅<a href="https://www.eclipse.org/acceleo/documentation/aql.html#MigratingfromMTLqueries" target="_blank">AQL文档</a>以获取详细信息。</p>
		<p>Acceleo表达式括在括号中： <code>[theExpression/]</code> 。在括号内，您可以编写任何有效的Acceleo表达式，例如使用<code>if</code>和<code>let</code>语句。有关该语言的确切语法和语义，请参阅<a href="https://wiki.eclipse.org/Acceleo" target="_blank">Acceleo文档</a> 。
		</p>
		<p>请注意，VSM中使用的Acceleo表达式<strong>必须</strong>包含在单个括号内。目前无法混合使用Acceleo表达式和固定文本（例如<code>"prefix[someExpression/]suffix"</code> ）。相反，您可以使用Acceleo的字符串操作操作来获得相同的结果： <code>['prefix' + someExpression + 'suffix'/]</code> ）。与此相关，仅当您在格式正确的括号内（即<code>[&lt;cursor&gt;/]</code> ）时，自动完成才有效;如果您只是打开括号但未关闭它（即<code>[&lt;cursor&gt;</code> ），则无法完成。
		</p>
		<p>Acceleo表达式可以透明地从遵循<a href="#service_methods">服务方法</a>约定的Java类调用方法，并且已在VSM中正确声明。请注意，目前仅在Java服务类与<em>VSM</em>位于同一项目中时才有效。您还可以调用Viewpoint规范项目中<code>.mtl</code>文件中定义的Acceleo <em>查询</em> 。为此，您的Viewpoint规范项目应该是Acceleo Generator项目，您可以使用<em>Configure&gt; Toggle Acceleo Nature</em>上下文菜单转换项目。如果要在Sirius项目中使用<code>.mtl</code>文件中的查询，则父<em>Viewpoint</em>元素必须具有引用MTL文件的<em>Java Extension</em>元素，使用<code>com::example::domain::design::module</code>语法（请注意限定名称不包含<code>.mtl</code>或<code>.emtl</code>文件扩展名）。另请确保阅读<a href="http://www.obeonetwork.com/page/building-an-acceleo-generator" target="_blank">http://www.obeonetwork.com/page/building-an-acceleo-generator</a>以确保项目正确构建，或者在部署项目时， <code>.mtl</code>文件中定义的查询可能不可用作为插件。
		</p>
		<p>
			<em>注意：</em>由于EMF 2.9中序列化格式的不兼容更改，如果在建模器定义中使用外部<code>.mtl</code>文件并使用EMF 2.9或更高版本构建建模器插件，则生成的建模器将无法与以前版本的EMF一起使用（因为生成的<code>.emtl</code>文件无法正确加载EMF 2.8及更早版本）。作为参考，EMF 2.9对应于Eclipse 4.3（Kepler）。
		</p>
		<p>Acceleo对于执行查询的元素类型非常精确（并且要求很高）。这通常意味着您可以获得良好的自动完成和有用的验证和诊断。但是，有时Sirius无法静态地确定要评估表达式的模型元素的精确类型。在这种情况下，它假定一个简单的<em>EObject</em> 。如果您知道将使用的实际类型，请在表达式前加上<code>filter(ExpectedType)</code>以帮助Sirius。请注意，如果运行时的实际类型与<code>ExpectedType</code>不兼容，则会以静默方式忽略表达式的其余部分。
		</p>
		<p>在Sirius的上下文中，您可以访问一个特殊功能，可用于跟踪“反向链接”或“交叉引用”。从给定的模型元素中，这使您可以轻松（并且有效地）找到在同一建模项目中的模型和表示范围内引用它的所有元素。此功能可通过<code>eInverse()</code>方法获得，该方法可用于Acceleo表达式内的任何模型元素。
		</p>
		<p>请注意，在大多数情况下，Sirius中的表达式是在定义<em>变量</em>的上下文中计算的。例如，工具定义中的大多数表达式都可以访问变量，告诉它们应用了工具的哪些元素。在某些情况下，这些变量的名称可能与元模型中的要素名称冲突。Acceleo的评估规则（实际上是OCL）优先考虑变量，因此建议始终使用<code>self</code> （或其他表达式）对元模型特征的访问加前缀以避免歧义。举一个具体的例子，假设您有一个表达式<code>"[target/]"</code> ，您希望它可以访问您的某个对象的<code>target</code>特征。如果在存在<code>target</code>变量的上下文中进行求值，则表达式的值将是变量的值， <em>而不是</em>对象属性的值。为避免歧义，在这种情况下，请始终使用<code>"[self.target/]"</code>形式的表达式。
		</p>
		<p>
			<em>注意：</em>由于Eclipse Equinox运行时的内部更改，从Eclipse Luna（4.4）开始，如果直接在工作空间中定义Java服务，则无法从Acceleo 3表达式评估Java服务。这仅影响说明符（不是最终用户）。在开发使用Acceleo表达式并依赖Java服务的建模器时，必须从开发环境启动Eclipse运行时，以在服务作为已部署插件的一部分可用的上下文中测试生成的建模器。从Sirius 3.0开始，您也可以使用AQL语言，其语法与Acceleo 3 / MTL非常相似，但对工作区中的服务没有此限制。
		</p>
		<h2 id="ocl">使用原始OCL</h2>
		<p>Sirius还支持原始OCL表达式，但此支持已弃用，将在以后的版本中删除。OCL表达式必须以<code>ocl:</code>为前缀。如果您使用它，您的Sirius项目必须声明对<code>org.eclipse.sirius.common.ocl</code>插件的依赖关系，以确保在使用建模器的任何地方都可以使用OCL支持。
		</p>
		<p>强烈建议您使用Acceleo，它实现了MTL标准并且是OCL语言的超集，而不是原始OCL。</p>
		<h2 id="custom">提供自定义语言</h2>
		<p>如果您有特定的需求或希望重用现有的自定义语言，Sirius允许您提供自己的语言实现。请注意，Sirius必须能够在语法上明确地从表达式中确定它所写的语言（将其发送给适当的解释器）。实现此目的的最简单方法是定义一个前缀（如<code>ocl:</code> for OCL），以便用您的语言编写的表达式可以与任何其他表达式中的表达式区分开来。
		</p>
		<p>要提供自定义语言，必须<em>至少</em>实现<code>org.eclipse.sirius.common.expressionInterpreter</code>扩展点，并提供<code>org.eclipse.sirius.common.tools.api.interpreter.的实现<code>org.eclipse.sirius.common.tools.api.interpreter.IInterpreter</code>界面。下面的示例显示了Acceleo解释器的注册方式。<code>AcceleoMTLInterpreterProvider</code>是实现<code>IInterpreter</code>接口的一个。
		</p>
		<pre><code>&lt;extension point =“org.eclipse.sirius.common.expressionInterpreter”id =“org.eclipse.sirius.common.acceleo.mtl。AcceleoMTLInterpreter“&gt; &lt;expressionInterpreterProvider interpreterProviderClass =”org.eclipse.sirius.common.acceleo.mtl.business.internal.interpreter。AcceleoMTLInterpreterProvider“/&gt; &lt;/ extension&gt;</code></pre>
		<p>您还可以选择通过实现<code>org.eclipse.sirius.common.proposalProvider</code>扩展点并提供<code>org.eclipse.sirius.common.proposalProvider</code>的实现来为您的语言提供自动完成支持<code>org.eclipse.sirius.common.tools.api.contentassist.IProposalProvider</code>接口。例如，以下是如何注册Acceleo的完成支持（ <code>AcceleoProposalProvider</code>是实现<code>IProposalProvider</code>接口的类）：</p>
		<pre><code>&lt;extension point =“org.eclipse.sirius.common.proposalProvider”&gt; &lt;proposalProvider class =“org.eclipse.sirius.common.acceleo.mtl.ide。AcceleoProposalProvider“interpreter =”org.eclipse.sirius.common.acceleo.mtl。AcceleoMTLInterpreter“/&gt; &lt;/ extension&gt;</code></pre>
		<h2 id="service_methods">编写Java服务</h2>
		<p>查询语言可能支持<em>Java服务</em>的概念， <em>Java服务</em>是用Java编写的方法，可以从Sirius中的解释表达式透明地调用。Acceleo 3包含此支持。您需要做的就是创建一个Java类，其方法遵循Viewpoint规范项目中的一些约定（如下所述），并在VSM中声明类（使用其完全限定的Java名称）。然后，您可以在使用Acceleo或其他支持服务的语言编写的任何解释表达式中使用该类中定义的服务（有关详细信息，请参阅查询语言的文档）。
		</p>
		<p>服务只是一种公共Java方法，遵循一些约定：</p>
		<ul>
			<li>包含该方法的类必须是公共的，并且具有不带参数的默认构造函数。</li>
			<li>该类可以包含许多公共方法（静态或非静态），如果它们遵循正确的约定，则每个方法都将作为服务可见。</li>
			<li>服务方法必须采取的至少一个参数，这应该是一个EMF类型（即<code>EObject</code>或子类型的<code>EObject</code> ）。
			</li>
			<li>服务方法可能需要更多参数，可以是：<ul>
					<li>字符串</li>
					<li>数字</li>
					<li>EMF类型（即<code>EObject</code>或子类型）</li>
					<li>EMF类型的Java集合（请注意， <strong>不</strong>支持数组类型）。
					</li>
				</ul>
			</li>
			<li>服务方法可以返回一个值，该值可以与参数具有相同类型的类型。</li>
		</ul>
		<p>
			<strong>警告：</strong> AQL仅支持Sequences和Set作为集合类型。因此，为了从AQL验证中获得全部好处，建议编写将List或Set作为集合类型返回的服务。
		</p>
		<p>以下是Java服务的示例：</p>
		<pre><code id="ecore_services">public class EObjectServices {public List &lt;EClass&gt; getEClasses（EPackage ePackage）{List &lt;EClass&gt; eClasses = new ArrayList &lt;EClass&gt;（）; //服务代码返回eClasses; }}</code></pre>
		<p>定义服务后，您必须使用Java扩展在VSM中注册它：</p>
		<p>
			<img border="0" src="images/serviceVsmRegistration.png">
		</p>
		<p>然后你可以在支持它的语言表达式中调用它： <code>[aFamily.getFamiliesContainingParents()/]</code> 。 （使用Acceleo语法）调用看起来好像该服务是<code>Family</code>类型的正常功能。调用服务时，调用它的模型元素将用作Java方法的第一个参数。如果在表达式中传递参数，则它们将映射到Java方法的第二个，第三个等参数，假设类型是兼容的。评估服务调用的结果是Java方法的结果。
		</p>
		<p>
			<em>警告：</em> Java服务方法应该是无状态的。无法保证两个模型元素（或甚至同一个）上的相同服务方法的两个连续调用将使用服务类的相同实例。
		</p>
		<p>
			<em>警告：</em>目前Acceleo使用Java服务存在一些限制：</p>
		<ul>
			<li>原始类型不能用作从Acceleo 3表达式调用的服务方法的参数或返回类型。解决方法是使用相应的包装器类型（例如<code>Integer</code>而不是<code>int</code> ）。
			</li>
			<li>从Acceleo 3表达式调用的服务方法不能返回<code>void</code> 。您可以返回任何值，例如target argument（服务方法的第一个参数）。
			</li>
		</ul>
		<h2 id="service_navigation">从解释表达式或Java扩展访问Java服务实现</h2>
		<p>如果要在Java编辑器中查看解释表达式中使用的服务实现，只需将光标放在服务上并按<strong>F3</strong>键盘键即可。点击F3后会出现三种情况：</p>
		<ul>
			<li>如果您的服务不存在于VSM中定义的任何服务类中，或者表达式未完成（缺少括号和参数），则不会发生任何事情。</li>
			<li>如果只有一个实现与您的服务匹配，则直接在Java编辑器中打开它。</li>
			<li>如果许多实现与您的服务调用匹配，则会打开一个向导，允许您选择包含您希望看到的服务实现的Java类：</li>
		</ul>
		<p>
			<img border="0" src="images/serviceNavigation.png">
		</p>
		<p>
			<em>警告：</em>此功能仅适用于<code>service:</code>和<code>aql:</code> interpreters，而不适用于Acceleo 3 / MTL <code>[/]</code>解释器。
		</p>
		<p>您还可以通过在VSM中双击它来打开Java扩展中指定的服务类。如果限定名称对应于现有实现，它将打开Java编辑器。</p>
		<h2 id="standard_services">标准服务</h2>
		<p>Sirius提供了一些可以从任何VSM使用的标准服务，只需将相应的引用（作为<em>Java扩展</em> ）添加到实现类的完全限定名称即可。使用此类服务类时，请确保您的<em>Viewpoint规范项目</em>依赖于提供所述类的Sirius插件。
		</p>
		<h3 id="editing_domain_services">编辑域服务和EMF编辑集成</h3>
		<p>从Sirius 4.0开始， <code>org.eclipse.sirius.ext.emf.edit</code>插件提供了<code>org.eclipse.sirius.ext.emf.edit.EditingDomainServices</code>服务类，可以从任何VSM引用（一旦正确声明）。此类提供了大量方法，这些方法可以直接从解释表达式中作为服务调用访问，从而可以访问<em>EMF Edit</em>框架的许多有用功能，特别是各种<em>项目提供程序</em> 。
		</p>
		<h4 id="GeneralEditingDomainrelatedServices">一般编辑与域相关的服务</h4>
		<p>提供以下一般服务：</p>
		<ul>
			<li>
				<code>getEditingDomain（EObject）</code>
			</li>
			<li>
				<code>isStale（EObject）</code>
			</li>
			<li>
				<code>isControlled（EObject）</code>
			</li>
			<li>
				<code>getAdapterFactory（EObject）</code>
			</li>
			<li>
				<code>getAdapter（EObject，Class）</code>
			</li>
		</ul>
		<h4 id="ItemProvidersServices">物品供应商服务</h4>
		<p>以下接口的大多数公共方法在任何<code>EObject</code>上都可用作服务（通常来自Sirius会话）：</p>
		<ul>
			<li>
				<code>org.eclipse.emf.edit.provider。IItemLabelProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。IItemColorProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。IItemFontProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。IStructuredItemContentProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。ITreeItemContentProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。ITableItemLabelProvider的</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。ITableItemColorProvider</code>
			</li>
			<li>
				<code>org.eclipse.emf.edit.provider。ITableItemFontProvider</code>
			</li>
		</ul>
		<p>在所有情况下，还提供了<code>getXXXProvider()</code>服务方法（例如<code>getLabelProvider(EObject)</code> ，它返回项目提供程序本身（或<code>null</code> ）。使用与元素编辑域关联的<code>AdapterFactory</code>返回的<code>ItemProviderAdapter</code>定位项提供程序。这假设所述域是<code>AdapterFactoryEditingDomain</code> （在Sirius中实际上是真的，它使用继承自此的<code>TransactionalEditingDomain</code> ）。
		</p>
		<p>如果找不到相应的项提供程序，则所有服务方法都返回显式<code>null</code>值（如果返回布尔值的服务，则返回<code>false</code> ）。请注意，这与实际返回<code>null</code>或<code>false</code>的项提供程序方法无法区分。
		</p>
		<h4 id="ItemPropertyRelatedServices">物品相关服务</h4>
		<p>可以使用以下服务获取与元素及其<code>IItemPropertySource</code>关联的<code>IItemPropertyDescriptors</code> ：</p>
		<ul>
			<li>
				<code>getItemPropertySource（EObject）</code>
			</li>
			<li>
				<code>getPropertyDescriptors(EObject)</code>获取元素的<strong>所有</strong> <code>IItemPropertyDescriptor</code> 。
			</li>
			<li>
				<code>getPropertyDescriptorForFeature(EObject, String)</code>获取元素特定功能的<code>IItemPropertyDescriptor</code></li>
		</ul>
		<p>以下服务都将特征名称作为第二个参数（作为服务调用时的第一个显式参数），可以访问与相应元素的特征相关联的<code>IItemPropertyDescriptor</code>中的相应方法：</p>
		<ul>
			<li>
				<code>getPropertyDescriptorPropertyValue（）</code>
			</li>
			<li>
				<code>isPropertyDescriptorPropertySet（）</code>
			</li>
			<li>
				<code>canSetPropertyDescriptorProperty（）</code>
			</li>
			<li>
				<code>resetPropertyDescriptorPropertyValue（）</code>
			</li>
			<li>
				<code>setPropertyDescriptorPropertyValue（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorCategory（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorDescription（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorDisplayName（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorFilterFlags（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorHelpContextIds（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorId（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorLabelProvider（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorFeature（）</code>
			</li>
			<li>
				<code>isPropertyDescriptorMany（）</code>
			</li>
			<li>
				<code>getPropertyDescriptorChoiceOfValues（）</code>
			</li>
			<li>
				<code>isPropertyDescriptorMultiLine（）</code>
			</li>
			<li>
				<code>isPropertyDescriptorSortChoices（）</code>
			</li>
		</ul>
		<h4 id="CommandrelatedServices">与命令有关的服务</h4>
		<p>可以使用一系列服务方法来调用<code>ItemProviderAdapter</code>的各种<code>createXXXCommand()</code>方法中提供的标准EMF命令。请注意，与仅返回<code>Command</code>实例的<code>createXXXCommand()</code>方法相反， <code>createXXXCommand()</code>公开的服务方法将直接在编辑域<code>CommandStack</code>上<strong>执行</strong>命令。
			<br>它们的名称遵循<code>perfomXXXCommand()</code>模式来反映这一点。它们都返回<code>self</code>元素（调用服务的<code>EObject</code> 。
		</p>
		<p>与命令相关的服务包括：</p>
		<ul>
			<li>
				<code>performSetCommand（）</code>
			</li>
			<li>
				<code>performUnsetCommand（）</code>
			</li>
			<li>
				<code>performAddCommand（）</code>
			</li>
			<li>
				<code>performRemoveCommand（）</code>
			</li>
			<li>
				<code>performReplaceCommand（）</code>
			</li>
			<li>
				<code>performMoveCommand（）</code>
			</li>
		</ul>
		<p>这些服务的实现委托给<code>ItemProviderAdapter.createCommand()</code>方法，因此将考虑在<code>ItemProviderAdapter</code>的实现中进行的任何自定义。
		</p>
	</body>
</html><html id="1904.sB.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="chapter" id="sB">
            <div class="headl">
               <div class="headr">
                  <h1>§B版本之间的变化</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sB.html">§B版本之间的变化</a></li>
                  <li><a href="#sB.1">§B.1版本之间的段落发生了变化</a></li>
                  <li><a href="#sB.2">§B.2版本之间的增加</a></li>
               </ul>
            </div>
            <div class="sect depth2" id="sB.1">
               <h2 class="sect">§B.1版本之间的段落发生了变化<a class="img" href="sB.html#sB.1" title="PermaLinkto§B.1版本之间的段落发生了变化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.1.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.html#sB.1.1" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s3.html#s3.2.a" title="§3.2。（a）with clause" class="sect">§3.2。（a）</a> ： <strong>参数映射</strong><p>禁止角色接口中的参数映射。
                           			
                        </p>
                     </li>
                     <li><a href="s4.html#s4.5.d" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ： <strong>替换绑定</strong><p>禁止不安全地使用多态和原始类型转换。
                           			
                        </p>
                     </li>
                     <li><a href="s6.html#s6.1.a" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法的签名</strong><p>使两个方法通用，以便可以使用返回值而无需进行转换。
                           				
                        </p>
                     </li>
                     <li><a href="s7.html#s7.2" title="§7.2受限制的角色" class="sect">§7.2</a> ：受<strong>限制的角色</strong><p>改进的解释。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.html#sB.1.2" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.html#s1.2.1.e" title="§1.2.1。（e）角色特征" class="sect">§1.2.1。（e）</a> ： <strong>角色特征的可见性</strong><p>添加了澄清说明角色可以始终访问其封闭团队有权访问的所有功能。
                           				
                        </p>
                     </li>
                     <li><a href="s2.html#s2.1.2.e" title="§2.1.2。（e）没有自由类型参数" class="sect">§2.1.2。（e）</a> ： <strong>通用角色/基础</strong><p>放宽了有关通用绑定角色的规则。这种变化也包含了先前在<a href="s4.html#s4.1.b" title="§4.1.(b) Prerequisite: Class binding" class="sect">§4.1中</a>的具体限制<a href="s4.html#s4.1.b" title="§4.1。（b）先决条件：类绑定" class="sect">。（b）</a> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.html#s3.1.i" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a>和<a href="s3.html#s3.5.f" title="§3.5。（f）速记定义" class="sect">§3.5。（f）</a> ： <strong>速记标注的可见性</strong><p>由速记标注绑定定义的角色方法现在可以指定可见性修饰符（另请参见<a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ），否则它将继承其绑定基本方法/字段的可见性修饰符。
                           				
                        </p>
                     </li>
                     <li><a href="s3.html#s3.1.j" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.html#s3.5.h" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断标注的可见性</strong><p>推断为标注绑定的角色方法是<code>public</code> （通过接口推断）或从自我调用/字段访问推断的<code>private</code> 。
                           				
                        </p>
                     </li>
                     <li><a href="s3.html#s3.5.h" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>没有明确使用推断的字段</strong><p>已添加澄清说明，无法显式调用为推断的字段调用生成的访问器方法。
                           				
                        </p>
                     </li>
                     <li><a href="s4.html#s4.1.b" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>没有通用角色的callin</strong><p>已经明确规定，通用角色无法定义callin绑定。
                           				
                        </p>
                     </li>
                     <li><a href="s4.html#s4.2.d" title="§4.2。（d）Callin方法" class="sect">§4.2。（d）</a> ： <strong>Callin方法</strong><p>稍微改写并扩展规则以明确表示使用第二级callin绑定确实可以拦截callin方法。
                           				
                        </p>
                     </li>
                     <li><a href="s6.html#s6.1.a" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法<code>getAllRoles</code></strong><p>更高精度：仅回答<em>绑定</em>角色。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.html#sB.1.3" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.html#s1.2.4.c" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字的语法</strong><p>以前，不支持语法<code>R&lt;@t&gt;.class</code> 。此限制已被删除。
                           					
                        </p>
                     </li>
                     <li><a href="s1.html#s1.3" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ： <strong>团队扩展非团队类</strong><p>以前， <code>org.objectteams.Team</code>是所有团队课程的超级班级。因此，团队无法扩展非团队类。通过引入所有团队的新超类型，界面<code>org.objectteams. ，已经消除了这一限制<code>org.objectteams.ITeam</code> 。当成员被移动到新界面时，此更改也会影响<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中的</a>某些段落。
                           					
                        </p>
                     </li>
                     <li><a href="s1.html#s1.5.e" title="§1.5。（e）不同超级之间的优先权" class="sect">§1.5。（e）</a> ： <strong>不同隐式超级之间的优先权</strong><p>纠正了不同超级中优先级规则的不一致性：主要规则一直是隐式继承比显式继承更强，但是，对于不同隐式超级中的优先级，定义了不同的规则。<br>这已被改变，使得不同的隐<em>式</em>超级优先于其封闭团队的优先级，使得来自<em>隐式</em>超级团队的角色与来自<em>显式</em>超级团队的角色更紧密相关。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.1.2.b" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）</a> ： <strong>放宽了对基类循环的规则</strong><p><a href="s2.html#s2.1.2.b" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）中</a>定义的基类循环不再是错误，而是可配置警告。但是，在存在基类循环的情况下，不允许调用（第<a href="s2.html#s2.4.2" title="§2.4.2 Role creation via a regular constructor" class="sect">3.1节</a> <a href="s3.html#s3.1.a" title="§3.1。（a）先决条件：类绑定" class="sect">（a）</a> ）和基本构造函数调用（第<a href="s2.html#s2.4.2" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2节</a> ）。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ： <strong>更改了角色绑定歧义的处理</strong><p>明确的绑定歧义不再是（可抑制的）编译器错误，而是由声明<code>org.objectteams.的需要发出信号<code>org.objectteams.LiftingFailedException</code> 。通过这种方式，诊断可以从团队中非常不特定的位置移动到那些在运行时可能因提升失败而受到影响的应用程序。虽然通常不建议忽略任何<code>LiftingFailedException</code>但在<a href="s2.html#s2.3.4.b" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4。（b）中</a>提到的一些<a href="s2.html#s2.3.4.b" title="§2.3.4。（b）明确的歧义" class="sect">极端</a>情况下，捕获此异常仍然有意义。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.4.c" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ： <strong>进一步限制callin绑定后的结果映射</strong><p>澄清<code>after</code> callin绑定<code>after</code>无法使用<code>-&gt;</code>标记来映射结果值。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.8.a" title="§4.8。（a）优先权声明" class="sect">§4.8。（a）</a> ： <strong>影响callin绑定<code>after</code>优先声明。</strong><p>虽然以前优先声明的效果不明确，但已经定义优先声明中元素的顺序会影响它们的<em>优先级，</em>类似于<a href="s5.html#s5.1" title="§5.1团队激活的影响" class="sect">§5.1</a> 。这意味着与先前的实现相比， <code>after</code>绑定的执行顺序现在是颠倒的。为了在程序中可视化，现在必须使用关键字<code>after</code>标记后绑定的优先声明。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.10" title="§4.10通用callin绑定" class="sect">§4.10</a> ， <a href="s4.html#s4.10.a" title="§4.10。（a）新鲜型参数" class="sect">§4.10。（a）</a> ： <strong>通用的callin绑定</strong><p><a href="s4.html#s4.10.e" title="§4.10.(e) Propagating type parameters" class="sect">稍作</a>修改，为新段落<a href="s4.html#s4.10.e" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）留出</a>空间。
                        </p>
                     </li>
                     <li><a href="s5.html#s5.4.1.a" title="§5.4.1。（a）方法绑定警卫" class="sect">§5.4.1。（a）</a> ： <strong>定期装订守卫的范围</strong><p>在常规方法绑定防护中删除了关于特殊标识符<code>result</code>的错误句子。由于在评估保护之前应用了参数映射，因此可以通过结果映射（ <a href="s4.html#s4.4.c" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ）访问结果值。此外，这句话实际上混淆了基础和角色方面。
                           	
                        </p>
                     </li>
                     <li><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ， <a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="sect">§A.3.3</a> ： <strong>语法：泛型方法绑定</strong><p>方法绑定中可能的类型参数的位置已经明确。</p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.1.4">
                  <h4 class="subsect">（4） <span class="title">在OTJLD 1.3和OTJLD 1.4之间</span><a class="img" href="sB.html#sB.1.4" title="PermaLink to（4）OTJLD 1.3和OTJLD 1.4之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.html#s2.1.2.d" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ： <strong>没有按需基础进口</strong><p>已经澄清，基础进口不能是按需进口（使用通配符） <code>.*</code> ）。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth2" id="sB.2">
               <h2 class="sect">§B.2版本之间的增加<a class="img" href="sB.html#sB.2" title="PermaLinkto§B.2版本之间的增加"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§B</a></span></h2>
               <div class="subsect depth3" id="sB.2.1">
                  <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.html#sB.2.1" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.html#s1.2.4.c" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字</strong><p>使现有功能显式化并为外化角色引入新的限定类文字。
                           				
                        </p>
                     </li>
                     <li><a href="s3.html#s3.1.j" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.html#s3.5.h" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断出的标注</strong><p>新功能。
                           				
                        </p>
                     </li>
                     <li><a href="s4.html#s4.6.a" title="§4.6。（a）超级班的私人方法" class="sect">§4.6。（a）</a> ： <strong>来自超级类的Callin绑定私有方法</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                     <li><a href="s4.html#s4.9" title="§4.9Callin继承" class="sect">§4.9</a> ： <strong>Callin继承</strong><p>澄清了指定不充分或解释不充分的问题，具体而言：</p>
                        <ul>
                           <li>callin绑定对遗传或被覆盖的基本方法的影响（ <a href="s4.html#s4.9.1" title="§4.9.1基础侧继承" class="sect">§4.9.1</a> ）。
                           </li>
                           <li>callin绑定和基本方法与协变返回类型的<a href="s4.html#s4.9.3" title="§4.9.3 Covariant return types" class="sect">相互作用</a> （ <a href="s4.html#s4.9.3" title="§4.9.3协变返回类型" class="sect">§4.9.3</a> ）</li>
                        </ul>
                     </li>
                     <li><a href="s4.html#s4.10" title="§4.10通用callin绑定" class="sect">§4.10</a> ： <strong>通用替换绑定</strong><p>通过使用类型参数调整<a href="s4.html#s4.5.d" title="§4.5。（d）打字规则" class="sect">§4.5。（d）中</a>引入的替换绑定的类型安全性，并具有所需的灵活性。
                           				
                        </p>
                     </li>
                     <li><a href="s7.html#s7.2.b" title="§7.2。（b）受限阵列" class="sect">§7.2。（b）</a> ： <strong>受限制的阵列</strong><p>添加了必要的限制。
                           				
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.2">
                  <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.html#sB.2.2" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s1.html#s1.2.2.h" title="§1.2.2。（h）外化创作" class="sect">§1.2.2。（h）</a> ： <strong>外化创作</strong><p>使用值参数和更改的标题添加了替代语法。</p>
                     </li>
                     <li><a href="s1.html#s1.2.5.f" title="§1.2.5。（f）进口角色档案" class="sect">§1.2.5。（f）</a> ： <strong>角色文件中的导入</strong><p>添加了缺少的规则，用于定义角色文件中的导入效果。</p>
                     </li>
                     <li><a href="s1.html#s1.3.1.c" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">§1.3.1。（c）</a> ： <strong>@</strong> <a href="s1.html#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">Override</a> <strong>角色注释</strong><p>常规的<code>@Override</code>注释（Java≥5）也已扩展为适用于角色类。
					
                        </p>
                     </li>
                     <li><a href="s1.html#s1.3.1.k" title="§1.3.1。（k）协变返回类型" class="sect">§1.3.1。（k）</a> ： <strong>协变返回类型</strong><p>在存在隐式和显式继承的情况下协变返回类型的必要约束。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ： <strong>绑定到最终基类</strong><p>已经补充说，绑定到最终基类现在也被视为解封装。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.2.f" title="§2.2。（f）模糊降低" class="sect">§2.2。（f）</a> ： <strong>模糊降低</strong><p>添加了一个诊断来检测可能意图降低但由于声明的类型是<code>java.lang.而失败的情况<code>java.lang.Object</code> ，这使得潜在的降低翻译变得不必要并且因此是模糊的。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.3.2.e" title="§2.3.2。（e）通用宣布解除" class="sect">§2.3.2。（e）</a> ： <strong>通用声明提升</strong><p>支持将不相关的基类型传递到声明提升的相同方法中。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.6.g" title="§2.6。（g）通过基准参考进行解封装" class="sect">§2.6。（g）</a> ： <strong>通过基准参考进行解封装</strong><p>将解封装扩展到两个以上的位置。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.3.f" title="§4.3。（f）基本超级电话" class="sect">§4.3。（f）</a> ： <strong>基本超级呼叫</strong><p>支持base直接调用绑定基本方法的超级版本，从而绕过精确绑定的基本方法以及与此基本方法或其超级版本相关的任何其他callins。
                           					
                        </p>
                     </li>
                     <li><a href="s5.html#s5.4.b" title="§5.4。（b）无副作用" class="sect">§5.4。（b）</a> ： <strong>守卫谓词的副作用</strong><p>将有关未来功能的先前注释迁移到常规段落。</p>
                     </li>
                     <li><a href="s5.html#s5.4.c" title="§5.4。（c）例外情况" class="sect">§5.4。（c）</a> ： <strong>守卫谓词的例外情况</strong><p>澄清从保护谓词抛出的异常的影响。</p>
                     </li>
                     <li><strong>§6.2</strong> <a href="s6.html#s6.2.d" title="§6.2。（d）例外情况" class="sect">。（d）</a> ： <strong>LiftingVetoException</strong><p>添加了大部分内部<code>LiftingVetoException</code>文档以及它如何在客户端代码中实际使用。
                           				    
                        </p>
                     </li>
                     <li><a href="s6.html#s6.2.e" title="§6.2。（e）角色迁移" class="sect">§6.2。（e）</a> ： <strong>角色迁移</strong><p>添加了两个接口，以将迁移功能添加到角色类。
                           				    
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.3">
                  <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.html#sB.2.3" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s2.html#s2.1.1" title="§2.1.1绑定接口" class="sect">§2.1.1</a> ：将<strong>角色绑定到基接口</strong><p><a href="s2.html#s2.1.1" title="§2.1.1绑定接口" class="sect">§2.1.1</a>中提到的实施限制已被大部分删除。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.3.1.d" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> ： <strong>微调角色实例化</strong><p>已经定义了注释用于修改提升的语义以便提高性能。此外，还添加了一个新的部分作为<a href="s6.html#s6.3" title="§6.3注释" class="sect">§6.3，</a>以总结本文档中定义的注释类型。
                           					
                        </p>
                     </li>
                     <li><a href="s2.html#s2.3.5" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ： <strong>解除问题的后果</strong><p>在<a href="s2.html#s2.3.4" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a>澄清了<code>LiftingFailedException</code> （ <code>LiftingFailedException</code> <a href="s6.html#s6.2.d" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）确实是一个经过检查的异常之后，又添加了一个子节来定义这种异常在各种程序情况下的后果。
                           					
                        </p>
                     </li>
                     <li><a href="s3.html#s3.1.k" title="§3.1。（k）通用方法的标注" class="sect">§3.1。（k）</a> ： <strong>通用方法的标注</strong><p>添加了关于callout绑定如何引用泛型基本方法的规则。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.1.b" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>Callin以“不可授予的”角色进行约束</strong><p>现在甚至可以在“unliftable”角色中定义Callin绑定。
                           	
                        </p>
                     </li>
                     <li><a href="s4.html#s4.1.h" title="§4.1。（h）封闭类的方法" class="sect">§4.1。（h）</a> ： <strong>绑定团队方法</strong><p>callin绑定<code>before</code>和<code>after</code>现在也可以绑定到封闭类的方法。
                           	
                        </p>
                     </li>
                     <li><a href="s4.html#s4.8.d" title="§4.8。（d）多个优先权陈述" class="sect">§4.8。（d）</a> ： <strong>合并优先声明时的顺序</strong><p>阐明了如何合并多个优先级声明，这是未指定的，因为C3算法需要有序输入，但未指定此顺序。
                           					
                        </p>
                     </li>
                     <li><a href="s4.html#s4.10.e" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ： <strong>在callin绑定中传播类型参数</strong><p>除了捕获协变返回类型之外，callin绑定还可以声明类型参数，以便将通用性从其基本方法传播到角色方法。
                           	
                        </p>
                     </li>
                     <li><a href="s5.html#s5.3.d" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> ： <strong>配置隐式激活</strong><p>添加了用于配置隐式团队激活的机制。默认值已更改为不应用隐式激活。<a href="s5.html#s5.3" title="§5.3隐式团队激活" class="sect">§5.3中</a>也增加了相应的注释</p>
                     </li>
                     <li><a href="s9.html#s9.2.1.a" title="§9.2.1。（a）实例约束类型参数" class="sect">§9.2.1。（a）</a> ： <strong>实例约束类型参数</strong><p>类型锚现在也可以应用于类型参数，从而在类型参数上表达一种新的约束。
                           	
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="subsect depth3" id="sB.2.4">
                  <h4 class="subsect">（4） <span class="title">OTJLD 1.3之后</span><a class="img" href="sB.html#sB.2.4" title="PermaLink至（4）OTJLD 1.3之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <ul>
                     <li><a href="s4.html#s4.1.i" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ： <strong>致电建设者</strong><p>绑定后的callin现在也可以应用于基类的构造函数。
                           					
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="sA.html" rel="prev">&lt;&lt;§AOT / J语法</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html><html id="3659.Xtend_language.html" dir="ltr"></html><html dir="ltr">
<head>
<title>的Xtend</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="Xpand Documentation"></link>
<link rel="up" href="core_reference.html" title="Xpand / Xtend / Check Reference"></link>
<link rel="prev" href="Check_language.html" title="Check"></link>
<link rel="next" href="xpand_reference_introduction.html" title="Xpand2"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">的Xtend</h1>
<div class="section" title="的Xtend">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Xtend_language"></a> <span class="emphasis"><em>的Xtend</em></span>
</h2>
</div>
</div>
</div>
<a name="N10DCF" class="indexterm"></a>
<p>像表达式子语言一样，它总结了<span class="emphasis"><em>Xpand</em></span>框架提供的所有其他文本语言的表达式语法，还有另一种常用语言<span class="emphasis"><em>Xtend</em></span> 。</p>
<p>该语言提供了定义独立操作和非侵入式元模型扩展的丰富库的可能性<a name="N10DDE" class="indexterm"></a>基于Java方法或<span class="emphasis"><em>Xtend</em></span>表达式。可以从基于表达式框架的所有其他文本语言引用这些库。</p>
<div class="section" title="Xtend文件">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10DE7"></a> Xtend文件</h3>
</div>
</div>
</div>
<a name="N10DEA" class="indexterm"></a>
<p>
<a name="N10DEE" class="indexterm"></a> Xtend文件必须驻留在已使用的执行上下文的Java类路径中。文件扩展名必须为<code class="filename">*.ext</code> 。我们来看看Xend文件。</p>
<pre class="programlisting">import my :: metamodel; extension other :: ExtensionFile; / ** * Documentation * / anExpressionExtension（String stringParam）：doingStuff（with（stringParam））; / ** * java扩展只是映射* / String aJavaExtension（String param）：JAVA my。JavaClass.staticMethod（java.lang中。String）;</pre>
<p>该示例显示以下语句：</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>进口报表</p>
</li>
<li class="listitem">
<p>扩展导入语句</p>
</li>
<li class="listitem">
<p>表达式或java扩展</p>
</li>
</ol>
</div>
</div>
<div class="section" title="评论">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10E05"></a>评论<a name="N10E08" class="indexterm"></a>
</h3>
</div>
</div>
</div>
<p>我们有单行和多行评论。单行注释的语法是：</p>
<pre class="programlisting">//我的评论</pre>
<p>多行注释的写法如下：</p>
<pre class="programlisting">/ *我的多行评论* /</pre>
</div>
<div class="section" title="导入语句">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10E15"></a>导入语句</h3>
</div>
</div>
</div>
<p>使用导入<a name="N10E1A" class="indexterm"></a>语句一可以导入不同类型的名称空间。（参见表达式框架参考文档）。</p>
<p>语法是：</p>
<pre class="programlisting">import my :: imported :: namespace;</pre>
<p>Xtend不支持静态导入或任何类似的概念。因此，以下是不正确的语法：</p>
<pre class="programlisting">import my :: imported :: namespace :: *; //错！import my :: Type; //错！</pre>
</div>
<div class="section" title="扩展进口声明">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10E26"></a>扩展进口声明</h3>
</div>
</div>
</div>
<a name="N10E29" class="indexterm"></a>
<p>您可以使用扩展语句导入另一个Xtend文件。语法是：</p>
<pre class="programlisting">extension fully :: qualified :: ExtensionFileName;</pre>
<p>请注意，未指定文件扩展名（ <code class="filename">*.ext</code> ）。</p>
<div class="section" title="重新导出扩展">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10E35"></a>重新导出扩展</h4>
</div>
</div>
</div>
<p>如果要将扩展名从其他扩展文件与本地扩展名一起导出，可以添加关键字<code class="methodname">reexport</code> <a name="N10E3D" class="indexterm"></a>到相应的扩展导入语句的末尾。</p>
<pre class="programlisting">extension fully :: qualified :: ExtensionFileName reexport;</pre>
</div>
</div>
<div class="section" title="扩展">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10E43"></a>扩展</h3>
</div>
</div>
</div>
<p>简单表达式扩展的语法如下：</p>
<pre class="programlisting">ReturnType extensionName（ParamType1 paramName1，ParamType2 ...）：expression-using-params;</pre>
<p>
<span class="bold">
<strong>例：</strong>
</span>
</p>
<pre class="programlisting">String getterName（NamedElement ele）：'get'+ ele.name.firstUpper（）;</pre>
<div class="section" title="扩展调用">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10E50"></a>扩展调用<a name="N10E53" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>如何调用扩展有两种不同的方法。它可以像函数一样调用：</p>
<pre class="programlisting">getterName（myNamedElement）</pre>
<p>调用扩展的另一种方法是通过“成员语法”：</p>
<pre class="programlisting">myNamedElement.getterName（）</pre>
<p>对于成员语法中的任何调用，目标表达式（成员）将映射到第一个参数。因此，两种句法形式都做同样的事情。</p>
<p>重要的是要理解扩展不是类型系统的成员，因此，它们不能通过反射访问，并且您不能使用它们专门化或覆盖操作。</p>
<p>表达式评估引擎在查找扩展名之前首先查找适当的操作，换句话说，操作具有更高的优先级。</p>
</div>
<div class="section" title="类型推断">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10E66"></a>类型推断<a name="N10E69" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>对于大多数扩展，您不需要指定返回类型， <a name="N10E6E" class="indexterm"></a>因为它可以从指定的表达式派生。特别的是，这种扩展的静态返回类型取决于使用的上下文。</p>
<p>例如，如果您有以下扩展名</p>
<pre class="programlisting">asList（Object o）：{o};</pre>
<p>调用</p>
<pre class="programlisting">asList（ '文本'）</pre>
<p>具有静态类型<code class="classname">List[String]</code> 。这意味着你可以打电话</p>
<pre class="programlisting">asList（ '文本'）。得到（0）.toUpperCase（）</pre>
<p>表达式是静态类型安全的，因为它的返回类型是自动派生的。</p>
<p>即使您明确指定“ <code class="classname">Void</code> ”，也<span class="emphasis"><em>始终</em></span>存在返回值，无论您是否指定它。</p>
<p>请参阅以下示例。</p>
<pre class="programlisting">modelTarget.ownedElements.addAllNotNull（modelSource.contents.duplicate（））</pre>
<p>在此示例中， <code class="methodname">duplicate()</code>多态方式调度<a name="N10E94" class="indexterm"></a> 。其中两个扩展可能如下所示：</p>
<pre class="programlisting">虚空重复（Realization realization）：实现。Specifier（）。duplicate（） - &gt;实现。Realizer（）。duplicate（）; create target :: Class duplicate（source :: Class）：...;</pre>
<p>如果“ <code class="classname">Realization</code> ”包含在“ <code class="methodname">contents</code> ”的“名单<code class="varname">modelSource</code> ”中，“ <code class="methodname">Realizer</code>的”的“ <code class="classname">Realization</code> ”将被添加到“ <code class="varname">ownedElements</code>了“的名单<code class="varname">modelTarget</code> ”。如果您不想添加包含的元素是“实现”的情况，您可以将扩展名更改为：</p>
<pre class="programlisting">虚空重复（Realization realization）：实现。Specifier（）。duplicate（） - &gt;实现。Realizer（）。duplicate（） - &gt; {};</pre>
</div>
<div class="section" title="递归">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10EB3"></a>递归</h4>
</div>
</div>
</div>
<p>只有一个例外：对于递归扩展<a name="N10EB8" class="indexterm"></a><a name="N10EBB" class="indexterm"></a>无法推断返回类型，因此您需要明确指定它：</p>
<pre class="programlisting">String fullyQualifiedName（NamedElement n）：n.parent == null？n.name：fullyQualifiedName（n.parent）+'::'+ n.name;</pre>
<p>递归扩展在静态上下文中是非确定性的，因此，必须指定返回类型。</p>
</div>
<div class="section" title="缓存扩展">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10EC5"></a>缓存扩展<a name="N10EC8" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>如果您经常调用没有副作用的扩展，您希望缓存每组参数的结果，以提高性能。你可以添加关键字' <code class="code">cached</code> ' <a name="N10ED2" class="indexterm"></a>扩展以实现这一目标：</p>
<pre class="programlisting">cached String getterName（NamedElement ele）：'get'+ ele.name.firstUpper（）;</pre>
<p>该<code class="methodname">getterName</code>将为每个被计算一次<code class="classname">NamedElement</code> 。</p>
</div>
<div class="section" title="私人扩展">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10EE0"></a>私人扩展<a name="N10EE3" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>默认情况下，所有扩展都是公共的，即它们在扩展文件外部可见。如果您想要隐藏扩展程序，可以添加关键字“ <code class="methodname">private</code> ” <a name="N10EED" class="indexterm"></a>在他们面前：</p>
<pre class="programlisting">private internalHelper（NamedElement ele）：//实现....;</pre>
</div>
</div>
<div class="section" title="Java扩展">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N10EF3"></a> Java扩展</h3>
</div>
</div>
</div>
<p>在某些情况下，人们确实希望从表达式内部调用Java方法。这可以通过提供Java扩展来完成<a name="N10EF8" class="indexterm"></a><a name="N10EFB" class="indexterm"></a> ：</p>
<pre class="programlisting">Void myJavaExtension（String param）：JAVA my。Type.someMethod（java.lang中。String）;</pre>
<p>签名与任何其他扩展名相同。它的语法是：</p>
<pre class="programlisting">JAVA完全合格。Type.someMethod（我的。ParamType1，我的。ParamType2，...）;</pre>
<p>请注意，您不能使用任何导入的命名空间。您必须以完全限定的方式指定类型，方法和参数类型。</p>
<p>
<span class="bold">
<strong>例：</strong>
</span>
</p>
<p>如果已定义以下Java扩展：</p>
<pre class="programlisting">String concat（String a，String b）：JAVA my。Helper.concat（java.lang中。String，java.lang。串）;</pre>
<p>并且您有以下Java类：</p>
<pre class="programlisting">打包我; public class Helper {public String concat（String a，String b）{return a + b; }}</pre>
<p>表达式</p>
<pre class="programlisting">concat（'你好'，'世界！“）”你好“.concat（'世界！“）</pre>
<p>两个结果都是调用Java方法<code class="methodname">void concat(String a, String b).</code>
</p>
<div class="section" title="静态与非静态调用">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10F1D"></a>静态与非静态调用</h4>
</div>
</div>
</div>
<p>Java扩展的实现被重定向到Java类中的公共方法。如果该方法未声明为static，则需要Java类具有默认构造函数。Xtend将为每次调用实例化该类。</p>
</div>
<div class="section" title="IExecutionContextAware">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N10F22"></a> IExecutionContextAware <a name="N10F25" class="indexterm"></a>
</h4>
</div>
</div>
</div>
<p>使用Java扩展可以访问ExecutionContext <a name="N10F2A" class="indexterm"></a> ，它可以检索有关调用的详细运行时信息。要在Java扩展中使用当前的ExecutionContext，该类必须实现<code class="classname">org.eclipse.xtend.expression.IExecutionContextAware</code>
</p>
<pre class="programlisting">public interface IExecutionContextAware {void setExecutionContext（ExecutionContext ctx）; }</pre>
<p>调用的方法不能是静态的。</p>
</div>
</div>
<div class="section" title="创建扩展（模型转换）">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="create_extension"></a>创建扩展（模型转换）</h3>
</div>
</div>
</div>
<p><span class="emphasis"><em>Xtend</em></span>语言支持对模型转换的额外支持<a name="N10F3E" class="indexterm"></a> 。这个概念叫做<span class="emphasis"><em>创建扩展</em></span>和<a name="N10F45" class="indexterm"></a><a name="N10F4A" class="indexterm"></a>它像往常一样被解释得更加全面。</p>
<p>模型中包含的元素通常被多次引用。考虑以下模型结构：</p>
<pre class="programlisting">P / \ C1 C2 \ / R.</pre>
<p>包<code class="varname">P</code>包含两个类<code class="varname">C1</code>和<code class="varname">C2</code> 。<code class="varname">C1</code>包含<code class="varname">C2</code>类型的参考<code class="varname">R</code> （ <code class="varname">P</code>也参考<code class="varname">C2</code> ）。</p>
<p>我们可以编写以下扩展，以便将Ecore（EMF）模型转换为我们的元模型（Package，Class，Reference）。</p>
<pre class="programlisting">package toPackage（EPackage x）：let p = new Package：p.ownedMember.addAll（x.eClassifiers.toClass（）） - &gt; p; class toClass（EClass x）：let c = new Class：c.attributes.addAll（x.eReferences.toReference（）） - &gt; c;引用引用（EReference x）：令r = new引用：r.setType（x.eType.toClass（）） - &gt; r;</pre>
<p>对于具有上述结构的Ecore模型，结果将是：</p>
<pre class="programlisting">P / \ C1 C2 | R  -  C2</pre>
<p>发生了什么？<code class="varname">C2</code>类已创建2次（包含限制一次，参考<code class="varname">R</code>另一次也引用<code class="varname">C2</code> ）。我们可以通过添加' <code class="methodname">cached</code> '关键字来解决问题<a name="N10F82" class="indexterm"></a>到第二个扩展：</p>
<pre class="programlisting">缓存toClass（EClass x）：let c = new Class：c.attributes.addAll（c.eAttributes.toAttribute（）） - &gt; c;</pre>
<p>过程如下：</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>开始创造<code class="varname">P</code>
</p>
<div class="orderedlist">
<ol class="orderedlist" type="a">
<li class="listitem">
<p>开始创建<code class="varname">C1</code> （包含在<code class="varname">P</code> ）</p>
<div class="orderedlist">
<ol class="orderedlist" type="i">
<li class="listitem">
<p>开始创建<code class="varname">R</code> （包含在<code class="varname">C1</code> ）</p>
<div class="orderedlist">
<ol class="orderedlist" type="A">
<li class="listitem">
<p>开始创建<code class="varname">C2</code> （从<code class="varname">R</code>引用）</p>
</li>
<li class="listitem">
<p>结束（结果<code class="varname">C2</code>被缓存）</p>
</li>
</ol>
</div>
</li>
<li class="listitem">
<p>结束<code class="varname">R</code>
</p>
</li>
</ol>
</div>
</li>
<li class="listitem">
<p>结束<code class="varname">C1</code>
</p>
</li>
<li class="listitem">
<p>开始获取缓存<code class="varname">C2</code> （包含在<code class="varname">P</code> ）</p>
</li>
</ol>
</div>
</li>
<li class="listitem">
<p>结束P.</p>
</li>
</ol>
</div>
<p>所以这很有效。我们将获得预期的结构。但是循环依赖呢？例如， <code class="varname">C2</code>可以包含<code class="varname">C1</code>类型的<code class="classname">Reference</code> <code class="varname">R2</code> （双向引用）：</p>
<p>转换将发生如下：</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>开始创造<code class="varname">P</code>
</p>
<div class="orderedlist">
<ol class="orderedlist" type="a">
<li class="listitem">
<p>开始创建<code class="varname">C1</code> （包含在<code class="varname">P</code> ）</p>
<div class="orderedlist">
<ol class="orderedlist" type="i">
<li class="listitem">
<p>开始创建<code class="varname">R</code> （包含在<code class="varname">C1</code> ）</p>
<div class="orderedlist">
<ol class="orderedlist" type="A">
<li class="listitem">
<p>开始创建<code class="varname">C2</code> （从<code class="varname">R</code>引用）</p>
<div class="orderedlist">
<ol class="orderedlist" type="I">
<li class="listitem">
<p>开始创建<code class="varname">R2</code> （包含在<code class="varname">C2</code> ）</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>开始创建<code class="varname">C1</code> （从<code class="varname">R1</code>引用）......OOPS！</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<p>
<code class="varname">C1</code>已经在创建，并且在堆栈减少之前不会完成。僵局！问题是缓存缓存了返回值，但到目前为止还没有返回<code class="varname">C1</code> ，因为它仍处于构造状态。</p>
<p>解决方案：创建扩展！</p>
<p>语法如下：</p>
<pre class="programlisting">create Package toPackage（EPackage x）：this.classifiers.addAll（x.eClassifiers.toClass（））; create class toClass（EClass x）：this.attributes.addAll（x.eReferences.toReference（））; create referenceReference（EReference x）：this.setType（x.eType.toClass（））;</pre>
<p>这不仅是一种较短的语法，而且还具有所需的语义：在评估主体之前，创建的模型元素将被添加到缓存中。返回值始终是对已创建且可能未完全初始化元素的引用。</p>
</div>
<div class="section" title="从Java调用扩展">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N11023"></a>从Java调用扩展</h3>
</div>
</div>
</div>
<p>上一节介绍了如何在Java中实现Extensions。本节介绍如何从Java调用Extensions。<a name="N11028" class="indexterm"></a>
</p>
<pre class="programlisting">// setup XtendFacade f = XtendFacade.create（“my :: path :: MyExtensionFile”）; //使用f.call（“sayHello”，new Object [] {“World”}）;</pre>
<p>被调用的扩展文件如下所示： <a name="N1102F" class="indexterm"></a>
</p>
<pre class="programlisting">sayHello（String s）：“你好”+ s;</pre>
<p>此示例仅使用<code class="classname">BuiltinMetaModel</code>功能，在本例中为<code class="classname">StringTypeImpl</code>的“ <code class="methodname">+</code> ”功能。</p>
<p>这是另一个使用<code class="classname">JavaBeansMetaModel</code>示例<a name="N11045" class="indexterm"></a>战略。此策略提供了附加功能：使用getter和setter方法访问属性。</p>
<p>有关类型系统的更多信息，请参阅<span class="emphasis"><em><a class="xref" href="r10_expressions_language.html" title="表达式">表达式</a></em></span>参考文档。</p>
<p>我们有一个类似JavaBean的元模型类：</p>
<pre class="programlisting">打包我的包装; public class MyBeanMetaClass {private String myProp; public String getMyProp（）{return myProp; public void setMyProp（String s）{myProp = s;}}</pre>
<p>除了内置的元模型类型系统，我们还注册了<code class="classname">JavaMetaModel</code> <a name="N11057" class="indexterm"></a>使用<code class="classname">JavaBeansStrategy</code> <a name="N1105D" class="indexterm"></a>对于我们的门面。现在，我们也可以在我们的扩展中使用此策略：</p>
<pre class="programlisting">// setup facade XtendFacade f = XtendFacade.create（“myext :: JavaBeanExtension”）; //设置其他类型系统JavaMetaModel jmm = new JavaMetaModel（“JavaMM”，new JavaBeansStrategy（））; f.registerMetaModel（JMM）; //使用Facade MyBeanMetaClass jb = MyBeanMetaClass（）; jb.setMyProp（ “测试”）; f.call（“readMyProp”，new Object [] {jb}））;</pre>
<p>被调用的扩展文件如下所示：</p>
<pre class="programlisting">进口包装; readMyProp（MyBeanMetaClass jb）：jb.myProp;</pre>
</div>
<div class="section" title="WorkflowComponent">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N11067"></a> WorkflowComponent <a name="N1106A" class="indexterm"></a>
</h3>
</div>
</div>
</div>
<p>通过对模型转换的额外支持，在工作流中调用<span class="emphasis"><em>Xtend</em></span>是有意义的。<span class="emphasis"><em>Xtend</em></span>组件的典型工作流配置<a name="N11075" class="indexterm"></a>看起来像这样：</p>
<pre class="programlisting">&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel1.ecore“/&gt; &lt;/ metamodel&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.type.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel2.ecore“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”my :: example :: Trafo :: transform（inputSlot）“/&gt; &lt;outputSlot value =”transformedModel“/&gt; &lt;/组件&gt;</pre>
<p>请注意，您可以混合使用任何类型的元模型（不仅仅是EMF元模型）。</p>
</div>
<div class="section" title="Xtend中面向方面的编程">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="N1107E"></a> <span class="emphasis"><em>Xtend中</em></span>面向方面的编程<a name="N11083" class="indexterm"></a><a name="N11086" class="indexterm"></a>
</h3>
</div>
</div>
</div>
<p>使用工作流引擎，现在可以打包（例如zip）一个书面生成器并将其作为一种黑盒子传送。如果您想使用这样的生成器但需要在不修改任何代码的情况下更改某些内容，则可以使用<span class="emphasis"><em>Xtend</em></span>支持的建议。</p>
<p>编织以下建议<a name="N11090" class="indexterm"></a>围绕名称以' <span class="package">my :: generator ::</span> '开头的扩展的每次调用：</p>
<pre class="programlisting">我的:: generator :: *（*）：log（'Invoking'+ ctx.name） - &gt; ctx.proceed（）;</pre>
<p>周围的建议<a name="N1109B" class="indexterm"></a>让您以非侵入方式更改行为（您不需要触摸打包的扩展）。</p>
<div class="section" title="加入Point和Point Cut语法">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N1109F"></a>加入Point和Point Cut语法</h4>
</div>
</div>
</div>
<p>方面取向基本上是将代码编织到软件模块的调用图内的不同点。这些点称为<span class="emphasis"><em>连接点</em></span> 。在<span class="emphasis"><em>Xtend中</em></span> ，连接点是扩展调用（请注意， <span class="emphasis"><em>Xpand</em></span>提供了类似的功能，请参阅<span class="emphasis"><em>Xpand</em></span>文档）。</p>
<p>一个指定哪个连接点<a name="N110B2" class="indexterm"></a>应该通过在所有可用连接点上指定类似“查询”的内容来执行提供的代码。这种查询称为切点。<a name="N110B6" class="indexterm"></a>
</p>
<pre class="programlisting">围绕[切入点]：表达;</pre>
<p>切入点由完全限定名称和参数声明列表组成。</p>
<div class="section" title="扩展名称">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N110BD"></a>扩展名称</h5>
</div>
</div>
</div>
<p>切入点的扩展名称部分必须与连接点定义的完全限定名称匹配。这些表达式区分大小写。星号字符用于指定通配符。</p>
<p>一些例子：</p>
<pre class="programlisting">my :: Extension :: definition //具有指定名称的扩展名org :: eclipse :: xpand2 :: * //扩展名前缀为'org :: eclipse :: xpand2 ::'* Operation * //包含单词'的扩展名操作'在里面。* //所有扩展名</pre>
<div class="warning" title="警告" style="margin-left:0.5in;margin-right:0.5in">
<h3 class="title">警告</h3>
<p>使用通配符时要小心，因为如果你编织一个在建议中调用的扩展名，你将获得无休止的递归。</p>
</div>
</div>
<div class="section" title="参数类型">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N110C9"></a>参数类型</h5>
</div>
</div>
</div>
<p>我们想要添加建议的扩展的参数也可以在切入点中指定。规则是，指定参数的类型必须相同，或者是要调用的定义的相应参数类型（运行时的动态类型）的超类型。</p>
<p>此外，可以在参数列表的末尾设置通配符，以指定可能没有任何类型的参数。<a name="N110D0" class="indexterm"></a>
</p>
<p>一些例子：</p>
<pre class="programlisting">my :: Templ :: extension（）//没有参数的扩展名my :: Templ :: extension（String s）//扩展名只有一个类型为String的参数my :: Templ :: extension（String s，*）// templ def带有一个或多个参数，//其中第一个参数的类型为String my :: Templ :: extension（*）// templ def，带有任意数量的参数</pre>
</div>
<div class="section" title="诉讼">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="N110D9"></a>诉讼</h5>
</div>
</div>
</div>
<p>在建议中，您可能希望调用基础定义。这可以使用隐式变量<code class="varname">ctx</code>来完成，它是<span class="type">xtend :: AdviceContext</span>类型<a name="N110E3" class="indexterm"></a>并提供操作<code class="methodname">proceed()</code> <a name="N110E9" class="indexterm"></a>它使用原始参数调用基础定义（请注意，您之前可能已更改了通知中的任何可变对象）。</p>
<p>如果要控制将哪些参数传递给定义，可以使用操作<code class="methodname">proceed(List[Object] params)</code> 。您应该知道，在建议中，没有进行类型检查。</p>
<p>此外，还有一些检查属性（如<code class="varname">name</code> ， <code class="varname">paramTypes</code>等）可用。</p>
</div>
</div>
<div class="section" title="工作流程配置">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="N110FA"></a>工作流程配置</h4>
</div>
</div>
</div>
<p>将定义的建议编织到不同的连接点<a name="N110FF" class="indexterm"></a> ，您需要配置<code class="classname">XtendComponent</code> <a name="N11105" class="indexterm"></a>使用包含建议的扩展文件的限定名称。</p>
<p>例：</p>
<pre class="programlisting">&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel1.ecore“/&gt; &lt;/ metamodel&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelFile value =”metamodel2.ecore“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”my :: example :: Trafo :: transform（inputSlot）“/&gt; &lt;outputSlot value =”transformedModel“/&gt; &lt;advices value =“my :: Advices，my :: Advices2”/&gt; &lt;/ component&gt;</pre>
</div>
<div class="section" title="使用Xtend进行模型到模型的转换">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_introduction"></a>使用<span class="emphasis"><em>Xtend进行</em></span>模型到模型的转换
</h4>
</div>
</div>
</div>
<p>此示例使用Eclipse EMF作为基础<a name="N11118" class="indexterm"></a>用于模型到模型的转换。它建立在其他地方记录的<span class="emphasis"><em>emfExample</em></span>之上。请先阅读并安装<span class="emphasis"><em>emfExample</em></span> 。</p>
<p>此示例中的想法是将EMF示例中引入的数据模型转换为自身。这可能看起来很无聊，但事实上这个例子非常具有说明性。</p>
</div>
<div class="section" title="工作流程">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_workflow"></a>工作流程</h4>
</div>
</div>
</div>
<p>到目前为止，您应该了解工作流文件的角色和结构。因此，下面的工作流文件的有趣方面是<span class="emphasis"><em><code class="classname">XtendComponent</code></em></span> 。</p>
<pre class="programlisting">&lt;workflow&gt; &lt;property file =“workflow.properties”/&gt; ...&lt;component class =“org.eclipse.xtend。XtendComponent“&gt; &lt;metaModel class =”org.eclipse.xtend.typesystem.emf。EmfMetaModel“&gt; &lt;metaModelPackage value =”数据。DataPackage“/&gt; &lt;/ metaModel&gt; &lt;invoke value =”test :: Trafo :: duplicate（rootElement）“/&gt; &lt;outputSlot value =”newModel“/&gt; &lt;/ component&gt; ...&lt;/工作流程&gt;</pre>
<p>像往常一样，我们必须定义应该使用的元模型，因为我们想要将数据模型转换为数据模型，所以我们只需要指定<code class="classname">data.DataPackage</code>作为元模型。</p>
<p>然后，我们指定要为转换调用哪个函数。语句<code class="classname">test::Trafo::duplicate(rootElement)</code>意味着调用：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="classname">duplicate</code>函数将<code class="classname">rootElement</code>插槽的内容作为参数</p>
</li>
<li class="listitem">
<p>该函数可以在<code class="filename">Trafo.ext</code>文件中找到</p>
</li>
<li class="listitem">
<p>而这又是在类路径中，在<span class="package">测试</span>包中。</p>
</li>
</ul>
</div>
</div>
<div class="section" title="转型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="xtend_example_the_transformation"></a>转型</h4>
</div>
</div>
</div>
<p>如上所述，转换可以在<code class="classname">src</code>文件夹的<code class="classname">test</code>包中的<code class="filename">Trafo.ext</code>文件中找到。让我们一起浏览文件。</p>
<p>所以，首先我们导入元模型。</p>
<pre class="programlisting">进口数据;</pre>
<p>下一个功能是所谓的创建扩展<a name="N11167" class="indexterm"></a><a name="N1116C" class="indexterm"></a> 。创建扩展，作为调用时的副作用，创建<code class="classname">create</code>关键字后面给出的类型的实例。在我们的例子中， <code class="classname">duplicate</code>函数创建了一个<code class="classname">DataModel</code>实例。可以在转换中引用此新创建的对象<a name="N11179" class="indexterm"></a>由<code class="classname">this</code> （这就是为什么<code class="classname">this</code>在后面类型指定）。由于<code class="classname">this</code>可以省略，我们不必在转换中明确提及它。</p>
<p>该函数还将<code class="classname">DataModel</code>的实例作为其唯一参数。该对象在转换中称为<code class="varname">s</code> 。因此，此函数将新创建的<code class="classname">DataModel</code>的名称设置为原始<code class="classname">DataModel</code>的名称，然后将原始实体的所有实体的重复项添加到新实体。要创建实体的<code class="classname">duplicate()</code>将为每个<code class="classname">Entity</code>调用<code class="classname">duplicate()</code>操作。这是转换中的下一个功能。</p>
<pre class="programlisting">创建DataModel这个重复（DataModel s）：entity.addAll（s.entity.duplicate（）） - &gt; setName（s.name）;</pre>
<p>实体的复制功能也是创建扩展。这一次，它为传入的每个旧<code class="classname">Entity</code>创建一个新<code class="classname">Entity</code> 。同样，它复制名称并添加属性的重复项和对新名称的引用。</p>
<pre class="programlisting">create Entity this duplicate（Entity old）：attribute.addAll（old.attribute.duplicate（）） - &gt; reference.addAll（old.reference.duplicate（）） - &gt; setName（old.name）;</pre>
<p>复制属性的功能相当简单，但......</p>
<pre class="programlisting">create Attribute this duplicate（Attribute old）：setName（old.name） - &gt; setType（old.type）;</pre>
<a name="N111AA" class="indexterm"></a>
<p>......参考文献更有趣。请注意，引用虽然由某个<code class="classname">Entity</code>拥有，但也引用另一个实体作为其目标。那么，你如何确保不重复目标两次？<span class="emphasis"><em>Xtend</em></span>为这种情况提供了明确的支持。<span class="emphasis">
<em>创建扩展只在每个参数元组执行一次！</em>
</span>因此，例如，如果通过使用相应参数调用<code class="methodname">duplicate</code>函数来复制目标引用后面的<span class="emphasis"><em>实体</em></span> ，则下次调用它时将<span class="emphasis"><em>返回完全相同的对象</em></span> 。这对图形转换非常有用。</p>
<pre class="programlisting">创建EntityReference这个副本（EntityReference old）：setName（old.name） - &gt; setTarget（old.target.duplicate（））;</pre>
<p>有关<span class="emphasis"><em>Xtend</em></span>语言的更多信息，请参阅<span class="emphasis"><em><a class="xref" href="Xtend_language.html" title="的Xtend">Xtend</a></em></span>参考文档。</p>
</div>
</div>
</div>
</body>
</html><html id="0120.gs-IncreaseTheSpaceBetweenRows.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>格式化报告</title>
    <link rel="StyleSheet" href="css/getstarted.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="gs-TutT6SortTheData.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="gs-TutT8CreateAReportTitle.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h3 class="N_TutorialTask">任务7： <a name="344905">格式化报告</a></h3>
      <p class="b_Body"><a name="138863">现在您已验证报告以正确的顺序显示正确的数据，您可以将注意力转向改进报告的外观。您在本节中执行以下任务：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138864">编辑列标题的文本。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138865">格式化列标题。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138866">在同一行显示联系人名字和姓氏。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138867">增加行之间的空间。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <h4 class="N_h3_Head3"><a name="138870">编辑列标题</a></h4>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138871">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138872">双击第一列标题CUSTOMERNAME。列标题位于表的第一行 - 标题行中。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138877">要替换所有突出显示的文本，请开始键入，然后在完成后按Enter键。要编辑文本，请单击一次以取消选择文本，然后将光标定位到要添加或删除字符的位置。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="138878">用以下文本替换CUSTOMERNAME：</a></div>
      <div class="cfi_CodeFirstIndent"><a name="138879">顾客</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138880">重复步骤</a> <a href="#138872" title="格式化报告">2</a>和<a href="#138877" title="格式化报告">3</a> ，将第二和第三列标题更改为以下文本：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi_CodeFirstIndent"><a name="178175">电话</a></div>
      <div class="coi_CodeIndent"><a name="344772">联系</a></div>
      <div class="N_i_Indent1"><a name="344776">报告设计应</a> <a href="#191409" title="格式化报告">如图1-23</a> <a name="344776">所示</a> 。</div>
      <p class="i2_Image2"><a name="344780"><img class="Default" src="images/layout4.png" alt="图1-23报表设计中的修订列标题" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-23</b> <a name="191409">报表设计中的修订列标题</a></div>
      <h4 class="N_h3_Head3"><a name="138890">格式化列标题</a></h4>
      <p class="b1i_Bullet1-intro"><a name="138894">要格式化报表元素，请使用以下两种方法之一设置其属性：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138895">通过Property Editor设置元素的属性。使用此方法仅格式化所选元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="138896">定义包含所需属性的样式，并将样式应用于元素。使用此方法一次定义格式属性并将其应用于多个元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="396049">您可能会注意到，在报表设计中，列标题以纯文本显示并且是居中对齐的。但是，生成的HTML报告以粗体显示并居中显示列标题。出现这种差异是因为BIRT使用浏览器的默认格式来放置表头中的项目。</a></p>
      <p class="b_Body"><a name="319456">在此过程中，使用“属性编辑器”将列标题对齐到左侧，然后定义样式以向标题行添加颜色。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="285150">要使用属性编辑器格式化列标题：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="286589">选择所有列标题。要选择多个元素，请在单击每个元素时按住Shift键。属性编辑器显示所选元素的属性，</a> <a href="#286598" title="格式化报告">如图1-24</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i3_Image3"><a name="286596"><img class="Default" src="images/layout5_print.png" alt="图1-24属性编辑器中所选元素的属性" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图1-24</b> <a name="286598">属性编辑器中所选元素的属性</a></div>
      <p class="N_si_ScanIcon"><a name="319500"><img class="Default" src="images/left_button.png" alt="左键" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="319514">选择“向左”按钮将列标题对齐到左侧。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="N_si_ScanIcon"><a name="142154"><img class="Default" src="images/bold_button.png" alt="大胆的按钮" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="142155">选择B按钮将列标题格式化为粗体文本。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138915">单击表格外的空白区域取消选择列标题。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138919">要使用样式向标题行添加背景颜色：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="290531">从主菜单栏中，选择元素</a> <span class="Dingbat">→</span>样式<span class="Dingbat">→</span>新样式。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i2_Indent2"><a name="345619">出现New Style，</a> <a href="#345625" title="格式化报告">如图1-25</a> <a name="345619">所示</a> 。左侧显示属性类别。右侧显示您选择的类别的属性。</div>
      <p class="i3_Image3"><a name="345623"><img class="Default" src="images/newstyle.png" alt="图1-25新风格" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图1-25</b> <a name="345625">新风格</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138933">对于自定义样式，请为样式键入以下名称：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="138934">table_header_row</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138935">从属性类别列表中选择背景。“新建样式”显示可以设置的背景属性。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138938">使用以下方法之一为Background Color属性指定颜色：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173199999999997pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="138939">选择属性旁边的按钮，然后从显示的调色板中选择一种颜色。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173199999999997pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="138940">从下拉列表中选择一种颜色。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i2_Indent2"><a name="138941">选择确定。</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="459025">在布局编辑器中，选择表。选择表会导致引导单元出现在表的顶部和左侧，</a> <a href="#459046" title="格式化报告">如图1-26</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i3_Image3"><a name="459044"><img class="Default" src="images/getstarted.01.10.06.png" alt="图1-26表格顶部和左侧的引导单元格" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图1-26</b> <a name="459046">表格顶部和左侧的引导单元格</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138951">选择标题行旁边的引导单元格。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138954">在Property Editor中，选择Properties，然后选择General以显示该行的常规属性。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="138955">通过从Style旁边的下拉列表中选择table_header_row来应用刚刚创建的样式。BIRT报告设计器将样式应用于标题行，并以彩色显示。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="191542">预览报告。该报告应</a> <a href="#425456" title="格式化报告">如图1-27</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="191550"><img class="Default" src="images/output2.png" alt="图1-27显示标题行样式的报告预览" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-27</b> <a name="425456">显示标题行样式的报告预览</a></div>
      <h4 class="N_h3_Head3"><a name="425460">在同一行显示名字和姓氏</a></h4>
      <p class="b_Body"><a name="242268">在单个单元格中放置多个元素时，BIRT报表设计器会创建块级元素。如果您熟悉HTML，则知道每个块元素都在新行上开始。要在同一行上显示多个元素，您需要将它们设置为内联元素。或者，您可以连接第一个和最后一个名称值以显示在单个数据元素中，如此过程中所述。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138982">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138983">删除显示[CONTACTLASTNAME]的数据元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138984">双击显示[CONTACTFIRSTNAME]的数据元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="138985">编辑数据绑定（如图</a> <a href="#425510" title="格式化报告">1-28</a>所示）显示有关与当前数据元素关联的数据的信息。在Expression中，dataSetRow [“CONTACTFIRSTNAME”]表示数据元素显示数据集中CONTACTFIRSTNAME字段的数据。</div>
      <p class="i2_Image2"><a name="257009"><img class="Default" src="images/editdatabinding.png" alt="图1-28编辑数据绑定" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-28</b> <a name="425510">编辑数据绑定</a></div>
      <p class="N_si_ScanIcon"><a name="425515"><img class="Default" src="images/expressionbldrbutton.png" alt="Expression Builder按钮" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="186768">单击“表达式”字段旁边的表达式构建器按钮。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="186767">表达式构建器在窗口顶部的文本区域中显示表达式。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="138986">要连接名字和姓氏，请按如下方式编辑表达式：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi_CodeFirstIndent"><a name="345047">dataSetRow [“CONTACTFIRSTNAME”] +“”+ dataSetRow [“CONTACTLASTNAME”]</a></div>
      <div class="N_i_Indent1"><a href="#230437" title="格式化报告" name="345189">图1-29</a>显示了表达式构建器中的此表达式。空引号（“”）在名字和姓氏之间添加一个空格。您可以在文本区域中键入表达式，也可以双击窗口右下角的项目将其插入表达式中。</div>
      <p class="i2_Image2"><a name="345079"><img class="Default" src="images/getstarted.01.10.10.png" alt="图1-29表达式构建器显示连接数据的表达式" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-29</b> <a name="230437">表达式构建器显示连接数据的表达式</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="139000">选择“确定”关闭表达式构建器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="257057">编辑的表达式显示在“编辑数据绑定”中。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="345632">选择“确定”以将更改保存到数据元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="139001">预览报告。该报告应</a> <a href="#208254" title="格式化报告">如图1-30</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="208252"><img class="Default" src="images/output3.png" alt="图1-30显示串联联系人姓名的报告预览" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-30</b> <a name="208254">显示串联联系人姓名的报告预览</a></div>
      <h4 class="N_h3_Head3"><a name="208256">增加行之间的空间</a></h4>
      <p class="b_Body"><a name="139010">默认布局在表行之间添加最小空间。通常，您需要调整行之间的间距。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="139011">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257069">选择表的详细行，即中间行，</a> <a href="#257084" title="格式化报告">如图1-31</a> <a name="257069">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="257070"><img class="Default" src="images/selected_row.png" alt="图1-31布局编辑器中的选定表行" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-31</b> <a name="257084">布局编辑器中的选定表行</a></div>
      <div class="N_i_Indent1"><a name="319646">属性编辑器显示行的属性。属性编辑器中显示的标题显示了您选择的元素类型，因此您应该看到Property Editor-Row。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257093">在“常规”属性中，将“高度”设置为24磅。行的高度增加，</a> <a href="#257104" title="格式化报告">如图1-32</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="257097"><img class="Default" src="images/setrowheight_qs.png" alt="图1-32行高设置为24点" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-32</b> <a name="257104">行高设置为24点</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="139030">预览报告。该报告应</a> <a href="#191472" title="格式化报告">如图1-33</a> 所示</a> 。数据行之间有更多空间。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="139034"><img class="Default" src="images/output4.png" alt="图1-33报告预览显示增加的行间距" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图1-33</b> <a name="191472">报告预览显示增加的行间距</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3132.org_eclipse_ui_actionSets.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>动作集</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">动作集</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.actionSets<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>此扩展点用于将菜单，菜单项和工具栏按钮添加到Workbench窗口中的公共区域。这些贡献统称为<i>操作集</i> ，并由用户自定义透视图显示在Workbench窗口中。
</p>
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p>
<p>存在实施限制，其当前影响动作集。定义要在操作集中引用的整个菜单结构非常重要。因此，例如，如果另一个动作集定义了一个名为“example”的菜单，则不可能依赖于“example”存在。有必要在每个希望使用它的动作集中重新定义“示例”菜单。
</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.actionSet">actionSet</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.actionSet">actionSet</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST actionSet</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">可见（true | false）</p>
<p class="code SchemaDtdAttlist">说明CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素用于定义一组动作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此操作集的唯一标识符。</li>
<li><b>label</b> -  Workbench用于向用户表示此操作集的可翻译名称。</li>
<li><b>visible</b> - 一个可选属性，指示在透视图打开时动作集最初是否可见。仅当用户打开尚未自定义的透视图时，才会使用此选项。用户可以从“自定义透视对话框”中覆盖此选项。应谨慎使用此属性，以免过多操作使用户不堪重负。</li>
<li><b>description</b> -  Workbench用于向用户表示此操作集的可翻译描述。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">pulldown（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">重定位（true | false）</p>
<p class="code SchemaDtdAttlist">allowLabelUpdate（true | false）</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在菜单栏中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在菜单栏中。</li>
<li><b>toolbarPath</b> - 斜杠分隔的路径（'/'），用于指定工具栏中此操作的位置。第一个标记表示工具栏标识符（“Normal”是默认工具栏），而第二个标记是工具栏中将添加此操作的命名组。如果工具栏中不存在该组，则会创建该组。如果省略toolbarPath，则操作不会出现在工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件或<code>ISharedImages</code>常量的位置。该图标将显示在工具栏中，但不会显示在菜单中。启用的操作将由hoverIcon在菜单中显示。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的属性。如果省略，则默认为<samp>推送</samp> 。属性值将是以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- 作为级联样式菜单项或工具项旁边的下拉菜单。</td>
      </tr>
    </table></li>
<li><b>state</b> - 指示初始状态（ <samp>true</samp>或<samp>false</samp> ）的可选属性。仅在<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><i style="color:red">不推荐使用的</i> <b>下拉列表</b> - 将<samp>style</samp>属性与值<samp>pulldown一起使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的类的完全限定名称<samp>。IWorkbenchWindowActionDelegate</samp>或<samp>org.eclipse.ui。IWorkbenchWindowPulldownDelegate</samp> 。后者应该在<samp>style</samp>属性具有值<samp>pulldown的</samp>情况下实现。此类是负责执行操作的处理程序。如果<samp>retarget</samp>属性为true，则忽略此属性，不应提供该属性。</li>
<li><b>retarget</b> - 重定向此操作的可选属性。如果为true，则视图和编辑器部件可以使用标准机制为此操作提供处理程序，该机制使用此操作的标识符在其站点上设置全局操作处理程序。如果此属性为true，则不应提供<samp>class</samp>属性。<br><b>注意：</b>不支持<code>pulldown</code>和<code>retarget</code>的组合。命令可用于提供此类功能，请参阅<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>和具有<code>pulldown</code>样式的命令元素。</li>
<li><b>allowLabelUpdate</b> - 可选属性，指示重定目标操作是否允许处理程序覆盖它的标签和工具提示。仅在<samp>retarget</samp>属性为true时适用。</li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定且未满足条件，则禁用该操作。如果省略，则动作启用状态不受影响。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IWorkbenchWindowActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是动作集的示例（请注意子元素和使用的方式属性）：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.actionSets”</span> <span class="code SchemaTag">&gt; &lt;actionSet id =</span> <span class="code SchemaCstring">“com.xyz.actionSet”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“My Actions”</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Menu”</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">“additions”</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">“group1”</span> <span class="code SchemaTag">/&gt; &lt;separator name =</span> <span class="code SchemaCstring">“option1”</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">“com.xyz.runXYZ”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ Tool”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“ toggle“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu / group1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runXYZ.gif“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz。动作。RunXYZ“</span> <span class="code SchemaTag">enableFor =</span> <span class="code SchemaCstring">”1“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runABC“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run ABC Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”push“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu / group1 “</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">”Normal / XYZ“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runABC.gif“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行ABC工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_abc_action_context“</span> <span class="code SchemaTag">retarget =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">allowLabelUpdate =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runDEF“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run DEF Tool”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“radio”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / option1”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runDEF.gif”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行DEF工具”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz .actions。RunDEF“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_def_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runGHI“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run GHI Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”radio“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com .xyz.xyzMenu / option1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runGHI.gif“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行GHI工具“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunGHI“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_ghi_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runJKL“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run JKL Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”radio“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com .xyz.xyzMenu / option1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runJKL.gif“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行JKL工具“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunJKL“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_jkl_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;/ actionSet&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，名为“My Actions”的指定操作集最初在每个透视图中都不可见，因为未指定<samp>visible</samp>属性。
</p>
<p>XYZ操作将显示为复选框菜单项，最初未选中。仅当选择计数为1且选择包含Java文件资源时才会启用它。
</p>
<p>ABC操作将同时出现在菜单和工具栏上。仅当选择不包含任何Java文件资源时才会启用它。另请注意，这是一个标签重定目标操作，因此它不提供<samp>类</samp>属性。
</p>
<p>DEF，GHI和JKL操作显示为单选按钮菜单项。它们始终处于启用状态，与当前选择状态无关。
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须是实现<samp>org.eclipse.ui的类的完全限定名<samp>。IWorkbenchWindowActionDelegate</samp>或<samp>org.eclipse.ui。IWorkbenchWindowPulldownDelegate</samp> 。后者应该在<samp>style</samp>属性具有值<samp>pulldown的</samp>情况下实现。此类是负责执行操作的处理程序。如果<samp>retarget</samp>属性为true，则忽略此属性，不应提供该属性。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。
<p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p><p>请务必注意，工作台不会代表插件生成菜单。菜单路径必须引用已存在的菜单。
</p><p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>插件可以使用此扩展点添加新的顶级菜单。插件还可以定义命名组，允许其他插件将其操作贡献给它们。
<p>通过使用path属性的以下值创建顶级菜单：</p><ul>
<li>添加 - 表示<samp>窗口</samp>菜单左侧的一个组。
</li></ul>省略path属性将导致将新菜单添加到添加菜单栏组中。

<p>工作台窗口中的默认组在<samp>IWorkbenchActionConstants</samp>接口中定义。这些常量可以在代码中用于动态贡献。这些值也可以复制到XML文件中，以便与现有的工作台菜单和工具栏进行细粒度的集成。
</p>
<p>工作台窗口中的各种菜单和工具栏项都是通过算法定义的。在这些情况下，必须使用单独的机制来扩展窗口。例如，添加新工作台视图会导致“透视”菜单中出现一个新菜单项。导入，导出和新向导扩展也会自动添加到窗口中。
</p>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2007 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="0549.Doc01_ConfiguringRepositories.html" dir="ltr"></html><html dir="ltr">

<head>
<title>配置存储库（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Configuring Repositories (CDO Model Repository Documentation)";
    }
}
</script>

<link rel="stylesheet" href="../editor.css" type="text/css" charset="UTF-8"></link>

<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>

<script src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.1/themes/smoothness/jquery-ui.css"></link>

<script>
$(function() {
$( ".resizable" ).resizable({ handles:"s,e,se", autoHide:true });
});
</script>

<script type="text/javascript">
function maximize(id)
{
  e = document.getElementById('max_' + id);
  c1 = document.getElementById('editor_content_1_' + id);
  c2 = document.getElementById('editor_content_2_' + id);
  pv = document.getElementById('max_pv_' + id);
  if (e.className == 'max')
  {
    e.className = 'rst';
    e.setAttribute('title', 'Restore');
    c1.setAttribute('style_orig', c1.getAttribute('style'));
    c1.setAttribute('style', 'border:2px solid #99b4d1; border-top:none;');
    c2.setAttribute('style', '');
    if (pv != null)
    {
      pv.setAttribute('width_orig', pv.getAttribute('width'));
      pv.setAttribute('width', '');
    }
  }
  else
  {
    e.className = 'max';
    e.setAttribute('title', 'Maximize');
    c1.setAttribute('style', c1.getAttribute('style_orig'));
    c1.setAttribute('style_orig', '');
    c2.setAttribute('style', 'overflow:scroll; width:100%; height:100%;');
    if (pv != null)
    {
      pv.setAttribute('width', pv.getAttribute('width_orig'));
      pv.setAttribute('width_orig', '');
    }
  }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">Operator's Guide</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>配置存储库</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="Doc00_OperatingServer.html" title="向后操作CDO服务器"><img src="../../images/backward.png" border="0"></a> <a href="Doc02_ConfiguringAcceptors.html" title="转发到配置接受者"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Eike Stepper</p>
<p>CDO服务器的存储库在cdo-server.xml文件中配置。这是一个例子：</p><div class="snippet" align="left" style="margin-left:24px">
  <a name="snippet_Doc01_ConfiguringRepositories_1"></a>
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td width="25px"><div style="position:relative"><img src="../../images/editor-1.png"><img src="../../images/formatter-xml.gif" style="position:absolute;top:5px;left:5px"></div></td>
      <td width="1px" style="background-image:url(../../images/editor-2.png);background-repeat:repeat-x"><font face="Segoe UI,Arial" size="-1">CDO-的server.xml</font></td>
      <td width="1px"><img src="../../images/editor-3.png"></td>
      <td align="right" style="background-image:url(../../images/editor-4.png);background-repeat:repeat-x"></td>
      <td align="center" width="16" style="background-image:url(../../images/editor-4.png);background-repeat:repeat-x"><a href="javascript:void(0);" id="max_Doc01_ConfiguringRepositories_1" class="max" title="最大化">     </a></td>
      <td width="6px"><img src="../../images/editor-5.png"></td>
    </tr>
    <tr>
      <td colspan="6" align="left" valign="top" style="border:1px solid #a0a0a0;border-top:none" nowrap="">
        <div id="editor_content_1_Doc01_ConfiguringRepositories_1" class="ui-widget-content resizable" style="width:600px;height:300px;border:2px solid #99b4d1;border-top:none">
          <div id="editor_content_2_Doc01_ConfiguringRepositories_1" style="overflow:scroll;width:100%;height:100%">
            <code>
<font color="#0000e1">&lt;？xml version =</font> <font color="#000080">“1.0” <font color="#0000e1">encoding =</font> <font color="#000080">“UTF-8” <font color="#0000e1">？&gt;</font><font color="#000080"><br>
</font> <font color="#0000e1">&lt;cdoServer&gt;</font><font color="#000080"><br>
<br>
  </font> <font color="#0000e1">&lt;repository name =</font> <font color="#000080">“repo1” <font color="#0000e1">&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“overrideUUID” <font color="#0000e1">value =</font> <font color="#000080">“” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“supportingAudits” <font color="#0000e1">value =</font> <font color="#000080">“true” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“supportingBranches” <font color="#0000e1">value =</font> <font color="#000080">“true” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“ensureReferentialIntegrity” <font color="#0000e1">value =</font> <font color="#000080">“false” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“allowInterruptRunningQueries” <font color="#0000e1">value =</font> <font color="#000080">“true” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“idGenerationLocation” <font color="#0000e1">value =</font> <font color="#000080">“STORE” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“serializeCommits” <font color="#0000e1">value =</font> <font color="#000080">“false” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“optimisticLockingTimeout” <font color="#0000e1">value =</font> <font color="#000080">“10000” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
<br>
    </font> <font color="#0000e1">&lt;store type =</font> <font color="#000080">“db” <font color="#0000e1">&gt;</font><font color="#000080"><br>
      </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“connectionKeepAlivePeriod” <font color="#0000e1">value =</font> <font color="#000080">“60” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
      </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“readerPoolCapacity” <font color="#0000e1">value =</font> <font color="#000080">“20” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
      </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“writerPoolCapacity” <font color="#0000e1">value =</font> <font color="#000080">“20” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
<br>
      </font> <font color="#0000e1">&lt;mappingStrategy type =</font> <font color="#000080">“horizontal” <font color="#0000e1">&gt;</font><font color="#000080"><br>
        </font> <font color="#0000e1">&lt;property name =</font> <font color="#000080">“qualifiedNames” <font color="#0000e1">value =</font> <font color="#000080">“true” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
      </font> <font color="#0000e1">&lt;/ mappingStrategy&gt;</font><font color="#000080"><br>
<br>
      </font> <font color="#0000e1">&lt;dbAdapter name =</font> <font color="#000080">“h2” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
<br>
      </font> <font color="#0000e1">&lt;数据源<br>class =</font> <font color="#000080">“org.h2.jdbcx。JdbcDataSource”<font color="#0000e1"><br>URL =</font> <font color="#000080">“jdbc：h2：database / repo1” <font color="#0000e1">/&gt;</font><font color="#000080"><br>
    </font> <font color="#0000e1">&lt;/商店&gt;</font><font color="#000080"><br>
  </font> <font color="#0000e1">&lt;/存储库&gt;</font><font color="#000080"><br>
<br>
  </font> <font color="#3f7f5f">&lt;！ - 其他接受者和存储库 - &gt;</font><font color="#000080"><br>
<br>
</font> <font color="#0000e1">&lt;/ cdoServer&gt;</font><font color="#000080"><br>
</font>            </font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></code>

          </div>
        </div>
      </td>
    </tr>
  </table>
</div>
<p>

 </p><p>以下部分描述了各种元素和属性。
 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_repository" title="CDO模型存储库文档中的章节">元素库</a></td></tr>
<tr><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_overrideUUID" title="CDO模型存储库文档中的章节">属性overrideUUID</a></td></tr>
<tr><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_supportingAudits" title="CDO模型存储库文档中的章节">财产支持审计</a></td></tr>
<tr><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">物业支持分支</a></td></tr>
<tr><td></td><td>1.4</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_supportingEcore" title="CDO模型存储库文档中的章节">物业支持核心</a></td></tr>
<tr><td></td><td>1.5</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_supportingUnits" title="CDO模型存储库文档中的章节">物业支持单位</a></td></tr>
<tr><td></td><td>1.6</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_checkUnitMoves" title="CDO模型存储库文档中的章节">属性checkUnitMoves</a></td></tr>
<tr><td></td><td>1.7</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_ensureReferentialIntegrity" title="CDO模型存储库文档中的章节">财产确保参考完整性</a></td></tr>
<tr><td></td><td>1.8</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_serializeCommits" title="CDO模型存储库文档中的章节">物业序列化提交</a></td></tr>
<tr><td></td><td>1.9</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_allowInterruptRunningQueries" title="CDO模型存储库文档中的章节">Property_allowInterruptRunningQueries</a></td></tr>
<tr><td></td><td>1.10</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_idGenerationLocation" title="CDO模型存储库文档中的章节">属性idGenerationLocation</a></td></tr>
<tr><td>2</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_securityManager" title="CDO模型存储库文档中的章节">元素securityManager</a></td></tr>
<tr><td>3</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_authenticator" title="CDO模型存储库文档中的章节">元素验证器</a></td></tr>
<tr><td>4</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_initialPackage" title="CDO模型存储库文档中的章节">元素initialPackage</a></td></tr>
<tr><td>五</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_store" title="CDO模型存储库文档中的章节">元素商店</a></td></tr>
<tr><td></td><td>5.1</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_connectionKeepAlivePeriod" title="CDO模型存储库文档中的章节">属性connectionKeepAlivePeriod</a></td></tr>
<tr><td></td><td>5.2</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_readerPoolCapacity" title="CDO模型存储库文档中的章节">属性readerPoolCapacity</a></td></tr>
<tr><td></td><td>5.3</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_writerPoolCapacity" title="CDO模型存储库文档中的章节">属性writerPoolCapacity</a></td></tr>
<tr><td></td><td>5.4</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_dropAllDataOnActivate" title="CDO模型存储库文档中的章节">属性dropAllDataOnActivate</a></td></tr>
<tr><td>6</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_mappingStrategy" title="CDO模型存储库文档中的章节">元素映射策略</a></td></tr>
<tr><td></td><td>6.1</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_toManyReferences" title="CDO模型存储库文档中的章节">属性toManyReferences</a></td></tr>
<tr><td></td><td>6.2</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_maxTableNameLength" title="CDO模型存储库文档中的章节">属性maxTableNameLength</a></td></tr>
<tr><td></td><td>6.3</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_maxFieldNameLength" title="CDO模型存储库文档中的章节">属性maxFieldNameLength</a></td></tr>
<tr><td></td><td>6.4</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_tableNamePrefix" title="CDO模型存储库文档中的章节">属性tableNamePrefix</a></td></tr>
<tr><td></td><td>6.5</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_qualifiedNames" title="CDO模型存储库文档中的章节">属性qualifiedNames</a></td></tr>
<tr><td></td><td>6.6</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_forceNamesWithID" title="CDO模型存储库文档中的章节">Property forceNamesWithID</a></td></tr>
<tr><td></td><td>6.7</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_fieldConstructionTracking" title="CDO模型存储库文档中的章节">物业领域建筑物跟踪</a></td></tr>
<tr><td></td><td>6.8</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_objectTypeCacheSize" title="CDO模型存储库文档中的章节">属性objectTypeCacheSize</a></td></tr>
<tr><td></td><td>6.9</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_columnTypeModifier" title="CDO模型存储库文档中的章节">属性columnTypeModifier</a></td></tr>
<tr><td></td><td>6.10</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_forceIndexes" title="CDO模型存储库文档中的章节">Property forceIndexes</a></td></tr>
<tr><td></td><td>6.11</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_withRanges" title="CDO模型存储库文档中的章节">物业withRanges</a></td></tr>
<tr><td></td><td>6.12</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_copyOnBranch" title="CDO模型存储库文档中的章节">属性copyOnBranch</a></td></tr>
<tr><td></td><td>6.13</td><td class="te" colspan="3"><a href="Doc01_ConfiguringRepositories.html#Property_forceZeroBasedIndex" title="CDO模型存储库文档中的章节">Property forceZeroBasedIndex</a></td></tr>
<tr><td>7</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_dbAdapter" title="CDO模型存储库文档中的章节">元素dbAdapter</a></td></tr>
<tr><td>8</td><td class="te" colspan="4"><a href="Doc01_ConfiguringRepositories.html#Element_dataSource" title="CDO模型存储库文档中的章节">元素dataSource</a></td></tr>
</table>



<h2><a name="Element_repository"></a> 1个元素存储库</h2>
<p>定义一个<a href="../../javadoc/org/eclipse/emf/cdo/server/IRepository.html" title="org.eclipse.emf.cdo.server中的接口"><code>IRepository</code></a>实例。
 </p><p><code>name</code>属性唯一标识存储库配置程序范围内的存储库。
 </p><p><code>repository</code>元素可以包含多个属性元素（见下文），并且必须只包含一个<a href="Doc01_ConfiguringRepositories.html#Element_store" title="CDO模型存储库文档中的章节">store</a>元素。

</p><h3><a name="Property_overrideUUID"></a> 1.1属性overrideUUID</h3>
<p>指定存储库的常量UUID。如果省略，将使用随机UUID创建存储库。未进一步指定覆盖UUID的格式，但应遵循所使用操作系统的文件命名约定。
 </p><p>如果您的脚本在服务器上为每个存储库创建并以存储库UUID命名的文件系统文件夹上运行，则覆盖默认随机UUID会很有用。</p><h3><a name="Property_supportingAudits"></a> 1.2财产支持审计</h3>
<p>指定存储库是否支持审核视图。请注意，如果存储库的<a href="Doc01_ConfiguringRepositories.html#Element_store" title="Chapter in CDO Model Repository Documentation">商店也</a>支持审计视图，则<a href="Doc01_ConfiguringRepositories.html#Element_store" title="CDO模型存储库文档中的章节">存储</a>库只能支持审计视图。
 </p><p>发布的DBStore支持审计视图。另请注意，如果支持审核，则不会删除或更新已修改对象的行。存储库的所有修订状态都将保存在DB中，这可能导致数据库变得非常大！

</p><h3><a name="Property_supportingBranches"></a> 1.3物业支持分支</h3>
<p>指定存储库是否支持在始终存在的主分支下创建和使用分支。请注意，如果存储库的<a href="Doc01_ConfiguringRepositories.html#Element_store" title="Chapter in CDO Model Repository Documentation">存储</a>支持分支，则<a href="Doc01_ConfiguringRepositories.html#Element_store" title="CDO模型存储库文档中的章节">存储</a>库只能支持分支。
 </p><p>另请注意，分支支持也始终<b>需要</b> <a href="Doc01_ConfiguringRepositories.html#Property_supportingAudits" title="CDO模型存储库文档中的章节">审计支持</a> 。

</p><h3><a name="Property_supportingEcore"></a> 1.4物业支持核心</h3>
<p>指定存储库是否支持Ecore（元元）模型实例的存储。
 </p><p>随着CDO 3.0中<a href="../users/Doc09_TechnicalBackground.html#Doc_BackgroundLegacyModels" title="CDO模型存储库文档中的章节">传统模式</a>的出现，您可以将任何模型的实例存储在CDO存储库中。是否为CDO生成这些模型仅影响其特性（可伸缩性，性能等）。因此，您还可以在CDO存储库中存储Ecore（元元）模型的实例。由于Ecore始终在所有包注册表中注册，因此即使您从未计划存储Ecore的实例，传统模式也会导致在许多类型的商店中创建映射表。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。
 </p><p>
 <b>不推荐使用此属性。截至4.2，Ecore的实例始终受到支持（按需）。</b>

</p><h3><a name="Property_supportingUnits"></a> 1.5物业支持单位</h3>
<p>指定库是否支持创建和优化装载的<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOUnit.html" title="org.eclipse.emf.cdo.view中的接口"><code>units</code></a>或不是。
 </p><p>仅当配置的<a href="../../javadoc/org/eclipse/emf/cdo/server/IStore.html" title="org.eclipse.emf.cdo.server中的接口"><code>store</code></a>支持单元时，才能使用单元支持。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。

</p><h3><a name="Property_checkUnitMoves"></a> 1.6属性checkUnitMoves</h3>
<p>指定存储库是否将应用额外验证以防止在<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOUnit.html" title="org.eclipse.emf.cdo.view中的接口"><code>units</code></a>之间移动对象。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。
 </p><p></p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_ConfiguringRepositories.html#Property_supportingUnits" title="CDO模型存储库文档中的章节">物业支持单位</a></li>
</ul>


<h3><a name="Property_ensureReferentialIntegrity"></a> 1.7财产保证参考完整性</h3>
<p>指定存储库是否将检测并拒绝将在对象图中留下陈旧引用的提交。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。

</p><h3><a name="Property_serializeCommits"></a> 1.8属性serializeCommits</h3>
<p>指定存储库是否通过使用锁定来序列化提交操作。
 </p><p>某些商店（如LissomeStore）需要将提交操作序列化。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。

</p><h3><a name="Property_allowInterruptRunningQueries"></a> 1.9 Property_allowInterruptRunningQueries</h3>
<p>指定存储库是否将取消已调度的查询作业（如果已在运行）。一些底层商店（例如带有Derby数据库的DBStore）可能无法干净地处理这个问题。对于此类存储，此参数可以设置为<code>false</code> 。
 </p><p>有效值： <code>false</code> （默认值）或<code>true</code> 。

</p><h3><a name="Property_idGenerationLocation"></a> 1.10属性idGenerationLocation</h3>
<p>指定存储库是否期望客户端为新对象生成ID，或者是否要求后端存储生成它们。
 </p><p>有效值： <code>STORE</code> （默认）或<code>CLIENT</code> 。</p><h2><a name="Element_securityManager"></a> 2元素securityManager</h2>
<p>示例：&lt;securityManager type =“default”description =“/ security：annotation：home（/ home）”/&gt;</p><p>另见： <a href="http://wiki.eclipse.org/CDO/Security_Manager">http</a> ： <a href="http://wiki.eclipse.org/CDO/Security_Manager">//wiki.eclipse.org/CDO/Security_Manager</a>

</p><h2><a name="Element_authenticator"></a> 3元素验证器</h2>
<p>示例：&lt;authenticator type =“file”description =“_ database / repo1.users”/&gt;</p><p>另见： <a href="http://bugs.eclipse.org/302775">http</a> ： <a href="http://bugs.eclipse.org/302775">//bugs.eclipse.org/302775</a>

</p><h2><a name="Element_initialPackage"></a> 4元素initialPackage</h2>
<p>示例：&lt;initialPackage nsURI =“http://www.eclipse.org/emf/CDO/examples/company/1.0.0”/&gt;</p><p>另见： <a href="http://bugs.eclipse.org/345431">http</a> ： <a href="http://bugs.eclipse.org/345431">//bugs.eclipse.org/345431</a>

</p><h2><a name="Element_store"></a> 5元素商店</h2>
<p>定义一个<a href="../../javadoc/org/eclipse/emf/cdo/server/IStore.html" title="org.eclipse.emf.cdo.server中的接口"><code>IStore</code></a>实例。
 </p><p><code>type</code>属性对应于通过<code>org.eclipse.emf.cdo.server.storeFactory</code>扩展点提供的商店工厂的类型。其余属性取决于指定的<code>type</code>属性值。随附的分发可能具有以下值（取决于用户提供的扩展名）：</p><ul>
 <li> <b>mem</b> ：存储没有真正的持久性。只要服务器未重新启动，具有MEMStore的存储库就可以正常运行。没有识别出其他属性。
 </li><li> <b>db</b> ：通过JDBC连接到关系数据库并通过内置O / R映射器管理持久修订和模型的存储，请参见[[CDO / DB Store]]。DBStore元素可以包含以下嵌套元素：<ul>
        <li> <a href="Doc01_ConfiguringRepositories.html#Element_mappingStrategy" title="CDO模型存储库文档中的章节">元素映射策略</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Element_dbAdapter" title="CDO模型存储库文档中的章节">元素dbAdapter</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Element_dataSource" title="CDO模型存储库文档中的章节">元素dataSource</a>
      </li></ul>
 </li><li> <b>hibernate：</b>使用Teneo / Hibernate的商店，请参阅[[CDO / Hibernate Store]]。
 </li><li> <b>客观性：</b>使用Objectivity / DB的商店，参见[[CDO / Objectivity Store]]。
 </li><li> <b>mongodb：</b>使用MongoDB的商店，请参阅[[CDO / MongoDB商店]]。
 </li><li> <b>db4o：</b>使用DB4O的商店，请参阅[[CDO / DB4O商店]]。
 </li></ul>

<h3><a name="Property_connectionKeepAlivePeriod"></a> 5.1属性connectionKeepAlivePeriod</h3>
<p>如果存储是DBStore，则指定存储将以什么时间间隔发出SQL语句以保持与数据库的连接处于活动状态。

</p><h3><a name="Property_readerPoolCapacity"></a> 5.2属性readerPoolCapacity</h3>
<p>如果存储是DBStore，则指定要保留在读取器池中的最大存储访问者数（JDBC连接）。
 </p><p>默认值为15。

</p><h3><a name="Property_writerPoolCapacity"></a> 5.3属性writerPoolCapacity</h3>
<p>如果存储是DBStore，则指定要保留在编写器池中的最大存储访问者数（JDBC连接）。
 </p><p>默认值为15。

</p><h3><a name="Property_dropAllDataOnActivate"></a> 5.4属性dropAllDataOnActivate</h3>
<p>如果设置为<code>true</code>且存储是DBStore，则在存储激活开始时删除已配置<a href="Doc01_ConfiguringRepositories.html#Element_dataSource" title="CDO模型存储库文档中的章节">模式的</a>所有数据库表。
 </p><p>默认值为<code>false</code> 。

</p><h2><a name="Element_mappingStrategy"></a> 6元素映射战略</h2>
<p>该元素由DBStores识别，并定义内置O / R映射器的整体<a href="../../javadoc/org/eclipse/emf/cdo/server/db/mapping/IMappingStrategy.html" title="org.eclipse.emf.cdo.server.db.mapping中的接口"><code>mapping strategy</code></a> 。
 </p><p><code>type</code>属性对应于通过<code>org.eclipse.emf.cdo.server.db.mappingStrategies</code>扩展点提供的映射策略工厂的类型。随附的分发可能具有以下值（取决于用户提供的扩展名）：</p><ul>
 <li> <b>horizontal</b> ：映射策略，为每个具体模型类创建一个DB表。识别以下嵌套属性元素：<ul>
        <li> <a href="Doc01_ConfiguringRepositories.html#Property_toManyReferences" title="CDO模型存储库文档中的章节">属性toManyReferences</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Property_maxTableNameLength" title="CDO模型存储库文档中的章节">属性maxTableNameLength</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Property_maxFieldNameLength" title="CDO模型存储库文档中的章节">属性maxFieldNameLength</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Property_tableNamePrefix" title="CDO模型存储库文档中的章节">属性tableNamePrefix</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Property_qualifiedNames" title="CDO模型存储库文档中的章节">属性qualifiedNames</a>
        </li><li> <a href="Doc01_ConfiguringRepositories.html#Property_forceNamesWithID" title="CDO模型存储库文档中的章节">Property forceNamesWithID</a>
      </li></ul>
 </li></ul>

<h3><a name="Property_toManyReferences"></a> 6.1属性toManyReferences</h3>
<p>指定内置O / R映射器如何处理多个引用（集合）。识别以下值：</p><ul>
 <li> <b>ONE_TABLE_PER_REFERENCE</b> ：模型的每个to-many引用都将获得自己的DB表。
 </li><li> <b>ONE_TABLE_PER_CLASS</b> ：模型类的所有多对引用将共享一个DB表。
 </li><li> <b>ONE_TABLE_PER_PACKAGE</b> ：模型包的所有多对引用将共享一个DB表。
 </li><li> <b>ONE_TABLE_PER_REPOSITORY</b> ：存储库将共享单个数据库表的所有模型类的所有对多引用。
 </li></ul>

<h3><a name="Property_maxTableNameLength"></a> 6.2属性maxTableNameLength</h3>
<p>使您可以覆盖所选数据库适配器的默认值，以获得最大的表名长度。

</p><h3><a name="Property_maxFieldNameLength"></a> 6.3属性maxFieldNameLength</h3>
<p>使您可以覆盖所选数据库适配器的默认值，以获取列名的最大长度。

</p><h3><a name="Property_tableNamePrefix"></a> 6.4属性tableNamePrefix</h3>
<p>为此映射策略生成的所有表名指定公共固定前缀。

</p><h3><a name="Property_qualifiedNames"></a> 6.5属性qualifiedNames</h3>
<p>指定生成的包或类表名是否合格。

</p><h3><a name="Property_forceNamesWithID"></a> 6.6属性forceNamesWithID</h3>
<p>指定生成的名称是否始终以内部ID为后缀，或仅在生成的名称绝对需要修改的情况下。

</p><h3><a name="Property_fieldConstructionTracking"></a> 6.7属性字段构建跟踪</h3>
<p>指定是否希望架构更新中的<a href="../../../org.eclipse.net4j.db.doc/javadoc/org/eclipse/net4j/db/ddl/IDBField.html" title="Interface in org.eclipse.net4j.db.ddl"><code>IDBField</code></a>构造<a href="../../../org.eclipse.net4j.db.doc/javadoc/org/eclipse/net4j/db/ddl/IDBField.html" title="org.eclipse.net4j.db.ddl中的接口"><code>IDBField</code></a>具有可为空索引字段的来源。

</p><h3><a name="Property_objectTypeCacheSize"></a> 6.8属性objectTypeCacheSize</h3>
<p>指定内存缓存中对象类型的大小。可能的配置值是：</p><ul>
 <li>0（零）：不使用内存缓存。
 </li><li>&gt; 0：使用给定缓存大小的内存缓存。
 </li></ul>默认值为10,000,000的内存高速缓存大小。

<h3><a name="Property_columnTypeModifier"></a> 6.9属性columnTypeModifier</h3>
<p>指定<a href="../../javadoc/org/eclipse/emf/cdo/server/db/mapping/ColumnTypeModifier.html" title="org.eclipse.emf.cdo.server.db.mapping中的类"><code>ColumnTypeModifier</code></a>的名称。

</p><h3><a name="Property_forceIndexes"></a> 6.10 Property forceIndexes</h3>
<p>指定要在哪些类型的结构特征上创建其他索引。值为空或| （管道）以下标记的分隔列表：</p><ul>
 <li>无（默认）</li><li>ALL（等于ATTRIBUTE | REFERENCE）</li><li>属性</li><li>参考（等于CONTAINER | CONTAINMENT | XREF）</li><li>容器</li><li>遏制</li><li>XREF</li></ul>

<h3><a name="Property_withRanges"></a> 6.11财产与范围</h3>
<p>指定新<a href="../../javadoc/org/eclipse/emf/cdo/common/revision/CDORevision.html" title="org.eclipse.emf.cdo.common.revision中的接口"><code>revisions</code></a>是否创建其所有列表<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>features</code></a>全新副本，或者是否仅存储列表增量。
 </p><p>可能的配置值是：</p><ul>
 <li> <code>false</code> （存储修订的所有列表的新副本;默认值）</li><li> <code>true</code> （仅存储列表增量/修订范围）</li></ul>
 <p>此属性仅适用于<a href="Doc01_ConfiguringRepositories.html#Property_supportingAudits" title="CDO模型存储库文档中的章节">审计</a>或<a href="Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">分支</a>存储库中的水平映射策略。

</p><h3><a name="Property_copyOnBranch"></a> 6.12属性copyOnBranch</h3>
<p>指定<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html" title="org.eclipse.emf.cdo.common.branch中的接口"><code>branch</code></a> <b>的第一个</b>新<a href="../../javadoc/org/eclipse/emf/cdo/common/revision/CDORevision.html" title="org.eclipse.emf.cdo.common.revision中的接口"><code>revisions</code></a>是否创建其所有列表<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>features</code></a>全新副本，或者是否仅存储列表增量（相对于父分支中的基本修订）。
 </p><p>可能的配置值是：</p><ul>
 <li> <code>false</code> （仅存储列表中的第一个修订的列表增量/范围;默认值）</li><li> <code>true</code> （存储分支中第一个修订的所有列表的新副本）</li></ul>
 <p>此属性仅适用于<a href="Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">分支</a>存储库中<a href="Doc01_ConfiguringRepositories.html#Property_withRanges" title="CDO模型存储库文档中的章节">基于范围的</a>水平映射策略。

</p><h3><a name="Property_forceZeroBasedIndex"></a> 6.13属性forceZeroBasedIndex</h3>
<p>指定从列表<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>features</code></a>开头的元素删除是否调整所有后续元素的列表索引，或者是否允许第一个元素具有非零列表索引。
 </p><p>可能的配置值是：</p><ul>
 <li> <code>false</code> （允许第一个列表元素的非零列表索引;默认值）</li><li> <code>true</code> （强制第一个列表元素的零列表索引）</li></ul>
 <p>此属性仅适用于<a href="Doc01_ConfiguringRepositories.html#Property_supportingAudits" title="CDO模型存储库文档中的章节">审计</a>或<a href="Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">分支</a>存储库中<a href="Doc01_ConfiguringRepositories.html#Property_withRanges" title="CDO模型存储库文档中的章节">基于范围的</a>水平映射策略。

</p><h2><a name="Element_dbAdapter"></a> 7元素dbAdapter</h2>
<p>定义解释所用数据库的SQL方言的商店的<a href="../../../org.eclipse.net4j.db.doc/javadoc/org/eclipse/net4j/db/IDBAdapter.html" title="org.eclipse.net4j.db中的接口"><code>IDBAdapter</code></a>实例。
 </p><p><code>type</code>属性对应于通过<code>org.eclipse.net4j.db.dbAdapters</code>扩展点提供的数据库适配器工厂的名称。没有识别出其他属性。
 </p><p>DB适配器必须与<a href="Doc01_ConfiguringRepositories.html#Element_dataSource" title="CDO模型存储库文档中的章节">dataSource</a>元素中指定的数据库匹配。

</p><h2><a name="Element_dataSource"></a> 8个元素数据源</h2>
<p>定义商店的DataSource实例。
 </p><p><code>class</code>属性对应于数据源类的完全限定名称。有关支持的数据源及其属性的详细信息，请参阅数据库手册。

</p><p align="right">
<a href="Doc00_OperatingServer.html" title="向后操作CDO服务器"><img src="../../images/backward.png" border="0"></a> <a href="Doc02_ConfiguringAcceptors.html" title="转发到配置接受者"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">Operator's Guide</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="0165.sg-DisplayTheTotalNumberOfCustomersInTheReport.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>显示汇总信息</title>
    <link rel="StyleSheet" href="css/grouping.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="sg-TutT6DisplayCreditLimitRangesInTheGroupHeader.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="sg-DisplayTheNumberOfCustomersTextOnOneLine.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h3 class="N_TutorialTask">任务7： <a name="192310">显示聚合信息</a></h3>
      <p class="b_Body"><a name="192314">分组数据的好处之一是您可以在每个组的开头或结尾添加摘要信息。摘要信息也称为聚合信息。在此过程中，将以下聚合信息添加到报告中：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="261842">每组中的客户数量</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="261853">报告中列出的所有客户的数量</a></div>
            </td>
          </tr>
        </table>
      </div>
      <h4 class="N_h3_Head3"><a name="192317">显示每个组中的客户数量</a></h4>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="261797">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192319">在调色板中的“快速工具”下，拖动聚合元素并将其放在组页脚行的第二个单元格中。组页脚中的元素显示在每个组的末尾。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="209451">在Aggregation Builder中，指定以下值：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="209452">在“列绑定名称”中，键入以下名称：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="209456">GRP_TOTAL_CUSTOMERS</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="209478">在“功能”中，选择“COUNT”。 BIRT选择适当的数据类型，整数。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="209485">在Aggregate On中，选择Group和credit_group。此值指示COUNT函数返回每个信用限额组中的行数。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i2_Indent2"><a href="#461714" title="显示汇总信息" name="461708">图7-10</a>显示了聚合元素的完整定义。</div>
      <p class="i3_Image3"><a name="461712"><img class="Default" src="images/grpt_agg_grp.png" alt="图7-10聚合生成器显示用于获取每个信用限额组中的客户数的值" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图7-10</b> <a name="461714">聚合生成器显示用于获取每个信用限额组中的客户数的值</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="261854">选择确定。在报表设计中，</a> <a href="#421275" title="显示汇总信息">如图7-11</a> <a name="261854">所示</a> ，聚合元素显示sigma符号，后跟列绑定名称。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="421269"><img class="Default" src="images/grouping.07.09.02.png" alt="" style="display:inline;float:none;left:0.0;top:0.0"> [GRP_TOTAL_CUSTOMER]</a></div>
      <p class="i2_Image2"><a name="421273"><img class="Default" src="images/grpt_layout4b.png" alt="图7-11显示聚合元素的报告设计" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-11</b> <a name="421275">显示聚合元素的报告设计</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="421277">预览报告。该报告显示每个组末尾的客户数量。</a><a href="#211765" title="显示汇总信息">图7-12</a>显示了第一个信用限额组的客户数量37。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="192357"><img class="Default" src="images/grpt_output4.png" alt="图7-12报告预览显示每个组的计数" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-12</b> <a name="211765">报告预览显示每个组的计数</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192359">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192360">不是仅显示每个组中的客户数量，而是在总计之前显示以下文本：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi_CodeFirstIndent"><a name="256899">顾客：</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="256903">从调色板拖动文本元素，并将其放在组页脚行的第一个单元格中。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="256907">在“编辑文本项”中，从显示“自动”的下拉列表中选择“HTML”。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="316699">在文本区域中指定以下文本，</a> <a href="#256943" title="显示汇总信息">如图7-13</a> <a name="316699">所示</a> ：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="316700">客户：&lt;VALUE-OF&gt;行[“GRP_TOTAL_CUSTOMERS”] &lt;/ VALUE-OF&gt;</a></div>
      <div class="N_i2_Indent2"><a name="423479">在文本元素中，&lt;VALUE-OF&gt;标记支持动态数据的显示。表达式row [“GRP_TOTAL_CUSTOMERS”]是对您创建的列绑定的引用，用于返回每个信用限额组中的客户数。</a></div>
      <p class="i3_Image3"><a name="316704"><img class="Default" src="images/grpt_grptotal_text.png" alt="图7-13为文本元素指定的文本" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图7-13</b> <a name="256943">为文本元素指定的文本</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="261656">选择“确定”将编辑内容保存到文本元素。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="290666">预览报告。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="425028">滚动到第一个信用限额组的底部。该报告应</a> <a href="#290675" title="显示汇总信息">如图7-14</a> 所示</a> 。组页脚显示以下信息：</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi_CodeFirstIndent"><a name="423502">客户：37 37</a></div>
      <p class="i2_Image2"><a name="290673"><img class="Default" src="images/grpt_output4b.png" alt="图7-14报告预览显示文本元素显示的文本" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-14</b> <a name="290675">报告预览显示文本元素显示的文本</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">9</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="261703">选择“布局”以返回布局编辑器。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">10</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="261934">从组页脚行中的第二个单元格中删除聚合元素，以删除第二个总计，现在是多余的。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <h4 class="N_h3_Head3"><a name="256874">显示报告中的客户总数</a></h4>
      <p class="b_Body"><a name="261922">在上一过程中，您通过从调色板插入聚合元素来添加聚合数据。这次，</a>您可以通过表的Binding页面创建列绑定来添加聚合数据。</p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192361">选择表格。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="261932">在“属性编辑器”中，选择“绑定”选项卡。Binding页面，</a> <a href="#345560" title="显示汇总信息">如图7-15</a> 所示</a> ，显示表中元素使用的所有列绑定。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="345558"><img class="Default" src="images/grpt_tablebindings.png" alt="图7-15显示列绑定" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-15</b> <a name="345560">显示列绑定</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="351243">选择Add Aggregation以创建定义聚合表达式的新列绑定。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="351247">在Aggregation Builder中，指定以下值：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="351248">在“列绑定名称”中，键入以下名称：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="261998">TOTAL_CUSTOMERS</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="261999">在“功能”中，选择“COUNT”。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="291653">在Aggregate On中，选择Table。此值指示COUNT函数返回表中的行数。</a><a href="#291659" title="显示汇总信息">图7-16</a>显示了聚合元素的完整定义。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i3_Image3"><a name="291657"><img class="Default" src="images/grpt_agg_table.png" alt="图7-16聚合生成器显示用于获取表中客户数的值" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图7-16</b> <a name="291659">聚合生成器显示用于获取表中客户数的值</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="383391">选择确定。新的列绑定TOTAL_CUSTOMERS可供表中的任何元素使用。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="262080">如有必要，请选择表格。引导单元格出现在表格的顶部和左侧。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="235098">右键单击第一行左侧的引导单元格</a> - 表格 - 标题，然后选择“插入” <span class="Dingbat">→“</span>行” <span class="Dingbat">→“</span>上方”。显示列标题的行上方会显示一个新的表标题行。新行以彩色显示，因为它继承了它下面的行的属性。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192371">选择新行。在属性编辑器的“属性”下，在“常规”中，将“背景颜色”设置为白色</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192372">从调色板拖动数据元素，并将其放在新表标题行的第一个单元格中。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">9</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="209545">在New Data Binding中，创建一个新的列绑定：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="209546">在“列绑定名称”中，键入以下名称：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="209547">CUSTOMER_TOTAL</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="209548">在“数据类型”中，使用默认值String。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="262230">在Expression中，选择表达式构建器按钮。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="262231">在表达式构建器中：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="262235">输入以下文字：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="262232">“客户数量：”+</a></div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="304141">在表达式构建器的下部窗格中，选择“可用列绑定”，选择“表”，然后双击“TOTAL_CUSTOMERS”，即您创建的列绑定以获取表中的客户数。表达式row [“TOTAL_CUSTOMERS”]出现在文本区域中键入的文本之后，</a> <a href="#291782" title="显示汇总信息">如图7-17</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i4_Image4"><a name="304116"><img class="Default" src="images/grpt_expbldr.png" alt="图7-17显示引用TOTAL_CUSTOMERS列绑定的表达式的表达式构建器" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc4_FigCall4Title">
        <b class="Bold">图7-17</b> <a name="291782">显示引用TOTAL_CUSTOMERS列绑定的表达式的表达式构建器</a></div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="425171">选择确定。表达式出现在New Data Binding的Expression字段中，</a> <a href="#425180" title="显示汇总信息">如图7-18</a> <a name="425171">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i4_Image4"><a name="425178"><img class="Default" src="images/grpt_databinding.png" alt="图7-18定义了列绑定" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc4_FigCall4Title">
        <b class="Bold">图7-18</b> <a name="425180">定义了列绑定</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="440798">选择“确定”以保存列绑定。报告设计应</a> <a href="#440807" title="显示汇总信息">如图7-19</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="440805"><img class="Default" src="images/grpt_layout5.png" alt="图7-19报告设计显示了客户的总计数" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-19</b> <a name="440807">报告设计显示了客户的总计数</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">10</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="192392">预览报告。该报告显示表格开头的客户数量，</a> <a href="#211781" title="显示汇总信息">如图7-20</a> 所示</a> 。文本在列中居中。您稍后重新格式化此文本。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="192404"><img class="Default" src="images/grpt_output5.png" alt="图7-20显示客户总数的报告预览" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图7-20</b> <a name="211781">显示客户总数的报告预览</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="0619.Common.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>GEF通用开发人员文档</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<p>
			<em>非维基读者注意：本文档是从GEF@github.com维基生成的 - 如果您有更正或补充，如果您可以将它们贡献给<a href="https://github.com/eclipse/gef/wiki/Common" target="doc_external">原始维基页面，</a>那将非常棒</em> 。
		</p>
		<h2 id="introduction">介绍</h2>
		<p><span style="color:#5b8e92"><a href="Common.html">Common</a></span>组件提供了所有其他GEF组件可能使用的关键概念和基础结构。它内部由单个<strong><a href="Common.html#common">Common</a></strong>模块组成。
		</p>
		<p>
			<img alt="" border="0" src="images/common/components.common.jpeg">
		</p>
		<hr>
		<h2 id="common">共同</h2>
		<ul>
			<li>
				<strong>功能：org.eclipse.gef.common</strong>
			</li>
			<li>
				<strong>bundle：org.eclipse.gef.common</strong>
			</li>
		</ul>
		<p>在<a href="Common.html#common">通用</a>的模块<a href="Common.html">共同</a>提供了以下包中的基本抽象和相关的支持类：</p>
		<ul>
			<li>
				<a href="Common.html#activate">激活</a> ： <em>可激活</em>对象和相关支持类的一般抽象</li>
			<li>
				<a href="Common.html#adapt">Adapt</a> ： <em>适应性</em>对象和相关支持类的一般抽象</li>
			<li>
				<a href="Common.html#adaptinject">适应。注入</a> ：基于<a href="https://github.com/google/guice" target="doc_external">Google Guice</a>的支持，用于在适应性对象上注入和确定适配器</li>
			<li>
				<a href="Common.html#attributes">属性</a> ：属性存储的一般抽象</li>
			<li>
				<a href="Common.html#beansbinding">豆子。绑定</a> ： <a href="Common.html#beansproperty">Beans提供的属性的JavaFX样式绑定<a href="Common.html#beansproperty">。财产</a> 。
			</li>
			<li>
				<a href="Common.html#beansproperty">豆子。属性</a> ： <a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的 JavaFX样式属性<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>以及JavaFX的Set，List和Map集合属性的替换</li>
			<li>
				<a href="Common.html#beansvalue">豆子。值</a> ：与集合提供的<a href="Common.html#collections">集合</a>相关的可观察值抽象以及与<a href="Common.html#beansproperty">Bean提供的属性相关的可写值抽象<a href="Common.html#beansproperty">。财产</a> 。
			</li>
			<li>
				<a href="Common.html#collections">集合</a> ： <a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的 JavaFX样式可观察集合<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合和相关的侦听器抽象。
			</li>
			<li>
				<a href="Common.html#dispose">Dispose</a> ： <em>一次性</em>对象的一般抽象</li>
			<li>
				<a href="Common.html#reflect">反映</a> ：用于使用Java Reflection的实用程序类</li>
			<li>
				<em> </em>
			</li>
		</ul>
		<h3 id="activate">启用</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.activate</strong>
			</li>
		</ul>
		<p><a href="Common.html#activate">Activate</a>包为维护活动状态的对象（ <a href="Common.html#iactivatable">IActivatable</a> ）和支持类（ <a href="Common.html#activatablesupport">ActivatableSupport</a> ）提供了一般抽象，可以将其用作委托，简单地实现对其合同的<a href="Common.html#iactivatable">IActivatable赋予</a> 。
		</p>
		<h4 id="iactivatable">IActivatable</h4>
		<p><code>IActivatable</code>保持“活动”状态，可以激活和停用。<code>IActivatable</code>的活动状态通过（可观察的） <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyBooleanProperty.html" target="doc_external">javafx.beans.property公开。ReadOnlyBooleanProperty</a> ，因此侦听器可以轻松地观察活动状态。
		</p>
		<h4 id="activatablesupport">ActivatableSupport</h4>
		<p>为了强制执行<a href="Common.html#iactivatable">IActivatable的</a>实现者， <a href="Common.html#iactivatable">请</a>遵循上述合同，可以使用<code>ActivatableSupport</code> 。它没有正式实现<a href="Common.html#iactivatable">IActivatable</a>接口，但为其所有方法提供了实现，因此可以简单地用作委托，如下所示：</p>
		<pre><code>public class MyActivatable实现IActivatable {//创建委托私有ActivatableSupport acs = new ActivatableSupport（this）; public void activate（）{acs.activate（null / * pre-activation hook * /，this :: doActivate / * post-activation hook * /）; } ...}</code></pre>
		<hr>
		<h3 id="adapt">适应</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.adapt</strong>
			</li>
		</ul>
		<p><a href="Common.html#adapt">Adapt</a>包提供了对<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">org.eclipse.core.runtime的现代化解释<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">。IAdaptable</a> 。这个扩展背后的动机和简短的概述在<a href="http://nyssen.blogspot.de/2014/11/iadaptable-gef4s-interpretation-of.html" target="doc_external">IAdaptable中</a>给出<a href="http://nyssen.blogspot.de/2014/11/iadaptable-gef4s-interpretation-of.html" target="doc_external">-  GEF的经典解释</a> 。具体而言， <a href="Common.html#adapt">Adapt</a>提供的增强功能包括：</p>
		<ol>
			<li>可以通过<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect注册和检索适配器<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">。TypeToken</a>键作为Class键的替代，它确保具有参数化类型的适配器也可以以类型安全的方式注册和检索，而不仅仅是通过其原始类型。例如，一个适配器实例<em>A1</em>参数化类型<em>A &lt;T1&gt;</em>的和<em>a2</em> <em>A</em>型<em>&lt;T2&gt;</em>的一个实例都可以在注册<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a> 。<a href="MVC.html">MVC</a>组件在注册提供者（即提供者&lt;？）时会密切利用这一点。扩展IGeometry&gt;和提供者&lt;？扩展IFXAnchor&gt;可以同时在IVisualPart注册。
			</li>
			<li>可以（可选地）通过提供附加角色密钥来注册和检索适配器，其允许在<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>处注册多个相同类型的适配器（使用不同的角色）。例如，类型<em>A的</em>适配器实例<em>a1</em>和<em>a2</em>都可以使用不同的角色在adaptable上注册。在注册提供者时， <a href="MVC.html">MVC</a>组件再次使用它。不同的几何提供商（提供商&lt;？扩展IGeometry&gt;）例如通过向各个提供者注册各自的角色来注册用于选择和悬停反馈。
			</li>
			<li>适配器可以通过实现相应的后接口（ <a href="Common.html#iadaptablebound">IAdaptable ，请求）对它们在其注册的相应<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>进行反向引用<a href="Common.html#iadaptablebound">。绑定</a> ）。同样，这在<a href="MVC.html">MVC中</a>被广泛使用，其中例如IBehavior或IPolicy需要知道它注册的主机IVisualPart。
			</li>
			<li>IAdaptable支持注册属性更改侦听器，以便在注册或取消注册适配器时得到通知。</li>
		</ol>
		<p>除了<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ， <a href="Common.html#iadaptablebound">IAdaptable。Bound</a>和<a href="Common.html#iadaptable-adapterkey">AdapterKey</a>抽象形式化了现代化的自适应模式，该软件包还提供了一个支持类（ <a href="Common.html#adaptablesupport">AdaptableSupport</a> ）来实现符合其合同的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ，以及一个独立的实现（ <a href="Common.html#adapterstore">AdapterStore</a> ）。
		</p>
		<h4 id="iadaptable-adapterkey">IAdaptable，AdapterKey</h4>
		<p><code>IAdaptable</code>提供了注册适配器的功能，并通过类型键（ <a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang）的组合来检索它们<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。Class</a>或<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect。TypeToken</a> ）和（可选） <a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang。字符串</a>角色，它们组合在<code>AdapterKey</code> 。可以选择使用<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect。TypeToken</a>而不是简单的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang。类</a>密钥，支持使用参数化类型的类型安全检索适配器。与附加（可选）角色的组合使得可以在<code>IAdaptable</code>处注册多个相同类型的适配器。
		</p>
		<p>Eclipse Core Runtime <a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">org.eclipse.core.runtime提供的“传统”getAdapter（Class &lt;T&gt;）方法<a href="PLUGINS_ROOT/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html" target="doc_external">。这里的IAdaptable</a>只是一个简便的操作，它将检索用相应的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang注册的单个适配器<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。类</a>键和<em>默认</em>角色（或在给定的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang下注册的唯一适配器<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">。类</a>密钥，如果该类型密钥只有一个适配器）。
		</p>
		<p>在从<code>IAdaptable</code>检索适配器之前，必须注册它们。注册再次包含一个角色（如果未提供角色，则使用“默认”角色），并且可能需要通过<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">com.google.common.reflect获取有关实际适配器类型的其他信息<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/reflect/TypeToken.html" target="doc_external">。TypeToken</a> 。如果无法从注册的适配器实例本身推断出这种附加类型信息（参数化类型就是这种情况）。
		</p>
		<p>因此，现在可以通过各种方式注册和检索适配器：</p>
		<pre><code>//在'default'角色下注册并检索原始类型'A'的适配器'a'（不需要输入信息）adaptable.setAdapter（a）; A = adaptable.getAdapter（A.class）; //在'default'角色下注册并检索参数化类型'A &lt;T&gt;'的适配器'a'（需要输入信息）adaptable.setAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，a）; A &lt;T&gt; a = adaptable.getAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}）; //在角色'a1'下注册并检索原始类型'A'的适配器'a'（不需要输入信息）adaptable.setAdapter（a，“a1”）; A = adaptable.getAdapter（AdapterKey.get（A.class，“a1”））; //在角色'a1'下注册并检索参数化类型'A &lt;T&gt;'的适配器'a'（需要输入信息）adaptable.setAdapter（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，a，“a1” ）; A = adaptable.getAdapter（AdapterKey.get（new TypeToken &lt;A &lt;T &gt;&gt;（）{}，“a1”））;</code></pre>
		<p>为了正式支持通知侦听器注册和取消注册适配器， <code>IAdaptable</code>通过<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">javafx.collections提供其适配器<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">。ObservableMap</a>和（不可修改的） <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapProperty.html" target="doc_external">javafx.beans.property。ReadOnlyMapProperty</a> 。
		</p>
		<h4 id="iadaptable-bound">IAdaptable的。界</h4>
		<p>要形式化适配器可能需要获取<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>的后引用， <code>IAdaptable.Bound</code>接口被引入。如果适配器实现此接口，则适配器注册的适应性负责提供适配器的后向引用，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {public &lt;T&gt; void setAdapter（T adapter）{...if（适配器instanceof IAdaptable。约束）{（（IAdaptable。绑定&lt;A&gt;）适配器）.setAdaptable（this）; ...} public &lt;T&gt; void unsetAdapter（T adapter）{...if（适配器instanceof IAdaptable。约束）{（（IAdaptable。绑定&lt;A&gt;）适配器）.setAdaptable（null）; } ...} ...}</code></pre>
		<h4 id="adaptablesupport">AdaptableSupport</h4>
		<p>为了强制执行<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实施者，请遵循上述合同，可以使用<code>AdaptableSupport</code> 。它没有正式实现<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>接口，但为其所有方法提供了实现，因此可以简单地用作委托，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {//创建委托私有AdaptableSupport &lt;MyAdaptable&gt; ads = new AdaptableSupport &lt;MyAdaptable&gt;（this）; public &lt;T&gt; T getAdapter（AdapterKey &lt;T&gt; key）{return ads.getAdapter（key）; } ...}</code></pre>
		<h4 id="adapterstore">AdapterStore</h4>
		<p><code>AdaptableStore</code>是一个可以独立使用的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现。
		</p>
		<hr>
		<h3 id="adapt-inject">适应。注入</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.adapt.inject</strong>
			</li>
		</ul>
		<p><a href="Common.html#adaptinject">适应。Inject</a>包含基于<a href="https://github.com/google/guice" target="doc_external">Google Guice</a>的支持，用于将适配器注入<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> 。也就是说，如果<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现在其&lt;T&gt; setAdapter（TypeToken &lt;T&gt;，T，String）方法上提供@InjectAdapters注释，并且在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com中提供了使用@AdapterMap注释限定的相应适配器（映射）绑定<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。 google.inject。模块</a> ，适配器实例可以自动注入<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实例。需要指出的是，各种适配器（映射）绑定是以多态方式进行评估的，即具体的自适应也将注入所有注册其超类型的适配器。
		</p>
		<p>除了对适配器的基本注入支持之外，该包还支持通过专用的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">com.google.inject对在<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>的（传递）上下文中注入的所有对象进行作用域<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">。范围</a> （ <a href="Common.html#adaptablescope-adaptablescopes">AdaptableScope</a> ）。
		</p>
		<h4 id="adapterinjectionsupport-adaptabletypelistener-adapterinjector">AdapterInjectionSupport，AdaptableTypeListener，AdapterInjector</h4>
		<p>要启用将适配器注入<a href="Common.html#iadaptable-adapterkey">IAdaptable</a> ，特定的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/spi/TypeListener.html" target="doc_external">com.google.inject.spi。需要在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中注册TypeListener</a> （ <code>AdaptableTypeListener</code> ） <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> 。为确保正确完成此操作，请使用相应的支持<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject。提供了模块</a> ，即<code>AdapterInjectionSupport</code> ，可以轻松集成到自定义的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中。模块</a>如下：</p>
		<pre><code>public class MyModule extends AbstractModule {@Override protected void configure（）{// register adapter map injection support install（new AdapterInjectionSupport（））; ...}}</code></pre>
		<p>这将确保<code>AdaptableTypeListener</code>正确注册（并自行注入）。<code>AdaptableTypeListener</code>将注册专用的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/MembersInjector.html" target="doc_external">com.google.inject。在它遇到的所有合适的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现上的MembersInjector</a> （ <code>AdapterInjector</code> ）。
		</p>
		<h4 id="injectadapters">@InjectAdapters</h4>
		<p>在相应的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实现中指定注入点（即&lt;T&gt; setAdapter（TypeToken &lt;T&gt;，T，String）方法是通过添加@InjectAdapters注释来实现的，如下所示：</p>
		<pre><code>公共类MyAdaptable实现IAdaptable {@InjectAdapters public &lt;T&gt; void setAdapter（TypeToken &lt;T&gt; adapterType，T adapter，String role）{...}}</code></pre>
		<h4 id="adaptermap-adaptermaps">AdapterMap，AdapterMaps</h4>
		<p>指定要注入的适配器是通过<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中的映射绑定来执行的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> ，使用@AdapterMap注释进行限定。如果无法从适配器实例本身或相应的绑定推断出要注册的适配器的实际类型，则必须通过所有绑定中使用的<a href="Common.html#iadaptable-adapterkey">AdapterKey</a>提供有关实际适配器类型的信息。在可以从实例或绑定本身推断出适配器的类型的情况下，可以省略它。
		</p>
		<pre><code>公共类MyModule扩展AbstractModule {@Override protected void configure（）{...//获取一个map binder来绑定各个IAdaptable类型的适配器。MapBinder &lt;AdapterKey &lt;？&gt;，Object&gt; adapterMapBinder = AdapterMaps.getAdapterMapBinder（binder（），MyAdaptable.class）; //为每个MyAdaptable实例添加带有'default'角色的原始类型'A'的适配器'a'的适配器（映射）绑定; //类型信息可以省略，因为它可以从适配器实例adapterMapBinder.addBinding（AdapterKey.defaultRole（））。toInstance（a）; //添加适配器（map）绑定，用于将具有角色'r'的原始类型'A'的实例绑定到每个MyAdaptable实例; //类型信息可以省略，因为它可以从绑定adapterMapBinder.addBinding（AdapterKey.role（“r”）。to（A.class）; //为绑定适配器'a'添加适配器（map）绑定推断出来参数化类型'A &lt;T&gt;'对每个MyAdaptable实例具有'default'角色; //类型信息是必需的，因为它不能从适配器实例推断，也不能从绑定adapterMapBinder.addBinding推断（AdapterKey.get（new TypeToken） &lt;A &lt;T &gt;&gt;（）{}））。toInstance（a）; ...}}</code></pre>
		<p>在<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中正确启用适配器映射注入时<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a> ，通过<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Injector.html" target="doc_external">com.google.inject创建的所有合适的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实例<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Injector.html" target="doc_external">。Injector</a> ，它知道各自的<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject。模块</a> ，将被注入。
		</p>
		<p>为此，可以将<code>@AdapterMap</code>与Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/name/Named.html" target="doc_external">@Named</a> <code>@AdapterMap</code>进行比较，只与<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Class.html" target="doc_external">java.lang进行比较。类</a>而不是<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang。使用字符串</a>键。但是， <code>@AdapterMap</code>更强大，因为它们是多态的。也就是说，如果为特定的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>指定了绑定，让我们说'A'，它将被评估为'A'的所有子类型的实例，只要它们适合注入（即它们直接或通过继承）提供适合注入适配器的相应方法）。这是一个非常强大的机制，由<a href="MVC.html">MVC</a>组件密集使用。它允许为某些抽象基类型注册某些适配器，以便为每个具体子类型注入相应的适配器实例。
		</p>
		<p>此外，适配器映射绑定可以是有条件的，通过使用（传递）自适应类型和角色对它们进行限定。然后仅在要注入的自适应适配器链中存在指定类型的适应性（其本身在特定角色下适应）的情况下才评估相应的绑定。潜在的用例是为各个查看者中的可视部分绑定不同的行为和策略：</p>
		<pre><code>//内容查看器中与GeometricShapePart相关的绑定bindGeometricShapePartAdaptersInContentViewerContext（AdapterMaps.getAdapterMapBinder（binder（），GeometricShapePart.class，AdapterKey.get（IViewer.class，CONTENT_VIEWER_ROLE）））; //调色板查看器中与GeometricShapePart相关的绑定bindGeometricShapePartAdapterInPaletteViewerContext（AdapterMaps.getAdapterMapBinder（binder（），GeometricShapePart.class，AdapterKey.get（IViewer.class，PALETTE_VIEWER_ROLE）））;</code></pre>
		<p>如果适配器映射绑定是有条件的，则AdapterInjector会推迟其注入，直到建立完整的自适应适配器链。</p>
		<h4 id="adaptablescope-adaptablescopes">AdaptableScope，AdaptableScopes</h4>
		<p><code>AdaptableScope</code>是一个Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Scope.html" target="doc_external">com.google.inject。范围</a>绑定到一个<a href="Common.html#iadaptable-adapterkey">IAdaptable的</a>实例。它可用于在注入期间对对象实例（不限于适配器）进行范围调整。要启用此功能，绑定必须是“作用域”，并且必须在触发注入适配器之前为相应的<a href="Common.html#iadaptable-adapterkey">IAdaptable</a>实例输入范围（使用<code>AdaptableScopes</code>支持类最好支持）。
		</p>
		<p>范围绑定可以简单地在Guice <a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">com.google.inject中执行<a href="http://google.github.io/guice/api-docs/3.0/javadoc/com/google/inject/Module.html" target="doc_external">。模块</a>如下：</p>
		<pre><code>公共类MyModule扩展AbstractModule {@Override protected void configure（）{...//在IAdaptable'A'的上下文中，重用一个'B'binder（）类型的实例.bind（B.class）.in（AdaptableScopes.typed（A.class））; ...}}</code></pre>
		<p>通过AdapterInjector在内部执行相应的AdaptableScope。</p>
		<hr>
		<h3 id="attributes">属性</h3>
		<ul>
			<li>
				<strong>package：org.eclipse.gef.common.attributes</strong>
			</li>
		</ul>
		<p><a href="Common.html#attributes">Attributes</a>包提供基于字符串键（对象）属性的抽象。
		</p>
		<h4 id="iattributestore">IAttributeStore</h4>
		<p><code>IAttributeStore</code>是一种通用抽象，为存储和检索<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Object.html" target="doc_external">java.lang提供支持<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Object.html" target="doc_external">。通过<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">java.lang的 对象</a>属性<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/String.html" target="doc_external">。字符串</a>键以（可观察的）映射属性的形式。
		</p>
		<h4 id="iattributecopier">IAttributeCopier</h4>
		<p><code>IAttributeCopier</code>是复制器的通用抽象，可以将属性从一个<a href="Common.html#iattributestore">IAttributeStore</a>传输/复制到另一个。它提供静态<code>NULL_COPY</code>和<code>SHALLOW_COPY</code>默认复制器实现。
		</p>
		<hr>
		<h3 id="beans-binding">豆子。捆绑</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.binding</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansbinding">豆子。绑定</a>包为<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect提供绑定实现<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合，以及JavaFX（内部）表达式助手类的替换，由<a href="Common.html#beansproperty">Beans提供的JavaFX属性替换类使用<a href="Common.html#beansproperty">。财产</a> 。
		</p>
		<hr>
		<h3 id="beans-property">豆子。属性</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.property</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansproperty">豆子。Property</a>包为<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect提供（可观察的）属性抽象和实现<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合，以及JavaFX的list，set和map属性基类的<a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapPropertyBase.html" target="doc_external">替换 （ <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyMapPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlyMapPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlyListPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlyListPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/ReadOnlySetPropertyBase.html" target="doc_external">javafx.beans.property。ReadOnlySetPropertyBase</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleMapProperty.html" target="doc_external">javafx.beans.property。SimpleMapProperty</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleListProperty.html" target="doc_external">javafx.beans.property。SimpleListProperty</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/beans/property/SimpleSetProperty.html" target="doc_external">javafx.beans.property。SimpleSetProperty</a> ）。
		</p>
		<p>关于如何使用<a href="Common.html#beansproperty">Beans提供的属性的一个很好的概述<a href="Common.html#beansproperty">。属性</a>在<a href="http://nyssen.blogspot.de/2016/04/gef4-common-collections-and-properties.html" target="doc_external">GEF Common Collections and Properties中给出 -  Guava为FX</a> 。</p>
		<hr>
		<h3 id="beans-value">豆子。值</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.beans.value</strong>
			</li>
		</ul>
		<p><a href="Common.html#beansvalue">豆子。Value</a>包提供与<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect相关的ObservableValue和WritableValue抽象<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合。这些是由<a href="Common.html#collections">Collections</a>和<a href="Common.html#beansproperty">Beans提供的可观察集合和属性实现的<a href="Common.html#beansproperty">。财产</a> 。
		</p>
		<hr>
		<h3 id="collections">集合</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.collections</strong>
			</li>
		</ul>
		<p><a href="Common.html#collections">Collections</a>包提供了<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a>集合以及一个实用程序类，通过它可以实例化这些可观察集合以及JavaFX可观察集合（修复某些问题）的替换。
		</p>
		<p>有关如何使用Collections提供的<a href="Common.html#collections">集合的详细</a>概述以及有关JavaFX提供的集合的添加和变通方法的一些见解，请参阅<a href="http://nyssen.blogspot.de/2016/04/gef4-common-collections-and-properties.html" target="doc_external">GEF Common Collections和Properties  -  Guava goes FX</a> 。</p>
		<h4 id="collectionutils">CollectionUtils</h4>
		<p>
			<code>CollectionUtils</code>是一个增强<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">javafx.collections的实用程序类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">。FXCollections</a> 。它提供静态实用程序方法来为<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect创建可观察的等效项<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。Multiset</a>和<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect。SetMultimap</a> ，以及提供的JavaFX集合的替换类。
		</p>
		<h4 id="observablemultiset-observablemultisetwrapper-unmodifiableobservablemultisetwrapper">ObservableMultiset，ObservableMultisetWrapper，UnmodifiableObservableMultisetWrapper</h4>
		<p>
			<code>ObservableMultiset</code>是<a href="https://github.com/google/guava" target="doc_external">Google Guava</a>的<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/Multiset.html" target="doc_external">。具有JavaFX可观察集合风格的Multiset</a> 。有两个具体的（内部）实现， <code>ObservableMultisetWrapper</code>以及<code>UnmodifiableObservableMultisetWrapper</code> ，它们不应该直接访问，而是可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的实用程序操作创建。
		</p>
		<h4 id="observablesetmultimap-observablesetmultimapwrapper-unmodifiableobservablesetmultimapwrapper">ObservableSetMultimap，ObservableSetMultimapWrapper，UnmodifiableObservableSetMultimapWrapper</h4>
		<p>
			<code>ObservableSetMultimap</code>是<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">com.google.common.collect的可观察变体<a href="http://google.github.io/guava/releases/15.0/api/docs/com/google/common/collect/SetMultimap.html" target="doc_external">。SetMultimap</a>采用JavaFX可观察集合的样式。有两个具体的（内部）实现， <code>ObservableSetMultimapWrapper</code>以及<code>UnmodifiableObservableSetMultimapWrapper</code> ，它们不应该直接访问，而是可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的实用程序操作创建。
		</p>
		<h4 id="multisetlistenerhelper-setmultimaplistenerhelper">MultisetListenerHelper，SetMultimapListenerHelper</h4>
		<p>的<code>MultisetListenerHelper</code>和<code>SetMultimapListenerHelper</code>是由内部使用（内部）委托类<a href="Common.html#observablemultiset-observablemultisetwrapper-unmodifiableobservablemultisetwrapper">ObservableMultiset</a>和<a href="Common.html#beansbinding">\ #ObservableSetMultimap，ObservableSetMultimapWrapper，UnmodifiableObservableSetMultimapWrapper | ObservableSetMultimap]]，以及[豆中的相关属性和绑定。捆绑</a>和<a href="Common.html#beansproperty">豆类。维护和通知已注册听众的属性</a> 。
		</p>
		<h4 id="observablelistwrapperex">ObservableListWrapperEx</h4>
		<p>
			<code>ObservableListWrapperEx</code>是<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">javafx.collections返回的ObservableListWrapper的（内部）替换类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/FXCollections.html" target="doc_external">。FXCollections</a>在其效用函数中与可观察列表相关。它可以使用<a href="Common.html#collectionutils">CollectionUtils</a>提供的各种实用方法构建。
		</p>
		<h4 id="listlistenerhelperex-setlistenerhelperex-maplistenerhelperex">ListListenerHelperEx，SetListenerHelperEx，MapListenerHelperEx</h4>
		<p><code>ListListenerHelperEx</code> ， <code>SetListenerHelperEx</code>和<code>MapListenerHelperEx</code>是（内部）委托类，它们替换为<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableList.html" target="doc_external">javafx.collections提供的JavaFX实现在内部使用的相应委托类<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableList.html" target="doc_external">。ObservableList</a> ， <a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableSet.html" target="doc_external">javafx.collections。ObservableSet</a>和<a href="http://docs.oracle.com/javafx/2/api/javafx/collections/ObservableMap.html" target="doc_external">javafx.collections。ObservableMap</a> 。它们由<a href="Common.html#observablelistwrapperex">ObservableListWrapperEx</a>以及<a href="Common.html#beansbinding">Beans提供的替换使用<a href="Common.html#beansbinding">。捆绑</a>和<a href="Common.html#beansproperty">豆类。财产</a> 。
		</p>
		<hr>
		<h3 id="dispose">部署</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.dispose</strong>
			</li>
		</ul>
		<p><a href="Common.html#dispose">Dispose</a>包为<a href="Common.html#dispose">处理</a>时需要通知的对象提供抽象（ <a href="Common.html#idisposable">IDisposable</a> ）。
		</p>
		<h4 id="idisposable">IDisposable的</h4>
		<p>需要处理<code>IDisposable</code> 。虽然<code>IDisposable</code>封装了处理时必须执行的必要步骤，但处理的启动留给了客户。
		</p>
		<hr>
		<h3 id="reflect">反映</h3>
		<ul>
			<li>
				<strong>包：org.eclipse.gef.common.reflect</strong>
			</li>
		</ul>
		<p><a href="Common.html#reflect">Reflect</a>包提供了一个实用程序类（ <a href="Common.html#reflectionutils">ReflectionUtils</a> ），它在Java反射的上下文中提供了便利操作。
		</p>
		<h4 id="types">类型</h4>
		<p><code>Types</code>实用程序为处理不同的TypeToken实现提供支持。
		</p>
		<h4 id="reflectionutils">ReflectionUtils</h4>
		<p><code>ReflectionUtils</code>实用程序支持通过Java反射获取和设置私有字段的值。
		</p>
	</body>
</html><html id="0567.Doc05_UsingCheckouts.html" dir="ltr"></html><html dir="ltr">

<head>
<title>使用Checkout（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Working with Checkouts (CDO Model Repository Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>使用Checkout</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="Doc04_CheckingOut.html" title="向后退出存储库"><img src="../../images/backward.png" border="0"></a> <a href="Doc06_UsingResources.html" title="转发使用文件夹和资源"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Eike Stepper</p>
<p>在<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer中</a>使用模型的关键概念是<a href="../../javadoc/org/eclipse/emf/cdo/explorer/checkouts/CDOCheckout.html" title="org.eclipse.emf.cdo.explorer.checkouts中的接口"><code>checkout</code></a> 。有关如何创建<a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">联机事务检出</a> ， <a href="Doc04_CheckingOut.html#Doc_HistoricalCheckouts" title="CDO模型存储库文档中的章节">联机历史签出</a>和<a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="Chapter in CDO Model Repository Documentation">脱机签</a> <a href="Doc04_CheckingOut.html" title="Article in CDO Model Repository Documentation">出</a>的详细信息，请参阅<a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">从存储库</a> <a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">签出</a> 。
 </p><p>结帐表示以下信息的<i>命名</i>组合：</p><ul>
 <li>已配置的存储库（有关如何创建和配置存储库的详细信息，请参阅<a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">创建存储库和连接</a> ），</li><li>一个<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html" title="org.eclipse.emf.cdo.common.branch中的接口"><code>branch point</code></a> ，从什么决定<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getBranch()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>branch</code></a> ，并从什么<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getTimeStamp()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>time</code></a>结帐的模型显示，和</li><li>一个对象，用作结帐模型树的根对象。默认情况下，这是存储库的<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOView.html#getRootResource()" title="org.eclipse.emf.cdo.view中的方法。CDOView"><code>root resource</code></a> 。
 </li></ul>
 <p>创建后，结帐将显示在Project Explorer中，如工作区项目，并使用小的蓝色存储库图像进行修饰。与工作空间项目相比，显示的检出在工作空间中没有物理表示。</p><p align="center"><img src="project-explorer.png">

 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_RenamingCheckouts" title="CDO模型存储库文档中的章节">重命名结帐</a></td></tr>
<tr><td>2</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_DuplicatingCheckouts" title="CDO模型存储库文档中的章节">复制结账</a></td></tr>
<tr><td>3</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_OpeningClosing" title="CDO模型存储库文档中的章节">打开和关闭结帐</a></td></tr>
<tr><td>4</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_DeletingCheckouts" title="CDO模型存储库文档中的章节">删除结帐</a></td></tr>
<tr><td>五</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranch" title="CDO模型存储库文档中的章节">切换结账的分支</a></td></tr>
<tr><td></td><td>5.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchNewBranch" title="CDO模型存储库文档中的章节">切换到新分支</a></td></tr>
<tr><td></td><td>5.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranch" title="CDO模型存储库文档中的章节">切换到其他分支</a></td></tr>
<tr><td>6</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranchPoint" title="CDO模型存储库文档中的章节">切换结账的时间戳</a></td></tr>
<tr><td></td><td>6.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranchPoint" title="CDO模型存储库文档中的章节">切换到其他分支点</a></td></tr>
<tr><td></td><td>6.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_SwitchCommit" title="CDO模型存储库文档中的章节">切换到提交</a></td></tr>
<tr><td>7</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_ComparingCheckouts" title="CDO模型存储库文档中的章节">比较结账</a></td></tr>
<tr><td></td><td>7.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranch" title="CDO模型存储库文档中的章节">与其他分支比较</a></td></tr>
<tr><td></td><td>7.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranchPoint" title="CDO模型存储库文档中的章节">与其他分支点比较</a></td></tr>
<tr><td></td><td>7.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CompareCommit" title="CDO模型存储库文档中的章节">与提交相比</a></td></tr>
<tr><td>8</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_MergingCheckouts" title="CDO模型存储库文档中的章节">合并结账</a></td></tr>
<tr><td></td><td>8.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranch" title="CDO模型存储库文档中的章节">从其他分支合并</a></td></tr>
<tr><td></td><td>8.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranchPoint" title="CDO模型存储库文档中的章节">从其他分支点合并</a></td></tr>
<tr><td></td><td>8.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_MergeCommit" title="CDO模型存储库文档中的章节">从提交中合并</a></td></tr>
<tr><td>9</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowIn" title="CDO模型存储库文档中的章节">在其他视图中显示结帐</a></td></tr>
<tr><td></td><td>9.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInSessions" title="CDO模型存储库文档中的章节">在CDO会话视图中显示结帐</a></td></tr>
<tr><td></td><td>9.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInTimeMachine" title="CDO模型存储库文档中的章节">在CDO时间机器视图中显示结帐</a></td></tr>
<tr><td></td><td>9.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInServerBrowser" title="CDO模型存储库文档中的章节">在CDO服务器浏览器中显示Checkout</a></td></tr>
<tr><td></td><td>9.4</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInProperties" title="CDO模型存储库文档中的章节">在属性视图中显示结帐</a></td></tr>
<tr><td></td><td>9.5</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInHistory" title="CDO模型存储库文档中的章节">在历史记录视图中显示结帐</a></td></tr>
<tr><td></td><td>9.6</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_CheckoutShowInSystemExplorer" title="CDO模型存储库文档中的章节">在系统资源管理器中显示Checkouts</a></td></tr>
<tr><td>10</td><td class="te" colspan="4"><a href="Doc05_UsingCheckouts.html#Doc_UsingOfflineCheckouts" title="CDO模型存储库文档中的章节">使用脱机结帐</a></td></tr>
<tr><td></td><td>10.1</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">更新脱机结帐</a></td></tr>
<tr><td></td><td>10.2</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineCheckin" title="CDO模型存储库文档中的章节">签入离线结账</a></td></tr>
<tr><td></td><td>10.3</td><td class="te" colspan="3"><a href="Doc05_UsingCheckouts.html#Doc_OfflineRevert" title="CDO模型存储库文档中的章节">还原离线结帐</a></td></tr>
</table>



<h2><a name="Doc_RenamingCheckouts"></a> 1重命名结帐</h2>
<p>CDO支持随时重命名现有结帐，即更改其标签。可以通过选择结帐并按F2键或在上下文菜单中选择重命名操作来重命名结帐。将弹出以下对话框：</p><p align="center"><img src="checkout-rename.png">

 </p><p>如果结帐标签未更改或更改为不存在的标签，则只能使用“确定”按钮完成对话框。

</p><h2><a name="Doc_DuplicatingCheckouts"></a> 2复制结账</h2>
<p>有时，在Project Explorer中从同一个存储库中进行两次或多次签出是很有用的。可以通过选择结帐，打开上下文菜单以及选择“复制结帐”操作来复制结帐。结果是具有唯一默认标签的相同结帐：</p><p align="center"><img src="checkout-duplicate.png">


</p><h2><a name="Doc_OpeningClosing"></a> 3打开和关闭结帐</h2>
<p>要使用已配置的结帐，结帐必须处于已<i>打开</i>状态。创建后直接打开结帐。在Eclipse启动后，所有签出都处于<i>关闭</i>状态。
 </p><p>如果结帐已关闭，可以通过双击它或在其上下文菜单中选择“打开结帐”来打开它。
 </p><p>如果结帐处于打开状态，可以通过在其上下文菜单中选择“关闭结帐”来关闭它。

</p><h2><a name="Doc_DeletingCheckouts"></a> 4删除结账</h2>
<p>通过选择该结帐并按Del键或在上下文菜单中选择“删除”操作，可以删除现有结帐。可以立即删除多个结帐。将弹出以下对话框：</p><p align="center"><img src="checkout-delete.png">

 </p><p>删除结帐不会删除关联的存储库或其中的任何数据。如果选中“删除磁盘上的检出内容”复选框（即，选中），则会永久删除可能选择的脱机检出的本地复制数据！

</p><h2><a name="Doc_SwitchingBranch"></a> 5切换结账的分支</h2>
<p>通过选择结帐，打开上下文菜单并选择“切换到”子菜单，可以将配置了版本控制模式<b>分支的</b>存储库的联机事务检出切换到其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html" title="org.eclipse.emf.cdo.common.branch中的接口"><code>branches</code></a> ：</p><p align="center"><img src="switch-to-branch.png">

 </p><p>有关如何为远程存储库启用分支的说明，请参阅<a href="../operators/Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">Property</a> supportsBranches， <a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">创建本地存储库</a>以获取有关如何为本地存储库启用分支的说明。
 </p><p>“切换到”子菜单包含以下操作组：</p><ul>
 <li><a href="Doc05_UsingCheckouts.html#Doc_SwitchNewBranch" title="Chapter in CDO Model Repository Documentation">切换到新分支中</a>说明<a href="Doc05_UsingCheckouts.html#Doc_SwitchNewBranch" title="CDO模型存储库文档中的章节">了新分支操作</a> 。
 </li><li>切换到先前在所选结帐中使用的分支的操作的历史记录列表。
 </li><li>其他分支操作在<a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranch" title="CDO模型存储库文档中的章节">切换到其他分支中进行了</a>说明。
 </li><li>从与所选结帐相同的存储库切换到其他事务检出的分支的操作列表。
 </li></ul>
 <p>通过拖动元素并将其拖放到目标结帐时，无需按住任何修改键，也可以切换结帐的分支。可以将以下元素放到目标上：</p><ul>
 <li>与目标结帐相同的存储库的分支</li><li>目标结帐的存储库（引入其主分支）</li><li>来自与所选结帐相同的存储库的在线交易结账（引入其分支机构）</li></ul>
 <p>当结帐切换到不同的分支时，嵌套的资源节点和模型元素以及所有打开的资源编辑器的所有内容都会立即更改以反映新分支的状态。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></li>
</ul>


<h3><a name="Doc_SwitchNewBranch"></a> 5.1切换到新分支</h3>
<p>可以使用“切换到 - &gt;新建分支”上下文菜单操作将在线事务检出切换到新创建的分支。将弹出New Branch对话框：</p><p align="center"><img src="branch-create.png">

 </p><p>有关如何使用“新建分支”对话框的说明，请参见<a href="Doc03_UsingBranches.html#Doc_CreatingBranches" title="CDO模型存储库文档中的章节">创建分支</a> 。

</p><h3><a name="Doc_SwitchOtherBranch"></a> 5.2切换到其他分支</h3>
<p>可以使用“切换到 - &gt;其他分支”上下文菜单操作将在线事务检出切换到任何其他分支。将弹出Select Branch Point对话框（没有时间戳区域）：</p><p align="center"><img src="branch-select.png"> 。

</p><h2><a name="Doc_SwitchingBranchPoint"></a> 6切换结账的时间戳</h2>
<p>从储存库被配置成与所述版本控制模式<b>审计</b>或<b>分支</b>历史在线检出可以被切换到其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html" title="org.eclipse.emf.cdo.common.branch中的接口"><code>branch points</code></a>通过选择结帐时，打开上下文菜单，并选择切换到子菜单：</p><p align="center"><img src="switch-to-branchpoint.png">

 </p><p>见<a href="../operators/Doc01_ConfiguringRepositories.html#Property_supportingAudits" title="CDO模型存储库文档中的章节">物业supportingAudits</a>有关如何启用审核远程仓库，说明<a href="../operators/Doc01_ConfiguringRepositories.html#Property_supportingBranches" title="CDO模型存储库文档中的章节">物业supportingBranches</a>关于如何启用分支远程存储库，或指令<a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">创建本地资源库</a> ，了解如何启用审核或分支的本地资源库的指令。
 </p><p>“切换到”子菜单包含以下操作组：</p><ul>
 <li>切换到之前在所选结帐中使用的分支点的操作的历史记录列表。
 </li><li>“ <a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranchPoint" title="Chapter in CDO Model Repository Documentation">切换到其他分支点”中</a>说明<a href="Doc05_UsingCheckouts.html#Doc_SwitchOtherBranchPoint" title="CDO模型存储库文档中的章节">了“其他分支点”操作</a> 。
 </li><li>“ <a href="Doc05_UsingCheckouts.html#Doc_SwitchCommit" title="CDO模型存储库文档中的章节">切换到提交”中</a>介绍了“提交”操作。
 </li><li>从与所选结帐相同的存储库切换到其他历史检出的分支点的操作列表。
 </li></ul>
 <p>通过拖动元素并将其拖放到目标结帐时，无需按住任何修改键，也可以切换结账的分支点。可以将以下元素放到目标上：</p><ul>
 <li>与目标结帐相同的存储库的分支（引起他们的<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>heads</code></a>
 </li><li>目标结账的存储库（引入其主要分支的负责人）</li><li>来自与所选结帐相同的存储库的在线历史结帐（引入其分支点）</li><li>例如，从“ <a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录”视图中</a>提交
 </li></ul>
 <p>使用<a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO Time Machine View</a>也可以切换结账的分支点。
 </p><p>当结帐切换到不同的分支点时，嵌套的资源节点和模型元素以及所有打开的资源编辑器的所有内容立即更改以反映新分支点的状态。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO时间机器视图</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史整合</a></li>
</ul>


<h3><a name="Doc_SwitchOtherBranchPoint"></a> 6.1切换到其他分支点</h3>
<p>可以使用“切换到 - &gt;其他分支点”上下文菜单操作将在线历史签出切换到任何其他分支点。将弹出“选择分支点”对话框（带有时间戳区域）：</p><p align="center"><img src="branchpoint-select.png"> 。

</p><h3><a name="Doc_SwitchCommit"></a> 6.2切换到提交</h3>
<p>可以使用“切换到 - &gt;提交”上下文菜单操作将在线历史签出切换为提交。将弹出“选择提交”对话框：</p><p align="center"><img src="commit-select.png"> 。

</p><h2><a name="Doc_ComparingCheckouts"></a> 7比较结账</h2>
<p>通过选择结帐，打开上下文菜单并选择Compare With子菜单，可以将所有类型的结账与同一存储库中的其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getTimeStamp()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>time stamps</code></a>或其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getBranch()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>branches</code></a>进行比较：</p><p align="center"><img src="compare-with.png">

 </p><p>Compare With子菜单包含以下操作组：</p><ul>
 <li>与先前在所选结帐中使用的分支点进行比较的操作的历史记录列表。
 </li><li>“其他分支”操作在<a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranch" title="CDO模型存储库文档中的章节">与其他分支比较中进行了</a>说明。
 </li><li>其他分支点操作在<a href="Doc05_UsingCheckouts.html#Doc_CompareOtherBranchPoint" title="CDO模型存储库文档中的章节">与其他分支点比较中进行了</a>说明。
 </li><li>“提交”操作在“ <a href="Doc05_UsingCheckouts.html#Doc_CompareCommit" title="Chapter in CDO Model Repository Documentation">与提交</a>进行<a href="Doc05_UsingCheckouts.html#Doc_CompareCommit" title="CDO模型存储库文档中的章节">比较”中进行了</a>说明。
 </li><li>与选定结帐的同一存储库中其他检出的分支点进行比较的操作列表。
 </li></ul>
 <p>通过拖动元素并按下Shift和Ctrl键将它们拖放到目标结帐时，也可以比较结帐。可以将以下元素放到目标上：</p><ul>
 <li>与目标结帐相同的存储库的分支（引起他们的<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>heads</code></a>
 </li><li>目标结账的存储库（引入其主要分支的负责人）</li><li>从与所选结帐相同的存储库中签出（引入其分支点）</li><li>例如，从“ <a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录”视图中</a>提交
 </li></ul>
 <p>当结账与不同的分支点进行比较时，将打开EMF比较编辑器，左侧显示所选比较源（例如，拖动源），右侧显示所选比较目标（例如，放置目标）：</p><p align="center"><img src="compare.png">
</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史整合</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_CompareIntegration" title="CDO模型存储库文档中的章节">比较整合</a></li>
	<li><a href="http://www.eclipse.org/emf/compare/documentation/latest/user/user-guide.html" title="CDO模型存储库文档中的文章">EMF比较指南</a></li>
</ul>


<h3><a name="Doc_CompareOtherBranch"></a> 7.1与其他分支比较</h3>
<p>可以使用“比较” - &gt;“其他分支”上下文菜单操作将结帐与任何其他分支进行比较。将弹出Select Branch Point对话框（没有时间戳区域）：</p><p align="center"><img src="branch-select.png"> 。

</p><h3><a name="Doc_CompareOtherBranchPoint"></a> 7.2与其他分支点比较</h3>
<p>可以使用“比较” - &gt;“其他分支点”上下文菜单操作将结帐与任何其他分支点进行比较。将弹出“选择分支点”对话框（带有时间戳区域）：</p><p align="center"><img src="branchpoint-select.png"> 。

</p><h3><a name="Doc_CompareCommit"></a> 7.3与提交比较</h3>
<p>可以使用Compare With  - &gt; Commit上下文菜单操作将Checkout与提交进行比较。将弹出“选择提交”对话框：</p><p align="center"><img src="commit-select.png"> 。

</p><h2><a name="Doc_MergingCheckouts"></a> 8合并结账</h2>
<p>通过选择结帐，打开上下文菜单并选择Merge From子菜单，可以从同一存储库中的其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getTimeStamp()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>time stamps</code></a>或其他<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getBranch()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>branches</code></a>合并脱机和联机事务检出：</p><p align="center"><img src="merge-from.png">

 </p><p>Merge From子菜单包含以下操作组：</p><ul>
 <li>从先前在所选结帐中使用的分支点合并的操作的历史记录列表。
 </li><li>“其他分支”操作在“ <a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranch" title="CDO模型存储库文档中的章节">从其他分支合并”中进行了</a>说明。
 </li><li>其他分支点操作在<a href="Doc05_UsingCheckouts.html#Doc_MergeOtherBranchPoint" title="CDO模型存储库文档中的章节">从其他分支点合并中进行了</a>说明。
 </li><li>在提交<a href="Doc05_UsingCheckouts.html#Doc_MergeCommit" title="Chapter in CDO Model Repository Documentation">合并中</a>解释<a href="Doc05_UsingCheckouts.html#Doc_MergeCommit" title="CDO模型存储库文档中的章节">了提交操作</a> 。
 </li><li>从与所选结帐相同的存储库中的其他检出的分支点合并的操作列表。
 </li></ul>
 <p>通过拖动元素并按下Shift和Ctrl键将它们拖放到目标结帐时，也可以合并结帐。可以将以下元素放到目标上：</p><ul>
 <li>与目标结帐相同的存储库的分支（引起他们的<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>heads</code></a>
 </li><li>目标结账的存储库（引入其主要分支的负责人）</li><li>从与所选结帐相同的存储库中签出（引入其分支点）</li><li>例如，从“ <a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录”视图中</a>提交
 </li></ul>
 <p>当从不同分支点合并结账时，打开EMF合并编辑器，左侧显示所选合并源（例如，拖动源），右侧显示所选合并目标（例如，放置目标）：</p><p align="center"><img src="merge.png">
</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史整合</a></li>
	<li><a href="Doc01_UserInterface.html#Doc_CompareIntegration" title="CDO模型存储库文档中的章节">比较整合</a></li>
	<li><a href="http://www.eclipse.org/emf/compare/documentation/latest/user/user-guide.html" title="CDO模型存储库文档中的文章">EMF比较指南</a></li>
</ul>


<h3><a name="Doc_MergeOtherBranch"></a> 8.1从其他分支合并</h3>
<p>可以使用Merge From  - &gt; Other Branch上下文菜单操作从任何其他分支合并Checkout。将弹出Select Branch Point对话框（没有时间戳区域）：</p><p align="center"><img src="branch-select.png"> 。

</p><h3><a name="Doc_MergeOtherBranchPoint"></a> 8.2从其他分支点合并</h3>
<p>可以使用“合并自 - &gt;其他分支点”上下文菜单操作从任何其他分支点合并签出。将弹出“选择分支点”对话框（带有时间戳区域）：</p><p align="center"><img src="branchpoint-select.png"> 。

</p><h3><a name="Doc_MergeCommit"></a> 8.3从提交中合并</h3>
<p>可以使用Merge From  - &gt; Commit上下文菜单操作从提交中合并Checkout。将弹出“选择提交”对话框：</p><p align="center"><img src="commit-select.png"> 。

</p><h2><a name="Doc_CheckoutShowIn"></a> 9在其他视图中显示结帐</h2>
<p>通过选择它们，打开上下文菜单，打开Show In子菜单，然后选择Show In操作之一，Checkout可以在许多其他视图中显示，具体取决于结帐的类型。
 </p><p>在线交易结账可以在以下视图中显示：</p><p align="center"><img src="checkout-transactional-showin.png">

 </p><p>在线历史签出可以在以下视图中显示：</p><p align="center"><img src="checkout-historical-showin.png">

 </p><p>离线结帐可以在以下视图中显示：</p><p align="center"><img src="checkout-offline-showin.png">


</p><h3><a name="Doc_CheckoutShowInSessions"></a> 9.1在CDO会话视图中显示签出</h3>
<p>在线结帐可以显示在<a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">CDO会话视图中</a> ：</p><p align="center"><img src="sessions-view.png">

 </p><p>在CDO会话视图中打开与所选结帐具有相同目标存储库的新<a href="../../javadoc/org/eclipse/emf/cdo/session/CDOSession.html" title="org.eclipse.emf.cdo.session中的接口"><code>session</code></a> 。在该会话上打开一个新<a href="../../javadoc/org/eclipse/emf/cdo/transaction/CDOTransaction.html" title="org.eclipse.emf.cdo.transaction中的接口"><code>transaction</code></a> ，指向与所选结帐相同的分支点。

</p><h3><a name="Doc_CheckoutShowInTimeMachine"></a> 9.2在CDO Time Machine视图中显示结帐</h3>
<p>在线时间检查可以在<a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO Time Machine视图中显示</a> ：</p><p align="center"><img src="timemachine-view.png">


</p><h3><a name="Doc_CheckoutShowInServerBrowser"></a> 9.3在CDO服务器浏览器中显示签出</h3>
<p>脱机签出可以在CDO服务器浏览器中显示：</p><p align="center"><img src="server-browser.png">

 </p><p>CDO服务器浏览器允许在Web浏览器中内省本地复制的存储库的内部数据。它仅用于测试和调试目的。它<b>并不</b>意味着可以扩展到任意存储库大小的生产工具！

</p><h3><a name="Doc_CheckoutShowInProperties"></a> 9.4在属性视图中显示结帐</h3>
<p>所有签出都可以显示在“ <a href="Doc01_UserInterface.html#Doc_PropertySheetIntegration" title="CDO模型存储库文档中的章节">属性”视图中</a> ：</p><p align="center"><img src="property-sheet.png">


</p><h3><a name="Doc_CheckoutShowInHistory"></a> 9.5在历史记录视图中显示结帐</h3>
<p>所有结帐都可以显示在<a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录视图中</a> ：</p><p align="center"><img src="history.png">

 </p><p>如果未启用“历史记录”视图工具栏中的“使用编辑器和选择链接”按钮，并且历史记录页面不会自动调整为工作台选择，则此功能特别有用。

</p><h3><a name="Doc_CheckoutShowInSystemExplorer"></a> 9.6在系统资源管理器中显示签出</h3>
<p>所有结帐都可以在系统资源管理器中显示：</p><p align="center"><img src="system-explorer-checkout.png">

 </p><p>每个结帐都拥有当前工作空间的.metadata下的专用目录。此目录包含checkout.properties文件，该文件包含结帐的配置。脱机签出还将本地复制的存储库的数据库和脏模型元素的基线数据存储在此目录中。

</p><h2><a name="Doc_UsingOfflineCheckouts"></a> 10使用脱机签出</h2>
<p>
 <b>在线</b>结账直接对存储在其存储库中的数据进行操作，因此需要有效的网络连接;即，存储库必须处于<a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接状态</a> 。它们非常适合支持模型上的实时协作，但只有在可以访问底层存储库时才能打开它们，远程存储库不一定总是这样。
 </p><p>
 相反， <b>脱机</b>检出对其存储库的本地复制数据进行操作，因此不需要活动的网络连接;即，存储库可以处于<a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">断开状态</a> 。即使在无法访问底层存储库期间，它们也非常适合支持模型的离线工作。所包含模型上的协作仅限于显式同步时间，即从远程<a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="Chapter in CDO Model Repository Documentation">更新</a>结账或<a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">将</a>其签<a href="Doc05_UsingCheckouts.html#Doc_OfflineCheckin" title="CDO模型存储库文档中的章节">入</a>到远程时。
 </p><p>脱机检出以及所有模型和模型元素都使用其本地编辑状态进行修饰，即<b>干净</b> ， <b>脏</b>或<b>新</b> 。
 </p><p>除了这些微妙的差异，离线检查的设计行为与在线结账非常相似。此外，还可以使用一些特殊操作，这些操作将在以下嵌套部分中进行说明。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">离线结账</a></li>
</ul>


<h3><a name="Doc_OfflineUpdate"></a> 10.1更新离线结账</h3>
<p>由于脱机结账中的模型和模型元素未实时更新，因此需要在适当的时间手动更新，例如，在尝试将其<a href="Doc05_UsingCheckouts.html#Doc_OfflineCheckin" title="CDO模型存储库文档中的章节">签入</a>远程修改的存储库之前。
 </p><p>要从远程更新脱机结帐，选择结帐并从其上下文菜单中选择更新操作。更新过程尝试合并它们可能出现的所有琐碎冲突。琐碎的冲突是：</p><ul>
 <li>更改多值<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>features</code></a>在同一个模型元素的两侧。
 </li><li>对同一模型元素两侧的不同单值<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>features</code></a>更改。
 </li></ul>
 <p>如果检测到非平凡的更改，即更改同一模型元素两侧的同一单值<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EStructuralFeature.html" title="org.eclipse.emf.ecore中的接口" target="_blank"><code>feature</code></a> ，则会打开EMF Merge编辑器：</p><p align="center"><img src="merge.png">

 </p><p>合并编辑器的左侧显示远程存储库，右侧显示选定的脱机结帐。保存合并编辑器会将所需的更改应用于本地模型元素并关闭合并编辑器。可以通过关闭合并编辑器而不保存更新/合并过程来取消。
 </p><p>更新脱机结账是一项<b>远程操作</b> 。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc01_UserInterface.html#Doc_CompareIntegration" title="CDO模型存储库文档中的章节">比较整合</a></li>
	<li><a href="Doc09_TechnicalBackground.html#Doc_BackgroundCompare" title="CDO模型存储库文档中的章节">比较整合的技术背景</a></li>
</ul>


<h3><a name="Doc_OfflineCheckin"></a> 10.2检查离线结账</h3>
<p>在脱机结账中使用模型和模型元素一段时间之后，将在此期间累积的更改签入到远程存储库中似乎是合适的。
 </p><p>要从远程更新脱机结帐，选中结帐并从其上下文菜单中选择Checkin操作。
 </p><p>只要本地更改和远程更改不冲突（即，既不存在普通冲突也不存在非平凡冲突），签入并不严格要求本地脱机结帐是最新的。如果在签入过程中检测到冲突，则会弹出以下对话框，要求首先<a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">更新</a>结帐：</p><p align="center"><img src="checkin-error.png">

 </p><p>签入离线结账是一项<b>远程操作</b> 。

</p><h3><a name="Doc_OfflineRevert"></a> 10.3恢复离线结账</h3>
<p>有时，在离线结账时放弃模型和模型元素的所有本地编辑状态似乎很有用，从而有效地将结账恢复到最近<a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">更新的</a>状态。
 </p><p>要还原离线结帐，系统会选中结帐并从其上下文菜单中选择“还原”操作。将弹出以下确认对话框：</p><p align="center"><img src="revert.png">

 </p><p>还原离线结帐是<b>本地操作</b> 。

</p><p align="right">
<a href="Doc04_CheckingOut.html" title="向后退出存储库"><img src="../../images/backward.png" border="0"></a> <a href="Doc06_UsingResources.html" title="转发使用文件夹和资源"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="2282.EssentialOCL.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>基本的OCL语言</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="UsersGuide.html" title="Users Guide"></link>
<link rel="prev" href="UsersGuide.html" title="Users Guide"></link>
<link rel="next" href="OCLinEcore.html" title="The OCLinEcore Language"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">基本的OCL语言</h1>
<div class="section" title="基本的OCL语言">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="EssentialOCL"></a>基本的OCL语言</h2>
</div>
</div>
</div>
<p>支持模型表达式的OCL核心功能称为Essential OCL。这种语言本身的用途非常有限，因为无法提供模型。</p>
<p>基本的OCL以各种方式扩展，以提供这种缺失的上下文。</p>
<p><a class="link" href="CompleteOCL.html" title="完整的OCL语言">完整OCL</a>为文档提供了一种语言，其中OCL补充了具有不变量和其他功能的现有元模型。完整的OCL是OMG OCL规范的一部分。
			</p>
<p>
				
<a class="link" href="OCLinEcore.html" title="OCLinEcore语言">OCLinEcore</a>将OCL嵌入到Ecore模型的注释中以丰富该模型。OCLinEcore定义为Eclipse OCL。它不是OMG OCL规范的一部分。
			</p>
<p>UML支持使用OCL约束作为OpaqueExpression的一种形式，而诸如Papyrus的UML工具支持UML模型的约束。</p>
<div class="section" title="句法">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Syntax"></a>句法</h3>
</div>
</div>
</div>
<p>Essential OCL语法的Eclipse OCL实现在以下小节中提供，从表达式术语开始，然后详细说明运算符。</p>
<div class="section" title="语法实现">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="GrammarImplementation"></a>语法实现</h4>
</div>
</div>
</div>
<p>Xtext编辑器使用的语法可以在以下位置找到：</p>
<p>/src/org/eclipse/ocl/examples/xtext/essentialocl/EssentialOCL.xtext</p>
<p>在org.eclipse.ocl.xtext.essentialocl插件中。</p>
</div>
<div class="section" title="语法方法">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="GrammarApproach"></a>语法方法</h4>
</div>
</div>
</div>
<p>OCL 2.4语法含糊不清，因此具有消歧规则。如何应用这些消除歧义的规则是一个实现细节。</p>
<p>Eclipse OCL中采用的消除歧义的方法是解析一个明确的更大的语言，统一所有的歧义。后续的语义验证区分了大型语言中的歧义和诊断表达式，这些表达式不是有效的OCL表达式。</p>
<p>从技术角度来看，这使得语法更简单，更规则，并且实现更加模块化，并且可以通过库模型进行配置。</p>
<p>从用户的角度来看，略微错误的表达可能在语法上有效，因此语义验证可能会产生更有用的诊断。但是，完成辅助可能会提供更大语言的非法表达。</p>
</div>
<div class="section" title="OCL表达">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-Exp"></a> OCL表达</h4>
</div>
</div>
</div>
<p>Exp语法定义OCL表达式。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-exp.png"></div>
<p>
					
</p>
<p>表达式由各种运算符和表达式术语组成，这些术语由<a class="link" href="EssentialOCL.html#EssentialOCL-InfixedExp" title="InfixedExp">InfixedExp</a>在顶层定义。我们将首先定义表达式的术语，然后定义将表达式术语绑定在一起的各种形式的运算符。
					</p>
</div>
<div class="section" title="PrimaryExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-PrimaryExp"></a> PrimaryExp</h4>
</div>
</div>
</div>
<p>PrimaryExp语法标识OCL表达式的基本构建块。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-primaryexp.png"></div>
<p>
					
</p>
<p>文字如</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-PrimitiveLiteralExp" title="PrimitiveLiteralExp">PrimitiveLiteralExpCS</a> - <code class="code">true</code>或<code class="code">3.14159</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-CollectionLiteralExp" title="CollectionLiteralExp">CollectionLiteralExpCS</a> - <code class="code">Set{1..5}</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-TupleLiteralExp" title="TupleLiteralExp">TupleLiteralExpCS</a> - <code class="code">Tuple{name:String='me',at:String='here')</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-TypeLiteralExp" title="TypeLiteralExp">TypeLiteralExpCS</a> - <code class="code">Integer</code>或<code class="code">Set&lt;Integer&gt;</code>
							
</p>
</li>
</ul>
</div>
<p>上下文对象</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-SelfExp" title="SelfExp">SelfExpCS</a> - <code class="code">self</code>
							
</p>
</li>
</ul>
</div>
<p>复合表达式如</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-NestedExp" title="NestedExp">NestedExpCS</a> - <code class="code">(x)</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-IfExp" title="IfExp">IfExpCS</a> - <code class="code">if x then y else z endif</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-LetExp" title="LetExp">LetExpCS</a> - <code class="code">let x : Integer in x + x</code>
							
</p>
</li>
</ul>
</div>
<p>导航表达式如</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-NavigatingExp" title="NavigatingExp">NavigatingExpCS</a> - <code class="code">x</code>或<code class="code">x.ÿ:: Z-&gt;迭代（一个：整数; ACC：整型| ACC +α）</code>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="SelfExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-SelfExp"></a> SelfExp</h4>
</div>
</div>
</div>
<p>SelfExp语法支持在表达式中使用主流上下文对象。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-selfexp.png"></div>
<p>
					
</p>
</div>
<div class="section" title="PrimitiveLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-PrimitiveLiteralExp"></a> PrimitiveLiteralExp</h4>
</div>
</div>
</div>
<p>PrimitiveLiteralExp语法支持在表达式中使用已知值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-primitiveliteralexp.png"></div>
<p>
					
</p>
<p>价值可能是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-NumberLiteralExp" title="NumberLiteralExp">NumberLiteralExpCS</a> - <code class="code">4</code>或<code class="code">3.14159</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-StringLiteralExp" title="StringLiteralExp">StringLiteralExpCS</a> - <code class="code">'a string'</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-BooleanLiteralExp" title="BooleanLiteralExp">BooleanLiteralExpCS</a> - <code class="code">true</code>或<code class="code">false</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-UnlimitedNaturalLiteralExp" title="UnlimitedNaturalLiteralExp">UnlimitedNaturalLiteralExpCS</a> - <code class="code">*</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-InvalidLiteralExp" title="InvalidLiteralExp">InvalidLiteralExpCS</a> - <code class="code">invalid</code>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-NullLiteralExp" title="NullLiteralExp">NullLiteralExpCS</a> - <code class="code">null</code>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="NumberLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NumberLiteralExp"></a> NumberLiteralExp</h4>
</div>
</div>
</div>
<p>NumberLiteralExp语法支持在表达式中使用数值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-numberliteralexp.png"></div>
<p>
					
</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-numberliteral.png"></div>
<p>
					
</p>
<p>数值是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一个整数，如<code class="code">4</code>
							
</p>
</li>
<li class="listitem">
<p>固定点数如<code class="code">3.1</code>
							
</p>
</li>
<li class="listitem">
<p>浮点数，如<code class="code">12.8e-5</code> 。
							</p>
</li>
</ul>
</div>
<p>数值没有前导<code class="code">-</code> ;负数被解析为一元否定运算符到正数的应用。
					</p>
<p>数值可能没有尾随小数点。</p>
<p>数值可能没有冗余前导零。</p>
</div>
<div class="section" title="StringLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-StringLiteralExp"></a> StringLiteralExp</h4>
</div>
</div>
</div>
<p>StringLiteralExp语法支持在表达式中使用字符串值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-stringliteralexp.png"></div>
<p>
					
</p>
<p>字符串被指定为单引号之间的字符序列。</p>
<p>例如<code class="code">'This is a string'</code>
					
</p>
<p>标准的Java和C反斜杠转义符可用于尴尬的字符，例如单引号。</p>
<p>
						
<code class="code">\b</code> - ＃x08：退格BS</p>
<p>
						
<code class="code">\t</code> -  #x09：水平标签HT</p>
<p>
						
<code class="code">\n</code> - ＃x0a：linefeed LF</p>
<p>
						
<code class="code">\f</code> -  #x0c：换页FF</p>
<p>
						
<code class="code">\r</code> -  #x0d：回车CR</p>
<p>
						
<code class="code">\"</code> - ＃x22：双引号”</p>
<p>
						
<code class="code">\'</code> - ＃x27：单引号'</p>
<p>
						
<code class="code">\\</code> - ＃x5c：反斜杠\</p>
<p>
						
<code class="code">\x</code>十六进制十六进制 - ＃x00到#xFF</p>
<p>
						
<code class="code">\u</code> Hex Hex Hex Hex  - ＃x0000到#xFFFF</p>
</div>
<div class="section" title="BooleanLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-BooleanLiteralExp"></a> BooleanLiteralExp</h4>
</div>
</div>
</div>
<p>BooleanLiteralExp语法支持在表达式中使用布尔值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-booleanliteralexp.png"></div>
<p>
					
</p>
<p>布尔值为<code class="code">true</code>和<code class="code">false</code> 。
					</p>
</div>
<div class="section" title="UnlimitedNaturalLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-UnlimitedNaturalLiteralExp"></a> UnlimitedNaturalLiteralExp</h4>
</div>
</div>
</div>
<p>UnlimitedNaturalLiteralExp语法支持在表达式中使用非数字无限值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-unlimitednaturalliteralexp.png"></div>
<p>
					
</p>
<p>非数字无限值为<code class="code">*</code> 。其他UnlimitedNatural值是<a class="link" href="EssentialOCL.html#EssentialOCL-NumberLiteralExp" title="NumberLiteralExp">NumberLiteralExpCS</a> 。</p>
</div>
<div class="section" title="InvalidLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-InvalidLiteralExp"></a> InvalidLiteralExp</h4>
</div>
</div>
</div>
<p>InvalidLiteralExp语法支持在表达式中使用无效值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-invalidliteralexp.png"></div>
<p>
					
</p>
<p>无效值<code class="code">invalid</code> 。
					</p>
</div>
<div class="section" title="NullLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NullLiteralExp"></a> NullLiteralExp</h4>
</div>
</div>
</div>
<p>NullLiteralExp语法支持在表达式中使用null或未指定的值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-nullliteralexp.png"></div>
<p>
					
</p>
<p>null值为<code class="code">null</code> 。
					</p>
</div>
<div class="section" title="CollectionLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-CollectionLiteralExp"></a> CollectionLiteralExp</h4>
</div>
</div>
</div>
<p>CollectionLiteralExp语法支持创建要在表达式中使用的值集合。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-collectionliteralexp.png"></div>
<p>
					
</p>
<p>集合文字包含<a class="link" href="EssentialOCL.html#EssentialOCL-CollectionType" title="CollectionType">CollectionType，</a>后跟括号，其中包含一个逗号分隔的零个或多个<a class="link" href="EssentialOCL.html#EssentialOCL-CollectionLiteralPart" title="CollectionLiteralPart">CollectionLiteralPart</a>列表。
					</p>
<p>例如<code class="code">Sequence{1,2,4..6}</code>
					
</p>
<p>请注意，集合中允许使用null，collection和tuple值，但不允许使用无效值。“包含”无效值的集合将展平为无效值。</p>
</div>
<div class="section" title="CollectionLiteralPart">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-CollectionLiteralPart"></a> CollectionLiteralPart</h4>
</div>
</div>
</div>
<p>CollectionLiteralPart语法支持在值集合中使用值或值范围。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-collectionliteralpart.png"></div>
<p>
					
</p>
<p>单个项目集合文字部分可以是任何表达式（无效除外）。例如<code class="code">1+2</code>
					
</p>
<p>多项集合文字部分包括两个整数限制之间的包含范围的值。</p>
<p>
						
<code class="code">1..3</code>是这三个值<code class="code">1</code> ， <code class="code">2</code> ， <code class="code">3</code> 。
					</p>
<p>
						
<code class="code">1..-1</code>是这三个值<code class="code">1</code> ， <code class="code">0</code> ， <code class="code">-1</code> 。
					</p>
</div>
<div class="section" title="TupleLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TupleLiteralExp"></a> TupleLiteralExp</h4>
</div>
</div>
</div>
<p>TupleLiteralExp语法支持在表达式中使用命名表达式值的元组。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-tupleliteralexp.png"></div>
<p>
					
</p>
<p>元组文字包含<code class="code">Tuple</code>关键字，后跟括号，其中包含一个或多个<a class="link" href="EssentialOCL.html#EssentialOCL-TupleLiteralPart" title="TupleLiteralPart">TupleLiteralPart</a>的逗号分隔列表。
					</p>
<p>
						
<code class="code">元组{年：整数= '2000'，一个月：字符串=“1月份，天：整数= '1'}</code>
					
</p>
</div>
<div class="section" title="TupleLiteralPart">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TupleLiteralPart"></a> TupleLiteralPart</h4>
</div>
</div>
</div>
<p>TupleLiteralPart语法支持在这些值的元组中使用命名表达式值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-tupleliteralpart.png"></div>
<p>
					
</p>
<p>该部分包括名称，可选类型和值。如果省略类型，则从值推断。</p>
<p>
						
<code class="code">leapyear：Boolean = true</code>
					
</p>
</div>
<div class="section" title="TypeLiteralExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TypeLiteralExp"></a> TypeLiteralExp</h4>
</div>
</div>
</div>
<p>TypeLiteralExp语法支持将类型用作表达式中的值。这对于诸如<code class="code">myCollection.oclAsType(Set&lt;MyType&gt;)</code>表达式很有用。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-typeliteralexp.png"></div>
<p>
					
</p>
<p>TypeLiteralExp包含<a class="link" href="EssentialOCL.html#EssentialOCL-TypeLiteral" title="TypeLiteral">TypeLiteral</a> 。
					</p>
</div>
<div class="section" title="NestedExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NestedExp"></a> NestedExp</h4>
</div>
</div>
</div>
<p>NestedExp语法支持使用内部表达式作为外部表达式中的术语，确保内部表达式的运算符优先级不受外部表达式的影响，</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-nestedexp.png"></div>
<p>
					
</p>
<p>嵌套表达式只是括号括起来的表达式。</p>
</div>
<div class="section" title="IfExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-IfExp"></a> IfExp</h4>
</div>
</div>
</div>
<p>IfExp语法支持在表达式中使用条件选择的表达式值。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-ifexp.png"></div>
<p>
					
</p>
<p>if表达式包含要测试的条件表达式，如果条件为真则包含要评估的then表达式，如果表达式为假，则包含用于评估的else表达式。</p>
<p>
						
<code class="code">如果this.size&gt; that.size然后这个那个结束</code>
					
</p>
<p>请注意，else-expression是必需的，因此当多个if表达式嵌套时没有歧义。</p>
</div>
<div class="section" title="LetExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-LetExp"></a> LetExp</h4>
</div>
</div>
</div>
<p>LetExp语法支持引入局部变量，以便于在表达式中重用中间结果。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-letexp.png"></div>
<p>
					
</p>
<p>let表达式包含let关键字，后跟一个或多个逗号分隔的let变量，然后是in关键字和in-expression，借助额外的变量进行评估。</p>
<p>每个let变量包含一个名称，一个可选类型和一个初始化变量的表达式。如果省略类型，则从初始化程序推断出。</p>
<div class="literallayout">
<p>
<code class="code">let test：String ='prefix [contents] suffix'，<br>start：Integer = test.indexOf（'['），<br>完成：Integer = test.indexOf（']'）<br>在test.substring（开始，完成）<br>

</code>
</p>
</div>
<p></p>
<p>let语法没有终止关键字，例如endlet，因此存在歧义，例如<code class="code">1 + let b : Integer = 2 in b + 4</code> 。通过选择最长可能的in-expression，将歧义解析为<code class="code">1 + let b : Integer = 2 in (b + 4)</code>的<code class="code">1 + let b : Integer = 2 in (b + 4)</code> 。
					</p>
</div>
<div class="section" title="NameExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NameExp"></a> NameExp</h4>
</div>
</div>
</div>
<p>NameExp语法支持使用模型元素的名称，例如表达式中的属性，操作或类型。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-nameexp.png"></div>
<p>
					
</p>
<p>名称表达式包含一个名称，该名称可选地以双冒号分隔的路径名称为前缀。</p>
<p>第一个名称是<a class="link" href="EssentialOCL.html#EssentialOCL-UnrestrictedName" title="UnrestrictedName">UnrestrictedName</a> ，它是一个不与任何OCL保留字（如<code class="code">else</code>或内置类型（如<code class="code">String</code>冲突的名称。后续名称为<a class="link" href="EssentialOCL.html#EssentialOCL-UnreservedName" title="UnreservedName">UnreservedName，</a>允许重复使用内置类型名称，但不允许重复使用保留字。
					</p>
</div>
<div class="section" title="IndexExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-IndexExp"></a> IndexExp</h4>
</div>
</div>
</div>
<p>IndexExp语法支持将限定符应用于模型属性以区分源或选择特定关联。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-indexexp1.png"></div>
<p>
					
</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-indexexp2.png"></div>
<p>
					
</p>
<p>标识模型属性的<a class="link" href="EssentialOCL.html#EssentialOCL-NameExp" title="NameExp">NameExp</a>可选地由第一个限定符列表和第二个限定符列表限定。
					</p>
<p>此语法是实验性的，评估时尚不支持限定符。</p>
</div>
<div class="section" title="NavigatingExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NavigatingExp"></a> NavigatingExp</h4>
</div>
</div>
</div>
<p>NavigatingExp语法支持使用模型属性，操作和迭代来导航模型。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-navigatingexp1.png"></div>
<p>
					
</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-navigatingexp2.png"></div>
<p>
					
</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-navigatingexp3.png"></div>
<p>
					
</p>
<p>标识可能合格的模型特征的<a class="link" href="EssentialOCL.html#EssentialOCL-IndexExp" title="IndexExp">IndexExp</a>可选地后跟带括号的参数。如果省略括号参数，则模型特征应为Property。如果参数存在，则模型特征应该是迭代或操作。
					</p>
<p>OCL 2.4为OperationCallExpCS和IteratorExpCS指定的各种语法会产生难以解析的歧义。Eclipse OCL使用的合并语法收集参数贡献而不强加过早验证。</p>
<p>带括号的参数可以是空的，或者可以包括一个或多个参数，可选的累加器和可选的主体。</p>
<p>以逗号分隔的参数列表以NavigatingArgCS开头，后跟任意数量的NavigatingCommaArgCS。</p>
<p>
						
<code class="code">simpleCall（simpleArgument）</code>
					
</p>
<p>可选的以逗号分隔的累加器列表由以分号为前缀的NavigatingSemiArgCS引入，后跟任意数量的NavigatingCommaArgCS。</p>
<p>
						
<code class="code">some-&gt; iterate（p; anAccumulator：Integer = 0 | p.size（））</code>
					
</p>
<p>可选的以逗号分隔的主体列表由垂直栏前缀的NavigatingBarArgCS引入，后跟任意数量的NavigatingCommaArgCS。</p>
<p>
						
<code class="code">some-&gt; exists（p | p.size（））</code>
					
</p>
</div>
<div class="section" title="NavigatingArg">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NavigatingArg"></a> NavigatingArg</h4>
</div>
</div>
</div>
<p>NavigatingArg语法支持解析在NavigatingExps中使用的潜在参数，累加器和实体。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-navigatingarg.png"></div>
<p>
					
</p>
<p>每种语法都支持表达式的可选类型和可选的初始值设定项。</p>
</div>
<div class="section" title="PrefixedExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-PrefixedExp"></a> PrefixedExp</h4>
</div>
</div>
</div>
<p>PrefixedExp语法支持将零个或多个前缀一元运算符应用于表达式。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-prefixedexp.png"></div>
<p>
					
</p>
<p>前缀运算符在表达式之前： <code class="code">-4</code>或<code class="code">not(this or that)</code>
					
</p>
<p>一元运算符是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">-</code>否定</p>
</li>
<li class="listitem">
<p>
								
<code class="code">not</code>逻辑补充</p>
</li>
</ul>
</div>
</div>
<div class="section" title="InfixedExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-InfixedExp"></a> InfixedExp</h4>
</div>
</div>
</div>
<p>InfixedExp语法支持在表达式术语之间应用零个或多个中缀二进制运算符。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-infixedexp.png"></div>
<p>
					
</p>
<p>中缀运算符分隔表达式术语： <code class="code">1 + 2 / 3 * 4 / 5 + 6</code> 。
					</p>
<p>中缀运营商是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><a class="link" href="EssentialOCL.html#EssentialOCL-NavigationOperators" title="NavigationOperators">NavigationOperators</a>
							
</p>
</li>
<li class="listitem">
<p>
								
<code class="code">*</code> ， <code class="code">/</code>乘以除</p>
</li>
<li class="listitem">
<p>
								
<code class="code">+</code> ， <code class="code">-</code>加减</p>
</li>
<li class="listitem">
<p>
								
<code class="code">&lt;</code> ， <code class="code">&lt;=</code> ， <code class="code">&gt;=</code> ， <code class="code">&gt;</code>关系比较</p>
</li>
<li class="listitem">
<p>
								
<code class="code">=</code> ， <code class="code">&lt;&gt;</code>平等和不平等</p>
</li>
<li class="listitem">
<p>
								
<code class="code">and</code>逻辑的</p>
</li>
<li class="listitem">
<p>
								
<code class="code">or</code>包容性的</p>
</li>
<li class="listitem">
<p>
								
<code class="code">xor</code>独家或</p>
</li>
<li class="listitem">
<p>
								
<code class="code">implies</code>逻辑含义</p>
</li>
</ul>
</div>
<p>运算符的优先级和关联性由OCL标准库模型定义，而不是由语法定义。OCL 2.4库优先级如上所述，所有运算符都是左关联的。因此，上述示例被解释为<code class="code">(1 + (((2 / 3) * 4) / 5)) + 6</code> 。
					</p>
</div>
<div class="section" title="NavigationOperators">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-NavigationOperators"></a> NavigationOperators</h4>
</div>
</div>
</div>
<p>NavigationOperators运算符是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<code class="code">.</code>用于对象导航</p>
</li>
<li class="listitem">
<p>
								
<code class="code">-&gt;</code>用于收集导航</p>
</li>
</ul>
</div>
</div>
<div class="section" title="TypeExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TypeExp"></a> TypeExp</h4>
</div>
</div>
</div>
<p>TypeExp语法支持将类型用作表达式。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-typeexp.png"></div>
<p>
					
</p>
<p>类型表达式可以是a</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-TypeNameExp" title="TypeNameExp">TypeNameExpCS</a> - 用户定义的类型</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-TypeLiteral" title="TypeLiteral">TypeLiteralCS</a> - 内置或聚合类型</p>
</li>
</ul>
</div>
</div>
<div class="section" title="TypeNameExp">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TypeNameExp"></a> TypeNameExp</h4>
</div>
</div>
</div>
<p>TypeNameExp语法支持使用用户定义的类型作为声明或表达式。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-typenameexp.png"></div>
<p>
					
</p>
<p>名称表达式包含一个类型的名称，该类型可选地以双冒号分隔的路径名称为前缀。</p>
<p>第一个名称是<a class="link" href="EssentialOCL.html#EssentialOCL-UnrestrictedName" title="UnrestrictedName">UnrestrictedName</a> ，它是一个不与任何OCL保留字（如<code class="code">else</code>或内置类型（如<code class="code">String</code>冲突的名称。后续名称为<a class="link" href="EssentialOCL.html#EssentialOCL-UnreservedName" title="UnreservedName">UnreservedName，</a>允许重复使用内置类型名称，但不允许重复使用保留字。
					</p>
</div>
<div class="section" title="TypeLiteral">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TypeLiteral"></a> TypeLiteral</h4>
</div>
</div>
</div>
<p>TypeLiteral语法支持使用内置或聚合类型作为声明或表达式。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-typeliteral.png"></div>
<p>
					
</p>
<p>类型文字可以是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-PrimitiveType" title="PrimitiveType">PrimitiveTypeCS</a>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-CollectionType" title="CollectionType">CollectionTypeCS</a>
							
</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="EssentialOCL.html#EssentialOCL-TupleType" title="TupleType">TupleTypeCS</a>
							
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="PrimitiveType">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-PrimitiveType"></a> PrimitiveType</h4>
</div>
</div>
</div>
<p>PrimitiveType语法支持在声明或表达式中使用的内置类型的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-primitivetype.png"></div>
<p>
					
</p>
<p>内置类型是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>布尔</p>
</li>
<li class="listitem">
<p>整数</p>
</li>
<li class="listitem">
<p>真实</p>
</li>
<li class="listitem">
<p>串</p>
</li>
<li class="listitem">
<p>UnlimitedNatural</p>
</li>
<li class="listitem">
<p>OclAny</p>
</li>
<li class="listitem">
<p>OclInvalid</p>
</li>
<li class="listitem">
<p>OclVoid</p>
</li>
</ul>
</div>
</div>
<div class="section" title="CollectionType">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-CollectionType"></a> CollectionType</h4>
</div>
</div>
</div>
<p>CollectionType语法支持在声明或表达式中使用的集合类型的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-collectiontype.png"></div>
<p>
					
</p>
<p>集合类型包括CollectionTypeIdentifier，后跟定义集合元素类型的<a class="link" href="EssentialOCL.html#EssentialOCL-TypeExp" title="TypeExp">Type Expression</a> 。
					</p>
<p>
						
<code class="code">Set(String)</code>或<code class="code">Sequence&lt;Bag&lt;Integer&gt;&gt;</code>
					
</p>
<p>内置的CollectionTypeIdentifiers是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>采集</p>
</li>
<li class="listitem">
<p>袋</p>
</li>
<li class="listitem">
<p>OrderedSet</p>
</li>
<li class="listitem">
<p>序列</p>
</li>
<li class="listitem">
<p>组</p>
</li>
</ul>
</div>
<p>OCL 2.4指定使用括号来包围元素类型。Eclipse OCL还允许使用UML指定的尖括号，并且可能需要支持更常规的模板类型。</p>
</div>
<div class="section" title="TupleType">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TupleType"></a> TupleType</h4>
</div>
</div>
</div>
<p>TupleType语法支持在声明或表达式中使用的元组类型的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-tupletype.png"></div>
<p>
					
</p>
<p>元组类型包括<code class="code">Tuple</code>关键字，后跟逗号分隔的一个或多个<a class="link" href="EssentialOCL.html#EssentialOCL-TuplePart" title="TuplePart">TuplePart</a>列表。
					</p>
<p>OCL 2.4指定使用括号来包围零件。Eclipse OCL还允许使用UML指定的尖括号，并且可能需要支持更常规的模板类型。</p>
<p>
						
<code class="code">组&lt;年：整数，月：字符串，天：整数&gt;</code>
					
</p>
</div>
<div class="section" title="TuplePart">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-TuplePart"></a> TuplePart</h4>
</div>
</div>
</div>
<p>TuplePart语法支持TupleType元素的定义。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1100-tuplepart.png"></div>
<p>
					
</p>
<p>该部分包括名称，类型和值。</p>
<p>
						
<code class="code">leapyear：布尔值</code>
					
</p>
</div>
<div class="section" title="UnreservedName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-UnreservedName"></a> UnreservedName</h4>
</div>
</div>
</div>
<p>基本的OCL保留字是<code class="code">and</code> ， <code class="code">else</code> ， <code class="code">endif</code> ， <code class="code">false</code> ， <code class="code">if</code> ， <code class="code">implies</code> ， <code class="code">in</code> ， <code class="code">invalid</code> ， <code class="code">let</code> ， <code class="code">not</code> ， <code class="code">null</code> ， <code class="code">or</code> <code class="code">self</code> ， <code class="code">then</code> ， <code class="code">true</code> ， <code class="code">xor</code> 。这些只能在<code class="code">_'self'</code>转义时用作名称。
					</p>
</div>
<div class="section" title="UnrestrictedName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EssentialOCL-UnrestrictedName"></a> UnrestrictedName</h4>
</div>
</div>
</div>
<p>基本OCL限制词是上面的保留字和OCL保留类型名称，包括<code class="code">Bag</code> ， <code class="code">Boolean</code> ， <code class="code">Collection</code> ， <code class="code">Integer</code> ， <code class="code">Lambda</code> ， <code class="code">OclAny</code> ， <code class="code">OclInvalid</code> ， <code class="code">OclMessage</code> ， <code class="code">OclSelf</code> ， <code class="code">OclVoid</code> ， <code class="code">OrderedSet</code> ， <code class="code">Real</code> ， <code class="code">Sequence</code> ， <code class="code">Set</code> ， <code class="code">String</code> ， <code class="code">Tuple</code> ， <code class="code">UnlimitedNatural</code> 。UnrestrictedName可以在任何上下文中使用。保留类型名称可以在<code class="code">::</code> <code class="code">_'Boolean'</code>使用，不限定的无限制名称必须转义为<code class="code">_'Boolean'</code> 。
					</p>
<p>
						
<code class="code">Lambda</code>用于实验语法，将迭代器体实现为lambda表达式。
					</p>
</div>
</div>
</div>
</body>
</html><html id="2296.OCLExamplesforUML.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>UML的OCL约束示例（使用Papyrus）</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="UsersGuide.html" title="Users Guide"></link>
<link rel="prev" href="OCLinPapyrus.html" title="OCL in UML (using Papyrus)"></link>
<link rel="next" href="UserInterface.html" title="User Interface"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">UML的OCL约束示例（使用Papyrus）</h1>
<div class="section" title="UML的OCL约束示例（使用Papyrus）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OCLExamplesforUML"></a> UML的OCL约束示例（使用Papyrus）</h2>
</div>
</div>
</div>
<p>（本文档适用于Papyrus 3.0.0和Eclipse Oxygen。）</p>
<p><a class="link" href="OCLinPapyrus.html" title="OCL in UML (using Papyrus)">UML中</a>的<a class="link" href="OCLinPapyrus.html" title="OCL in UML (using Papyrus)">OCL（使用Papyrus）</a>部分显示了如何<a class="link" href="OCLinPapyrus.html" title="UML中的OCL（使用Papyrus）">使用Papyrus</a>来创建和维护丰富UML模型或配置文件的OCL表达式。
			</p>
<p>在本节中，我们将展示一些简单且不那么简单的OCL示例如何解决有用的规范问题。</p>
<p>OCL约束可以在任何元级别指定。类级别定义实例级使用的类型和属性。OCL约束验证实例是否合规。因此，OCL使用类级别的类型和属性在实例级别的实例上执行。</p>
<p>约束可以仅用于记录设计意图，但是在给定适当的环境的情况下，可以测试和/或使用约束来验证模型的一致性。这可能是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>通过使用UML InstanceSpecification定义测试模型来实例化UML模型。</p>
</li>
<li class="listitem">
<p>通过实例化Uore模型的Ecore等效创建的实时模型</p>
</li>
<li class="listitem">
<p>符合UML配置文件的UML模型</p>
</li>
</ul>
</div>
<p>在请求验证模型的所有情况下，验证器尝试对其应用的每个可能实例执行每个可能的约束。执行约束时，验证器将<code class="code">self</code>变量绑定到要验证的实例。<code class="code">self</code>的类型由约束的上下文决定。在Papyrus中，此上下文由Constraint的<code class="code">&lt;&lt;context&gt;&gt;</code>链接的非Constraint结束决定。评估约束的结果应该为<code class="code">true</code>或<code class="code">false</code> 。如果为<code class="code">true</code> ，则满足约束。如果为<code class="code">false</code> ，则违反约束，并且应向用户显示某些诊断。
			</p>
<p>在<a class="link" href="OCLExamplesforUML.html#OCLM1Constraints" title="模型约束">模型约束中</a> ，我们提供了适用于UML模型元素的示例。约束在模型的实例上进行评估。如何诊断违规取决于模型实例的合成和相应的运行时环境。
			</p>
<p>在<a class="link" href="OCLExamplesforUML.html#OCLM2Constraints" title="配置文件约束">Profile Constraints中</a> ，我们提供了适用于UML概要文件元素的示例。评估约束以验证模型中元素的一致使用。在UML编辑器中诊断出违规。
			</p>
<div class="section" title="模型约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLM1Constraints"></a>模型约束</h3>
</div>
</div>
</div>
<div class="section" title="简单的元模型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="SimpleMetamodel"></a>简单的元模型</h4>
</div>
</div>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-metamodel.png"></div>
<p>
					
</p>
<p>该图显示了UML中指定为元卷模型的元模型。上半部分显示了一个简单的元模型，它只包含一个<code class="code">Person</code>类。一个<code class="code">Person</code>有一个<code class="code">String</code> -valued <code class="code">name</code> ，可能有一个<code class="code">partner</code> ， <code class="code">parents</code>和/或<code class="code">children</code> 。
					</p>
<p>可以使用UML功能直接指定诸如<code class="code">parents[0..2]</code>对父项数量限制为2的约束而不使用OCL。但是更多具有挑战性的限制需要OCL限制，在图的下半部分提供了五个示例。
					</p>
</div>
<div class="section" title="标量约束">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ScalarConstraints"></a>标量约束</h4>
</div>
</div>
</div>
<p>为了帮助理解OCL评估的方式，考虑一些符合约束模型的实例是有帮助的</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-scalars.png"></div>
<p>
					
</p>
<p>该图显示了一个由三个人组成的模型，其名字是<code class="code">father</code> ， <code class="code">mother</code>和<code class="code">baby</code> 。
					</p>
<p>图中的符号类似于UML对象图。
						<span class="emphasis"><em>这应该是在纸莎草纸上绘制的，不幸的是，许多虫子在纸莎草的氧气释放中阻止了这种情况</em></span> 。该符号略微偏离UML，仅通过下划线类型名称，并使用圆角矩形来区分DataType值和Class实例。
					</p>
<p><code class="code">Person</code>的三个实例显示为三个矩形，实例名称为<code class="code">pa</code> ，下划线类型为<code class="code">Person</code> 。这三个名称显示为圆角矩形，其值为<code class="code">father</code>和<code class="code">String</code> 。<code class="code">Person</code>实例与其<code class="code">name</code>之间的关联由<code class="code">Person</code>实例到值的有向链接显示。该链接标有关系角色，即<code class="code">name</code> 。
					</p>
<p><code class="code">partner</code>关系角色类似地通过从<code class="code">pa</code>到<code class="code">ma</code>的有向链接显示，反之亦然。
					</p>
<div class="section" title="NameIsAlphabetic">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="NameIsAlphabetic"></a>
							<code class="code">NameIsAlphabetic</code>
						
</h5>
</div>
</div>
</div>
<p>最简单的示例约束使用正则表达式来指定<code class="code">name</code>必须仅包含字母字符。
						</p>
<div class="literallayout">
<p>
<code class="code">self.name.matches（ '[A-ZA-Z] *'）<br>

</code>
</p>
</div>
<p>的<code class="code">.</code>是OCL对象导航操作符。它分隔了一系列导航步骤，每个导航步骤都返回一个结果值。
						</p>
<p>评估从<code class="code">self</code>开始，在Java中与<code class="code">this</code>类似，它绑定到一个对象，其类型是Constraint的上下文。因此结果是一个<code class="code">Person</code>对象，例如<code class="code">pa</code> 。
						</p>
<p>属性导航步骤<code class="code">name</code>遍历其角色为<code class="code">name</code>的关系。导航步骤从<code class="code">pa</code>到<code class="code">father</code>值。结果是包含<code class="code">father</code>的String。
						</p>
<p>操作调用步骤<code class="code">matches('[a-zA-Z]*')</code> ，使用提供的正则表达式执行正则表达式匹配函数。最终结果是<code class="code">true</code> <code class="code">false</code> 。
						</p>
</div>
<div class="section" title="NoSelfPartnership">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="NoSelfPartnership"></a>
							<code class="code">NoSelfPartnership</code>
						
</h5>
</div>
</div>
</div>
<p>另一个非常简单的示例约束检查<code class="code">partner</code>关系与源和目标不具有相同的<code class="code">Person</code> 。
						</p>
<div class="literallayout">
<p>
<code class="code">self.partner &lt;&gt; self<br>

</code>
</p>
</div>
<p>OCL包含由infix <code class="code">&lt;&gt;</code>运算符分隔的两个导航表达式。
						</p>
<p>第一个是<code class="code">self.partner</code> ，从<code class="code">self</code>导航到计算包含<code class="code">self</code>上下文实例的<code class="code">partner</code>的结果。
						</p>
<p>第二个， <code class="code">self</code>只返回上下文实例。
						</p>
<p>not-equals <code class="code">&lt;&gt;</code>缀运算符比较其前后参数，并在参数不相等时提供<code class="code">true</code>结果，在相等时提供<code class="code">false</code> 。
						</p>
</div>
</div>
<div class="section" title="集合约束">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="CollectionConstraints"></a>集合约束</h4>
</div>
</div>
</div>
<p>对象和值之间的一对一关系具有通常涉及指针的简单实现。由于涉及到一组值，因此一对多和多对多关系更复杂。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-collections.png"></div>
<p>
					
</p>
<p>上图详细说明了前面的图，以显示多对多关系。该图还通过在<code class="code">Person</code>实例中嵌入每个<code class="code">name</code>值，使用更简单的对象表示来评估关系。<code class="code">partner</code>之间的一对一对象关系不受影响。使用绘制为三个重叠矩形的多对象来显示诸如<code class="code">parents</code>类的多对多关系。每个多对象通常是关系源所拥有的集合，并由标有关系名称的实心箭头显示。集合的每个元素由虚线箭头标识。
						因此， <code class="code">child</code>有两个<code class="code">parents</code> ; <code class="code">pa</code>和<code class="code">ma</code> 。事实上，多对多关系可以在每个方向上实现为独立的一对多关系。的<code class="code">children</code>相对的<code class="code">parents</code>因此由示出<code class="code">children</code>多对象为每个父识别所述一个孩子。
					</p>
<p>当Ecore用于实现UML时，多重对象由<code class="code">EList</code>以这种方式实现。
					</p>
<p>OCL提供了在表达式中使用这些多对象的功能。多对象是<code class="code">Collection</code> ，或者更具体地是<code class="code">Bag</code> ， <code class="code">OrderedSet</code> ， <code class="code">Sequence</code>或<code class="code">Set</code>这取决于to-many-relationship是否被指定为<code class="code">ordered</code>和/或<code class="code">unique</code> 。
					</p>
<p>在OCL中， <code class="code">-&gt;</code>是集合导航操作符，它使评估能够利用所有目标对象。
					</p>
<div class="section" title="EachChildHasTwoParents">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="EachChildHasTwoParents"></a> EachChildHasTwoParents</h5>
</div>
</div>
</div>
<p>每个孩子应该有两个父母，但在任何有限的模型中，必须有一些<code class="code">Person</code>实例，父母被省略。因此，模型指定[0..2]多重性而不是精确[2..2]。我们可以通过OCL约束来弥补这一不足。
						</p>
<div class="literallayout">
<p>
<code class="code">self.children-&gt; forAll（child | child.parents-&gt; size（）= 2）<br>

</code>
</p>
</div>
<p><code class="code">self</code>和<code class="code">children</code>从context对象导航，以定位上下文实例的所有子节点的集合作为导航结果。
						</p>
<p><code class="code">-&gt;</code> collection运算符和随后的<code class="code">forAll(child | ...)</code>迭代导致<code class="code">forAll(child | ...)</code>执行迭代，将每个子<code class="code">forAll(child | ...)</code>依次分配给<code class="code">child</code>迭代器变量。对每个孩子评估<code class="code">...</code>迭代器主体并进行累积，以便只有在每个<code class="code">child</code>的身体评估也为<code class="code">true</code>时， <code class="code">forAll</code>的结果才为<code class="code">true</code> 。
						</p>
<p>迭代主体从每个<code class="code">child</code>导航以选择其所有<code class="code">parents</code>的集合。然后<code class="code">-&gt;</code>集合导航操作符调用集合操作<code class="code">size()</code>来计算集合的大小。使用<code class="code">=</code> （等于）运算符将此大小与常量<code class="code">2</code> 。因此迭代体返回<code class="code">false</code>除非父项的数量等于2。
						</p>
<p>这个例子可以更紧凑地编写</p>
<div class="literallayout">
<p>
<code class="code">children-&gt; forAll（parents-&gt; size（）= 2）<br>

</code>
</p>
</div>
<p>因为隐式迭代器是迭代体内导航的默认源，而<code class="code">self</code>是默认外部。
						</p>
</div>
<div class="section" title="AcyclicAncestry">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="AcyclicAncestry"></a> AcyclicAncestry</h5>
</div>
</div>
</div>
<p>用户模型的实例通常形成非循环图。因此，希望将其指定为OCL约束，以便OCL模型验证器检测任何周期。在OCL传递闭包迭代的帮助下，这很容易指定。</p>
<div class="literallayout">
<p>
<code class="code">self.parents-&gt; closure（parent | parent.parents） - &gt;排除（个体经营）<br>

</code>
</p>
</div>
<p><code class="code">self.parents</code>导航再次返回上下文实例的所有父项的集合。此集合用作种子， <code class="code">closure(parent | ... )</code>集合迭代通过重复聚合<code class="code">...</code> body评估的结果来生成最终结果。中间结果的每个元素都绑定到<code class="code">parent</code>迭代器，直到结果中没有剩余值，而迭代体尚未被评估。
						</p>
<p><code class="code">parent.parents</code>迭代主体只返回给定父级的所有父级，以便关闭逐步聚合祖父母，然后是曾祖父母，然后......
						</p>
<p>一旦<code class="code">closure</code>完成，它将返回所有祖先的<code class="code">Set</code> （或<code class="code">OrderedSet</code> ），并将其传递给<code class="code">excludes</code>运算符以确认<code class="code">self</code>实例不是其自身的祖先。
						</p>
<p>这个例子可以更紧凑地编写</p>
<div class="literallayout">
<p>
<code class="code">parents-&gt;关闭（父母） - &gt;不包括（个体经营）<br>

</code>
</p>
</div>
</div>
<div class="section" title="EachChildsParentsArePartners">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="EachChildsParentsArePartners"></a> EachChildsParentsArePartners</h5>
</div>
</div>
</div>
<p>用户模型可能并不总是允许其实例之间的任意关系。OCL约束可以强制规则，并且在更复杂的OCL约束内，一个或多个let变量可以提供有助于可读性的结构。</p>
<p>在我们的例子中，我们可能希望强制要求孩子的两个父母是伴侣。</p>
<div class="literallayout">
<p>
<code class="code">让selfAndPartner = self.oclAsSet（） - &gt;包括（self.partner）in<br>self.children-&gt; forAll（child | selfAndPartner-&gt; includesAll（child.parents））<br>

</code>
</p>
</div>
<p><code class="code">let selfAndPartner ... in ...</code>将第一个<code class="code">...</code>表达式的值赋给<code class="code">selfAndPartner</code> let-variable，这样<code class="code">selfAndPartner</code>就可以用于评估提供最终结果的第二个<code class="code">...</code>表达式。let-variable允许子计算多次重复使用，或者只是分配给可读名称。
						</p>
<p>let变量首先使用<code class="code">self.oclAsSet()</code>来计算包含<code class="code">self</code>的单个元素Set然后使用<code class="code">including(self.partner)</code>的集合操作来计算包含原始集合的所有（一个）元素的另一个集合。包括另一个元素。因此，结果是一组两个元素， <code class="code">self</code>和<code class="code">self.partner</code> 。
						</p>
<p>如前<code class="code">self.children-&gt;forAll(child | ...)</code>结合每个孩子的<code class="code">child</code>迭代器，并要求<code class="code">...</code>身体的计算结果为<code class="code">true</code>为所有值<code class="code">child</code> 。身体验证在<code class="code">selfAndPartner</code>缓存的那对人包括由<code class="code">child.parents</code>识别的每个人。
						</p>
<p>这个例子可以更紧凑地编写</p>
<div class="literallayout">
<p>
<code class="code">让selfAndPartner = self-&gt;包括（伙伴）in<br>children-&gt; forAll（selfAndPartner = parents）<br>

</code>
</p>
</div>
<p>更紧凑的形式利用了对<code class="code">-&gt;</code>集合导航操作符具有非集合作为其源的<code class="code">oclAsSet()</code>的隐式调用。
						</p>
<p>消除明确<code class="code">child</code>从迭代器<code class="code">forAll</code>迭代是允许的，但也许是不明智的，因为一个偶然的OCL用户可能很难理解最终是否<code class="code">parents</code>是<code class="code">self.parents</code>或<code class="code">child.parents</code> 。
						</p>
</div>
</div>
</div>
<div class="section" title="配置文件约束">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLM2Constraints"></a>配置文件约束</h3>
</div>
</div>
</div>
<p>UML概要文件通过定义可添加到元模型元素的原型来提供扩展现有元模型的能力。所述<code class="code">Ecore.profile.uml</code>其中注释<code class="code">UML.uml</code>定义了Eclipse UML的支持是这样的使用的一个很好的例子。通过新的元模型可以更好地实现扩展单个类元模型的设计示例。
				</p>
<div class="section" title="示例配置文件">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExampleProfile"></a>示例配置文件</h4>
</div>
</div>
</div>
<p>我们设计的示例提供了两种形式的扩展，即针对<code class="code">Person</code>元素的<code class="code">Gender</code>和<code class="code">Role</code> ，但由于我们定义了一个配置文件，因此我们必须定义<code class="code">Person</code>的元类的扩展，即<code class="code">Class</code> 。我们还定义了另一个扩展， <code class="code">Vehicle</code> ，对于一个<code class="code">Class</code>是明智的，但对于一个<code class="code">Person</code>显然是愚蠢的。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-profile.png"></div>
<p>
					
</p>
<p>一个<code class="code">Person</code>可能将<code class="code">Gender</code>定义为一种抽象的刻板印象，从中可以得出具体的<code class="code">Male</code>和<code class="code">Female</code>刻板印象。
					</p>
<p>一个<code class="code">Person</code>可以将一个或多个<code class="code">Role</code>定义为抽象刻板印象，具体的<code class="code">Astronaut</code>和<code class="code">Priest</code>刻板印象从中衍生出来。<code class="code">Priest</code>提供额外的<code class="code">priesthood</code>查点财产，确定牧师的宗教信仰。</p>
<p>这些定义被绘制为从基本构造型（如<code class="code">Gender</code> ）到元类（如<code class="code">Class</code>的扩展链接。链接是一个UML <code class="code">Extension</code> ，它是一种<code class="code">Association</code>形式，因此它的两端有两个自动合成的<code class="code">Property</code>元素。通过将<code class="code">base_</code>或<code class="code">extension_</code>前缀应用于目标类/元类名称来派生属性角色名称。因此， <code class="code">base_Class</code>属性标识<code class="code">Extension</code>的<code class="code">Class</code> metaclass end， <code class="code">extension_Gender</code>标识<code class="code">Gender</code> end。
					</p>
<p><code class="code">extension_</code>属性具有多重性，[0..1]指定允许<code class="code">Gender</code>构造型的最多一个应用程序。或者，[0 .. *] multiplicity指定可以使用零个或多个<code class="code">Role</code>构造型的应用程序;牧师也可能是宇航员。非零下限的规范是可能的，但通常不合适，因为应用于元类。如果一个完全独立的类（如<code class="code">Road</code>也被建模，则强制始终应用<code class="code">Gender</code>会导致愚蠢。
					</p>
<p>扩展多样性对构造型的使用提供了非常有限的设计规则。通常需要要求OCL约束的更复杂的规则。稍后示出并解释了四个示例。</p>
<p>
						
<span class="emphasis"><em>（Papyrus的氧气释放为刻板印象的多重性提供了误导性的编辑界面。在Model Explorer视图中选择扩展名后，仅使用高级属性</em></span> 。
					</p>
</div>
<div class="section" title="示例剖析模型">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExampleProfiledModel"></a>示例剖析模型</h4>
</div>
</div>
</div>
<p>刻板印象的应用相对简单，而不是本节的主题。配置文件应用于模型，以便可以将其构造型应用于元素。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-profiled.png"></div>
<p>
					
</p>
<p>应用的刻板印象在guilemets中显示。上面的示例显示了已应用<code class="code">Female</code>和<code class="code">Priest</code>型的名为<code class="code">Priestess</code>的派生<code class="code">Person</code>类的定义。图中未显示具有<code class="code">RABBI</code>值的<code class="code">Priest::priesthood</code>属性的定义。
					</p>
<p>UML表示看似简单，因此在编写OCL约束时相当混乱。我们需要查看OCL评估使用的等效对象模型。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1720-persons-applied.png"></div>
<p>
					
</p>
<p>这个图只显示了<code class="code">Priestess</code>课程。在中心， <code class="code">Class</code>元类的实例被实例化为名为<code class="code">Priestess</code>的<code class="code">Class</code> ，其具有名为<code class="code">name</code>的继承的String值<code class="code">Property</code> 。每个<code class="code">Stereotype</code>元类都被实例化为没有类型规范的元素。这些元素被命名为<code class="code">Priest</code>和<code class="code">Female</code> 。
					</p>
<p>
						
<span class="emphasis"><em>缺少类型规范，因为UML规范不需要构造型实例的概念。这种省略导致UML的XMI序列化的复杂性。省略的类型由名称周围的guilemets表示。</em></span>
					
</p>
<p><code class="code">Priestess</code>和<code class="code">«Female»</code>之间的关系显示了合成的<code class="code">base_Class</code>和<code class="code">extension_Gender</code>关系。请注意，它是<code class="code">extension_Gender</code>而不是<code class="code">extension_Female</code>因为配置文件将<code class="code">Gender</code>定义为<code class="code">Class</code>元类的扩展。
						<code class="code">Female</code>是定义的扩展的派生。
					</p>
<p>由于可以应用多个<code class="code">Role</code> ，因此<code class="code">Priestess</code>和<code class="code">«Priest»</code>之间的关系更加复杂。因此， <code class="code">extension_Role</code>标识零个或多个<code class="code">Role</code>的集合。该示例显示该集合仅包含一个<code class="code">«Priest»</code>元素。
					</p>
<p>我们现在可以检查一些示例约束，以了解约束评估如何使用此模型。</p>
<div class="section" title="男女不限">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="MaleOrFemale"></a>
							<code class="code">MaleOrFemale</code>
						
</h5>
</div>
</div>
</div>
<p>抽象<code class="code">«Gender»</code>刻板印象的简单示例约束确认仅应用了<code class="code">«Female»</code>或<code class="code">«Male»</code>刻板印象中的一种。
						</p>
<div class="literallayout">
<p>
<code class="code">让gender = self.base_Class.extension_Gender in<br>gender.oclIsKindOf（男）&lt;&gt; gender.oclIsKindOf（女）<br>

</code>
</p>
</div>
<p>导航以<code class="code">self</code>绑定到<code class="code">«Gender»</code>实例开始，因为这是Constraint定义的<code class="code">«context»</code> 。导航到<code class="code">base_Class</code>找到提供<code class="code">base_Class</code>的<code class="code">Class</code>实例。对<code class="code">extension_Gender</code>的进一步导航为构造型的任何相应应用程序定位<code class="code">«Gender»</code>实例。此实例保存在<code class="code">gender</code>变量中。
						</p>
<p>如果<code class="code">gender</code>是<code class="code">Male</code> <code class="code">oclIsKindOf(Male)</code>型实例，则使用<code class="code">oclIsKindOf(Male)</code>从<code class="code">gender</code>导航的后续操作将返回<code class="code">true</code> ，否则返回<code class="code">false</code> 。对<code class="code">oclIsKindOf(Female)</code>的类似测试进行比较，以便约束仅在应用的<code class="code">oclIsKindOf(Female)</code>型不同时才为<code class="code">true</code> 。
						</p>
<p>这种约束有点多余，因为<code class="code">«Gender»</code>刻板印象的最多一个多样性会抑制任何双重应用。因此，变量<code class="code">gender</code>始终与<code class="code">self</code>相同。因此，可以更紧凑地编写此约束：</p>
<div class="literallayout">
<p>
<code class="code">真正<br>

</code>
</p>
</div>
</div>
<div class="section" title="GenderIsRequired">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="GenderIsRequired"></a>
							<code class="code">GenderIsRequired</code>
						
</h5>
</div>
</div>
</div>
<p>更有用的约束要求应用<code class="code">«Role»</code>每个非抽象类也具有<code class="code">«Gender»</code>构造型的应用。
						</p>
<div class="literallayout">
<p>
<code class="code">不是self.base_Class.isAbstract意味着<br>self.base_Class.extension_Gender &lt;&gt; null<br>

</code>
</p>
</div>
<p>当我们对单实例示例模型进行求值时，评估从<code class="code">self</code>绑定到<code class="code">«Priest»</code>构造型实例开始，因为约束定义的<code class="code">«context»</code>是<code class="code">Priest</code>派生的<code class="code">Role</code> 。
						</p>
<p>
							
<code class="code">self.base_Class</code>从<code class="code">«Priest»</code> <code class="code">self.base_Class</code>型实例导航到<code class="code">Priestess</code>类实例，其中<code class="code">isAbstract</code>导航用于测试<code class="code">UML::Class::isAbstract</code>属性以确定<code class="code">Priestess</code>是否是抽象的。
						</p>
<p><code class="code">x implies y</code>缀运算符通常更具可读性<code class="code">(not x) or y</code> ;当第一个表达式为<code class="code">false</code>时，它可以方便地对垃圾秒表达式的评估进行短路。在此示例中，对抽象类的实例绕过后续评估。
						</p>
<p><code class="code">self.base_Class.extension_Gender</code>首先导航到<code class="code">Priestess</code>类实例，然后导航到<code class="code">«Gender»</code> <code class="code">self.base_Class.extension_Gender</code>型实例。如果有这样的实例，或者该导航返回一个非空的对象<code class="code">null</code>如果不存在。因此，当应用了<code class="code">Gender</code>构造型时， <code class="code">&lt;&gt; null</code>比较返回<code class="code">true</code> ;或未应用时为<code class="code">false</code> 。
						</p>
<p>请注意，这些示例将相关的构造型指定为<code class="code">«context»</code> 。当<code class="code">Class</code>元类被指定为<code class="code">«context»</code>时，可以编写相同的约束。
						</p>
<div class="literallayout">
<p>
<code class="code">不是抽象暗示<br>extension_Role-&gt; notEmpty（）暗示<br>extension_Gender &lt;&gt; null<br>

</code>
</p>
</div>
<p>然而，这是低效的，因为它必须对所有可能的类执行，其中它执行双重测试“任何角色”然后“检查性别”。通过定义<code class="code">Role</code>的约束，第一个测试是免费执行的。避免对<code class="code">Road</code>元素进行冗余评估。当然，可能需要将<code class="code">Role</code>仅应用于<code class="code">Person</code>的单独约束。
						</p>
<div class="literallayout">
<p>
<code class="code">base_Class.oclIsKindOf（人）<br>

</code>
</p>
</div>
</div>
<div class="section" title="CatholicPriestsAreMale">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="CatholicPriestsAreMale"></a>
							<code class="code">CatholicPriestsAreMale</code>
						
</h5>
</div>
</div>
</div>
<p>更强的约束可能要求一个商业规则，例如要求<code class="code">CATHOLIC</code>牧师是男性。
						</p>
<div class="literallayout">
<p>
<code class="code">self.priesthood = Priesthood :: CATHOLIC暗示<br>self.base_Class.extension_Gender.oclIsKindOf（男）<br>

</code>
</p>
</div>
<p><code class="code">implies</code>的左侧将约束限制为已为<code class="code">priesthood</code>元属性分配了<code class="code">CATHOLIC</code>枚举值的情况。在我们的单个类示例中， <code class="code">Priestess</code>被赋值为<code class="code">RABBI</code> ，因此测试总是失败。如果定义了另一个<code class="code">CatholicPriest</code>类，则此约束变得有用，因为<code class="code">implies</code>表达式的右侧检查<code class="code">«Gender»</code>构造型实例是否存在并且是<code class="code">«Male»</code>构造型实例。
						</p>
</div>
<div class="section" title="AtMostOnePriesthood">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="AtMostOnePriesthood"></a>
							<code class="code">AtMostOnePriesthood</code>
						
</h5>
</div>
</div>
</div>
<p>由于允许多个<code class="code">«Role»</code>构造型实例，我们可能需要业务规则来禁止应用两个<code class="code">Priest</code>型。
						</p>
<div class="literallayout">
<p>
<code class="code">self.base_Class.extension_Role-&gt; selectByKind（Priest） - &gt; size（）= 1<br>

</code>
</p>
</div>
<p>和之前一样， <code class="code">self</code>是一个<code class="code">«Role»</code> <code class="code">base_Class</code>型实例，因此导航到<code class="code">base_Class</code>识别已经<code class="code">base_Class</code>的<code class="code">Person</code>类。<code class="code">extension_Role</code>标识所有应用的<code class="code">Role</code>构造型的集合，因为允许多个应用程序。
						</p>
<p>的<code class="code">-&gt;</code>采集导航操作和收集操作<code class="code">selectByKind(Priest)</code>返回经过滤的集合，仅选择那些，或从导出那些原型实例<code class="code">Priest</code>铅板。进一步的<code class="code">-&gt;</code>集合导航操作符和<code class="code">size()</code>集合操作计算此集合的大小。如果大小等于1，则约束结果为<code class="code">true</code> ;否则是<code class="code">false</code> 。
						</p>
</div>
<div class="section" title="- &gt; notEmpty（）">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="notEmpty"></a>
							<code class="code">-&gt;notEmpty()</code>
						
</h5>
</div>
</div>
</div>
<p><code class="code">-&gt;notEmpty()</code>集合导航和操作便于测试是否存在一个或多个构造型的应用程序。
						</p>
<div class="literallayout">
<p>
<code class="code">self.base_Class.extension_Role-&gt; notEmpty（）<br>

</code>
</p>
</div>
<p>在最多一个应用程序可能的情况下，使用<code class="code">-&gt;notEmpty()</code>并不罕见。
						</p>
<div class="literallayout">
<p>
<code class="code">self.base_Class.extension_Gender-&gt; notEmpty（）<br>

</code>
</p>
</div>
<p>这没有错，但效率稍低，因为它引发了以下自动非集合来设置转换。</p>
<div class="literallayout">
<p>
<code class="code">self.base_Class.extension_Gender.oclAsSet（） - &gt; notEmpty（）<br>

</code>
</p>
</div>
<p>写作更有效率</p>
<div class="literallayout">
<p>
<code class="code">self.base_Class.extension_Gender &lt;&gt; null<br>

</code>
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html><html id="3157.org_eclipse_ui_popupMenus.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>弹出菜单</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">弹出菜单</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.popupMenus<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于向其他插件所拥有的上下文菜单添加新操作。可以针对特定对象类型（ <samp>objectContribution</samp> ）或针对视图或编辑器部件（ <samp>viewerContribution</samp> ）的特定上下文菜单进行操作贡献。使用<samp>objectContribution时</samp> ，贡献将出现在所有视图或编辑器部件上下文菜单中，其中选择了指定类型的对象。相反，使用<samp>viewerContribution时</samp> ，无论选择如何，贡献都只会出现在视图或编辑器的指定上下文菜单中。
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>来放置命令编辑器或查看上下文菜单。
</p>
<p>当选择是异构的时，如果可能的话，如果针对共同类型的选择进行注册，则将应用该贡献。如果无法直接匹配，则将尝试匹配超类和超接口。
</p><p>通过使用名称过滤器可以进一步限制选择。如果使用，则选择中的所有对象必须与过滤器匹配才能应用贡献。
</p><p>对象贡献中的各个动作可以使用属性<code>enablesFor</code>来指定它是否应该仅应用单个，多个或任何其他选择类型。
</p><p>如果这些过滤机制不充分，则动作贡献可以使用<samp>过滤</samp>机制。在这种情况下，目标对象的属性在一系列名称 - 值对中描述。适用于选择的属性是特定于类型的，并且超出了工作台本身的范围，因此工作台会将此级别的过滤委派给实际选择。
</p><p><code>objectContribution</code>元素使用核心表达式<code>enablement</code> ，如<a href="org_eclipse_core_expressions_definitions.html">org.eclipse.core.expressions.definitions中</a>所定义。</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.objectContribution">objectContribution</a> *， <a href="#e.viewerContribution">viewerContribution</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectContribution">objectContribution</a> （ <a href="#e.filter">filter</a> *， <a href="#e.visibility">visibility</a> ？， <a href="#e.enablement">enablement</a> ？， <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectcontribution</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">objectClass CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">nameFilter CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">adaptable（true | false）“false”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素用于为选择了指定类型的对象的任何查看器上下文菜单定义一组动作和/或菜单。 <code>enablement</code>在此元素是指核心表达启用，如在定义<a href="org_eclipse_core_expressions_definitions.html">org.eclipse.core.expressions.definitions</a> ，并影响objectContribution的启用不包含的动作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符</li>
<li><b>objectClass</b> - 选择中的所有对象必须子类或实现的类或接口的完全限定名称。</li>
<li><b>nameFilter</b> - 名称的可选通配符过滤器，可应用于选择中的所有对象。如果没有匹配，将不会发生任何贡献。</li>
<li><b>adaptable</b> - 一个标志，指示适应IResource的类型是否应使用此对象贡献。仅当objectClass适应IResource时才使用此标志。默认值为false。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewerContribution">viewerContribution</a> （ <a href="#e.visibility">visibility</a> ？， <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST viewer贡献</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">targetID CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于为特定视图或编辑器部件上下文菜单定义一组操作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符</li>
<li><b>targetID</b> - 视图或编辑器部件中上下文菜单的唯一标识符。ID在<code>getSite().registerContextMenu(*)</code>的调用中定义。如果在注册时未指定，则默认为视图或编辑器ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （ <a href="#e.selection">选择</a> *， <a href="#e.enablement">启用</a> ？， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">overrideActionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 用作菜单项文本的可翻译名称。名称可以包括mnenomic信息。</li>
<li><b>definitionId</b> - 指定此操作正在处理的命令。这用于决定在弹出菜单中显示哪个键绑定。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在上下文菜单中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作将添加到<samp>IWorkbenchActionConstants定义的标准添加组中<samp>。MB_ADDITIONS</samp> 。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。在某些平台上，如果操作显示为菜单项，则在菜单项突出显示时按相应的帮助键将显示帮助。并非所有平台都支持此行为。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的可选属性。如果已定义，则属性值将为以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- 作为级联样式菜单项。</td>
      </tr>
    </table></li>
<li><b>state</b> - 一个可选属性，指示初始状态（ <samp>true</samp>或<samp>false</samp> ），当<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的完全限定类的名称<samp>。IObjectActionDelegate</samp> （用于对象贡献）， <samp>org.eclipse.ui。IViewActionDelegate</samp> （用于查看器对视图部分的贡献）或<samp>org.eclipse.ui。IEditorActionDelegate</samp> （用于查看者对编辑器部分的贡献）。为了向后兼容， <samp>org.eclipse.ui。可以为对象贡献实现IActionDelegate</samp> 。</li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定了此属性并且满足条件，则启用该操作。如果不满足条件，则禁用该操作。如果未指定任何属性，则会为所选的任意数量的项启用该操作。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table>
<p>动作扩展的启用标准最初由<samp>enableFor</samp> ， <samp>selection</samp>和<samp>enablement</samp>定义。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。</p></li>
<li><b>overrideActionId</b> - 一个可选属性，指定此操作覆盖的操作的标识符。此标识符表示的操作不会提供给上下文菜单。操作标识符必须仅来自必备插件。此属性仅适用于对象贡献的操作元素。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.filter">过滤器</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST过滤器</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。仅当选择中的每个对象具有指定的属性状态时才匹配。选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现为class属性列出的接口之一的类。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是弹出菜单扩展点的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.popupMenus”</span> <span class="code SchemaTag">&gt; &lt;objectContribution id =</span> <span class="code SchemaCstring">“com.xyz。C1“</span> <span class="code SchemaTag">objectClass =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">nameFilter =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; XYZ Java Tools“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt; action id =</span> <span class="code SchemaCstring">“com.xyz.runXYZ”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ Tool”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / group1”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ.gif”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz .run_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。XYZToolActionDelegate“</span> <span class="code SchemaTag">enableFor =</span> <span class="code SchemaCstring">”1“</span> <span class="code SchemaTag">/&gt; &lt;/ objectContribution&gt; &lt;viewerContribution id =</span> <span class="code SchemaCstring">”com.xyz。C2“</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">”org.eclipse.ui.views。TaskList“</span> <span class="code SchemaTag">&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.showXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Show XYZ“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”toggle“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / showXYZ.gif“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com .xyz.show_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。XYZShowActionDelegate“</span> <span class="code SchemaTag">/&gt; &lt;/ viewerContribution&gt; &lt;/ extension&gt;</span></pre>在上面的示例中，指定的对象贡献操作仅允许单个选择（ <samp>enableFor</samp>属性）。此外，选择中的每个对象都必须实现指定的接口（ <samp>IFile</samp> ），并且必须是Java文件。此操作将添加到先前创建的子菜单中。此贡献将在具有所需选择的任何视图中有效。
<p>相反，上面的查看器贡献只会出现在“任务”视图上下文菜单中，并且不会受到视图中选择的影响。
</p><p>以下是过滤机制的示例。在这种情况下，该操作仅对已完成且具有高优先级的IMarkers显示。
</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.popupMenus”</span> <span class="code SchemaTag">&gt; &lt;objectContribution id =</span> <span class="code SchemaCstring">“com.xyz。C3“</span> <span class="code SchemaTag">objectClass =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IMarker“</span> <span class="code SchemaTag">&gt; &lt;filter name =</span> <span class="code SchemaCstring">”done“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;filter name =</span> <span class="code SchemaCstring">”priority“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”2“</span> <span class="code SchemaTag">/&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”高优先级已完成的动作工具“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runXYZ.gif“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。MarkerActionDelegate“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;/ objectContribution&gt; &lt;/ extension&gt;</span></pre>以下是使用visibility元素的另一个示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.popupMenus”</span> <span class="code SchemaTag">&gt; &lt;viewerContribution id =</span> <span class="code SchemaCstring">“com.xyz。C4“</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">”org.eclipse.ui.views。TaskList“</span> <span class="code SchemaTag">&gt; &lt;visibility&gt; &lt;和&gt; &lt;pluginState id =</span> <span class="code SchemaCstring">”com.xyz“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”activated“</span> <span class="code SchemaTag">/&gt; &lt;systemProperty name =</span> <span class="code SchemaCstring">”ADVANCED_MODE“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ visibility&gt; &lt;action id =</span> <span class="code SchemaCstring">“com.xyz.showXYZ”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Show XYZ”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“additions”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / showXYZ.gif”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz.show_action_context”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz .actions。XYZShowActionDelegate“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;/ viewerContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将在“任务”视图上下文菜单中显示为菜单项，但前提是“com.xyz”插件处于活动状态且指定的系统属性设置为true。
</p><p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>action属性<samp>类</samp>的值必须是实现<samp>org.eclipse.ui的Java类的完全限定类名<samp>。IObjectActionDelegate</samp>在对象贡献的情况下， <samp>org.eclipse.ui。IViewActionDelegate</samp>用于对属于视图或<samp>org.eclipse.ui的上下文菜单的贡献<samp>。IEditorActionDelegate</samp>用于对属于编辑器的上下文菜单的贡献。在所有情况下，实现类都会尽可能晚地加载，以避免在真正需要之前加载整个插件。
<p>注意：为了向后兼容， <samp>org.eclipse.ui。可以为对象贡献实现IActionDelegate</samp> 。
</p><p>只有当目标部件发布扩展菜单时，才能在部件中使用Conext菜单扩展。强烈建议这样做，因为它可以提高产品的可扩展性。为实现此目的，每个部分都应发布通过调用<samp>IWorkbenchPartSite.registerContextMenu</samp>定义的任何上下文菜单。完成此操作后，工作台将自动插入存在的任何操作扩展。
</p><p>必须为每个注册的菜单提供菜单ID。为了使各部分保持一致，所有部分实施者都应采用以下策略。
</p><p>
</p><ul>
<li>如果目标部件只有一个上下文菜单，则应使用id == part id进行注册。这可以通过调用<samp>registerContextMenu（MenuManager，ISelectionProvider）</samp>轻松完成。扩展程序可以使用part id本身作为action扩展的targetID。</li>
<li>如果目标部件具有多个上下文菜单，则应为每个上下文菜单定义唯一ID。使用部件ID为每个id添加前缀，并在目标部件的javadoc中发布这些id。通过调用<samp>registerContextMenu（String，MenuManager，ISelectionProvider）</samp>在运行时注册每个菜单。扩展程序将使用唯一菜单ID作为操作扩展的targetID。</li></ul>
<p>在工作台中注册的任何上下文菜单也应包含ID为<samp>IWorkbenchActionConstants的标准插入点<samp>。MB_ADDITIONS</samp> 。其他插件将使用此值作为插入的参考点。可以通过将GroupMarker添加到适当位置的菜单以便插入来定义插入点。
</p><p>工作台中的对象是上下文菜单中的选择，可以定义<samp>org.eclipse.ui。IActionFilter</samp> 。这是一种可以执行特定类型过滤的过滤策略。工作台将通过测试来检索选择的过滤器，以查看它是否实现了<samp>IActionFilter</samp> 。如果失败，工作台将通过<samp>IAdaptable</samp>机制请求过滤器。
</p><p>操作和菜单标签可能包含编码助记符的特殊字符，这些助记符是使用翻译文本中所选字符前面的＆符号（'＆'）指定的。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。
</p><p>如果单个扩展名为菜单提供了两个或多个操作，则操作将按照它们在plugin.xml文件中列出的顺序相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
</p><p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>工作台视图具有内置的上下文菜单，这些菜单已经加载了许多操作。插件可以为这些菜单做出贡献。如果查看者为这些贡献保留了插槽并将其公开，则可以将插槽名称用作路径。否则，将在弹出菜单的末尾添加操作和子菜单。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2007 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="2860.org_eclipse_ui_actionSets.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>动作集</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">动作集</h1>
<div style="border:1px solid #990000;padding:5px;text-align:center;color:red">不推荐使用此扩展点</div>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.actionSets<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>
<b>警告：此扩展点已弃用。</b><br>请勿使用此扩展点，将在本产品的未来版本中将其删除。相反，请使用扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a>
</p>
<p>此扩展点用于将菜单，菜单项和工具栏按钮添加到Workbench窗口中的公共区域。这些贡献统称为<i>操作集</i> ，并由用户自定义透视图显示在Workbench窗口中。
</p>
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p>
<p>存在实施限制，其当前影响动作集。定义要在操作集中引用的整个菜单结构非常重要。因此，例如，如果另一个动作集定义了一个名为“example”的菜单，则不可能依赖于“example”存在。有必要在每个希望使用它的动作集中重新定义“示例”菜单。
</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.actionSet">actionSet</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>actionSet</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.actionSet">actionSet</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST actionSet</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">可见（true | false）</p>
<p class="code SchemaDtdAttlist">说明CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素用于定义一组动作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此操作集的唯一标识符。</li>
<li><b>label</b> -  Workbench用于向用户表示此操作集的可翻译名称。</li>
<li><b>visible</b> - 一个可选属性，指示在透视图打开时动作集最初是否可见。仅当用户打开尚未自定义的透视图时，才会使用此选项。用户可以从“自定义透视对话框”中覆盖此选项。应谨慎使用此属性，以免过多操作使用户不堪重负。</li>
<li><b>description</b> -  Workbench用于向用户表示此操作集的可翻译描述。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>action</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">加速器CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">disabledIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">hoverIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">pulldown（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">重定位（true | false）</p>
<p class="code SchemaDtdAttlist">allowLabelUpdate（true | false）</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。</li>
<li><i style="color:red">不推荐使用的</i> <b>加速器</b> - 改为使用<samp>definitionId</samp>属性。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在菜单栏中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在菜单栏中。</li>
<li><b>toolbarPath</b> - 斜杠分隔的路径（'/'），用于指定工具栏中此操作的位置。第一个标记表示工具栏标识符（“Normal”是默认工具栏），而第二个标记是工具栏中将添加此操作的命名组。如果工具栏中不存在该组，则会创建该组。如果省略toolbarPath，则操作不会出现在工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件或<code>ISharedImages</code>常量的位置。该图标将显示在工具栏中，但不会显示在菜单中。启用的操作将由hoverIcon在菜单中显示。</li>
<li><b>disabledIcon</b> - 用于在禁用操作时直观地表示其上下文中的操作的图标的相对路径。如果省略，则普通图标将显示为灰色。该路径相对于贡献插件的plugin.xml文件的位置。禁用的图标将显示在工具栏中，但不会显示在菜单中。菜单中的禁用操作图标将由OS提供。</li>
<li><b>hoverIcon</b> - 用于在鼠标指针悬停在操作上时可视地表示其上下文中的操作的图标的相对路径。如果省略，将使用普通图标。该路径相对于贡献插件的plugin.xml文件的位置。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。如果操作显示为菜单项，则在菜单项突出显示时按F1将显示帮助。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的属性。如果省略，则默认为<samp>推送</samp> 。属性值将是以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- 作为级联样式菜单项或工具项旁边的下拉菜单。</td>
      </tr>
    </table></li>
<li><b>state</b> - 指示初始状态（ <samp>true</samp>或<samp>false</samp> ）的可选属性。仅在<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><i style="color:red">不推荐使用的</i> <b>下拉列表</b> - 将<samp>style</samp>属性与值<samp>pulldown一起使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的类的完全限定名称<samp>。IWorkbenchWindowActionDelegate</samp>或<samp>org.eclipse.ui。IWorkbenchWindowPulldownDelegate</samp> 。后者应该在<samp>style</samp>属性具有值<samp>pulldown的</samp>情况下实现。此类是负责执行操作的处理程序。如果<samp>retarget</samp>属性为true，则忽略此属性，不应提供该属性。</li>
<li><b>retarget</b> - 重定向此操作的可选属性。如果为true，则视图和编辑器部件可以使用标准机制为此操作提供处理程序，该机制使用此操作的标识符在其站点上设置全局操作处理程序。如果此属性为true，则不应提供<samp>class</samp>属性。<br><b>注意：</b>不支持<code>pulldown</code>和<code>retarget</code>的组合。命令可用于提供此类功能，请参阅<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>和具有<code>pulldown</code>样式的命令元素。</li>
<li><b>allowLabelUpdate</b> - 可选属性，指示重新定位操作是否允许处理程序覆盖其标签和工具提示。仅在<samp>retarget</samp>属性为true时适用。</li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定且未满足条件，则禁用该操作。如果省略，则动作启用状态不受影响。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>参数</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>class</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IWorkbenchWindowActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是动作集的示例（请注意子元素和使用的方式属性）：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.actionSets”</span> <span class="code SchemaTag">&gt; &lt;actionSet id =</span> <span class="code SchemaCstring">“com.xyz.actionSet”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“My Actions”</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Menu”</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">“additions”</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">“group1”</span> <span class="code SchemaTag">/&gt; &lt;separator name =</span> <span class="code SchemaCstring">“option1”</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">“com.xyz.runXYZ”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ Tool”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“ toggle“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu / group1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runXYZ.png“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz。动作。RunXYZ“</span> <span class="code SchemaTag">enableFor =</span> <span class="code SchemaCstring">”1“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runABC“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run ABC Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”push“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu / group1 “</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">”Normal / XYZ“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runABC.png“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行ABC工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_abc_action_context“</span> <span class="code SchemaTag">retarget =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">allowLabelUpdate =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runDEF“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run DEF Tool”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“radio”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / option1”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runDEF.png”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行DEF工具”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz .actions。RunDEF“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_def_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runGHI“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run GHI Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”radio“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com .xyz.xyzMenu / option1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runGHI.png“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行GHI工具“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunGHI“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_ghi_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runJKL“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run JKL Tool“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”radio“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”com .xyz.xyzMenu / option1“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runJKL.png“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行JKL工具“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunJKL“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_jkl_action_context“</span> <span class="code SchemaTag">&gt; &lt;/ action&gt; &lt;/ actionSet&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，名为“My Actions”的指定操作集最初在每个透视图中都不可见，因为未指定<samp>visible</samp>属性。
</p>
<p>XYZ操作将显示为复选框菜单项，最初未选中。仅当选择计数为1且选择包含Java文件资源时才会启用它。
</p>
<p>ABC操作将同时出现在菜单和工具栏上。仅当选择不包含任何Java文件资源时才会启用它。另请注意，这是一个标签重定目标操作，因此它不提供<samp>类</samp>属性。
</p>
<p>DEF，GHI和JKL操作显示为单选按钮菜单项。它们始终处于启用状态，与当前选择状态无关。
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须是实现<samp>org.eclipse.ui的类的完全限定名<samp>。IWorkbenchWindowActionDelegate</samp>或<samp>org.eclipse.ui。IWorkbenchWindowPulldownDelegate</samp> 。后者应该在<samp>style</samp>属性具有值<samp>pulldown的</samp>情况下实现。此类是负责执行操作的处理程序。如果<samp>retarget</samp>属性为true，则忽略此属性，不应提供该属性。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。
<p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p><p>请务必注意，工作台不会代表插件生成菜单。菜单路径必须引用已存在的菜单。
</p><p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>插件可以使用此扩展点添加新的顶级菜单。插件还可以定义命名组，允许其他插件将其操作贡献给它们。
<p>通过使用path属性的以下值创建顶级菜单：</p><ul>
<li>添加 - 表示<samp>窗口</samp>菜单左侧的一个组。
</li></ul>省略path属性将导致将新菜单添加到添加菜单栏组中。

<p>工作台窗口中的默认组在<samp>IWorkbenchActionConstants</samp>接口中定义。这些常量可以在代码中用于动态贡献。这些值也可以复制到XML文件中，以便与现有的工作台菜单和工具栏进行细粒度的集成。
</p>
<p>工作台窗口中的各种菜单和工具栏项都是通过算法定义的。在这些情况下，必须使用单独的机制来扩展窗口。例如，添加新工作台视图会导致“透视”菜单中出现一个新菜单项。导入，导出和新向导扩展也会自动添加到窗口中。
</p>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2011 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3296.i18n_changes.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>i18n_changes</title>
		<link type="text/css" rel="stylesheet" href="resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="TranslationKeysChanges">翻译密钥更改</h1>
		<p>本文档列出了每个Sirius版本中用于Sirius国际化的<code>TranslatableMessage</code>的变化。
		</p>
		<h2 id="sirius61">Sirius 6.1中的翻译键变化（来自Sirius 6.0）</h2>
		<h3 id="MessageKeysAdded">添加了消息密钥</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.common.ui。消息。MigrationUIUtil_askToSaveChanges</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ChangeEditModeAction_ChangeFailure</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ChangeEditModeAction_ChangePropertyValueRequest_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DDiagramEditorImpl_updateToolFailure</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DefaultModeAction_Label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DefaultModeAction_statusOn</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramAppearancePreferencePage_displayUserFixedColorsInPaletteLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DoubleClickEditPolicy_confirmDialogAsking</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DoubleClickEditPolicy_confirmDialogTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DoubleClickEditPolicy_filterConfirmDialogBody</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DoubleClickEditPolicy_layerConfirmDialogBody</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。EditModeAction_Label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。Group_No_Menu_ID</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。Group_Not_Displayed</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LayoutingModeSwitchingAction_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_Blank</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_MoreThanTwoLocations</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_NoId</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_OnlyOneLocationURIPerScheme</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_WrongFormat</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LocationURI_ParsePb_WrongScheme</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。UndoRedoCapableEMFCommandFactory_insertHorizontalBlankSpaceNotImplemented</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。ToolManagment_ToolChange_Command_Label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。UpdateToolRecordingCommand_cancelExceptionMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。ViewWithNullElementMigrationParticipant_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。ViewWithNullElementMigrationParticipant_singleMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。ViewWithNullElementMigrationParticipant_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。CustomLayoutConfigurationDescriptionPropertySection_noLayoutAlgorithmProviderDescription</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。CustomLayoutConfigurationDescriptionPropertySection_noLayoutAlgorithmProviderName</code>
			</li>
			<li>
				<code>org.eclipse.sirius.server.internal。消息。SiriusServerConfigurator_headerConfig</code>
			</li>
			<li>
				<code>org.eclipse.sirius.server.internal。消息。SiriusServerConfigurator_wrongPropertyTypeWarning</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusPreferencePage_askUserToSaveAfterMigration</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusPreferencePage_migrationGroup</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。CreateMissingRepresentationFileResolution_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。CreateMissingRepresentationFileResolution_description</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。AirDResourceImpl_nullUid</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。Constraint_validNullLocationURIForGroupInPopupMenuConstraint_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。TechnicalUidMigrationParticipant_message</code>
			</li>
		</ul>
		<h3 id="MessageKeysRemoved">消息密钥已删除</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LayoutingModeSwitchingAction_activate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LayoutingModeSwitchingAction_deactivate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_activate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_deactivate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。UndoRedoCapableEMFCommandFactory_insertHorizontalBlankSpaceNotImplemented</code>
			</li>
		</ul>
		<h2 id="sirius60">Sirius 6.0中的翻译键变化（来自Sirius 5.1）</h2>
		<h3 id="MessageKeysAdded2">添加了消息密钥</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramGeneralPreferencePage_sizeGroupLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。GenericConnectionCreationTool_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。InsertBlankSpace_cmdName</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LayoutAlgorithmProviderRegistry_badClassType</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。LayoutAlgorithmProviderRegistry_classInitialization</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SetShowingModeCommandAndUpdateActionImage_activateLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SetShowingModeCommandAndUpdateActionImage_deactivateLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_activate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_deactivate</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。ShowingModeSwitchingAction_statusOn</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_expressionMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_expressionTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_expressionTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_sameETypeMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_sameETypeTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StandardDiagramServices_sameETypeTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。NoteAttachmentWithoutSourceOrTargetMigrationParticipant_edgesRemoved</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。NoteAttachmentWithoutSourceOrTargetMigrationParticipant_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。UndoRedoCapableEMFCommandFactory_insertHorizontalBlankSpaceNotImplemented</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram。消息。UndoRedoCapableEMFCommandFactory_insertVerticalBlankSpaceNotImplemented</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.workflow.internal。消息。WorkflowMenuBuilder_NewWorkflow_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.workflow.internal。消息。WorkflowMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。AddOptionOverridePropertySection_dialogTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。AddOptionOverridePropertySection_overrideButtonLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。CustomSiriusEditor_failedNavigationExceptionMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。CustomSiriusEditor_failedNavigationMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。CustomSiriusEditor_failedNavigationTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。LayoutOptionValue_defaultLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_filteringLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_optionDefaultValueColumnLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_optionDescriptionLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_optionNameColumnLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_optionTypeColumnLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。OptionOverrideEditorDialog_tableLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。ServiceNavigator_serviceNavigationDialog_description</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。ServiceNavigator_serviceNavigationDialog_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor。消息。ServiceNavigator_targetInitialization_error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ext.ide.internal。消息。DescriptorRegistryEventListener_cannotInstantiateExtension</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ext.ide.internal。消息。DescriptorRegistryEventListener_extensionAlreadyContributed</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ext.ide.internal。消息。DescriptorRegistryEventListener_missingAttribute</code>
			</li>
			<li>
				<code>org.eclipse.sirius.server.internal。消息。SiriusServerManager_cannotStartServer</code>
			</li>
			<li>
				<code>org.eclipse.sirius.server.internal。消息。SiriusServerManager_cannotStopServer</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractExportRepresentationsAsImagesDialog_scalingLevelDiagramLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ExportAction_invalidLevel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ExportAsImage_dialogSizeGroupName</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ExportAsImage_maxLevelLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ExportAsImage_nominalLevelLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ExportAsImage_sizeTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。No_Browser_Error_Message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。OpenViewpointSelectionBrowser_Error_Message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SingleRepresentationTreeSelectionDialog_Title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.workflow.ui.page。消息。WorkflowPage_header_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.workflow.ui.page。消息。WorkflowPage_tab_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。InvalidModelingProjectMarkerUpdaterJob_updateMarkers</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_addAnotherRepresentationFile</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_addAnotherRepresentationFileSeveralProjects</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_mainRepresentationFileDeleted</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_mainRepresentationFilesOfSomeProjectsDeleted</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_satusUnsaveDataWillBeLostWithProjectNames</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelingModelProvider_satusUnsavedDataWillBeLost</code>
			</li>
		</ul>
		<h3 id="MessageKeysRemoved2">消息密钥已删除</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramGeneralPreferencePage_scaleDiagramOnExport</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractExportRepresentationsAsImagesDialog_autoScaleDiagram</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。InvalidModelingProjectMarkerUpdaterJob_updateMarkers</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_addAnotherRepresentationFile</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_addAnotherRepresentationFileSeveralProjects</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_mainRepresentationFileDeleted</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_mainRepresentationFilesOfSomeProjectsDeleted</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_satusUnsaveDataWillBeLostWithProjectNames</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ModelingModelProvider_satusUnsavedDataWillBeLost</code>
			</li>
		</ul>
		<h2 id="sirius51">Sirius 5.1中的翻译键更改（来自Sirius 5.0）</h2>
		<h3 id="MessageKeysAdded3">添加了消息密钥</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.diagram.sequence。消息。Range_wrongArgument</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。BundledImageShape_attributeAbsent</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramGeneralPreferencePage_scaleDiagramOnExport</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramGeneralPreferencePage_showSynchronizeStatusDecoratorLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。RepairGMFbendpointsMigrationParticipant_edgesModified</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。RepairGMFbendpointsMigrationParticipant_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SiriusStatusLineContributionItemProvider_diagramSynchronized</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SiriusStatusLineContributionItemProvider_diagramUnsynchronized</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SnapBackDistantLabelsMigrationParticipant_nodesMoved</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SnapBackDistantLabelsMigrationParticipant_oneLabelSnapBacked</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SnapBackDistantLabelsMigrationParticipant_severalLabelsSnapBacked</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SnapBackDistantLabelsMigrationParticipant_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_BottomSidePinnedLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_BottomSidePinnedTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_LeftSidePinnedLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_LeftSidePinnedTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_RightSidePinnedLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_RightSidePinnedTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_TopSidePinnedLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。StraightenToAction_TopSidePinnedTooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SynchronizeStatusFigure_diagSynchronized</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SynchronizeStatusFigure_diagUnsynchronized</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。DefaultSessionEditorPage_closeSession_action_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。DefaultSessionEditorPage_closeSession_action_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalSemanticModelsHandler_addModelButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalSemanticModelsHandler_newModelButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalSemanticModelsHandler_removeModelButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。PluginPageProviderRegistry_badClassType</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。PluginPageProviderRegistry_classInitialization</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。SessionEditor_PageActivation_Failure</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。SessionEditor_PageCommand_Integrity_Error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractExportRepresentationsAsImagesDialog_autoScaleDiagram</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractSWTCallback_DeleteRepresentationAction_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractSWTCallback_DeleteRepresentationAction_message_plural</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractSWTCallback_DeleteRepresentationAction_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractSWTCallback_DeleteRepresentationAction_title_plural</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_disableViewpointButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_enableViewpointButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_newRepresentationButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_removeRepresentationButton_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。RemoveSemanticResourceAction_Active_Representation_Message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。RemoveSemanticResourceAction_Controlled_Resources_Message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。RemoveSemanticResourceAction_Error_Removal_Title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。RemoveSemanticResourceAction_Not_External_Dependency_Message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。UpdateRepresentationsLocationHandler_errorMsg</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。UpdateRepresentationsLocationHandler_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。DRepresentationDescriptorToDRepresentationLinkManager_repLoading</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。ModelOperationToTask_cannotCreateTaskWarningMsg</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。SessionFactoryImpl_ResourceTypeErrorMsg</code>
			</li>
		</ul>
		<h3 id="MessageKeysRemoved3">消息密钥已删除</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。DeleteRepresentationAction_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。DeleteRepresentationAction_message_plural</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。DeleteRepresentationAction_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。DeleteRepresentationAction_title_plural</code>
			</li>
		</ul>
		<h2 id="sirius50">Sirius 5.0中的翻译键变化（来自Sirius 4.1）</h2>
		<h3 id="MessageKeysAdded4">添加了消息密钥</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.common.acceleo.aql.business。消息。AQLInterpreter_errorWithExpression</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramAppearancePreferencePage_authorizeOverlapGroupText</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramAppearancePreferencePage_decorationGroupText</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramPrintingPreferencePage_optionsGroupText</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。DiagramPrintingPreferencePage_printDecorations</code>
			</li>
			<li>
				<code>org.eclipse.sirius.diagram.ui.provider。消息。SiriusDiagramGraphicalViewer_tooltipDisplayDelay</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ecore.extender.business.internal。消息。PermissionService_permissionProviderInstantiationError</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.ext.widgets.reference.internal。消息。DefaultReferenceDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.ext.widgets.reference.internal。消息。DefaultReferenceDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。CategoryMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。ConditionalStyleMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。ContainerMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。CreateWidgetForAllFeaturesCommand_text</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。CreateWidgetFromDomainClassMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。CustomExpressionMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。CustomOperationMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultBooleanDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultBooleanDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultEnumerationDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultEnumerationDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMonolineTextDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMonolineTextDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMultilineTextDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMultilineTextDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMultivaluedEAttributeDescriptionFactory_name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DefaultMultivaluedEAttributeDescriptionFactory_widgetLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DialogButtonMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。DynamicMappingMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。GroupMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。LayoutMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。OverridesMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。PageMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。PropertiesMenuBuilder_ExtendPropertiesView_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。PropertiesMenuBuilder_ImportPropertiesView_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。PropertiesMenuBuilder_NewPropertiesView_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。PropertiesMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。StyleMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。ToolbarActionMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。ValidationMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。WidgetActionMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.editor.properties.internal。消息。WidgetMenuBuilder_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.core.internal。消息。AbstractDescriptionConverter_noConverterFound</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.core.internal。消息。IDescriptionConverter_InvalidDescriptionType</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.core.internal。消息。SiriusToolServices_MainTabLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.defaultrules.internal。消息。DefaultRulesProvider_DefaultPropertiesNotFound</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.provider。消息。分类名称</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.provider。消息。GridLayoutDescription__label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.provider。消息。GroupDescription__name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.provider。消息。PageDescription__name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.properties.provider。消息。ViewExtensionDescription__name</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Refresh_cancelled</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Refresh_error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Refresh_errorDuringRefresh</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Table_LineElement</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Table_TableElement</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.tools.internal。消息。TableToolVariables_LineElement</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.tools.internal。消息。TableToolVariables_TableElement</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefresh_error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefresh_refreshCancelled</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefresh_treeRefreshError</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。SiriusTreePreferencePage_alwaysUseStandardFont</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。SiriusTreePreferencePage_alwaysUseStandardFont_help</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。SiriusTreePreferencePage_globalGroupName</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。DefaultSessionEditorPage_collapseAllAction_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。DefaultSessionEditorPage_selectFilterAction_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalRepresentationHandler_disabledViewpoint_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalRepresentationHandler_missingDependencies_requirements</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。GraphicalRepresentationHandler_representationNumber_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_default_page_tab_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_header_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_inputNotHandled_error_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_models_button_newSemanticModel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_models_button_removeSemanticModel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_models_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_new_semantic_model_action_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_page_loading_error_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_representation_button_newRepresentation</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_representation_button_removeRepresentation</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_representation_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_session_loading_error_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_session_loading_task_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.editor。消息。UI_SessionEditor_viewpoints_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。DialogTask_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。WizardTask_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal.preferences。消息。SiriusPropertiesPreferencePage_maxLengthTabName_invalidInteger</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal.preferences。消息。SiriusPropertiesPreferencePage_maxLengthTabName_invalidValue</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。AbstractExportRepresentationsAsImagesDialog_decorationExport</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。CreateEMFModelWizard_errorInstantiateRootElement</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。CreateEMFModelWizard_modelNamePrefix</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。CreateEMFModelWizard_windowTitle</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。DynamicViewpointsSelectionComponent_missingDependencies_requirements</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_CreateRepresentationWizard_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_activateDeactivateViewpoint_incorrectSelection_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_activateDeactivateViewpoint_incorrectSelection_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_activateViewpoint</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_deactivateViewpoint</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_newRepresentation</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_button_removeRepresentation</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_checkBoxGroupByRepresentationDescription_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_checkBoxGroupByViewpoint_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_disabledViewpoint_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_missingDependencies_requirements</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。GraphicalRepresentationHandler_representationNumber_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。NameAndLocationWizardPage_description</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。NameAndLocationWizardPage_errorMessage</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。NameAndLocationWizardPage_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。OtherRepresentationAction_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。OtherRepresentationAction_noRepresentation_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。OtherRepresentationAction_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectEMFMetamodelWizardPage_description</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectEMFMetamodelWizardPage_documentationLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectEMFMetamodelWizardPage_metamodelLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectEMFMetamodelWizardPage_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectRootElementWizardPage_checkboxLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectRootElementWizardPage_description</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectRootElementWizardPage_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SelectRootElementWizardPage_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusPreferencePage_autoSessionEditorOpening</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusPreferencePage_sessionEditorGroup</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusRepresentationWithInactiveStatusLabelProvider_representationDescriptionItem_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusRepresentationWithInactiveStatusLabelProvider_viewpointItem_tooltip</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_confirmDependencyActivation_activateLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_confirmDependencyActivation_deactivateLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_confirmDependencyActivation_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_confirmDependencyActivation_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_missingDependency_message</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。ViewpointSelectionCallbackWithConfimationAndDependenciesHandling_missingDependency_title</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。AbstractResourceStrategyImpl_methodReleaseNotHandleMsg</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。LetTask_label</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint。消息。SessionInterpreter_evaluationError</code>
			</li>
		</ul>
		<h3 id="MessageKeysRemoved4">消息密钥已删除</h3>
		<ul>
			<li>
				<code>org.eclipse.sirius.editor.properties。消息。ImportingDefaultPropertiesViewDescriptionCommand_text</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Action_cancelled</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。Action_error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.table.metamodel.table.provider。消息。RefreshAction_errorDuringRefresh</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefreshAction_error</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefreshAction_refreshCancelled</code>
			</li>
			<li>
				<code>org.eclipse.sirius.tree.ui.provider。消息。EditorRefreshAction_treeRefreshError</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。AbstractDescriptionConverter_noConverterFound</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。IDescriptionConverter_InvalidDescriptionType</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。SiriusTabDescriptorProvider_DefaultPropertiesNotFound</code>
			</li>
			<li>
				<code>org.eclipse.sirius.ui.properties.internal。消息。SiriusToolServices_MainTabLabel</code>
			</li>
			<li>
				<code>org.eclipse.sirius.viewpoint.provider。消息。SiriusCommonLabelProvider_eClassDisabled</code>
			</li>
		</ul>
	</body>
</html><html id="1968.s1.3.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s1.2.html" rel="prev">&lt;&lt;§1.2角色类和对象</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s1.4.html" rel="next">§1.4姓名冲突&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a></div>
         <div class="sect depth2" id="s1.3">
            <h2 class="sect">§1.3角色类的获取和隐式继承<a class="img" href="s1.3.html" title="PermaLinkto§1.3角色类的获取和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <p>每个团队类都隐式实现预定义的接口<code>org.objectteams.ITeam</code> 。如果团队类没有显式的<code>extends</code>子句，则它会隐式扩展<code>org.objectteams.Team</code> ，从而为<code>org.objectteams.的方法提供实现<code>org.objectteams.ITeam</code> 。如果团队类扩展了非团队类，则编译器会隐式添加<code>org.objectteams.声明的所有方法的<code>org.objectteams.ITeam</code>到团队课。团队的<code>org.objectteams.类（包括<code>org.objectteams.Team</code> ）必须再次成为一个团队。接口实现不受此规则的影响。
               		
            </p>
            <p>通过接口<code>org.objectteams.提供的基础设施<code>org.objectteams.ITeam</code>在<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中介绍</a> 。
               		
            </p>
            <div class="sect depth3" id="s1.3.1">
               <h3 class="sect">§1.3.1角色类的获取和隐式继承<a class="img" href="s1.3.1.html" title="PermaLinkto§1.3.1角色类的获取和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1.3</a></span></h3>
               <p>团队从其超级团队中获得所有角色。这种关系类似于内部类的继承，但是接下来定义了一些决定性的差异。两种实现方案中提到<a href="s1.html#aux1.1" class="int">以下</a> ，这可以用来实现角色收购的特殊语义（虚拟类和副本继承）。
                  			
               </p>
               <h5 class="listing">隐式角色继承</h5>
               <div class="listing example frame" id="l1.3.1-1">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>班级</b> S {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>    <b>受保护的</b> <b>等级</b> R0 {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>受保护的</b> <b>类</b> R1 <em><b>扩展</b> R0</em> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>        <b>布尔</b>好</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>R2 m（）{...}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>        <b>void</b> n（ <em>R2</em> r）{...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>    <b>受保护的</b> <b>类</b> R2 {...}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">9</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="listing example frame" id="l1.3.1-2">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">10</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>类</b> T <em><b>延伸</b> S</em> {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">11</td>
                        <td><pre>@Override <b>受保护的</b> <em><b>类</b> R1</em> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">12</td>
                        <td><pre>        <strong>R2</strong> m（）{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">13</td>
                        <td><pre>if（ <em>ok</em> ）{ <b>return</b> <em>tsuper</em> .m（）; }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">14</td>
                        <td><pre>            <b>else</b> { <b>return</b> null; }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">15</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">16</td>
                        <td><pre>        <b>void</b> doIt（）{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">17</td>
                        <td><pre>N（米（））;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">18</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">19</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">20</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="subsect depth4" id="s1.3.1.a">
                  <h4 class="subsect">（a） <span class="title">角色类获取</span><a class="img" href="s1.3.1.a.html" title="PermaLink（a）角色类获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>扩展超级团队<code>S</code>的团队<code>T</code>具有对应于超级团队的每个角色<code>SR</code>的一个角色类<code>TR</code> 。新类型<code>TR</code> <strong>覆盖</strong> <code>R</code>用于<code>T</code>及其角色的上下文。获取角色类可以是直接的（见下文（b）），也可能涉及覆盖和隐式继承（下面的（c））。
                     				
                  </p>
                  <div class="codecomment">在上面的例子中（代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> ），团队<code>S</code>对类型<code>S.R0</code> ， <code>S.R1</code>和<code>S.R2</code>进行操作，而<code>T</code>对类型<code>T.R0</code> ， <code>T.R1</code>和<code>T.R2</code> 。<br><em>（类似于“ <code>S.R0</code> ”的引用在源代码中实际上是非法的（ <a href="s1.2.3.b.html" title="§1.2.3。（b）合格的角色类型" class="sect">§1.2.3。（b）</a> ）。这里它们仅用于说明目的）</em></div>
               </div>
               <div class="subsect depth4" id="s1.3.1.b">
                  <h4 class="subsect">（b） <span class="title">直接角色获取</span><a class="img" href="s1.3.1.b.html" title="PermaLink（b）直接角色获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在子团队<code>T</code> ，其超级团队<code>S</code>每个角色<code>SR</code>都可以通过简单名称<code>R</code>而无需进一步声明。
                     				
                  </p>
                  <div class="codecomment"><a href="#l1.3.1-1" class="listing">清单1.3.1-1中</a>的角色<code>R2</code>可用于子团队<code>T</code> （第12行），因为此角色类型是在封闭团队的超类中定义的。
                     				
                  </div>
               </div>
               <div class="subsect depth4" id="s1.3.1.c">
                  <h4 class="subsect">（c） <span class="title">覆盖和隐含继承</span><a class="img" href="s1.3.1.c.html" title="PermaLink to（c）覆盖和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果团队包含与其超级团队中定义的角色同名的角色类定义，则新角色类将覆盖超级团队中的相应角色，并<strong>隐式继承</strong>其所有功能。这种关系只能通过名称对应来建立。
                     				
                  </p>
                  <p>覆盖继承角色的角色应使用<code>@Override</code>注释进行标记。编译器应该可选地使用警告标记缺少的<code>@Override</code>注释。相反，如果角色标有<code>@Override</code>注释但实际上没有覆盖继承的角色，则会出错。
                     				
                  </p>
                  <p>使用接口覆盖角色类是错误的，反之亦然。最后一个角色不能被覆盖。<br>与常规继承不同， <strong>构造函数</strong>也是沿着隐式继承继承的，并且可以像普通方法一样被覆盖。
                     				
                  </p>
                  <div class="codecomment">在<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> <code>R1</code>在<code>T</code>隐含继承的所有功能<code>R1</code>在<code>S</code> 。这是因为它的封闭团队<code>T</code>扩展了团队<code>S</code> （第10行），角色定义使用相同的名称<code>R1</code> （第11行）。因此，在<code>T.R1</code> （第13行）的方法<code>m()</code>中可以使用属性<code><strong>ok</strong></code> 。<code>T.R1</code>还覆盖<code>S.R1</code>其由标记<code>@Override</code>在第11行注释。
                     				
                  </div>
               </div>
               <div class="subsect depth4" id="s1.3.1.d">
                  <h4 class="subsect">（d） <span class="title">缺乏分类</span><a class="img" href="s1.3.1.d.html" title="永久链接到（d）缺少子类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>从超级团队直接获取角色和隐式继承不会建立<strong>子类型</strong>关系。给定团队的角色永远不会与任何<em>其他</em>团队的任何角色保持一致（即可替代）。
                     	    <code>SR</code>和<code>TR</code>总是不可通约的。<br><span class="underline">请注意，</span>此规则是<a href="s1.2.2.e.html" title="§1.2.2。（e）一致性" class="sect">§1.2.2。（e）</a>的直接结果。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.1.e">
                  <h4 class="subsect">（e） <span class="title">类型的动态绑定</span><a class="img" href="s1.3.1.e.html" title="PermaLink到（e）类型的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>通过新角色类覆盖获取的角色具有以下含义：如果表示或声明（代表团队<code>T</code>的实例或其包含的角色之一进行评估）引用角色<code>R</code> ，则<code>R</code>将始终解析为<code>TR</code>即使<code>R</code>是在<code>T</code>的超级团队中引入的，即使特定的代码行是从超级团队或其中一个角色继承而来的。只有封闭的team-instance的动态类型用于确定正确的角色类（请参阅下面的示例）。
                     				
                  </p>
                  <p>动态绑定角色类型的一个特例涉及所谓的类文字（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）。角色类文字包含在<a href="s6.1.c.html" title="§6.1。（c）角色的类文字" class="sect">第6.1节中。（c）</a> 。
                     				
                  </p>
                  <p>仅在涉及隐式继承的情况下才严格要求上述内容。然而，它可以帮助直觉，也可以考虑（b）中直接获得的角色<code>TR</code>来覆盖给定的角色<code>SR</code> 。</p>
                  <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1的</a>第17行中，使用<code>m</code>的调用结果调用隐式继承的方法<code>n</code> 。虽然<code>n</code>在定义<code>S</code> （因此与参数类型<code>S.R2, see line 6</code> ）的背景下<code>T</code>它期望的参数<code>T.R2</code> 。这是通过在<code>T</code>的上下文中调用<code>m</code>来正确提供的。</div>
               </div>
               <div class="subsect depth4" id="s1.3.1.f">
                  <h4 class="subsect">（f） <span class="title">tsuper</span><a class="img" href="s1.3.1.f.html" title="永久链接到（f）tsuper"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <div class="syntaxlink"><a href="sA.html#sA.5.4" title="§A.5.4TSuperCall" class="syntax">→语法§A.5.4</a></div>
                  <p>隐式继承的超级调用使用new关键字<strong>tsuper</strong> 。虽然<code>super</code>仍然可以在常规继承中使用，但是调用<code>tsuper.m()</code>选择从超级团队获取的相应角色的<code>m</code>版本。
                     				
                  </p>
                  <p>有关角色构造函数的上下文中的<code>tsuper</code> ，请参见第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2</a> <code>tsuper</code> 。
                     				
                  </p>
                  <p><code>tsuper</code>只能用于调用封闭方法或构造函数的相应版本，即表达式<code>tsuper.m()</code>只能在方法<code>m</code> ，两个方法具有相同的签名（参见<a href="s2.3.2.b.html" title="§2.3.2。（b）在宣布解除的范围内超级" class="sect">§2.3.2。（b）</a>对于异常，两种方法的签名略有不同）。
                     				
                  </p>
                  <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中，团队<code>T</code>的角色<code>R1</code>覆盖了<code>S</code>隐式继承的方法<code>m()</code> 。 <code><strong>tsuper</strong> .m()</code>从<code>S.R1</code> （第13行<code><strong>tsuper</strong> .m()</code>调用重写的方法<code>m()</code> ）。
                     				
                  </div>
               </div>
               <div class="subsect depth4" id="s1.3.1.g">
                  <h4 class="subsect">（g） <span class="title">隐含继承超类型</span><a class="img" href="s1.3.1.g.html" title="PermaLink to（g）隐式继承超类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色类具有显式超类（使用<code>extends</code> ），则此关系将沿隐式继承继承。
                     				
                  </p>
                  <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中， <code>T</code>的角色<code>R1</code>将<code>T.R0</code>作为其隐式继承的超类，因为超级团队中的相应角色<code><strong>extends R0</strong></code> （第3行）。
                     				
                  </div>
                  <p>覆盖隐式继承的超类由下面的<a href="#s1.3.2.b" title="§1.3.2。（b）继承和覆盖extends子句" class="sect">§1.3.2。（b）管理</a> 。<br>已实现的接口列表沿隐式继承合并。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.1.h">
                  <h4 class="subsect">（h） <span class="title">保持可见度</span><a class="img" href="s1.3.1.h.html" title="永久链接到（h）保持可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>角色类必须至少提供与隐式超级角色一样多的访问权限，否则会发生编译时错误（这与<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#227965" class="ext">JLS§8.4.6.3类似</a> ）。由隐式继承覆盖的方法的访问权限遵循与正常覆盖相同的规则。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.1.i">
                  <h4 class="subsect">（i） <span class="title">构造函数的动态绑定</span><a class="img" href="s1.3.1.i.html" title="PermaLink（i）构造函数的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>使用<code>new</code>创建角色实例时，不仅动态绑定要实例化的类型（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ），但是调用的构造函数也是根据具体类型动态绑定的。<br>在角色构造函数中，所有<code>this(..)</code>和<code>super(..)</code>调用都是静态绑定到显式继承，并且动态地关于隐式继承。这意味着目标角色名称是静态确定的，但使用该名称时，将使用动态绑定确定合适的角色类型。
                     			<br>另见<a href="s2.5.a.html" title="§2.5。（a）使用抽象类进行创建" class="sect">§2.5。（a）</a>关于使用抽象角色类的构造函数。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.1.j">
                  <h4 class="subsect">（j） <span class="title">覆盖和兼容性</span><a class="img" href="s1.3.1.j.html" title="PermaLink to（j）覆盖和兼容性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#228745" class="ext">JLS§8.4.6</a>的规则也适用于通过隐式继承继承的方法<em>和构造函数</em> 。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.1.k">
                  <h4 class="subsect">（k） <span class="title">协变回报类型</span><a class="img" href="s1.3.1.k.html" title="PermaLink到（k）协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>给定一组<code>T1</code>与两个角色<code>R1</code>和<code>R2</code> ，其中<code>R2</code>明确地从继承<code>R1</code> ，两个角色定义一个方法<code>m</code>返回某种类型的<code>A</code> 。还给出了一个<code>T1</code> ， <code>T2</code>的子团队，其中<code>T2.R1</code>使用协变返回类型<code>B</code> （ <code>A</code>子类型）覆盖<code>m</code> ：</p>
                  <div class="listing plain"><pre>    <b>公共</b> <b>团队</b> <b>类</b> T1 { <b>protected</b> <b>abstract</b> <b>class</b> R1 { <b>abstract</b> A m（）; } <b>protected</b> <b>class</b> R2 <b>扩展</b> R1 {A m（）{ <b>return</b> <b>new</b> A（）; <b>public</b> <b>team</b> <b>class</b> T2 <b>扩展</b> T1 { <b>protected</b> <b>class</b> R1 {@Override B m（）{ <b>return</b> <b>new</b> B（）; } <span class="error">//此声明呈现<b>类</b> T2。R2非法</span> }}</pre></div>
                  <p>在这种情况下角色<code>T2.除非还使用至少为<code>B</code>的返回类型覆盖<code>m</code> ，否则R2</code>将是非法的。注意，实际错误发生在隐式继承的方法<code>T2.R2.m</code>在源代码中不可见，甚至是<code>T2.不需要在源代码中明确提及R2</code> 。编译器应将此标记为团队级别的不兼容性，因为团队必须以一致的方式专门化继承的角色。
                     				
                  </p>
               </div>
               <h5 class="listing">示例代码（团队和角色）：</h5>
               <div class="listing example frame" id="l1.3.1-3">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>受保护的</b> <b>类</b> MyRole {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>字符串名称;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>    <b>public</b> MyRole（String n）{name = n; }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>    <b>public</b> <b>void</b> print（）{System.out.println（“id =”+ name）; }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">7</td>
                        <td><pre>  <b>protected</b> MyRole getRole（）{ <b>return</b> <b>new</b> MyRole（“Joe”）; }</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">8</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="listing example frame" id="l1.3.1-4">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">10</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>类</b> MySubTeam <b>扩展了</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">11</td>
                        <td><pre>  <b>受保护的</b> <b>类</b> MyRole {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">12</td>
                        <td><pre>    <b>INT</b>年龄;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">13</td>
                        <td><pre>    <b>public</b> <b>void</b> setAge（ <b>int</b> a）{age = a; }</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">14</td>
                        <td><pre>    <b>public</b> <b>void</b> print（）{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">15</td>
                        <td><pre>tsuper.print（）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">16</td>
                        <td><pre>的System.out.println（ “年龄=” +年龄）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">17</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">18</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">19</td>
                        <td><pre>  <b>public</b> <b>void</b> doit（）{</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">20</td>
                        <td><pre>MyRole r = getRole（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">21</td>
                        <td><pre>r.setAge（27）;</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">22</td>
                        <td><pre>r.print（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">23</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">24</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">25</td>
                        <td><pre>...</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">26</td>
                        <td><pre>MySubTeam myTeam = <b>new</b> MySubTeam（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">27</td>
                        <td><pre>myTeam.doit（）;</pre></td>
                     </tr>
                  </table>
               </div>
               <h5 class="listing">程序输出</h5>
               <div class="listing example frame"><pre>id =乔年龄= 27岁</pre></div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <ul>
                     <li>根据<a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ， <code>MyTeamA</code>实施了<code>ITeam</code> （第1行）。
                     </li>
                     <li>为<code>MySubTeam.创建了隐式角色继承<code>MySubTeam.MyRole</code> （ <a href="#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ;第11行）。<br>如果我们使用虚构关键字<code>overrides</code>可视化此特殊继承，编译器将看到一个声明：<div class="listing plain"><pre><b>受保护的</b> <b>类</b> MyRole <em>重写MyTeamA.MyRole</em> {...}</pre></div>
                     </li>
                     <li>在<code>myTeam</code>上调用<code>getRole()</code> （第<code>myTeam</code>行）会创建一个<code>MySubTeam.实例<code>MySubTeam.MyRole</code>因为获取的角色<code>MyTeamA.MyRole</code>被<code>MySubTeam.覆盖<code>MySubTeam.MyRole</code>遵循隐式继承的规则（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ）。
                        					 
                     </li>
                     <li>覆盖角色方法和访问继承的功能与往常一样。
                        					
                     </li>
                     <li>作为<a href="#s1.3.1.f" title="§1.3.1.(f) tsuper" class="sect">§1.3.1</a>的示例<a href="#s1.3.1.f" title="§1.3.1。（f）tsuper" class="sect">。（f）</a>参见调用<code>tsuper.print()</code> （第15行），它选择<code>MyTeamA.MyRole.print</code>的实现。
                        						
                     </li>
                  </ul>
               </div>
            </div>
            <div class="sect depth3" id="s1.3.2">
               <h3 class="sect">§1.3.2常规角色继承<a class="img" href="s1.3.2.html" title="PermaLinkto§1.3.2常规角色继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§1.3</a></span></h3>
               <p>除了隐式继承之外，角色还可以使用标准Java关键字<code>extends</code>继承。这些限制适用：</p>
               <div class="subsect depth4" id="s1.3.2.a">
                  <h4 class="subsect">（a） <span class="title">超级限制</span><a class="img" href="s1.3.2.a.html" title="PermaLink（a）超级限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果一个角色的超类再次成为一个角色，它必须是一个封闭团队的直接角色。这个规则只是通过在<code>extends</code>子句中禁止类型锚来强制执行（参见<a href="s1.2.2.g.html" title="§1.2.2。（g）法律背景" class="sect">§1.2.2。（g）</a> ）。作为一种效果，超级类可能永远不会比子类更深入地嵌套。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.2.b">
                  <h4 class="subsect">（b） <span class="title">继承和覆盖扩展条款</span><a class="img" href="s1.3.2.b.html" title="PermaLink to（b）继承和覆盖extends子句"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果角色通过隐式继承覆盖另一个角色，则只有当新的超类是重写的extends子句中的类的子类时，它才可以更改继承的<code>extends</code>子句（参见<a href="#s1.3.1.g" title="§1.3.1。（g）隐式继承超类型" class="sect">上面的§1.3.1。（g）</a> ）。即，隐式子角色可以<em>专门</em>化其隐式超级角色的extends子句。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.2.c">
                  <h4 class="subsect">（c） <span class="title">建筑师和被覆盖的'延伸'</span><a class="img" href="s1.3.2.c.html" title="PermaLink to（c）构造函数和覆盖&#39;extends&#39;"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>覆盖其隐式超级角色的extends子句的角色类的每个构造函数都必须调用此新引入的显式超类的构造函数。因此，它可能不使用<code>tsuper</code>构造函数（参见<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">§2.4.2</a> ）。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.2.d">
                  <h4 class="subsect">（d） <span class="title">添加已实现的接口</span><a class="img" href="s1.3.2.d.html" title="PermaLink（d）添加已实现的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p><code>implements</code>声明是附加的，即隐式子角色可以添加更多接口，但也必须实现其隐式超级角色的所有接口。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s1.3.2.e">
                  <h4 class="subsect">（e） <span class="title">继承方法的可见性</span><a class="img" href="s1.3.2.e.html" title="PermaLink（e）继承方法的可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>当角色继承了一个普通类（如父类）非公开方式，这些方式被认为是私人的角色，也就是说，它们只能在非限定方法调用访问<code>m()</code>使用隐式接收器<code>this</code> 。
                     				
                  </p>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s1.2.html" rel="prev">&lt;&lt;§1.2角色类和对象</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s1.4.html" rel="next">§1.4姓名冲突&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html>