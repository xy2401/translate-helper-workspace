<html id="2273.CustomizingtheEnvironment.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>自定义环境</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="ProgrammersGuide.html" title="Classic Ecore/UML Programmers Guide"></link>
<link rel="prev" href="AbstractSyntax.html" title="OCL Abstract Syntax Model"></link>
<link rel="next" href="Persistence.html" title="OCL Persistence"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">自定义环境</h1>
<div class="section" title="自定义环境">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="CustomizingtheEnvironment"></a>自定义环境</h2>
</div>
</div>
</div>
<p>集成OCL的应用程序可能会发现为其用户提供增强的OCL环境是有利的，以简化他们制定OCL约束和查询的任务。例如，应用程序可能会在与其域相关的OCL标准数据类型上定义其他“原始”操作，或者将有用对象注入用户上下文的“全局”变量。还可以自定义查找和导航“隐藏”对立的方式，特别是允许跨没有相反定义的Ecore引用的反向导航。</p>
<div class="section" title="定义全局变量">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DefiningGlobalVariables"></a>定义全局变量</h3>
</div>
</div>
</div>
<p>考虑允许最终用户使用OCL指定条件来过滤用户界面中显示的对象的应用程序。给定UI所呈现的对象的足够丰富的模型（以Ecore或UML表示），可以完全根据该模型表达许多条件。但是，某些查询可能取决于应用程序的状态，而不是数据：哪个透视图处于活动状态，是否显示某个视图，甚至是一天中的时间。这些不是用户希望过滤的对象的特征。</p>
<p>这样的应用程序可能会选择定义过滤条件可以查询的特定于应用程序的变量： <code class="code">app$perspective</code> ， <code class="code">app$views</code> ， <code class="code">app$time</code> 。或者，也许是单个变量<code class="code">app$</code> ，它具有条件可以访问的属性：</p>
<div class="literallayout">
<p>
<code class="code">- 在Web Development透视图中过滤掉OCL文件<br>self.extension ='ocl'和app $ .perspective ='Web Development'<br>

</code>
</p>
</div>
<p></p>
<p>为此，我们定义了应用程序上下文的一个小Ecore模型，例如：</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/5160-appcontext.png"></div>
<p>
				
</p>
<p>然后，在解析用户的过滤条件的代码中：</p>
<div class="literallayout">
<p>
<code class="code">OCL &lt;？，EClassifier，？，？，？，？，？，？，？，Constraint，EClass，EObject&gt; ocl;<br>ocl = OCL.newInstance（EcoreEnvironmentFactory。实例）;<br>

<br>OCLHelper &lt;EClassifier，？，？，Constraint&gt; helper = ocl.createOCLHelper（）;<br>helper.setContext（MyPackage的。文字。文件）;<br>

<br>//创建一个声明我们的全局应用程序上下文对象的变量<br>变量&lt;EClassifier，EParameter&gt; appContextVar =<br>ExpressionsFactory.eINSTANCE.createVariable（）;<br>appContextVar.setName（ “应用$”）;<br>appContextVar.setType（AppPackage。文字。APP_CONTEXT）;<br>

<br>//将其添加到全局OCL环境中<br>ocl.getEnvironment（）。addElement（appContextVar.getName（），appContextVar，true）;<br>

<br>List &lt;Constraint&gt; conditions = new ArrayList &lt;Constraint&gt;（）;<br>

<br>//解析用户的过滤条件<br>for（String cond：getFilterConditions（））{<br>conditions.add（helper.createInvariant（COND））;<br>}<br>

<br>//应用过滤器<br>applyFilters（条件）;<br>

</code>
</p>
</div>
<p></p>
<p>我们假设的<code class="code">applyFilters()</code>方法的主体必须将此上下文变量绑定到一个值。在这种情况下，可以在应用过滤器时计算值：</p>
<div class="literallayout">
<p>
<code class="code">AppContext appContext = AppFactory.eINSTANCE.createAppContext（）;<br>

<br>//假设的工作台实用程序<br>appContext.setPerspective（WorkbenchUtil.getCurrentPerspective（））;<br>。appContext.getViews（）中的addAll（WorkbenchUtil.getOpenViewIDs（））;<br>appContext.setTime（new Date（））;<br>

<br>List &lt;Query &lt;EClassifier，EClass，EObject &gt;&gt; queries =<br>new ArrayListlt; Query &lt;EClassifier，EClass，EObject &gt;&gt;（constraints.size（））;<br>

<br>for（Constraint next：constraints）{<br>查询&lt;EClassifier，EClass，EObject&gt; query = ocl.createQuery（next）;<br>

<br>//绑定变量值<br>query.getEvaluationEnvironment（）。add（“app $”，appContext（））;<br>
    <br>queries.add（查询）;<br>}<br>

<br>过滤（查询）; //将这些过滤器应用于当前对象<br>//通过评估它们上的OCLS。<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="用Java定义帮助程序操作">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DefiningHelperOperationsinJava"></a>用Java定义帮助程序操作</h3>
</div>
</div>
</div>
<p>OCL允许使用<code class="code">def:</code>表达式定义其他操作和属性。这对于约束的制定非常方便，但是如果我们需要的操作类似于正则表达式模式匹配呢？
				</p>
<div class="literallayout">
<p>
<code class="code">班级人员<br>inv valid_ssn：self.ssn.regexMatch（'\ d {3}  -  \ d {3}  -  \ d {3}'）&lt;&gt; null<br>

</code>
</p>
</div>
<p></p>
<p>我们可能尝试使用OCL定义它，作为OCL标准库的<code class="code">String</code>基元类型的附加操作：</p>
<div class="literallayout">
<p>
<code class="code">class String<br>def：regexMatch（pattern：String）：String =<br>-  ???<br>

</code>
</p>
</div>
<p></p>
<p>OCL标准库中可用的操作仅仅不足以表示此操作的值，该操作应返回匹配正则表达式模式的子字符串，如果模式不匹配，则返回<code class="code">null</code> 。我们需要在Java中实现这个操作。我们可以通过创建一个知道如何查找此操作的自定义<code class="code">Environment</code>以及一个知道如何实现它的<code class="code">EvaluationEnvironment</code>来实现这一点。
				</p>
<p>首先，让我们从定义<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/EcoreEnvironment.html" target="_new"><code class="code">EcoreEnvironment</code></a> 。用于初始化<code class="code">OCL</code>实例的根环境的构造函数将我们的<code class="code">regexMatch</code>附加操作添加到<code class="code">String</code>基元类型。用于创建嵌套环境的构造函数从其父级复制操作。
				</p>
<div class="literallayout">
<p>
<code class="code">class MyEnvironment扩展EcoreEnvironment {<br>EOperation regexMatch;<br>
    <br>//此构造函数用于初始化根环境<br>MyEnvironment（EPackage。注册表注册表）{<br>超（注册表）;<br>
        <br>defineCustomOperations（）;<br>}<br>
    <br>//此构造函数用于初始化子环境<br>MyEnvironment（MyEnvironment parent）{<br>超级（父）;<br>
        <br>//获取父级的自定义操作<br>regexMatch = parent.regexMatch;<br>}<br>
	
<br>//重写此方法以提供继承的受保护方法的可见性<br>@覆盖<br>protected void setFactory（<br>EnvironmentFactory &lt;EPackage，EClassifier，EOperation，<br>EStructuralFeature，EEnumLiteral，EParameter，EObject，<br>CallOperationAction，SendSignalAction，Constraint，EClass，EObject&gt;<br>工厂）{<br>super.setFactory（工厂）;<br>}<br>
    <br>//使用AbstractEnvironment的机制进行定义<br>//“附加操作”将我们的自定义操作添加到<br>// OCL的String基元类型<br>private void defineCustomOperations（）{<br>//模式匹配操作<br>regexMatch = EcoreFactory.eINSTANCE.createEOperation（）;<br>regexMatch.setName（ “REGEXMATCH”）;<br>regexMatch.setEType（getOCLStandardLibrary（）的getString（））;<br>EParameter parm = EcoreFactory.eINSTANCE.createEParameter（）;<br>parm.setName（ “图案”）;<br>parm.setEType（getOCLStandardLibrary（）的getString（））;<br>。regexMatch.getEParameters（）添加（PARM）;<br>
        <br>//注释它以便我们识别它<br>//在评估环境中<br>EAnnotation注释= EcoreFactory.eINSTANCE.createEAnnotation（）;<br>annotation.setSource（ “MyEnvironment”）;<br>。regexMatch.getEAnnotations（）添加（注释）;<br>
        <br>//将其定义为OCL String上的附加操作<br>addOperation（getOCLStandardLibrary（）。getString（），regexMatch）;<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
<p>接下来，我们将定义<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/EcoreEvaluationEnvironment.html" target="_new"><code class="code">EcoreEvaluationEnvironment</code></a>的相应<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/EcoreEvaluationEnvironment.html" target="_new"><code class="code">EcoreEvaluationEnvironment</code></a> ，它将知道如何评估对此自定义操作的调用：</p>
<div class="literallayout">
<p>
<code class="code">class MyEvaluationEnvironment扩展EcoreEvaluationEnvironment {<br>MyEvaluationEnvironment（）{<br>超（）;<br>}<br>

<br>MyEvaluationEnvironment（<br>EvaluationEnvironment &lt;EClassifier，EOperation，EStructuralFeature，<br>EClass，EObject&gt; parent）{<br>超级（父）;<br>}<br>
    <br>public Object callOperation（EOperation操作，int操作码，<br>对象源，Object [] args）{<br>if（operation.getEAnnotation（“MyEnvironment”）== null）{<br>//不是我们的自定义正则表达式操作<br>return super.callOperation（operation，opcode，source，args）;<br>}<br>
        <br>if（“regexMatch”.equals（operation.getName（）））{<br>模式模式= Pattern.compile（（String）args [0]）;<br>Matcher matcher = pattern.matcher（（String）source）;<br>
            <br>return matcher.matches（）？matcher.group（）：null;<br>}<br>
        <br>抛出新的UnsupportedOperationException（）; //未知的操作<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
<p>最后，我们定义了<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/EcoreEnvironmentFactory.html" target="_new"><code class="code">EcoreEnvironmentFactory</code></a> ，它创建了我们的自定义环境：</p>
<div class="literallayout">
<p>
<code class="code">class MyEnvironmentFactory扩展EcoreEnvironmentFactory {<br>公共环境&lt;EPackage，EClassifier，EOperation，EStructuralFeature，<br>EEnumLiteral，EParameter，EObject，CallOperationAction，<br>SendSignalAction，Constraint，EClass，EObject&gt; createEnvironment（）{<br>MyEnvironment结果=新的MyEnvironment（getEPackageRegistry（））;<br>result.setFactory（本）;<br>返回结果;<br>}<br>
    <br>公共环境&lt;EPackage，EClassifier，EOperation，EStructuralFeature，<br>EEnumLiteral，EParameter，EObject，CallOperationAction，<br>SendSignalAction，Constraint，EClass，EObject&gt;<br>createEnvironment（环境&lt;EPackage，EClassifier，EOperation，<br>EStructuralFeature，EEnumLiteral，EParameter，EObject，<br>CallOperationAction，SendSignalAction，Constraint，EClass，<br>EObject&gt; parent）{<br>如果（！（父实例MyEnvironment））{<br>抛出新的IllegalArgumentException（<br>“父环境必须是我的环境：”+父母）;<br>}<br>
        <br>MyEnvironment结果=新的MyEnvironment（（MyEnvironment）parent）;<br>result.setFactory（本）;<br>返回结果;<br>}<br>

<br>公共评估环境&lt;EClassifier，EOperation，EStructuralFeature，<br>EClass，EObject&gt; createEvaluationEnvironment（）{<br>返回新的MyEvaluationEnvironment（）;<br>}<br>

<br>公共评估环境&lt;EClassifier，EOperation，EStructuralFeature，<br>EClass，EObject&gt; createEvaluationEnvironment（<br>EvaluationEnvironment &lt;EClassifier，EOperation，EStructuralFeature，<br>EClass，EObject&gt; parent）{<br>返回新的MyEvaluationEnvironment（parent）;<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
<p>现在，我们可以使用我们的环境来解析我们正在寻找的表达式：</p>
<div class="literallayout">
<p>
<code class="code">OCL &lt;？，EClassifier，？，？，？，？，？，？，？，Constraint，EClass，EObject&gt; ocl;<br>ocl = OCL.newInstance（new MyEnvironmentFactory（））;<br>

<br>OCLHelper &lt;EClassifier，？，？，Constraint&gt; helper = ocl.createOCLHelper（）;<br>helper.setContext（MyPackage的。文字。人）;<br>

<br>//将'\'加倍以在Java字符串文字中对其进行转义<br>约束validSSN = helper.createInvariant（<br>“self.ssn.regexMatch（'\\ d {3}  -  \\ d {3}  -  \\ d {3}'）&lt;&gt; null”）;<br>
        <br>Person person = getPersonToValidate（）;<br>

<br>System.out.printf（“％s有效SSN：％b％n”，person，ocl.check（person，validSSN））;<br>

</code>
</p>
</div>
<p></p>
</div>
<div class="section" title="选择包查找策略">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="SelectingaPackageLookupStrategy"></a>选择包查找策略</h3>
</div>
</div>
</div>
<p>当在OCL表达式中提供包名称时，例如，当在<code class="code">oclIsKindOf</code>调用中表示类型时，使用特定策略查找这些名称。默认情况下，查找从解析上下文开始，遍历包层次结构。如果无法以这种方式解析包名称，则对于Ecore绑定，将在<code class="code">EPackage.执行查找<code class="code">EPackage.Registry</code> 。默认情况下，将提供的程序包名称与作为注册表中的值包含的程序包的名称进行比较。
				</p>
<p>在极少数情况下，可能存在含糊不清的包名称。例如，如果要使用OCL AST元模型中的分类器作为其上下文来解析OCL表达式，则上下文包是<code class="code">ocl::ecore</code> 。如果这样的表达式试图从包含名称为<code class="code">ecore</code>的EMF Ecore包中引用类型，则相对于上下文包的查找会隐藏EMF Ecore包。而不是EMF Ecore包，将找到<code class="code">ocl::ecore</code>包。
				</p>
<p>这种歧义可以通过使用专用的<code class="code">EPackage.来解决<code class="code">EPackage.Registry</code>使用特殊的“URI”注册其他模糊的包，该URI表示包的简单别名。为了强制OCL解析器通过这些别名来查找包，需要在OCL环境中设置一个选项，如下所示：</p>
<div class="literallayout">
<p>
<code class="code">注册表r =新的EPackageRegistryImpl（）;<br>r.putAll（EPackage。注册。实例）;<br>r.put（“EMFEcore”，EcorePackage.eINSTANCE）;<br>r.put（“OCLEcore”，org.eclipse.ocl.ecore。EcorePackage.eINSTANCE）;<br>OCL ocl = OCL.newInstance（new EcoreEnvironmentFactory（r））;<br>（（EcoreEnvironment）ocl.getEnvironment（））。setOption（<br>ParsingOptions。PACKAGE_LOOKUP_STRATEGY，<br>ParsingOptions。PACKAGE_LOOKUP_STRATEGIES。<br>LOOKUP_PACKAGE_BY_ALIAS_THEN_NAME）;<br>Helper helper = ocl.createOCLHelper（）;<br>helper.setContext（<br>org.eclipse.ocl.ecore。EcorePackage.eINSTANCE.getOCLExpression（））;<br>org.eclipse.ocl.ecore。OCLExpression expr = helper.createQuery（<br>“self.oclIsKindOf（EMFEcore :: EClassifier）而不是<br>self.oclIsKindOf（OCLEcore :: OCLExpression）“）;<br>

</code>
</p>
</div>
<p></p>
<p>在上面的示例中，两个包含模糊简单名称的包（EMF Ecore包和OCL Ecore包，两者都使用简单的名称<code class="code">ecore</code> ）分别添加了别名<code class="code">EMFEcore</code>和<code class="code">OCLEcore</code> 。然后将包查找策略设置为<code class="code">LOOKUP_PACKAGE_BY_ALIAS_THEN_NAME</code> ，允许OCL表达式通过别名引用包，如<code class="code">self.oclIsKindOf(EMFEcore::EClassifier) and not self.oclIsKindOf(OCLEcore::OCLExpression)</code> 。
				</p>
<p>注意，使用委托注册表（构造函数<code class="code">EPackageRegistryImpl(EPackage.Registry)</code> ）不起作用，因为以这种方式初始化的注册表不会将调用转发给OCL包查找实现所需的<code class="code">values()</code> 。相反，如果需要使用默认注册表注册的包，则需要使用<code class="code">putAll</code>将它们复制到新的注册表，如上所示。
				</p>
</div>
<div class="section" title="自定义隐藏的相反查找和导航">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CustomizingHiddenOppositeLookupandNavigation"></a>自定义隐藏的相反查找和导航</h3>
</div>
</div>
</div>
<p>默认的<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/EcoreEnvironmentFactory.html" target="_new"><code class="code">EcoreEnvironmentFactory</code></a>生成的环境可以找到具有源<code class="code">http://schema.omg.org/spec/MOF/2.0/emof.xml</code>的注释的引用，其中包含具有关键<code class="code">Property.oppositeRoleName</code>的详细信息。在作为引用类型的类及其所有子类中，对于OCL，此批注定义了另一个可以在OCL表达式中使用的“隐藏”对立属性。当不可能或不希望定义明确的相反引用时，这可能是方便的，例如，因为不能容易地修改必须拥有相反引用的类或者不能改变该类的序列化。
				</p>
<p>用于找到这些“隐藏”对立并导航它们的逻辑由<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/OppositeEndFinder.html" target="_new"><code class="code">OppositeEndFinder</code></a>接口的实现提供。默认情况下， <code class="code">EcoreEnvironmentFactory</code>使用<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/DefaultOppositeEndFinder.html" target="_new"><code class="code">DefaultOppositeEndFinder</code></a>实现。它通过维护基于Ecore包注册表的缓存来执行带注释的引用的查找。成功导航那些“隐藏”的对立面需要为包含层次结构或应该用作导航范围的资源或资源集注册<a class="ulink" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/util/ECrossReferenceAdapter.html" target="_new"><code class="code">ECrossReferenceAdapter</code></a> 。
				</p>
<p>显然， <a class="ulink" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/util/ECrossReferenceAdapter.html" target="_new"><code class="code">ECrossReferenceAdapter</code></a>有一个明显的缺点：它仅根据EMF加载的内容响应“隐藏”的导航请求。如果底层EMF存储系统所拥有的资源集包含的资源多于迄今为止已加载到资源集中的资源，则<code class="code">ECrossReferenceAdapter</code>将不会考虑来自该存储系统的未加载内容。给定具有合理搜索能力的商店，希望利用这些能力来执行那些“隐藏”对立的反向导航。为此，可以提供<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/OppositeEndFinder.html" target="_new"><code class="code">OppositeEndFinder</code></a>接口的特定实现。它可能是<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/DefaultOppositeEndFinder.html" target="_new"><code class="code">DefaultOppositeEndFinder</code></a>一个<a class="ulink" href="http://download.eclipse.org/ocl/javadoc/6.4.0/org/eclipse/ocl/ecore/DefaultOppositeEndFinder.html" target="_new"><code class="code">DefaultOppositeEndFinder</code></a> ，例如，当基于Ecore包注册表的引用查找足够并且只重新定义导航行为时：</p>
<div class="literallayout">
<p>
<code class="code">MyOppositeEndFinder类扩展DefaultOppositeEndFinder {<br>MyOppositeEndFinder（EPackage。注册表注册表）{<br>超（注册表）;<br>}<br>
      <br>@覆盖<br>public Object navigateOppositeProperty（EStructuralFeature属性，Object target）{<br>Collection &lt;Object&gt; result = null;<br>EObject eTarget =（EObject）target;<br>//做一些聪明的事情，例如，使用底层商店的查询工具或<br>//新的EMF Query2组件（孵化）<br>// ...<br>返回结果;<br>}<br>}<br>

</code>
</p>
</div>
<p></p>
<p>有了这个，可以使用自定义的相对端查找器实例化OCL，如下所示：</p>
<div class="literallayout">
<p>
<code class="code">OCL ocl = OCL.newInstance（new EcoreEnvironmentFactoryWithHiddenOpposites（<br>EPackage。注册。INSTANCE，新的MyOppositeEndFinder（）））;<br>...<br>

</code>
</p>
</div>
<p></p>
<p>这样，当OCL表达式中的属性的使用无法解析为属性或引用时，要求相对的末端查找器查找相应命名的“隐藏”对面。然后，在“隐藏”对面的<code class="code">navigateOppositeProperty</code>将调用<code class="code">MyOppositeEndFinder</code>上的<code class="code">navigateOppositeProperty</code>方法。
				</p>
</div>
</div>
</body>
</html><html id="2718.index.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta name="copyright" content="Copyright (c) 2000, 2016 IBM Corporation and others. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
    <title>平台扩展点</title>
    <link rel="STYLESHEET" href="../../book.css" type="text/css" charset="ISO-8859-1"></link>
    <style type="text/css">/*     3Cspan class=    22notranslate hidefromparserselfclosedtags    22 gtc:attrval=    22    26lt;![CDATA[ */
:link {
  color: #0000ff;
}
:visited {
  color: #800080;
}
h1.c1 {
  text-align: center;
}
/* ]]    26gt;    22    3EFORMAT_PLACEHOLDER_1    3C/span    3E */
</style>
  </head>

  <body dir="ltr">
    <h1 class="c1">平台扩展点</h1>以下扩展点可用于扩展平台基础结构的功能：<h3>
      <a name="runtime" id="runtime"></a>平台运行时</h3>
    <ul>
      <li>
        <a href="org_eclipse_core_contenttype_contentTypes.html">org.eclipse.core.contenttype.contentTypes</a>

      </li>
      <li>
        <a href="org_eclipse_core_runtime_adapters.html">org.eclipse.core.runtime.adapters</a>
      </li>
      <li>
        <a href="org_eclipse_core_runtime_applications.html">了org.eclipse.core.runtime.applications</a>
      </li>
      <li>

        <a href="org_eclipse_core_runtime_contentTypes.html">org.eclipse.core.runtime.contentTypes</a>
      </li>
      <li>
        <a href="org_eclipse_core_runtime_preferences.html">org.eclipse.core.runtime.preferences</a>
      </li>
      <li>
        <a href="org_eclipse_core_runtime_products.html">org.eclipse.core.runtime.products</a>

      </li>
      <li>
        <a href="org_eclipse_equinox_preferences_preferences.html">org.eclipse.equinox.preferences.preferences</a>
      </li>
    </ul>
    <h3>
      <a name="workspace" id="workspace"></a>工作区</h3>
    <ul>

      <li>
        <a href="org_eclipse_core_filesystem_filesystems.html">org.eclipse.core.filesystem.filesystems</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_builders.html">org.eclipse.core.resources.builders</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_fileModificationValidator.html">org.eclipse.core.resources.fileModificationValidator</a>

      </li>
      <li>
        <a href="org_eclipse_core_resources_filterMatchers.html">org.eclipse.core.resources.filterMatchers</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_markers.html">org.eclipse.core.resources.markers</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_modelProviders.html">org.eclipse.core.resources.modelProviders</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_moveDeleteHook.html">org.eclipse.core.resources.moveDeleteHook</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_natures.html">org.eclipse.core.resources.natures</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_refreshProviders.html">org.eclipse.core.resources.refreshProviders</a>

      </li>
      <li>
        <a href="org_eclipse_core_resources_teamHook.html">org.eclipse.core.resources.teamHook</a>
      </li>
      <li>
        <a href="org_eclipse_core_resources_variableResolvers.html">org.eclipse.core.resources.variableResolvers</a>
      </li>
    </ul>
    <h3>
      <a name="text" id="text"></a>平台文本</h3>
    <ul>
      <li>
        <a href="org_eclipse_core_filebuffers_annotationModelCreation.html">org.eclipse.core.filebuffers.annotationModelCreation</a>

      </li>
      <li>
        <a href="org_eclipse_core_filebuffers_documentCreation.html">org.eclipse.core.filebuffers.documentCreation</a>
      </li>
      <li>
        <a href="org_eclipse_core_filebuffers_documentSetup.html">org.eclipse.core.filebuffers.documentSetup</a>
      </li>
      <li>

        <a href="org_eclipse_ui_editors_annotationTypes.html">org.eclipse.ui.editors.annotationTypes</a>
      </li>
      <li>
        <a href="org_eclipse_ui_editors_documentProviders.html">org.eclipse.ui.editors.documentProviders</a>
      </li>
      <li>
        <a href="org_eclipse_ui_editors_markerAnnotationSpecification.html">org.eclipse.ui.editors.markerAnnotationSpecification</a>

      </li>
      <li>
        <a href="org_eclipse_ui_editors_markerUpdaters.html">org.eclipse.ui.editors.markerUpdaters</a>
      </li>
      <li>
        <a href="org_eclipse_ui_editors_templates.html">org.eclipse.ui.editors.templates</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_autoEditStrategies.html">org.eclipse.ui.genericeditor.autoEditStrategies</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_characterPairMatchers.html">org.eclipse.ui.genericeditor.characterPairMatchers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_contentAssistProcessors.html">org.eclipse.ui.genericeditor.contentAssistProcessors</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_highlightReconcilers.html">org.eclipse.ui.genericeditor.highlightReconcilers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_presentationReconcilers.html">org.eclipse.ui.genericeditor.presentationReconciliers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_genericeditor_reconcilers.html">org.eclipse.ui.genericeditor.reconcilers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_workbench_texteditor_hyperlinkDetectors.html">org.eclipse.ui.workbench.texteditor.hyperlinkDetectors</a>
      </li>
      <li>
        <a href="org_eclipse_ui_workbench_texteditor_hyperlinkDetectorTargets.html">org.eclipse.ui.workbench.texteditor.hyperlinkDetectorTargets</a>
      </li>
      <li>
        <a href="org_eclipse_ui_workbench_texteditor_rulerColumns.html">org.eclipse.ui.workbench.texteditor.rulerColumns</a>

      </li>
      <li>
        <a href="org_eclipse_ui_workbench_texteditor_quickDiffReferenceProvider.html">org.eclipse.ui.workbench.texteditor.quickDiffReferenceProvider</a>
      </li>
      <li>
        <a href="org_eclipse_ui_workbench_texteditor_spellingEngine.html">org.eclipse.ui.workbench.texteditor.spellingEngine</a>
      </li>
    </ul>

    <h3>
      <a name="workbench" id="workbench"></a>工作台</h3>
    <ul>
      <li>
        <a href="org_eclipse_ui_acceleratorConfigurations.html">org.eclipse.ui.acceleratorConfigurations</a>
      </li>
      <li>
        <a href="org_eclipse_ui_acceleratorScopes.html">org.eclipse.ui.acceleratorScopes</a>

      </li>
      <li>
        <a href="org_eclipse_ui_acceleratorSets.html">org.eclipse.ui.acceleratorSets</a>
      </li>
      <li>
        <a href="org_eclipse_ui_actionDefinitions.html">org.eclipse.ui.actionDefinitions</a>
      </li>
      <li>

        <a href="org_eclipse_ui_actionSetPartAssociations.html">org.eclipse.ui.actionSetPartAssociations</a>
      </li>
      <li>
        <a href="org_eclipse_ui_actionSets.html">org.eclipse.ui.actionSets</a>
      </li>
      <li>
        <a href="org_eclipse_ui_activities.html">org.eclipse.ui.activities</a>

      </li>
      <li>
        <a href="org_eclipse_ui_activitySupport.html">org.eclipse.ui.activitySupport</a>
      </li>
      <li>
        <a href="org_eclipse_ui_bindings.html">org.eclipse.ui.bindings</a>
      </li>
      <li>

        <a href="org_eclipse_ui_browser_browsers.html">org.eclipse.ui.browser.browsers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_browserSupport.html">org.eclipse.ui.browserSupport</a>
      </li>
      <li>
        <a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a>

      </li>
      <li>
        <a href="org_eclipse_ui_commandImages.html">org.eclipse.ui.commandImages</a>
      </li>
      <li>
        <a href="org_eclipse_ui_contexts.html">org.eclipse.ui.contexts</a>
      </li>
      <li>

        <a href="org_eclipse_ui_decorators.html">org.eclipse.ui.decorators</a>
      </li>
      <li>
        <a href="org_eclipse_ui_dropActions.html">org.eclipse.ui.dropActions</a>
      </li>
      <li>
        <a href="org_eclipse_ui_editorActions.html">org.eclipse.ui.editorActions</a>

      </li>
      <li>
        <a href="org_eclipse_ui_editors.html">org.Eclipse.ui.editors的</a>
      </li>
      <li>
        <a href="org_eclipse_ui_elementFactories.html">org.eclipse.ui.elementFactories</a>
      </li>
      <li>

        <a href="org_eclipse_ui_encodings.html">org.eclipse.ui.encodings</a>
      </li>
      <li>
        <a href="org_eclipse_ui_exportWizards.html">org.eclipse.ui.exportWizards</a>
      </li>
      <li>
        <a href="org_eclipse_ui_fontDefinitions.html">org.eclipse.ui.fontDefinitions</a>

      </li>
      <li>
        <a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_helpSupport.html">org.eclipse.ui.helpSupport</a>
      </li>
      <li>

        <a href="org_eclipse_ui_ide_editorAssociationOverride.html">org.eclipse.ui.ide.editorAssociationOverride</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_filesystemSupport.html">org.eclipse.ui.ide.filesystemSupport</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_markerHelp.html">org.eclipse.ui.ide.markerHelp</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_markerImageProviders.html">org.eclipse.ui.ide.markerImageProviders</a>

      </li>
      <li>
        <a href="org_eclipse_ui_ide_markerResolution.html">org.eclipse.ui.ide.markerResolution</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_markerSupport.html">org.eclipse.ui.ide.markerSupport</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_projectConfigurators.html">org.eclipse.ui.ide.projectConfigurators</a>
      </li>
      <li>

        <a href="org_eclipse_ui_ide_projectNatureImages.html">org.eclipse.ui.ide.projectNatureImages</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_resourceFilters.html">org.eclipse.ui.ide.resourceFilters</a>
      </li>
      <li>
        <a href="org_eclipse_ui_ide_unassociatedEditorStrategy.html">org.eclipse.ui.ide.unassociatedEditorStrategy</a>
      </li>
      <li>
        <a href="org_eclipse_ui_navigator_linkHelper.html">org.eclipse.ui.navigator.linkHelper</a>

      </li>
      <li>
        <a href="org_eclipse_ui_navigator_navigatorContent.html">org.eclipse.ui.navigator.navigatorContent</a>
      </li>
      <li>
        <a href="org_eclipse_ui_navigator_viewer.html">org.eclipse.ui.navigator.viewer</a>
      </li>
      <li>

        <a href="org_eclipse_ui_importWizards.html">org.eclipse.ui.importWizards</a>
      </li>
      <li>
        <a href="org_eclipse_ui_installationPages.html">org.eclipse.ui.installationPages</a>
      </li>
      <li>
        <a href="org_eclipse_ui_intro.html">org.eclipse.ui.intro</a>

      </li>
      <li>
        <a href="org_eclipse_ui_keywords.html">org.eclipse.ui.keywords</a>
      </li>
      <li>
        <a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>
      </li>
      <li>
        <a href="org_eclipse_ui_monitoring_logger.html">org.eclipse.ui.monitoring.logger</a>
      </li>
      <li>

        <a href="org_eclipse_ui_newWizards.html">org.eclipse.ui.newWizards</a>
      </li>
      <li>
        <a href="org_eclipse_ui_perspectiveExtensions.html">org.eclipse.ui.perspectiveExtensions</a>
      </li>
      <li>
        <a href="org_eclipse_ui_perspectives.html">org.eclipse.ui.perspectives</a>

      </li>
      <li>
        <a href="org_eclipse_ui_popupMenus.html">org.eclipse.ui.popupMenus</a>
      </li>
      <li>
        <a href="org_eclipse_ui_preferencePages.html">org.eclipse.ui.preferencePages</a>
      </li>
      <li>

        <a href="org_eclipse_ui_preferenceTransfer.html">org.eclipse.ui.preferenceTransfer</a>
      </li>
      <li>
        <a href="org_eclipse_ui_propertiesView.html">org.eclipse.ui.propertiesView</a>

      </li>
      <li>
        <a href="org_eclipse_ui_propertyPages.html">org.eclipse.ui.propertyPages</a>
      </li>
      <li>
        <a href="org_eclipse_ui_services.html">org.eclipse.ui.services</a>
      </li>
      <li>

        <a href="org_eclipse_ui_splashHandlers.html">org.eclipse.ui.splashHandlers</a>
      </li>
      <li>
        <a href="org_eclipse_ui_startup.html">org.eclipse.ui.startup</a>
      </li>
      <li>
        <a href="org_eclipse_ui_statusHandlers.html">org.eclipse.ui.statusHandlers</a>

      </li>
      <li>
        <a href="org_eclipse_ui_systemSummarySections.html">org.eclipse.ui.systemSummarySections</a>
      </li>
      <li>
        <a href="org_eclipse_ui_themes.html">org.eclipse.ui.themes</a>
      </li>
      <li>

        <a href="org_eclipse_ui_viewActions.html">的org.eclipse.ui.viewActions</a>
      </li>
      <li>
        <a href="org_eclipse_ui_views.html">的org.eclipse.ui.views</a>
      </li>
      <li>
        <a href="org_eclipse_ui_views_properties_tabbed_propertyContributor.html">org.eclipse.ui.views.properties.tabbed.propertyContributor</a>

      </li>
      <li>
        <a href="org_eclipse_ui_views_properties_tabbed_propertySections.html">org.eclipse.ui.views.properties.tabbed.propertySections</a>
      </li>
      <li>
        <a href="org_eclipse_ui_views_properties_tabbed_propertyTabs.html">org.eclipse.ui.views.properties.tabbed.propertyTabs</a>
      </li>
      <li>

        <a href="org_eclipse_ui_workingSets.html">org.eclipse.ui.workingSets</a>
      </li>
    </ul>
    <h3>
      <a name="team" id="team"></a>球队</h3>
    <ul>
<!-- Bug 467584: [JSch] document org.eclipse.jsch.core.authenticator extension-point
      <li>
        <a href=
        "org_eclipse_jsch_core_authenticator.html">org.eclipse.jsch.core.authenticator</a>
      </li>
-->
      <li>
        <a href="org_eclipse_jsch_core_identityrepository.html">org.eclipse.jsch.core.identityrepository</a>
      </li>
      <li>
        <a href="org_eclipse_team_core_fileTypes.html">org.eclipse.team.core.fileTypes</a>

      </li>
      <li>
        <a href="org_eclipse_team_core_ignore.html">org.eclipse.team.core.ignore</a>
      </li>
      <li>
        <a href="org_eclipse_team_core_projectSets.html">org.eclipse.team.core.projectSets</a>
      </li>
      <li>

        <a href="org_eclipse_team_core_repository.html">org.eclipse.team.core.repository</a>
      </li>
      <li>
        <a href="org_eclipse_team_core_storageMergers.html">org.eclipse.team.core.storageMergers</a>
      </li>
      <li>
        <a href="org_eclipse_team_ui_configurationWizards.html">org.eclipse.team.ui.configurationWizards</a>

      </li>
      <li>
        <a href="org_eclipse_team_ui_synchronizeParticipants.html">org.eclipse.team.ui.synchronizeParticipants</a>
      </li>
      <li>
        <a href="org_eclipse_team_ui_synchronizeWizards.html">org.eclipse.team.ui.synchronizeWizards</a>
      </li>
      <li>

        <a href="org_eclipse_team_ui_teamContentProviders.html">org.eclipse.team.ui.teamContentProviders</a>
      </li>
      <li>
        <a href="org_eclipse_team_ui_teamDecorators.html">org.eclipse.team.ui.teamDecorators</a>
      </li>
    </ul>
    <h3>
      <a name="debug" id="debug"></a>调试</h3>

    <ul>
      <li>
        <a href="org_eclipse_debug_core_breakpoints.html">org.eclipse.debug.core.breakpoints</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_breakpointImportParticipants.html">org.eclipse.debug.core.breakpointImportParticipants</a>
      </li>
      <li>

        <a href="org_eclipse_debug_core_launchConfigurationComparators.html">org.eclipse.debug.core.launchConfigurationComparators</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_launchConfigurationTypes.html">org.eclipse.debug.core.launchConfigurationTypes</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_launchDelegates.html">org.eclipse.debug.core.launchDelegates</a>

      </li>
      <li>
        <a href="org_eclipse_debug_core_launchers.html">org.eclipse.debug.core.launchers</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_launchModes.html">org.eclipse.debug.core.launchModes</a>
      </li>
      <li>

        <a href="org_eclipse_debug_core_logicalStructureProviders.html">org.eclipse.debug.core.logicalStructureProviders</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_logicalStructureTypes.html">org.eclipse.debug.core.logicalStructureTypes</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_processFactories.html">org.eclipse.debug.core.processFactories</a>

      </li>
      <li>
        <a href="org_eclipse_debug_core_sourceContainerTypes.html">org.eclipse.debug.core.sourceContainerTypes</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_sourceLocators.html">org.eclipse.debug.core.sourceLocators</a>
      </li>
      <li>

        <a href="org_eclipse_debug_core_sourcePathComputers.html">org.eclipse.debug.core.sourcePathComputers</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_statusHandlers.html">org.eclipse.debug.core.statusHandlers</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_stepFilters.html">org.eclipse.debug.core.stepFilters</a>
      </li>
      <li>
        <a href="org_eclipse_debug_core_watchExpressionDelegates.html">org.eclipse.debug.core.watchExpressionDelegates</a>

      </li>
      <li>
        <a href="org_eclipse_debug_ui_breakpointOrganizers.html">org.eclipse.debug.ui.breakpointOrganizers</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_consoleColorProviders.html">org.eclipse.debug.ui.consoleColorProviders</a>
      </li>
      <li>

        <a href="org_eclipse_debug_ui_consoleLineTrackers.html">org.eclipse.debug.ui.consoleLineTrackers</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_contextViewBindings.html">org.eclipse.debug.ui.contextViewBindings</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_debugModelContextBindings.html">org.eclipse.debug.ui.debugModelContextBindings</a>

      </li>
      <li>
        <a href="org_eclipse_debug_ui_debugModelPresentations.html">org.eclipse.debug.ui.debugModelPresentations</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_detailPaneFactories.html">org.eclipse.debug.ui.detailPaneFactories</a>
      </li>
      <li>

        <a href="org_eclipse_debug_ui_launchConfigurationTabGroups.html">org.eclipse.debug.ui.launchConfigurationTabGroups</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_launchConfigurationTabs.html">org.eclipse.debug.ui.launchConfigurationTabs</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_launchConfigurationTypeImages.html">org.eclipse.debug.ui.launchConfigurationTypeImages</a>

      </li>
      <li>
        <a href="org_eclipse_debug_ui_launchGroups.html">org.eclipse.debug.ui.launchGroups</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_launchShortcuts.html">org.eclipse.debug.ui.launchShortcuts</a>
      </li>
      <li>

        <a href="org_eclipse_debug_ui_memoryRenderings.html">org.eclipse.debug.ui.memoryRenderings</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_sourceContainerPresentations.html">org.eclipse.debug.ui.sourceContainerPresentations</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_stringVariablePresentations.html">org.eclipse.debug.ui.stringVariablePresentations</a>

      </li>
      <li>
        <a href="org_eclipse_debug_ui_toggleBreakpointsTargetFactories.html">org.eclipse.debug.ui.toggleBreakpointsTargetFactories</a>
      </li>
      <li>
        <a href="org_eclipse_debug_ui_variableValueEditors.html">org.eclipse.debug.ui.variableValueEditors</a>
      </li>
    </ul>

    <h3>
      <a name="console" id="console"></a>安慰</h3>
    <ul>
      <li>
        <a href="org_eclipse_ui_console_consoleFactories.html">org.eclipse.ui.console.consoleFactories</a>
      </li>
      <li>
        <a href="org_eclipse_ui_console_consolePageParticipants.html">org.eclipse.ui.console.consolePageParticipants</a>

      </li>
      <li>
        <a href="org_eclipse_ui_console_consolePatternMatchListeners.html">org.eclipse.ui.console.consolePatternMatchListeners</a>
      </li>
    </ul>
    <h3>
      <a name="ua" id="ua"></a>用户帮助</h3>
    <ul>

      <li>
        <a href="org_eclipse_help_contentExtension.html">org.eclipse.help.contentExtension</a>
      </li>
      <li>
        <a href="org_eclipse_help_contentProducer.html">org.eclipse.help.contentProducer</a>
      </li>
      <li>
        <a href="org_eclipse_help_contexts.html">org.eclipse.help.contexts</a>

      </li>
      <li>
        <a href="org_eclipse_help_criteriaDefinition.html">org.eclipse.help.criteriaDefinition</a>
      </li>
      <li>
        <a href="org_eclipse_help_criteriaProvider.html">org.eclipse.help.criteriaProvider</a>
      </li>
      <li>

        <a href="org_eclipse_help_index.html">org.eclipse.help.index</a>
      </li>
      <li>
        <a href="org_eclipse_help_toc.html">org.eclipse.help.toc将此</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_activitySupport.html">org.eclipse.help.base.activitySupport</a>

      </li>
      <li>
        <a href="org_eclipse_help_base_browser.html">org.eclipse.help.base.browser</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_display.html">org.eclipse.help.base.display</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_luceneAnalyzer.html">org.eclipse.help.base.luceneAnalyzer</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_searchParticipant.html">org.eclipse.help.base.searchParticipant</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_searchProcessor.html">org.eclipse.help.base.searchProcessor</a>

      </li>
      <li>
        <a href="org_eclipse_help_base_server.html">org.eclipse.help.base.server</a>
      </li>
      <li>
        <a href="org_eclipse_help_base_scope.html">org.eclipse.help.base.scope</a>
      </li>
      <li>

        <a href="org_eclipse_help_ui_searchEngine.html">org.eclipse.help.ui.searchEngine</a>
      </li>
      <li>
        <a href="org_eclipse_help_webapp_contentFilter.html">org.eclipse.help.webapp.contentFilter</a>
      </li>
      <li>
        <a href="org_eclipse_help_webapp_frame.html">org.eclipse.help.webapp.frame</a>

      </li>
      <li>
        <a href="org_eclipse_help_webapp_toolbarButton.html">org.eclipse.help.webapp.toolbarButton</a>
      </li>
      <li>
        <a href="org_eclipse_help_webapp_validatedServlet.html">org.eclipse.help.webapp.validatedServlet</a>
      </li>
      <li>

        <a href="org_eclipse_help_webapp_view.html">org.eclipse.help.webapp.view</a>
      </li>
      <li>
        <a href="org_eclipse_ui_cheatsheets_cheatSheetContent.html">org.eclipse.ui.cheatsheets.cheatSheetContent</a>
      </li>
      <li>
        <a href="org_eclipse_ui_cheatsheets_cheatSheetItemExtension.html">org.eclipse.ui.cheatsheets.cheatSheetItemExtension</a>

      </li>
      <li>
        <a href="org_eclipse_ui_intro_config.html">org.eclipse.ui.intro.config</a>
      </li>
      <li>
        <a href="org_eclipse_ui_intro_configExtension.html">org.eclipse.ui.intro.configExtension</a>
      </li>
      <li>
        <a href="org_eclipse_ui_intro_quicklinks.html">org.eclipse.ui.intro.quicklinks</a>
      </li>
    </ul>

    <h3>
      <a name="ltk" id="ltk"></a>语言工具包</h3>
    <ul>
      <li>
        <a href="org_eclipse_ltk_core_refactoring_refactoringContributions.html">org.eclipse.ltk.core.refactoring.refactoringContributions</a>
      </li>
      <li>
        <a href="org_eclipse_ltk_core_refactoring_copyParticipants.html">org.eclipse.ltk.core.refactoring.copyParticipants</a>

      </li>
      <li>
        <a href="org_eclipse_ltk_core_refactoring_createParticipants.html">org.eclipse.ltk.core.refactoring.createParticipants</a>
      </li>
      <li>
        <a href="org_eclipse_ltk_core_refactoring_deleteParticipants.html">org.eclipse.ltk.core.refactoring.deleteParticipants</a>
      </li>
      <li>

        <a href="org_eclipse_ltk_core_refactoring_moveParticipants.html">org.eclipse.ltk.core.refactoring.moveParticipants</a>
      </li>
      <li>
        <a href="org_eclipse_ltk_core_refactoring_renameParticipants.html">org.eclipse.ltk.core.refactoring.renameParticipants</a>
      </li>
      <li>
        <a href="org_eclipse_ltk_ui_refactoring_changePreviewViewers.html">org.eclipse.ltk.ui.refactoring.changePreviewViewers</a>

      </li>
      <li>
        <a href="org_eclipse_ltk_ui_refactoring_statusContextViewers.html">org.eclipse.ltk.ui.refactoring.statusContextViewers</a>
      </li>
    </ul>
    <h3>
      <a name="security" id="security"></a>安全</h3>
    <ul>

      <li>
        <a href="org_eclipse_equinox_security_loginConfigurationProvider.html">org.eclipse.equinox.security.loginConfigurationProvider</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_security_loginModule.html">org.eclipse.equinox.security.loginModule</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_security_callbackHandler.html">org.eclipse.equinox.security.callbackHandler</a>

      </li>
      <li>
        <a href="org_eclipse_equinox_security_callbackHandlerMapping.html">org.eclipse.equinox.security.callbackHandlerMapping</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_security_secureStorage.html">org.eclipse.equinox.security.secureStorage</a>
      </li>
    </ul>

    <h3>
      <a name="other" id="other"></a>其他</h3>
    <ul>
      <li>
        <a href="org_eclipse_ant_core_antProperties.html">org.eclipse.ant.core.antProperties</a>
      </li>
      <li>
        <a href="org_eclipse_ant_core_antTasks.html">org.eclipse.ant.core.antTasks</a>

      </li>
      <li>
        <a href="org_eclipse_ant_core_antTypes.html">org.eclipse.ant.core.antTypes</a>
      </li>
      <li>
        <a href="org_eclipse_ant_core_extraClasspathEntries.html">org.eclipse.ant.core.extraClasspathEntries</a>
      </li>
      <li>

        <a href="org_eclipse_compare_contentMergeViewers.html">org.eclipse.compare.contentMergeViewers</a>
      </li>
      <li>
        <a href="org_eclipse_compare_contentViewers.html">org.eclipse.compare.contentViewers</a>
      </li>
      <li>
        <a href="org_eclipse_compare_streamMergers.html">org.eclipse.compare.streamMergers</a>

      </li>
      <li>
        <a href="org_eclipse_compare_structureCreators.html">org.eclipse.compare.structureCreators</a>
      </li>
      <li>
        <a href="org_eclipse_compare_structureMergeViewers.html">org.eclipse.compare.structureMergeViewers</a>
      </li>
      <li>

        <a href="org_eclipse_core_expressions_propertyTesters.html">org.eclipse.core.expressions.propertyTesters</a>
      </li>
      <li>
        <a href="org_eclipse_core_expressions_definitions.html">org.eclipse.core.expressions.definitions</a>
      </li>
      <li>
        <a href="org_eclipse_core_variables_dynamicVariables.html">org.eclipse.core.variables.dynamicVariables</a>

      </li>
      <li>
        <a href="org_eclipse_core_variables_valueVariables.html">org.eclipse.core.variables.valueVariables</a>
      </li>
      <li>
        <a href="org_eclipse_e4_ui_css_swt_theme.html">org.eclipse.e4.ui.css.swt.theme</a>
      </li>
      <li>
        <a href="org_eclipse_e4_workbench_model.html">org.eclipse.e4.workbench.model</a>
      </li>
      <li>
        <a href="org_eclipse_e4_workbench_model_definition_enrichment.html">org.eclipse.e4.workbench.model.definition.enrichment</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_bidi_bidiTypes.html">org.eclipse.equinox.bidi.bidiTypes</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_http_registry_filters.html">org.eclipse.equinox.http.registry.filters</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_http_registry_httpcontexts.html">org.eclipse.equinox.http.registry.httpcontexts</a>
      </li>
      <li>

        <a href="org_eclipse_equinox_http_registry_resources.html">org.eclipse.equinox.http.registry.resources</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_http_registry_servlets.html">org.eclipse.equinox.http.registry.servlets</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_p2_artifact_repository_artifactChecksums.html">org.eclipse.equinox.p2.artifact.repository.artifactChecksums</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_p2_artifact_repository_artifactComparators.html">org.eclipse.equinox.p2.artifact.repository.artifactComparators</a>
      </li>
      <li>
        <a href="org_eclipse_equinox_p2_artifact_repository_artifactRepositories.html">org.eclipse.equinox.p2.artifact.repository.artifactRepositories</a>
      </li>
       <li>
        <a href="org_eclipse_equinox_p2_artifact_repository_processingSteps.html">org.eclipse.equinox.p2.artifact.repository.processingSteps</a>
      </li>
      
      <li>
        <a href="org_eclipse_search_searchPages.html">org.eclipse.search.searchPages</a>

      </li>
      <li>
        <a href="org_eclipse_search_searchResultSorters.html">org.eclipse.search.searchResultSorters</a>
      </li>
      <li>
        <a href="org_eclipse_search_searchResultViewPages.html">org.eclipse.search.searchResultViewPages</a>
      </li>
      <li>

        <a href="org_eclipse_search_textSearchEngine.html">org.eclipse.search.textSearchEngine</a>
      </li>
      <li>
        <a href="org_eclipse_search_textSearchQueryProvider.html">org.eclipse.search.textSearchQueryProvider</a>
      </li>
      <li>
        <a href="org_eclipse_ui_externaltools_configurationDuplicationMaps.html">org.eclipse.ui.externaltools.configurationDuplicationMaps</a>

      </li>
    </ul>
  </body>
</html><html id="1993.s2.1.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.2.html" rel="next">§2.2降低&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
         <div class="sect depth2" id="s2.1">
            <h2 class="sect">§2.1播放了关系<a class="img" href="s2.1.html" title="PermaLink到§2.1播放了关系"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="syntaxlink"><a href="sA.html#sA.1.1" title="§A.1.1ClassDeclaration" class="syntax">→语法§A.1.1</a></div>
            <div class="subsect depth3" id="s2.1.a">
               <h4 class="subsect">（a）基于<span class="title">角色的约束力</span><a class="img" href="s2.1.a.html" title="PermaLink到（a）角色基础绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>角色由<code>playedBy</code>关键字绑定到基类。
                  			
               </p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>公共</b> <b>课</b> MyRole <em><b>playBy</b> MyBase</em> {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>...</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth3" id="s2.1.b">
               <h4 class="subsect">（b） <span class="title">继承</span><a class="img" href="s2.1.b.html" title="永久链接到（b）继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p><code>playedBy</code>关系沿着显式和隐式（ <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）角色继承继承。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.1.c">
               <h4 class="subsect">（c） <span class="title">协变细化</span><a class="img" href="s2.1.c.html" title="PermaLink（c）协变细化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p><em>显</em> <code>playedBy</code>角色（使用<code>extends</code>子类）可以将<code>playedBy</code>关系细化为更具体的基类（这是<a href="s2.3.3.html" title="§2.3.3 Smart lifting" class="sect">智能提升</a>的基础<a href="s2.3.3.html" title="§2.3.3智能提升" class="sect">（第2.3.3节）</a> ）。<br>如果角色类从其超类及其超级接口继承了几个<code>playedBy</code>关系，则这些关系中必须存在最特定的基类，这与所有其他基类一致。这个最具体的基类是当前角色的基类。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.1.d">
               <h4 class="subsect">（d） <span class="title">无差异</span><a class="img" href="s2.1.d.html" title="永久链接到（d）无差异"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p><em>隐</em> <a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">式子</a>角色（根据<a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）可能只添加一个<code>playedBy</code>关系但从不更改现有关系。<br>但是请注意，隐式继承可能隐含地专门化现有的<code>playedBy</code>关系（这种高级情况在<a href="s2.7.d.html" title="§2.7。（d）隐式播放专业化" class="sect">§2.7。（d）中说明</a> ）。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.1.e">
               <h4 class="subsect">（e） <span class="title">使用playingBy绑定</span><a class="img" href="s2.1.e.html" title="永久链接到（e）使用playBy绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p><code>playedBy</code>关系本身对角色和基础对象的行为没有影响。然而，它是翻译多态性（降低： <a href="s2.2.html" title="§2.2降低" class="sect">§2.2</a>和提升： <a href="s2.3.html" title="§2.3提升" class="sect">§2.3</a> ）和方法绑定（标注： <a href="s3.html" title="§3标注绑定" class="sect">§3</a>和callin： <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）的前提条件。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s2.1.f">
               <h4 class="subsect">（f） <span class="title">对垃圾收集的影响</span><a class="img" href="s2.1.f.html" title="PermaLink（f）对垃圾收集的影响"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>角色及其基础对象形成一个概念实体。垃圾收集器将以双向方式链接角色及其基础对象。因此，如果角色的基础仍然可以访问，则不能对其进行垃圾回收，反之亦然。
                  <br>在内部，团队使用弱引用来管理其角色和相应的基础。使用其中一个<code>getAllRoles(..)</code>方法（参见<a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ），结果可能是非确定性的，因为这些内部结构可能包含对下一次垃圾收集器收集的对象的弱引用。我们建议<code>getAllRoles(..)</code>客户在调用<code>getAllRoles(..)</code>之前调用<code>System.gc()</code>以确保确定性结果。
                  			
               </p>
            </div>
            <div class="sect depth3" id="s2.1.1">
               <h3 class="sect">§2.1.1绑定接口<a class="img" href="s2.1.1.html" title="PermaLinkto§2.1.1绑定接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.1</a></span></h3>
               <p>角色基础绑定可能涉及类和/或接口。定义为团队成员的接口是角色接口，因此可以具有<code>playedBy</code>子句。另外，在<code>playedBy</code>关键字之后提到的类型可以是接口。
                  			
               </p>
               <div class="note">
                  <h5>实施限制：</h5>OTDT版本2.0的语言实现在将角色绑定到基接口时强加了一个特定的限制：绑定到基接口的角色可能不包含任何callin绑定（ <a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ）。
                  			
               </div>
            </div>
            <div class="sect depth3" id="s2.1.2">
               <h3 class="sect">§2.1.2法定基础类<a class="img" href="s2.1.2.html" title="PermaLinkto§2.1.2法定基类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§2.1</a></span></h3>
               <p>通常， <code>playedBy</code>之后提到的基类必须在封闭范围内可见（参见<a href="#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">下文（§2.1.2。（c））</a>的异常）。通常，此范围仅由封闭团队的导入定义。对于角色文件（ <a href="s1.2.5.b.html" title="§1.2.5。（b）角色文件" class="sect">§1.2.5。（b）</a> ），还会考虑角色文件中的其他导入。
                  <br><a href="#s2.1.2.d" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a>定义了如何约束导入，以便某些类型只能用作基类型。
                  			
               </p>
               <div class="subsect depth4" id="s2.1.2.a">
                  <h4 class="subsect">（a） <span class="title">同一团队没有任何作用</span><a class="img" href="s2.1.2.a.html" title="PermaLink（a）没有同一团队的角色"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>任何角色类的基类都不能是同一团队的角色。
                     			<br>如果该基类以其简单名称给出并使用常规导入解析，则也不允许声明与绑定到此或其他角色的基类绑定同名的角色类。换句话说， <code>playedBy</code>之后提到的基类可能不会被封闭团队的任何角色类<em>遮蔽</em> 。
                     			<br>如下定义的<em>基本导入</em> （第<a href="#s2.1.2.d" title="§2.1.2。（d）基础进口" class="sect">2.1.2节（d）</a> ）通过允许仅将类作为基类导入来放宽此规则。在这种情况下，由于基类和角色的范围是不相交的，因此不会发生阴影。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.1.2.b">
                  <h4 class="subsect">（b） <span class="title">周期</span><a class="img" href="s2.1.2.b.html" title="永久链接到（b）周期"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在<code>playedBy</code>之后提到的基类通常不应该是被定义的角色类的封闭类型（在任何深度）。
                     <br>此规则不鼓励创建循环，其中给定角色<code>R</code>的基本实例包含相同类型<code>R</code>角色。<br>更一般地，这涉及<code>C <sub>1</sub> , C <sub>2</sub> , ..类的任何序列<code>C <sub>1</sub> , C <sub>2</sub> , ..C <sub>n</sub></code>各自<code>C <sub>i+1</sub></code>可以是一个部件或基类的<code>C <sub>i</sub></code>和<code>C <sub>n</sub> = C <sub>1</sub></code> 。
                     <br>这些结构可能难以理解，并且对callout（ <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">§3.1。（a）</a> ）和基本构造函数调用（ <a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">§2.4.2</a> ）有一定的限制。此外，建议装备一个封闭类所扮演的所有角色，并使用这样的守护谓词（ <a href="s5.4.html" title="§5.4守护谓词" class="sect">§5.4</a> ）：</p>
                  <div class="listing plain"><pre><em>基数</em> <em>时</em> （MyTeam.this == <em>base</em> ）</pre></div>
                  <p>这将避免角色适应封闭类的其他实例，而不是封闭实例。
                     
                  </p>
                  <p>禁止将角色类绑定到其自己的内部类。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.1.2.c">
                  <h4 class="subsect">（c） <span class="title">基类解封</span><a class="img" href="s2.1.2.c.html" title="PermaLink到（c）基类解封装"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果在<code>playedBy</code>之后引用的基类存在但在Java的正常可见性规则下不可见，则可以覆盖此限制。这个概念称为解<strong>封装</strong> ，即与封装相反（另见<a href="s3.4.html" title="§3.4覆盖访问限制" class="sect">§3.4</a> ）。编译器应该发出任何基类解封装的信号。如果编译器支持配置警告，则可以使用这个来让用户选择（a）忽略基类解封装，（b）将其视为警告或甚至（c）将其视为错误。
                     
                  </p>
                  <p>绑定到<code>final</code>基类也被视为解封装，因为<code>playedBy</code>关系具有类似于<code>extends</code>关系的权限，这通过将类标记为<code>final</code>来禁止。
                     
                  </p>
                  <p>如果基类是一个受限制的角色，则不允许解封装（参见<a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ）。
                     
                  </p>
                  <p>在当前角色中，可以在任何方法绑定（ <a href="s3.html" title="§3标注绑定" class="sect">callout（§3）</a>或<a href="s4.html" title="§4Callin绑定" class="sect">callin（§4）</a> ）的右侧提及解封装的基类。这些位置的参数也可以提到解封的基类：</p>
                  <ul>
                     <li>角色的一个构造函数的第一个参数（参见<a href="s2.4.1.html" title="§2.4.1通过提升构造函数创建角色" class="sect">提升构造函数（第2.4.1节）</a> ）。
                     </li>
                     <li>声明提升的参数的基础侧（参见<a href="s2.3.2.html" title="§2.3.2宣布解除" class="sect">声明的提升（§2.3.2）</a> ）。
                     </li>
                  </ul>
               </div>
               <div class="subsect depth4" id="s2.1.2.d">
                  <h4 class="subsect">（d） <span class="title">基础进口</span><a class="img" href="s2.1.2.d.html" title="永久链接到（d）基础进口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果文件中的主要类型表示团队，则可以将修改器<code>base</code>应用于单个导入，以指定应仅将此类型作为基本类型导入应用程序。例：</p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><em><b>进口</b>基地</em> some.pack。MyBase;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>班</b> MyTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <span class="comment">//简单名称解析为导入的类：</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>  <b>受保护的</b> <b>类</b> MyRole <em><b>playBy</b> MyBase</em> {}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>  <span class="error"><em>MyBase</em>非法声明;</span> <span class="comment">// base import不适用于此职位</span></pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <p>基本导入不能是按需导入（使用通配符） <code>.*</code> ）。<br>基本导入导入的类型只能用于同样适用基类解封装（ <a href="#s2.1.2.c" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ）的位置。<br>建议在关键字<code>playedBy</code>之后提到的类型始终使用<code>base</code>修饰符导入，否则编译器将发出警告。<br>基本导入创建的范围与正常范围不相交。因此，作为基础导入的名称永远不会与通常可见的名称冲突（与<a href="s1.4.html" title="§1.4姓名冲突" class="sect">§1.4</a>相反）。更具体地说，如果使用基本导入，则对其角色使用基类名称也不是问题。
                     				
                  </p>
               </div>
               <div class="subsect depth4" id="s2.1.2.e">
                  <h4 class="subsect">（e） <span class="title">没有自由类型参数</span><a class="img" href="s2.1.2.e.html" title="永久链接到（e）没有自由类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>playBy绑定中的角色类和基类都不能具有任何<em>自由类型参数</em> 。如果使用相同名称的类型参数指定两个类，则会识别这两个参数，并且不会将其视为<em>空闲</em> 。
                     				
                  </p>
                  <p>由此可见，角色类不能具有比其基础更多的类型参数。相反，只存在一种情况，其中基类可以拥有比绑定到它的角色类更多的类型参数：如果角色类没有类型参数，则可以使用基类的原始类型绑定通用基类，即，不指定类型参数。
                     				
                  </p>
                  <div class="note">
                     <h5>注意：</h5>来自<code>playedBy</code>声明的信息在运行时用于将角色实例与基本实例相关联。指定具有自由类型参数的基类将意味着只有这样的基类实例由类型符合指定参数化类的角色进行修饰。但是，类型参数在运行时不可用，因此运行时环境无法确定哪些基本实例应该具有角色，哪些不应该具有角色。这是由于Java中的泛型设计是通过擦除实现的。
                     				
                  </div>
                  <p>以下示例显示了如何在各种位置使用泛型。请注意，示例中使用的某些概念将在后面的部分中介绍。
                  </p>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>类</b> ValueTrafo <em>&lt;T&gt;</em> {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <em>T</em> transform（ <em>T</em> val） <b>抛出</b>异常{/ * ...* /}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>类</b> TransformTeam {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>    <b>受保护的</b> <b>类</b> SafeTrafo <em>&lt;U&gt;</em> <b>playingBy</b> ValueTrafo <em>&lt;U&gt;</em> {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>        <em>U</em>变换（ <em>U</em> v） <b>- &gt;</b> <em>U</em>变换（ <em>U</em> val）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>        <b>protected</b> <em>U</em> safeTransform（ <em>U</em> v）{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>            <b>尝试</b> {</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>            	<b>return</b> transform（v）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>} <b>catch</b> （例外e）{</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>            	<b>返回</b> v;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">13</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">14</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">15</td>
                           <td><pre>    <em>&lt;V&gt; V</em>执行（ValueTrafo <em>&lt;V&gt;</em> <b>为</b> SafeTrafo <em>&lt;V&gt;</em> trafo， <em>V</em>值）{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">16</td>
                           <td><pre>        <b>return</b> trafo.safeTransform（value）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">17</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">18</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">19</td>
                           <td><pre>...</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">20</td>
                           <td><pre>ValueTrafo <em>&lt;String&gt;</em> trafo = <b>new</b> ValueTrafo <em>&lt;String&gt;</em> （）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">21</td>
                           <td><pre>TransformTeam safeTrafo = <b>new</b> TransformTeam（）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">22</td>
                           <td><pre>String s = safeTrafo.perform（trafo，“Testing”）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">23</td>
                           <td><pre></pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>说明</h5>
                     <ul>
                        <li>第5行显示了一个带有类型参数<code>U</code>的角色，其中type参数用角色基类的相应类型参数标识（最初在第1行中声明为<code>T</code>
                        </li>
                        <li>第6行显示了一个callout绑定（ <a href="s3.html" title="§3标注绑定" class="sect">§3</a> ），它将一个基本方法转换为相应的角色方法，同时保持灵活的类型。
                        </li>
                        <li>第7-13行中的常规方法只传递<code>U</code>类型的值。
                        </li>
                        <li>第15行中的通用方法。使用声明的提升（第<a href="s2.3.2.html" title="§2.3.2宣布解除" class="sect">2.3.2节</a> ）来获取给定基础对象的角色。该方法不知道role或base的具体类型参数，但在保证两个类型参数对于任何单个调用都是相同的情况下工作。
                        </li>
                        <li>第20行ff。最后创建base和team的实例并调用该行为，从而将类型参数实例化为<code>String</code> 。
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s2.2.html" rel="next">§2.2降低&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s2.html" rel="section">§2角色绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html><html id="2869.org_eclipse_ui_commands.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>命令</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">命令</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.commands<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>2.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p><code>org.eclipse.ui.commands</code>扩展点用于使用<code>command</code>和<code>category</code>元素声明命令和命令类别。命令是某些语义行为的抽象表示，但不是其实际实现。这允许不同的开发人员为他们的各个部分贡献特定的行为。例如，可能存在“粘贴”命令，其中编辑器中具有一个实现，而浏览器窗口小部件中具有不同的实现。这些实现称为处理程序。命令也可以被视为声明性函数指针或信号处理程序。
</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.category">类别</a> *， <a href="#e.command">命令</a> *， <a href="#e.commandParameterType">commandParameterType</a> *， <a href="#e.keyBinding">keyBinding</a> *， <a href="#e.keyConfiguration">keyConfiguration</a> *， <a href="#e.context">context</a> *， <a href="#e.scope">scope</a> *， <a href="#e.activeKeyConfiguration">activeKeyConfiguration</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 扩展实例的可选标识符。</li>
<li><b>name</b> - 扩展实例的可选名称。</li>
<li><b>point</b> - 目标扩展点的标准标识符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.command">命令</a> （ <a href="#e.defaultHandler">defaultHandler</a> ？， <a href="#e.state">state</a> *， <a href="#e.commandParameter">commandParameter</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令</p>
<p class="code SchemaDtdAttlist">类别CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">categoryId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultHandler CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">returnTypeId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>该元素用于定义命令。命令表示来自用户的可以由动作处理的请求，并且在其他命令中应该在语义上是唯一的。如果已经定义了具有相同含义的命令，则不要定义命令。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。请参阅扩展点<a href="org_eclipse_ui_actionSets.html">org.eclipse.ui.actionSets</a>和<a href="org_eclipse_ui_editorActions.html">org.eclipse.ui.editorActions</a>以了解操作如何连接到命令。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">弃用</i> <b>类别</b> - 请改用<code>categoryId</code> 。</li>
<li><b>description</b> - 此命令的可翻译简短描述，用于在UI中显示。</li>
<li><b>id</b> - 此命令的唯一标识符。</li>
<li><b>name</b> - 要在UI中显示的此命令的可翻译名称。命令通常以命令式动词的形式命名。</li>
<li><b>categoryId</b> -<p>此命令的类别的唯一ID。如果此命令未指定类别，则它将被置于全局“未分类”类别中，默认情况下将在“密钥”首选项页面上进行过滤，这意味着除非用户禁用“未分类”命令的过滤器，否则用户无法分配密钥绑定。
</p>
<p><em>从：3.0</em></p></li>
<li><b>defaultHandler</b> -<p>此命令的默认处理程序（请参阅<a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>扩展点）。如果没有其他处理程序处于活动状态，则此处理程序将处此处理程序将与指定没有<code>activeWhen</code>条件的其他处理程序定义冲突。如果要创建<code>IExecutableExtension</code> ，则可以使用<code>defaultHandler</code>元素。
</p>
<p><em>自：3.1</em></p></li>
<li><b>returnTypeId</b> -<p><code>commandParameterType</code>的id，指示此命令返回的值的类型。指定<code>returnTypeId</code>允许执行该命令的客户端将返回的值与Java类型相关联，并将该值转换为可以存储和/或传递给另一个接受相同类型参数的命令的String形式。
</p>
<p><em>自：3.2</em></p></li>
<li><b>helpContextId</b> -<p>通常与此命令相关的帮助上下文的标识符。处理程序可以覆盖此上下文标识符，以提供更特定于其特定行为的帮助。
</p>
<p><em>自：3.2</em></p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.category">类别</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST类别</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>在UI中，命令通常按类别组织，以使其更易于管理。此元素用于定义这些类别。命令可以将自己添加到最多一个类别。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>description</b> - 此类别的可翻译简短描述，用于在UI中显示。</li>
<li><b>id</b> - 此类别的唯一标识符。</li>
<li><b>name</b> - 要在UI中显示的此类别的可翻译名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.commandParameter">commandParameter</a> （ <a href="#e.values">值</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST命令参数</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">typeId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">optional（true | false）“true”&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>定义命令应该理解的参数。参数是一种在执行时向处理程序提供更多信息的方法。例如，“show view”命令可能会将视图作为参数。处理程序应该能够理解这些参数，因此它们应该像API一样对待。</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此参数的唯一标识符。</li>
<li><b>name</b> - 参数的名称。这是将显示给最终用户的名称。因此，它应该是可翻译的。这个名字应该简短 - 最好是一个字。</li>
<li><b>values</b> - 提供用户选择的参数值列表的类。这个类应该实现<code>org.eclipse.core.commands.IParameterValues</code> 。如果未指定此类，则必须指定更详细的<code>values</code>元素。请参阅<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
<li><b>typeId</b> - 此<b>commandParameter的commandParameterType</b>的id。指定typeId允许命令的处理程序以一致的方式将字符串参数值转换为对象，并允许命令的潜在调用者查找为其参数获取各种类型的对象的命令。</li>
<li><b>可选</b> - 此参数是否可选。如果参数是可选的，则处理程序应该能够处理参数的缺失。默认情况下，所有参数都是可选的。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.commandParameterType">commandParameterType</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST commandParameterType</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">键入CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">转换器CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>定义commandParameter的对象类型，并可以指定<code>org.eclipse.core.commands.AbstractParameterValueConverter</code>子类，用于在字符串参数值和对象之间进行转换。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此commandParameterType的唯一标识符。</li>
<li><b>type</b> - 要用作此命令参数类型的Java类或接口的标准名称。此属性是可选的，但如果省略，则为<code>java.lang.Object</code>将用作参数类型。</li>
<li><b>converter</b> - 用于在命令参数值的对象和字符串表示形式之间进行转换的类。这个类应该扩展<code>org.eclipse.core.commands.AbstractParameterValueConverter</code> 。转换器应生成和使用<code>type</code>属性中指示的<code>type</code>对象。如果未指定此类，则此参数类型的字符串和对象值之间的转换将无法使用（类<code>ParameterType</code>上的<code>getValueConverter()</code>将返回<code>null</code> ）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.values">值</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST值</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p><code>commandParameter</code>上的<code>values</code>属性的详细版本。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 提供用户选择的参数值列表的类。这个类应该实现<code>org.eclipse.core.commands.IParameterValues</code> 。如果未指定此类，则必须指定更详细的<code>values</code>元素。请参阅<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>参数的可能值。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 要传递给<code>IExecutableExtension</code>的参数的名称。</li>
<li><b>value</b> - 要传递给<code>IExecutableExtension</code>的参数的值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.defaultHandler">defaultHandler</a> （ <a href="#e.parameter">参数</a> ）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST defaultHandler</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>此命令的默认处理程序。如果没有其他处理程序处于活动状态，则此处理程序将处此处理程序将与指定没有<code>activeWhen</code>条件的其他处理程序定义冲突。如果您没有创建<code>IExecutableExtension</code> ，则可以使用<code>defaultHandler</code>属性。
</p>
<p><em>自：3.1</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.core.commands.的类<code>org.eclipse.core.commands.IHandler</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.state">状态</a> （ <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST州</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>所有处理程序之间共享的状态信息，并且可能在会话之间持续存在。状态只是一个被加载以监视状态的类。有关更多详细信息，请参阅API信息。这不用于UI属性，如菜单贡献复选框状态或标签。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 可以加载以存储此命令状态的类。状态由处理程序共享，并且可以在会话之间保持不变。该类必须是<code>org.eclipse.core.commands.子类<code>org.eclipse.core.commands.State</code> 。请参阅API信息。</li>
<li><b>id</b> -<p>此状态的唯一标识符。这用于在会话之间保持状态（如果状态是<code>org.eclipse.jface.commands.的实例<code>org.eclipse.jface.commands.PersistentState</code> ）。某些常用标识符（请参阅<code>org.eclipse.jface.menus.在菜单或工具栏中呈现命令时，可以理解IMenuStateIds</code> ）。标识符在定义状态的命令中只需要是唯一的。
</p></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>可以加载以存储此命令状态的类。如果要将多个参数传递给<code>org.eclipse.core.runtime.则使用此元素<code>org.eclipse.core.runtime.IExecutableExtension</code> 。
</p>
<p><em>自：3.2</em></p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 可以加载以存储此命令状态的类。状态由处理程序共享，并且可以在会话之间保持不变。该类必须实现<code>org.eclipse.core.commands.State</code> 。请参阅API信息。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>keyConfiguration</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.keyConfiguration">keyConfiguration</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST keyConfiguration</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">parentId CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义键配置。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。请改用“org.eclipse.ui.bindings”扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>描述</b> - 用于在UI中显示的此键配置的可翻译简短描述。</li>
<li><i style="color:red">不推荐使用的</i> <b>ID</b> - 此密钥配置的唯一标识符。</li>
<li><i style="color:red">不推荐使用的</i> <b>名称</b> - 用于在UI中显示的此键配置的可翻译名称。如果此密钥配置具有父密钥，则无需在名称中添加“（extends ...）”。这将在必要时由UI自动添加。</li>
<li><i style="color:red">不推荐使用的</i> <b>父级</b> - 父级密钥配置的唯一ID。如果此密钥配置具有父密钥，则除了在其自己的密钥配置中定义的密钥绑定之外，它还将借用其父密钥的所有密钥绑定。@deprecated请改用parentId。</li>
<li><i style="color:red">不推荐使用的</i> <b>parentId</b> - 父键配置的唯一ID。如果此密钥配置具有父密钥，则除了在其自己的密钥配置中定义的密钥绑定之外，它还将借用其父密钥的所有密钥绑定。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>context</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.context">context</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST背景</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">parentId CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义上下文。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。请改用<a href="org_eclipse_ui_contexts.html">org.eclipse.ui.contexts</a>扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>描述</b> - 用于在UI中显示的此上下文的可翻译简短描述。</li>
<li><i style="color:red">不推荐使用的</i> <b>ID</b> - 此上下文的唯一标识符。</li>
<li><i style="color:red">不推荐使用的</i> <b>名称</b> - 用于在UI中显示的此上下文的可翻译名称。如果此上下文具有父级，则不必在名称中添加“（extends parent）”。这将在必要时由UI自动添加。</li>
<li><i style="color:red">不推荐使用的</i> <b>父级</b> - 父级上下文的唯一ID。如果此上下文具有父级，则除了在其自己的上下文中定义的键绑定之外，它还将从其父级借用所有键绑定。@deprecated请改用“parentId”。</li>
<li><i style="color:red">不推荐使用的</i> <b>parentId</b> - 父上下文的唯一ID。如果此上下文具有父级，则除了在其自己的上下文中定义的键绑定之外，它还将从其父级借用所有键绑定。</li>
</ul>
<br><div style="color:red;font-style:italic"><b>scope</b>元素已弃用</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.scope">范围</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST范围</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">父CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义范围。如果这些元素中的多个元素具有相同的<code>id</code>属性，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>描述</b> - 用于在UI中显示的此范围的可翻译简短描述。 @deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>ID</b> - 此范围的唯一标识符。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>名称</b> - 此范围的可翻译名称，用于在UI中显示。如果此范围具有父级，则无需在名称中添加“（extends parent）”。这将在必要时由UI自动添加。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
<li><i style="color:red">不推荐使用的</i> <b>父级</b> - 父级作用域的唯一ID。如果此作用域具有父作用域，则除了在其自己的作用域中定义的键绑定外，它还将从其父作业中借用所有键绑定。@deprecated请改用“org.eclipse.ui.contexts”扩展点。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>activeKeyConfiguration</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.activeKeyConfiguration">activeKeyConfiguration</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST activeKeyConfiguration</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">keyConfigurationId CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>此元素用于定义Eclipse的初始活动密钥配置。如果存在多个这些元素，则只有最后声明的元素（按读取插件注册表的顺序）才被视为有效。
</p>
<p>此元素已替换为首选项。如果您的应用程序需要更改默认密钥配置，请在<code>plugin_customization.ini</code>文件中指定以下内容： <code>org.eclipse.ui/KEY_CONFIGURATION_ID=your.default.key.configuration.id</code> 。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>值</b> - 希望最初激活的keyConfiguration元素的唯一ID（ <code>id</code>属性）。</li>
<li><i style="color:red">不</i> <b>推荐</b> <i style="color:red">使用的</i> <b>keyConfigurationId</b> - 希望最初处于活动状态的keyConfiguration元素的唯一ID（ <code>id</code>属性）。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>keyBinding</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT键<a name="e.keyBinding">绑定</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST键绑定</p>
<p class="code SchemaDtdAttlist">配置CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">命令CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">locale CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">平台CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">contextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">string CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">范围CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">keyConfigurationId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">commandId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">keySequence CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素允许用户为命令分配键序列。请改用“org.eclipse.ui.bindings”扩展点中的<code>key</code>元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><i style="color:red">不推荐使用的</i> <b>配置</b> - 此键绑定的密钥配置的唯一ID。@deprecated请改用keyConfigurationId。</li>
<li><i style="color:red">不推荐使用的</i> <b>命令</b> - 分配了此键绑定指定的键序列的命令的唯一标识符。如果此属性的值为空字符串，则将键序列分配给内部“无操作”命令。这对于可能从父母那里借用的特定密钥配置和上下文中的“取消定义”键绑定非常有用。@deprecated请改用“commandId”。</li>
<li><i style="color:red">不推荐使用的</i> <b>语言环境</b> - 一个可选属性，指示仅为指定的语言环境定义此键绑定。根据<code>java.util.声明的格式指定语言环境<code>java.util.Locale</code> 。</li>
<li><i style="color:red">不推荐使用的</i> <b>平台</b> - 一个可选属性，指示仅为指定平台定义此键绑定。<code>platform</code>属性的可能值是<code>org.eclipse.swt.返回的可能值的集合<code>org.eclipse.swt.SWT.getPlatform()</code> 。</li>
<li><i style="color:red">不推荐使用的</i> <b>contextId</b> - 此键绑定的上下文的唯一ID。</li>
<li><i style="color:red">不推荐使用的</i> <b>字符串</b> - 分配给命令的键序列。键序列由一个或多个键击组成，其中键击由键盘上的键组成，可选择与以下一个或多个修饰符组合使用：Ctrl，Alt，Shift和Command。键击由空格分隔，修饰符用“+”字符分隔。@deprecated请改用“keySequence”。</li>
<li><i style="color:red">不推荐使用的</i> <b>范围</b> - 此键绑定的上下文的唯一ID。@deprecated请改用“contextId”。旧的默认范围“org.eclipse.ui.globalScope”已更改为“org.eclipse.ui.contexts.window”。旧名称仍受支持，但已弃用。</li>
<li><i style="color:red">不</i> <b>推荐</b> <i style="color:red">使用</i> <b>keyConfigurationId</b> - 此键绑定的键配置的唯一ID。@deprecated请在新的“org.eclipse.ui.bindings”扩展点的<code>key</code>元素上使用<code>schemeId</code>属性。</li>
<li><i style="color:red">不</i> <b>推荐</b> <i style="color:red">使用的</i> <b>commandId</b> - 分配了此键绑定指定的键序列的命令的唯一标识符。如果此属性的值为空字符串，则将键序列分配给内部“无操作”命令。这对于可能从父母那里借用的特定密钥配置和上下文中的“取消定义”键绑定非常有用。</li>
<li><i style="color:red">不</i> <b>推荐的keySequence</b> -<p>分配给命令的键序列。键序列由一个或多个键击组成，其中键击由键盘上的键组成，可选择与以下一个或多个修饰符组合使用：Ctrl，Alt，Shift和Command。键击由空格分隔，修饰符用“+”字符分隔。</p>
<p>修饰键也可以以与平台无关的方式表达。例如，在MacOS X上，几乎总是使用“Command”代替“Ctrl”。因此，我们提供“M1”，它将根据需要映射到“Ctrl”或“Command”。同样，“M2”是“Shift”; “M3”是“Alt”;并且“M4”是“Ctrl”（MacOS X）。如果添加了更多平台，那么您可以依赖这些别名映射到良好的平台默认值。</p>
<p>此字符串的语法在<code>org.eclipse.ui.internal.keys</code>定义。简而言之，字符串不区分大小写 - 尽管所有大写字母在风格上都是首选。如果密钥是一个字母，那么只需附加该字母即可。如果密钥是特殊密钥（即非ASCII），则使用以下之一：ARROW_DOWN，ARROW_LEFT，ARROW_RIGHT，ARROW_UP，BREAK，CAPS_LOCK，END，F1，F2，F3，F4，F5，F6，F7， F8，F9，F10，F11，F12，F13，F14，F15，HOME，INSERT，NUM_LOCK，NUMPAD_0，NUMPAD_1，NUMPAD_2，NUMPAD_3，NUMPAD_4，NUMPAD_5，NUMPAD_6，NUMPAD_7，NUMPAD_8，NUMPAD_9，NUMPAD_ADD，NUMPAD_DECIMAL，NUMPAD_DIVIDE，NUMPAD_ENTER， NUMPAD_EQUAL，NUMPAD_MULTIPLY，NUMPAD_SUBTRACT，PAGE_UP，PAGE_DOWN，PAUSE，PRINT_SCREEN或SCROLL_LOCK。如果密钥是不可打印的ASCII密钥，则使用以下之一：BS，CR，DEL，ESC，FF，LF，NUL，SPACE，TAB或VT。请注意，主键盘输入/返回键是CR。</p></li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p><code>org.eclipse.ui</code>插件中的<code>plugin.xml</code>文件广泛使用了<code>org.eclipse.ui.commands</code>扩展点。
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>可以使用<code>org.eclipse.ui.handlers.在命令中注册处理程序<code>org.eclipse.ui.handlers.IHandlerService</code> 。这可以通过调用<code>getService(IHandlerService.class)</code>从各种工作台组件（例如，工作台，工作台窗口，零件站点等）中<code>getService(IHandlerService.class)</code> 。
</p>
<p>通常，最好静态地声明所有命令（在<code>plugin.xml</code> ）。这样用户可以将键绑定附加到命令。但是，可以在运行时声明命令。为此，请检索<code>org.eclipse.ui.commands.来自工作台组件的ICommandService</code> ，调用<code>getCommand(yourCommandID)</code>然后调用<code>Command.define(...)</code> 。如果已卸载，则必须通过编程方式清除以编程方式定义的命令。
</p>
<p>有一些处理程序状态的默认实现可能对此扩展点的用户有用：</p>
<ul>
<li>org.eclipse.jface.commands。TextState</li>
<li>org.eclipse.jface.commands。RadioState</li>
<li>org.eclipse.jface.commands。ToggleState</li>
<li>org.eclipse.ui.handlers。RegistryRadioState</li>
<li>org.eclipse.ui.handlers。RegistryToggleState</li>
</ul>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2018 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3838.202_xtend_classes_members.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>课程和成员</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="xtend-classes-members">课程和成员</h1>

<p>乍一看，Xtend文件几乎看起来像一个Java文件。它以包声明开头，后跟导入部分和类定义。实际上，这些类直接转换为相应Java包中的Java类。一个类可以有构造函数，字段，方法和注释。</p>

<p>这是一个示例Xtend文件：</p>

<pre><code class="language-xtend">package com.acme import java.util。列表类MyClass {String name new（String name）{this.name = name} def String first（List &lt;String&gt; elements）{elements.get（0）}}</code></pre>

<h2 id="package-decl">包装声明</h2>

<p>包声明看起来像Java中的声明。两个小的，可选的差异：</p>

<ul>
  <li>如果标识符与关键字冲突，则可以使用<code>^</code>字符对其进行转义。</li>
  <li>终止分号是可选的。</li>
</ul>

<pre><code class="language-xtend">包com.acme</code></pre>

<h2 id="imports">进口</h2>

<p>类型名称的普通导入等同于Java中已知的导入。再一次，可以使用<code>^</code>来转义与关键字冲突的任何名称。与Java相反，终止分号是可选的。不推荐使用非静态通配符类型导入，以获得更好的可用性和良好定义的依赖性。</p>

<p>Xtend还具有用于导入静态字段和方法的静态导入。语义和语法就像在Java中一样。</p>

<p>与Java一样， <code>java.lang</code>包中的所有类都是隐式导入的。</p>

<pre><code class="language-xtend">import java.math。BigDecimal导入静态java.util。Collections.sort导入静态org.junit。断言。*</code></pre>

<p>静态方法也可以作为<code>extension</code> s导入。有关详细信息，请参阅<a href="202_xtend_classes_members.html#extension-methods">扩展方法</a>部分。</p>

<h2 id="xtend-class-declaration">班级宣言</h2>

<p>类声明重用了许多Java的语法，但在某些方面仍然有点不同：默认情况下，所有Xtend类型都是<code>public</code> ，因为这是常见的情况。Java的“包私有”默认可见性由Xtend中更明确的关键字<code>package</code>声明。与Java相比，Xtend支持每个文件的多个公共顶级类声明。每个Xtend类都编译为一个单独的顶级Java类。</p>

<p>抽象类是使用Java中的<code>abstract</code>修饰符定义的。另请参见<a href="202_xtend_classes_members.html#abstract-methods">抽象方法</a> 。</p>

<p>Xtend的继承方法在概念上与Java相同。支持单继承类以及实现多个接口。Xtend类可以扩展其他Xtend类，甚至Java类也可以从Xtend类继承。如果未指定超类型，则使用<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a> 。</p>

<p>最简单的类看起来像这样：</p>

<pre><code class="language-xtend">class MyClass {}</code></pre>

<p>Xtend中更高级的泛型类声明：</p>

<pre><code class="language-xtend">class ArrayList &lt;E&gt; extends AbstractList &lt;E&gt;实现List &lt;E&gt;，RandomAccess，Cloneable，java.io。可序列化{...}</code></pre>

<h2 id="constructors">构造函数</h2>

<p>Xtend类可以定义任意数量的构造函数。与Java不同，您不必一遍又一遍地重复该类的名称，而是使用关键字<code>new</code>来声明构造函数。构造函数也可以在第一行中使用<code>this(args...)</code>委托给其他构造函数。</p>

<pre><code class="language-xtend">class MyClass扩展AnotherClass {new（String s）{super（s）} new（）{this（“default”）}}</code></pre>

<p>关于继承的相同规则适用于Java，即如果超类没有定义无参数构造函数，则必须使用<code>super(args...)</code>显式调用一个作为构造函数体中的第一个表达式。</p>

<p>构造函数的默认可见性是<code>public</code>但您也可以指定显式可见性<code>public</code> ， <code>protected</code> ， <code>package</code>或<code>private</code> 。</p>

<h2 id="fields">字段</h2>

<p>字段可以有初始化程序。最终字段使用<code>val</code>声明，而<code>var</code>引入非final字段，可以省略。然而，如果存在初始化表达式，如果使用<code>val</code>或<code>var</code>来引入该字段，则可以推断字段的类型。关键字<code>final</code>是<code>val</code>同义词。标记为<code>static</code>字段将编译为静态Java字段。</p>

<pre><code class="language-xtend">class MyClass {int count = 1 static boolean debug = false var name ='Foo'// type String is isferred val UNIVERSAL_ANSWER = 42 //带有推断类型的最终字段int ...}</code></pre>

<p>字段的默认可见性是<code>private</code> 。您还可以将其明确声明为<code>public</code> ， <code>protected</code> ， <code>package</code>或<code>private</code> 。</p>

<p>Xtend的一个特色是提供<em>扩展方法的</em>字段，这些<em>方法</em>在<a href="202_xtend_classes_members.html#extension-methods">自己的章节中介绍</a> 。</p>

<h2 id="methods">方法</h2>

<p>Xtend方法在类中声明，并转换为具有完全相同签名的相应Java方法。唯一的例外是调度方法， <a href="202_xtend_classes_members.html#polymorphic-dispatch">稍后将</a>对此进行说明。</p>

<pre><code class="language-xtend">def String first（List &lt;String&gt; elements）{elements.get（0）}</code></pre>

<p>方法声明以关键字<code>def</code>开头。方法的默认可见性是<code>public</code> 。您可以明确声明它是<code>public</code> ， <code>protected</code> ， <code>package</code>或<code>private</code> 。</p>

<p>Xtend支持方法的<code>static</code>修饰符，如果未明确给出，则可以<a href="202_xtend_classes_members.html#inferred-return-types">推断</a>返回类型：</p>

<pre><code class="language-xtend">def static createInstance（）{new MyClass（'foo'）}</code></pre>

<p>与在Java中一样，vararg参数是允许的，并且可以作为方法体中的数组值访问：</p>

<pre><code class="language-xtend">def printAll（String ... strings）{strings.forEach [s | println（s）]}</code></pre>

<p>可以从其主体推断出方法的返回类型。递归方法和抽象方法必须声明显式返回类型。</p>

<h3 id="abstract-methods">抽象方法</h3>

<p>Xtend中的抽象方法不定义主体，必须在<code>abstract</code>类或接口中声明。同时指定返回类型是必需的，因为无法推断。</p>

<pre><code class="language-xtend">抽象类MyAbstractClass（）{def String abstractMethod（）//没有body}</code></pre>

<h3 id="overriding-methods">最重要的方法</h3>

<p>方法可以使用关键字<code>override</code>超类中的其他方法或实现接口方法。如果方法覆盖超类型的方法，则<code>override</code>关键字是必需的，并替换关键字<code>def</code> 。覆盖语义与Java中的相同，例如，不可能覆盖<code>final</code>方法或不可见方法。重写方法从超级声明继承它们的返回类型。</p>

<p>例：</p>

<pre><code class="language-xtend">override String second（List &lt;String&gt; elements）{elements.get（1）}</code></pre>

<h3 id="declared-exceptions">声明例外</h3>

<p>Xtend不会强制您捕获或声明已检查的异常。尽管如此，您仍然可以使用<code>throws</code>子句声明在方法体中<code>throws</code>就像在Java中一样。</p>

<p>如果您没有在方法中声明已检查的异常，但它们可能会在您的代码中抛出，则编译器将以静默方式抛出已检查的异常（使用<a href="http://projectlombok.org/features/SneakyThrows.html">Lombok</a>引入的偷偷摸摸技术）。</p>

<pre><code class="language-xtend">/ * *抛出异常* / def void throwException（）抛出Exception {throw new Exception} / * *抛出异常而不声明它* / def void sneakyThrowException（）{throw new Exception}</code></pre>

<p>也支持对checked异常的可选验证，并且可以在相应的Eclipse首选项页面上为Xtend错误和警告配置。</p>

<h3 id="inferred-return-types">推断的返回类型</h3>

<p>如果方法的返回类型可以从其主体推断出来，则不必声明它。</p>

<p>这就是方法</p>

<pre><code class="language-xtend">def String second（List &lt;String&gt; elements）{elements.get（1）}</code></pre>

<p>可以像这样声明：</p>

<pre><code class="language-xtend">def second（List &lt;String&gt;元素）{elements.get（1）}</code></pre>

<p>返回类型对于抽象方法声明以及递归实现是必需的。</p>

<h3 id="generic-methods">通用方法</h3>

<p>您可以在方法上指定类型参数。上一节中方法的参数化变体可能如下所示：</p>

<pre><code class="language-xtend">def &lt;T&gt; second（List &lt;T&gt;元素）{elements.get（1）}</code></pre>

<p>支持类型参数边界和约束，并共享与<a href="http://docs.oracle.com/javase/specs/jls/se6/html/classes.html#8.4.4">Java语言规范中</a>定义的语法和语义相同的语法和语义。</p>

<h3 id="operator-declaration">运营商声明</h3>

<p>Xtend支持基于运算符名称映射的运算符重载，如运算符一<a href="203_xtend_expressions.html#operators">节</a>中所述。要声明一个运算符，可以使用运算符的名称声明一个简单的方法，也可以直接使用运算符，如下所示：</p>

<pre><code class="language-xtend">class Money {def +（Money other）{...} def  - （钱其他）{...} def *（BigDecimal times）{...} ...}</code></pre>

<h3 id="polymorphic-dispatch">派遣方法</h3>

<p>通常，方法解析和绑定在编译时静态完成，如在Java中。方法调用基于静态类型的参数进行绑定。有时这不是你想要的。特别是在<a href="202_xtend_classes_members.html#extension-methods">扩展方法</a>的上下文中，您希望具有多态行为。</p>

<p>使用关键字<code>dispatch</code>声明调度方法。</p>

<pre><code class="language-xtend">def dispatch printType（Number x）{“它是一个数字”} def dispatch printType（整数x）{“它是一个int”}</code></pre>

<p>对于当前类型层次结构中具有相同名称和相同数量的参数的一组可见分派方法，编译器会推断出合成调度程序方法。此调度程序使用所有已声明参数的公共超类型。实际调度案例的方法名称前缀为下划线，如果已将这些方法定义为公共方法，则这些方法的可见性将降低为受保护。客户端代码始终绑定到合成的调度程序方法。</p>

<p>对于上面示例中的两个调度方法，将生成以下Java代码：</p>

<pre><code class="language-java">protected String _printType（final Number x）{return“it \'sa number”; } protected String _printType（final Integer x）{return“它是一个int”; public String printType（final Number x）{if（x instanceof Integer）{return _printType（（Integer）x）;如果（x！）= null）{return _printType（x）; } else {throw new IllegalArgumentException（“Unhandled parameter types：”+ Arrays。&lt;Object&gt; asList（x）.toString（））; }}</code></pre>

<p>请注意，对级联的<code>instanceof</code>进行排序，以便首先处理更具体的类型。</p>

<p>调度案例的默认可见性<code>protected</code> 。如果所有调度方法都明确声明了相同的可见性，那么这也将是推断的调度程序的可见性。否则它是<code>public</code> 。参数类型的比较从左到右进行。在以下示例中，第二个方法声明被认为更具体，因为它的第一个参数类型是最具体的：</p>

<pre><code class="language-xtend">def dispatch printTypes（Number x，Integer y）{“它是一些数字和一个int”} def dispatch printTypes（Integer x，Number y）{“它是一个int和一个数字”}</code></pre>

<p>生成以下Java代码：</p>

<pre><code class="language-java">public String printTypes（final Number x，final Number y）{if（x instanceof Integer &amp;&amp; y！= null）{return _printTypes（（Integer）x，y）;如果（x！）= null &amp;&amp; y instanceof Integer）{return _printTypes（x，（Integer）y）; } else {throw new IllegalArgumentException（“Unhandled parameter types：”+ Arrays。&lt;Object&gt; asList（x，y）.toString（））; }}</code></pre>

<p>代码的编译方式是<code>null</code>引用永远不匹配。 <code>null</code>值可以由使用参数类型<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html">Void的</a>派遣案例处理。</p>

<pre><code class="language-xtend">def dispatch printType（Number x）{“它是一些数字”} def dispatch printType（整数x）{“它是一个int”} def dispatch printType（Void x）{“它是null”}</code></pre>

<p>这将编译为以下Java代码：</p>

<pre><code class="language-java">public String printType（final Number x）{if（x instanceof Integer）{return _printType（（Integer）x）;如果（x！）= null）{return _printType（x）; } else if（x == null）{return _printType（（Void）null）; } else {throw new IllegalArgumentException（“Unhandled parameter types：”+ Arrays。&lt;Object&gt; asList（x）.toString（））; }}</code></pre>

<h4 id="dispatch-methods-and-inheritance">派遣方法和继承</h4>

<p>所有符合调度方法的编译表示的超类型的可见Java方法也包含在调度程序中。符合意味着它们具有预期数量的参数，并且具有与前置下划线相同的编译名称。</p>

<p>例如，请考虑以下Java类：</p>

<pre><code class="language-java">public abstract class AbstractLabelProvider {protected String _label（Object o）{// some generic implementation}}</code></pre>

<p>以及扩展Java类的以下Xtend类：</p>

<pre><code class="language-xtend">class MyLabelProvider扩展AbstractLabelProvider {def dispatch label（Entity it）{name} def dispatch label（Method it）{name +“（”+ params.join（“，”）+“）：”+ type} def dispatch label（Field it ）{name + type}}</code></pre>

<p>生成的Java类<code>MyLabelProvider</code>生成的调度方法将如下所示：</p>

<pre><code class="language-java">public String label（final Object it）{if（it instanceof Entity）{return _label（（Entity）it）; } else if（it instanceof Field）{return _label（（Field）it）; } else if（it instanceof Method）{return _label（（Method）it）;如果（它！）= null）{return super._label（it）; } else {throw new IllegalArgumentException（“Unhandled parameter types：”+ Arrays。&lt;Object&gt; asList（it）.toString（））; }}</code></pre>

<h4 id="static-dispatch-methods">静态调度方法</h4>

<p>还支持静态调度方法。禁止混合静态和非静态调度方法。</p>

<h3 id="create-methods">创建方法</h3>

<p>在Xtend中创建方法允许在一次通过中进行图形转换，通常需要两次通过。这意味着您不需要在典型的两个阶段中将转换从一个图形分离到另一个图形：树构造和树节点的链接。你基本上只需要使用create方法编写整个转换，内置的身份保存将负责其余部分。</p>

<p>考虑您要将以下人员列表的副本创建为：</p>

<pre><code>Fred Flintstone {已婚与Willma Flintstone的朋友与Barny Rubble} Willma Flintstone {已婚与Fred Flintstone} Barny Rubble {朋友与Fred Flintstone}</code></pre>

<p>像下面这样的函数可以做到这一点：</p>

<pre><code class="language-xtend">def List &lt;Person&gt; copyPersons（List &lt;Person&gt; persons）{persons.map [copy]} def copy（Person p）{val result = new Person（）result.name = p.name //以下是错误的结果在堆栈溢出result.friendWith = p.friendWith.map [copy] result.marriedWith = p.marriedWith.map [copy]}</code></pre>

<p>该代码的问题在于我们不跟踪创建的副本的来源。这是模型转换的主要问题。经典的解决方案是两次运行复制。首先，我们创建所有实例，然后我们建立链接。虽然它有效，但它会产生混乱和非连贯的代码。Xtend的创建函数通过跟踪每个创建的实例的来源引入身份保持来处理这个问题。因此，create函数需要两个表达式。一个用于实例化实际对象，另一个用于初始化它。</p>

<pre><code class="language-xtend">def create result：new Person copy（Person p）{result.name = p.name // now now works result.friendWith = p.friendWith.map [copy] result.marriedWith = p.marriedWith.map [copy]}</code></pre>

<p>如果未指定结果变量的名称，则假定它是隐式接收器变量<code>it</code> ，可以在主体内的功能调用中跳过该变量。此外，您可以定义create函数的返回类型：</p>

<pre><code class="language-xtend">def Person创建新的PersonImpl（）副本（Person p）{/ * it。* / name = p.name friendWith = p.friendWith.map [copy] marriedWith = p.marriedWith.map [copy]}</code></pre>

<h4 id="how-it-works">这个怎么运作</h4>

<p>除了关键字<code>create</code> one之外，还指定了两个表达式。第一个表达式是创建实例的工厂，而第二个表达式将进一步初始化它。在调用工厂表达式之前，执行高速缓存查找以查找先前为相同参数创建的实例。如果没有此类实例，则计算工厂表达式，并将结果存储在缓存中。随后评估主表达式（也称为初始化表达式）。仅当缓存中没有先前创建的实例时才会发生这种情况。如果该表达式依次使用相同的参数集传递地调用create函数，则返回先前实例化的和缓存的对象。请注意，该对象当前可能已初始化。也就是说，其内部状态可能尚未可用。缓存的生命周期附加到声明Xtend类的实例。也就是说，您可以通过Guice控制缓存的生存时间。</p>

<hr>

<h2 id="annotations">注释</h2>

<p>可以在类，字段，方法和参数上使用注释。它们以<code>@</code>字符为前缀，并接受许多键值对或名为<code>value</code>的注释属性的默认<code>value</code> 。期望数组的注释值也可以处理单个值。值数组包含在数组文字<code>#['first', 'second']</code> 。注释的语义与<a href="http://docs.oracle.com/javase/specs/jls/se6/html/interfaces.html#9.7">Java语言规范</a>中的定义完全相同。这是一个例子：</p>

<pre><code class="language-xtend">@TypeAnnotation（“some value”）类MyClass {@FieldAnnotation（value = @NestedAnnotation（true））static val CONSTANT ='a compile-time constant'@MethodAnnotation（constant = CONSTANT）def String myMethod（@ParameterAnnotation String param）{ // ...}}</code></pre>

<p>此外， <a href="204_activeannotations.html">Active Annotations</a>允许用户参与将Xtend代码编译为Java源代码。</p>

<h2 id="extension-methods">扩展方法</h2>

<p>扩展方法允许向现有类型添加新方法而无需修改它们。这个功能实际上是Xtend得名的地方。它们基于一个简单的语法技巧：不是在方法调用的括号内传递扩展方法的第一个参数，而是可以使用第一个参数作为接收器调用该方法 - 可以调用该方法，就好像方法是一个参数类型的成员。</p>

<pre><code class="language-xtend">“hello”.toFirstUpper（）//调用StringExtensions.toFirstUpper（“hello”）</code></pre>

<p>扩展语法中的方法调用通常会产生更易读的代码，因为它们是链接的而不是嵌套的。扩展的另一个好处是您可以添加特定于应用程序的特定上下文或层的方法。</p>

<p>例如，您可能不希望将特定于UI的方法和依赖项放入域模型类中。因此，此功能通常在实用程序类或服务层中的静态方法或方法中定义。这是有效的，但是如果你调用这样的方法，代码的可读性会降低，面向对象也会减少。在Java中，您经常会看到如下代码：</p>

<pre><code class="language-java">persistenceManager.save（myObject的）;</code></pre>

<p>如果不将实体绑定到persistenceManager，扩展方法允许您编写</p>

<pre><code class="language-xtend">myObject.save</code></pre>

<p>有多种方法可以使方法可用作扩展，这将在以下各节中介绍。</p>

<h3 id="library-extensions">图书馆的扩展</h3>

<p>Xtend库为Java SDK中的现有类型提供了许多非常有用的扩展方法，而不再赘述。</p>

<pre><code class="language-xtend">“hello”.toFirstUpper //调用StringExtensions.toFirstUpper（String）listOfStrings.map [toUpperCase] //调用ListExtensions。&lt;T，R&gt; map（List &lt;T&gt; list，Function &lt;？超级T，？扩展R&gt; mapFunction）</code></pre>

<p>查看JavaDoc以了解可用功能：</p>

<ul>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ObjectExtensions.java">ObjectExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IterableExtensions.java">IterableExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/MapExtensions.java">MapExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/ListExtensions.java">ListExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/CollectionExtensions.java">CollectionExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/BooleanExtensions.java">BooleanExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/IntegerExtensions.java">IntegerExtensions</a></li>
  <li><a href="https://github.com/eclipse/xtext-lib/blob/master/org.eclipse.xtext.xbase.lib/src/org/eclipse/xtext/xbase/lib/FunctionExtensions.java">FunctionExtensions</a></li>
</ul>

<h3 id="local-extension-methods">本地扩展方法</h3>

<p>当前类及其超类型的所有可见非静态方法都可自动作为扩展名使用。例如</p>

<pre><code class="language-xtend">class MyClass {def doSomething（Object obj）{//用obj做一些事情} def extensionCall（Object obj）{obj.doSomething（）//调用this.doSomething（obj）}}</code></pre>

<p>必须像任何其他静态方法一样通过导入使本地静态方法可用。</p>

<h3 id="extension-imports">扩展进口</h3>

<p>在Java中，您通常会编写一个带有静态方法的辅助类来装饰具有其他行为的现有类。为了集成这样的静态帮助程序类，Xtend允许将关键字<code>extension</code>放在<a href="202_xtend_classes_members.html#imports">静态导入</a>的<code>static</code>关键字之后，从而使所有导入的静态函数可用作扩展方法。</p>

<p>以下导入声明</p>

<pre><code class="language-xtend">import static extension java.util。Collections.singletonList</code></pre>

<p>允许我们使用像这样的singletonList方法：</p>

<pre><code class="language-xtend">new MyClass（）。singletonList（）//调用Collections.singletonList（new MyClass（））</code></pre>

<h3 id="extension-provider">扩展提供商</h3>

<p>通过将<code>extension</code>关键字添加到字段，局部变量或参数声明中，其实例方法将成为扩展方法。</p>

<p>想象一下，您希望在类<code>Person</code>上拥有一些特定于图层的功能。让我们假设您处于类似servlet的类中，并希望使用一些持久性机制来持久化<code>Person</code> 。让我们假设<code>Person</code>实现了一个公共接口<code>Entity</code> 。您可以拥有以下界面</p>

<pre><code class="language-java">interface EntityPersistence {public save（Entity e）;公开更新（实体e）;公共删除（实体e）; }</code></pre>

<p>如果你已经获得了这种类型的实例（通过工厂或依赖注入，或者是什么），就像这样：</p>

<pre><code class="language-xtend">class MyServlet {extension EntityPersistence ep = Factory.get（EntityPersistence）...}</code></pre>

<p>您可以保存，更新和删除任何类似的实体：</p>

<pre><code class="language-xtend">val人员= ...person.save //调用ep.save（person）person.name ='Horst'person.update //调用ep.update（person）person.delete //调用ep.delete（person）</code></pre>

<p>在值上使用<code>extension</code>修饰符与静态<a href="202_xtend_classes_members.html#extension-imports">扩展导入</a>相比具有明显的优势：您的代码不受扩展方法的实际实现的约束。您可以通过提供不同的实例，简单地将提供引用扩展的组件与来自外部的另一个实现交换。</p>

<h2 id="interfaces">接口声明</h2>

<p>接口声明与Java中的接口声明非常相似。接口可以声明字段，默认情况下是最终静态，因此必须具有初始值。当然可以声明方法，默认情况下公开。接口可以扩展任意数量的其他接口，并可以声明类型参数。这是一个例子：</p>

<pre><code class="language-xtend">interface MyInterface &lt;T&gt; extends OtherInterface {val CONSTANT = 42 def T doStuff（String ... varArg）throws SomeException}</code></pre>

<p>从Java语言的第8版开始，允许接口包含非抽象实例方法，称为<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">默认方法</a> ，以及静态方法。Xtend也支持这一点（自2.8起）：如果选择Java 8作为目标语言版本，则允许接口使用如下例中的实体声明方法。</p>

<pre><code class="language-xtend">interface MyInterface {def doStuff（）{'这是一个返回字符串的实例方法。'} static def doGlobalStuff（）{'这是一个返回字符串的静态方法。'}}</code></pre>

<p>非抽象实例方法的行为等同于Java默认方法的行为。由于接口可以扩展多个其他接口，因此在继承方法的不同实现时可能会发生多继承冲突：</p>

<pre><code class="language-xtend">接口A {def execute（）{return 1}}接口B {def execute（）{return 2}}接口C扩展A，B {}类D实现A，B {}</code></pre>

<p>由于方法<code>execute()</code>的多重继承，接口<code>C</code>和类<code>D</code>都标记有错误。有四种方法可以解决问题。</p>

<ul>
  <li>
    <p>将该方法重新声明为抽象（不允许非抽象类）：</p>

    <pre><code class="language-xtend">覆盖执行（）</code></pre>
  </li>
  <li>
    <p>覆盖实现：</p>

    <pre><code class="language-xtend">覆盖execute（）{return 3}</code></pre>
  </li>
  <li>
    <p>请参阅超类型实现：</p>

    <pre><code class="language-xtend">覆盖execute（）{A.super.execute（）}</code></pre>
  </li>
  <li>
    <p>首先避免继承多个方法实现。这是推荐的方法。</p>
  </li>
</ul>

<h2 id="annotation-type-declaration">注释类型声明</h2>

<p>也可以声明注释类型。由关键字<code>annotation</code>引入，并使用简明的语法声明它们的值：</p>

<pre><code class="language-xtend">注释MyAnnotation {String [] value boolean isTricky = false int [] lotteryNumbers =＃[42,137]}</code></pre>

<h2 id="enum-type-declaration">枚举类型声明</h2>

<p>枚举类型声明如下：</p>

<pre><code class="language-xtend">枚举MyColor {GREEN，BLUE，RED}</code></pre>

<h2 id="nested-type-declarations">嵌套类型声明</h2>

<p>可以嵌套类，枚举，注释和接口声明。就像在Java嵌套枚举中一样，注释和接口始终是静态的。在Xtend中，嵌套类也始终是静态的。嵌套类型默认是公共的，只能嵌套在类，接口或注释声明中。</p>

<pre><code class="language-xtend">class MyClass {static class NestedClass {} annotation NestedAnnotation {} enum NestedEnum {} interface NestedInterface {}} interface MyInterface {static class NestedClass {} annotation NestedAnnotation {} enum NestedEnum {} interface NestedInterface {}} annotation MyAnnotation {static class NestedClass {}注释NestedAnnotation {}枚举NestedEnum {}接口NestedInterface {}}</code></pre>

<hr>

<p><strong><a href="203_xtend_expressions.html">下一章：表达式</a></strong></p>


</body>
</html><html id="0008.migration.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8"></meta>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content=""></meta>
    <meta name="author" content="Stéphane Bégaudeau"></meta>    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet"></link>
    <link href="../../assets/css/docs.css" rel="stylesheet"></link>
    
    <title>Acceleo</title>
  </head>
  <body dir="ltr">
    <div class="container">
      <section id="introduction">
        <div class="page-header">
          <h1><small>从Acceleo 2.x</small>迁移<small>到Acceleo 3.x.</small></h1>
        </div>
        <p>本文档列出了Acceleo 2和Acceleo 3表达式之间的等价性。
        </p>
      </section>
      
      <section id="miscellaneous">
        <div class="page-header">
          <h1>杂</h1>
        </div>
        
        <p>杂项表达的平等指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td>&lt;％metamodel http://www.eclipse.org/uml2/2.0.0/UML%&gt;</td>
              <td>[module module_name（'http://www.eclipse.org/uml2/2.0.0/UML'）/]</td>
            </tr>
            <tr>
              <td>&lt;％import module.mt％&gt;</td>
              <td>[导入模块/]</td>
            </tr>
            <tr>
              <td>&lt;％import service.java％&gt;</td>
              <td>不再需要导入服务</td>
            </tr>
            <tr>
              <td>&lt;％list + object％&gt;</td>
              <td>[列表 - &gt;包括（对象）/]</td>
            </tr>
            <tr>
              <td>&lt;％object + list％&gt;</td>
              <td>[对象 - &gt;联合（列表）/]</td>
            </tr>
            <tr>
              <td>&lt;％list1 + list2％&gt;</td>
              <td>[list1-&gt;联盟（列表2）/]</td>
            </tr>
            <tr>
              <td>&lt;％string + object％&gt;</td>
              <td>[string + object /]</td>
            </tr>
            <tr>
              <td>&lt;％list  -  object％&gt;</td>
              <td>[列表 - &gt;不包括（对象）/]</td>
            </tr>
            <tr>
              <td>&lt;％list1  -  list2％&gt;</td>
              <td>[list1-&gt; asSet（） -  list2-&gt; asSet（）/]（注意，这不再保留重复项，这并不等同于Acceleo 2）</td>
            </tr>
            <tr>
              <td>&lt;％list1 ||列表2％&gt;</td>
              <td>[list1-&gt;联盟（列表2）/]</td>
            </tr>
            <tr>
              <td>&lt;％list &amp;&amp; object％&gt;</td>
              <td>[list-&gt; select（element | element = object）/]</td>
            </tr>
            <tr>
              <td>&lt;％list1 &amp;&amp; list2％&gt;</td>
              <td>[list1-&gt; iterate（element; result：Sequence（T）= Sequence {} | if list2-&gt; includes（element）then result-&gt; including（element）else result endif）/]</td>
            </tr>
            <tr>
              <td>&lt;％list1 == list2％&gt;</td>
              <td>[list1 = list2 /]</td>
            </tr>
            <tr>
              <td>&lt;％list1！= list2％&gt;</td>
              <td>[list1 &lt;&gt; list2 /]</td>
            </tr>
            <tr>
              <td>&lt;％object！= object％&gt;</td>
              <td>[object &lt;&gt; object /]</td>
            </tr>
            <tr>
              <td>&lt;％！布尔％&gt;</td>
              <td>[不是布尔/]</td>
            </tr>
          </tbody>
        </table>
      </section>
      
      <section id="eobject">
        <div class="page-header">
          <h1>EObject服务</h1>
        </div>
        
        <p>EObject服务的Equilavence指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％x.eAllContents％&gt;</td>
            <td>[x.eAllContents（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eAllContents（ “的EClass”）％&gt;</td>
            <td>[x.eAllContents（的EClass）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eClass％&gt;</td>
            <td>[x.eClass（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eContainer％&gt;</td>
            <td>[x.eContainer（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eContainer（ “EPackage”）％&gt;</td>
            <td>[x.eContainer（EPackage）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eContainingFeature％&gt;</td>
            <td>[x.eContainingFeature（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eContainmentFeature％&gt;</td>
            <td>[x.eContainmnentFeature（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eContents％&gt;</td>
            <td>[x.eContents（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eCrossReferences％&gt;</td>
            <td>[x.eCrossReferences（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eResource％&gt;</td>
            <td>[x.eResource（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.eResourceName％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％x.getRootContainer％&gt;</td>
            <td>[x.ancestors（） - &gt;最后（）/]</td>
          </tr>
          <tr>
            <td>&lt;％负载（ “// UML2_LIBRARIES / UML2PrimitiveTypes.library.uml2”）％&gt;</td>
            <td>没有直接等价物：Acceleo 3接受多个模型元素作为一代的参数。另一种方法是使用自定义Java服务来满足这种需求。</td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="request">
        <div class="page-header">
          <h1>请求服务</h1>
        </div>
        
        <p>请求服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％list.select（“eAttributes.nSize（）&gt; 0”）％&gt;</td>
            <td>[list-&gt; select（eAttributes-&gt; size（）&gt; 0）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.select（“eAttributes.nSize（）”，“0”）％&gt;</td>
            <td>[list-&gt; select（eAttributes-&gt; size（）= 0）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.delete（“eAttributes.nSize（）&gt; 0”）％&gt;</td>
            <td>[list-&gt; reject（eAttributes-&gt; size（）&gt; 0）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.delete（“eAttributes.nSize（）”，“0”）％&gt;</td>
            <td>[list-&gt; reject（eAttributes-&gt; size（）= 0）/]</td>
          </tr>
            <tr><td>&lt;％evaluate（“2 + 4”）％&gt;</td>
            <td> </td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="resources">
        <div class="page-header">
          <h1>资源服务</h1>
        </div>
        
        <p>资源服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％getFileContent（ “C：/Obeo/models/MyModel.xmi”）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％getChainPath％&gt;</td>
            <td> </td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="string">
        <div class="page-header">
          <h1>字符串服务</h1>
        </div>
        
        <p>字符串服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％x.length％&gt;</td>
            <td>[x.size（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.toUpperCase％&gt;</td>
            <td>[x.toUpper（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.toLowerCase％&gt;</td>
            <td>[x.toLower（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.toU1Case％&gt;</td>
            <td>[x.toUpperFirst（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.toL1Case％&gt;</td>
            <td>[x.toLowerFirst（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.substring（1,3）％&gt;</td>
            <td>[x.substring（2,3）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.substring（1）％&gt;</td>
            <td>[x.substring（2）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.replaceAll（“test”，“replacement”）％&gt;</td>
            <td>[x.replaceAll（'test'，'replace'）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.replaceAll（“\ w”，“$ 0”）％&gt;</td>
            <td>[x.replaceAll（'\\ w'，'$ 0'）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.replaceFirst（“test”，“replace”）％&gt;</td>
            <td>[x.replace（'test'，'replace'）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.replaceFirst（“\ w”，“$ 0”）％&gt;</td>
            <td>[x.replace（'\\ w'，'$ 0'）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.trim％&gt;</td>
            <td>[x.trim（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.startsWith（Y）％&gt;</td>
            <td>[x.startsWith（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.endsWith（Y）％&gt;</td>
            <td>[x.endsWith（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.equalsIgnoreCase（Y）％&gt;</td>
            <td>[x.equalsIgnoreCase（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.matches（Y）％&gt;</td>
            <td>[x.matches（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.charAt（4）％&gt;</td>
            <td>[x.substring（5,5）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.indexOf（Y）％&gt;</td>
            <td>[x.index（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.indexOf（y，4）％&gt;</td>
            <td>[x.substring（5，x.size（））。index（y）+ 4 /]</td>
          </tr>
          <tr>
            <td>&lt;％x.lastIndexOf（Y）％&gt;</td>
            <td>[x.lastIndex（Y）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.lastIndexOf（y，4）％&gt;</td>
            <td>[x.substring（5，x.size（））。lastIndex（y）+ 4 /]</td>
          </tr>
          <tr>
            <td>&lt;％x.split（Y）％&gt;</td>
            <td>没有直接等价，使用String :: tokenize（String）</td>
          </tr>
          <tr>
            <td>&lt;％x.indentSpace％&gt;</td>
            <td>[x.replaceAll（'\ r \ n | \ r | \ n'，'$ 0'）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.indentTab％&gt;</td>
            <td>[x.replaceAll（'\ r \ n | \ r | \ n'，'$ 0t'）/]</td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="system">
        <div class="page-header">
          <h1>系统服务</h1>
        </div>
        
        <p>系统服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％I（）％&gt;</td>
            <td>[一世/]</td>
          </tr>
          <tr>
            <td>&lt;％ARGS（0）％&gt;</td>
            <td>参数是显式的，并在Acceleo 3中命名</td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="xpath">
        <div class="page-header">
          <h1>XPath服务</h1>
        </div>
        
        <p>XPath服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％x.ancestor％&gt;</td>
            <td>[x.ancestors（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.parent％&gt;</td>
            <td>[x.eContainer（）/]</td>
          </tr>
          <tr>
            <td>&lt;％自％&gt;</td>
            <td>[自/]</td>
          </tr>
          <tr>
            <td>&lt;％x.child％&gt;</td>
            <td>[x.eContents（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.descendant％&gt;</td>
            <td>[x.eAllContents（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.precedingSibling％&gt;</td>
            <td>[x.precedingSiblings（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.preceding％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％x.followingSibling％&gt;</td>
            <td>[x.followingSiblings（）/]</td>
          </tr>
          <tr>
            <td>&lt;％x.following％&gt;</td>
            <td> </td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="enode">
        <div class="page-header">
          <h1>ENode服务</h1>
        </div>
        
        <p>ENode服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％eObject.adapt（ “EObject”）％&gt;</td>
            <td>[eObject /]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（eObject.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {eObject} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “字符串”）％&gt;</td>
            <td>[if（eObject.oclIsUndefined（））] [''/] [else] [eObject.toString（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “布尔”）％&gt;</td>
            <td>[不是eObject.oclIsUndefined（）/]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “INT”）％&gt;</td>
            <td>[eObject-&gt;尺寸（）/]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “双”）％&gt;</td>
            <td>[eObject-&gt;尺寸（）。的toString（）。toReal（）/]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “列表”）％&gt;</td>
            <td>[if（eObject.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {eObject} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.adapt（ “ENode的”）％&gt;</td>
            <td>[eObject /]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “EObject”）％&gt;</td>
            <td>[if（list.oclIsUndefined（））] [null /] [elseif（list-&gt; size（）== 0）] [else] [list.at（0）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（list.oclIsUndefined（））] [Sequence {} /] [else] [list /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “字符串”）％&gt;</td>
            <td>[if（list.oclIsUndefined（））] [''/] [else] [list.toString（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “布尔”）％</td>
            <td>[list-&gt; size（）&gt; 0 /]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “INT”）％&gt;</td>
            <td>[列表 - &gt;尺寸（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “双”）％&gt;</td>
            <td>[列表 - &gt;尺寸（）。的toString（）。toReal（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “列表”）％&gt;</td>
            <td>[if（list.oclIsUndefined（））] [Sequence {} /] [else] [list /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％list.adapt（ “ENode的”）％&gt;</td>
            <td>[列表/]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “EObject”）％&gt;</td>
            <td>只能在Acceleo 2中返回空的enodes，因此迁移只是“没有”</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（string.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {string} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “字符串”）％&gt;</td>
            <td>[串/]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “布尔”）％&gt;</td>
            <td>[string.equalsIgnoreCase（ '真'）/]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “INT”）％&gt;</td>
            <td>[string.toInt（）/]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “双”）％&gt;</td>
            <td>[string.toReal（）/]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “列表”）％&gt;</td>
            <td>[if（string.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {string} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％string.adapt（ “ENode的”）％&gt;</td>
            <td>[串/]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “EObject”）％&gt;</td>
            <td>只能在Acceleo 2中返回空的enodes，因此迁移只是“没有”</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（boolean.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {boolean} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “字符串”）％&gt;</td>
            <td>[if（boolean.oclIsUndefined（））] [''/] [else] [boolean.toString（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “布尔”）％&gt;</td>
            <td>[不是boolean.oclIsUndefined（）和boolean /]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “INT”）％&gt;</td>
            <td>[if（不是boolean.oclIsUndefined（）和boolean）] [1 /] [else] [0 /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “双”）％&gt;</td>
            <td>[if（不是boolean.oclIsUndefined（）和boolean）] [1.0 /] [else] [0.0 /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “列表”）％&gt;</td>
            <td>[if（boolean.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {boolean} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％boolean.adapt（ “ENode的”）％&gt;</td>
            <td>[布尔/]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “EObject”）％&gt;</td>
            <td>只能在Acceleo 2中返回空的enodes，因此迁移只是“没有”</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（int.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {int} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “字符串”）％&gt;</td>
            <td>[if（int.oclIsUndefined（））] [''/] [else] [int.toString（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “布尔”）％&gt;</td>
            <td>[不是int.oclIsUndefined（）和int&gt; 0 /]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “INT”）％&gt;</td>
            <td>[if（int.oclIsUndefined（））] [0 /] [else] [int /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “双”）％&gt;</td>
            <td>[if（int.oclIsUndefined（））] [0.0 /] [else] [int.toString（）。toReal（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “列表”）％&gt;</td>
            <td>[if（int.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {int} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％int.adapt（ “ENode的”）％&gt;</td>
            <td>[INT /]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “EObject”）％&gt;</td>
            <td>只能在Acceleo 2中返回空的enodes，因此迁移只是“没有”</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “ENodeList”）％&gt;</td>
            <td>[if（double.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {double} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “字符串”）％&gt;</td>
            <td>[if（double.oclIsUndefined（））] [''/] [else] [double.toString（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “布尔”）％&gt;</td>
            <td>[不是double.oclIsUndefined（）和double&gt; 0 /]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “INT”）％&gt;</td>
            <td>[if（double.oclIsUndefined（））] [0 /] [else] [double.toString（）。toInt（）/] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “双”）％&gt;</td>
            <td>[if（double.oclIsUndefined（））] [0.0 /] [else] [double /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “列表”）％&gt;</td>
            <td>[if（double.oclIsUndefined（））] [Sequence {} /] [else] [Sequence {double} /] [/ if]</td>
          </tr>
          <tr>
            <td>&lt;％double.adapt（ “ENode的”）％&gt;</td>
            <td>[双/]</td>
          </tr>
          <tr>
            <td>&lt;％list.cast（ “的EClass”）％&gt;</td>
            <td>[list-&gt; select（not oclIsKindOf（EObject）or oclIsKindOf（EClass））/]</td>
          </tr>
          <tr>
            <td>&lt;％list.filter（ “的EClass”）％&gt;</td>
            <td>[list-&gt; select（not oclIsKindOf（EObject）or oclIsKindOf（EClass））/]</td>
          </tr>
          <tr>
            <td>&lt;％电流（）％&gt;</td>
            <td>[自/]</td>
          </tr>
          <tr>
            <td>&lt;％的电流（1）％&gt;</td>
            <td>迭代器变量在Acceleo 3中命名</td>
          </tr>
          <tr>
            <td>&lt;％node.debug％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％node.trace％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％node.trace（ “名称”）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％nPut（“key”，object）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％nGet（ “钥匙”）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％nPeek％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％NPOP％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％nPush％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％list.nMinimize％&gt;</td>
            <td>[列表 - &gt; asOrderedSet（） - &gt; asSequence（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.minimize％&gt;</td>
            <td>[列表 - &gt; asOrderedSet（） - &gt; asSequence（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nContains（项目）％&gt;</td>
            <td>[列表 - &gt;包括：（项目）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nFirst％&gt;</td>
            <td>[列表 - &gt;第一（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nLast％&gt;</td>
            <td>[列表 - &gt;最后（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nGet（0）％&gt;</td>
            <td>[列表 - &gt;在（0）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nGet（0,1）％&gt;</td>
            <td>[list-&gt; subSequence（1,2）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nReverse％&gt;</td>
            <td>[列表 - &gt;反向（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.reverse％&gt;</td>
            <td>[列表 - &gt;反向（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nSize％&gt;</td>
            <td>[列表 - &gt;尺寸（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nSort％&gt;</td>
            <td>[列表 - &gt; sortedBy（的toString（））/]</td>
          </tr>
          <tr>
            <td>&lt;％list.nSort（名称）％&gt;</td>
            <td>[列表 - &gt; sortedBy（名）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.sort％&gt;</td>
            <td>[列表 - &gt; sortedBy（的toString（）） - &gt; asOrderedSet（） - &gt; asSequence（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.sort（名称）％&gt;</td>
            <td>[列表 - &gt; sortedBy（名称） - &gt; asOrderedSet（） - &gt; asSequence（）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.sep（ “”）％&gt;</td>
            <td>[列表 - &gt; SEP（ ''）/]</td>
          </tr>
          <tr>
            <td>&lt;％list.sepStr（ “”）％&gt;</td>
            <td>[列表 - &gt; SEP（ ''）/]</td>
          </tr>
          <tr>
            <td>&lt;％node.toString％&gt;</td>
            <td>[node.toString（）/]</td>
          </tr>
          <tr>
            <td>&lt;％eObject.until（“eContainer”，“EClass”）％&gt;</td>
            <td> </td>
          </tr>       
          </tbody>
        </table>
      </section>
      
      <section id="context">
        <div class="page-header">
          <h1>上下文服务</h1>
        </div>
        
        <p>上下文服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％的get（ “钥匙”）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％PEEK％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％弹出％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％推％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％put（“key”，object）</td>
            <td> </td>
          </tr>
          </tbody>
        </table>
      </section>
      
      <section id="properties">
        <div class="page-header">
          <h1>物业服务</h1>
        </div>
        
        <p>物业服务的平衡指南。
        </p>
        
        <table class="table table-striped table-bordered table-condensed">
          <colgroup>
            <col width="43%">
            <col width="57%">
          </colgroup>
          <thead valign="bottom">
            <tr>
              <th class="head">Acceleo 2表达</th>
              <th class="head">Acceleo 3表达式（OCL）</th>
            </tr>
          </thead>
          <tbody valign="top">
          <tr>
            <td>&lt;％getBestProperty（ “partial.key”）％&gt;</td>
            <td> </td>
          </tr>
          <tr>
            <td>&lt;％的getProperty（ “钥匙”）％&gt;</td>
            <td>[的getProperty（ '钥匙'）/]</td>
          </tr>
          <tr>
            <td>&lt;％getProperty（“propertiesFile”，“key”）％&gt;</td>
            <td>[getProperty（'propertiesFile'，'key'）/]</td>
          </tr>
          </tbody>
        </table>
        
        <br>
        <br>
      </section>
      
      <footer class="footer">
        <p>这些指南中的材料是版权所有（c）2008,2012 Obeo。该材料可在Eclipse Public License v1.0下获得</p>
      </footer>
      
    </div>
  </body>
</html><html id="0383.org_eclipse_datatools_connectivity_oda_datasource.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>开放数据访问</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">开放数据访问</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.datatools.connectivity.oda.dataSource<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>[API]此扩展点用于支持数据应用程序对设计时和数据源访问的扩展。每个扩展必须实现<i>org.eclipse.datatools.connectivity.oda</i>包中定义的开放数据访问（ODA）Java运行时接口。<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.dataSource">dataSource</a> ， <a href="#e.dataSet">dataSet</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>&gt;<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dataSource">dataSource</a> （ <a href="#e.traceLogging">traceLogging</a> ？， <a href="#e.properties">properties</a> ？， <a href="#e.relationship">relationship</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST dataSource</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">odaVersion CDATA“3.0”</p><p class="code SchemaDtdAttlist">defaultDisplayName CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">driverClass CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">setThreadContextClassLoader（true | false）“false”</p><p class="code SchemaDtdAttlist">overrideExplorerFiltering（true | false）“false”</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">在设计时和运行时使用的ODA数据源扩展类型的定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 在ODA使用者应用程序环境中唯一标识此ODA数据源扩展的完全限定ID。如果此ODA驱动程序可以使用数据源设计器扩展（实现<i>org.eclipse.datatools.connectivity.oda.design.ui.dataSource</i>扩展点），则此属性的值必须与其设计者扩展的<i>id</i>属性的值相匹配。数据源元素。</li>
<li><b>odaVersion</b> - 为此驱动程序开发的ODA接口的版本。此元素是必需的，应采用Major格式。次要或重大。次要。服务（例如3.0或2.0.1）。</li>
<li><b>defaultDisplayName</b> -  ODA数据源扩展的显示名称。可以使用plugin.properties机制对其值进行本地化。如果未指定显示名称，则默认为扩展名ID。当ODA消费者应用程序的设计工具没有相应的数据源编辑器（数据源UI扩展点）时，它可以用于显示ODA数据源扩展列表。</li>
<li><b>driverClass</b> - 实现<i>org.eclipse.datatools.connectivity.oda的具体类<i>。IDriver</i>界面。这是ODA运行时驱动程序的入口点。相同的驱动程序可能支持多个数据源扩展。</li>
<li><b>setThreadContextClassLoader</b> - 如果为true，则ODA运行时扩展插件的使用者应在调用任何ODA接口方法之前将线程上下文类加载器设置为用于加载此驱动程序的加载器。此标志设置为true的任何数据源插件扩展都将优先，并应用于此插件实现的所有数据源扩展。
<br>如果设置的线程上下文类加载器是用于加载此ODA运行时插件的OSGi类加载器，则插件不会将其设计为反过来加载其他类。如果需要进一步加载类，则由各个ODA运行时插件实现来提供自己的URLClassLoader，并根据需要切换线程上下文类加载器。</li>
<li><b>overrideExplorerFiltering</b> - 覆盖ODA扩展资源管理器筛选行为。默认值为false。如果设置为true，则此扩展始终对客户端可见，即使它已被ODA扩展资源管理器筛选排除。
<br>@since 3.2.2（DTP 1.7.2）</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dataSet">dataSet</a> （ <a href="#e.dataTypeMapping">dataTypeMapping</a> +， <a href="#e.properties">属性</a> ？， <a href="#e.relationship">关系</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST数据集</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">defaultDisplayName CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">dataSource扩展支持的数据集类型的定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 在ODA使用者应用程序环境中唯一标识此ODA数据集定义的完全限定ID。</li>
<li><b>defaultDisplayName</b> -  ODA数据集定义的显示名称。可以使用plugin.properties机制对其值进行本地化。如果未指定显示名称，则默认为其id。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.dataTypeMapping">dataTypeMapping</a> （ <a href="#e.alternativeOdaDataType">alternativeOdaDataType</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST dataTypeMapping</p>
<p class="code SchemaDtdAttlist">nativeDataType CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">nativeDataTypeCode CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">odaScalarDataType（Date | Double | Integer | String | Time | Timestamp | Decimal | Blob | Clob | Boolean | JavaObject）“String”</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">数据类型从数据提供程序的本机数据类型映射到一个或多个ODA数据类型。必须将每个本机数据类型映射到主ODA标量数据类型。驱动程序可以选择提供能够转换本机数据类型的备用ODA数据类型列表。此数据类型映射有助于所有ODA使用者从同一组ODA数据类型映射到其自己的特定于应用程序的数据类型。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>nativeDataType</b> - 本机数据类型名称（字符串）。仅用于提供信息。</li>
<li><b>nativeDataTypeCode</b> - 本机数据类型代码（整数）。其值必须与驱动程序的ODA接口实现中返回的数据类型代码之一匹配。</li>
<li><b>odaScalarDataType</b> - 本机类型映射到的主要ODA标量数据类型。支持的ODA数据类型包括：Date，Double，Integer，String，Time，Timestamp，Decimal，Blob，Clob，Boolean和Java Object。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.alternativeOdaDataType">alternativeOdaDataType</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST alternativeOdaDataType</p>
<p class="code SchemaDtdAttlist">odaScalarDataType（Date | Double | Integer | String | Time | Timestamp | Decimal | Blob | Clob | Boolean | JavaObject）</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">提供ODA标量数据类型的替代映射。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>odaScalarDataType</b> - 驱动程序可以将本机类型转换为的ODA标量数据类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.traceLogging">traceLogging</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST traceLogging</p>
<p class="code SchemaDtdAttlist">logLevel CDATA“警告”</p><p class="code SchemaDtdAttlist">logFileNamePrefix CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">logDirectory CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">logFormatterClass CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">配置ODA运行时驱动程序的数据源扩展的跟踪日志记录设置。配置的值将传递给驱动程序的<code>IDriver.setLogConfiguration</code>方法实现。
<br>由个人ODA驱动程序决定如何适当地遵守这些跟踪日志记录属性。

<br><br>注意：如果调试跟踪标志设置为“true”，则插件PDE .options文件中指定的跟踪日志记录配置将优先于此元素中配置的跟踪日志记录配置。
<br>ODA插件的PDE跟踪选项（下面列出的交叉引用）与此元素的属性相匹配。
<br>&lt;plug-in Id&gt; / debug = true / false<br>&lt;plug-in Id&gt; / traceLogging / logLevel<br>&lt;plug-in Id&gt; / traceLogging / logFileNamePrefix<br>&lt;plug-in Id&gt; / traceLogging / logDirectory<br>&lt;plug-in Id&gt; / traceLogging / logFormatterClass</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>logLevel</b> - 驱动程序日志级别的名称或数值。
<br>日志级别的名称和相应的数值是：<br>“严重”= 1000; “警告”= 900; “INFO”= 800; “CONFIG”= 700; “精细”= 500; “FINER”= 400; “最好”= 300; “ALL”= 0; “OFF”= 1001或更高。</li>
<li><b>logFileNamePrefix</b> - 驱动程序日志文件名的字符串前缀。</li>
<li><b>logDirectory</b> - 日志文件的目录。</li>
<li><b>logFormatterClass</b> - 具体日志格式化程序的类名，适用于特定于驱动程序的日志记录实用程序。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.property">属性</a> （ <a href="#e.choice">选择</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST财产</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">defaultDisplayName CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">type（string | choice）“string”</p><p class="code SchemaDtdAttlist">canInherit（true | false）“true”</p><p class="code SchemaDtdAttlist">defaultValue CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">isEncryptable（true | false）“false”</p><p class="code SchemaDtdAttlist">allowsEmptyValueAsNull（true | false）“true”</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">可以使用ODA使用者应用程序的设计器工具在设计时编辑其值的属性。然后在运行时将其值传递给ODA运行时驱动程序。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 属性的唯一名称。</li>
<li><b>defaultDisplayName</b> - 默认显示名称。可以使用plugin.properties机制对其值进行本地化。</li>
<li><b>type</b> - 属性的类型。属性类型可以是限制枚举中列出的值之一。</li>
<li><b>canInherit</b> - 保留。</li>
<li><b>defaultValue</b> - 如果未设置属性值，则属性的默认值。</li>
<li><b>isEncryptable</b> - 一个标志，指示此属性值是否可加密。将其设置为“true”表示ODA使用者应用程序应该加密此属性的值。</li>
<li><b>allowsEmptyValueAsNull</b> - 一个标志，指示是否可以将此属性的空值视为空值。默认值为true。当ODA使用者将属性的值传递给此ODA运行时驱动程序时，此属性设置适用。此可选属性可用于适应属性值的输入控件未提供指定空值的方法的情况。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.propertyGroup">propertyGroup</a> （ <a href="#e.property">property</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST propertyGroup</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">defaultDisplayName CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">ODA使用者应用程序的设计器工具中的一个或多个属性的分组。组属性仅供显示。属性组下列出的所有属性在运行时作为标量属性处理。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>名字</b> -</li>
<li><b>defaultDisplayName</b> - 默认显示名称。可以使用plugin.properties机制对其值进行本地化。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.propertyVisibility">propertyVisibility</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST propertyVisibility</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">能见度（改变|锁定|隐藏）</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">用于在ODA使用者应用程序的设计器工具的属性表中显示命名属性时设置其可见性级别。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 由此数据源扩展定义的属性的名称，或者是系统定义的属性。</li>
<li><b>可见性</b> - 有效选项包括：更改，隐藏，锁定。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.choice">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的选择</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p><p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p><p class="code SchemaDtdAttlist">defaultDisplayName CDATA #IMPLIED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">选择财产价值。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 选择的名称</li>
<li><b>value</b> - 如果选择了给定的选项，则使用的值。</li>
<li><b>defaultDisplayName</b> - 默认显示名称。可以使用plugin.properties机制对其值进行本地化。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.properties">属性</a> （ <a href="#e.property">property</a> *， <a href="#e.propertyGroup">propertyGroup</a> *， <a href="#e.propertyVisibility">propertyVisibility</a> *）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">数据源扩展中的属性定义集合或其支持的数据集定义。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.relationship">关系</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的关系</p>
<p class="code SchemaDtdAttlist">type（replacementBy | wrapperOf）</p><p class="code SchemaDtdAttlist">relatedId CDATA #REQUIRED</p>&gt;<p></p>
<p class="ConfigMarkupElementDesc">一个可选元素，用于指定此元素的关系。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 此扩展的dataSource或dataSet元素与<i>relatedId</i>元素的关系类型。有效值为：<br>* <i>replacedBy：</i>指定此DataSource /数据集已被弃用，由<i>relatedId</i>的替换。由ODA主机决定是否适当应用，例如迁移其不推荐使用的扩展的引用，以及控制在运行时使用哪个ODA扩展。默认情况下，已弃用的数据源类型将隐藏在ODA设计UI框架中显示的数据源列表中，例如用于创建新的连接配置文件实例。
<br>* <i>wrapperOf</i> ：指定此dataSource / dataSet是<i>relatedId</i>标识符的包装。默认情况下，包装器数据源类型是从ODA设计UI框架中显示的可用数据源列表中隐藏的。自：3.1.2。</li>
<li><b>relatedId</b> - 相关ODA数据源或数据集元素的完全限定ID。其用于<i>replacedBy</i>类型值必须匹配，在另一ODA驾驶员<i>org.eclipse.datatools.connectivity.oda.dataSource</i>扩展定义的相应<i>dataSource.id</i>或<i>dataSet.id</i>属性。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>
   </p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.datatools.connectivity.oda.dataSource”</span> <span class="code SchemaTag">&gt; &lt;dataSource odaVersion =</span> <span class="code SchemaCstring">“3.1”</span> <span class="code SchemaTag">driverClass =</span> <span class="code SchemaCstring">“org.eclipse.datatools.connectivity.oda.flatfile。FlatFileDriver“</span> <span class="code SchemaTag">defaultDisplayName =</span> <span class="code SchemaCstring">”平面文件数据源“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.datatools.connectivity.oda.flatfile“</span> <span class="code SchemaTag">setThreadContextClassLoader =</span> <span class="code SchemaCstring">”false“</span> <span class="code SchemaTag">&gt; &lt;properties&gt; &lt;propertyGroup defaultDisplayName =</span> <span class="code SchemaCstring">”Connection Properties“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”connectionProperties“</span> <span class="code SchemaTag">&gt; &lt;property type =</span> <span class="code SchemaCstring">“string”</span> <span class="code SchemaTag">defaultDisplayName =</span> <span class="code SchemaCstring">“Home Folder”</span> <span class="code SchemaTag">canInherit =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“HOME”</span> <span class="code SchemaTag">/&gt; &lt;property type =</span> <span class="code SchemaCstring">“string”</span> <span class="code SchemaTag">defaultDisplayName =</span> <span class="code SchemaCstring">“Character Set”</span> <span class="code SchemaTag">canInherit =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“CHARSET”</span> <span class="code SchemaTag">/&gt; &lt;property type =</span> <span class="code SchemaCstring">“string”</span> <span class="code SchemaTag">canInherit =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">defaultDisplayName =</span> <span class="code SchemaCstring">“包含数据类型（是/否）”</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">“INCLTYPELINE”</span> <span class="code SchemaTag">/&gt; &lt;/ propertyGroup&gt; &lt;/ properties&gt; &lt;/ dataSource&gt; &lt;dataSet defaultDisplayName =</span> <span class="code SchemaCstring">“平面文件数据集“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.datatools.connectivity.oda.flatfile.dataSet“</span> <span class="code SchemaTag">&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”BIT“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">” -  7“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”Integer“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”TINYINT“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">” - 6“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”Integer“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”SMALLINT“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">”5“</span> <span class="code SchemaTag">odaScalarD ataType =</span> <span class="code SchemaCstring">“Integer”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“INTEGER”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“4”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Integer”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“BIGINT”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“ -  5”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Decimal”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“FLOAT”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“6”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Double”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“REAL”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“7”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Double”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“DOUBLE”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“8”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Double “</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”NUMERIC“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">”2“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”Decimal“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”DECIMAL“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">”3“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”Decimal“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”CHAR“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“1”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“VARCHAR”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“12”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“LONGVARCHAR”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“ -  1”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“DATE”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“91”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Date”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“TIME”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“92”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Time”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“TIMESTAMP”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“ 93“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”Timestamp“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”BINARY“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">” -  2“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”String“</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">”VARBINARY“</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">” -  3“</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">”String“</span> <span class="code SchemaTag">/&gt; &lt; dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“LONGVARBINARY”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“ -  4”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“BOOLEAN”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“16”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“Boolean”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“BLOB”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“2004”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;dataTypeMapping nativeDataType =</span> <span class="code SchemaCstring">“CLOB”</span> <span class="code SchemaTag">nativeDataTypeCode =</span> <span class="code SchemaCstring">“2005”</span> <span class="code SchemaTag">odaScalarDataType =</span> <span class="code SchemaCstring">“String”</span> <span class="code SchemaTag">/&gt; &lt;/ dataSet&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>数据源扩展的驱动程序必须实现<i>org.eclipse.datatools.connectivity.oda</i>包中定义的接口。有关更多信息，请参阅包的JavaDoc文档和API接口。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>ODA框架提供ODA插件项目模板向导，以自动生成具有一组主ODA接口的默认实现的自定义ODA插件项目。该向导在New-&gt; Project ...对话框中可用;一个用于ODA运行时驱动程序，另一个用于ODA设计器。
<br>他们生成的实现类假设一个简单的ODA驱动程序和设计器UI的行为。它们包含TODO任务标记，供ODA驱动程序开发人员实现特定于数据源的行为。提供这些具体类以帮助开发自定义ODA数据源。它们的使用纯粹是可选的。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2004-2009 Actuate Corporation。版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从https://www.eclipse.org/legal/epl-2.0/获取。</p>
</body>
</html><html id="2936.org_eclipse_ui_viewActions.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>查看菜单，工具栏和操作</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">查看菜单，工具栏和操作</h1>
<div style="border:1px solid #990000;padding:5px;text-align:center;color:red">不推荐使用此扩展点</div>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>的org.eclipse.ui.viewActions<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>
<b>警告：此扩展点已弃用。</b><br>请勿使用此扩展点，将在本产品的未来版本中将其删除。相反，请使用扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a>
</p>
<p>此扩展点用于向下拉菜单和工具栏添加操作，以便其他插件注册的视图。每个视图都有一个本地下拉菜单，通常通过单击右上角的三角形按钮激活。其他插件可以为此菜单提供子菜单和操作。插件也可以为视图工具栏提供操作。视图所有者首先有机会填充这些区域。附加了其他插件的可选添加项。</p>
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.viewContribution">viewContribution</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>viewContribution</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.viewContribution">viewContribution</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST viewContribution</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">targetID IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">该元素用于定义一组视图动作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符。</li>
<li><b>targetID</b> - 作为此贡献的目标的已注册视图的唯一标识符。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>action</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">disabledIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">hoverIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle | pulldown）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在下拉菜单中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在下拉菜单中。</li>
<li><b>toolbarPath</b> - 目标视图的本地工具栏中的命名组。如果该组不存在，则将创建该组。如果省略，则操作不会显示在本地工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件的位置。图标将显示在工具栏中，但不会显示在下拉菜单中。</li>
<li><b>disabledIcon</b> - 用于在禁用操作时直观地表示其上下文中的操作的图标的相对路径。如果省略，则普通图标将显示为灰色。该路径相对于贡献插件的plugin.xml文件的位置。禁用的图标将显示在工具栏中，但不会显示在下拉菜单中。</li>
<li><b>hoverIcon</b> - 用于在鼠标指针悬停在操作上时可视地表示其上下文中的操作的图标的相对路径。如果省略，将使用普通图标。该路径相对于贡献插件的plugin.xml文件的位置。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。在某些平台上，如果操作显示为菜单项，则在菜单项突出显示时按相应的帮助键将显示帮助。并非所有平台都支持此行为。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的可选属性。如果已定义，则属性值将为以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>拉下</b></td>
        <td valign="top">- 作为下拉工具项目。初始值由<samp>state</samp>属性指定。</td>
      </tr>    </table></li>
<li><b>state</b> - 一个可选属性，指示初始状态（ <samp>true</samp>或<samp>false</samp> ），当<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的完全限定类的名称<samp>。IViewActionDelegate</samp> 。</li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定了此属性并且满足条件，则启用该操作。如果不满足条件，则禁用该操作。如果未指定任何属性，则会为所选的任意数量的项启用该操作。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>参数</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>class</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IViewActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是视图操作扩展的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.viewActions”</span> <span class="code SchemaTag">&gt; &lt;viewContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzViewC1”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“org.eclipse.ui.views.navigator。ResourceNavigator“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / group1”</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">“Normal / additions”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“toggle”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ.png”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“Run XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunXYZ“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;/ viewContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作仅启用单个选择（ <samp>enableFor</samp>属性）。此外，选择中的对象必须是Java文件资源。
</p>
<p>以下是视图操作扩展的另一个示例：</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.viewActions”</span> <span class="code SchemaTag">&gt; &lt;viewContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzViewC1”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“org.eclipse.ui.views.navigator。ResourceNavigator“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”com.xyz.xyzMenu“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”XYZ Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ2 Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“com.xyz.xyzMenu / group1”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ2.png”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行XYZ2工具”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz.run_action_context2”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.actions。RunXYZ2“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;/ viewContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为菜单项。如果选择不包含Java文件资源，则启用该操作。
</p><p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>class</samp>属性的值必须是实现<samp>org.eclipse.ui的Java类的完全限定名<samp>。IViewActionDelegate</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。
<p>接口<samp>org.eclipse.ui。IViewActionDelegate</samp>扩展了<samp>org.eclipse.ui。IActionDelegate</samp>并添加了一个额外的方法，允许委托使用它所贡献的视图实例进行初始化。
</p>
<p>此扩展点可用于将操作提供给先前由目标视图创建的菜单。省略菜单路径属性将导致在下拉菜单末尾添加新菜单或操作。
</p>
<p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p>
<p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>每个视图通常在下拉菜单和本地工具栏上都有许多标准项。来自其他插件的添加内容将附加到标准补充中。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2011 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3142.org_eclipse_ui_editorActions.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>编辑器菜单，工具栏和操作</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">编辑器菜单，工具栏和操作</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.editorActions<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于向其他插件注册的编辑器的菜单和工具栏添加操作。
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p>
<p>为编辑器设置的初始贡献由另一个扩展点（org.eclipse.ui.editors）定义。一组操作由同一编辑器类型的所有实例创建和共享。调用时，这些操作将作用于活动编辑器。此扩展点遵循相同的模式。每个操作扩展都由相同编辑器类型的所有实例创建和共享。动作类是实现<samp>org.eclipse.ui所必需的<samp>。IEditorActionDelegate</samp> 。通过调用<samp>IEditorActionDelegate.setActiveEditor</samp>将活动编辑器传递给委托。</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.editorContribution">editorContribution</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.editorContribution">editorContribution</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST编辑贡献</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">targetID IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义一组编辑器操作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符。</li>
<li><b>targetID</b> - 作为此贡献的目标的已注册编辑器的唯一标识符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">actionID CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。此标签应为非空或应提供definitionId。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在菜单栏中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在菜单栏中。</li>
<li><b>toolbarPath</b> - 斜杠分隔的路径（'/'），用于指定工具栏中此操作的位置。第一个标记表示工具栏标识符（“Normal”是默认工具栏），而第二个标记是工具栏中将添加此操作的命名组。如果工具栏中不存在该组，则会创建该组。如果省略toolbarPath，则操作不会出现在工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件的位置。该图标将显示在工具栏中，但不会显示在菜单中。启用的操作将由hoverIcon在菜单中显示。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。如果操作显示为菜单项，则在菜单项突出显示时按F1将显示帮助。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的可选属性。如果已定义，则属性值将为以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
    </table></li>
<li><b>state</b> - 一个可选属性，指示初始状态（ <samp>true</samp>或<samp>false</samp> ），当<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的完全限定类的名称<samp>。IEditorActionDelegate</samp></li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定了此属性并且满足条件，则启用该操作。如果不满足条件，则禁用该操作。如果未指定任何属性，则会为所选的任意数量的项启用该操作。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>actionID</b> - 文本编辑器使用的内部标记。插件开发人员不应该使用它。以下ID对文本编辑器框架具有特殊含义：<ul>
<li>“RulerClick”：在（左）垂直标尺中单击时调用的贡献动作</li>
<li>“RulerDoubleClick”：在（左）垂直标尺中单击时调用的贡献操作</li>
</ul>
<p>如果多个扩展为同一文本编辑器提供标尺操作，则插件位于先决条件树顶部的扩展会获胜。如果有多个这样的插件，第一个获胜。
</p></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IEditorActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是编辑器操作扩展的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.editorActions”</span> <span class="code SchemaTag">&gt; &lt;editorContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzContribution”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“com.ibm。XMLEditor“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”XYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; XYZ Menu“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run XYZ工具“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”XYZ / group1“</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">”正常/添加“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”toggle“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runXYZ.gif“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context “</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunXYZ“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;/ editorContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为名为“XYZ Menu”的新顶级菜单中的复选框项，以及工具栏中的切换按钮。如果选择仅包含Java文件资源，则启用该操作。
</p><p>以下是编辑器操作扩展的另一个示例：</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.editorActions”</span> <span class="code SchemaTag">&gt; &lt;editorContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyz2Contribution”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“com.ibm。XMLEditor“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”XYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; XYZ2 Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”edit / additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ2 Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“edit / XYZ2 / group1”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ2.gif”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行XYZ2工具”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz.run_action_context2”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.actions。RunXYZ2“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;/ editorContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为顶级“编辑”菜单中名为“XYZ2菜单”的子菜单中的菜单项。如果选择不包含Java文件资源，则启用该操作。
</p><p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须是实现<samp>org.eclipse.ui的Java类的完全限定名<samp>。IEditorActionDelegate</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。每次激活指定类型的编辑器时，都将调用方法<samp>setActiveEditor</samp> 。无论在Workbench中当前打开的编辑器实例的数量如何，都将仅为指定编辑器类型的所有实例创建一组操作和菜单。
<p>此扩展点可用于将操作提供给目标编辑器先前创建的菜单。此外，菜单和操作可以提供给Workbench窗口。Workbench窗口中的操作和主要组的标识符在<samp>org.eclipse.ui中定义<samp>。IWorkbenchActionConstants</samp> 。这些应该用作添加新操作的参考点。通过使用path属性的以下值创建顶级菜单：</p><ul>
<li>添加 - 表示<samp>窗口</samp>菜单左侧的命名组。
</li>
</ul>省略path属性将导致将新菜单添加到添加菜单栏组中。
<p>只有在关联的编辑器处于活动状态时，才会显示添加到这些路径中的操作和菜单。关闭编辑器后，将删除菜单和操作。
</p><p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p><p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>Workbench提供了内置的“默认文本编辑器”。插件可以为此默认编辑器或其他插件提供的编辑器做出贡献。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2007 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="2953.eclipse-install.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">

<head>

<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2011. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>

<meta http-equiv="Content-Language" content="en-us"></meta>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<link rel="STYLESHEET" href="../../book.css" type="text/css" charset="ISO-8859-1"></link>
<title>如何编写Eclipse安装程序</title>
</head>

<body dir="ltr">

<h1>如何编写Eclipse安装程序</h1>
<p>最后修改时间为2004年6月18日星期五15:20</p>
<p>基于Eclipse的产品需要在最终用户的计算机上正确安装。专用打包工具（如<a href="http://www.installshield.com/">InstallShield</a>和<a href="http://www.rpm.org/">RPM</a> ）通常用于构建可自动安装，更新和卸载的可执行安装程序。本说明介绍如何为基于Eclipse的产品编写安装程序，以及如何为基于Eclipse的产品单独安装扩展。</p>
<p>我们假设产品开发团队负责提供原始成分，这些成分需要找到最终用户的计算机打包为可执行安装程序。可执行安装程序的创建是脚本化的，与最终用户交互和在其计算机上存放文件所需的安装时间操作也是如此。本说明详细描述了这些安装程序需要执行的操作以及它们应如何工作。</p>
<p>应将此注释视为负责为基于Eclipse的产品编写安装程序的人员的配方。我们建议所有安装程序编写者遵循我们的配方的两个很好的理由：</p>
<ul>
  <li><b>产品和扩展互操作性。</b> 通过以标准方式运行，一个基于Eclipse的产品或扩展的安装程序自动使用其他安装程序规定的产品和扩展。否则，一个产品的安装程序的特性需要在预期与该产品一起使用的所有扩展安装程序中匹配怪癖。</li>
  <li><b>安装时间用户交互的一致性。</b> 基于Eclipse的产品和扩展的所有安装程序都应以相同的方式与用户交互。在这件事上没有任何无偿的变化。</li>
</ul>

<h2>产品安装程序创建脚本</h2>

<p>产品安装程序应该是独立的 - 可以在CD上分发并安装在具有合适操作系统的任何计算机上的东西。</p>
<p>Eclipse需要Java2 Java运行时环境（JRE）才能运行Java代码。JRE是从Java供应商处获得的许可软件。有了从JRE供应商重新分发JRE的许可，公司可以在其产品中包含JRE，并在产品的同时将其安装在最终用户的计算机上。另一种方法是要求在最终用户的计算机上预安装JRE，并在产品安装时关联。无论如何，基于Eclipse的产品需要合适的JRE，产品安装程序必须在安装JRE或定位和链接到预先存在的JRE中发挥作用。</p>
<p>假设要与产品一起安装JRE。包含JRE的目录是安装程序创建脚本的一个输入。表示此目录&lt; <i>JRE</i> &gt;。此目录必须具有标准JRE目录结构，Java可执行文件位于<code>jre/bin/java.exe</code> ，而类库位于&lt; <i>JRE</i> &gt;目录下的<code>jre/lib/rt.jar</code> 。作为参考，该目录的骨架结构如下所示：</p>
<p><code>&lt; <i>JRE</i> &gt; /<br>JRE /<br>斌/<br>java.exe的<br>LIB /<br>的rt.jar</code></p>
<p>这些目录中还有其他文件（和子目录）;我们只展示了一个样本来给出一般结构。斜体的斜体名称是特定于产品的。</p>
<p>安装程序创建脚本的第二个输入是一个目录&lt; <code><i>product head</i></code> &gt;，其中包含特定于产品的可执行启动程序以及与Eclipse无关的任何文件。作为参考，此目录的骨架结构看起来像（斜体表示文件名因产品而异）：</p>
<p><code>&lt; <i>产品负责人</i> &gt; /<br>
<i>acmeproduct.exe<br>
</i>
<br>
</code>安装程序创建脚本的第三个输入是一个目录&lt; <code><i>product body</i></code> &gt;，其中包含为该产品开发的功能和插件。作为参考，此目录的骨架结构如下所示：</p>
<p><code>&lt; <i>产品主体</i> &gt; /<br>日食/<br>特征/<br>
      <i>com.example.acme.acmefeature</i> _ <i>1.0.0</i> /<br>feature.xml的<br>
      <i>com.example.acme.otherfeature</i> _ <i>1.0.0</i> /<br>feature.xml的<br>插件/<br>
</code>  <code>     <i>com.example.acme.acmefeature</i>_<i>1.0.0</i>/<br>plugin.xml中<br>about.ini<br>about.properties<br>about.mappings<br>PLUGIN_CUSTOMIZATION.INI<br>为splash.bmp<br>
</code>  <code>     <i>com.example.acme.otherfeature</i>_<i>1.0.0</i>/<br>plugin.xml中<br>about.ini<br>about.properties<br>about.mappings<br>
</code>  <code>     <i>com.example.acme.myplugin</i>_<i>1.0.0</i>/<br>plugin.xml中<br>
        <i>myplugin</i> .jar<br>
</code>  <code>     <i>com.example.acme.otherplugin</i>_<i>1.0.0</i>/<br>plugin.xml中<br>
        <i>otherplugin</i> .jar</code></p>
<p>安装程序创建脚本的第四个输入是一个目录&lt; <code><i>platform</i></code> &gt;，其中包含Eclipse平台本身的功能和插件以及所包含的任何第三方工具。该目录还包括标准的Eclipse可执行启动程序<code>eclipse.exe</code> （在Unix操作环境中名为<code>eclipse</code> ），以及安装根目录所需的任何其他Eclipse平台文件。作为参考，此目录的骨架结构如下所示：</p>
<p><code>&lt; <i>platform</i> &gt;<br>日食/<br>的eclipse.exe<br>特征/<br>org.eclipse.platform_2.0.0 /<br>org.eclipse.platform.win32_2.0.0 /<br>org.eclipse.jdt_2.0.0 /<br>org.eclipse.pde_2.0.0 /<br>插件/<br>org.eclipse.equinox.launcher_1.0.0.v20070530.jar<br>org.eclipse.equinox.launcher.win32.win32.x86_1.0.0.v20070523 /<br>org.eclipse.platform_2.0.0 /<br>org.eclipse.core.runtime_2.0.0 /<br>org.eclipse.core.boot_2.0.0 /<br>org.eclipse.core.resources_2.0.0 /<br>org.eclipse.ui_2.0.0 /<br>org.eclipse.jdt_2.0.0 /<br>org.eclipse.jdt.core_2.0.0 /<br>org.eclipse.jdt.ui_2.0.0 /<br>org.eclipse.pde_2.0.0 /<br>org.eclipse.pde.core_2.0.0 /<br>org.eclipse.pde.ui_2.0.0 /<br>（更多org.eclipse。*插件目录）<br>
<br>
</code> &lt; <i><code>JRE</code></i> &gt;，&lt; <i><code>product head</code></i> &gt;，&lt; <i><code>product body</code></i> &gt;和&lt; <code><i>platform</i></code> &gt;输入目录的确切内容决定了最终用户计算机上最终安装的文件。</p>
<p>安装程序创建脚本的最终输入是产品主要功能的ID和版本字符串;例如，“ <code><i>com.example.acme.acmefeature"</i></code>和“ <code><i>1.0.0</i></code> ”;和产品可执行文件的名称;例如，“ <code><i>acmeproduct</i></code> <code>.exe</code> ”。对于不需要自己的产品可执行文件的产品，这将是标准Eclipse可执行启动程序“ <code>eclipse/eclipse.exe</code> ”的路径。这些字符串对安装程序具有特殊意义，出现在文件和目录名称中，以及安装时创建的标记文件的内容中。</p>
<p>在安装时，安装程序应以标准方式运行（更多详细信息请遵循步骤列表）：</p>
<ol>
  <li>警告用户退出所有程序</li>
  <li>介绍要安装的产品</li>
  <li>如果合适，请询问用户注册所有者的名称和许可证密钥</li>
  <li>显示产品的许可协议并要求用户接受</li>
  <li>建议在磁盘上安装一个位置来安装产品（但允许用户覆盖此默认值）</li>
  <li>检查产品或扩展程序是否尚未存储在指定位置</li>
  <li>要求用户确认安装的所有细节</li>
  <li>创建标记文件以标记产品安装的根目录</li>
  <li>将文件复制到磁盘（见下文）</li>
  <li>如果合适，将注册所有者和许可证密钥的名称插入“about”描述中</li>
  <li>创建桌面快捷方式以运行产品可执行文件</li>
  <li>创建适当的条目以允许用户卸载产品</li>
  <li>使用-initialize选项启动产品可执行文件以执行所有首次处理</li>
  <li>提供显示产品发布说明（“自述”文件）</li>
</ol>
<p>如果步骤5中指定的位置是&lt; <code><i>install</i></code> &gt;，则安装程序会将&lt; <i><code>JRE</code></i> &gt;， <code>&lt; <i>platform</i> &gt;,</code> &lt; <i><code>product</code></i> &gt;和<code>&lt; <i>product plug-ins</i> &gt;</code>目录中的所有文件复制到&lt; <code><i>install</i></code> &gt;中。</p>
<table border="1" width="50%">
  <tr>
    <td width="50%">输入文件</td>
    <td width="50%">已安装的文件</td>
  </tr>
  <tr>
    <td width="50%"><code>&lt; <i>JRE</i> &gt; / *</code></td>
    <td width="50%"><code>&lt; <i>install</i> &gt; / eclipse / *</code></td>
  </tr>
  <tr>
    <td width="50%"><code>&lt; <i>产品负责人</i> &gt; / *</code></td>
    <td width="50%"><code>&lt; <i>install</i> &gt; / *</code></td>
  </tr>
  <tr>
    <td width="50%"><code>&lt; <i>产品主体</i> &gt; / *</code></td>
    <td width="50%"><code>&lt; <i>install</i> &gt; / *</code></td>
  </tr>
  <tr>
    <td width="50%"><code>&lt; <i>platform</i> &gt; / *</code></td>
    <td width="50%"><code>&lt; <i>install</i> &gt; / *</code></td>
  </tr>
</table>
<p>在步骤8中创建的标记文件是<code>&lt; <i>install</i> &gt;/eclipse/.eclipseproduct</code>用于标记已安装基于Eclipse的产品的目录，主要用于扩展安装程序的定位。此标记文件是<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Properties.html">java.util。属性</a>格式文件（带有“\”转义的ISO 8859-1字符编码），包含以下信息，用于向用户标识产品并区分一个基于Eclipse的产品：</p>
<blockquote>
<p><code>name = <i>Acme Visual Tools Pro</i><br>id = <i>com.example.acme.acmefeature<br>
</i> version = <i>1.0.0</i></code></p>
</blockquote>
<p>“id”和“version”属性的值是安装程序创建脚本的输入;该产品的名称可能是已知的并且是硬连线的。（产品通常不会访问此标记文件;只有产品和扩展安装程序可以写入或读取它。）</p>
<p>步骤6需要检查现有的<code>&lt; <i>install</i> &gt;/eclipse/.eclipseproduct</code>或<code>&lt; <i>install</i> &gt;/eclipse/.eclipseextension</code>文件。产品不能安装在与其他产品或扩展名完全相同的位置。</p>
<p>安装所有文件后，安装目录的顶级结构将包含以下文件和子目录（可能还有其他文件）：</p>
<p><code>&lt; <i>install</i> &gt; /<br>
  <i>acmeproduct</i> .exe<br>日食/<br>.eclipseproduct<br>的eclipse.exe<br>特征/<br>插件/<br>JRE /<br>
<br>
</code>如果产品安装程序向用户请求许可证信息，例如注册所有者的名称和许可证密钥，则该信息应该进入产品“关于”对话框（步骤10）。</p>
<p>这是通过在主要功能的插件中的“ <code>about.mapping</code> ”文件中记录用户响应来完成的。例如，在<code>&lt; <i>install</i> &gt;/plugins/ <i>com.example.acme.acmefeature</i> _ <i>1.0.0</i> /about.mapping</code> 。“ <code>about.mapping</code> ”文件可能预先存在于&lt; <i><code>product head</code></i> &gt;输入中，或者可能需要安装程序在安装时创建。钥匙是数字; “ <i>n</i> ”键的值替换“ <code>aboutText</code> ”属性中的子串“ <code>{ <i>n</i> }</code> ”。例如，如果许可证密钥是字段编号0，则应创建包含类似“ <code>0=T42-24T-ME4U-U4ME</code> ”的行的“ <code>about.mapping</code> ”文件。</p>
<p>注意“ <code>about.mapping</code> ”文件是<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Properties.html">java.util。属性</a>格式文件（带有“\”转义的ISO 8859-1字符编码）。当安装时的本机字符编码与ISO 8859-1不同时，安装程序负责将本机字符编码转换为Unicode，并在需要时添加“\”转义符。当字符串包含特殊字符（例如“\”）或非拉丁字符时，需要转义。例如，包含希腊字母表的前3个字母的字段编号1将被写为“ <code>1=\u03B1\u03B2\u03B3</code> ”。</p>
<p>在步骤12，产品安装程序使用特殊的-initialize选项[确切的详细信息TBD]启动产品可执行文件<code>&lt; <i>install</i> &gt;/ <i>acmeproduct</i> .exe</code> 。这会导致Eclipse平台悄悄地执行所有耗时的首次处理并缓存结果，这样当用户启动产品时，它会立即以开放营业状态出现。</p>
<h3>卸载程序行为</h3>
<p>在卸载时，卸载程序应以标准方式运行：</p>
<ol>
  <li>警告用户退出所有程序，尤其是正在卸载的产品</li>
  <li>要求用户确认要卸载该产品</li>
  <li>从&lt; <i><code>install</code></i> &gt;目录中删除所有已安装的文件，并删除&lt; <i><code>install</code></i> &gt; <code>/eclipse/features</code>和&lt; <i><code>install</code></i> &gt; <code>/eclipse/plugins</code> <b>所有</b>文件，包括由此安装程序以外的其他各方放置的文件（例如，由Eclipse更新管理器提供）</li>
  <li>删除产品可执行文件的桌面快捷方式</li>
  <li>删除产品卸载程序的条目</li>
  <li>告知用户任何未删除的文件</li>
</ol>
<p>卸载产品时，应删除安装时存放的文件，以及Eclipse更新管理器创建的更新功能和插件。<b>重要：</b>在卸载时， <code>&lt; <i>install</i> &gt;</code>目录中可能还有其他目录和文件，特别是<code>&lt; <i>install</i> &gt;/eclipse/workspace/</code> ， <code>&lt; <i>install</i> &gt;/eclipse/links/</code>和<code>&lt; <i>install</i> &gt;/eclipse/configuration/</code> ，包含重要数据，在卸载产品时必须保留这些数据。用户必须能够在同一位置卸载并重新安装产品，而不会丢失重要数据。</p>
<h3>已安装产品时的安装程序行为</h3>
<p>当产品已安装在用户的计算机上时，安装程序应允许将服务更新或版本升级应用于已安装的产品。</p>
<p>在安装时，安装程序应以标准方式运行：</p>
<ol>
  <li>警告用户退出所有程序，尤其是正在更新的产品</li>
  <li>找到要更新的已安装产品，必要时通过在磁盘中搜索现有产品安装或允许用户找到它</li>
  <li>确定此安装程序是兼容更新的位置</li>
  <li>如果合适，请询问用户注册所有者的名称和许可证密钥</li>
  <li>显示产品的更新许可协议并要求用户接受</li>
  <li>要求用户确认更新的所有详细信息</li>
  <li>将文件更新到磁盘（见下文）</li>
  <li>如果需要，请更改桌面快捷方式以运行产品可执行文件</li>
  <li>应该将已修改或新添加的文件添加到卸载时要删除的文件列表中（如果可行）</li>
  <li>提供显示产品发布说明（“自述”文件）</li>
</ol>
<p>在步骤2中，可以通过存在立即包含名为“ <code>.eclipseproduct</code> ”的文件的“ <code>eclipse</code> ”目录来识别已安装的产品。“ <code>eclipse</code> ”目录的父级是产品的安装目录;即， <code>&lt; <i>install</i> &gt;/eclipse/.eclipseproduct</code> 。应向用户显示此标记文件中包含的信息，以确认正在更新正确的产品（用户计算机上可能有几个基于Eclipse的产品）。</p>
<p>安装程序应在步骤3中通过与<code>&lt; <i>install</i> &gt;/eclipse/features</code>目录中的子目录的简单模式匹配来执行兼容性检查。例如，匹配“ <code><i>com.example.acme.otherfeature</i> _ <i>1.0.1</i></code> ”的文件夹的存在将确保已对已安装的产品应用某个服务更新。</p>
<p>对于步骤7，安装程序可以删除或替换它最初安装的任何文件，并添加更多文件。<b>重要提示：</b>多个文件和目录（包括<code>&lt; <i>install</i> &gt;/eclipse/workspace/</code> ， <code>&lt; <i>install</i> &gt;/eclipse/configuration</code> ）可能与安装位于同一位置，并包含重要数据文件，这些文件需要在升级产品时保留。</p>
<p>在升级情况下， <code>&lt; <i>install</i> &gt;/eclipse/plugins/</code>下面的大多数文件很可能是相同的（同样适用于<code>&lt; <i>install</i> &gt;/eclipse/features/</code> ）。在<code>&lt; <i>install</i> &gt;/eclipse/plugins/</code>进行优化有很大的机会，因为嵌入插件（或片段）版本号的子目录名称只有当它下面的任何文件发生变化时才会发生变化。换句话说，如果升级后该子目录也应该存在，则无需触及<code>&lt; <i>install</i> &gt;/eclipse/plugins/org.eclipse.ui_2.0.0</code> /中的任何文件;如果要更改任何插件的文件，则修改插件的版本号，使升级的插件的文件安装在并行目录<code>&lt; <i>install</i> &gt;/eclipse/plugins/org.eclipse.ui_2.0.1</code> /。</p>
<h3>关联安装在其他地方的JRE</h3>
<p>JRE预计位于<code>&lt; <i>install</i> &gt;/eclipse/jre/bin/javaw.exe</code> 。如果它位于其他位置，则应使用命令行上的<code>-vm</code>选项指定绝对路径;例如， <code>-vm C:\j2jre1.3.0\jre\bin\javaw.exe</code> 。在这种情况下，安装程序应将此选项添加到它创建的桌面快捷方式的命令行中。</p>
<h2>Extension installer创建脚本</h2>

<p>扩展我们指的是一组可单独安装的功能及其插件，这些功能可以与安装在同一台计算机上的一个或多个基于Eclipse的产品相关联并使用。与产品相比，扩展不是独立的;扩展不包括产品可执行文件，Eclipse平台，JRE。</p>
<p>在不失一般性的情况下，假设扩展包含单个特征。安装程序创建脚本的第一个输入是一个目录&lt; <code><i>extension</i></code> &gt;，其中包含其功能和插件。我们假设扩展没有与Eclipse相关的文件;如果是这样，他们会进入<code>&lt; <i>extension</i> &gt;/</code> ，而不是<code>&lt; <i>extension</i> &gt;/eclipse/</code> 。作为参考，此目录的骨架结构如下所示：</p>
<p><code>&lt; <i>extension</i> &gt; /<br>日食/<br>特征/<br>
      <i>com.example.wiley.anvilfeature</i> _ <i>1.0.0</i> /<br>feature.xml的<br>插件/<br>
</code>  <code>     <i>com.example.wiley.anvilfeature</i>_<i>1.0.0</i>/<br>plugin.xml中<br>about.ini<br>about.properties<br>about.mappings<br>
</code>  <code>     <i>com.example.wiley.mainplugin</i>_<i>1.0.0</i>/<br>
</code>  <code>     <i>com.example.wiley.otherplugin</i>_<i>1.0.0</i>/
</code></p>
<p>&lt; <i><code>extension</code></i> &gt;输入目录的确切内容确定最终用户计算机上最终将安装哪些文件。</p>
<p>安装程序创建脚本的最终输入是扩展程序功能的id和version字符串;例如，“ <i><code>com.example.wiley.anvil</code></i> ”和“ <code><i>1.0.0</i></code> ”。这些字符串对安装程序具有特殊意义，出现在文件和目录名称中，以及安装时创建的标记文件的内容中。</p>
<p>扩展安装程序在大多数方面类似于产品安装程序。下面突出显示它不同的区域：</p>
<p>在安装时，安装程序以标准方式运行：</p>
<ol>
  <li>警告用户退出所有程序</li>
  <li>介绍要安装的扩展</li>
  <li>如果合适，请询问用户注册所有者的名称和许可证密钥</li>
  <li>显示扩展程序的许可协议并要求用户接受</li>
  <li>建议在磁盘上安装一个位置以安装扩展（但允许用户覆盖此默认值）</li>
  <li>检查产品或其他扩展名是否尚未存储在指定位置</li>
  <li>询问用户要使用此扩展名的产品（搜索磁盘;浏览;或跳过）</li>
  <li>（可选）确定扩展名是否与所选产品兼容</li>
  <li>要求用户确认安装的所有细节</li>
  <li>创建标记文件以标记扩展安装的根目录</li>
  <li>将文件复制到磁盘（见下文）</li>
  <li>将注册所有者和许可证密钥的名称插入“about”描述中</li>
  <li>创建适当的条目以允许用户卸载扩展</li>
  <li>在每个选定的产品中写入链接文件，以将扩展名与产品相关联</li>
  <li>提供显示扩展发行说明（“自述”文件）</li>
</ol>
<p>如果步骤5中指定的位置是&lt; <code><i>install</i></code> &gt;，则安装程序会将<code>&lt; <i>extension</i> &gt;</code>目录中的所有文件复制到步骤11中的&lt; <code><i>install</i></code> &gt;中。</p>
<table border="1" width="50%">
  <tr>
    <td width="50%">输入文件</td>
    <td width="50%">已安装的文件</td>
  </tr>
  <tr>
    <td width="50%"><code>&lt; <i>extension</i> &gt; / *</code></td>
    <td width="50%"><code>&lt; <i>install</i> &gt; / *</code></td>
  </tr>
</table>
<p>对于第7步，任何Eclipse产品都可能是候选产品。基于Eclipse的产品可以通过<code>&lt; <i>product install</i> &gt;/eclipse/.eclipseproduct</code>文件的存在来识别;用户应该能够请求对已安装产品进行有限磁盘搜索（“搜索已安装产品”按钮），或者导航到包含产品的目录（即“浏览”按钮）。</p>
<p>安装程序应在步骤8中通过与<code>&lt; <i>product install</i> &gt;/eclipse/features</code>目录中的子目录的简单模式匹配来执行兼容性检查。例如，匹配“ <code>org.eclipse.jdt_2.*</code> ”的文件夹的存在意味着JDT包含在已安装的产品中。</p>
<p>在步骤10中创建的标记文件是<code>&lt; <i>install</i> &gt;/eclipse/.eclipseextension</code>用于标记已安装基于Eclipse的扩展的目录，主要用于扩展安装程序的定位（类似于产品的<code>.eclipseproduct</code>标记文件）。此标记文件是<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Properties.html">java.util。属性</a>格式文件（带有“\”转义的ISO 8859-1字符编码），包含以下信息，用于标识用户的扩展并区分一个基于Eclipse的扩展：</p>
<blockquote>
<p><code>name = <i>Wiley Anvil企业版</i><br>id = <i>com.example.wiley.anvilfeature<br>
</i> version = <i>1.0.0</i></code></p>
</blockquote>
<p>“id”和“version”属性的值是安装程序创建脚本的输入;扩展名称大概是已知的并且是硬连线的。（产品通常不会访问此标记文件;只有产品和扩展安装程序可以写入或读取它。）</p>
<p>安装所有文件后，安装目录的顶级结构将包含以下文件和子目录：</p>
<p><code>&lt; <i>install</i> &gt; /<br>日食/<br>.eclipseextension的<br>特征/<br>插件/</code></p>
<p>与产品安装程序的唯一显着区别是，扩展安装程序还在已安装在用户计算机上的其他基于Eclipse的产品中创建链接文件。（这使用户不必使用Eclipse更新管理器手动关联每个产品中的新扩展。）</p>
<p>在步骤14中创建的链接文件是<code>&lt; <i>product install</i> &gt;/eclipse/links/ <i>com.example.wiley.anvilfeature.</i> link</code> ;也就是说，该文件的名称与扩展名的功能目录相同，而不是版本号后缀。链接文件是<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Properties.html">java.util。属性</a>格式文件（带有“\”转义的ISO 8859-1字符编码）。键是“path”，值是已安装扩展的绝对路径， <code>&lt; <i>install</i> &gt;</code> ;例如，条目可能看起来像“ <code>path=C:\\Program Files\\Wiley\\Anvil</code> ” <code>.</code> 安装程序负责从本机字符编码转换为Unicode，并在需要时添加“\”转义符。通常需要转义，因为<code>&lt; <i>install</i> &gt;</code>通常包含特殊字符（例如“\”），并且可能会提及名称中包含非拉丁字符的目录。产品在启动时读取链接文件。安装程序会记录它创建的任何链接文件，以便在更新或卸载扩展时找到它们。</p>
<h3>卸载程序行为</h3>
<p>在卸载时，un安装程序应该以标准方式运行：</p>
<ol>
  <li>警告用户退出所有程序，尤其是使用卸载的扩展程序的产品</li>
  <li>要求用户确认要卸载扩展</li>
  <li>从&lt; <i><code>install</code></i> &gt;目录中删除所有已安装的文件，并删除&lt; <i><code>install</code></i> &gt; <code>/eclipse/features</code>和&lt; <i><code>install</code></i> &gt; <code>/eclipse/plugins</code> <b>所有</b>文件，包括由此安装程序以外的其他各方放置的文件（例如，由Eclipse更新管理器提供）</li>
  <li>如果可行，请从已添加的链接文件中删除链接文件</li>
  <li>删除扩展卸载程序的条目</li>
  <li>告知用户任何未删除的文件</li>
</ol>
<p>卸载扩展时，应删除所有插件和功能文件;这些子目录中没有重要的数据文件。这允许用户完全卸载扩展，包括Eclipse更新管理器应用的任何更新。</p>
<h3>已安装扩展时的安装程序行为</h3>
<p>当扩展已安装在用户的计算机上时，安装程序应允许将服务更新或版本升级应用于已安装的扩展。</p>
<p>在安装时，安装程序应以标准方式运行：</p>
<ol>
  <li>警告用户退出所有程序，尤其是使用正在更新的扩展程序的产品</li>
  <li>找到要更新的已安装扩展，必要时通过在磁盘上搜索现有扩展安装或允许用户找到它</li>
  <li>确定此安装程序是兼容更新的位置</li>
  <li>如果合适，请询问用户注册所有者的名称和许可证密钥</li>
  <li>显示产品的更新许可协议并要求用户接受</li>
  <li>要求用户确认更新的所有详细信息</li>
  <li>更新磁盘上的文件（见下文）</li>
  <li>应该将已修改或新添加的文件添加到卸载时要删除的文件列表中（如果可行）</li>
  <li>提供显示扩展发行说明（“自述”文件）</li>
</ol>
<p>在步骤2中，可以通过存在立即包含名为“ <code>.eclipseextension</code> ”的文件的“ <code>eclipse</code> ”目录来识别已安装的扩展。“ <code>eclipse</code> ”目录的父级是扩展的安装目录;即， <code>&lt; <i>install</i> &gt;/eclipse/.eclipseextension</code> 。应向用户显示此标记文件中包含的信息，以确认正在更新正确的扩展（用户计算机上可能有几个基于Eclipse的扩展）。</p>
<p>对于步骤7，安装程序不应删除或覆盖最初安装的任何文件;相反，它应该只为新版本的功能和插件添加文件，并可能重写标记文件<code>&lt; <i>install</i> &gt;/eclipse/.eclipseextension</code> 。保留旧版本可让用户选择退出更新。与升级产品安装一样，如果升级后该子目录也应该存在，则无需触及<code>&lt; <i>install</i> &gt;/eclipse/plugins/ <i>com.example.wiley.otherplugin</i> _ <i>1.0.0</i></code> /中的任何文件。如果要更改任何插件的文件，则修改插件的版本号，使升级的插件的文件安装在并行目录<code>&lt; <i>install</i> &gt;/eclipse/plugins/ <i>com.example.wiley.otherplugin</i> _ <i>1.0.1</i></code> /。</p>



</body>

</html><html id="1958.s1.3.1.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s1.3.2.html" rel="next">§1.3.2常规角色继承&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a> &gt; <a class="nav" href="s1.3.html" rel="section">§1.3角色类的获取和隐式继承</a></div>
         <div class="sect depth3" id="s1.3.1">
            <h3 class="sect">§1.3.1角色类的获取和隐式继承<a class="img" href="s1.3.1.html" title="PermaLinkto§1.3.1角色类的获取和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h3>
            <p>团队从其超级团队中获得所有角色。这种关系类似于内部类的继承，但是接下来定义了一些决定性的差异。两种实现方案中提到<a href="s1.html#aux1.1" class="int">以下</a> ，这可以用来实现角色收购的特殊语义（虚拟类和副本继承）。
               			
            </p>
            <h5 class="listing">隐式角色继承</h5>
            <div class="listing example frame" id="l1.3.1-1">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">1</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>班级</b> S {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">2</td>
                     <td><pre>    <b>受保护的</b> <b>等级</b> R0 {...}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">3</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> R1 <em><b>扩展</b> R0</em> {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">4</td>
                     <td><pre>        <b>布尔</b>好</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">五</td>
                     <td><pre>R2 m（）{...}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">6</td>
                     <td><pre>        <b>void</b> n（ <em>R2</em> r）{...}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">7</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">8</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> R2 {...}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">9</td>
                     <td><pre>}</pre></td>
                  </tr>
               </table>
            </div>
            <div class="listing example frame" id="l1.3.1-2">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">10</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>类</b> T <em><b>延伸</b> S</em> {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">11</td>
                     <td><pre>@Override <b>受保护的</b> <em><b>类</b> R1</em> {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">12</td>
                     <td><pre>        <strong>R2</strong> m（）{</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">13</td>
                     <td><pre>if（ <em>ok</em> ）{ <b>return</b> <em>tsuper</em> .m（）; }</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">14</td>
                     <td><pre>            <b>else</b> { <b>return</b> null; }</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">15</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">16</td>
                     <td><pre>        <b>void</b> doIt（）{</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">17</td>
                     <td><pre>N（米（））;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">18</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">19</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">20</td>
                     <td><pre>}</pre></td>
                  </tr>
               </table>
            </div>
            <div class="subsect depth4" id="s1.3.1.a">
               <h4 class="subsect">（a） <span class="title">角色类获取</span><a class="img" href="s1.3.1.a.html" title="PermaLink（a）角色类获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>扩展超级团队<code>S</code>的团队<code>T</code>具有对应于超级团队的每个角色<code>SR</code>的一个角色类<code>TR</code> 。新类型<code>TR</code> <strong>覆盖</strong> <code>R</code>用于<code>T</code>及其角色的上下文。获取角色类可以是直接的（见下文（b）），也可能涉及覆盖和隐式继承（下面的（c））。
                  				
               </p>
               <div class="codecomment">在上面的例子中（代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> ），团队<code>S</code>对类型<code>S.R0</code> ， <code>S.R1</code>和<code>S.R2</code>进行操作，而<code>T</code>对类型<code>T.R0</code> ， <code>T.R1</code>和<code>T.R2</code> 。<br><em>（类似于“ <code>S.R0</code> ”的引用在源代码中实际上是非法的（ <a href="s1.2.3.b.html" title="§1.2.3。（b）合格的角色类型" class="sect">§1.2.3。（b）</a> ）。这里它们仅用于说明目的）</em></div>
            </div>
            <div class="subsect depth4" id="s1.3.1.b">
               <h4 class="subsect">（b） <span class="title">直接角色获取</span><a class="img" href="s1.3.1.b.html" title="PermaLink（b）直接角色获取"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在子团队<code>T</code> ，其超级团队<code>S</code>每个角色<code>SR</code>都可以通过简单名称<code>R</code>而无需进一步声明。
                  				
               </p>
               <div class="codecomment"><a href="#l1.3.1-1" class="listing">清单1.3.1-1中</a>的角色<code>R2</code>可用于子团队<code>T</code> （第12行），因为此角色类型是在封闭团队的超类中定义的。
                  				
               </div>
            </div>
            <div class="subsect depth4" id="s1.3.1.c">
               <h4 class="subsect">（c） <span class="title">覆盖和隐含继承</span><a class="img" href="s1.3.1.c.html" title="PermaLink to（c）覆盖和隐式继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果团队包含与其超级团队中定义的角色同名的角色类定义，则新角色类将覆盖超级团队中的相应角色，并<strong>隐式继承</strong>其所有功能。这种关系只能通过名称对应来建立。
                  				
               </p>
               <p>覆盖继承角色的角色应使用<code>@Override</code>注释进行标记。编译器应该可选地使用警告标记缺少的<code>@Override</code>注释。相反，如果角色标有<code>@Override</code>注释但实际上没有覆盖继承的角色，则会出错。
                  				
               </p>
               <p>使用接口覆盖角色类是错误的，反之亦然。最后一个角色不能被覆盖。<br>与常规继承不同， <strong>构造函数</strong>也是沿着隐式继承继承的，并且可以像普通方法一样被覆盖。
                  				
               </p>
               <div class="codecomment">在<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a> <code>R1</code>在<code>T</code>隐含继承的所有功能<code>R1</code>在<code>S</code> 。这是因为它的封闭团队<code>T</code>扩展了团队<code>S</code> （第10行），角色定义使用相同的名称<code>R1</code> （第11行）。因此，在<code>T.R1</code> （第13行）的方法<code>m()</code>中可以使用属性<code><strong>ok</strong></code> 。<code>T.R1</code>还覆盖<code>S.R1</code>其由标记<code>@Override</code>在第11行注释。
                  				
               </div>
            </div>
            <div class="subsect depth4" id="s1.3.1.d">
               <h4 class="subsect">（d） <span class="title">缺乏分类</span><a class="img" href="s1.3.1.d.html" title="永久链接到（d）缺少子类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>从超级团队直接获取角色和隐式继承不会建立<strong>子类型</strong>关系。给定团队的角色永远不会与任何<em>其他</em>团队的任何角色保持一致（即可替代）。
                  	    <code>SR</code>和<code>TR</code>总是不可通约的。<br><span class="underline">请注意，</span>此规则是<a href="s1.2.2.e.html" title="§1.2.2。（e）一致性" class="sect">§1.2.2。（e）</a>的直接结果。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s1.3.1.e">
               <h4 class="subsect">（e） <span class="title">类型的动态绑定</span><a class="img" href="s1.3.1.e.html" title="PermaLink到（e）类型的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>通过新角色类覆盖获取的角色具有以下含义：如果表示或声明（代表团队<code>T</code>的实例或其包含的角色之一进行评估）引用角色<code>R</code> ，则<code>R</code>将始终解析为<code>TR</code>即使<code>R</code>是在<code>T</code>的超级团队中引入的，即使特定的代码行是从超级团队或其中一个角色继承而来的。只有封闭的team-instance的动态类型用于确定正确的角色类（请参阅下面的示例）。
                  				
               </p>
               <p>动态绑定角色类型的一个特例涉及所谓的类文字（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）。角色类文字包含在<a href="s6.1.c.html" title="§6.1。（c）角色的类文字" class="sect">第6.1节中。（c）</a> 。
                  				
               </p>
               <p>仅在涉及隐式继承的情况下才严格要求上述内容。然而，它可以帮助直觉，也可以考虑（b）中直接获得的角色<code>TR</code>来覆盖给定的角色<code>SR</code> 。</p>
               <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1的</a>第17行中，使用<code>m</code>的调用结果调用隐式继承的方法<code>n</code> 。虽然<code>n</code>在定义<code>S</code> （因此与参数类型<code>S.R2, see line 6</code> ）的背景下<code>T</code>它期望的参数<code>T.R2</code> 。这是通过在<code>T</code>的上下文中调用<code>m</code>来正确提供的。</div>
            </div>
            <div class="subsect depth4" id="s1.3.1.f">
               <h4 class="subsect">（f） <span class="title">tsuper</span><a class="img" href="s1.3.1.f.html" title="永久链接到（f）tsuper"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <div class="syntaxlink"><a href="sA.html#sA.5.4" title="§A.5.4TSuperCall" class="syntax">→语法§A.5.4</a></div>
               <p>隐式继承的超级调用使用new关键字<strong>tsuper</strong> 。虽然<code>super</code>仍然可以在常规继承中使用，但是调用<code>tsuper.m()</code>选择从超级团队获取的相应角色的<code>m</code>版本。
                  				
               </p>
               <p>有关角色构造函数的上下文中的<code>tsuper</code> ，请参见第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2</a> <code>tsuper</code> 。
                  				
               </p>
               <p><code>tsuper</code>只能用于调用封闭方法或构造函数的相应版本，即表达式<code>tsuper.m()</code>只能在方法<code>m</code> ，两个方法具有相同的签名（参见<a href="s2.3.2.b.html" title="§2.3.2。（b）在宣布解除的范围内超级" class="sect">§2.3.2。（b）</a>对于异常，两种方法的签名略有不同）。
                  				
               </p>
               <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中，团队<code>T</code>的角色<code>R1</code>覆盖了<code>S</code>隐式继承的方法<code>m()</code> 。 <code><strong>tsuper</strong> .m()</code>从<code>S.R1</code> （第13行<code><strong>tsuper</strong> .m()</code>调用重写的方法<code>m()</code> ）。
                  				
               </div>
            </div>
            <div class="subsect depth4" id="s1.3.1.g">
               <h4 class="subsect">（g） <span class="title">隐含继承超类型</span><a class="img" href="s1.3.1.g.html" title="PermaLink to（g）隐式继承超类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果角色类具有显式超类（使用<code>extends</code> ），则此关系将沿隐式继承继承。
                  				
               </p>
               <div class="codecomment">在代码<a href="#l1.3.1-1" class="listing">清单1.3.1-1</a>中， <code>T</code>的角色<code>R1</code>将<code>T.R0</code>作为其隐式继承的超类，因为超级团队中的相应角色<code><strong>extends R0</strong></code> （第3行）。
                  				
               </div>
               <p>覆盖隐式继承的超类由下面的<a href="s1.3.2.b.html" title="§1.3.2。（b）继承和覆盖extends子句" class="sect">§1.3.2。（b）管理</a> 。<br>已实现的接口列表沿隐式继承合并。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s1.3.1.h">
               <h4 class="subsect">（h） <span class="title">保持可见度</span><a class="img" href="s1.3.1.h.html" title="永久链接到（h）保持可见性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>角色类必须至少提供与隐式超级角色一样多的访问权限，否则会发生编译时错误（这与<a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#227965" class="ext">JLS§8.4.6.3类似</a> ）。由隐式继承覆盖的方法的访问权限遵循与正常覆盖相同的规则。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s1.3.1.i">
               <h4 class="subsect">（i） <span class="title">构造函数的动态绑定</span><a class="img" href="s1.3.1.i.html" title="PermaLink（i）构造函数的动态绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>使用<code>new</code>创建角色实例时，不仅动态绑定要实例化的类型（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ），但是调用的构造函数也是根据具体类型动态绑定的。<br>在角色构造函数中，所有<code>this(..)</code>和<code>super(..)</code>调用都是静态绑定到显式继承，并且动态地关于隐式继承。这意味着目标角色名称是静态确定的，但使用该名称时，将使用动态绑定确定合适的角色类型。
                  			<br>另见<a href="s2.5.a.html" title="§2.5。（a）使用抽象类进行创建" class="sect">§2.5。（a）</a>关于使用抽象角色类的构造函数。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s1.3.1.j">
               <h4 class="subsect">（j） <span class="title">覆盖和兼容性</span><a class="img" href="s1.3.1.j.html" title="PermaLink to（j）覆盖和兼容性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p><a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#228745" class="ext">JLS§8.4.6</a>的规则也适用于通过隐式继承继承的方法<em>和构造函数</em> 。
                  				
               </p>
            </div>
            <div class="subsect depth4" id="s1.3.1.k">
               <h4 class="subsect">（k） <span class="title">协变回报类型</span><a class="img" href="s1.3.1.k.html" title="PermaLink到（k）协变返回类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>给定一组<code>T1</code>与两个角色<code>R1</code>和<code>R2</code> ，其中<code>R2</code>明确地从继承<code>R1</code> ，两个角色定义一个方法<code>m</code>返回某种类型的<code>A</code> 。还给出了一个<code>T1</code> ， <code>T2</code>的子团队，其中<code>T2.R1</code>使用协变返回类型<code>B</code> （ <code>A</code>子类型）覆盖<code>m</code> ：</p>
               <div class="listing plain"><pre>    <b>公共</b> <b>团队</b> <b>类</b> T1 { <b>protected</b> <b>abstract</b> <b>class</b> R1 { <b>abstract</b> A m（）; } <b>protected</b> <b>class</b> R2 <b>扩展</b> R1 {A m（）{ <b>return</b> <b>new</b> A（）; <b>public</b> <b>team</b> <b>class</b> T2 <b>扩展</b> T1 { <b>protected</b> <b>class</b> R1 {@Override B m（）{ <b>return</b> <b>new</b> B（）; } <span class="error">//此声明呈现<b>类</b> T2。R2非法</span> }}</pre></div>
               <p>在这种情况下角色<code>T2.除非还使用至少为<code>B</code>的返回类型覆盖<code>m</code> ，否则R2</code>将是非法的。注意，实际错误发生在隐式继承的方法<code>T2.R2.m</code>在源代码中不可见，甚至是<code>T2.不需要在源代码中明确提及R2</code> 。编译器应将此标记为团队级别的不兼容性，因为团队必须以一致的方式专门化继承的角色。
                  				
               </p>
            </div>
            <h5 class="listing">示例代码（团队和角色）：</h5>
            <div class="listing example frame" id="l1.3.1-3">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">1</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">2</td>
                     <td><pre>  <b>受保护的</b> <b>类</b> MyRole {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">3</td>
                     <td><pre>字符串名称;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">4</td>
                     <td><pre>    <b>public</b> MyRole（String n）{name = n; }</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">五</td>
                     <td><pre>    <b>public</b> <b>void</b> print（）{System.out.println（“id =”+ name）; }</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">6</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">7</td>
                     <td><pre>  <b>protected</b> MyRole getRole（）{ <b>return</b> <b>new</b> MyRole（“Joe”）; }</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">8</td>
                     <td><pre>}</pre></td>
                  </tr>
               </table>
            </div>
            <div class="listing example frame" id="l1.3.1-4">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">10</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>类</b> MySubTeam <b>扩展了</b> MyTeamA {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">11</td>
                     <td><pre>  <b>受保护的</b> <b>类</b> MyRole {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">12</td>
                     <td><pre>    <b>INT</b>年龄;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">13</td>
                     <td><pre>    <b>public</b> <b>void</b> setAge（ <b>int</b> a）{age = a; }</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">14</td>
                     <td><pre>    <b>public</b> <b>void</b> print（）{</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">15</td>
                     <td><pre>tsuper.print（）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">16</td>
                     <td><pre>的System.out.println（ “年龄=” +年龄）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">17</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">18</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">19</td>
                     <td><pre>  <b>public</b> <b>void</b> doit（）{</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">20</td>
                     <td><pre>MyRole r = getRole（）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">21</td>
                     <td><pre>r.setAge（27）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">22</td>
                     <td><pre>r.print（）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">23</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">24</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">25</td>
                     <td><pre>...</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">26</td>
                     <td><pre>MySubTeam myTeam = <b>new</b> MySubTeam（）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">27</td>
                     <td><pre>myTeam.doit（）;</pre></td>
                  </tr>
               </table>
            </div>
            <h5 class="listing">程序输出</h5>
            <div class="listing example frame"><pre>id =乔年龄= 27岁</pre></div>
            <div class="codecomment">
               <h5>功效：</h5>
               <ul>
                  <li>根据<a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ， <code>MyTeamA</code>实施了<code>ITeam</code> （第1行）。
                  </li>
                  <li>为<code>MySubTeam.创建了隐式角色继承<code>MySubTeam.MyRole</code> （ <a href="#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ;第11行）。<br>如果我们使用虚构关键字<code>overrides</code>可视化此特殊继承，编译器将看到一个声明：<div class="listing plain"><pre><b>受保护的</b> <b>类</b> MyRole <em>重写MyTeamA.MyRole</em> {...}</pre></div>
                  </li>
                  <li>在<code>myTeam</code>上调用<code>getRole()</code> （第<code>myTeam</code>行）会创建一个<code>MySubTeam.实例<code>MySubTeam.MyRole</code>因为获取的角色<code>MyTeamA.MyRole</code>被<code>MySubTeam.覆盖<code>MySubTeam.MyRole</code>遵循隐式继承的规则（参见<a href="#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3.1。（e）</a> ）。
                     					 
                  </li>
                  <li>覆盖角色方法和访问继承的功能与往常一样。
                     					
                  </li>
                  <li>作为<a href="#s1.3.1.f" title="§1.3.1.(f) tsuper" class="sect">§1.3.1</a>的示例<a href="#s1.3.1.f" title="§1.3.1。（f）tsuper" class="sect">。（f）</a>参见调用<code>tsuper.print()</code> （第15行），它选择<code>MyTeamA.MyRole.print</code>的实现。
                     						
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s1.3.2.html" rel="next">§1.3.2常规角色继承&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a> &gt; <a class="nav" href="s1.3.html" rel="section">§1.3角色类的获取和隐式继承</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="0291.Howtodeveloptemplates.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<link href="_stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen"></link>
<link href="_stock/sysdoc.css" type="text/css" rel="stylesheet" media="print"></link>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>如何在如何使用模板扩展用户界面中开发模板</title>
   <style type="text/css" media="screen">.ButtonBox {
  background-image: url('_stock/gradient.jpg');
}
</style>
   </head>
   <body dir="ltr">
   <table width="100%" border="0" cellspacing="0" cellpadding="0"><tbody><tr>
   </tr><tr><td class="DocSetBox" width="25%">
   <p> </p>
   </td>
   <td class="ButtonBox" align="right" width="40%">
   <p> <a href="index.html"><img height="22" alt="[以前]" src="_stock/btn_prev_wt.gif" width="85" border="0"></a> <a href="Howtoregistertemplates.html"><img height="22" alt="[下一个]" src="_stock/btn_next_wt.gif" width="58" border="0"></a></p>
   </td>
   </tr></tbody></table>
   <hr noshade="" size="1">
   <p class="breadcrumbNav"><span class="separator">»</span> <a href="index.html">如何使用模板扩展用户界面</a> <span class="separator">»</span>如何开发模板</p>

   <hr noshade="" size="1">
   <div class="AuthoredContent">
    

</div><div class="Head1">

<h1>如何开发模板</h1>
</div><div class="Bodytext">
<p>模板构成驱动器的重要部分，以支持Eclipse框架工作中支持的各种用户界面类型的自动GUI生成。这些模板通常称为项目模板，因为它们用于支持现成项目的创建。例如，您可以定义模板以为一组构建配置创建基于GUI的简单<code class="filename">EXE</code>应用程序。
</p>
<p>项目模板是简单的XML文件，它遵循<code class="filename">TemplateDescriptorSchema.xsd</code>文件中定义的结构或模式。这些模板定义了为特定平台创建项目所需的输入和过程。输入定义所需的输入类型，例如文件，设置等。流程定义如何处理这些输入以创建特定类型的项目。
</p>
<p>“新建项目”向导根据模板定义的匹配条件列出所有可用模板。用户从列表中选择模板后，Template Engine插件将处理所选模板。插件根据模板是否需要用户输入生成后续向导页面。
</p>
<p>本文档详细介绍了编写项目模板的模式。模式文件<code class="filename">TemplateDescriptorSchema.xsd</code>定义了项目模板的结构，是<code class="filename">org.eclipse.cdt.core</code>插件的一部分。
</p>
<p>项目模板的结构或架构如下：</p>
<p class="CodeBlock"><code>&lt;模板<br>类型= “TemplateType”<br>版本=“版本”<br>供应商=“供应商”<br>修订=“版本”<br>笔者=“作者”<br>ID = “TemplateId”<br>label =“用户可见的模板标签”<br>description =“模板的简要说明”<br>预览图标=“icon.gif”&gt;<br><br>&lt;属性组<br>ID = “properyGroupId”<br>label =“属性组标签”<br>description =“属性组的简单描述”<br>type =“UIElement组的类型”<br>品牌图标=“icon.gif”&gt;<br>...<br>&lt;/属性组&gt;<br><br>&lt;方法&gt;<br>...<br>&lt;/过程&gt;<br><br>&lt;/模板&gt;</code></p>
<p>项目模板的根元素是<code>template</code> ，它提供以下属性或属性来描述模板：</p>
<ul>
<li>
<p>
<code>type</code> ：使用此属性指定模板类型。对于项目模板， <code>type</code>应为<code>ProjTempl</code> 。
</p>
</li><li>
<p>
<code>version</code> ：使用此属性指定主要版本</p>
</li><li>
<p>
<code>supplier</code> ：使用此属性指定提供模板的供应商的名称。
</p>
</li><li>
<p>
<code>revision</code> ：使用此属性指定模板的次要版本号。
</p>
</li><li>
<p>
<code>author</code> ：使用此属性指定模板作者的姓名。
</p>
</li><li>
<p>
<code>id</code> ：使用此属性指定模板的唯一名称。
</p>
</li><li>
<p>
<code>label</code> ：使用此属性指定模板的标签，其中简要描述了模板的用途。例如，如果要为Helloworld <code class="filename">EXE</code>应用程序定义模板，则标签可以是“HelloWorld <code class="filename">EXE</code> Application”。
</p>
</li><li>
<p>
<code>description</code> ：使用此属性提供模板的描述，当用户从可用模板列表中选择模板时，将向用户显示该描述。
</p>
<p>
<code>preview-icon</code> ：使用此属性指定要用作模板图标的<code class="filename">GIF</code>或<code class="filename">JPG</code>文件名。对图像没有约束，因为此属性是为了将来使用。
</p>
</li>
</ul>
<p><code>template</code>元素包含以下子元素：</p>
<ul>
<li>
<p>
<code>property-group</code> ：属性组元素表示“新建项目”向导中的向导页面。它列出了要显示给用户的所有字段，以便使用<code>property</code>元素进行输入。例如，您可以使用此元素定义要在“新建项目”向导的“ <em>项目目录”</em>页面中显示的所有输入字段。property-group的<em>id</em>属性用作Eclipse Help系统id（请参阅<code>org.eclipse.help.contexts</code> ）。上下文id的包含插件是<code>org.eclipse.cdt.ui</code> 。
</p>
</li><li>
<p>
<code>process</code> ：process元素根据用户输入值定义在Eclipse工作区中创建项目的过程。例如，如果用户将“include”指定为所有头文件的文件夹名称，则在此处定义按该名称创建文件夹并将所有头文件复制到其中的过程。
</p>
</li>
</ul>
<h4 class="subheading">属性组</h4>
<p>如前所述， <code>property-group</code>包括<code>property</code>元素，这些元素指定向导页面所需的所有输入字段。<code>property-group</code>可以包含任意数量的<code>property</code>元素。以下属性可用于描述属性组：</p>
<ul>
<li>
<p>
<code>id</code> ：使用此属性指定属性组的唯一ID。
</p>
</li><li>
<p>
<code>label</code> ：使用此属性指定属性组的名称，该名称显示为Template Engine生成的向导页面的标题。
</p>
</li><li>
<p>
<code>description</code> ：使用此属性提供属性组的简短描述，该描述显示在向导页面标题下方。
</p>
</li><li>
<p>
<code>type</code> ：此属性用于将来扩展。目前，唯一有效的值是：</p>
<ul>
<li>
<p>
<code>PAGES-ONLY</code> ：如果您希望所有属性都列在一个简单的页面中。
</p>

<!-- Constants currently unsupported
<li>
<p>
<code>PAGES-TAB</code>: If you want all the properties to be
displayed as tabs in a page. 
</p>
<li>
<p>
<code>PAGES-TREE</code>: If you want all the properties to be
displayed in a simple tree structure. 
</p>
<li>
<p>
<code>PAGES-TREE-TREE</code>: If you want all the properties to
be displayed in a multi-level tree structure. 
</p>
<li>
<p>
<code>PAGES-TAB-TREE</code>: If you want all the properties to be
displayed as tabs or as a tree structure. 
</p>
</li>
-->

</li></ul>
</li><li>
<p>
<code>branding-icon</code> ：使用此属性指定要用作属性<code class="filename">GIF</code>文件名。
</p>
</li>
</ul>
<h4 class="subheading">属性</h4>
<p>property-group元素包含的<code>property</code>元素的语法如下：</p>
<p class="CodeBlock"><code>&lt;财产<br>ID = “属性ID”<br>label =“用户可见的标签属性”<br>description =“财产的简要描述”<br>type =“属性的类型”<br>pattern =“预期属性的正则表达式”<br>default =“属性的默认值”<br>大小=“大小”<br>强制性=“真|假”<br>隐藏=“真|假”<br>坚持=“真|假”&gt;<br><br>&lt;项目<br>value =“项目的值”<br>label =“项目的用户可见标签”<br>...<br>&lt;/项目&gt;<br>&lt;/属性&gt;</code></p>
<p>以下是<code>property</code>元素的属性列表：</p>
<ul>
<li>
<p>
<code>id</code> ：使用此属性指定属性的唯一ID。
</p>
</li><li>
<p>
<code>label</code> ：使用此属性指定属性的名称，该名称在输入字段旁边的向导页面中显示为标签。
</p>
</li><li>
<p>
<code>description</code> ：使用此属性提供属性的简短描述，只要鼠标悬停在标签上，就会显示该属性。
</p>
</li><li>
<p>
<code>type</code> ：使用此属性指定属性类型。此属性的可能值为：</p>
<ul>
<li>
<p>
<code>input</code> ：如果需要文本输入框。
</p>
</li><li>
<p>
<code>multiline</code> ：如果你想要一个多行输入框。
</p>
</li><li>
<p>
<code>select</code> ：如果需要下拉组合框。
</p>
</li><li>
<p>
<code>boolean</code> ：如果你想要一个选项按钮。
</p>
</li><li>
<p>
<code>stringlist</code> ：如果你想要一个列表框。
</p>
</li><li>
<p>
<code>speciallist</code> ：如果你想要一个带按钮的列表框来添加和删除项目。
</p>
</li><li>
<p>
<code>browse</code> ：如果您想要一个打开文件（而不是目录）选择对话框的浏览按钮</p>
</li>
<li>
<p>
<code>browsedir</code> ：如果你想要一个打开目录选择对话框的浏览按钮</p>
</li>
</ul>
</li><li>
<p>
<code>pattern</code> ：使用此属性可以使用正则表达式指定属性的输入字符模式。有关正则表达式模式的更多信息，请参阅<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">java.util.regex的 Java API文档<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">。模式</a> 。
</p>
</li><li>
<p>
<code>default</code> ：使用此属性指定属性的默认值。
</p>
</li><li>
<p>
<code>size</code> ：使用此属性指定属性的大小。请注意，仅当属性类型为<code>input</code>或多<code>multiline</code> ，此属性才相关。
</p>
</li><li>
<p>
<code>mandatory</code> ：使用此属性指定属性是否为必需属性。此属性的值可以为<code>true</code>或<code>false</code> 。
</p>
</li><li>
<p>
<code>hidden</code> ：使用此属性指定属性是否对用户可见。此属性的值可以为<code>true</code>或<code>false</code> 。
</p>
</li><li>
<p>
<code>persist</code> ：使用此属性指定属性是否应保留其值。此属性的值可以为<code>true</code>或<code>false</code> 。
</p>
</li>
</ul>
<p>如果属性<code>type</code>为<code>select</code>或<code>stringlist</code> ，则可以包含<code>item</code>元素以指定要列出的项目。可以列出的项目数量没有限制。以下是<code>item</code>元素的语法：</p>
<p class="CodeBlock"><code>&lt;项目<br>value =“项目的值”<br>label =“项目的用户可见标签”<br>&lt;/项目&gt;</code></p>
<p>以下是<code>item</code>元素的属性列表：</p>
<ul>
<li>
<p>
<code>label</code> ：用于指定向用户显示的标签。
</p>
</li><li>
<p>
<code>value</code> ：用于为列表项指定唯一值。这将是宏扩展中使用的值。
</p>
</li></ul>
<h4 class="subheading">处理</h4>
<p>项目模板的根元素中的<code>process</code>元素根据所采用的输入定义创建项目时要遵循的流程。以下是此元素的语法：</p>
<p class="CodeBlock"><code>&lt;process type =“org.eclipse.cdt。{core | managedbuilder.core}。&lt;process type&gt;”&gt;<br>&lt;simple name =“name”value =“”/&gt;<br><br>&lt;complex name =“name”&gt;<br>...<br>&lt;/复杂&gt;<br><br>&lt;simple-array name =“values”&gt;<br>...<br>&lt;/简单阵列&gt;<br><br>&lt;complex-array name =“name”&gt;<br>...<br>&lt;/复杂阵列&gt;<br><br>&lt;/过程&gt;</code></p>
<p><code>process</code>元素定义单个流程。过程就像一个带有一组参数的过程。在类似的术语中， <code>process</code>元素定义过程。您需要指定进程所需的所有参数。在项目模板中，您需要为与其类型匹配的流程指定参数，并按指定的顺序指定。
</p>
<p>您可以使用<code>type</code>属性指定进程类型。例如，要将文件添加到项目，可以使用<code>org.eclipse.cdt.core.AddFiles</code>作为流程类型。
</p>
<p><code>process</code>元素可以包含以下子元素：</p>
<ul>
<li>
<p>
<code>simple</code> ：一个简单的字符串参数。在项目模板中，您需要使用<code>name</code>属性以及相应的<code>value</code>属性为参数指定名称。
</p>
<p>以下是显示此元素用法的示例：</p>
<p class="CodeBlock"><code>&lt;simple name =“name”value =“value”/&gt;</code></p>
</li><li>
<p>
<code>simple-array</code> ：一个简单的字符串数组参数。在项目模板中，您需要使用<code>name</code>属性以及相应的<code>element</code>子<code>element</code>为参数指定名称。每个带有相应<code>value</code>属性的<code>simple-array</code>元素可以包含任意数量的<code>element</code>子元素。
</p>
<p>以下是显示此元素用法的示例：</p>
<p class="CodeBlock"><code>&lt;simple-array name =“values”&gt;<br>&lt;element value =“value1”/&gt;<br>&lt;element value =“value2”/&gt;<br>&lt;/简单阵列&gt;</code></p>
</li><li>
<p>
<code>complex</code> ： <code>complex</code>参数将任意数量的<code>simple</code> ， <code>simple-array</code>和<code>complex</code>参数组合在一起。在项目模板中，您需要使用<code>name</code>属性以及相应的子元素为参数指定名称。
</p>
<p>以下是显示此元素用法的示例：</p>
<p class="CodeBlock"><code>&lt;complex name =“name”&gt;<br>&lt;元件&gt;<br>&lt;simple name =“name”value =“value”/&gt;<br>&lt;simple-array name =“values”&gt;<br>&lt;element value =“value1”/&gt;<br>&lt;element value =“value2”/&gt;<br>&lt;/简单阵列&gt;<br>&lt;/元件&gt;<br>&lt;/复杂&gt;</code></p>
</li><li>
<p>
<code>complex-array</code> ：复杂数组参数。此参数的每个元素都是<code>complex</code>类型。在项目模板中，您需要使用<code>name</code>属性以及相应的<code>element</code>子<code>element</code>为参数指定名称。每个complex-array元素可以包含任意数量的元素子元素，并带有相应的复杂类型参数。
</p>
<p>以下是显示此元素用法的示例：</p>
<p class="CodeBlock"><code>&lt;complex-array name =“values”&gt;<br>&lt;元件&gt;<br>&lt;simple name =“name1”value =“value1”/&gt;<br>&lt;simple name =“name2”value =“value2”/&gt;<br>&lt;simple name =“name3”value =“value3”/&gt;<br>&lt;/元件&gt;<br>&lt;元件&gt;<br>&lt;simple name =“name4”value =“value4”/&gt;<br>&lt;simple name =“name5”value =“value5”/&gt;<br>&lt;simple name =“name6”value =“value6”/&gt;<br>&lt;/元件&gt;<br>&lt;/复杂阵列&gt;</code></p>
</li>
</ul>
<h4 class="subheading">流程类型</h4>
<p>流程类型是流程过程的原型。它定义了完成过程所需的参数。例如，要复制文件，您需要其源和目标信息，这些信息可以定义为复制过程的参数。
</p>
<p>Template Engine插件使用扩展点<code class="filename">org.eclipse.cdt.core.templateProcessTypes</code>提供一组进程类型。使用这些流程类型，您可以在模板中描述流程。例如，您可以通过提供源文件夹和目标文件夹名称来描述复制过程。
</p>
<p>以下是模板引擎提供的流程类型列表：</p>
<!--<ul>
<li>
<p>
<strong>NewProject</strong>: It defines all the parameters required for a
new C/C++ project and provides the fully qualified name of the class, which
processes these parameters.
</p>
<p>
Here is a list of parameters defined by this process type:
</p>
<ul>
<li>
<p>
<em>Name</em>: You use this parameter to specify the name of
the project. It is of type <code>simple</code>.
</p>
<li>
<p>
<em>projectType</em>: You use this parameter to specify the
type of the project. It is of type <code>simple</code>.
</p>
<li>
<p>
<em>location</em>: You use this parameter to specify the
location of the project. It is of type <code>simple</code>.
</p>
<li>
<p>
<em>targetType</em>: You use this parameter to specify the
type of the target binary. It is of type <code>simple</code>.
</p>
<li>
<p>
<em>configs</em>: You use this parameter to specify the build
configurations for the project. It is of type <code>simple</code>.
</p>
</li>
</ul> -->
<li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>NewManagedProject</strong> ：它定义了新托管项目所需的所有参数，并提供了类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>名称</em> ：您可以使用此参数指定托管项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>projectType</em> ：您可以使用此参数指定托管项目的类型。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>location</em> ：您可以使用此参数指定托管项目的位置。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>targetType</em> ：您可以使用此参数指定目标二进制文件的类型。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>配置</em> ：使用此参数指定托管项目的构建配置。它很<code>simple</code> 。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>复制</strong> ：它定义复制文件所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>files</em> ：您可以使用此参数列出要复制的文件。它是<code>complexArrary</code>类型。要复制的每个文件由baseType <code>element</code>表示，该<code>element</code>包含以下<code>simple</code>类型：</p>
<ul>
<li>
<p>
<em>source</em> ：用于指定文件系统中的源文件位置。
</p>
</li><li>
<p>
<em>target</em> ：使用此选项指定文件的目标位置。
</p>
</li><li>
<p>
<em>replaceable</em> ：使用此标志指定是否应替换文件（如果在<code>target</code>位置中找到该文件）。
</p>
</li>
</ul>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>附加</strong> ：它定义将文件附加到项目所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。有关参数的更多信息，请参阅上述<code>Copy</code>过程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>AddFile</strong> ：它定义了向项目添加文件所需的所有参数，并提供了类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定要将文件复制到的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>file</em> ：使用此参数包含与source，target和replaceable相关的信息。它是<code>complex</code>类型。有关参数的更多信息，请参阅上述<code>Copy</code>过程类型。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>AddFiles</strong> ：它定义了向项目添加文件所需的所有参数，并提供了类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定要将文件复制到的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>files</em> ：使用此参数包含与source，target和replaceable相关的信息。它是<code>complexArray</code>类型。有关参数的更多信息，请参阅上述<code>Copy</code>过程类型。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>CreateSourceFolder</strong> ：它定义为项目中的源文件创建文件夹所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定要将文件复制到的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>path</em> ：使用此参数指定相对于项目文件夹的路径，其中应创建源文件的文件夹。它很<code>simple</code> 。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>AddLink</strong> ：它定义了创建链接文件所需的所有参数，并提供了类的完全限定名称，用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定应在其中创建链接文件的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>filePath</em> ：使用此参数指定原始文件相对于项目文件夹的路径。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>targetPath</em> ：使用此参数指定相对于项目文件夹的目标位置，其中应创建到原始文件的链接文件。它很<code>simple</code> 。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>CreateIncludeFolder</strong> ：它定义为项目中的头文件创建文件夹所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。有关参数的信息，请参阅上述<code>CreateSourceFolder</code>流程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>ExcludeResources</strong> ：它定义从CDT项目中排除资源所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定要排除其资源的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>configIdPattern</em> ：使用此参数指定<code>java.util.regex.的正则表达式<code>java.util.regex.用于匹配项目配置ID的Pattern</code>语法。匹配<em>filePatterns</em>参数中给出的任何正则表达式的资源将从所有匹配的项目配置中排除。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>filePatterns</em> ：使用此参数指定<code>java.util.regex.的<code>simple-array</code> <code>java.util.regex.用于匹配要排除的项目资源的Pattern</code> 。将匹配的路径是工作空间相对（包括项目文件夹）并使用正斜杠作为文件分隔符。这个参数是一个数组纯粹是为了允许逻辑上单独的模式分别给出而不是作为一个大字符串。如果任何正则表达式匹配，则匹配配置将排除有问题的资源。对于所有匹配的项目配置，将排除与<em>filePatterns</em>参数中给出的任何正则表达式匹配的资源。它是<code>simple-array</code>类型。
</p></li><li>
<p>
<em>invertedConfigMatching</em> ：如果将其设置为“true”，则将反转与任何指定文件模式匹配的资源的配置集。这使您可以指定不应排除文件的配置，而无需知道可能存在的其他配置。它很<code>simple</code> 。
</p>
</li>
</ul>

</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>SetMBSStringOptionValue</strong> ：它定义创建字符串选项值所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>projectName</em> ：使用此参数指定为其创建字符串选项的项目的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>resourcePaths</em> ：使用此参数指定资源的路径。它是<code>complexArray</code>类型。要创建的每个资源patth由baseType <code>element</code>表示，该<code>element</code>包含以下<code>simple</code>类型：</p>
<ul>
<li>
<p>
<em>id</em> ：使用此参数指定资源路径的唯一ID。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>value</em> ：使用此参数指定资源路径的值。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>path</em> ：使用此参数指定资源的路径。它很<code>simple</code> 。
</p>
</li>
</ul>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>SetMBSStringListOptionValues</strong> ：它定义创建选项值字符串列表所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。所需的参数类似于<code>SetMBSStringOptionValue</code>流程类型的参数，唯一的区别是每个资源路径都有一个选项值列表。有关参数的信息，请参阅上述<code>SetMBSStringOptionValue</code>流程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>SetMBSBooleanOptionValue</strong> ：它定义创建布尔选项值所需的所有参数，并提供类的完全限定名称，该名称用于处理这些参数。所需的参数类似于<code>SetMBSStringOptionValue</code>进程类型的参数，唯一的区别是此进程类型用于创建布尔选项值。有关参数的信息，请参阅上述<code>SetMBSStringOptionValue</code>流程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>AppendToMBSStringOptionValue</strong> ：它定义将字符串选项值附加到现有字符串选项所需的所有参数。它还提供了类的完全限定名称，用于处理这些参数。有关参数的信息，请参阅上述<code>SetMBSStringOptionValue</code>流程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>AppendToMBSStringListOptionValues</strong> ：它定义将选项值的字符串列表附加到选项值的现有字符串列表所需的所有参数。它还提供了类的完全限定名称，用于处理这些参数。有关参数的信息，请参阅上述<code>SetMBSStringListOptionValues</code>过程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>AppendCreate</strong> ：它定义在项目中追加或创建文件所需的所有参数。它还提供了类的完全限定名称，用于处理这些参数。有关参数的信息，请参阅上述<code>AddFiles</code>流程类型。
</p>
</li><li>
<p>
<em>org.eclipse.cdt.core。</em><strong>CreateResourceIdentifier</strong> ：它定义追加或创建资源标识符所需的所有参数。它还提供了类的完全限定名称，用于处理这些参数。
</p>
<p>以下是此流程类型定义的参数列表：</p>
<ul>
<li>
<p>
<em>valueName</em> ：使用此属性指定资源标识符的名称。它很<code>simple</code> 。
</p>
</li><li>
<p>
<em>appName</em> ：使用此属性指定将使用此资源标识符的应用程序。它很<code>simple</code> 。
</p>
</li>
</ul>
</li><li>
<p>
<em>org.eclipse.cdt.managedbuilder.core。</em><strong>GenerateMakefileWithBuildDescription</strong> ：</p>
<ul>
<li>
<p><em>projectName：</em>使用此参数指定将从当前项目构建信息生成makefile的项目的名称。它很<code>simple</code> 。
</p>
</li>
</ul>
<p><br>编写项目模板后，将其注册到Eclipse以使其可用。有关此内容的更多信息，请参阅<a href="Howtoregistertemplates.html#Howto%2eregister%2etemplates">如何使用Eclipse注册模板</a> 。
</p>
<a name="1.38"></a>
</li></div><div class="Head2">
<hr size="2" noshade="">
<h2>也可以看看：</h2>
</div><div class="Bodytext">
<ul>
<li>
<p>
<a href="Howtoregistertemplates.html#Howto%2eregister%2etemplates">如何使用Eclipse注册模板</a>
</p>
</li><li>
<p>
<a href="exampletemplate.html#Corona%2ecustomguide%2eexampletemplate">示例模板</a>
</p>
</li>
</ul>

   </div><div class="Footer">
   <hr noshade="" size="1">
   <table cellpadding="0" cellspacing="0" border="0" width="100%">
     <tr>
       <td class="ButtonBottomBox" align="right" height="12" width="67%">
         <p>
           <a href="index.html"><img height="22" alt="[以前]" src="_stock/btn_prev.gif" width="85" border="0"></a>
	   <a href="#_top"><img alt="[最佳]" src="_stock/btn_top.gif" align="bottom" border="0"></a>
           <a href="Howtoregistertemplates.html"><img height="22" alt="[下一个]" src="_stock/btn_next.gif" width="58" border="0"></a>
         </p>
       </td>
     </tr>
   </table>
   </div>
   </body>
   </html><html id="3305.extensions-properties_provide_custom_widget_advanced.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>扩展 -  properties_provide_custom_widget_advanced</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SiriusPropertiesAdvancedCustomWidget">Sirius Properties  - 高级自定义小工具</h1>
		<h2 id="Goal">目标</h2>
		<p>使用高级自定义窗口小部件方法，我们的目标是为Sirius说明符创建具有出色用户体验的自定义窗口小部件。将在开发基本自定义窗口小部件后创建此自定义窗口小部件。您应该首先熟悉这种方法。</p>
		<h2 id="Strategy">战略</h2>
		<p>为了创建自定义窗口小部件，我们必须考虑将与我们的工作交互的两种用户，Sirius说明符和最终用户。通过这种高级方法，我们将为最终用户创建一个表小部件，为操作它的Sirius说明符提供良好的体验。</p>
		<h3 id="SpecificationofthecustomwidgetinEclipseSirius">Eclipse Sirius中自定义小部件的规范</h3>
		<p>高级自定义小部件的规范将是与基本自定义小部件的主要区别。使用基本方法时，Sirius说明符必须使用通用且平淡的自定义窗口小部件描述，使用高级方法，我们将为Sirius说明符创建一个真正的定义来进行操作。</p>
		<p>作为第一步，我们希望贡献一个模型，以便在我们的Sirius说明符的odesign文件中显示。为此，您必须创建一个名为<code>com.example.awesomeproject.sirius.properties.ext.widgets.table</code>的插件，该插件在名为model的文件夹中包含名为<code>properties-ext-widgets-table.ecore</code>的Ecore模型。在此Ecore模型中，您必须加载资源<code>properties.ecore</code>用于在odesign中定义Properties视图描述。这个元模型可以在EPackage注册表中使用其NsURI <code>http://www.eclipse.org/sirius/properties/1.0.0</code> 。</p>
		<p>加载此资源后，为您的EPackage（根元素）指定名称NsPrefix和NsURI，例如：</p>
		<ul>
			<li>名称： <code>propertiesextwidgetstable</code>
			</li>
			<li>NsPrefix： <code>properties-ext-widgets-table</code>
			</li>
			<li>NsURI： <code>http://www.example.com/awesomeproject/properties/ext/widgets/table</code> ： <code>http://www.example.com/awesomeproject/properties/ext/widgets/table</code>
			</li>
		</ul>
		<p>之后，您可以在EPackage下创建一个EClass，其名称为<code>ExtTableDescription</code> ，并且EClass <code>WidgetDescription</code>为超类型。对于我们的示例，此EClass应包含两个名为<code>onClickExpression</code>和<code>valueExpression</code> ，两者都应具有<code>InterpretedExpresion</code>类型。
		</p>
		<p>然后，您可以在同一存储库中为Ecore模型创建genmodel文件。确保将<em>运行时版本</em>属性设置为<em>2.3</em>配置您的<code>genmodel</code> ，以便生成的Java与Sirius的“父”元模型兼容。启动模型的生成及其编辑支持将生成两个插件：</p>
		<ul>
			<li>Sirius Properties模型扩展： <code>com.example.awesomeproject.sirius.properties.ext.widgets.table</code>
			</li>
			<li>Sirius Properties模型扩展编辑支持： <code>com.example.awesomeproject.sirius.properties.ext.widgets.table.edit</code>
			</li>
		</ul>
		<h3 id="SpecificationofthecustomwidgetinEclipseEEF">Eclipse EEF中自定义窗口小部件的规范</h3>
		<p>Eclipse EEF具有独立于Eclipse Sirius的运行时，因此必须将odesign文件中存在的小部件定义转换为可由Eclipse EEF维护的定义。对于大多数现有概念，这种转换是非常基本的，因为它只涉及将Sirius概念直接转换为类似的EEF概念，但两种领域特定的语言都有不同的角色。</p>
		<p>Eclipse Sirius Properties DSL用作Eclipse Sirius说明符的用户界面，而Eclipse EEF DSL是运行时解释的模型。完全可能，甚至建议，在Sirius Properties DSL的扩展中定义高级概念，这些概念对于Sirius说明符应该是用户友好的，并且保持从扩展转换的EEF DSL原始概念的扩展Sirius Properties DSL。</p>
		<p>您现在必须使用名为<code>eef-ext-widgets-table.ecore</code>的模型文件夹和Ecore模型创建名为<code>com.example.awesomeproject.eef.ext.widgets.table</code>的第三个插件。在此模型中，您应该加载包含您必须扩展的EEF DSL的资源<code>eef.ecore</code> 。您可以使用其NsURI <code>http://www.eclipse.org/eef</code>在EPackage注册表中找到它。加载EEF DSL后，您可以设置根EPackage的属性：</p>
		<ul>
			<li>姓名： <code>eefextwidgetstable</code>
			</li>
			<li>NsPrefix： <code>eef-ext-widgets-table</code>
			</li>
			<li>NsURI： <code>http://www.example.com/awesomeproject/eef/ext/widgets/table</code> ： <code>http://www.example.com/awesomeproject/eef/ext/widgets/table</code>
			</li>
		</ul>
		<p>在这个根EPackage下，您现在可以创建名为<code>EEFExtTableDescription</code> ，它应该将<code>EEFWidgetDescription</code>作为超类型。对于我们的示例，此EClass应包含两个名为<code>onClickExpression</code>和<code>valueExpression</code> ，两者都应具有<code>EString</code>类型。在我们的示例中，Sirius DSL和EEF DSL的扩展具有相同的属性，因为我们使用的是一个非常简单的示例。
		</p>
		<p>您现在可以为EEF DSL的扩展创建genmodel并生成模型的代码（此处不需要编辑支持）。您现在将有三个插件：</p>
		<ul>
			<li>Sirius Properties模型扩展： <code>com.example.awesomeproject.sirius.properties.ext.widgets.table</code>
			</li>
			<li>Sirius Properties模型扩展编辑支持： <code>com.example.awesomeproject.sirius.properties.ext.widgets.table.edit</code>
			</li>
			<li>EEF模型扩展： <code>com.example.awesomeproject.eef.ext.widgets.table</code>
			</li>
		</ul>
		<h3 id="ContributionoftheconverterfromSiriustoEEF">转换器从Sirius到EEF的贡献</h3>
		<p>既然您已经扩展了Sirius Properties DSL和EEF DSL，那么您需要告知Sirius网桥如何将您的扩展中的概念转换为Sirius DSL转换为EEF概念。为此，可以使用扩展点来提供IDescriptionConverter。此转换器必须依赖于Eclipse EEF的Sirius桥接器，并且至少是Sirius Properties DSL和EEF DSL的扩展。因此，此代码必须进入另一个插件，因为在现有插件上具有这些依赖性将违反最佳实践。因此，我们将创建一个名为<code>com.example.awesomeproject.sirius.ui.properties.ext.widgets.table</code>的第四个插件。在此插件中，我们将使用以下扩展名声明我们的描述转换器。
		</p>
		<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;？eclipse版本=“3.4”？&gt; &lt;plugin&gt; &lt;extension point =“org.eclipse.sirius.ui.properties.descriptionConverter”&gt; &lt;descriptor class =“com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.internal。ExtTableDescriptionConverter“description =”％tableDescriptionConverter。描述“id =”com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.descriptionConverter“label =”％tableDescriptionConverter。标签“&gt; &lt;/ descriptor&gt; &lt;/ extension&gt; &lt;/ plugin&gt;</pre>
		<p>
			<br>从Sirius DSL到EEF DSL的转换分为两部分，首先使用IDescriptionConverter转换描述，然后使用IDescriptionLinkResolver解析某些链接。在我们的例子中，描述转换器将仅用于将<code>ExtTableDescription</code>的实例转换为<code>EEFExtTableDescription</code> ，我们不会使用描述链接解析器，因为它在这里<code>EEFExtTableDescription</code> 。
		</p>
		<pre>package com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.internal; import java.util。地图; import com.example.awesomeproject.eef.ext.widgets.table。EEFExtTableDescription; import com.example.awesomeproject.eef.ext.widgets.table。EefExtWidgetsTableFactory; import org.eclipse.emf.ecore。EObject; import com.example.awesomeproject.sirius.properties.ext.widgets.table。ExtTableDescription; import org.eclipse.sirius.ui.properties.api。DescriptionCache; import org.eclipse.sirius.ui.properties.api。IDescriptionConverter;公共类ExtTableDescriptionConverter实现IDescriptionConverter {@Override public boolean canHandle（EObject description）{返回描述instanceof ExtTableDescription; } @Override public EObject convert（EObject description，Map &lt;String，Object&gt; parameters，DescriptionCache cache）{if（描述instanceof ExtTableDescription）{ExtTableDescription \ textTableDescription =（ExtTableDescription）描述; EEFExtTableDescription eefExtTableDescription = EefExtWidgetsTableFactory.eINSTANCE.createEEFExtTableDescription（）; eefExtTableDescription.setIdentifier（extTableDescription.getIdentifier（））; eefExtTableDescription.setHelpExpression（extTableDescription.getHelpExpression（））; eefExtTableDescription.setIsEnabledExpression（extTableDescription.getIsEnabledExpression（））; eefExtTableDescription.setLabelExpression（extTableDescription.getLabelExpression（））; eefExtTableDescription.setValueExpression（extTableDescription.getValueExpression（））; eefExtTableDescription.setOnClickExpression（extTableDescription.getOnClickExpression（））; //让我们不要忘记为其他转换器填充缓存或链接解析器cache.put（extTableDescription，eefExtTableDescription）; return eefExtTableDescription; } return null; }}</pre>
		<p>
			<br>IDescriptionConverter可用于将Sirius Properties DSL中的任何元素转换为EEF DSL元素。为了支持自定义小部件，您只需处理自己的对象，但仍可以从Sirius Properties DSL修改其他类型的对象。因此，此机制可用于在运行时动态修改“属性”视图的描述中的任何内容。几乎从不使用IDescriptionConverter的这种用法，它对于极端高级用户来说是一种非常强大的机制。
		</p>
		<p>为了帮助开发人员将他们的Sirius实体转换为EEF实体，可以使用多种可能的超类：</p>
		<ul>
			<li>org.eclipse.sirius.ui.properties.api。AbstractDescriptionConverter  - 具有实用方法的通用超类</li>
			<li>org.eclipse.sirius.ui.properties.api。DefaultDescriptionConverter  - 用于基本转换的转换器</li>
			<li>org.eclipse.sirius.ui.properties.api。DefaultDescriptionWithInitialOperationConverter  - 支持将基本操作转换为正则表达式的转换器</li>
			<li>org.eclipse.sirius.ui.properties.api。DefaultStyleDescriptionConverter  - 支持样式的转换器</li>
		</ul>
		<h3 id="ContributionofthepreprocessorfromSiriuswithextensibilityfeaturestoflattenSirius">天狼星预处理器对可扩展性特征的贡献使天狼星变平</h3>
		<p>既然您已经对Sirius Properties DSL进行了扩展，那么您需要告知Sirius网桥如何将具有可扩展性的新小部件中的概念转换为Sirius DSL，而无需扩展或覆盖机制。为此，可以使用扩展点来提供IDescriptionPreprocessor。这个预处理器必须依赖Sirius桥。因此，此代码必须与转换器进入相同的插件以获得最佳实践。因此，我们将为名为<code>com.example.awesomeproject.sirius.ui.properties.ext.widgets.table</code>的插件做出贡献。在这个插件中，我们将使用以下扩展声明我们的描述预处理器。
		</p>
		<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;？eclipse版本=“3.4”？&gt; &lt;plugin&gt; &lt;extension point =“org.eclipse.sirius.ui.properties.descriptionPreprocessor”&gt; &lt;descriptor class =“com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.internal。ExtTableDescriptionPreprocessor“description =”％tableDescriptionPreprocessor。描述“id =”com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.descriptionPreprocessor“label =”％tableDescriptionPreprocessor。标签“&gt; &lt;/ descriptor&gt; &lt;/ extension&gt; &lt;/ plugin&gt;</pre>
		<p>
			<br>从带有扩展/覆盖的Sirius DSL到Sirius DSL的转换分为两部分，首先使用IDescriptionPreprocessor转换描述，然后使用IDescriptionLinkResolver解析某些链接。在我们的例子中，描述预处理器将简单地用于转换<code>ExtTableDescription</code>的实例，并扩展为展平的<code>ExtTableDescription</code>而不扩展/覆盖，我们不会使用描述链接解析器，因为它在这里<code>ExtTableDescription</code> 。
		</p>
		<pre>package com.example.awesomeproject.sirius.ui.properties.ext.widgets.table.internal; import java.util。地图; import com.example.awesomeproject.eef.ext.widgets.table。EEFExtTableDescription; import com.example.awesomeproject.eef.ext.widgets.table。EefExtWidgetsTableFactory; import org.eclipse.emf.ecore。EObject; import com.example.awesomeproject.sirius.properties.ext.widgets.table。ExtTableDescription; import org.eclipse.sirius.ui.properties.api。DescriptionCache; import org.eclipse.sirius.ui.properties.api。IDescriptionPreprocessor; public class ExtTableDescriptionPreprocessor extends PreconfiguredPreprocessor &lt;ExtTableDescription&gt; {@Override public boolean canHandle（EObject description）{return description instanceof ExtTableDescription; }}</pre>
		<p>
			<br>IDescriptionPreprocessor可用于将带有扩展/覆盖的Sirius Properties DSL中的任何元素转换为扁平的Sirius DSL。</p>
		<p>为了帮助开发人员将他们的Sirius实体转换为Sirius flatten实体，可以使用多种可能的超类：</p>
		<ul>
			<li>org.eclipse.sirius.ui.properties.api。DefaultDescriptionPreprocessor  - 基本转换的预处理器</li>
			<li>org.eclipse.sirius.ui.properties.api。DefaultDescriptionPreprocessorWithFiltering  - 预处理器，支持忽略某些功能并复制其他一些功能的值。这意味着在预处理产生的模型中，不会复制或继承忽略的值。</li>
			<li>org.eclipse.sirius.ui.properties.api。PreconfiguredPreprocessor  - 通过忽略大多数情况支持的预处理器：扩展引用，扩展机制的所有过滤器以及通过复制：动作，初始操作，样式，条件样式。</li>
		</ul>
		<h3 id="ContributionofthePropertiessectionfortheodesign">属性部分对odesign的贡献</h3>
		<p>如果您尝试在设计编辑器中编辑Sirius DSL的扩展，您会发现它不起作用。为了能够查看窗口小部件的属性，在我们的示例中是<code>onClickExpression</code>和<code>valueExpression</code> ，您需要贡献给odesign编辑器的Properties视图。由于此贡献需要依赖于用于odesign编辑器的Properties视图的框架，因此需要另一个名为<code>com.example.awesomeproject.sirius.editor.properties.ext.widgets.table</code>插件，其依赖性至少为：</p>
		<ul>
			<li>com.example.awesomeproject.sirius.properties.ext.widgets.table</li>
			<li>com.example.awesomeproject.sirius.properties.ext.widgets.table.edit</li>
			<li>org.eclipse.ui.views.properties.tabbed</li>
			<li>org.eclipse.sirius.editor</li>
		</ul>
		<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;？eclipse版本=“3.4”？&gt; &lt;plugin&gt; &lt;extension point =“org.eclipse.ui.views.properties.tabbed.propertySections”&gt; &lt;propertySections contributorId =“org.eclipse.sirius.editor.editorPlugin。SiriusEditorContributor“&gt; &lt;propertySection afterSection =”properties.section.widgetDescription。IsEnabledExpression“class =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal。ExtTableDescriptionValueExpressionPropertySection“filter =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal。ExtTableDescriptionValueExpressionFilter“id =”properties.section.extTableDescription.valueExpression“tab =”viewpoint.tab.general“&gt; &lt;input type =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.propertiesextwidgetstablee。ExtTableDescription“&gt; &lt;/ input&gt; &lt;/ propertySection&gt; &lt;propertySection afterSection =”properties.section.extTableDescription.valueExpression“class =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal。ExtTableDescriptionOnClickExpressionPropertySection“filter =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal。ExtTableDescriptionOnClickExpressionFilter“id =”properties.section.extTableDescription.valueExpression“tab =”viewpoint.tab.general“&gt; &lt;input type =”com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.propertiesextwidgetstablee。ExtTableDescription“&gt; &lt;/ input&gt; &lt;/ propertySection&gt; &lt;/ propertySections&gt; &lt;/ extension&gt; &lt;/ plugin&gt;</pre>
		<p>
			<br>为了显示值表达式和单击表达式的文本字段，将需要两个属性部分。
		</p>
		<pre>package com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal; import org.eclipse.emf.ecore。EStructuralFeature; import org.eclipse.sirius.editor.properties.filters.common。ViewpointPropertyFilter; import com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.propertiesextwidgetstablee。PropertiesExtTablePackage;公共类ExtTableDescriptionOnClickExpressionFilter扩展了ViewpointPropertyFilter {@Override protected EStructuralFeature getFeature（）{return PropertiesExtTablePackage.eINSTANCE.getExtTableDescription_OnClickExpression（）; } @Override protected boolean isRightInputType（Object arg0）{return arg0 instanceof com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.propertiesextwidgetstablee。ExtTableDescription; }}</pre>
		<p>
			<br>两个过滤器看起来几乎相同，唯一的区别是它们将返回的结构特征。
		</p>
		<pre>package com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.internal; import org.eclipse.emf.ecore。EAttribute; import org.eclipse.sirius.editor.editorPlugin。SiriusEditor; import org.eclipse.sirius.editor.properties.sections.common。AbstractTextWithButtonPropertySection; import org.eclipse.sirius.editor.tools.api.assist。TypeContentProposalProvider; import org.eclipse.sirius.editor.tools.internal.presentation。TextWithContentProposalDialog; import com.example.awesomeproject.sirius.editor.properties.ext.widgets.table.propertiesextwidgetstablee。PropertiesExtTablePackage; import org.eclipse.swt。SWT; import org.eclipse.swt.events。SelectionAdapter; import org.eclipse.swt.events。SelectionEvent; import org.eclipse.swt.events。SelectionListener中; import org.eclipse.swt.layout。FormAttachment; import org.eclipse.swt.layout。FORMDATA; import org.eclipse.swt.widgets。综合; import org.eclipse.ui.views.properties.tabbed。TabbedPropertySheetPage; @SuppressWarnings（“restriction”）公共类ExtTableDescriptionOnClickExpressionPropertySection扩展AbstractTextWithButtonPropertySection {@Override protected String getDefaultLabelText（）{return“On Click Expression”; // $ NON-NLS-1 $} @Override protected String getLabelText（）{String labelText; labelText = super.getLabelText（）+“*：”; // $ NON-NLS-1 $ return labelText; } @Override public EAttribute getFeature（）{return PropertiesExtTablePackage.eINSTANCE.getExtTableDescription_OnClickExpression（）; } @Override protected Object getFeatureValue（String newText）{return newText; } @Override protected boolean isEqual（String newText）{return this.getFeatureAsText（）。equals（newText）; } @Override public void createControls（Composite parent，TabbedPropertySheetPage tabbedPropertySheetPage）{super.createControls（parent，tabbedPropertySheetPage）; text.setToolTipText（getToolTipText（））; / * *我们设置颜色，因为它是InterpretedExpression * / text.setBackground（SiriusEditor.getColorRegistry（）。get（“yellow”））; // $ NON-NLS-1 $ TypeContentProposalProvider.bindPluginsCompletionProcessors（this，text）; FormData data = new FormData（）; data.top = new FormAttachment（text，0，SWT.TOP）; data.left = new FormAttachment（nameLabel）; nameLabel.setFont（SiriusEditor.getFontRegistry（）获取（ “要求”））; // $ NON-NLS-1 $} @Override protected SelectionListener createButtonListener（）{return new SelectionAdapter（）{@Override public void widgetSelected（SelectionEvent e）{TextWithContentProposalDialog dialog = new TextWithContentProposalDialog（composite.getShell（），ExtTableDescriptionOnClickExpressionPropertySection.this， text.getText（））; dialog.open（）; text.setText（dialog.getResult（））; handleTextModified（）; }}; } @Override protected String getPropertyDescription（）{return“”; // $ NON-NLS-1 $}}</pre>
		<p>
			<br>此属性部分将在odesign编辑器的Properties视图中创建一个文本字段和标签，以便让Sirius说明符编辑表的<code>onClickExpression</code> 。我们的文本字段将具有与Sirius使用的常规黄色文本字段相同的显示和特征。
		</p>
		<h3 id="Updatetothepluginsofourbasicwidgetapproach">更新我们的基本小部件方法的插件</h3>
		<p>现在我们可以在基本方法中重用我们的工作，但这次使用我们自己的特定DSL，而不是重用EEF DSL中的CustomElements。首先，我们必须修改生命周期管理器提供程序以支持我们的EEFExtTableDescription。</p>
		<pre>package com.example.awesomeproject.eef.ide.ui.ext.widgets.table.internal; import org.eclipse.eef。EEFControlDescription; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.ide.ui.api.widgets。IEEFLifecycleManager; import org.eclipse.eef.ide.ui.api.widgets。IEEFLifecycleManagerProvider; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager;公共类TableLifecycleManagerProvider实现IEEFLifecycleManagerProvider {/ ** *支持的控件描述的标识符。* / private static final String SUPPORTED_ID =“com.example.awesomeproject.sirius.properties.ext.widgets.table”; // $ NON-NLS-1 $ @Override public boolean canHandle（EEFControlDescription controlDescription）{//仅支持具有正确标识符的自定义小部件返回SUPPORTED_ID.equals（controlDescription.getIdentifier（））&amp;&amp; controlDescription instanceof EEFCustomWidgetDescription; } @Override public IEEFLifecycleManager getLifecycleManager（EEFControlDescription controlDescription，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{if（controlDescription instanceof EEFCustomWidgetDescription）{return new TableLifecycleManager（（EEFCustomWidgetDescription）controlDescription，variableManager，interpreter，contextAdapter）;抛出新的IllegalArgumentException（）; }}</pre>
		<p>
			<br>现在我们可以修改我们的生命周期管理器来支持我们的EEFExtTableDescription。
		</p>
		<pre>package com.example.awesomeproject.eef.ide.ui.ext.widgets.table.internal; import java.util.function。消费者; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef。EEFWidgetDescription; import org.eclipse.eef.common.ui.api。IEEFFormContainer; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.core.api.controllers。IEEFWidgetController; import org.eclipse.eef.ide.ui.api.widgets。AbstractEEFWidgetLifecycleManager; import org.eclipse.emf.edit.provider。ComposedAdapterFactory; import org.eclipse.emf.edit.ui.provider。AdapterFactoryLabelProvider; import org.eclipse.jface.viewers。ArrayContentProvider; import org.eclipse.jface.viewers。DelegatingStyledCellLabelProvider; import org.eclipse.jface.viewers。IStructuredSelection; import org.eclipse.jface.viewers。TableViewer的; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager; import org.eclipse.swt。SWT; import org.eclipse.swt.events。SelectionEvent; import org.eclipse.swt.events。SelectionListener中; import org.eclipse.swt.widgets。综合; import org.eclipse.swt.widgets。控制; import org.eclipse.swt.widgets。表; import com.example.awesomeproject.eef.core.ext.widgets.table.internal。TableController;公共类TableLifecycleManager扩展AbstractEEFWidgetLifecycleManager {private EEFCustomWidgetDescription description;私有TableViewer tableViewer;私有的ComposedAdapterFactory组成的AdapterFactory; private SelectionListener onClickListener;私有TableController控制器; private Consumer &lt;Object&gt; newValueConsumer; public TableLifecycleManager（EEFCustomWidgetDescription description，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{super（variableManager，interpreter，contextAdapter）; this.description = description; } @Override protected void createMainControl（Composite parent，IEEFFormContainer formContainer）{Table table = formContainer.getWidgetFactory（）。createTable（parent，SWT.READ_ONLY | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER | SWT.SINGLE）; this.tableViewer = new TableViewer（table）; this.composedAdapterFactory = new ComposedAdapterFactory（ComposedAdapterFactory。描述。注册。实例）; this.tableViewer.setContentProvider（ArrayContentProvider.getInstance（））; this.tableViewer.setLabelProvider（new DelegatingStyledCellLabelProvider（new AdapterFactoryLabelProvider。StyledLabelProvider（this.composedAdapterFactory，this.tableViewer）））; this.controller = new TableController（description，variableManager，interpreter，editingContextAdapter）; } @Override public void aboutToBeShown（）{super.aboutToBeShown（）; this.newValueConsumer =（newValue） - &gt; this.tableViewer.setInput（newValue）; this.controller.onNewValue（this.newValueConsumer）; this.onClickListener = new SelectionListener（）{@ Override public void widgetSelected（SelectionEvent event）{Object selection =（（IStructuredSelection）TableLifecycleManager.this.tableViewer.getSelection（））。getFirstElement（）; TableLifecycleManager.this.controller.handleClick（选择）; } @Override public void widgetDefaultSelected（SelectionEvent event）{Object selection =（（IStructuredSelection）TableLifecycleManager.this.tableViewer.getSelection（））。getFirstElement（）; TableLifecycleManager.this.controller.handleClick（选择）; }}; 。this.tableViewer.getTable（）addSelectionListener（this.onClickListener）; } @Override public void refresh（）{super.refresh（）; this.controller.refresh（）; } @Override public void aboutToBeHidden（）{super.aboutToBeHidden（）; this.controller.removeValueConsumer（）; this.newValueConsumer = null; 。this.tableViewer.getTable（）removeSelectionListener（this.onClickListener）; this.onClickListener = null; } @Override protected IEEFWidgetController getController（）{return this.controller; } @Override protected EEFWidgetDescription getWidgetDescription（）{return this.description; } @Override protected Control getValidationControl（）{return this.tableViewer.getTable（）; } @Override public void dispose（）{super.dispose（）; this.composedAdapterFactory.dispose（）; } @Override protected void setEnabled（boolean isEnabled）{this.tableViewer.getTable（）。setEnabled（isEnabled）; }}</pre>
		<p>
			<br>最后，我们可以轻松适配我们的控制器。
		</p>
		<pre>package com.example.awesomeproject.eef.core.ext.widgets.table.internal; import java.util.function。消费者; import java.util。HashMap的; import java.util。地图; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.core.api.controllers。AbstractEEFCustomWidgetController; import org.eclipse.eef.core.api.utils。EvalFactory; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager; public class TableController扩展AbstractEEFCustomWidgetController {private static final String VALUE_EXPRESSION_ID =“valueExpression”; // $ NON-NLS-1 $ private static final String ON_CLICK_EXPRESSION_ID =“onClickExpression”; // $ NON-NLS-1 $ private static final String SELECTION_VARIABLE_NAME =“selection”; // $ NON-NLS-1 $ private Consumer &lt;Object&gt; newValueConsumer; public TableController（EEFCustomWidgetDescription description，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{super（description，variableManager，interpreter，contextAdapter）; } @Override protected EEFCustomWidgetDescription getDescription（）{return this.description; } @Override public void refresh（）{super.refresh（）; this.newEval（）。call（this.getCustomExpression（VALUE_EXPRESSION_ID）。get（），this.newValueConsumer）; public void handleClick（Object object）{this.editingContextAdapter.performModelChange（（） - &gt; {String onClickExpression = this.getCustomExpression（ON_CLICK_EXPRESSION_ID）.get（）; Map &lt;String，Object&gt; variables = new HashMap &lt;String，Object&gt;（ ）; variables.putAll（this.variableManager.getVariables（））; variables.put（SELECTION_VARIABLE_NAME，object）; EvalFactory.of（this.interpreter，variables）.call（onClickExpression）;}）; public void onNewValue（Consumer &lt;Object&gt; consumer）{this.newValueConsumer = consumer; public void removeValueConsumer（）{this.newValueConsumer = null; }}</pre>
		<p>
			<br>通过最小的更改，我们可以在此高级方法中重用基本方法的代码。但是现在我们能够为Sirius说明符提供适当的用户界面来操作我们的小部件，我们可以在EEF运行时中操纵我们自己的概念。
		</p>
	</body>
</html><html id="3430.GWT-faq.html" dir="ltr"></html><html dir="ltr"><head><title>GWT Designer FAQ</title>
<meta content="text/html; charset=windows-1252" http-equiv="Content-Type"></meta>
<link href="../book.css" rel="stylesheet" type="text/css"></link>
</head>

<body dir="ltr">
		<h1>GWT Designer FAQ</h1>
		<table border="0" width="900" cellspacing="0" cellpadding="0">
			<tr>
				<td>以下是有关GWT Designer的常见问题：<ul>
			<li><a href="#UpdateManager">如果我使用Update Manager收到错误，该怎么办？</a></li><li><a href="#OtherGUIBuilders">GWT Designer可以编辑用其他工具创建的窗口吗？</a></li>
			<li><a href="#CreatedByHand">GWT Designer可以编辑手工创建的窗口吗？</a></li>
			<li><a href="#Refactor">我可以重构或以其他方式修改GWT Designer生成的代码吗？</a></li>
			<li><a href="#SpecialTags">为什么GWT Designer环绕声不会生成带有特殊标记的代码或将其标记为只读？</a></li>
			<li><a href="#CantParse">是否有GWT Designer无法解析的特定构造？</a></li>
			<li><a href="#Constructor">为什么GWT Designer会在构造函数中生成？</a></li>
			<li><a href="#CustomWidgets">GWT Designer可以使用自定义小部件吗？</a></li>
			<li><a href="#InstantiationException">如果在使用自定义小部件时遇到InstantiationException或其他错误，我该怎么办？</a></li>
			<li><a href="#Installation">如果安装后没有出现GWT Designer，我该怎么办？</a></li>
			<li><a href="#DoesNotWork">如果GWT Designer在安装后无法正常工作，我该怎么办？</a></li>
			<li><a href="#DesignTab">如果在编辑窗口时没有看到“设计”选项卡，该怎么办？</a></li>
			<li><a href="#Exception">如果使用GWT Designer遇到异常，我该怎么办？</a></li>
			<li><a href="#ParsingError">如果遇到解析错误，该怎么办？</a></li>
			<li><a href="#OutOfMemoryError">如果遇到使用GWT Designer的OutOfMemoryError，我该怎么办？</a></li>
			<li><a href="#NoSuchMethodError">如果遇到</a> <a href="#NoClassDefFoundError">使用GWT Designer</a> <a href="#NoSuchMethodError">的NoSuchMethodError或</a> <a href="#NoClassDefFoundError">NoClassDefFoundError，</a> <a href="#NoSuchMethodError">我该怎么办</a> <a href="#NoClassDefFoundError">？</a></li>
			<li><a href="#UnsupportedClassVersionError">如果使用GWT Designer遇到UnsupportedClassVersionError，我该怎么办？</a></li>
			<li><a href="#GWTProblem">如果使用GWT Designer遇到问题，我该怎么办？</a></li>
			<li><a href="#gwt-ext">GWT Designer是否支持GWT-Ext，EXT GWT（GXT）或SmartGWT？</a></li>
			<li><a href="#Linux">如何将GWT Designer配置为在Linux上运行？</a></li>
			<li><a href="#SuSELinux">如果我在SuSE Linux下运行时遇到问题该怎么办？</a></li>
			<li><a href="#LinuxFlashing">如何使用Metacity阻止预览窗口在Linux下闪烁</a></li>
		</ul>
				<h2><a name="UpdateManager"></a>如果我使用Update Manager收到错误，该怎么办？</h2>
				<p>如果您遇到某种类型的Eclipse Update Manager失败，其中包含“已下载的流不是有效存档”或“下载工件问题”等消息，则这是由Eclipse Update Manager中一个常见的，众所周知的缺陷引起的，该解决方案非常简单：等五分钟，重启Eclipse，再试一次。重新启动Eclipse是必要的，因为Eclipse实际上会缓存失败并拒绝在同一会话期间再次尝试。如果您尝试这几次并且问题仍然存在，则可能会导致Eclipse p2插件缓存损坏的问题更为罕见且令人不安。在这种情况下，接下来要尝试的是重新安装Eclipse并使用新的，干净的Eclipse环境再次尝试。如果这没有帮助，请发送“帮助&gt;关于&gt;安装详细信息&gt;已安装软件”页面的屏幕截图以及完整“帮助&gt;关于&gt;安装详细信息&gt;配置”的副本以支持。您还可以使用产品下载页面上的ZIP安装选项之一尝试安装到新的干净Eclipse环境中。</p>
				<h2><a name="OtherGUIBuilders"></a> GWT Designer可以编辑用其他工具创建的窗口吗？</h2>
		<p>是。世界上大多数GUI构建器只会读取和编写它们自己创建的代码。GWT Designer是该规则的一个例外。它不仅可以读取和编辑它创建的代码，还可以读取和编辑其他GUI构建器生成的大量代码（&gt; 95％）。我们在使用JBuilder，NetBeans等生成的代码方面取得了很好的成功。如果您遇到无效的案例，请将其发送给我们进行分析。我们可以“修复”越破坏的示例，从长远来看，更好的GWT Designer将获得更好的机会（并且您将更有可能按原样挽救旧代码）。请注意，GWT Designer将在不更改其格式的情况下编辑任何现有代码。将使用GWT Designer自己的代码生成首选项创建任何新的小部件。</p>
		<h2 style="font-weight:bold"><a name="CreatedByHand"></a> GWT Designer可以编辑手工创建的窗口吗？</h2>
		<p>是。世界上大多数GUI构建器只会读取和编写它们自己创建的代码。GWT Designer是该规则的一个例外。它不仅可以读取和写入它创建的代码，还可以读取和写入大量手工编写的代码（&gt; 90％）。如果您遇到无效的案例，请将其发送给我们进行分析。我们可以“修复”越破坏的示例，从长远来看，更好的GWT Designer将获得更好的机会（并且您将更有可能按原样挽救旧代码）。</p><p>请注意，无法呈现或编辑动态GUI代码。动态代码的问题在于它通常依赖于在运行时没有意义的运行时计算。在循环中创建的小部件（循环参数在外部传递）是一个很好的例子。在条件中创建的小部件，其中条件的值直到运行时才被知道是另一个示例。从复杂数据库查询的结果构造的动态GUI代码是另一个例子。</p>
		<h2 style="font-weight:bold"><a name="Refactor"></a>我可以重构或以其他方式修改GWT Designer生成的代码吗？</h2>
		<p>是。GWT Designer解析器很好地理解了基本的Java代码和各种Swing，SWT和GWT模式。因此，面对手工更改，它非常重构友好且非常有弹性。您可以在任何地方进行更改或添加代码，GWT Designer会尽可能对其进行反向工程。您也可以用几乎任何可想到的方式重构代码，GWT Designer仍然可以解析它并在设计视图中呈现它。例如，使用该工具创建一个新的Swing JFrame，添加一些小部件，然后使用Eclipse重构工具将一些小部件提取到他们自己的方法中。</p>
		<h2 style="font-weight:bold"><a name="SpecialTags"></a>为什么GWT Designer环绕声不会生成带有特殊标记的代码或将其标记为只读？</h2>
		<p>使用特殊标签或标记代码只读将违反GWT Designer的几个主要设计目标。GWT Designer不会对生成的代码和用户编写的代码进行任何区分。GWT Designer旨在生成您手动编写的相同代码，并在对设计视图进行更改时对源进行最少的更改。GWT Designer永远不会为文件重新生成整个源。如果更改单个属性，则只会更改一行代码。理论上，这行代码可以在源文件中的任何位置（包括最初由GWT Designer创建的行内或您手动编写的行内）。</p>
		<h2 style="font-weight:bold"><a name="CantParse"></a>是否有GWT Designer无法解析的特定构造？</h2>
		<p>是。以下是GWT Designer尚未处理的构造示例：</p>
		<ul>
			<li>通过使用本地参数化辅助方法构建UI</li>
			<li>引用同一组件的多个别名（字段或局部变量）</li>
			<li>通过对同一帮助器方法的多次调用，对同一窗口小部件定义进行多次引用</li>
			<li>基于运行时计算的动态GUI代码</li>
		</ul>
		<h2 style="font-weight:bold"><a name="Constructor"></a>为什么GWT Designer会在构造函数中生成小部件？</h2>
		<p>GWT Designer可以为您喜欢的任何方法生成代码。GWT Designer的一个关键特性是它的重构友好性。您实际上可以使用任何您想要的模板来创建新窗口（例如，您不需要使用GWT Designer提供的向导）。或者，您可以使用Eclipse重构命令将组件提取到新方法（如createComponents（）），该工具将继续工作。</p>
		<h2 style="font-weight:bold"><a name="CustomWidgets"></a> GWT Designer可以使用自定义小部件吗？</h2>
		<p>是的，有一些限制。</p>
				<p>可以使用具有公共零参数构造函数的任何公共Widget子类（这是所有基本GWT小部件的标准）。通过查找已知类型的getter / setter对，可以通过反射派生自定义属性。放置在GWT Designer中时，Custom Composite子类将显示其子组件。</p><p>注意：从GUI构建器的角度来看，Java Bean约定（稍微修改为SWT）非常重要，因为它们建立了一个通用的，预期的，并且大部分是自我文档化的API。如果您创建自己独特的构造函数，那么您实际上是在创建自己的个人API，这使得GUI构建器难以与您的组件进行反射性交互。生成自定义构造函数API的代码需要知道通常不由组件提供的API。这需要将组件的硬编码知识引入GUI构建器本身。</p>
		<p>注意：组件可能依赖于在设计时不可能的某些运行时行为（例如访问应用程序数据库或其他文件）。通过调用Beans.isDesignTime（）来包装特定于运行时的代码，应该隔离运行时特定的行为（并根据需要删除），当组件在GWT Designer中加载时将回答为true，在运行时加载为false。</p>
		<h2 style="font-weight:bold"><a name="InstantiationException"></a>如果遇到使用自定义小部件的InstantiationException或其他错误，我该怎么办？</h2>
		<p>InstantiationException意味着GWT Designer无法创建特定类的实例。最常见的原因是该组件不是<a href="#CustomWidgets">有效的自定义小部件</a> 。为了成为有效的GWT小部件，类必须是有效的Java Bean并且具有公共的零参数构造函数。SWT小部件必须具有公共双参数构造函数，父级和样式位作为两个参数。要解决此问题，请添加缺少的构造函数。注意：从GUI构建器的角度来看，Java Bean约定非常重要，因为它们建立了一个通用的，预期的，并且大部分是自我文档化的API。如果您创建自己独特的构造函数，那么您实际上是在创建自己的个人API，这使得GUI构建器难以与您的组件进行反射性交互。生成自定义构造函数API的代码需要知道通常不由组件提供的API。这需要将组件的硬编码知识引入GUI构建器本身。</p>
		<p>此异常的另一个可能原因是组件的初始化代码中的某些其他故障。组件可能依赖于在设计时不可能的某些运行时行为（例如访问应用程序数据库或某些其他文件）。通过调用<b>isDesignTime（）</b>包装运行时特定代码，应该隔离运行时特定行为（并根据需要<b>删除）</b> ，当在GWT Designer中加载组件时将回答true，在运行时加载false。要实现<a href="../gwt/gwt_composites.html#DesignTime">此处</a>所述的<b>isDesignTime（</b> ）方法。</p>
		<p>有关使用自定义小部件的更多详细信息，请参阅<a href="#CustomWidgets">此FAQ条目</a> 。</p>
		<h2 style="font-weight:bold"><a name="Installation"></a>如果安装后没有出现GWT Designer，我该怎么办？</h2>
		<p align="left">首先，确保已正确安装GWT Designer插件。如果您使用了ZIP安装，请确保将<b>GWT Designer</b>插件解压缩到您的eclipse / plugins或/ dropins目录。</p>
				<p align="left"><span style="font-weight:bold">如果要安装到Eclipse 3.4中</span> ，新的p2更新管理器中存在一个错误，它不会卸载软件包（请参阅错误<a class="moz-txt-link-freetext" href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=232094">232094</a> ）。要解决此问题，请尝试从/configuration/org.eclipse.equinox.simpleconfigurator目录中删除bundles.info文件，并从Eclipse ZIP文件中恢复该文件。如果删除bundles.info还不够，请从eclipse目录中删除整个/ configuration和/ p2目录，并从Eclipse ZIP文件中恢复这些目录。</p>
		<p align="left">重新启动Eclipse后，打开Eclipse首选项对话框并确认您看到了<a href="preferences/index.html">WindowBuilder首选项页面</a> 。如果仍未显示<b>GWT Designer</b> ，请检查Eclipse“.log”文件（位于&lt;workspace&gt; /.metadata目录中）以查找任何记录的异常，然后联系支持人员。如果不存在任何异常且<b>GWT Designer</b>仍然不存在，请确保使用正确配置的基于Eclipse的IDE。 <b>GWT Designer</b>需要存在完整的<b>Eclipse SDK</b> ，并且不会加载到Eclipse子集（如EasyEclipse或MyEclipse All-in-one版本）。一些Eclipse发行版中缺少的最重要的部分是Eclipse PDE（插件开发环境）。您可以通过启动Eclipse并选择“ <b>帮助”&gt;“软件更新”</b>来更正此问题。从站点列表中选择Eclipse Project更新，然后选择要安装的“ <b>Eclipse插件开发环境</b> ”。您可能需要关闭Eclipse并清理配置目录，如上所述。</p>
		<h2 style="font-weight:bold"><a name="DoesNotWork"></a>如果GWT Designer在安装后无法正常工作，我该怎么办？</h2>
		<p>如果GWT Designer在创建或编辑新窗口（或执行任何简单的编辑活动）后安装后无法正常工作（通过抛出随机异常或显示空白设计视图来指示），则可能会遇到安装问题。请尝试以下方法：</p>
		<ol>
			<li>检查是否为Eclipse环境安装了正确版本的GWT Designer。如果您使用的是Eclipse 3.6，请使用针对Eclipse 3.6的最新GWT Designer构建。同样，如果您使用的是Eclipse 3.7，请使用针对Eclipse 3.7的最新GWT Designer构建。</li>
			<li>检查是否只安装了一个版本的GWT Designer（一组* designer *插件和功能）。如果您还安装了旧版本（由早期版本号指示），请删除这些插件和功能，然后重复上面的第二步。确保您没有在Eclipse / plugins目录中本地安装GWT Designer，也无法通过.link文件远程安装GWT Designer（请检查Eclipse / links目录）。</li>
			<li>检查项目是否存在类路径问题以及编译问题的代码。如果您的文件或项目显示红色X，则GWT Designer可能无法编辑该文件。解决问题并再次打开文件。</li>
			<li>尝试使用“ <b>项目”&gt;“清理”</b>命令刷新和重建项目。</li>
			<li>如果问题仍然存在，请检查Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）以查找任何记录的异常，然后联系支持人员。</li>
			<li>如果Eclipse反复锁定，您可以尝试使用<b>-debug</b>命令行选项运行Eclipse。然后，您可以在控制台中按<b>Ctrl + Break</b>查看可能显示系统锁定位置的线程转储。将该线程转储发送到支持。</li>
			<li>如果您遇到GWT Designer无法正常工作的问题，请查看此<a href="#GWTProblem">额外的FAQ条目</a> 。</li>
		</ol>
		<h2 style="font-weight:bold"><a name="DesignTab"></a>如果在编辑窗口时没有看到“设计”选项卡，该怎么办？</h2>
		<p>
<img border="0" src="features/images/open_with.gif" align="right" hspace="5" v:shapes="_x0000_i1032"> Eclipse会记住与文件一起使用的最后一种编辑器类型。如果您没有看到“ <b>设计”</b>选项卡，则表示您使用的是标准Eclipse <b>Java编辑器</b>而不是<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b> 。使用<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b>打开文件，您将看到<b>Source</b>和<b>Design</b>选项卡。请注意，Eclipse一次只允许您使用一个编辑器打开文件，因此您可能需要在使用<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b>打开它之前关闭任何现有编辑<b><a href="features/editing_existing_window.html">器</a></b> 。</p>
				<p>
<img border="0" width="252" height="70" src="features/images/source_design.png" v:shapes="_x0000_i1033"></p>
		<h2 style="font-weight:bold"><a name="Exception"></a>如果使用GWT Designer遇到异常，我该怎么办？</h2>
		<p>如果可以使用比您正在使用的更新的GWT Designer版本，请下载较新的版本并尝试重现该问题。如果过去曾报告过这个问题，那很可能已经修复了。如果问题仍然存在，则应发送Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）以及任何相关的测试用例以支持。包括一个有助于我们重现问题的测试用例非常重要。我们可以越快地重现问题，我们就能越快地为您解决问题。如果我们无法重现问题，我们几乎无法帮助您。</p>
		<p>理想情况下，您发送的测试用例应该与问题发生时编辑的窗口相同（以及编译它所需的任何支持文件）。如果这是不可能的（可能是因为您不允许向第三方发送任何代码），那么您应该尝试创建一个新的独立测试用例来说明同样的问题。最好的方法是通过删除与手头问题无关的所有代码来创建独立的测试用例（例如，在问题消失之前保持删除代码，然后恢复上次删除的最后一个代码）。</p>
		<h2 style="font-weight:bold"><a name="ParsingError"></a>如果遇到解析错误，该怎么办？</h2>
		<p>正如消息所暗示的，这是错误是由解析问题引起的。它与许可无关。您的Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）应该提供有关解析错误原因的提示。发送日志文件以及测试用例以支持（理想情况下您尝试编辑的窗口）。包括一个有助于我们重现问题的测试用例非常重要。我们可以越快地重现问题，我们就能越快地为您解决问题。如果我们无法重现问题，我们几乎无法帮助您。</p>
		<p>理想情况下，您发送的测试用例应该与问题发生时编辑的窗口相同（以及编译它所需的任何支持文件）。如果这是不可能的（可能是因为您不允许向第三方发送任何代码），那么您应该尝试创建一个新的独立测试用例来说明同样的问题。最好的方法是通过删除与手头问题无关的所有代码来创建独立的测试用例（例如，在问题消失之前保持删除代码，然后恢复上次删除的最后一个代码）。</p>
		<p>解析问题也可能是<a href="#DoesNotWork">此前FAQ条目中</a>描述的其他问题的副作用，因此请检查每个建议。使用<b>Project&gt; Clean</b>命令刷新和重建项目通常可以帮助清理Eclipse“配置”目录。</p>
		<h2 style="font-weight:bold"><a name="OutOfMemoryError"></a>如果遇到使用GWT Designer的OutOfMemoryError，我该怎么办？</h2>
		<p>确保已将Eclipse配置为使用足够的内存。首先在Eclipse启动命令行中指定内存的起始内容（ <b>-vmargs -Xms ### m</b> ）（例如，Windows快捷方式中的目标字段）或<b>eclipse.ini</b>文件（在Eclipse根目录中）。如果未指定，则Eclipse的内存起始量非常小（仅40 MB）。您还应指定Eclipse可以使用的最大内存量（ <b>-vmargs -Xmx ### m）</b>和可用的最大perm空间量（ <b>-vmargs -XX：MaxPermSize = ### m</b> ）。</p>
		<p>我们通常推荐这样的东西（这些设置独立于您可能拥有的任何启动设置）：</p>
		<dl>
			<dd><b>-vmargs -XX：MaxPermSize = 128m -Xms256m -Xmx512m</b></dd>
		</dl>
		<p>OutOfMemoryError通常是其他内容的副作用，因此您应该发送Eclipse“.log”文件（位于&lt;workspace&gt; /.metadata目录中）以及任何相关的测试用例以支持。
		</p>
		<p>您可以尝试使用-debug命令行选项运行Eclipse。然后，您可以在控制台中按<b>Ctrl + Break</b>查看线程转储，该转储可能显示系统锁定的位置以及内存的位置。将该线程转储发送到支持</p>
		<h2 style="font-weight:bold"><a name="NoSuchMethodError"></a><a name="NoClassDefFoundError"></a>如果遇到使用GWT Designer的NoSuchMethodError或NoClassDefFoundError，我该怎么办？</h2>
		<p>首先检查Eclipse“.log”文件（可在<b>&lt;workspace&gt; /.metadata目录中找到</b> ）。如果错误引用了您的某个类或方法，请检查您的类路径是否正确引用了您尝试使用的类。还要检查您的类是否已正确编译（没有红色<font color="#ff0000"><b>X</b></font> ），并且您的projects <b>/ bin</b>目录中存在<b>.class</b>文件。用于编译代码的JDK与用于运行Eclipse的JVM之间的不匹配也可能表现为<span style="font-weight:bold">NoClassDefFoundError</span>问题。例如，如果使用JDK 1.5或1.6编译代码，然后使用1.4或1.5 JVM运行Eclipse，则可能会出现此问题。如果错误引用自定义窗口小部件，则还应检查组件在初始化期间是否未触发异常（可将其自身表示为<span style="font-weight:bold">NoClassDefFoundError</span> ）。尝试使用<b>Project&gt; Clean ...</b>或<b>Project&gt; Build Project</b>命令<b>刷新</b>和<b>清理</b>项目。如果这没有帮助，请发送测试用例以支持。</p>
		<p>如果错误引用了基本Eclipse方法或类，则意味着您为正在使用的Eclipse版本加载了错误版本的GWT Designer。GWT Designer正在尝试访问Eclipse发行版中根本不存在的方法或类。删除GWT Designer功能和插件目录，然后为您正在使用的Eclipse版本下载并安装正确版本的GWT Designer。</p>
		<p>如果错误引用GWT Designer类中的方法或类，则表示您遇到严重的Eclipse配置问题，并且未正确加载一个或多个GWT Designer插件。如果插件未加载，则其所有方法都将无法访问，并且任何访问它们的尝试都将触发NoSuchMethodError或NoClassDefFoundError。这个问题通常可以通过清理Eclipse“配置”目录来修复，如<a href="#DoesNotWork">前面的FAQ条目中所述</a> 。</p>
		<h2 style="font-weight:bold"><a name="UnsupportedClassVersionError"></a>如果使用GWT Designer遇到UnsupportedClassVersionError，我该怎么办？</h2>
		<p>UnsupportedClassVersionError通常是由于尝试运行使用早期JRE的IDE针对以后的JRE编译的代码而引起的。通常，在尝试使用在使用JDK 1.5启动的Eclipse版本中针对JDK 1.6编译的类（例如自定义窗口小部件）时，您会看到这一点。</p>
		<p>有两种解决方案可能：您可以使用JDK 1.5重新编译该类，也可以通过修改其启动参数来告诉Eclipse使用JDK 1.6运行（使用您的系统上的JDK 1.6路径）：</p>
		<blockquote>
			<p>-vm C：\ jdk1.6.0_21 \ bin \ java.exe</p>
		</blockquote>
				<h2 style="font-weight:bold"><a name="GWTProblem"></a>如果使用GWT Designer遇到问题，我该怎么办？</h2>尝试以下可能的解决方案：<ol>
			<li>确保<b>WindowBuilder&gt; GWT&gt; Path</b>首选项指向GWT安装目录。</li>
			<li>确保项目的.classpath文件包含以下条目（并且没有其他对gwt-user.jar的引用）...<br>
			<br>&lt;classpathentry kind =“var”path =“GWT_HOME / gwt-user.jar”/&gt;</li>
			<li>确保gwt-user.jar出现在gwt-servelt.jar，gwt-dev-windows.jar或任何其他Google提供的GWT jar之前（gwt-servlet.jar特别包含许多与gwt-user.jar重叠的类，所以首先列出gwt-user.jar非常重要。</li>
			<li>如果缓存的GWT字节码出现问题，请尝试删除以下目录...<br>
			<br>&lt;工作空间&gt; \。元数据位于\ .plugins \ com.swtdesigner.gwt \ bytesCache</li>
			<li>确保禁用任何可能干扰本地通信的内容（例如，在IE设置中配置的任何代理或任何过于激进的防病毒软件）。如果在IE LAN设置中配置了代理服务器，请确保已启用“绕过本地地址的代理服务器”选项。作为测试，您还可以尝试完全禁用代理。</li>
			<li>确保您的浏览器处于“在线”模式。在IE中，确保未选中“文件”&gt;“脱机工作”菜单。</li>
			<li>如果您使用的是FireFox，请尝试禁用或删除任何已安装的扩展程序。</li>
			<li>重新启动电脑并再次尝试。这应该排除内存，通信等方面的任何临时问题。</li>
			<li>将GWT Designer（使用最新版本）重新安装到干净的Eclipse环境（新工作区）中。这应该排除任何安装问题或其他插件的问题。</li>
			<li>完全重置浏览器设置（请参阅IE首选项）。这是为了排除任何未知的IE相关配置问题。</li>
		</ol>
		<h2 style="font-weight:bold"><a name="gwt-ext"></a> GWT Designer是否支持GWT-Ext，EXT GWT（GXT）或SmartGWT？</h2>
		<p>是。GWT Designer对gwt-ext提供了出色的支持。所有标准GWT小部件，面板和布局都与GWT Designer一起使用，与任何<a href="#CustomWidgets">符合JavaBean的</a>小部件一样（例如，它们包括公共默认构造函数并通过getter / setter对公开属性）。定义自己的API但不符合JavaBean规范的小部件可能不会按原样运行。</p>
				<h2 style="font-weight:bold"><a name="Linux"></a>如何将GWT Designer配置为在Linux上运行？</h2>
		<p>要在Linux中使用GWT Designer，我们建议您使用Sun的官方JDK，因为不建议使用Java的GPL版本。以下是使用Sun的Java与Fedora Core和Debian的一些设置说明。请注意，使用非Sun JDK会导致Eclipse锁定。<br>
		<br>使用Sun的Java和Fedora Core：</p>
		<ol>
			<li>下载并解压Sun的JDK .bin格式。<br>
 </li>
			<li>如果您希望在命令行或eclipse之外的其他程序中使用java，请将以下内容添加到/ etc / profile中<br>
			<br>JAVA_HOME = &lt;path_to_jdk&gt;<br>PATH = $ PATH：$ JAVA_HOME / bin<br>导出JAVA_HOME路径<br>
 </li>
			<li>安装Sun的java作为替代方案<br>＃/ usr / sbin / alternatives -install / usr / bin / java java &lt;path_to_jdk&gt; 2<br>
 </li>
			<li>切换到新的替代方案<br>＃/ usr / sbin / alternatives -config java<br>选择选项2<br>
 </li>
			<li>测试<br>＃/ usr / sbin / alternatives -display java</li>
		</ol>
		<p>您应该看到指向Sun JDK的java。<br>
		<br>在Debian中使用Sun的Java：</p>
		<ol>
			<li>以.bin格式下载Sun JDK<br>
 </li>
			<li>fakeroot make-jpkg &lt;jdk&gt; .bin<br>这会创建一个.deb包。<br>
 </li>
			<li>sudo dpkg -i &lt;jdk&gt; .deb<br>
 </li>
			<li>测试<br>#java -version。</li>
		</ol>
		<h2 style="font-weight:bold">
		<a name="SuSELinux"></a>如果我在SuSE Linux下运行时遇到问题该怎么办？</h2>
		<p>如果您在Linux SuSE 10.3上运行GWT Designer时遇到问题，例如Eclipse崩溃和/或工作不正确，或者您的日志文件包含类似“xcb_xlib.c：42：xcb_xlib_lock：Assertion”的内容！c-&gt; xlib.lock'“和/或”/ usr / lib / Eclipse：没有这样的文件或目录“，请尝试将以下内容添加到您的配置文件中：</p>
		<blockquote>
			<p>LIBXCB_ALLOW_SLOPPY_LOCK = 1<br>export LIBXCB_ALLOW_SLOPPY_LOCK。</p>
		</blockquote>
		<h2 style="font-weight:bold">
		<a name="LinuxFlashing"></a>如何使用Metacity阻止预览窗口在Linux下闪烁</h2>
		<p>为了创建您在设计视图中看到的图形，GWT Designer会创建一个包含各种小部件的屏幕外窗口，并为它们拍摄屏幕快照。这在Windows，OSX和某些版本的Linux下运行良好。然而，最近版本的Metacity窗口管理器（比2.1.4更新）已被修改/“修复”以禁止在屏幕外打开窗口。这会强制预览窗口出现在屏幕上，在您进行更改时会导致恼人的闪烁效果。解决方案是通过修补Metacity源代码并重新构建并将修补版本安装到系统中来禁用Metacity“fully_onscreen”约束。<br>
		<br>以下是要遵循的步骤：</p>
		<ol>
			<li>从<a href="ftp://ftp.gnome.org/pub/gnome/sources/metacity/">ftp://ftp.gnome.org/pub/gnome/sources/metacity/</a>下载Metacity源代码</li>
			<li>将源代码tarball解压缩到任何临时目录中。</li>
			<li>Chdir进入这个目录（带解压缩的代码）。</li>
			<li>找到window.c文件并用你最喜欢的texteditor打开它。</li>
			<li>找到一行“window-&gt; require_fully_onscreen = TRUE;”</li>
			<li>将其替换为“window-&gt; require_fully_onscreen = FALSE;”</li>
			<li>保存更改并关闭编辑器。</li>
			<li>用源代码打开一个终端和chdir进入目录（如果你已经这样做了，那就太好了）</li>
			<li>运行“./configure”。</li>
			<li>运行“make all”。</li>
			<li>确保步骤9和10完成且没有错误。</li>
			<li>成为root（或者通过“sudo”执行下一个命令，具体取决于您运行的Linux）</li>
			<li>运行“make install”（或“sudo make install”）。</li>
			<li>保存您的工作并关闭您正在使用的任何应用程序。</li>
			<li>结束会话（或按Ctrl-Alt-Delete重新启动x-server）并再次登录。</li>
			<li>你完成了！</li>
		</ol>
				</td>
			</tr>
		</table>









</body></html><html id="0019.ScriptingReference.24.3.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>BirtComp</title>
    <link rel="StyleSheet" href="css/ScriptingReference.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ScriptingReference.24.2.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="ScriptingReference.24.4.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h2 class="RH1_Class"><a name="275951">BirtComp</a>类</h2>
      <p class="b_Body"><a name="275952">BirtComp类提供比较值的函数，例如，测试值是否等于，大于或小于另一个值。所有函数都返回布尔值。这个类是静态的。应用程序无法创建该类的实例。</a></p>
      <h3 class="RH2_Method"><a name="275953">BirtComp.anyOf</a></h3>
      <p class="b_Body"><a name="275954">此函数将一个或多个值与字段的内容进行比较。</a></p>
      <p class="N_sb_ScanBold"><a name="275955">句法</a></p>
      <div class="rs_RSyntax"><a name="275956">boolean BirtComp.anyOf（source，target1，...，targetN）</a></div>
      <p class="N_sb_ScanBold"><a name="275957">参数</a></p>
      <p class="RParameter"><a name="275958">资源</a></p>
      <p class="bn_BodyNoLead"><a name="275959">包含用于比较的内容的字段。</a></p>
      <p class="RParameter"><a name="279956">目标</a></p>
      <p class="bn_BodyNoLead"><a name="279960">要在源中查找的值。</a></p>
      <p class="N_sb_ScanBold"><a name="275960">返回</a></p>
      <p class="b_Body"><a name="275961">布尔。如果目标值与源中的值匹配，则为True;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="275962">例子</a></p>
      <p class="b_Body"><a name="275963">以下示例测试加拿大，墨西哥或美国是否为“国家/地区”字段中的值。如果任何一个国家/地区在该字段中，则该函数返回true。</a></p>
      <div class="cf_CodeFirst"><a name="275964">BirtComp.anyOf（dataSetRow [“Country”]，“Canada”，“Mexico”，“USA”）</a></div>
      <p class="b_Body"><a name="275965">以下示例测试2009年1月15日或2009年1月31日是payDate字段中的值：</a></p>
      <div class="cf_CodeFirst"><a name="275966">BirtComp.anyOf（dataSetRow [“payDate”]，“2009-01-15”，“2009-01-31”）</a></div>
      <p class="b_Body"><a name="357420">以下示例测试两个特定产品代码是否为productCode字段中的值。如果字段中出现任一值，则显示字符串Obsolete;否则，productCode值将显示在字段中。</a></p>
      <div class="cf_CodeFirst"><a name="357493">if（BirtComp.anyOf（dataSetRow [“PRODUCTCODE”]，“S18_1749”，“S18_2248”））{</a></div>
      <div class="co_Code"><a name="357494">displayString =“已过时”</a></div>
      <div class="co_Code"><a name="357495">}其他{</a></div>
      <div class="co_Code"><a name="357496">dataSetRow [ “PRODUCTCODE”]</a></div>
      <div class="co_Code"><a name="357421">}</a></div>
      <h3 class="RH2_Method"><a name="357427">BirtComp.between</a></h3>
      <p class="b_Body"><a name="280060">此函数测试值是否在两个指定值之间。</a></p>
      <p class="N_sb_ScanBold"><a name="280061">句法</a></p>
      <div class="rs_RSyntax"><a name="280062">boolean BirtComp.between（source，target1，target2）</a></div>
      <p class="N_sb_ScanBold"><a name="280063">参数</a></p>
      <p class="RParameter"><a name="280064">资源</a></p>
      <p class="bn_BodyNoLead"><a name="280065">要测试的值。</a></p>
      <p class="RParameter"><a name="280066">目标1</a></p>
      <p class="bn_BodyNoLead"><a name="280067">要比较的值范围中的第一个值。</a></p>
      <p class="RParameter"><a name="280458">TARGET2</a></p>
      <p class="bn_BodyNoLead"><a name="280462">要比较的值范围中的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="280068">返回</a></p>
      <p class="b_Body"><a name="280069">如果源值介于target1和目标值之间，则为true;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="280070">例子</a></p>
      <p class="b_Body"><a name="280071">以下表达式测试字段值以查看它们是否在指定的值范围内：</a></p>
      <div class="cf_CodeFirst"><a name="280072">BirtComp.between（row [“SalesTotal”]，10000,20000）</a></div>
      <div class="co_Code"><a name="280074">BirtComp.between（row [“CustomerName”]，“A”，“M”）</a></div>
      <div class="co_Code"><a name="280486">BirtComp.between（row [“OrderDate”]，“2009-01-01”，“2009-01-31”）</a></div>
      <p class="b_Body"><a name="280075">以下示例计算装运日期。如果OrderDate值是在2008年12月（在2008年1月12日到2008年12月31日之间），则在OrderDate值中添加5天。如果OrderDate值在12月以外的月份中，则为OrderDate值添加3天。</a></p>
      <div class="cf_CodeFirst"><a name="280076">if（BirtComp.between（row [“OrderDate”]，“2008-12-01”，“2008-12-31”））{</a></div>
      <div class="co_Code"><a name="280077">shipDate = BirtDateTime.addDay（row [“OrderDate”]，5）</a></div>
      <div class="co_Code"><a name="280078">}</a></div>
      <div class="co_Code"><a name="280079">其他{</a></div>
      <div class="co_Code"><a name="280080">ShipDate = BirtDateTime.addDay（row [“OrderDate”]，3）</a></div>
      <div class="co_Code"><a name="280081">}</a></div>
      <h3 class="RH2_Method"><a name="287732">BirtComp.compareString</a></h3>
      <p class="b_Body"><a name="287733">在给定指定条件下，此函数测试字符串值是否与另一个字符串值匹配。</a></p>
      <p class="N_sb_ScanBold"><a name="287734">句法</a></p>
      <div class="rs_RSyntax"><a name="287735">boolean BirtComp.compareString（source1，source2，ignoreCase，trim）</a></div>
      <p class="N_sb_ScanBold"><a name="287736">参数</a></p>
      <p class="RParameter"><a name="287737">来源1</a></p>
      <p class="bn_BodyNoLead"><a name="287738">要在比较中使用的第一个字符串值。</a></p>
      <p class="RParameter"><a name="288180">源2</a></p>
      <p class="bn_BodyNoLead"><a name="288184">要在比较中使用的第二个字符串值。</a></p>
      <p class="RParameter"><a name="287739">IGNORECASE</a></p>
      <p class="bn_BodyNoLead"><a name="288343">指定true以执行不区分大小写的比较。指定false以执行区分大小写的比较。</a></p>
      <p class="RParameter"><a name="288346">修剪</a></p>
      <p class="bn_BodyNoLead"><a name="288350">指定true以在比较两个值之前删除任何前导或尾随空白。字符串中间的空白不会被删除。如果希望比较包括前导或尾随空白，请指定false。</a></p>
      <p class="N_sb_ScanBold"><a name="287750">返回</a></p>
      <p class="b_Body"><a name="287751">如果source1值与source2值匹配，则为true;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="287752">例子</a></p>
      <p class="b_Body"><a name="287755">以下表达式比较指定不同条件的字符串：</a></p>
      <div class="cf_CodeFirst"><a name="287756">BirtComp.compareString（“Jackson”，“Jackson”，false，false）//返回true</a></div>
      <div class="co_Code"><a name="292200">BirtComp.compareString（“Jackson”，“jackson”，false，true）//返回false</a></div>
      <div class="co_Code"><a name="292628">BirtComp.compareString（“Jackson”，“jackson”，true，false）//返回true</a></div>
      <div class="co_Code"><a name="292584">BirtComp.compareString（“Jackson”，“jackson”，true，false）//返回false</a></div>
      <div class="co_Code"><a name="292609">BirtComp.compareString（“Jackson”，“jackson”，true，true）//返回true</a></div>
      <h3 class="RH2_Method"><a name="280965">BirtComp.equalTo</a></h3>
      <p class="b_Body"><a name="280966">此函数测试值是否等于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="280967">句法</a></p>
      <div class="rs_RSyntax"><a name="280968">boolean BirtComp.equalTo（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="280969">参数</a></p>
      <p class="RParameter"><a name="280970">资源</a></p>
      <p class="bn_BodyNoLead"><a name="280971">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="280972">目标</a></p>
      <p class="bn_BodyNoLead"><a name="280973">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="280976">返回</a></p>
      <p class="b_Body"><a name="280977">如果源值等于目标值，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="280978">例子</a></p>
      <p class="b_Body"><a name="280979">以下表达式测试字段值以查看它们是否等于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="280980">BirtComp.equalTo（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="280981">BirtComp.equalTo（row [“Country”]，“France”）</a></div>
      <div class="co_Code"><a name="280982">BirtComp.equalTo（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="285949">BirtComp.greaterOrEqual</a></h3>
      <p class="b_Body"><a name="285950">此函数测试值是否大于或等于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285951">句法</a></p>
      <div class="rs_RSyntax"><a name="285952">boolean BirtComp.greaterOrEqual（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="285953">参数</a></p>
      <p class="RParameter"><a name="285954">资源</a></p>
      <p class="bn_BodyNoLead"><a name="285955">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="285956">目标</a></p>
      <p class="bn_BodyNoLead"><a name="285957">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285958">返回</a></p>
      <p class="b_Body"><a name="285959">如果源值大于或等于目标值，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="285960">例子</a></p>
      <p class="b_Body"><a name="285961">以下表达式测试字段值以查看它们是否大于或等于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="285962">BirtComp.greaterOrEqual（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="285963">BirtComp.greaterOrEqual（row [“ProductCode”]，“S50_4000”）</a></div>
      <div class="co_Code"><a name="285964">BirtComp.greaterOrEqual（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="286072">BirtComp.greaterThan</a></h3>
      <p class="b_Body"><a name="286073">此函数测试值是否大于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="286074">句法</a></p>
      <div class="rs_RSyntax"><a name="286075">boolean BirtComp.greaterThan（来源，目标）</a></div>
      <p class="N_sb_ScanBold"><a name="286076">参数</a></p>
      <p class="RParameter"><a name="286077">资源</a></p>
      <p class="bn_BodyNoLead"><a name="286078">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="286079">目标</a></p>
      <p class="bn_BodyNoLead"><a name="286080">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="286081">返回</a></p>
      <p class="b_Body"><a name="286082">如果源值大于目标值，则为True;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="286083">例子</a></p>
      <p class="b_Body"><a name="286084">以下表达式测试字段值以查看它们是否大于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="286085">BirtComp.greaterThan（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="286086">BirtComp.greaterThan（row [“CustomerName”]，“M”）</a></div>
      <div class="co_Code"><a name="286087">BirtComp.greaterThan（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="286109">BirtComp.lessOrEqual</a></h3>
      <p class="b_Body"><a name="286110">此函数测试值是否小于或等于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="286111">句法</a></p>
      <div class="rs_RSyntax"><a name="286112">boolean BirtComp.lessOrEqual（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="286113">参数</a></p>
      <p class="RParameter"><a name="286114">资源</a></p>
      <p class="bn_BodyNoLead"><a name="286115">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="286116">目标</a></p>
      <p class="bn_BodyNoLead"><a name="286117">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="286118">返回</a></p>
      <p class="b_Body"><a name="286119">如果源值小于或等于目标值，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="286120">例子</a></p>
      <p class="b_Body"><a name="286121">以下表达式测试字段值以查看它们是否小于或等于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="286122">BirtComp.lessOrEqual（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="286123">BirtComp.lessOrEqual（row [“ProductCode”]，“S18_4000”）</a></div>
      <div class="co_Code"><a name="286124">BirtComp.lessOrEqual（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="285537">BirtComp.lessThan</a></h3>
      <p class="b_Body"><a name="285538">此函数测试值是否小于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285539">句法</a></p>
      <div class="rs_RSyntax"><a name="285540">boolean BirtComp.lessThan（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="285541">参数</a></p>
      <p class="RParameter"><a name="285542">资源</a></p>
      <p class="bn_BodyNoLead"><a name="285543">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="285544">目标</a></p>
      <p class="bn_BodyNoLead"><a name="285545">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285546">返回</a></p>
      <p class="b_Body"><a name="285547">如果源值小于目标值，则为True;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="285548">例子</a></p>
      <p class="b_Body"><a name="285549">以下表达式测试字段值以查看它们是否小于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="285550">BirtComp.lessThan（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="285551">BirtComp.lessThan（row [“CustomerName”]，“M”）</a></div>
      <div class="co_Code"><a name="285552">BirtComp.lessThan（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="286184">BirtComp.like</a></h3>
      <p class="b_Body"><a name="286185">此函数测试字符串值是否与模式匹配。该模式必须使用SQL模式匹配语法。</a></p>
      <p class="N_sb_ScanBold"><a name="286186">句法</a></p>
      <div class="rs_RSyntax"><a name="286187">boolean BirtComp.like（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="286188">参数</a></p>
      <p class="RParameter"><a name="286189">资源</a></p>
      <p class="bn_BodyNoLead"><a name="286190">要评估的字符串值。</a></p>
      <p class="RParameter"><a name="286191">目标</a></p>
      <p class="bn_BodyNoLead"><a name="286192">要匹配的字符串模式。您必须将模式用双引号（“”）括起来。在键入要匹配的字符时使用正确的大小写。您可以在模式中使用以下特殊字符：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="286797">百分号（％）匹配零个或多个字符。例如，％ace％匹配包含子串ace的任何字符串值，例如Facebook和MySpace。它与Ace Corporation不匹配，因为该字符串包含大写字母A，而不是小写字母a。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="286830">一个与一个字符完全匹配的下划线字符（_）。例如，t_n匹配tan，ten，tin和ton。它与青少年或tn不匹配。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="286834">要匹配文字百分比（％）或下划线（_）字符，请在这些字符前面加上两个反斜杠（\\）字符。例如，要匹配S_10，请使用以下模式：</a></p>
      <div class="cf_CodeFirst"><a name="286838">小号\\ _ 10</a></div>
      <p class="b_Body"><a name="286842">要匹配50％，请使用以下模式：</a></p>
      <div class="cf_CodeFirst"><a name="286846">50 \\％</a></div>
      <p class="N_sb_ScanBold"><a name="286193">返回</a></p>
      <p class="b_Body"><a name="286194">如果源值与目标值匹配，则为True;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="286195">例子</a></p>
      <p class="b_Body"><a name="286196">以下示例对于以S18开头的productCode字段中的值返回true：</a></p>
      <div class="cf_CodeFirst"><a name="286197">BirtComp.like（row [“productCode”]，“S18％”）</a></div>
      <p class="b_Body"><a name="286720">以下示例对于包含以单个字符开头的子字符串Ford的productName值返回true：</a></p>
      <div class="cf_CodeFirst"><a name="286762">BirtComp.like（row [“productName”]，“_ Ford％”）</a></div>
      <h3 class="RH2_Method"><a name="287271">BirtComp.match</a></h3>
      <p class="b_Body"><a name="287272">此函数测试字符串值是否与模式匹配。该模式必须使用JavaScript正则表达式语法。</a></p>
      <p class="N_sb_ScanBold"><a name="287273">句法</a></p>
      <div class="rs_RSyntax"><a name="287274">boolean BirtComp.match（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="287275">参数</a></p>
      <p class="RParameter"><a name="287276">资源</a></p>
      <p class="bn_BodyNoLead"><a name="287277">要评估的字符串值。</a></p>
      <p class="RParameter"><a name="287278">目标</a></p>
      <p class="bn_BodyNoLead"><a name="287279">要匹配的字符串模式。在JavaScript正则表达式语法中，您可以在一对正斜杠（/）字符中指定模式。您可以使用JavaScript正则表达式支持的任何特殊字符，例如：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="287280">问号（？）匹配前一个字符的零或一次出现。例如，/ te？n /匹配tn，ten和经常。它与青少年或实习生不匹配。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="287281">星号（*）匹配前一个字符的零或任意数量的出现。例如，/ te * n /匹配tn，ten，often和teen。它与实习生不匹配。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="287714">句点（。）匹配任何字符。例如，/ te。* /匹配十个，通常是青少年，实习生。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="287724">插入符号（^）指定要查找的子字符串位于字符串的开头。例如，/ ^十/匹配十，网球和时态。它经常不匹配或假装。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="287725">i字符指定不区分大小写的搜索。例如，/ smith / i匹配史密斯，铁匠和史密森尼。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="287282">要按字面匹配特殊字符，请在特殊字符前加上反斜杠（\）字符。例如，要匹配S * 10，请使用以下模式：</a></p>
      <div class="cf_CodeFirst"><a name="287283">/ S \ * 10 /</a></div>
      <p class="N_sb_ScanBold"><a name="287286">返回</a></p>
      <p class="b_Body"><a name="287287">如果源值与目标值匹配，则为True;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="287288">例子</a></p>
      <p class="b_Body"><a name="287289">以下示例对于以S18开头的productCode字段中的值返回true：</a></p>
      <div class="cf_CodeFirst"><a name="287290">BirtComp.match（row [“productCode”]，/ ^ S18 /）</a></div>
      <p class="b_Body"><a name="287291">以下示例对包含子字符串Ford的productName值返回true：</a></p>
      <div class="cf_CodeFirst"><a name="287292">BirtComp.match（row [“productName”]，/ Ford /）</a></div>
      <h3 class="RH2_Method"><a name="280508">BirtComp.notBetween</a></h3>
      <p class="b_Body"><a name="280509">此函数测试值是否不在两个指定值之间。</a></p>
      <p class="N_sb_ScanBold"><a name="280510">句法</a></p>
      <div class="rs_RSyntax"><a name="280511">boolean BirtComp.notBetween（source，target1，target2）</a></div>
      <p class="N_sb_ScanBold"><a name="280512">参数</a></p>
      <p class="RParameter"><a name="280513">资源</a></p>
      <p class="bn_BodyNoLead"><a name="280514">要测试的值。</a></p>
      <p class="RParameter"><a name="280515">目标1</a></p>
      <p class="bn_BodyNoLead"><a name="280516">要比较的值范围中的第一个值。</a></p>
      <p class="RParameter"><a name="280517">TARGET2</a></p>
      <p class="bn_BodyNoLead"><a name="280518">要比较的值范围中的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="280519">返回</a></p>
      <p class="b_Body"><a name="280520">如果源值不在target1和目标值之间，则为true;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="280521">例子</a></p>
      <p class="b_Body"><a name="280522">以下表达式测试字段值以查看它们是否超出指定的值范围：</a></p>
      <div class="cf_CodeFirst"><a name="280523">BirtComp.notBetween（row [“SalesTotal”]，10000,20000）</a></div>
      <div class="co_Code"><a name="280524">BirtComp.notBetween（row [“CustomerName”]，“A”，“M”）</a></div>
      <div class="co_Code"><a name="280525">BirtComp.notBetween（row [“OrderDate”]，“2009-01-01”，“2009-01-31”）</a></div>
      <p class="b_Body"><a name="280526">以下示例计算装运日期。如果OrderDate值不是2008年12月（不是12月1日至2008年12月31日），请在OrderDate值中添加3天。如果OrderDate值在12月，则将OrderDate值添加5天。</a></p>
      <div class="cf_CodeFirst"><a name="280527">if（BirtComp.notBetween（row [“OrderDate”]，“2008-12-01”，“2008-12-31”））{</a></div>
      <div class="co_Code"><a name="280528">shipDate = BirtDateTime.addDay（row [“OrderDate”]，3）</a></div>
      <div class="co_Code"><a name="280529">}</a></div>
      <div class="co_Code"><a name="280530">其他{</a></div>
      <div class="co_Code"><a name="280531">ShipDate = BirtDateTime.addDay（row [“OrderDate”]，5）</a></div>
      <div class="co_Code"><a name="280532">}</a></div>
      <h3 class="RH2_Method"><a name="285068">BirtComp.notEqual</a></h3>
      <p class="b_Body"><a name="285069">此函数测试值是否不等于另一个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285070">句法</a></p>
      <div class="rs_RSyntax"><a name="285071">boolean BirtComp.notEqual（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="285072">参数</a></p>
      <p class="RParameter"><a name="285073">资源</a></p>
      <p class="bn_BodyNoLead"><a name="285074">比较中使用的第一个值。</a></p>
      <p class="RParameter"><a name="285075">目标</a></p>
      <p class="bn_BodyNoLead"><a name="285076">在比较中使用的第二个值。</a></p>
      <p class="N_sb_ScanBold"><a name="285077">返回</a></p>
      <p class="b_Body"><a name="285078">如果源值不等于目标值，则为真;否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="285079">例子</a></p>
      <p class="b_Body"><a name="285080">以下表达式测试字段值以查看它们是否不等于指定值：</a></p>
      <div class="cf_CodeFirst"><a name="285081">BirtComp.notEqual（row [“SalesTotal”]，10000）</a></div>
      <div class="co_Code"><a name="285082">BirtComp.notEqual（row [“Country”]，“France”）</a></div>
      <div class="co_Code"><a name="285083">BirtComp.notEqual（row [“OrderDate”]，“2009-02-15”）</a></div>
      <h3 class="RH2_Method"><a name="286853">BirtComp.notLike</a></h3>
      <p class="b_Body"><a name="286854">此函数测试字符串值是否与模式不匹配。该模式必须使用SQL模式匹配语法。</a></p>
      <p class="N_sb_ScanBold"><a name="286855">句法</a></p>
      <div class="rs_RSyntax"><a name="286856">boolean BirtComp.notLike（source，target）</a></div>
      <p class="N_sb_ScanBold"><a name="286857">参数</a></p>
      <p class="RParameter"><a name="286858">资源</a></p>
      <p class="bn_BodyNoLead"><a name="286859">要评估的字符串值。</a></p>
      <p class="RParameter"><a name="286860">目标</a></p>
      <p class="bn_BodyNoLead"><a name="286861">要比较的字符串模式。您必须将模式用双引号（“”）括起来。在键入要匹配的字符时使用正确的大小写。您可以在模式中使用以下特殊字符：</a></p>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="286862">百分号（％）匹配零个或多个字符。例如，％ace％匹配包含子串ace的任何字符串值，例如Facebook和MySpace。它与Ace Corporation不匹配，因为该字符串包含大写字母A，而不是小写字母a。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b1_Bullet1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b1_Bullet1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b1_Bullet1_inner"><a name="286863">一个与一个字符完全匹配的下划线字符（_）。例如，t_n匹配tan，ten，tin和ton。它与青少年或tn不匹配。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="b_Body"><a name="286864">要匹配文字百分比（％）或下划线（_）字符，请在这些字符前面加上两个反斜杠（\\）字符。例如，要匹配S_10，请使用以下模式：</a></p>
      <div class="cf_CodeFirst"><a name="286865">小号\\ _ 10</a></div>
      <p class="b_Body"><a name="286866">要匹配50％，请使用以下模式：</a></p>
      <div class="cf_CodeFirst"><a name="286867">50 \\％</a></div>
      <p class="N_sb_ScanBold"><a name="286868">返回</a></p>
      <p class="b_Body"><a name="286869">如果源值与目标值不匹配，则为True;否则为false。否则返回false。</a></p>
      <p class="N_sb_ScanBold"><a name="286870">例子</a></p>
      <p class="b_Body"><a name="286871">以下示例对以S18开头的productCode字段中的值返回false：</a></p>
      <div class="cf_CodeFirst"><a name="286872">BirtComp.notLike（row [“productCode”]，“S18％”）</a></div>
      <p class="b_Body"><a name="286873">以下示例对于包含以单个字符开头的子字符串Ford的productName值返回false：</a></p>
      <div class="cf_CodeFirst"><a name="286874">BirtComp.notLike（row [“productName”]，“_ Ford％”）</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3435.faq.html" dir="ltr"></html><html dir="ltr"><head><title>WindowBuilder Pro常见问题解答</title>
<meta content="text/html; charset=windows-1252" http-equiv="Content-Type"></meta>
<link href="../book.css" rel="stylesheet" type="text/css"></link>
</head>

<body dir="ltr">
		<h1>WindowBuilder Pro常见问题解答</h1>
		<table border="0" width="900" cellspacing="0" cellpadding="0">
			<tr>
				<td>以下是有关WindowBuilder的常见问题：<ul>
			<li><a href="#UpdateManager">如果我使用Update Manager收到错误，该怎么办？</a></li><li><a href="#OtherGUIBuilders">WindowBuilder Pro可以编辑用JBuilder，VA Java，NetBeans，VisualCafe等创建的窗口吗？</a></li>
			<li><a href="#CreatedByHand">WindowBuilder Pro可以编辑手工创建的窗口吗？</a></li>
			<li><a href="#Refactor">我可以重构或以其他方式修改WindowBuilder Pro生成的代码吗？</a></li>
			<li><a href="#SpecialTags">为什么WindowBuilder Pro环绕声不会生成带有特殊标记的代码或将其标记为只读？</a></li>
			<li><a href="#CantParse">WindowBuilder Pro无法解析任何特定的构造吗？</a></li>
			<li><a href="#Constructor">为什么WindowBuilder Pro在构造函数中生成？</a></li>
			<li><a href="#CustomWidgets">WindowBuilder Pro可以使用自定义小部件吗？</a></li>
			<li><a href="#InstantiationException">如果在使用自定义小部件时遇到InstantiationException或其他错误，我该怎么办？</a></li>
			<li><a href="#Installation">如果安装后没有出现WindowBuilder Pro，我该怎么办？</a></li>
			<li><a href="#DoesNotWork">如果WindowBuilder Pro在安装后无法正常工作，我该怎么办？</a></li>
			<li><a href="#DesignTab">如果在编辑窗口时没有看到“设计”选项卡，该怎么办？</a></li>
			<li><a href="#Exception">如果我使用WindowBuilder Pro遇到异常，我该怎么办？</a></li>
			<li><a href="#ParsingError">如果遇到解析错误，该怎么办？</a></li>
			<li><a href="#OutOfMemoryError">如果我使用WindowBuilder Pro遇到OutOfMemoryError，我该怎么办？</a></li>
			<li><a href="#NoSuchMethodError">如果我</a> <a href="#NoClassDefFoundError">使用WindowBuilder Pro</a> <a href="#NoSuchMethodError">遇到NoSuchMethodError或</a> <a href="#NoClassDefFoundError">NoClassDefFoundError，</a> <a href="#NoSuchMethodError">我该怎么办</a> <a href="#NoClassDefFoundError">？</a></li>
			<li><a href="#UnsupportedClassVersionError">如果使用WindowBuilder Pro遇到UnsupportedClassVersionError，我该怎么办？</a></li>
			<li><a href="#UnsatisfiedLinkError">如果在启动SWT应用程序时遇到UnsatisfiedLinkError，我该怎么办？</a></li>
			<li><a href="#Linux">如何将WindowBuilder Pro配置为在Linux上运行？</a></li>
			<li><a href="#SuSELinux">如果我在SuSE Linux下运行时遇到问题该怎么办？</a></li>
			<li><a href="#LinuxFlashing">如何使用Metacity阻止预览窗口在Linux下闪烁</a></li>
		</ul>
				<h2>如果我使用Update Manager收到错误，该怎么办？</h2>
				<p>如果您遇到某种类型的Eclipse Update Manager失败，其中包含“已下载的流不是有效存档”或“下载工件问题”等消息，则这是由Eclipse Update Manager中一个常见的，众所周知的缺陷引起的，该解决方案非常简单：等五分钟，重启Eclipse，再试一次。重新启动Eclipse是必要的，因为Eclipse实际上会缓存失败并拒绝在同一会话期间再次尝试。如果您尝试这几次并且问题仍然存在，则可能会导致Eclipse p2插件缓存损坏的问题更为罕见且令人不安。在这种情况下，接下来要尝试的是重新安装Eclipse并使用新的，干净的Eclipse环境再次尝试。如果这没有帮助，请发送“帮助&gt;关于&gt;安装详细信息&gt;已安装软件”页面的屏幕截图以及完整“帮助&gt;关于&gt;安装详细信息&gt;配置”的副本以支持。您还可以使用产品下载页面上的ZIP安装选项之一尝试安装到新的干净Eclipse环境中。</p>
				<h2><a name="OtherGUIBuilders"></a> WindowBuilder Pro可以编辑用JBuilder，VA Java，NetBeans，VisualCafe等创建的窗口吗？</h2>
		<p>是。世界上大多数GUI构建器只会读取和编写它们自己创建的代码。WindowBuilder Pro是该规则的一个例外。它不仅可以读取和编辑它创建的代码，还可以读取和编辑其他GUI构建器生成的大量代码（&gt; 95％）。我们已经通过JBuilder，NetBeans，Visual Cafe，VA Java，Eclipse VE等生成的代码取得了很好的成功。如果您遇到无效的案例，请将其发送给我们进行分析。我们可以“修复”的破坏的例子越多，从长远来看，WindowBuilder Pro就会越好（并且你将有更好的机会按原样挽救旧代码）。请注意，WindowBuilder Pro将在不更改其格式的情况下编辑任何现有代码。将使用WindowBuilder Pro自己的代码生成首选项创建任何新的小部件。</p>
		<h2 style="font-weight:bold"><a name="CreatedByHand"></a> WindowBuilder Pro可以编辑手工创建的窗口吗？</h2>
		<p>是。世界上大多数GUI构建器只会读取和编写它们自己创建的代码。WindowBuilder Pro是该规则的一个例外。它不仅可以读取和写入它创建的代码，还可以读取和写入大量手工编写的代码（&gt; 90％）。如果您遇到无效的案例，请将其发送给我们进行分析。我们可以“修复”的破坏的例子越多，从长远来看，WindowBuilder Pro就会越好（并且你将有更好的机会按原样挽救旧代码）。</p><p>请注意，无法呈现或编辑动态GUI代码。动态代码的问题在于它通常依赖于在运行时没有意义的运行时计算。在循环中创建的小部件（循环参数在外部传递）是一个很好的例子。在条件中创建的小部件，其中条件的值直到运行时才被知道是另一个示例。从复杂数据库查询的结果构造的动态GUI代码是另一个例子。</p>
		<h2 style="font-weight:bold"><a name="Refactor"></a>我可以重构或以其他方式修改WindowBuilder Pro生成的代码吗？</h2>
		<p>是。WindowBuilder Pro解析器很好地理解了基本的Java代码和各种Swing，SWT和其他UI工具包模式模式。因此，面对手工更改，它非常重构友好且非常有弹性。您可以在任何地方进行更改或添加代码，WindowBuilder Pro会尽可能对其进行反向工程。您也可以用几乎任何可想到的方式重构代码，WindowBuilder Pro仍然可以解析它并在设计视图中呈现它。例如，使用该工具创建一个新的Swing JFrame，添加一些小部件，然后使用Eclipse重构工具将一些小部件提取到他们自己的方法中。</p>
		<h2 style="font-weight:bold"><a name="SpecialTags"></a>为什么WindowBuilder Pro环绕声不会生成带有特殊标记的代码或将其标记为只读？</h2>
		<p>使用特殊标签或标记代码只读将违反WindowBuilder Pro的几个主要设计目标。WindowBuilder Pro不会对生成的代码和用户编写的代码进行任何区分。WindowBuilder Pro旨在生成您手动编写的相同代码，并在对设计视图进行更改时对源进行最少的更改。WindowBuilder Pro永远不会为文件重新生成整个源代码。如果更改单个属性，则只会更改一行代码。理论上，这行代码可以在源文件中的任何位置（包括最初由WindowBuilder Pro创建的行内或您手动编写的行内）。</p>
		<h2 style="font-weight:bold"><a name="CantParse"></a> WindowBuilder Pro无法解析任何特定的构造吗？</h2>
		<p>是。以下是WindowBuilder Pro尚未处理的一些构造示例：</p>
		<ul>
			<li>跨多个小部件重用GridBagConstraint对象（我们支持重用相同的变量，但不支持相同的对象）</li>
			<li>通过使用本地参数化辅助方法构建UI</li>
			<li>引用同一组件的多个别名（字段或局部变量）</li>
			<li>通过对同一帮助器方法的多次调用，对同一窗口小部件定义进行多次引用</li>
			<li>基于运行时计算的动态GUI代码</li>
		</ul>
		<h2 style="font-weight:bold"><a name="Constructor"></a>为什么WindowBuilder Pro在构造函数中生成小部件？</h2>
		<p>WindowBuilder Pro可以为您喜欢的任何方法生成代码。WindowBuilder Pro的一个关键特性是它的重构友好性。您实际上可以使用任何您想要的模板来创建新窗口（例如，您不需要使用WindowBuilder Pro提供的向导）。或者，您可以使用Eclipse重构命令将组件提取到新方法（如createComponents（）），该工具将继续工作。例如，尝试以下模板：</p>
		<blockquote>
			<p><font face="Courier">import javax.swing。JFrame的;<br>公共类MyFrame扩展了JFrame {<br>public static void main（String args []）{<br>尝试{<br>MyFrame frame = new MyFrame（）;<br>frame.setVisible（真）;<br>} catch（例外e）{<br>e.printStackTrace（）;<br>}<br>}<br>public MyFrame（）{<br>超（）;<br>的createComponents（）;<br>}<br>private void createComponents（）{<br>setBounds（100,100,400,300）;<br>setDefaultCloseOperation（JFrame中。EXIT_ON_CLOSE）;<br>}<br>}</font></p>
		</blockquote>
		<p>如果您开始添加新窗口小部件，它们将被添加到createComponents（）方法中。</p>
		<h2 style="font-weight:bold"><a name="CustomWidgets"></a> WindowBuilder Pro可以使用自定义小部件吗？</h2>
		<p>是的，有一些限制。</p><p>对于Swing，可以使用具有公共零参数构造函数的任何公共JComponent子类（根据Java Bean规范的要求）。通过查找已知类型的getter / setter对，可以通过反射派生自定义属性。如果匹配的JavaBean类已定义且可用，则它将用于任何自定义属性。放置在WindowBuilder Pro中时，自定义JPanel子类将显示其子组件。</p><p>对于SWT，可以使用具有公共双参数构造函数的任何公共Control子类（这是所有基本SWT小部件的标准）。通过查找已知类型的getter / setter对，可以通过反射派生自定义属性。SWT尚未定义任何类型的JavaBean接口，因此无法进一步定制。放置在WindowBuilder Pro中时，Custom Composite子类将显示其子组件。</p><p>对于其他UI工具包，可以使用具有公共零参数构造函数的任何公共Widget子类。通过查找已知类型的getter / setter对，可以通过反射派生自定义属性。放置在WindowBuilder Pro中时，Custom Composite子类将显示其子组件。</p><p>注意：从GUI构建器的角度来看，Java Bean约定（稍微修改为SWT）非常重要，因为它们建立了一个通用的，预期的，并且大部分是自我文档化的API。如果您创建自己独特的构造函数，那么您实际上是在创建自己的个人API，这使得GUI构建器难以与您的组件进行反射性交互。生成自定义构造函数API的代码需要知道通常不由组件提供的API。这需要将组件的硬编码知识引入GUI构建器本身。</p>
		<p>注意：组件可能依赖于在设计时不可能的某些运行时行为（例如访问应用程序数据库或其他文件）。通过调用Beans.isDesignTime（）包装运行时特定代码，应该隔离运行时特定行为（并根据需要删除），当组件在WindowBuilder Pro中加载时将回答为true，在运行时加载为false。</p>
		<h2 style="font-weight:bold"><a name="InstantiationException"></a>如果遇到使用自定义小部件的InstantiationException或其他错误，我该怎么办？</h2>
		<p>InstantiationException意味着WindowBuilder Pro无法创建特定类的实例。最常见的原因是该组件不是<a href="#CustomWidgets">有效的自定义小部件</a> 。为了成为有效的Swing小部件，类必须是有效的Java Bean并且具有公共的零参数构造函数。SWT小部件必须具有公共双参数构造函数，父级和样式位作为两个参数。要解决此问题，请添加缺少的构造函数。注意：从GUI构建器的角度来看，Java Bean约定（稍微修改为SWT）非常重要，因为它们建立了一个通用的，预期的，并且大部分是自我文档化的API。如果您创建自己独特的构造函数，那么您实际上是在创建自己的个人API，这使得GUI构建器难以与您的组件进行反射性交互。生成自定义构造函数API的代码需要知道通常不由组件提供的API。这需要将组件的硬编码知识引入GUI构建器本身。</p>
		<p>此异常的另一个可能原因是组件的初始化代码中的某些其他故障。组件可能依赖于在设计时不可能的某些运行时行为（例如访问应用程序数据库或某些其他文件）。通过调用<b>Beans.isDesignTime（）</b>包装运行时特定代码，应该隔离运行时特定行为（并根据需要<b>删除）</b> ，当组件在WindowBuilder Pro中加载时将回答为true，在运行时加载为false。</p>
		<p>有关使用自定义小部件的更多详细信息，请参阅<a href="#CustomWidgets">此FAQ条目</a> 。</p>
		<h2 style="font-weight:bold"><a name="Installation"></a>如果安装后没有出现WindowBuilder Pro，我该怎么办？</h2>
		<p align="left">首先，确保已正确安装WindowBuilder Pro插件。如果您使用ZIP安装，请确保将<b>WindowBuilder Pro</b>插件解压缩到您的eclipse / plugins或/ dropins目录。</p>
				<p align="left"><span style="font-weight:bold">如果要安装到Eclipse 3.4中</span> ，新的p2更新管理器中存在一个错误，它不会卸载软件包（请参阅错误<a class="moz-txt-link-freetext" href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=232094">232094</a> ）。要解决此问题，请尝试从/configuration/org.eclipse.equinox.simpleconfigurator目录中删除bundles.info文件，并从Eclipse ZIP文件中恢复该文件。如果删除bundles.info还不够，请从eclipse目录中删除整个/ configuration和/ p2目录，并从Eclipse ZIP文件中恢复这些目录。</p>
		<p align="left">重新启动Eclipse后，打开Eclipse首选项对话框并确认您看到了<a href="preferences/index.html">WindowBuilder首选项页面</a> 。如果<b>仍未</b>显示<b>WindowBuilder Pro</b> ，请检查Eclipse“.log”文件（位于&lt;workspace&gt; <b>/.metadata</b>目录中）以查找任何记录的异常，然后与支持人员联系。如果没有异常并且<b>WindowBuilder Pro</b>仍然不存在，请确保使用正确配置的基于Eclipse的IDE。 <b>WindowBuilder Pro</b>需要存在完整的<b>Eclipse SDK</b> ，并且不会加载到Eclipse子集中（如EasyEclipse或MyEclipse All-in-one版本）。一些Eclipse发行版中缺少的最重要的部分是Eclipse PDE（插件开发环境）。您可以通过启动Eclipse并选择“ <b>帮助”&gt;“软件更新”</b>来更正此问题。从站点列表中选择Eclipse Project更新，然后选择要安装的“ <b>Eclipse插件开发环境</b> ”。您可能需要关闭Eclipse并清理配置目录，如上所述。</p>
		<h2 style="font-weight:bold"><a name="DoesNotWork"></a>如果WindowBuilder Pro在安装后无法正常工作，我该怎么办？</h2>
		<p>如果WindowBuilder Pro在创建或编辑新窗口（或执行任何简单的编辑活动）后安装后无法正常工作（通过抛出随机异常或显示空白设计视图来指示），则可能会遇到安装问题。请尝试以下方法：</p>
		<ol>
			<li>检查您是否为Eclipse环境安装了正确版本的WindowBuilder Pro。如果您使用的是Eclipse 3.6，请使用针对Eclipse 3.6的最新WindowBuilder Pro构建。同样，如果您使用的是Eclipse 3.7，请使用针对Eclipse 3.7的最新WindowBuilder Pro构建。</li>
			<li>检查是否只安装了一个版本的WindowBuilder Pro（一组* designer *插件和功能）。如果您还安装了旧版本（由早期版本号指示），请删除这些插件和功能，然后重复上面的第二步。确保您没有在Eclipse / plugins目录中本地安装WindowBuilder Pro，也不通过.link文件远程安装（检查Eclipse / links目录）。</li>
			<li>检查项目是否存在类路径问题以及编译问题的代码。如果您的文件或项目显示红色X，则WindowBuilder Pro可能无法编辑该文件。解决问题并再次打开文件。</li>
			<li>尝试使用“ <b>项目”&gt;“清理”</b>命令刷新和重建项目。</li>
			<li>如果问题仍然存在，请检查Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）以查找任何记录的异常，然后联系支持人员。</li>
			<li>如果Eclipse反复锁定，您可以尝试使用<b>-debug</b>命令行选项运行Eclipse。然后，您可以在控制台中按<b>Ctrl + Break</b>查看可能显示系统锁定位置的线程转储。将该线程转储发送到支持。</li>
		</ol>
		<h2 style="font-weight:bold"><a name="DesignTab"></a>如果在编辑窗口时没有看到“设计”选项卡，该怎么办？</h2>
		<p>
<img border="0" src="features/images/open_with.gif" align="right" hspace="5" v:shapes="_x0000_i1032"> Eclipse会记住与文件一起使用的最后一种编辑器类型。如果您没有看到“ <b>设计”</b>选项卡，则表示您使用的是标准Eclipse <b>Java编辑器</b>而不是<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b> 。使用<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b>打开文件，您将看到<b>Source</b>和<b>Design</b>选项卡。请注意，Eclipse一次只允许您使用一个编辑器打开文件，因此您可能需要在使用<b><a href="features/editing_existing_window.html">WindowBuilder编辑器</a></b>打开它之前关闭任何现有编辑<b><a href="features/editing_existing_window.html">器</a></b> 。</p>
				<p>
<img border="0" width="252" height="70" src="features/images/source_design.png" v:shapes="_x0000_i1033"></p>
		<h2 style="font-weight:bold"><a name="Exception"></a>如果我使用WindowBuilder Pro遇到异常，我该怎么办？</h2>
		<p>如果可以使用比您正在使用的更新的WindowBuilder Pro版本，请下载较新的版本并尝试重现该问题。如果过去曾报告过这个问题，那很可能已经修复了。如果问题仍然存在，则应发送Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）以及任何相关的测试用例以<a href="support/product_support.html">支持</a> 。包括一个有助于我们重现问题的<a href="support/test_cases.html">测试用例</a>非常重要。我们可以越快地重现问题，我们就能越快地为您解决问题。如果我们无法重现问题，我们几乎无法帮助您。</p>
		<p>理想情况下，您发送的<a href="support/test_cases.html">测试用例</a>应该与问题发生时编辑的窗口相同（以及编译它所需的任何支持文件）。如果这是不可能的（可能是因为您不允许向第三方发送任何代码），那么您应该尝试创建一个新的独立测试用例来说明同样的问题。最好的方法是通过删除与手头问题无关的所有代码来创建独立的测试用例（例如，在问题消失之前保持删除代码，然后恢复上次删除的最后一个代码）。</p>
		<h2 style="font-weight:bold"><a name="ParsingError"></a>如果遇到解析错误，该怎么办？</h2>
		<p>正如消息所暗示的，这是错误是由解析问题引起的。它与许可无关。您的Eclipse“.log”文件（位于<b>&lt;workspace&gt; /.metadata</b>目录中）应该提供有关解析错误原因的提示。发送日志文件以及测试用例以<a href="support/product_support.html">支持</a> （理想情况下您尝试编辑的窗口）。包括一个有助于我们重现问题的<a href="support/test_cases.html">测试用例</a>非常重要。我们可以越快地重现问题，我们就能越快地为您解决问题。如果我们无法重现问题，我们几乎无法帮助您。</p>
		<p>理想情况下，您发送的<a href="support/test_cases.html">测试用例</a>应该与问题发生时编辑的窗口相同（以及编译它所需的任何支持文件）。如果这是不可能的（可能是因为您不允许向第三方发送任何代码），那么您应该尝试创建一个新的独立测试用例来说明同样的问题。最好的方法是通过删除与手头问题无关的所有代码来创建独立的测试用例（例如，在问题消失之前保持删除代码，然后恢复上次删除的最后一个代码）。</p>
		<p>解析问题也可能是<a href="#DoesNotWork">此前FAQ条目中</a>描述的其他问题的副作用，因此请检查每个建议。使用<b>Project&gt; Clean</b>命令刷新和重建项目通常可以帮助清理Eclipse“配置”目录。</p>
		<h2 style="font-weight:bold"><a name="OutOfMemoryError"></a>如果我使用WindowBuilder Pro遇到OutOfMemoryError，我该怎么办？</h2>
		<p>确保已将Eclipse配置为使用足够的内存。首先在Eclipse启动命令行中指定内存的起始内容（ <b>-vmargs -Xms ### m</b> ）（例如，Windows快捷方式中的目标字段）或<b>eclipse.ini</b>文件（在Eclipse根目录中）。如果未指定，则Eclipse的内存起始量非常小（仅40 MB）。您还应指定Eclipse可以使用的最大内存量（ <b>-vmargs -Xmx ### m）</b>和可用的最大perm空间量（ <b>-vmargs -XX：MaxPermSize = ### m</b> ）。</p>
		<p>我们通常推荐这样的东西（这些设置独立于您可能拥有的任何启动设置）：</p>
		<dl>
			<dd><b>-vmargs -XX：MaxPermSize = 128m -Xms256m -Xmx512m</b></dd>
		</dl>
		<p>OutOfMemoryError通常是其他内容的副作用，因此您应该发送Eclipse“.log”文件（位于&lt;workspace&gt; /.metadata目录中）以及任何相关的测试用例以支持。
		</p>
		<p>您可以尝试使用-debug命令行选项运行Eclipse。然后，您可以在控制台中按<b>Ctrl + Break</b>查看线程转储，该转储可能显示系统锁定的位置以及内存的位置。将该线程转储发送到支持</p>
		<h2 style="font-weight:bold"><a name="NoSuchMethodError"></a><a name="NoClassDefFoundError"></a>如果我使用WindowBuilder Pro遇到NoSuchMethodError或NoClassDefFoundError，我该怎么办？</h2>
		<p>首先检查Eclipse“.log”文件（可在<b>&lt;workspace&gt; /.metadata目录中找到</b> ）。如果错误引用了您的某个类或方法，请检查您的类路径是否正确引用了您尝试使用的类。还要检查您的类是否已正确编译（没有红色<font color="#ff0000"><b>X</b></font> ），并且您的projects <b>/ bin</b>目录中存在<b>.class</b>文件。用于编译代码的JDK与用于运行Eclipse的JVM之间的不匹配也可能表现为<span style="font-weight:bold">NoClassDefFoundError</span>问题。例如，如果使用JDK 1.5或1.6编译代码，然后使用1.4或1.5 JVM运行Eclipse，则可能会出现此问题。如果错误引用自定义窗口小部件，则还应检查组件在初始化期间是否未触发异常（可将其自身表示为<span style="font-weight:bold">NoClassDefFoundError</span> ）。尝试使用<b>Project&gt; Clean ...</b>或<b>Project&gt; Build Project</b>命令<b>刷新</b>和<b>清理</b>项目。如果这没有帮助，请发送测试用例以支持。</p>
		<p>如果错误引用了基本Eclipse方法或类，则意味着您为正在使用的Eclipse版本加载了错误版本的WindowBuilder Pro。WindowBuilder Pro试图访问Eclipse发行版中根本不存在的方法或类。删除WindowBuilder Pro功能和插件目录，然后为您正在使用的Eclipse版本下载并安装正确版本的WindowBuilder Pro。</p>
		<p>如果错误引用WindowBuilder Pro类中的方法或类，则意味着您遇到严重的Eclipse配置问题，并且未正确加载一个或多个WindowBuilder Pro插件。如果插件未加载，则其所有方法都将无法访问，并且任何访问它们的尝试都将触发NoSuchMethodError或NoClassDefFoundError。这个问题通常可以通过清理Eclipse“配置”目录来修复，如<a href="#DoesNotWork">前面的FAQ条目中所述</a> 。</p>
		<h2 style="font-weight:bold"><a name="UnsupportedClassVersionError"></a>如果使用WindowBuilder Pro遇到UnsupportedClassVersionError，我该怎么办？</h2>
		<p>UnsupportedClassVersionError通常是由于尝试运行使用早期JRE的IDE针对以后的JRE编译的代码而引起的。通常，在尝试使用在使用JDK 1.5启动的Eclipse版本中针对JDK 1.6编译的类（例如自定义窗口小部件）时，您会看到这一点。</p>
		<p>有两种解决方案可能：您可以使用JDK 1.5重新编译该类，也可以通过修改其启动参数来告诉Eclipse使用JDK 1.6运行（使用您的系统上的JDK 1.6路径）：</p>
		<blockquote>
			<p>-vm C：\ jdk1.6.0_21 \ bin \ java.exe</p>
		</blockquote>
		<h2 style="font-weight:bold"><a name="UnsatisfiedLinkError"></a>如果在启动SWT应用程序时遇到UnsatisfiedLinkError，我该怎么办？</h2>
		<p>如产品文档和教程中所述，Eclipse SWT DLL（可以在<b>$ ECLIPSE $ \ plugins \ org.eclipse.swt.win32_x.xx \ os \ win32 \ x86 \</b>目录或<b>org.eclipse中找到）。 swt.win32.win32.x86_3.xxjar文件</b> ）需要在您的路径上。将它放入<b>windows / system32</b>目录是最容易的事情。</p>
		<p>对于Linux，您需要找到SWT GTK插件中包含的相应Eclipse SWT * .so文件。</p>
				<h2 style="font-weight:bold"><a name="Linux"></a>如何将WindowBuilder Pro配置为在Linux上运行？</h2>
		<p>要在Linux中使用WindowBuilder Pro，我们建议您使用Sun的官方JDK，因为不建议使用Java的GPL版本。以下是使用Sun的Java与Fedora Core和Debian的一些设置说明。请注意，使用非Sun JDK会导致Eclipse锁定。<br>
		<br>使用Sun的Java和Fedora Core：</p>
		<ol>
			<li>下载并解压Sun的JDK .bin格式。<br>
 </li>
			<li>如果您希望在命令行或eclipse之外的其他程序中使用java，请将以下内容添加到/ etc / profile中<br>
			<br>JAVA_HOME = &lt;path_to_jdk&gt;<br>PATH = $ PATH：$ JAVA_HOME / bin<br>导出JAVA_HOME路径<br>
 </li>
			<li>安装Sun的java作为替代方案<br>＃/ usr / sbin / alternatives -install / usr / bin / java java &lt;path_to_jdk&gt; 2<br>
 </li>
			<li>切换到新的替代方案<br>＃/ usr / sbin / alternatives -config java<br>选择选项2<br>
 </li>
			<li>测试<br>＃/ usr / sbin / alternatives -display java</li>
		</ol>
		<p>您应该看到指向Sun JDK的java。<br>
		<br>在Debian中使用Sun的Java：</p>
		<ol>
			<li>以.bin格式下载Sun JDK<br>
 </li>
			<li>fakeroot make-jpkg &lt;jdk&gt; .bin<br>这会创建一个.deb包。<br>
 </li>
			<li>sudo dpkg -i &lt;jdk&gt; .deb<br>
 </li>
			<li>测试<br>#java -version。</li>
		</ol>
		<h2 style="font-weight:bold">
		<a name="SuSELinux"></a>如果我在SuSE Linux下运行时遇到问题该怎么办？</h2>
		<p>如果您在Linux SuSE 10.3上运行WindowBuilder Pro时出现问题，例如Eclipse崩溃和/或工作不正确，或者您的日志文件包含类似“xcb_xlib.c：42：xcb_xlib_lock：Assertion”的内容！c-&gt; xlib.lock'“和/或”/ usr / lib / Eclipse：没有这样的文件或目录“，请尝试将以下内容添加到您的配置文件中：</p>
		<blockquote>
			<p>LIBXCB_ALLOW_SLOPPY_LOCK = 1<br>export LIBXCB_ALLOW_SLOPPY_LOCK。</p>
		</blockquote>
		<h2 style="font-weight:bold">
		<a name="LinuxFlashing"></a>如何使用Metacity阻止预览窗口在Linux下闪烁</h2>
		<p>为了创建您在设计视图中看到的图形，WindowBuilder Pro会创建一个包含各种小部件的屏幕外窗口，并为它们拍摄屏幕快照。这在Windows，OSX和某些版本的Linux下运行良好。然而，最近版本的Metacity窗口管理器（比2.1.4更新）已被修改/“修复”以禁止在屏幕外打开窗口。这会强制预览窗口出现在屏幕上，在您进行更改时会导致恼人的闪烁效果。解决方案是通过修补Metacity源代码并重新构建并将修补版本安装到系统中来禁用Metacity“fully_onscreen”约束。<br>
		<br>以下是要遵循的步骤：</p>
		<ol>
			<li>从<a href="ftp://ftp.gnome.org/pub/gnome/sources/metacity/">ftp://ftp.gnome.org/pub/gnome/sources/metacity/</a>下载Metacity源代码</li>
			<li>将源代码tarball解压缩到任何临时目录中。</li>
			<li>Chdir进入这个目录（带解压缩的代码）。</li>
			<li>找到window.c文件并用你最喜欢的texteditor打开它。</li>
			<li>找到一行“window-&gt; require_fully_onscreen = TRUE;”</li>
			<li>将其替换为“window-&gt; require_fully_onscreen = FALSE;”</li>
			<li>保存更改并关闭编辑器。</li>
			<li>用源代码打开一个终端和chdir进入目录（如果你已经这样做了，那就太好了）</li>
			<li>运行“./configure”。</li>
			<li>运行“make all”。</li>
			<li>确保步骤9和10完成且没有错误。</li>
			<li>成为root（或者通过“sudo”执行下一个命令，具体取决于您运行的Linux）</li>
			<li>运行“make install”（或“sudo make install”）。</li>
			<li>保存您的工作并关闭您正在使用的任何应用程序。</li>
			<li>结束会话（或按Ctrl-Alt-Delete重新启动x-server）并再次登录。</li>
			<li>你完成了！</li>
		</ol>
				</td>
			</tr>
		</table>









</body></html><html id="3382.User-Guide.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass用户指南</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">Trace Compass用户指南</th>
			</tr>
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Overview.html" title="概观">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">概观</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Table_of_Contents">目录</h1>
		<ol style="list-style:none">
			<li>
				<a href="#Table_of_Contents">目录</a>
			</li>
			<li>
				<a href="Overview.html#Overview">概观</a>
				<ol style="list-style:none">
					<li>
						<a href="Overview.html#About_Tracing">关于追踪</a>
					</li>
					<li>
						<a href="Overview.html#Features">特征</a>
					</li>
					<li>
						<a href="Overview.html#LTTng_integration">LTTng集成</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Installation.html#Installation">安装</a>
				<ol style="list-style:none">
					<li>
						<a href="Installation.html#LTTng_Tracer">LTTng Tracer</a>
					</li>
					<li>
						<a href="Installation.html#Trace_Compass_Plug-ins">跟踪指南针插件</a>
					</li>
					<li>
						<a href="Installation.html#LTTng_Control_Dependencies">LTTng控制依赖关系</a>
					</li>
					<li>
						<a href="Installation.html#Installation_Verification">安装验证</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Trace-Compass-Main-Features.html#Trace_Compass_Main_Features">跟踪罗盘主要特点</a>
				<ol style="list-style:none">
					<li>
						<a href="Trace-Compass-Main-Features.html#Tracing_Perspective">追踪视角</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Project_Explorer_View">Project Explorer视图</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_a_Tracing_Project">创建跟踪项目</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Configuring_a_Project_as_Tracing_Project">将项目配置为跟踪项目</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Importing_Traces_to_the_Project">将跟踪导入项目</a>
								<ol style="list-style:none">
									<li>
										<a href="Trace-Compass-Main-Features.html#Opening_a_Trace">打开跟踪</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Importing">输入</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Drag_and_Drop">拖放</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Trace_Package_Exporting_and_Importing">跟踪包导出和导入</a>
								<ol style="list-style:none">
									<li>
										<a href="Trace-Compass-Main-Features.html#Exporting">出口</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Importing_2">输入</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Refreshing_of_Trace_and_Trace_Folder">刷新跟踪和跟踪文件夹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Remote_Fetching">远程提取</a>
								<ol style="list-style:none">
									<li>
										<a href="Trace-Compass-Main-Features.html#Remote_Profile_elements">远程配置文件元素</a>
										<ol style="list-style:none">
											<li>
												<a href="Trace-Compass-Main-Features.html#Profile">轮廓</a>
											</li>
											<li>
												<a href="Trace-Compass-Main-Features.html#Connection_Node">连接节点</a>
											</li>
											<li>
												<a href="Trace-Compass-Main-Features.html#Trace_Group">跟踪组</a>
											</li>
											<li>
												<a href="Trace-Compass-Main-Features.html#Trace">跟踪</a>
											</li>
										</ol>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Profile_editing_and_management">配置文件编辑和管理</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Selecting_remote_traces">选择远程跟踪</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Selecting_a_Trace_Type">选择跟踪类型</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Trace_Types_Preference_Page">跟踪类型首选项</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Opening_a_Trace_or_Experiment">打开追踪或实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_an_Experiment">创建实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Selecting_Traces_for_an_Experiment">选择实验的痕迹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_an_Experiment_from_Selection">从选择创建实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Removing_Traces_from_an_Experiment">从实验中删除痕迹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Deleting_Traces_from_an_Experiment">从实验中删除痕迹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Renaming_a_Trace_or_Experiment">重命名跟踪或实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Copying_a_Trace_or_Experiment">复制跟踪或实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Deleting_a_Trace_or_Experiment">删除跟踪或实验</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Deleting_Supplementary_Files">删除补充文件</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Displaying_the_trace.27s_time_range">显示跟踪的时间范围</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Link_with_Editor">与编辑链接</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Exporting_Time_Selection_as_New_Trace">将时间选择导出为新跟踪</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Events_Editor">活动编辑</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Searching_and_Filtering">搜索和过滤</a>
								<ol style="list-style:none">
									<li>
										<a href="Trace-Compass-Main-Features.html#Searching">搜索</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Filtering">过滤</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#Bookmarking">书签</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Copy_to_Clipboard">复制到剪贴板</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Event_Source_Lookup">事件源查找</a>
								<ol style="list-style:none">
									<li>
										<a href="Trace-Compass-Main-Features.html#Source_Code">源代码</a>
									</li>
									<li>
										<a href="Trace-Compass-Main-Features.html#EMF_Model">EMF模型</a>
									</li>
								</ol>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Exporting_To_Text">导出到文本</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Refreshing_of_Trace">刷新痕迹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Collapsing_of_Repetitive_Events">折叠重复事件</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Customization">定制</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Histogram_View">直方图视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Statistics_View">统计视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Colors_View">颜色视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Filters_View">过滤视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Time_Chart_View">时间图表视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#State_System_Explorer_View">State System Explorer视图</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#External_Analyses">外部分析</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Running_an_External_Analysis">运行外部分析</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Opening_a_Report">打开报告</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_a_Chart_from_a_Result_Table">从结果表创建图表</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Showing_or_Hiding_a_Result_Table">显示或隐藏结果表</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Adding_and_Removing_a_User-Defined_External_Analysis">添加和删除用户定义的外部分析</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Custom_Parsers">自定义解析器</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_a_custom_text_parser">创建自定义文本解析器</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Creating_a_custom_XML_parser">创建自定义XML解析器</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Managing_custom_parsers">管理自定义解析器</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Opening_a_trace_using_a_custom_parser">使用自定义解析器打开跟踪</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Pin_and_Clone">Pin和Clone</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Cloning_a_view_to_show_two_different_traces">克隆视图以显示两条不同的轨迹</a>
							</li>
							<li>
								<a href="Trace-Compass-Main-Features.html#Cloning_a_view_to_show_different_window_ranges_of_same_trace">克隆视图以显示相同跟踪的不同窗口范围</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Time_Synchronization_of_Views">视图的时间同步</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Automatic_Time_Axis_Alignment">自动时间轴对齐</a>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Searching_in_Time_Graph_Views">在时间图表视图中搜索</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Filtering_Time_Events_in_Time_Graph_Views">在时间图视图中过滤时间事件</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-Compass-Main-Features.html#Configurable_Marker_Sets">可配置的标记集</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-Compass-Main-Features.html#Marker_Set_Configuration_XML_Format">标记集配置XML格式</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="LTTng-Tracer-Control.html#LTTng_Tracer_Control">LTTng Tracer Control</a>
				<ol style="list-style:none">
					<li>
						<a href="LTTng-Tracer-Control.html#Control_View">控制视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Tracer-Control.html#Creating_a_New_Connection_to_a_Remote_Host">创建与远程主机的新连接</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Disconnecting_from_a_Remote_Host">断开与远程主机的连接</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Connecting_to_a_Remote_Host">连接到远程主机</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Deleting_to_a_Remote_Host_Connection">删除远程主机连接</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Creating_a_Tracing_Session">创建跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Creating_a_Tracing_Session_With_Advanced_Options">使用高级选项创建跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Creating_a_Snapshot_Tracing_Session">创建快照跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Channels_-_General">启用频道 - 常规</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Channels_On_Session_Level">在会话级别启用频道</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Configuring_Trace_File_Rotation">配置跟踪文件轮换</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Configuring_per_UID_and_per_PID_Buffers_.28UST_only.29">配置每个UID和每个PID缓冲区（仅限UST）</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Configuring_Periodical_Flush_for_metadata_Channel">配置元数据通道的定期刷新</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Channels_On_Domain_Level">在域级别启用通道</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_and_Disabling_Channels">启用和禁用频道</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Events_-_General">启用事件 - 常规</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Kernel_Events_On_Session_Level">在会话级别启用内核事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_UST_Events_On_Session_Level">在会话级别启用UST事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_JUL_Events_On_Session_Level">在会话级别启用JUL事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_LOG4J_Events_On_Session_Level">在会话级别启用LOG4J事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Python_Events_On_Session_Level">在会话级别启用Python事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Events_On_Domain_Level">在域级别启用事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Events_On_Channel_Level">在通道级别启用事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_and_Disabling_Events">启用和禁用事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Enabling_Tracepoint_Events_From_Provider">从提供程序启用跟踪点事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Configuring_Filter_Expression_When_Enabling_Events">启用事件时配置筛选表达式</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Adding_Contexts_to_Channels_and_Events_of_a_Domain">将上下文添加到域的通道和事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Adding_Contexts_to_All_Events_of_a_Channel">将上下文添加到频道的所有事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Adding_Contexts_to_an_Event_of_a_Specific_Channel">将上下文添加到特定频道的事件</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Start_Tracing">开始跟踪</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Recording_a_Snapshot">录制快照</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Stop_Tracing">停止追踪</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Destroying_a_Tracing_Session">销毁跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Refreshing_the_Node_Information">刷新节点信息</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Importing_Session_Traces_to_a_Tracing_Project">将会话跟踪导入跟踪项目</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Importing_Network_Traces_to_a_Tracing_Project">将网络跟踪导入跟踪项目</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Saving_Tracing_Sessions">保存跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Loading_Tracing_Sessions">加载跟踪会话</a>
							</li>
							<li>
								<a href="LTTng-Tracer-Control.html#Managing_Tracing_Session_Profiles">管理跟踪会话配置文件</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Tracer-Control.html#Properties_View">属性视图</a>
					</li>
					<li>
						<a href="LTTng-Tracer-Control.html#LTTng_Tracer_Control_Preferences">LTTng Tracer控件首选项</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="LTTng-Kernel-Analysis.html#LTTng_Kernel_Analysis">LTTng内核分析</a>
				<ol style="list-style:none">
					<li>
						<a href="LTTng-Kernel-Analysis.html#OS_Tracing_Overview_Perspective">操作系统跟踪概述视角</a>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#LTTng_Kernel_Perspective">LTTng内核视角</a>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Control_Flow_View">控制流视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Process_tree_and_information">处理树和信息</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Control_flow">控制流</a>
								<ol style="list-style:none">
									<li>
										<a href="LTTng-Kernel-Analysis.html#Using_the_mouse">用鼠标</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Using_the_keyboard">使用键盘</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Incomplete_regions">不完整的地区</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Zoom_region">缩放区域</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Tooltips">提示</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Dynamics_Filters">动态过滤器</a>
										<ol style="list-style:none">
											<li>
												<a href="LTTng-Kernel-Analysis.html#Show_Active_Threads_Only">仅显示活动主题</a>
											</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Toolbar">工具栏</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Marker_Axis">标记轴</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Resources_View">资源视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Follow_CPU">关注CPU</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Follow_thread">跟随线程</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Navigation">导航</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Incomplete_regions_2">不完整的地区</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Toolbar_2">工具栏</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Marker_Axis_2">标记轴</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#LTTng_CPU_Usage_View">LTTng CPU使用率视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Process_Information">处理信息</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#CPU_Usage_Chart">CPU使用率图表</a>
								<ol style="list-style:none">
									<li>
										<a href="LTTng-Kernel-Analysis.html#Tooltips_2">提示</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Using_the_mouse_2">用鼠标</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Using_the_keyboard_2">使用键盘</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Toolbar_3">工具栏</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#View_Menu">查看菜单</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#CPU_Filtering">CPU过滤</a>
									</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Kernel_Memory_Usage_View">内核内存使用情况视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Process_Information_2">处理信息</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Navigation_2">导航</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Toolbar_4">工具栏</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#View_Menu_2">查看菜单</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Relative_Kernel_Memory_Chart">相对内核内存图</a>
								<ol style="list-style:none">
									<li>
										<a href="LTTng-Kernel-Analysis.html#Navigation_3">导航</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Tooltips_3">提示</a>
									</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Process_Wait_Analysis">流程等待分析</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Prerequisites">先决条件</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Running_the_analysis">运行分析</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Input.2FOutput_Analysis">输入/输出分析</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Get_the_trace">得到踪迹</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Input.2FOutput_Views">输入/输出视图</a>
								<ol style="list-style:none">
									<li>
										<a href="LTTng-Kernel-Analysis.html#Disk_I.2FO_Activity_View">磁盘I / O活动视图</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Navigation_4">导航</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#Toolbar_5">工具栏</a>
									</li>
									<li>
										<a href="LTTng-Kernel-Analysis.html#View_Menu_3">查看菜单</a>
									</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#System_Call_Latency_Analysis">系统调用延迟分析</a>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Futex_Contention_Latency_Analysis">Futex争用延迟分析</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-Kernel-Analysis.html#Uaddr_vs_Waiter">Uaddr vs Waiter</a>
							</li>
							<li>
								<a href="LTTng-Kernel-Analysis.html#Scenarios">方案</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#Latency_analysis_for_IRQ_handlers">IRQ处理程序的延迟分析</a>
					</li>
					<li>
						<a href="LTTng-Kernel-Analysis.html#LTTng_Kernel_Events_Editor">LTTng内核事件编辑器</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="LTTng-UST-Analyses.html#LTTng-UST_Analyses">LTTng-UST分析</a>
				<ol style="list-style:none">
					<li>
						<a href="LTTng-UST-Analyses.html#Call_Stack_View">调用堆栈视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-UST-Analyses.html#Using_the_Callstack_View_with_LTTng-UST_traces">使用带有LTTng-UST跟踪的Callstack视图</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Importing_a_binary_or_function_name_mapping_file_.28for_LTTng-UST_.3C2.8_traces.29">导入二进制或函数名称映射文件（对于LTTng-UST &lt;2.8跟踪）</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Navigation_5">导航</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Marker_Axis_3">标记轴</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-UST-Analyses.html#Flame_Graph_View">火焰图视图</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-UST-Analyses.html#How_to_use_a_Flame_Graph">如何使用Flame Graph</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-UST-Analyses.html#Function_Duration_Statistics">功能持续时间统计</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-UST-Analyses.html#Using_the_mouse_3">用鼠标</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Using_the_keyboard_3">使用键盘</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Toolbar_6">工具栏</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Importing_a_binary_or_function_name_mapping_file_.28for_LTTng-UST_.3C2.8_traces.29_2">导入二进制或函数名称映射文件（对于LTTng-UST &lt;2.8跟踪）</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-UST-Analyses.html#Function_Duration_Density">功能持续时间密度</a>
					</li>
					<li>
						<a href="LTTng-UST-Analyses.html#Memory_Usage">内存使用情况</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-UST-Analyses.html#Navigation_6">导航</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#Toolbar_7">工具栏</a>
							</li>
							<li>
								<a href="LTTng-UST-Analyses.html#View_Menu_4">查看菜单</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="LTTng-UST-Analyses.html#Source_Lookup_.28for_LTTng-UST_2.8.2B.29">源查找（适用于LTTng-UST 2.8+）</a>
						<ol style="list-style:none">
							<li>
								<a href="LTTng-UST-Analyses.html#Binary_file_location_configuration">二进制文件位置配置</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="Trace-synchronization.html#Trace_synchronization">跟踪同步</a>
				<ol style="list-style:none">
					<li>
						<a href="Trace-synchronization.html#Obtain_synchronizable_traces">获得可同步的跟踪</a>
						<ol style="list-style:none">
							<li>
								<a href="Trace-synchronization.html#Use_LTTng-modules_2.9.2B">使用LTTng模块2.9+</a>
							</li>
							<li>
								<a href="Trace-synchronization.html#LTTng-module_network_tracepoint_with_complete_data">具有完整数据的LTTng模块网络跟踪点</a>
							</li>
							<li>
								<a href="Trace-synchronization.html#LTTng-modules_addons_kernel_module_with_dynamic_tracepoints">LTTng-modules使用动态跟踪点添加内核模块</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Trace-synchronization.html#Synchronize_traces_in_Trace_Compass">在Trace Compass中同步跟踪</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Time-offsetting.html#Time_offsetting">时间抵消</a>
				<ol style="list-style:none">
					<li>
						<a href="Time-offsetting.html#Basic_mode">基本模式</a>
					</li>
					<li>
						<a href="Time-offsetting.html#Advanced_mode">高级模式</a>
					</li>
					<li>
						<a href="Time-offsetting.html#Clearing_time_offset">清除时间偏移</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Timestamp-formatting.html#Timestamp_formatting">时间戳格式化</a>
			</li>
			<li>
				<a href="Data-driven-analysis.html#Data_driven_analysis">数据驱动分析</a>
				<ol style="list-style:none">
					<li>
						<a href="Data-driven-analysis.html#Managing_XML_files_containing_analyses">管理包含分析的XML文件</a>
					</li>
					<li>
						<a href="Data-driven-analysis.html#Defining_XML_components">定义XML组件</a>
					</li>
					<li>
						<a href="Data-driven-analysis.html#Defining_an_XML_state_provider">定义XML状态提供程序</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-driven-analysis.html#Definitions_and_example">定义和例子</a>
							</li>
							<li>
								<a href="Data-driven-analysis.html#Determining_the_state_system_structure">确定国家体制结构</a>
							</li>
							<li>
								<a href="Data-driven-analysis.html#Writing_the_XML_state_provider">编写XML状态提供程序</a>
							</li>
							<li>
								<a href="Data-driven-analysis.html#Debugging_the_XML_state_provider">调试XML状态提供程序</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Data-driven-analysis.html#Defining_an_XML_pattern_provider">定义XML模式提供程序</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-driven-analysis.html#The_state_system_structure">国家体制结构</a>
							</li>
							<li>
								<a href="Data-driven-analysis.html#Writing_the_XML_pattern_provider">编写XML模式提供程序</a>
							</li>
							<li>
								<a href="Data-driven-analysis.html#Representing_the_scenarios">代表场景</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Data-driven-analysis.html#Defining_an_XML_time_graph_view">定义XML时间图视图</a>
						<ol style="list-style:none">
							<li>
								<a href="Data-driven-analysis.html#Using_the_keyboard_4">使用键盘</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="Data-driven-analysis.html#Defining_an_XML_XY_chart">定义XML XY图表</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Latency-Analyses.html#Latency_Analyses">延迟分析</a>
			</li>
			<li>
				<a href="Counters-Analysis.html#Counters_Analysis">计数器分析</a>
				<ol style="list-style:none">
					<li>
						<a href="Counters-Analysis.html#Creating_an_LTTng_trace_with_performance_counters">使用性能计数器创建LTTng跟踪</a>
					</li>
					<li>
						<a href="Counters-Analysis.html#Counters_View">计数器视图</a>
						<ol style="list-style:none">
							<li>
								<a href="Counters-Analysis.html#Navigation_7">导航</a>
							</li>
							<li>
								<a href="Counters-Analysis.html#Toolbar_8">工具栏</a>
							</li>
							<li>
								<a href="Counters-Analysis.html#View_Menu_5">查看菜单</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
				<a href="Java-Logging.html#Java_Logging">Java日志记录</a>
				<ol style="list-style:none">
					<li>
						<a href="Java-Logging.html#Enable_JUL_Logging">启用JUL日志记录</a>
					</li>
					<li>
						<a href="Java-Logging.html#Configuring_JUL_logging">配置JUL日志记录</a>
					</li>
					<li>
						<a href="Java-Logging.html#LTTng_JUL_log_handler">LTTng JUL日志处理程序</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Limitations.html#Limitations">限制</a>
			</li>
			<li>
				<a href="How-to-use-LTTng-to-diagnose-problems.html#How_to_use_LTTng_to_diagnose_problems">如何使用LTTng来诊断问题</a>
				<ol style="list-style:none">
					<li>
						<a href="How-to-use-LTTng-to-diagnose-problems.html#Random_stutters">随机口吃</a>
					</li>
					<li>
						<a href="How-to-use-LTTng-to-diagnose-problems.html#Slow_I.2FO">慢I / O.</a>
					</li>
				</ol>
			</li>
			<li>
				<a href="Trace-Compass-Incubator.html#Trace_Compass_Incubator">跟踪指南针孵化器</a>
			</li>
			<li>
				<a href="References.html#References">参考</a>
			</li>
		</ol><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Overview.html" title="概观">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">概观</td>
			</tr>
		</table>
	</body>
</html><html id="2206.s6.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s5.html" rel="prev">&lt;&lt;§5团队激活</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s7.html" rel="next">§7角色封装&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s6">
            <div class="headl">
               <div class="headr">
                  <h1>§6ObjectTeams API</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s6.html">§6ObjectTeams API</a></li>
                  <li><a href="#s6.1">§6.1反思</a></li>
                  <li><a href="#s6.2">§6.2其他API元素</a></li>
                  <li><a href="#s6.3">§6.3注释</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>预定义类型和方法的作用</h3>
               <div class="line"></div>
               <div class="term">应用程序编程接口（API）</div>
               <div class="termdesc">支持OT / J的某些功能，但不引入新语法，而是通过预定义的类型和方法。</div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s6.1">
               <h2 class="sect">§6.1反思<a class="img" href="s6.1.html" title="PermaLinkto§6.1反思"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <p>对象团队支持关于团队，角色和角色基础关系的反思。
                  		
               </p>
               <div class="subsect depth3" id="s6.1.a">
                  <h4 class="subsect">（a） <span class="title">与角色登记处的接口</span><a class="img" href="s6.1.a.html" title="PermaLink（a）与角色注册表的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>每个团队实例内部都有一个由其基础对象索引的已知角色对象的注册表。程序员可以使用<code>org.objectteams.定义的以下反射方法来使用此注册表<code>org.objectteams.ITeam</code> ：</p>
                  <dl>
                     <dt><code>boolean hasRole（Object aBase）;</code></dt>
                     <dd>此方法检查传递的基础对象的角色是否已存在于目标团队中。
                        				
                     </dd>
                     <dt><code>boolean hasRole（Object aBase，Class roleType）;</code></dt>
                     <dd>此方法检查作为传递的基础对象<code>aBase</code>的角色的<code>roleType</code>的实例是否已存在于目标团队中。角色也可以是指定角色类型的任何子类型。<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                     <dt><code>Object getRole（Object aBase）;</code></dt>
                     <dd>如果传递的基础对象<code>aBase</code>已在目标团队中具有角色，则返回此角色。否则返回<code>null</code> 。
                        				
                     </dd>
                     <dt><code>&lt;T&gt; T getRole（Object aBase，Class &lt;T&gt; roleType）;</code></dt>
                     <dd>如果传递的基础对象<code>aBase</code>已在目标团队中具有可分配给<code>roleType</code>表示的<code>roleType</code> ，则返回此角色。否则返回<code>null</code> 。<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                     <dt><code>Object [] getAllRoles（）;</code></dt>
                     <dd>检索目标团队中的所有现有（已注册） <a href="s2.1.a.html" title="§2.1。（a）基于角色的约束" class="sect">绑定角色（第2.1节（a））</a> 。
                        					<br>此方法使用弱引用的内部结构。因此，它可能会返回垃圾收集器即将回收的角色实例。如果性能允许，建议在调用<code>getAllRoles()</code> <code>System.gc()</code>之前始终调用<code>System.gc()</code>以获得确定性结果（另见<a href="s2.1.f.html" title="§2.1。（f）对垃圾收集的影响" class="sect">§2.1。（f）</a> ）。
                        				
                     </dd>
                     <dt><code>&lt;T&gt; T [] getAllRoles（Class &lt;T&gt; roleType）;</code></dt>
                     <dd>检索目标团队中可分配给<code>roleType</code>表示的<code>roleType</code>所有现有（已注册） <a href="s2.1.a.html" title="§2.1。（a）基于角色的约束" class="sect">绑定角色（第2.1。（a））</a> 。
                        					<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        <br>请参阅上面有关垃圾收集的说明。
                        				
                     </dd>
                     <dt><code>void unregisterRole（Object aRole）;</code></dt>
                     <dd>此方法从目标团队取消注册传递的角色对象。因此相应的基础失去了这个角色。调用此方法后，不应再使用该角色。
                        				
                     </dd>
                     <dt><code>void unregisterRole（Object aRole，Class roleType）;</code></dt>
                     <dd>此方法从目标团队取消注册传递的角色对象。因此相应的基地失去了这个角色。调用此方法后，不应再使用该角色。与前一种方法的唯一区别是提高了速度，因为不必搜索相应的注册表。
                        					<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                  </dl>
                  <p>希望并且可能在警卫中使用这些方法（见<a href="s5.4.html" title="§5.4守护谓词" class="sect">§5.4</a> ）。这些方法允许以更简洁和更具表现力的方式编写警卫的规范。由签名确定，前四种方法只能用于基本级别的保护（第<a href="s5.4.2.html" title="§5.4.2基地警卫" class="sect">5.4.2节</a> ），因为它们需要引用基础对象。
                     			
                  </p>
                  <h5 class="listing">示例代码（警卫和反射）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>类</b> SpecialConditions {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>void</b>参与（账户<b>为</b> BonusAccount ba）{}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>公共</b> <b>类</b> BonusAccount <b>播放了</b>账号</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>    <b>基</b>时<em>（SpecialConditions.this。hasRole（</em>碱，BonusAccount.class））</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>    <b>callin</b> <b>void</b> creditBonus（ <b>int</b> amount）{</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>base.creditBonus（金额+奖金）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>    <b>void</b> creditBonus（ <b>int</b> amount） <b>&lt; -</b> <b>replace</b> <b>void</b> credit（ <b>int</b> i）</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>      <b>基数</b> <b>何时</b> （i&gt; 1000）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>功效：</h5>该团队为注册<code>Account</code>提供奖励系统。每次向注册账户存入超过1000的金额时，额外1％的金额将被记入贷方。
                     				 
                     <ul>
                        <li><code>participate</code>第2行的团队级方法使用声明的提升（参见<a href="s2.3.2.html" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ），允许通过的<code>Account</code>对象参与<code>SpecialConditions</code>团队提供的奖励系统。
                           	
                        </li>
                        <li>第4行中的基准防护使用反射方法<code>hasRole</code>来检查基础对象是否已在周围团队中具有<code>BonusAccount</code>类型的角色。表达式<code>BonusAccount.class</code>返回<code>java.lang.表示角色<code>BonusAccount</code> Class</code>对象（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）。该警卫确保只有通过<code>participate</code>明确注册的帐户才会使用<code>BonusAccount</code>类型的角色进行<code>BonusAccount</code> 。
                           
                        </li>
                        <li>第10行中的方法绑定保护将callin转换为<code>creditBonus</code>以限制基本方法参数<code>amount</code>大于1000的调用。
                           					
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="subsect depth3" id="s6.1.b">
                  <h4 class="subsect">（b） <span class="title">行为反思</span><a class="img" href="s6.1.b.html" title="永久链接到（b）行为反思"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>org.objectteams中定义的以下反射方法。ITeam可用于检查团队的动态行为：</p>
                  <dl>
                     <dt><code>boolean isExecutingCallin（）;</code></dt>
                     <dd>此方法用于检查控制流是否已被当前团队的至少一个callin绑定截获。它可以用来避免不希望的重新进入团队。
                        				
                     </dd>
                     <dt><code>boolean isActive（）;</code></dt>
                     <dd>此方法检查团队实例是否对当前线程处于活动状态。
                        				
                     </dd>
                     <dt><code>boolean isActive（Thread aThread）;</code></dt>
                     <dd>此方法检查团队实例是否对线程<code>aThread</code>是活动的。
                        				
                     </dd>
                  </dl>
               </div>
               <div class="subsect depth3" id="s6.1.c">
                  <h4 class="subsect">（c） <span class="title">角色的类文字</span><a class="img" href="s6.1.c.html" title="PermaLink to（c）角色的类文字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>所谓的类文字的Java语法， <code>MyClass <strong>.class</strong></code> （参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）可用于语义稍有变化的角色类型：角色类型是动态绑定的虚拟类型（ <a href="s1.3.1.html" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ）（ <a href="s1.3.1.e.html" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3） .1。（e）</a> ）。这也适用于角色类文字。由此遵循约束，即角色类文字只能在团队的非静态上下文中使用，即，用于评估角色类文字，封闭团队实例必须在范围内。
                     		<br>与角色类型的常规类型检查不同，类文本本身没有依赖类型。因此，对<code>hasRole(Object, Class)</code>等方法的调用的类型检查无法检测到<code>Class</code>实例是否实际上是从正确的团队实例中获取的。在给定团队中传递未被称为绑定角色的类的任何尝试都会在运行时导致<code>IllegalArgumentException</code> 。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s6.2">
               <h2 class="sect">§6.2其他API元素<a class="img" href="s6.2.html" title="PermaLink至§6.2其他API元素"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <div class="subsect depth3" id="s6.2.a">
                  <h4 class="subsect">（a） <span class="title">角色封装的接口</span><a class="img" href="s6.2.a.html" title="PermaLink（a）用于角色封装的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>存在一组<span class="underline">不</span>扩展<code>java.lang.的预定义类型<code>java.lang.Object</code>并<span class="underline">没有</span>除运算符之外的<span class="underline">任何</span>功能<code>==</code>和<code>!=</code> 。
                     			
                  </p>
                  <div class="note">
                     <h5>注意：</h5>JLS定义每个接口声明<code>java.lang.定义的所有方法<code>java.lang.Object</code> （ <a href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#32392" class="ext">JLS§9.2</a> ）以及接口类型引用的每个对象都可以扩展为<code>java.lang.Object</code> 。编译器通常通过声明<code>java.lang.实现它<code>java.lang.Object</code>所有接口的超类型。对于JLS中更复杂的定义，这种实现没有明显的区别。</div>
                  <p>这些预定义类型是</p>
                  <dl>
                     <dt><code>org.objectteams。IConfined</code></dt>
                     <dd>常规界面</dd>
                     <dt><code>org.objectteams。ITEAM。IConfined</code></dt>
                     <dd>角色界面</dd>
                     <dt><code>org.objectteams。球队。受限</code></dt>
                     <dd>角色类</dd>
                  </dl>
                  <p>这些类型不提供新功能，但从这些类型继承会影响关于封装的语义。这些类型的目的和用法在<a href="s7.html" title="§7角色封装" class="sect">§7中</a>描述。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.b">
                  <h4 class="subsect">（b） <span class="title">明确降低的界面</span><a class="img" href="s6.2.b.html" title="PermaLink to（b）显式降低的界面"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>存在以下角色接口以允许显式降低：</p>
                  <dl>
                     <dt><code>org.objectteams。ITEAM。ILowerable</code></dt>
                     <dd>角色界面</dd>
                  </dl>
                  <p>该接口在<a href="s2.2.d.html" title="§2.2。（d）明显降低" class="sect">§2.2。（d）</a>中有详细介绍。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.c">
                  <h4 class="subsect">（c） <span class="title">团队激活方法</span><a class="img" href="s6.2.c.html" title="PermaLink到（c）团队激活方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以通过界面<code>org.objectteams.预定义方法激活和停用每个团队<code>org.objectteams.ITeam</code> 。
                     			
                  </p>
                  <dl>
                     <dt><code>activate()</code>并<code>activate(Thread th)</code></dt>
                     <dd>激活团队的方法</dd>
                     <dt><code>deactivate()</code>和<code>deactivate(Thread th)</code></dt>
                     <dd>停用团队的方法</dd>
                  </dl>
                  <p>这些方法的用法在<a href="s5.2.b.html" title="§5.2。（b）势在必行的激活" class="sect">§5.2。（b）中</a>描述。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.d">
                  <h4 class="subsect">（d） <span class="title">例外情况</span><a class="img" href="s6.2.d.html" title="永久链接到（d）例外"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在执行ObjectTeam / Java程序期间，可能会抛出以下<code>Exceptions</code> ：</p>
                  <dl>
                     <dt><code>ResultNotProvidedException</code></dt>
                     <dd>如果没有基本调用的替换callin不提供必要的（基本类型）基本结果，则抛出（参见<a href="s4.3.e.html" title="§4.3。（e）脆弱的愈伤组织结合" class="sect">§4.3。（e）</a> ）。
                     </dd>
                     <dt><code>LiftingFailedException</code></dt>
                     <dd>如果吊装过程中出现的实际不确定性（见时抛出<a href="s2.3.4.c.html" title="§2.3.4。（c）实际含糊不清" class="sect">§2.3.4。（C） ），</a>或者如果提升需要实例化一个抽象角色类（见<a href="s2.5.b.html" title="§2.5。（b）相关角色" class="sect">§2.5。（B） ）。</a>这是一个经过检查的例外。有关更多信息，请参见<a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> 。
                     </dd>
                     <dt><code>WrongRoleException</code></dt>
                     <dd>如果基础对象相对于同一团队实例，则在提升期间抛出，之前已被提升为不符合当前请求类型的角色类型（参见<a href="s2.3.4.d.html" title="§2.3.4。（d）不匹配的作用" class="sect">§2.3.4。（d）</a>和<a href="s2.4.3.html" title="§2.4.3在智能提升的情况下创建角色" class="sect">§2.4.3</a> ）。
                     </dd>
                     <dt><code>DuplicateRoleException</code></dt>
                     <dd>在显式角色创建期间抛出，如果为基础对象创建了新角色，该角色已在给定团队中具有所需类型的角色（请参阅<a href="s2.4.1.c.html" title="§2.4.1。（c）重复角色运行时检查" class="sect">§2.4.1。（c）</a> ）。
                     </dd>
                     <dt><code>RoleCastException</code></dt>
                     <dd>如果将转换表达式锚定到与转换类型不同的团队实例，则在外部化角色的转换期间抛出（参见<a href="s1.2.4.b.html" title="§1.2.4。（b）铸造" class="sect">§1.2.4。（b）</a> ）。
                     </dd>
                     <dt><code>LiftingVetoException</code></dt>
                     <dd>当相关的保护谓词（第<a href="s5.4.html" title="§5.4守护谓词" class="sect">5.4节</a> ）评估为假时，此异常在内部用于中止提升过程。从生成的代码抛出的此类异常将永远不会出现在客户端代码中，因此通常不需要捕获<code>LiftingVetoException</code> 。但是，在某些情况下，从<code>LiftingVetoException</code>的提升构造函数（第<a href="s2.3.1.b.html" title="§2.3.1。（b）默认提升构造函数" class="sect">2.3.1。（b）</a> ）中显式<em>抛出</em> <code>LiftingVetoException</code>是很有用的。即使在提升构造器开始工作之后，该类型也允许中止提升，并且还允许用于需要提升的方法参数。如果由于callin方法绑定而触发了<code>LiftingVetoException</code>则在准备对role方法的调用时，如果抛出<code>LiftingVetoException</code> ，则此绑定将不会触发。
                     </dd>
                  </dl>
               </div>
               <div class="subsect depth3" id="s6.2.e">
                  <h4 class="subsect">（e） <span class="title">角色迁移</span><a class="img" href="s6.2.e.html" title="PermaLink（e）角色迁移"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>以下接口可用于启用角色迁移：</p>
                  <dl>
                     <dt><code>IBaseMigratable</code></dt>
                     <dd>该接口声明了一个方法<div class="listing plain"><pre>
    <code>&lt;B&gt; <b>void</b> migrateToBase（B otherBase）</code> </pre></div>并指示编译器为任何绑定角色生成此方法的实现，声明<code>IBaseMigratable</code>为其超级接口。<br>在角色实例上调用<code>migrateToBase</code>的效果是将此角色重新绑定到新的基本实例。基本实例必须与角色的基类兼容（为了避免在解除编译器期间出现问题，可能需要基类具有角色基类的确切类型）。将<code>null</code>传递给此方法会导致抛出<code>NullPointerException</code> 。
                     </dd>
                     <dt><code>ITeamMigratable</code></dt>
                     <dd>该接口声明了一个方法<div class="listing plain"><pre>
    <code>&lt;R&gt; R &lt;@otherTeam&gt; migrateToTeam（ <b>最终</b> ITeam otherTeam）</code></pre></div>并指示编译器为任何声明<code>ITeamMigratable</code>作为其超级接口的角色生成此方法的实现。<br>在角色实例上调用<code>migrateToTeam</code>的效果是重新绑定此角色，使其成为新团队实例的包含部分。团队实例必须是角色的封闭团队的确切类型。将<code>null</code>传递给此方法会导致抛出<code>NullPointerException</code> 。<br><div class="note">
                           <h5>警告：</h5>这种方法有意破坏了家族多态性的规则：在迁移之前建立的任何引用<code>R&lt;@previousTeam&gt; r</code>都会错误地暗示角色的封闭团队仍然是<code>previousTeam</code> ，迁移后不再是真的。虽然这不会影响任何方法查找（这仍然是安全的），但基于角色的依赖类型的进一步假设会因团队迁移而失效。从迁移角色到任何兄弟角色实例的引用也是如此。<br>如果应该保持家庭多态性的规则，那么就应该避免将<code>ITeamMigratable</code>声明为角色的超级接口。
                        </div>
                     </dd>
                  </dl>
                  <p>对于这两种方法，接口中声明的签名过于通用，但编译器执行必要的检查以确保角色，基本和团队实例确实兼容，并且另外将<code>migrateToTeam</code>的返回类型作为自我类型进行检查，即，它反映了呼叫目标的确切类型。
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s6.3">
               <h2 class="sect">§6.3注释<a class="img" href="s6.3.html" title="PermaLink至§6.3注释"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <div class="subsect depth3" id="s6.3.a">
                  <h4 class="subsect">（a） <span class="title">控制隐式团队激活</span><a class="img" href="s6.3.a.html" title="PermaLink（a）控制隐式团队激活"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>默认情况下禁用隐式团队激活，可以通过添加注释<code>@org.objectteams.来启用<code>@org.objectteams.ImplicitTeamActivation</code> 。有关详细信息，请参见<a href="s5.3.d.html" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.3.b">
                  <h4 class="subsect">（b） <span class="title">控制提升</span><a class="img" href="s6.3.b.html" title="PermaLink to（b）控制提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果按照<a href="s2.3.html" title="§2.3提升" class="sect">§2.3</a>和特别是<a href="s2.3.1.html" title="§2.3.1隐式角色创建" class="sect">§2.3.1中的</a>定义进行提升会导致性能问题，则可以使用注释<code>@org.objectteams.按角色类修改提升的语义<code>@org.objectteams.Instantiation</code> 。有关详细信息，请参见<a href="s2.3.1.d.html" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> 。
                     			
                  </p>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s5.html" rel="prev">&lt;&lt;§5团队激活</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s7.html" rel="next">§7角色封装&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="1899.s6.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s5.html" rel="prev">&lt;&lt;§5团队激活</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s7.html" rel="next">§7角色封装&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="chapter" id="s6">
            <div class="headl">
               <div class="headr">
                  <h1>§6ObjectTeams API</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s6.html">§6ObjectTeams API</a></li>
                  <li><a href="#s6.1">§6.1反思</a></li>
                  <li><a href="#s6.2">§6.2其他API元素</a></li>
                  <li><a href="#s6.3">§6.3注释</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>预定义类型和方法的作用</h3>
               <div class="line"></div>
               <div class="term">应用程序编程接口（API）</div>
               <div class="termdesc">支持OT / J的某些功能，但不引入新语法，而是通过预定义的类型和方法。</div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s6.1">
               <h2 class="sect">§6.1反思<a class="img" href="s6.html#s6.1" title="PermaLinkto§6.1反思"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <p>对象团队支持关于团队，角色和角色基础关系的反思。
                  		
               </p>
               <div class="subsect depth3" id="s6.1.a">
                  <h4 class="subsect">（a） <span class="title">与角色登记处的接口</span><a class="img" href="s6.html#s6.1.a" title="PermaLink（a）与角色注册表的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>每个团队实例内部都有一个由其基础对象索引的已知角色对象的注册表。程序员可以使用<code>org.objectteams.定义的以下反射方法来使用此注册表<code>org.objectteams.ITeam</code> ：</p>
                  <dl>
                     <dt><code>boolean hasRole（Object aBase）;</code></dt>
                     <dd>此方法检查传递的基础对象的角色是否已存在于目标团队中。
                        				
                     </dd>
                     <dt><code>boolean hasRole（Object aBase，Class roleType）;</code></dt>
                     <dd>此方法检查作为传递的基础对象<code>aBase</code>的角色的<code>roleType</code>的实例是否已存在于目标团队中。角色也可以是指定角色类型的任何子类型。<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                     <dt><code>Object getRole（Object aBase）;</code></dt>
                     <dd>如果传递的基础对象<code>aBase</code>已在目标团队中具有角色，则返回此角色。否则返回<code>null</code> 。
                        				
                     </dd>
                     <dt><code>&lt;T&gt; T getRole（Object aBase，Class &lt;T&gt; roleType）;</code></dt>
                     <dd>如果传递的基础对象<code>aBase</code>已在目标团队中具有可分配给<code>roleType</code>表示的<code>roleType</code> ，则返回此角色。否则返回<code>null</code> 。<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                     <dt><code>Object [] getAllRoles（）;</code></dt>
                     <dd>检索目标团队中的所有现有（已注册） <a href="s2.html#s2.1.a" title="§2.1。（a）基于角色的约束" class="sect">绑定角色（第2.1节（a））</a> 。
                        					<br>此方法使用弱引用的内部结构。因此，它可能会返回垃圾收集器即将回收的角色实例。如果性能允许，建议在调用<code>getAllRoles()</code> <code>System.gc()</code>之前始终调用<code>System.gc()</code>以获得确定性结果（另见<a href="s2.html#s2.1.f" title="§2.1。（f）对垃圾收集的影响" class="sect">§2.1。（f）</a> ）。
                        				
                     </dd>
                     <dt><code>&lt;T&gt; T [] getAllRoles（Class &lt;T&gt; roleType）;</code></dt>
                     <dd>检索目标团队中可分配给<code>roleType</code>表示的<code>roleType</code>所有现有（已注册） <a href="s2.html#s2.1.a" title="§2.1。（a）基于角色的约束" class="sect">绑定角色（第2.1。（a））</a> 。
                        					<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        <br>请参阅上面有关垃圾收集的说明。
                        				
                     </dd>
                     <dt><code>void unregisterRole（Object aRole）;</code></dt>
                     <dd>此方法从目标团队取消注册传递的角色对象。因此相应的基础失去了这个角色。调用此方法后，不应再使用该角色。
                        				
                     </dd>
                     <dt><code>void unregisterRole（Object aRole，Class roleType）;</code></dt>
                     <dd>此方法从目标团队取消注册传递的角色对象。因此相应的基地失去了这个角色。调用此方法后，不应再使用该角色。与前一种方法的唯一区别是提高了速度，因为不必搜索相应的注册表。
                        					<br>如果<code>roleType</code>不是当前团队的成员类型，则抛出<code>IllegalArgumentException</code> 。
                        				
                     </dd>
                  </dl>
                  <p>希望并且可能在警卫中使用这些方法（见<a href="s5.html#s5.4" title="§5.4守护谓词" class="sect">§5.4</a> ）。这些方法允许以更简洁和更具表现力的方式编写警卫的规范。由签名确定，前四种方法只能用于基本级别的保护（第<a href="s5.html#s5.4.2" title="§5.4.2基地警卫" class="sect">5.4.2节</a> ），因为它们需要引用基础对象。
                     			
                  </p>
                  <h5 class="listing">示例代码（警卫和反射）：</h5>
                  <div class="listing example frame">
                     <table class="listing">
                        <tr class="line odd">
                           <td class="ln">1</td>
                           <td><pre><b>公共</b> <b>团队</b> <b>类</b> SpecialConditions {</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">2</td>
                           <td><pre>  <b>public</b> <b>void</b>参与（账户<b>为</b> BonusAccount ba）{}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">3</td>
                           <td><pre>  <b>公共</b> <b>类</b> BonusAccount <b>播放了</b>账号</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">4</td>
                           <td><pre>    <b>基</b>时<em>（SpecialConditions.this。hasRole（</em>碱，BonusAccount.class））</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">五</td>
                           <td><pre>{</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">6</td>
                           <td><pre>    <b>callin</b> <b>void</b> creditBonus（ <b>int</b> amount）{</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">7</td>
                           <td><pre>base.creditBonus（金额+奖金）;</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">8</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">9</td>
                           <td><pre>    <b>void</b> creditBonus（ <b>int</b> amount） <b>&lt; -</b> <b>replace</b> <b>void</b> credit（ <b>int</b> i）</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">10</td>
                           <td><pre>      <b>基数</b> <b>何时</b> （i&gt; 1000）;</pre></td>
                        </tr>
                        <tr class="line odd">
                           <td class="ln">11</td>
                           <td><pre>}</pre></td>
                        </tr>
                        <tr class="line even">
                           <td class="ln">12</td>
                           <td><pre>}</pre></td>
                        </tr>
                     </table>
                  </div>
                  <div class="codecomment">
                     <h5>功效：</h5>该团队为注册<code>Account</code>提供奖励系统。每次向注册账户存入超过1000的金额时，额外1％的金额将被记入贷方。
                     				 
                     <ul>
                        <li><code>participate</code>第2行的团队级方法使用声明的提升（参见<a href="s2.html#s2.3.2" title="§2.3.2宣布解除" class="sect">§2.3.2</a> ），允许通过的<code>Account</code>对象参与<code>SpecialConditions</code>团队提供的奖励系统。
                           	
                        </li>
                        <li>第4行中的基准防护使用反射方法<code>hasRole</code>来检查基础对象是否已在周围团队中具有<code>BonusAccount</code>类型的角色。表达式<code>BonusAccount.class</code>返回<code>java.lang.表示角色<code>BonusAccount</code> Class</code>对象（参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）。该警卫确保只有通过<code>participate</code>明确注册的帐户才会使用<code>BonusAccount</code>类型的角色进行<code>BonusAccount</code> 。
                           
                        </li>
                        <li>第10行中的方法绑定保护将callin转换为<code>creditBonus</code>以限制基本方法参数<code>amount</code>大于1000的调用。
                           					
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="subsect depth3" id="s6.1.b">
                  <h4 class="subsect">（b） <span class="title">行为反思</span><a class="img" href="s6.html#s6.1.b" title="永久链接到（b）行为反思"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>org.objectteams中定义的以下反射方法。ITeam可用于检查团队的动态行为：</p>
                  <dl>
                     <dt><code>boolean isExecutingCallin（）;</code></dt>
                     <dd>此方法用于检查控制流是否已被当前团队的至少一个callin绑定截获。它可以用来避免不希望的重新进入团队。
                        				
                     </dd>
                     <dt><code>boolean isActive（）;</code></dt>
                     <dd>此方法检查团队实例是否对当前线程处于活动状态。
                        				
                     </dd>
                     <dt><code>boolean isActive（Thread aThread）;</code></dt>
                     <dd>此方法检查团队实例是否对线程<code>aThread</code>是活动的。
                        				
                     </dd>
                  </dl>
               </div>
               <div class="subsect depth3" id="s6.1.c">
                  <h4 class="subsect">（c） <span class="title">角色的类文字</span><a class="img" href="s6.html#s6.1.c" title="PermaLink to（c）角色的类文字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>所谓的类文字的Java语法， <code>MyClass <strong>.class</strong></code> （参见<a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530" class="ext">JLS§15.8.2</a> ）可用于语义稍有变化的角色类型：角色类型是动态绑定的虚拟类型（ <a href="s1.html#s1.3.1" title="§1.3.1角色类的获取和隐式继承" class="sect">§1.3.1</a> ）（ <a href="s1.html#s1.3.1.e" title="§1.3.1。（e）类型的动态绑定" class="sect">§1.3） .1。（e）</a> ）。这也适用于角色类文字。由此遵循约束，即角色类文字只能在团队的非静态上下文中使用，即，用于评估角色类文字，封闭团队实例必须在范围内。
                     		<br>与角色类型的常规类型检查不同，类文本本身没有依赖类型。因此，对<code>hasRole(Object, Class)</code>等方法的调用的类型检查无法检测到<code>Class</code>实例是否实际上是从正确的团队实例中获取的。在给定团队中传递未被称为绑定角色的类的任何尝试都会在运行时导致<code>IllegalArgumentException</code> 。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s6.2">
               <h2 class="sect">§6.2其他API元素<a class="img" href="s6.html#s6.2" title="PermaLink至§6.2其他API元素"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <div class="subsect depth3" id="s6.2.a">
                  <h4 class="subsect">（a） <span class="title">角色封装的接口</span><a class="img" href="s6.html#s6.2.a" title="PermaLink（a）用于角色封装的接口"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>存在一组<span class="underline">不</span>扩展<code>java.lang.的预定义类型<code>java.lang.Object</code>并<span class="underline">没有</span>除运算符之外的<span class="underline">任何</span>功能<code>==</code>和<code>!=</code> 。
                     			
                  </p>
                  <div class="note">
                     <h5>注意：</h5>JLS定义每个接口声明<code>java.lang.定义的所有方法<code>java.lang.Object</code> （ <a href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#32392" class="ext">JLS§9.2</a> ）以及接口类型引用的每个对象都可以扩展为<code>java.lang.Object</code> 。编译器通常通过声明<code>java.lang.实现它<code>java.lang.Object</code>所有接口的超类型。对于JLS中更复杂的定义，这种实现没有明显的区别。</div>
                  <p>这些预定义类型是</p>
                  <dl>
                     <dt><code>org.objectteams。IConfined</code></dt>
                     <dd>常规界面</dd>
                     <dt><code>org.objectteams。ITEAM。IConfined</code></dt>
                     <dd>角色界面</dd>
                     <dt><code>org.objectteams。球队。受限</code></dt>
                     <dd>角色类</dd>
                  </dl>
                  <p>这些类型不提供新功能，但从这些类型继承会影响关于封装的语义。这些类型的目的和用法在<a href="s7.html" title="§7角色封装" class="sect">§7中</a>描述。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.b">
                  <h4 class="subsect">（b） <span class="title">明确降低的界面</span><a class="img" href="s6.html#s6.2.b" title="PermaLink to（b）显式降低的界面"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>存在以下角色接口以允许显式降低：</p>
                  <dl>
                     <dt><code>org.objectteams。ITEAM。ILowerable</code></dt>
                     <dd>角色界面</dd>
                  </dl>
                  <p>该接口在<a href="s2.html#s2.2.d" title="§2.2。（d）明显降低" class="sect">§2.2。（d）</a>中有详细介绍。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.c">
                  <h4 class="subsect">（c） <span class="title">团队激活方法</span><a class="img" href="s6.html#s6.2.c" title="PermaLink到（c）团队激活方法"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>可以通过界面<code>org.objectteams.预定义方法激活和停用每个团队<code>org.objectteams.ITeam</code> 。
                     			
                  </p>
                  <dl>
                     <dt><code>activate()</code>并<code>activate(Thread th)</code></dt>
                     <dd>激活团队的方法</dd>
                     <dt><code>deactivate()</code>和<code>deactivate(Thread th)</code></dt>
                     <dd>停用团队的方法</dd>
                  </dl>
                  <p>这些方法的用法在<a href="s5.html#s5.2.b" title="§5.2。（b）势在必行的激活" class="sect">§5.2。（b）中</a>描述。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.2.d">
                  <h4 class="subsect">（d） <span class="title">例外情况</span><a class="img" href="s6.html#s6.2.d" title="永久链接到（d）例外"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在执行ObjectTeam / Java程序期间，可能会抛出以下<code>Exceptions</code> ：</p>
                  <dl>
                     <dt><code>ResultNotProvidedException</code></dt>
                     <dd>如果没有基本调用的替换callin不提供必要的（基本类型）基本结果，则抛出（参见<a href="s4.html#s4.3.e" title="§4.3。（e）脆弱的愈伤组织结合" class="sect">§4.3。（e）</a> ）。
                     </dd>
                     <dt><code>LiftingFailedException</code></dt>
                     <dd>如果吊装过程中出现的实际不确定性（见时抛出<a href="s2.html#s2.3.4.c" title="§2.3.4。（c）实际含糊不清" class="sect">§2.3.4。（C） ），</a>或者如果提升需要实例化一个抽象角色类（见<a href="s2.html#s2.5.b" title="§2.5。（b）相关角色" class="sect">§2.5。（B） ）。</a>这是一个经过检查的例外。有关更多信息，请参见<a href="s2.html#s2.3.5" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> 。
                     </dd>
                     <dt><code>WrongRoleException</code></dt>
                     <dd>如果基础对象相对于同一团队实例，则在提升期间抛出，之前已被提升为不符合当前请求类型的角色类型（参见<a href="s2.html#s2.3.4.d" title="§2.3.4。（d）不匹配的作用" class="sect">§2.3.4。（d）</a>和<a href="s2.html#s2.4.3" title="§2.4.3在智能提升的情况下创建角色" class="sect">§2.4.3</a> ）。
                     </dd>
                     <dt><code>DuplicateRoleException</code></dt>
                     <dd>在显式角色创建期间抛出，如果为基础对象创建了新角色，该角色已在给定团队中具有所需类型的角色（请参阅<a href="s2.html#s2.4.1.c" title="§2.4.1。（c）重复角色运行时检查" class="sect">§2.4.1。（c）</a> ）。
                     </dd>
                     <dt><code>RoleCastException</code></dt>
                     <dd>如果将转换表达式锚定到与转换类型不同的团队实例，则在外部化角色的转换期间抛出（参见<a href="s1.html#s1.2.4.b" title="§1.2.4。（b）铸造" class="sect">§1.2.4。（b）</a> ）。
                     </dd>
                     <dt><code>LiftingVetoException</code></dt>
                     <dd>当相关的保护谓词（第<a href="s5.html#s5.4" title="§5.4守护谓词" class="sect">5.4节</a> ）评估为假时，此异常在内部用于中止提升过程。从生成的代码抛出的此类异常将永远不会出现在客户端代码中，因此通常不需要捕获<code>LiftingVetoException</code> 。但是，在某些情况下，从<code>LiftingVetoException</code>的提升构造函数（第<a href="s2.html#s2.3.1.b" title="§2.3.1。（b）默认提升构造函数" class="sect">2.3.1。（b）</a> ）中显式<em>抛出</em> <code>LiftingVetoException</code>是很有用的。即使在提升构造器开始工作之后，该类型也允许中止提升，并且还允许用于需要提升的方法参数。如果由于callin方法绑定而触发了<code>LiftingVetoException</code>则在准备对role方法的调用时，如果抛出<code>LiftingVetoException</code> ，则此绑定将不会触发。
                     </dd>
                  </dl>
               </div>
               <div class="subsect depth3" id="s6.2.e">
                  <h4 class="subsect">（e） <span class="title">角色迁移</span><a class="img" href="s6.html#s6.2.e" title="PermaLink（e）角色迁移"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>以下接口可用于启用角色迁移：</p>
                  <dl>
                     <dt><code>IBaseMigratable</code></dt>
                     <dd>该接口声明了一个方法<div class="listing plain"><pre>
    <code>&lt;B&gt; <b>void</b> migrateToBase（B otherBase）</code> </pre></div>并指示编译器为任何绑定角色生成此方法的实现，声明<code>IBaseMigratable</code>为其超级接口。<br>在角色实例上调用<code>migrateToBase</code>的效果是将此角色重新绑定到新的基本实例。基本实例必须与角色的基类兼容（为了避免在解除编译器期间出现问题，可能需要基类具有角色基类的确切类型）。将<code>null</code>传递给此方法会导致抛出<code>NullPointerException</code> 。
                     </dd>
                     <dt><code>ITeamMigratable</code></dt>
                     <dd>该接口声明了一个方法<div class="listing plain"><pre>
    <code>&lt;R&gt; R &lt;@otherTeam&gt; migrateToTeam（ <b>最终</b> ITeam otherTeam）</code></pre></div>并指示编译器为任何声明<code>ITeamMigratable</code>作为其超级接口的角色生成此方法的实现。<br>在角色实例上调用<code>migrateToTeam</code>的效果是重新绑定此角色，使其成为新团队实例的包含部分。团队实例必须是角色的封闭团队的确切类型。将<code>null</code>传递给此方法会导致抛出<code>NullPointerException</code> 。<br><div class="note">
                           <h5>警告：</h5>这种方法有意破坏了家族多态性的规则：在迁移之前建立的任何引用<code>R&lt;@previousTeam&gt; r</code>都会错误地暗示角色的封闭团队仍然是<code>previousTeam</code> ，迁移后不再是真的。虽然这不会影响任何方法查找（这仍然是安全的），但基于角色的依赖类型的进一步假设会因团队迁移而失效。从迁移角色到任何兄弟角色实例的引用也是如此。<br>如果应该保持家庭多态性的规则，那么就应该避免将<code>ITeamMigratable</code>声明为角色的超级接口。
                        </div>
                     </dd>
                  </dl>
                  <p>对于这两种方法，接口中声明的签名过于通用，但编译器执行必要的检查以确保角色，基本和团队实例确实兼容，并且另外将<code>migrateToTeam</code>的返回类型作为自我类型进行检查，即，它反映了呼叫目标的确切类型。
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s6.3">
               <h2 class="sect">§6.3注释<a class="img" href="s6.html#s6.3" title="PermaLink至§6.3注释"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§6</a></span></h2>
               <div class="subsect depth3" id="s6.3.a">
                  <h4 class="subsect">（a） <span class="title">控制隐式团队激活</span><a class="img" href="s6.html#s6.3.a" title="PermaLink（a）控制隐式团队激活"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>默认情况下禁用隐式团队激活，可以通过添加注释<code>@org.objectteams.来启用<code>@org.objectteams.ImplicitTeamActivation</code> 。有关详细信息，请参见<a href="s5.html#s5.3.d" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> 。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s6.3.b">
                  <h4 class="subsect">（b） <span class="title">控制提升</span><a class="img" href="s6.html#s6.3.b" title="PermaLink to（b）控制提升"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>如果按照<a href="s2.html#s2.3" title="§2.3提升" class="sect">§2.3</a>和特别是<a href="s2.html#s2.3.1" title="§2.3.1隐式角色创建" class="sect">§2.3.1中的</a>定义进行提升会导致性能问题，则可以使用注释<code>@org.objectteams.按角色类修改提升的语义<code>@org.objectteams.Instantiation</code> 。有关详细信息，请参见<a href="s2.html#s2.3.1.d" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> 。
                     			
                  </p>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s5.html" rel="prev">&lt;&lt;§5团队激活</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s7.html" rel="next">§7角色封装&gt;&gt;</a></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="3847.302_configuration.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>组态</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="configuration">组态</h1>

<p>Xtext提供了两个级别，您可以在其上配置语言：语言生成器和依赖注入。语言生成器使用称为MWE2的特殊DSL来配置生成器。</p>

<h2 id="short-intro-to-mwe">MWE2简介</h2>

<p>MWE2（建模工作流引擎）允许以非常紧凑的方式以声明方式组成对象图。关于它的好处是它只是实例化Java类，并且配置是通过Java Beans封装原则中已知的公共setter和adder方法完成的。可以在<a href="306_mwe2.html">MWE2文档中</a>找到更深入的信息。</p>

<p>给出以下简单的Java类（POJO）：</p>

<pre><code class="language-java">包com.mycompany; public class Person {private String name; public void setName（String name）{this.name = name; private final List &lt;Person&gt; children = new ArrayList &lt;Person&gt;（）; public void addChild（Person child）{this.children.add（child）; }}</code></pre>

<p>通过以声明方式描述MWE2，可以轻松创建具有MWE2的族树，而无需编写单行Java代码，也无需编译类：</p>

<pre><code class="language-mwe2">模块com.mycompany。CreatePersons Person {name =“Grandpa”child = Person {name =“Father”child = {name =“Son”}}}</code></pre>

<p>当由MWE2解释时，这几行将导致由三个<em>com.mycompany实例组成的对象树<em>。人</em>解释器基本上与以下<em>主要</em>方法相同：</p>

<pre><code class="language-java">包com.mycompany; public class CreatePersons {public static void main（String [] args）{Person grandpa = new Person（）; grandpa.setName（ “爷爷”）;人父亲=新人（）; father.setName（ “父亲”）; grandpa.addChild（父亲）;人儿=新人（）; son.setName（ “儿子”）; father.addChild（子）; }}</code></pre>

<p>这就是它的工作原理：根元素是一个普通的Java类名。因为这个MWE2模块是<em>com.mycompany类的兄弟<em>。人</em>没有必要使用完全合格的名称。此外，根据模块中的声明来配置所构造的对象，即创建Person的第二个实例并将其添加到“Grandpa”的孩子列表中，而第三个人成为“父亲”的孩子。所有三个实例都将通过<em>setName</em>方法的反射调用分配其各自的<em>名称</em> 。请注意，在此示例中，“父”的<em>Person</em>类型是明确给出的，而对于“Son”，它是从指定的特征<em>子</em>元素推断出来的。</p>

<p><em>提示：每当您在* .mwe2文件中时，想知道底层组件可以接受哪种配置：只需在MWE2编辑器中使用内容辅助（ctrl + space）或直接导航到底层Java实现的声明，方法是F3（转到声明）。</em></p>

<p>MWE2的另一个常用功能是<em>变量</em> ，可以使用<code>var</code>声明，如下所示。在调用模块时，可以从外部重置这样的变量，例如，当从Maven构建中调用它时允许使用不同的设置。您可以使用<code>${variable-name}</code>表示法在字符串中引用变量。</p>

<pre><code class="language-mwe2">模块com.mycompany。CreatePersons var surname =“Johnson”Person {name =“John $ {surname}”child = {name =“Jim $ {surname}”} child = {name =“Jane $ {surname}”}}</code></pre>

<p>尽管可以使用任意Java类，但MWE2文件的标准根元素是<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/Workflow.java">Workflow</a> ，它是MWE2附带的非常纤薄的运行时模型的一部分。它接受<em>bean</em>和<em>组件</em> 。</p>

<ul>
  <li>
    <p>Workflow.addBean（Object）方法提供了一种应用全局副作用的方法，遗憾的是有时需要这种方法。例如， <a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe.utils/src/org/eclipse/emf/mwe/utils/StandaloneSetup.java">StandaloneSetup</a>可用于初始化全局EMF元数据，例如<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">Epackage。登记处</a> 。</p>
  </li>
  <li>
    <p>Workflow.addComponent（..）方法接受<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe2.runtime/src/org/eclipse/emf/mwe2/runtime/workflow/IWorkflowComponent.java">IWorkflowComponent的</a>实例，这是MWE2工作流模型的主要概念。语言生成器组件本身是IWorkflowComponent的一个实例，因此可以在MWE2工作流程中使用。</p>
  </li>
</ul>

<p>现在我们来看看用于配置Xtext语言生成器的组件模型。</p>

<h2 id="generator">语言生成器</h2>

<p>Xtext为您的语言的基础结构提供了许多通用实现，但也使用代码生成来创建专用组件。这样生成的组件例如是解析器，串行器，推断的Ecore模型（如果有的话）以及用于进一步配置的一些方便的基类。生成器还有助于共享项目资源，例如<em>plugin.xml</em> ， <em>MANIFEST.MF</em>和<a href="#guicemodules">Guice模块</a> 。</p>

<p>本文档是关于Xtext 2.9引入的新生成器基础结构。为了将较旧的Xtext项目迁移到此新基础结构，建议的方法是创建一个新的Xtext项目，并将语法和现有配置从旧项目逐步复制到新项目。</p>

<p>Xtext代码生成的入口点是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/XtextGenerator.xtend">XtextGenerator</a> ，它由<em>一般配置</em>和一组<em>语言配置组成</em> 。常规配置描述了项目的结构以及生成代码的常规设置。每种语言配置对应于特定的语法文件，并允许为相应的语言配置生成的代码。实际的代码生成由语言配置中包含的<em>生成器片段</em>执行。</p>

<p>在下文中，我们看到用MWE2编写的示例语言生成器配置：</p>

<pre><code class="language-mwe2">模块org.example.domainmodel。GenerateDomainmodel import org.eclipse.xtext.xtext.generator。* import org.eclipse.xtext.xtext.generator.model.project。* var rootPath =“..”工作流{component = XtextGenerator {configuration = {project = StandardProjectConfig {baseName =“org.example.domainmodel”rootPath = rootPath eclipsePlugin = {enabled = true} createEclipseMetaData = true} code = {encoding =“ UTF-8“}} language = StandardLanguage {name =”org.example.domainmodel。Domainmodel“fileExtensions =”dmodel“serializer = {generateStub = false}}}}</code></pre>

<p>此示例类似于创建新项目时Xtext项目向导生成的工作流。它使用两个便利类<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/StandardProjectConfig.xtend">StandardProjectConfig</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/StandardLanguage.xtend">StandardLanguage</a> ，它们都设计用于应用适用于大多数语言项目的默认配置。</p>

<h3 id="project-configuration">项目配置</h3>

<p>Xtext生成器需要知道项目的结构，以便将代码生成到正确的路径中。描述项目结构的基类是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/XtextProjectConfig.xtend">XtextProjectConfig</a> 。它由各个子项目的几个描述符组成：</p>

<ul>
  <li><code>runtime</code> - 基本语言特性：语法定义，解析器，序列化器，作用域，验证等。</li>
  <li><code>runtimeTest</code> - <code>runtime</code>单元测试</li>
  <li><code>genericIde</code> - 与平台无关的IDE功能，例如内容辅助服务</li>
  <li><code>eclipsePlugin</code> -  Eclipse的集成插件</li>
  <li><code>eclipsePluginTest</code> -单元测试<code>eclipsePlugin</code></li>
  <li><code>ideaPlugin</code> -  IntelliJ IDEA的集成插件</li>
  <li><code>web</code> - 集成到Web应用程序中</li>
</ul>

<p>这些子项目的类型为<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/SubProjectConfig.xtend">SubProjectConfig，</a>并提供重要参数：</p>

<ul>
  <li><code>enabled</code> - 是否存在子项目</li>
  <li><code>name</code> - 子项目的名称</li>
  <li><code>root</code> - 子项目的根文件夹的路径</li>
  <li><code>src</code> -  Java源文件的文件夹的路径</li>
  <li><code>srcGen</code> - 生成的Java源文件的文件夹的路径</li>
  <li><code>manifest</code> -  MANIFEST.MF文件的配置</li>
  <li><code>pluginXml</code> -  plugin.xml文件的配置</li>
</ul>

<p>由于手动设置所有这些参数将非常繁琐，并且大多数Xtext项目的结构非常相似，因此建议使用上面示例中所示的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/StandardProjectConfig.xtend">StandardProjectConfig</a> 。此专用项目配置将默认值应用于所有参数，因此您只需指定要覆盖默认值的那些参数。例如，给定配置</p>

<pre><code class="language-mwe2">project = StandardProjectConfig {baseName =“org.example.domainmodel”rootPath = rootPath eclipsePlugin = {enabled = true} createEclipseMetaData = true}</code></pre>

<p>我们获得与名称的运行系统项目<code>org.example.domainmodel</code> ，名为Eclipse的集成项目<code>org.example.domainmodel.ui</code> ，并与名称的通用IDE项目<code>org.example.domainmodel.ide</code> （通用IDE项目如果启用了任何集成项目，则自动启用）。源文件夹，MANIFEST.MF和plugin.xml路径设置为Eclipse插件项目的默认值。如果您不想要单独的IDE项目，可以通过为其分配相同的名称将其内容合并到另一个子项目中：</p>

<pre><code class="language-mwe2">project = StandardProjectConfig {baseName =“org.example.domainmodel”rootPath = rootPath genericIde = {name =“org.example.domainmodel.ui”} eclipsePlugin = {enabled = true} createEclipseMetaData = true}</code></pre>

<p>这导致将通用IDE代码生成到Eclipse集成插件中。</p>

<h3 id="other-general-configuration">其他一般配置</h3>

<p>上面我们的生成器工作流示例的配置块包含<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/CodeConfig.xtend">CodeConfig</a>作为<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/StandardProjectConfig.xtend">StandardProjectConfig的</a>兄弟。顾名思义，CodeConfig的参数会影响生成的代码：</p>

<ul>
  <li><code>encoding</code> - 字符编码</li>
  <li><code>fileHeader</code> - 要在每个文件的开头插入的文件头注释</li>
  <li><code>preferXtendStubs</code> - 是否<code>preferXtendStubs</code>使用Xtend over Java来手动实现存根文件;此选项仅适用于<code>src</code>文件夹中的文件，而对于<code>src-gen</code>文件夹，始终生成Java文件。</li>
</ul>

<p><a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/StandardProjectConfig.xtend">StandardProjectConfig</a>和<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/CodeConfig.xtend">CodeConfig</a>的容器属于<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/DefaultGeneratorModule.xtend">DefaultGeneratorModule</a>类型，并分配给<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/XtextGenerator.xtend">XtextGenerator</a>的属性<code>configuration</code> 。DefaultGeneratorModule实际上是一个<a href="https://github.com/google/guice">Guice</a>模块，它可以按照与<a href="#dependency-injection">依赖注入</a>中所述相似的方式进行子类化，以覆盖默认配置。这允许在无法通过MWE2访问的位置更改配置。例如，您可以绑定自己的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/XtextGeneratorNaming.xtend">XtextGeneratorNaming</a>子类，以便影响生成的类的名称。</p>

<h3 id="language-configuration">语言配置</h3>

<p>描述语言配置的基类是<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/XtextGeneratorLanguage.xtend">XtextGeneratorLanguage</a> ，其最重要的参数是</p>

<ul>
  <li><code>name</code> - 语法的名称，与语法定义的第一行中指定的完全相同</li>
  <li><code>grammarUri</code> - 指向语法定义文件的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.common/src/org/eclipse/emf/common/util/URI.java">URI</a> ;如果省略，则假定语法文件位于运行时项目的Java源文件夹中，并根据语言名称命名。</li>
  <li><code>fileExtensions</code> - 该语言的逗号分隔的文件扩展名列表</li>
  <li><code>referencedResources</code> - 要加载的其他资源（请参阅<a href="#importing-metamodels">导入现有元模型</a> ）</li>
</ul>

<p>实际的代码生成由<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/IXtextGeneratorFragment.xtend">生成器片段</a>执行，可以使用<code>fragment</code>属性将其添加到语言配置中。Xtext项目向导创建一个使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/StandardLanguage.xtend">StandardLanguage</a>的工作流，该工作流以与<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/StandardLanguage.xtend">StandardProjectConfig</a>专用XtextProjectConfig类似的方式专门化XtextGeneratorLanguage（请参阅<a href="#project-configuration">项目配置</a> ）。StandardLanguage的主要贡献是生成器片段的默认列表，其中包含Xtext的所有功能。这些片段会自动调整其生成的代码以适应您的语言和项目配置。一些片段提供自己的配置参数，因此可以通过StandardLanguage中的专用属性访问每个片段。例如，在语言配置中</p>

<pre><code class="language-mwe2">language = StandardLanguage {name =“org.example.domainmodel。Domainmodel“fileExtensions =”dmodel“serializer = {generateStub = false}}</code></pre>
<p>我们看到对<code>serializer</code>片段禁用了<code>generateStub</code>参数，这意味着该片段不应该创建任何存根文件来自定义序列化。</p>

<p>无法从<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/StandardLanguage.xtend">StandardLanguage中</a>删除片段。如果需要省略一个或多个默认片段的语言配置，则可以使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/XtextGeneratorLanguage.xtend">XtextGeneratorLanguage</a>代替并明确列出所需片段。您可以将以下配置作为模板：</p>

<pre><code class="language-mwe2">language = XtextGeneratorLanguage {name =“org.example.domainmodel。Domainmodel“fileExtensions =”dmodel“referencedResource =”platform：/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel“fragment = grammarAccess。GrammarAccessFragment2 {} fragment = ecore。EMFGeneratorFragment2 {} fragment = serializer。SerializerFragment2 {} fragment = resourceFactory。ResourceFactoryFragment2 {} fragment = parser.antlr。XtextAntlrGeneratorFragment2 {} fragment = validation。ValidatorFragment2 {} fragment =作用域。ImportNamespacesScopingFragment2 {} fragment = exports。QualifiedNamesFragment2 {} fragment = builder。BuilderIntegrationFragment2 {} fragment = generator。GeneratorFragment2 {} fragment =格式化。Formatter2Fragment2 {} fragment = ui.labeling。LabelProviderFragment2 {} fragment = ui.outline。QuickOutlineFragment2 {} fragment = ui.outline。OutlineTreeProviderFragment2 {} fragment = ui.quickfix。QuickfixProviderFragment2 {} fragment = ui.contentAssist。ContentAssistFragment2 {} fragment = junit。Junit4Fragment2 {} fragment = ui.refactoring。RefactorElementNameFragment2 {} fragment = types。TypesGeneratorFragment2 {} fragment = xbase。XtypeGeneratorFragment2 {} fragment = xbase。XbaseGeneratorFragment2 {} fragment = ui.templates。CodetemplatesGeneratorFragment2 {} fragment = ui.compare。CompareFragment2 {} fragment = idea.parser.antlr。XtextAntlrIDEAGeneratorFragment {} fragment = idea。IdeaPluginGenerator {} fragment = web。WebIntegrationFragment {framework =“Ace”} fragment = ui.projectWizard。TemplateProjectWizardFragment {} fragment = ui.fileWizard。TemplateFileWizardFragment {}}</code></pre>

<h3 id="importing-metamodels">导入现有的元模型</h3>

<p>如<a href="301_grammarlanguage.html#epackage-import">语法语言参考中所述</a> ，可以将现有元模型导入到您的语言定义中。</p>

<p>您可以在语法文件中使用名称空间URI来导入现有的EPackage。这通常是可取的，其他URI方案被认为已弃用。使用命名空间URI，将从Xtext索引读取包，因此您的语法独立于相应ecore文件的具体位置。您必须确保ecore文件包含在由Xtext管理的项目中。因此，项目必须附加Xtext项目性质。如果引用项目本身是Xtext项目，则会自动选择驻留在引用的Java归档（JAR）中的Ecore文件并编制索引。</p>

<p>为了能够在语言生成器中找到引用的包，必须在语言配置中提及其Ecore生成器模型：</p>

<pre><code class="language-mwe2">language = StandardLanguage {name =“org.example.domainmodel。Domainmodel“fileExtensions =”dmodel“referencedResource =”platform：/resource/org.example.domainmodel/model/Domainmodel.genmodel“}</code></pre>

<p>如果要导入多个元模型，则可以根据需要添加更多<code>referencedResource</code>声明。</p>

<p>在某些情况下，这种引用元模型的简单方法是不够的;然后，您可以使用<a href="https://github.com/eclipse/mwe/blob/v2.7.1/plugins/org.eclipse.emf.mwe.utils/src/org/eclipse/emf/mwe/utils/StandaloneSetup.java">StandaloneSetup</a>作为工作流bean来微调EMF设置。例：</p>

<pre><code class="language-mwe2">bean = StandaloneSetup {platformUri =“$ {rootPath}”scanClassPath = true registerGeneratedEPackage =“my.project。DomainmodelPackage“registerGenModelFile =”platform：/resource/my.project/model/Domainmodel.genmodel“}</code></pre>

<hr>

<h2 id="dependency-injection">依赖注入</h2>

<p>所有Xtext组件都通过依赖注入（DI）进行组装。这基本上意味着每当某些代码需要来自另一个组件的功能（或状态）时，只需声明依赖性而不是声明如何解决它，即获得该组件。</p>

<p>例如，当某些代码想要使用范围提供程序时，它只声明一个字段（或方法或构造函数）并添加<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Inject.html">Inject</a>批注：</p>

<pre><code class="language-java">公共类MyLanguageLinker扩展了Linker {@Inject private IScopeProvider scopeProvider; }</code></pre>

<p>客户端代码的职责不是关心<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>实现的来源或创建方式。当实例化上述类时，Guice发现它需要一个IScopeProvider实例并将其分配给指定的字段或方法参数。这当然只有在Guice创建对象本身时才有效。在Xtext中，几乎每个实例都是以这种方式创建的，因此整个依赖网络都是通过Guice的方式控制和配置的。</p>

<p>Guice当然需要知道如何为声明的依赖项实例化真实对象。这是在所谓的<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Module.html">模块中完成的</a> 。<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Module.html">模块</a>定义了一组从类型到现有实例，实例提供者或具体类的映射。模块以Java实现。这是一个例子：</p>

<pre><code class="language-java">公共类MyDslRuntimeModule实现模块{@Override public void configure（Binder binder）{binder .bind（IScopeProvider.class）.to（MyConcreteScopeProvider.class）; }}</code></pre>

<p>使用普通的Guice模块，可以实现一个名为configure的方法，并获取一个<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Binder.html">Binder</a>传入。该绑定器提供了一个流畅的API来定义提到的映射。</p>

<h3 id="guicemodules">模块API</h3>

<p>运行Xtext生成器后，您将获得几种不同的语言模块：一个用于基础项目，另一个用于每个平台集成项目。例如，对于名为<em>Domainmodel</em>的语言，我们将拥有<em>DomainmodelRuntimeModule</em> ， <em>DomainmodelUiModule</em> （用于Eclipse集成）， <em>DomainmodelIdeaModule</em> （用于IntelliJ IDEA集成）和<em>DomainmodelWebModule</em> 。来自运行时模块的绑定由所有集成项目共享。</p>

<p>Xtext附带了一个稍微增强的模块API。抽象基类<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/service/AbstractGenericModule.java">AbstractGenericModule</a>反映某些方法，以便查找声明的绑定。最常见的方法是</p>

<pre><code class="language-java">公共班&lt;？扩展IScopeProvider&gt; bindIScopeProvider（）{return MyConcreteScopeProvider.class; }</code></pre>

<p>这与上面的代码片段相同。它只是声明从<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>到<em>MyConcreteScopeProvider</em>的绑定。只要声明了对<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>的依赖，该绑定将使Guice实例化并注入<em>MyConcreteScopeProvider</em>的新实例。</p>

<p>每个绑定有一个方法允许通过覆盖相应的方法来停用单个绑定，并通过返回不同的目标类型或通过返回null完全删除该绑定来更改绑定。</p>

<p>支持另外两种绑定方法。第一个允许配置<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Provider.html">Provider</a> ，它就像一个特定类型的工厂。如果在创建特定类型的实例时需要挂钩，则可以使用此方法。例如，如果您想提供对单例的延迟访问，或者每次创建实例（即工厂）时都需要进行一些计算。如果要指向提供程序而不是具体类，可以使用以下绑定方法。</p>

<pre><code class="language-java">公共班&lt;？extends Provider &lt;IScopeProvider &gt;&gt; provideIScopeProvider（）{return MyConcreteScopeProviderFactory.class; }</code></pre>

<p>注意：请原谅我们过度使用术语<em>提供者</em> 。<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>不是Guice <a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Provider.html">提供者</a> 。</p>

<p>该绑定告诉Guice实例化<em>MyConcreteScopeProviderFactory</em>并调用get（）以获取已声明对该类型的依赖关系的客户端的<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java">IScopeProvider</a>实例。提到的两种绑定方法都允许返回实例而不是类型。如果应在应用程序中共享某个全局状态，这可能很有用。对于一个简单的例子，这将是</p>

<pre><code class="language-java">public IScopeProvider bindIScopeProvider（）{return new MyConcreteScopeProvider（）; }</code></pre>

<p>以及提供者绑定</p>

<pre><code class="language-java">public Provider &lt;IScopeProvider&gt; provideIScopeProvider（）{return new MyConcreteScopeProviderFactory（）; }</code></pre>

<p>Xtext提供的第三种绑定方法允许您使用Guice的绑定API执行任何操作，因为它允许您直接使用<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Binder.html">Binder</a> 。方法的名称必须以'configure'开头，返回类型必须为<code>void</code> ，并且它必须接受<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Binder.html">Binder</a>类型的一个参数：</p>

<pre><code class="language-java">public void configureIScopeProvider（Binder binder）{binder.bind（IScopeProvider.class）.to（MyConcreteScopeProvider.class）; }</code></pre>

<p>这些是围绕Guice的基本思想，以及Xtext提供的小扩展。有关更多信息，我们强烈建议您阅读<a href="https://github.com/google/guice">Google Guice网站</a>上<a href="https://github.com/google/guice">的</a>文档。</p>

<h3 id="obtaining-an-injector">获得注射器</h3>

<p>在与Guice连接的每个应用程序中，通常有一点使用声明的模块初始化<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Injector.html">Injector</a> 。通常这是使用<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Guice.html">Guice</a>的静态方法完成的。但是，在Xtext中，您不应该自己实例化语言的注入器。</p>

<p>Xtext可以在引入不同约束的不同环境中使用。特别重要的是OSGi托管容器和普通Java程序之间的区别。为了兑现这些差异，Xtext在正常模式下使用<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java">ISetup</a>实现的概念，并在应该在OSGi环境中配置时使用Eclipse的扩展机制。</p>

<h4 id="runtime-setup">运行时安装程序</h4>

<p>对于每种语言， <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java">都会</a>生成<a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java">ISetup的</a>实现。它实现了一个名为<code>createInjectorAndDoEMFRegistration()</code>的方法，可以调用该方法来进行语言基础结构的初始化。</p>

<pre><code class="language-java">public static void main（String [] args）{Injector injector = new MyDslStandaloneSetup（）。createInjectorAndDoEMFRegistration（）; MyApplication application = injector.getInstance（MyApplication.class）; application.run（）; }</code></pre>

<p>setup方法返回一个<a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Injector.html">Injector</a> ，它可以进一步用于获取解析器等。它还注册了<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/resource/Resource.java">Resource。工厂</a>和生成的<a href="https://github.com/eclipse/emf/blob/R2_9_0/plugins/org.eclipse.emf.ecore/src/org/eclipse/emf/ecore/EPackage.java">EPackages</a>由EMF提供给各自的全球注册机构。因此，基本上在运行设置之后，您可以开始使用EMF API来加载和存储您的语言模型。</p>

<p><strong>警告：</strong> <a href="https://github.com/eclipse/xtext-core/blob/master/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java">ISetup</a>类仅用于运行时和单元测试。如果在Equinox场景中使用它，则很可能会破坏正在运行的应用程序，因为全局注册表的条目将被覆盖。</p>

<h4 id="equinox-setup">Eclipse-Equinox（OSGi）中的安装程序</h4>

<p>在Eclipse中，我们有一个生成的<em>Activator</em> ，它使用<a href="#guicemodules">模块</a>创建一个Guice <a href="https://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Injector.html">Injector</a> 。此外，还为每种语言生成<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtensionFactory.html">IExecutableExtensionFactory</a> ，用于创建<a href="http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtension.html">IExecutableExtensions</a> 。这意味着通过扩展点创建的所有内容也由Guice管理，即您可以声明依赖项并在创建时注入它们。</p>

<p>要使用此工厂，您唯一需要做的就是在类<em>前面添加</em>生成的<em>ExecutableExtensionFactory</em>名称，后跟冒号。</p>

<pre><code class="language-xml">&lt;extension point =“org.eclipse.ui.editors”&gt; &lt;editor class =“example。MyDslExecutableExtensionFactory：org.eclipse.xtext.ui.editor。XtextEditor“contributorClass =”org.eclipse.ui.editors.text。TextEditorActionContributor“default =”true“extensions =”mydsl“id =”org.eclipse.xtext.example。MyDsl“name =”MyDsl Editor“&gt; &lt;/ editor&gt; &lt;/ extension&gt;</code></pre>

<hr>

<h2 id="logging">记录</h2>

<p>Xtext使用<a href="http://logging.apache.org/log4j/">Apache Log4j</a>进行日志记录。它使用名为<em>log4j.properties的</em>文件进行配置，这些文件在Java类路径的根目录中查找。如果要在运行时更改或提供配置（即非OSGi），您所要做的就是将<em>log4j.properties</em>置于适当的位置，并确保它不被先前类路径条目中的其他<em>log4j.properties</em>覆盖。</p>

<p>在OSGi中，您可以通过为<em>org.apache.log4j</em>创建片段来提供配置。在这种情况下，您需要确保没有任何第二个片段贡献<em>log4j.properties</em>文件。</p>

<hr>

<p><strong><a href="303_runtime_concepts.html">下一章：语言实现</a></strong></p>


</body>
</html><html id="2876.org_eclipse_ui_editorActions.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>编辑器菜单，工具栏和操作</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">编辑器菜单，工具栏和操作</h1>
<div style="border:1px solid #990000;padding:5px;text-align:center;color:red">不推荐使用此扩展点</div>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.editorActions<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p>
<b>警告：此扩展点已弃用。</b><br>请勿使用此扩展点，将在本产品的未来版本中将其删除。相反，请使用扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a>
</p>此扩展点用于向其他插件注册的编辑器的菜单和工具栏添加操作。
<p>您现在可以使用<a href="org_eclipse_ui_menus.html">org.eclipse.ui.menus</a>将命令放在菜单和工具栏中。
</p>
<p>为编辑器设置的初始贡献由另一个扩展点（org.eclipse.ui.editors）定义。一组操作由同一编辑器类型的所有实例创建和共享。调用时，这些操作将作用于活动编辑器。此扩展点遵循相同的模式。每个操作扩展都由相同编辑器类型的所有实例创建和共享。动作类是实现<samp>org.eclipse.ui所必需的<samp>。IEditorActionDelegate</samp> 。通过调用<samp>IEditorActionDelegate.setActiveEditor</samp>将活动编辑器传递给委托。</p><p>
</p>
<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.editorContribution">editorContribution</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>editorContribution</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.editorContribution">editorContribution</a> （ <a href="#e.menu">menu</a> *， <a href="#e.action">action</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST编辑贡献</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">targetID IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义一组编辑器操作和/或菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用于引用此贡献的唯一标识符。</li>
<li><b>targetID</b> - 作为此贡献的目标的已注册编辑器的唯一标识符。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>action</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.action">动作</a> （（ <a href="#e.selection">选择</a> * | <a href="#e.enablement">启用</a> ？）， <a href="#e.class">类</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST行动</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">加速器CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">menubarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">toolbarPath CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">disabledIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">hoverIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">工具提示CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">style（push | radio | toggle）“push”</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">enableFor CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">actionID CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">模式（FORCE_TEXT）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素定义用户可以在UI中调用的操作。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 用作此操作的引用的唯一标识符。</li>
<li><b>label</b> - 可翻译的名称，用作菜单项文本或工具栏按钮标签。名称可以包括mnenomic信息。此标签应为非空或应提供definitionId。</li>
<li><i style="color:red">不推荐使用的</i> <b>加速器</b> - <b><font color="#FF0000">不推荐使用：</font></b>改为使用<samp>definitionId</samp>属性。</li>
<li><b>definitionId</b> - 指定此操作将处理的命令。通过指定和操作，密钥绑定服务可以为此操作分配密钥序列。有关更多信息，请参阅扩展点<a href="org_eclipse_ui_commands.html">org.eclipse.ui.commands</a> 。</li>
<li><b>menubarPath</b> - 斜杠分隔的路径（'/'），用于在菜单栏中指定此操作的位置。路径中的每个标记（最后一个标记除外）必须表示层次结构中现有菜单的有效标识符。最后一个标记表示将添加此操作的命名组。如果省略该路径，则此操作不会出现在菜单栏中。</li>
<li><b>toolbarPath</b> - 斜杠分隔的路径（'/'），用于指定工具栏中此操作的位置。第一个标记表示工具栏标识符（“Normal”是默认工具栏），而第二个标记是工具栏中将添加此操作的命名组。如果工具栏中不存在该组，则会创建该组。如果省略toolbarPath，则操作不会出现在工具栏中。</li>
<li><b>icon</b> - 用于在其上下文中直观表示操作的图标的相对路径。如果省略并且操作显示在工具栏中，Workbench将使用占位符图标。该路径相对于贡献插件的plugin.xml文件的位置。该图标将显示在工具栏中，但不会显示在菜单中。启用的操作将由hoverIcon在菜单中显示。</li>
<li><b>disabledIcon</b> - 用于在禁用操作时直观地表示其上下文中的操作的图标的相对路径。如果省略，则普通图标将显示为灰色。该路径相对于贡献插件的plugin.xml文件的位置。禁用的图标将显示在工具栏中，但不会显示在菜单中。菜单中的禁用操作图标将由OS提供。</li>
<li><b>hoverIcon</b> - 用于在鼠标指针悬停在操作上时可视地表示其上下文中的操作的图标的相对路径。如果省略，将使用普通图标。该路径相对于贡献插件的plugin.xml文件的位置。</li>
<li><b>tooltip</b> - 表示动作工具<b>提示</b>的可翻译文本。仅在操作显示在工具栏中时使用。</li>
<li><b>helpContextId</b> - 一个唯一标识符，指示此操作的帮助上下文。如果操作显示为菜单项，则在菜单项突出显示时按F1将显示帮助。</li>
<li><b>style</b> - 用于定义操作的用户界面样式类型的可选属性。如果已定义，则属性值将为以下之一：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>推</b></td>
        <td valign="top">- 作为常规菜单项或工具项。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>无线电</b></td>
        <td valign="top">- 作为收音机样式的菜单项或工具项。在同一菜单或工具栏组中使用无线电样式的操作表现为收音机。初始值由<samp>state</samp>属性指定。</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>切换</b></td>
        <td valign="top">- 作为检查样式菜单项或切换工具项。初始值由<samp>state</samp>属性指定。</td>
      </tr>
    </table></li>
<li><b>state</b> - 一个可选属性，指示初始状态（ <samp>true</samp>或<samp>false</samp> ），当<samp>style</samp>属性具有值<samp>radio</samp>或<samp>toggle时使用</samp> 。</li>
<li><b>class</b> - 实现<samp>org.eclipse.ui的完全限定类的名称<samp>。IEditorActionDelegate</samp></li>
<li><b>enableFor</b> - 一个值，指示启用操作必须满足的选择计数。如果指定了此属性并且满足条件，则启用该操作。如果不满足条件，则禁用该操作。如果未指定任何属性，则会为所选的任意数量的项启用该操作。支持以下属性格式：<table border="0" width="80%">
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>！</b></td>
        <td valign="top">- 选择了0个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>？</b></td>
        <td valign="top">- 选择了0或1个项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>+</b></td>
        <td valign="top">- 选择了1个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>多个，2 +</b></td>
        <td valign="top">- 选择了2个或更多项目</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>ñ</b></td>
        <td valign="top">- 精确选择的项目数。精确选择的项目数。例如：enableFor =“4”仅在选择4个项目时启用操作</td>
      </tr>
      <tr>
 <td valign="top" width="25"></td>
        <td valign="top" nowrap=""><b>*</b></td>
        <td valign="top">- 选择任意数量的项目</td>
      </tr>
    </table></li>
<li><b>actionID</b> - 文本编辑器使用的内部标记。插件开发人员不应该使用它。以下ID对文本编辑器框架具有特殊含义：<ul>
<li>“RulerClick”：在（左）垂直标尺中单击时调用的贡献动作</li>
<li>“RulerDoubleClick”：在（左）垂直标尺中单击时调用的贡献操作</li>这些特殊ID可以使用modifires作为前缀，以支持使用修饰符（例如M1 + M3 + RulerClick）的多个操作的贡献。此操作将不同于M1 + M2 + RulerClick或RulerClick，因此将触发操作。
</ul>
<p>如果多个扩展为同一文本编辑器提供标尺操作，则插件位于先决条件树顶部的扩展会获胜。如果有多个这样的插件，第一个获胜。
</p></li>
<li><b>mode</b> - 对于出现在工具栏中的操作，即使有图标， <code>FORCE_TEXT</code>也会显示文本。请参阅ActionContribuitonItem。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>参数</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">要在IExecutableExtension元素中使用的参数元素。这将作为初始化数据传递给实例化的类。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 参数名称</li>
<li><b>value</b> - 参数值</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>class</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.class">类</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST课程</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>class</code>属性的元素版本。当类实现<code>org.eclipse.core.runtime.IExecutableExtension</code> ，您希望在初始化时使用参数化数据。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 实现<code>org.eclipse.ui.的类<code>org.eclipse.ui.IEditorActionDelegate</code> 。它也可以实现<code>org.eclipse.core.runtime.IExecutableExtension</code> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.menu">菜单</a> （ <a href="#e.separator">separator</a> *， <a href="#e.groupMarker">groupMarker</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST菜单</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义新菜单。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 可用于引用此菜单的唯一标识符。</li>
<li><b>label</b> -  Workbench用于此新菜单的可翻译名称。名称应包括助记符信息。</li>
<li><b>path</b> - 从菜单根开始的新菜单的位置。路径中的每个标记必须引用现有菜单，但最后一个标记除外，该标记应代表路径中最后一个菜单中的命名组。如果省略，新菜单将添加到菜单的<samp>添加</samp>命名组中。</li>
<li><b>icon</b> - 用于在其上下文中直观地表示菜单的图标的相对路径。该路径相对于贡献插件的plugin.xml文件的位置。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.separator">分隔符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST分隔符</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建菜单分隔符。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 菜单分隔符的名称。此名称稍后可以作为菜单路径中的最后一个标记引用。因此，分隔符也可以作为命名组，可以在其中添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.groupMarker">groupMarker</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST groupMarker</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于在新菜单中创建命名组。与<samp>分隔符</samp>元素不同，它在新菜单中没有可视化表示。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 组标记的名称。稍后可以将此名称引用为菜单路径中的最后一个标记。它作为命名组，可以添加操作和菜单。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selection">选择</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST选择</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于帮助确定基于当前选择的操作启用。如果指定了<samp>enablement</samp>元素，则忽略。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 选择中的每个对象必须实现的类或接口的完全限定名称才能启用该操作。</li>
<li><b>name</b> - 可以应用于选择中所有对象的名称的可选通配符过滤器。如果指定且匹配失败，则将禁用该操作。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是编辑器操作扩展的示例：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.editorActions”</span> <span class="code SchemaTag">&gt; &lt;editorContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyzContribution”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“com.ibm。XMLEditor“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”XYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; XYZ Menu“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; Run XYZ工具“</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">”XYZ / group1“</span> <span class="code SchemaTag">toolbarPath =</span> <span class="code SchemaCstring">”正常/添加“</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">”toggle“</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">”icons / runXYZ.png“</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">”运行XYZ工具“</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">”com.xyz.run_action_context “</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”com.xyz.actions。RunXYZ“</span> <span class="code SchemaTag">&gt; &lt;selection class =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">/&gt; &lt;/ action&gt; &lt;/ editorContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为名为“XYZ Menu”的新顶级菜单中的复选框项，以及工具栏中的切换按钮。如果选择仅包含Java文件资源，则启用该操作。
</p><p>以下是编辑器操作扩展的另一个示例：</p><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.editorActions”</span> <span class="code SchemaTag">&gt; &lt;editorContribution id =</span> <span class="code SchemaCstring">“com.xyz.xyz2Contribution”</span> <span class="code SchemaTag">targetID =</span> <span class="code SchemaCstring">“com.ibm。XMLEditor“</span> <span class="code SchemaTag">&gt; &lt;menu id =</span> <span class="code SchemaCstring">”XYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">”＆amp; XYZ2 Menu“</span> <span class="code SchemaTag">path =</span> <span class="code SchemaCstring">”edit / additions“</span> <span class="code SchemaTag">&gt; &lt;separator name =</span> <span class="code SchemaCstring">”group1“</span> <span class="code SchemaTag">/&gt; &lt;/ menu&gt; &lt;action id =</span> <span class="code SchemaCstring">”com.xyz.runXYZ2“</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“＆amp; Run XYZ2 Tool”</span> <span class="code SchemaTag">menubarPath =</span> <span class="code SchemaCstring">“edit / XYZ2 / group1”</span> <span class="code SchemaTag">style =</span> <span class="code SchemaCstring">“push”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“icons / runXYZ2.png”</span> <span class="code SchemaTag">tooltip =</span> <span class="code SchemaCstring">“运行XYZ2工具”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“com.xyz.run_action_context2”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz.actions。RunXYZ2“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;not&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ not&gt; &lt;/ and&gt; &lt;/ enablement&gt; &lt;/ action&gt; &lt;/ editorContribution&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，指定的操作将显示为顶级“编辑”菜单中名为“XYZ2菜单”的子菜单中的菜单项。如果选择不包含Java文件资源，则启用该操作。
</p><p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须是实现<samp>org.eclipse.ui的Java类的完全限定名<samp>。IEditorActionDelegate</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。每次激活指定类型的编辑器时，都将调用方法<samp>setActiveEditor</samp> 。无论在Workbench中当前打开的编辑器实例的数量如何，都将仅为指定编辑器类型的所有实例创建一组操作和菜单。
<p>此扩展点可用于将操作提供给目标编辑器先前创建的菜单。此外，菜单和操作可以提供给Workbench窗口。Workbench窗口中的操作和主要组的标识符在<samp>org.eclipse.ui中定义<samp>。IWorkbenchActionConstants</samp> 。这些应该用作添加新操作的参考点。通过使用path属性的以下值创建顶级菜单：</p><ul>
<li>添加 - 表示<samp>窗口</samp>菜单左侧的命名组。
</li>
</ul>省略path属性将导致将新菜单添加到添加菜单栏组中。
<p>只有在关联的编辑器处于活动状态时，才会显示添加到这些路径中的操作和菜单。关闭编辑器后，将删除菜单和操作。
</p><p>动作扩展的启用标准最初由<samp>enableFor</samp>定义，也可以由<samp>选择</samp>或<samp>启用定义</samp> 。但是，一旦动作委托被实例化，它就可以直接在其<samp>selectionChanged</samp>方法中控制动作启用状态。
</p><p>操作和菜单标签可能包含使用以下规则编码助记符的特殊字符：</p><ol>
<li>使用翻译文本中所选字符前面的＆符号（'＆'）指定助记符。由于XML字符串中不允许使用<samp>＆</samp>符号，因此请使用<samp>＆amp;</samp>字符实体。</li>
</ol>如果单个扩展名为菜单或工具栏提供了两个或多个操作，则操作将按照与plugin.xml文件中列出的操作相反的顺序显示。这种行为无疑是不直观的。但是，它在Eclipse Platform API被冻结后被发现。现在改变行为会破坏依赖于现有行为的每个插件。
<p><samp>选择</samp>和<samp>启用</samp>元素是互斥的。<samp>enablement</samp>元素可以使用子元素<samp>objectClass</samp>和<samp>objectState</samp>替换<samp>选择</samp>元素。例如，以下内容：</p><pre class="Example"><span class="code SchemaTag">&lt;selection class =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”* .java“</span> <span class="code SchemaTag">&gt; &lt;/ selection&gt;</span></pre>可用以下方式表达：<pre class="Example"><span class="code SchemaTag">&lt;enablement&gt; &lt;和&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">“org.eclipse.core.resources。IFile“</span> <span class="code SchemaTag">/&gt; &lt;objectState name =</span> <span class="code SchemaCstring">”extension“</span> <span class="code SchemaTag">value =</span> <span class="code SchemaCstring">”java“</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/ enablement&gt;</span></pre>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>Workbench提供了内置的“默认文本编辑器”。插件可以为此默认编辑器或其他插件提供的编辑器做出贡献。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2019 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3328.Specifying_Viewpoints.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Specifying_Viewpoints</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingViewpoints">指定视点</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingViewpoints">指定视点</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#concepts">哲学与概念</a>
					</li>
					<li>
						<a href="#vsp">观点规范项目</a>
					</li>
					<li>
						<a href="#vsm">观点规范模型</a>
						<ol style="list-style:disc">
							<li>
								<a href="#vsm_organization">组织</a>
							</li>
							<li>
								<a href="#common_attributes">共同属性</a>
							</li>
							<li>
								<a href="#type_names">输入名称</a>
							</li>
							<li>
								<a href="#interpreted_expressions">解释表达式</a>
							</li>
							<li>
								<a href="#feature_name">功能名称</a>
							</li>
							<li>
								<a href="#translatable_messages">可翻译的消息</a>
							</li>
							<li>
								<a href="#model_operations">模型操作</a>
							</li>
							<li>
								<a href="#quick_outline">快速大纲</a>
							</li>
							<li>
								<a href="#validation">VSM验证</a>
							</li>
							<li>
								<a href="#dynamic">动态发展</a>
							</li>
							<li>
								<a href="#migration">从先前版本迁移</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<p></p><div style="display:none">
			<br>TODO添加一些屏幕截图以减少文档干燥。
			<br></div>
		
		<p>本文档概述了如何指定，测试和部署视点。</p>
		<h2 id="introduction">介绍</h2>
		<p>
			<em>Sirius</em>是一种建模工具，最初是在复杂系统建模的环境中创建的。这些系统的复杂性使得有不同关注点的人员的合作成为必要。对于相同的域和相同的数据，可能存在不同级别的分析，不同角色和不同关注点。这些中的每一个都对应于同一<em>域模型</em>上的不同<em>视点</em> ，而Sirius（系统）为您提供了所有工具来指定与您的业务域相关的视点，无论它是什么。
		</p>
		<p>更实际的是，Sirius假设您的<em>域模型</em>是使用<em>EMF</em> （Eclipse Modeling Framework）定义的，这是一个具有丰富生态系统的行业标准。许多现有标准，如UML（用于软件系统）或TOGAF（用于企业架构）都具有基于EMF的实现。您还可以轻松定义自己<em>的特定于域的模型</em> （有时称为<em>特定</em>于<em>域的语言</em> ），以更精确地满足您的特定需求，并避免不必要的复杂性。虽然这部分（域规范）并不严格在Sirius的范围内，但系统提供了一个图形建模器，可以轻松创建自己的<em>DSM</em> （特定于域的模型）。
		</p>
		<p>鉴于这样一个领域模型，它在抽象中定义概念及其关系，Sirius将允许您轻松指定这些模型的<em>具体表示</em> 。表示可以是图表，表格，矩阵（交叉表）或层次结构（树）。您可以根据需要定义多个，一些比其他更详细，一些针对特定任务或角色（例如初始设计，审查，认证等）进行定制。这些表示不仅仅是静态的：如果您指定了适当的工具（见下文），它们可以是完整的建模环境，用户可以在其中创建，修改和验证他们的设计。表示可以在<em>视点中</em>进行逻辑组织，最终用户可以随意启用或禁用视点，以通过不同但逻辑上一致的视点在同一模型上工作。
		</p>
		<p>Sirius平台的主要优势可归纳为：</p>
		<ul>
			<li>它基于一个开放且广泛使用的<em>行业标准</em> （Eclipse Modeling Framework）;</li>
			<li>它可以<em>适应</em>任何与EMF兼容的DSM：它可以使用UML等标准，如果它们符合您的需求，但它不会强迫您这样做，并且您可以轻松创建自己的DSM，因此可以更简单，更适合于你的具体需求;</li>
			<li>它提供了它操作的语义模型（业务价值所在的位置）和表示模型（例如，处理图表中图形形状的大小和位置）之间的<em>强大分离</em> 。这意味着您的域模型不依赖于Sirius本身，并且可以使用EMF生态系统中的任何其他工具进行操作（例如，Acceleo生成源代码或其他文本工件）;</li>
			<li>它允许您在域模型上定义许多<em>不同的表示</em> ：图表，表格，树，显示不同级别的详细信息，并根据其用途提供不同的版本功能;</li>
			<li>它<em>易于使用，</em>并支持<em>非常快速的</em>开发。熟悉该工具后，您将能够在几分钟内获得一个简单的图表，一个适合几小时内客户端演示的原型，以及几天工作中的全功能和自定义建模器;</li>
			<li>它是<em>可扩展的</em> ：通过集成Eclipse平台并提供开放API，您可以将Sirius建模器与其他工具一起扩展和集成，从而为您的用户提供完全自定义的建模工作台。
			</li>
		</ul>
		<h2 id="concepts">哲学与概念</h2>
		<p>如介绍中所述， <em>Sirius</em>允许您指定专用表示和相关工具。作为<em>说明符</em> ，您的角色将是配置通用Sirius平台以向您的用户提供这些表示。这是通过创建和配置<a href="../../Glossary.html#VSM"><em>Viewpoint规范模型</em></a>来完成的，该<a href="../../Glossary.html#VSM"><em>模型</em></a>描述了建模者的结构，外观和行为。本文档不涉及您的域模型的定义;您可以使用UML，SysML，BPMN或TOGAF等标准版，也可以创建自定义版。Sirius的唯一假设是您的模型基于EMF。</p>
		<p>您将作为说明符使用的主要概念是：</p>
		<ul>
			<li>
				<strong>视点</strong>视点是说明符定义的核心元素之一：它是<strong>表示规范</strong>和<strong>表示扩展规范</strong>的逻辑集合。
			</li>
			<li>
				<strong>表示</strong> <em>表示</em>是一组<strong>表示域数据</strong>的<strong>图形结构</strong> 。表示描述了建模者的结构，外观和行为。默认情况下，Sirius支持四种表示（称为<em>方言</em> ）：图表，表格，矩阵（也称为交叉表格）和树。所有这些都遵循其定义中的相同基本原则。
			</li>
			<li>
				<strong>映射</strong> <em>映射</em>标识应出现在表示中的语义模型元素的子集，并指示它们应如何表示。每种方言都提供不同类型的映射。例如，图表提供<em>容器映射</em> ，可用于使用图形容器表示语义元素，其中可以显示其他元素（由其他映射指定）。<em>视点规范模型中</em>存在映射，但在具体表示中，它将生成<em>实例</em> 。如果指定容器映射来表示企业中的分部，并且企业的模型包含四个分区，则具体图将显示四个容器，每个容器都是相同映射的实例，但与不同的语义元素相关联。
			</li>
			<li>
				<strong>样式</strong>每个映射都可以有一个或多个与之关联的<em>样式</em> ，用于配置它们所代表的元素的可视外观。例如，对于图表元素，这将包括它们的形状和颜色。
			</li>
			<li>
				<strong>工具</strong>没有工具，您的表示只是可视化，没有版本功能。虽然这有时很有用，但大多数表示都允许用户创建，编辑和删除元素。工具与映射关联以描述其行为。<em>Sirius</em>支持的每种用户交互（例如创建或删除，标签编辑，边缘重新连接......）由不同类型的工具指定，但它们在定义中都遵循相同的原则。
			</li>
		</ul>
		<h2 id="vsp">观点规范项目</h2>
		<p>注意：当作为Sirius说明符工作时，建议使用<em>Sirius</em>透视图，它提供了一些额外的快捷方式和视图。<em>Modeling</em>透视图更简单，面向最终用户。
		</p>
		<p>视点在<em>视点规范项目</em>中指定为模型（见下文）。这些<a href="../../Glossary.html#VSP"><em>VSP</em></a>是普通的Eclipse插件项目，它恰好包含一个或多个<code>*.odesign</code>文件（用于<a href="../../Glossary.html#VSM"><em>Viewpoint规范模型</em></a>的扩展）。您可以使用提供的向导创建此类项目： <em>New&gt; Viewpoint Specification Project</em> 。
		</p>
		<p>按照惯例，项目中定义的VSM（或VSM）存储在<code>description</code>文件夹中。如果要将它们放在不同的位置，请确保将此位置添加到插件的<code>build.properties</code>以便它包含在已部署的版本中。
		</p>
		<p>根据使用上一个向导时定义的项目名称给出VSM名称。如果项目名称后缀为“design”，则VSM名称由此后缀之前的最后一个单词提供。否则，VSM名称由项目名称的最后一个单词给出。</p>
		<p>除此之外，该项目是一个普通的Java插件项目。如果您使用的查询语言支持<a href="Writing_Queries.html#service_methods">服务类</a> ，则可以向其中添加<a href="Writing_Queries.html#service_methods">服务类</a> ，以及任何其他Java代码，包括Eclipse视图，操作等。</p>
		<p>请注意，建议将域元模型插件添加为项目的依赖项。Java服务和查询语言的一些功能（如在AQL filter（）操作中使用类型文字）可能需要它们。</p>
		<p>
			<strong>重要提示：</strong>您放置在Eclipse工作区中的任何VSM都将立即可供使用和测试，无需部署。这是为了促进视点的动态和迭代开发。但是，在<strong>部署</strong> VSM时，它们<strong>必须</strong>是<em>VSP的</em>一部分，并且<strong>必须</strong>在插件的激活器类中注册它们。<em>VSP</em>向导生成的激活器已正确配置，但如果重命名<em>VSM</em>或添加新激活器，请务必编辑激活器类，以便在部署时在Sirius平台内正确注册所有<em>VSM</em> 。
		</p>
		<h2 id="vsm">观点规范模型</h2>
		<p><em>VSP</em>的核心部分是它包含的<em>视点规范模型</em> （或多个模型）。它们存储在<code>*.odesign</code>文件中，通常位于项目的<code>description</code>文件夹中。<em>VSM</em>指定一组<em>视点</em>及其表示（图表，树......）。
		</p>
		<p>要编辑<em>VSM</em> ，只需双击它，即可打开树编辑器。编辑器遵循标准EMF编辑器的约定：选择一个元素将在<em>Properties</em>视图中显示其属性，您可以在其中编辑它们。要创建新元素，只需右键单击其父元素，然后从一个<em>新的XXX</em>菜单中选择。要删除元素及其所有子元素，只需选择它并单击<em>Delete</em>键或右键单击并选择“ <em>删除”</em> 。
		</p>
		<h3 id="vsm_organization">组织</h3>
		<p><em>VSM</em>的顶级元素是<em>Group</em>元素。它没有特定的语义，仅作为其他元素的容器。但请注意，一旦定义了<em>Name</em> ，就不应该更改它，因为它成为<em>VSM</em>中所有元素标识的一部分。如果更改它，则使用该<em>VSM</em>创建的任何具体表示都将被破坏。
		</p>
		<p>在<em>组内</em> ，您可以使用共享<a href="Colors.html">颜色定义</a>创建可选的<em>用户颜色调色板</em> ;这对于为所有视点和表示定义统一的调色板很有用。您还可以，更重要的是，定义<em>Viewpoint</em>元素。
		</p>
		<p>除了<em>Id</em>和<em>Label</em> （见下文）之外， <em>Viewpoint</em>还可以与一个或多个<em>Model File Extensions</em>相关联，以空格分隔。这可用于将视点的可用性仅限于包含指定类型的语义模型的建模项目。例如，要使您的视点可用于UML和SysML模型，您可以指定<code>uml sysml</code> （请注意，语法仅指定文件扩展名<code>uml</code> ，而不是像<code>*.uml</code>这样的模式）。您可以使用星号<code>*</code>来使您的视点适用于<strong>所有</strong>型号，但通常优选尽可能具体，以免干扰不相关的模型和项目。
		</p>
		<p>在<em>Viewpoint</em>元素中，您可以创建：</p>
		<ul>
			<li>
				<em>表示描述</em> ，用于<a href="../diagrams/Diagrams.html">图表</a> ， <a href="../sequences/Sequence Diagrams.html">序列图</a> ， <a href="../tables/Tables.html">表和交叉表</a>以及<a href="../trees/Trees.html">树</a> 。
			</li>
			<li>
				<em>表示扩展</em> ，目前仅支持<a href="../diagrams/Diagrams.html#diagram_extension">图表</a> 。
			</li>
			<li>
				<a href="../diagrams/Diagrams.html#validation"><em>验证规则</em></a> ，适用于此观点中定义的所有表示。
			</li>
			<li>最后是<em>Java Extensions</em> 。这些引用（通过其完全限定名称）引用到<em>Viewpoint规范项目</em>中定义的Java类，该Java类定义<a href="Writing_Queries.html#service_methods">服务方法</a>并使这些服务在视点中定义的所有表示中可用。如果<a href="Writing_Queries.html#acceleo">使用Acceleo 3编写表达式</a> ，还可以使用这些元素在项目中声明要定义要在表达式中使用的MTL查询的Acceleo模块。
			</li>
		</ul>
		<p>要发现<em>VSM中的</em>所有元素，可以使用该按钮<img src="images/specifier-guide/expandall.png" style="display:inline;margin:0px;padding:0px"> ，在编辑器的右上角展开<em>VSM</em>树。显然，可以使用按钮折叠此树<img src="images/specifier-guide/collapseall.png" style="display:inline;margin:0px;padding:0px"> ，在编辑器的右上角。
		</p>
		<h3 id="common_attributes">共同属性</h3>
		<p>用于指定视点的许多元素共享一些常见的配置属性。它们在本节中以一般术语描述，并从使用它们的特定元素的部分引用（有时仅具有与该元素相关的其他细节）。</p>
		<p><img src="images/common_attributes.png" style="display:inline;margin:0px;padding:0px"></p>
		<ul>
			<li>
				<em>Id</em> ：元素的强制标识符。该标识符对描述编辑器中的说明符最为可见。它必须在其所属观点的背景下是独一无二的。<em>Id</em>在内部用于标识元素，并且必须在不同版本的VSM中保持稳定（或者它将使用旧<em>Id</em>创建的表示不可用）。
			</li>
			<li>
				<em>标签</em> ：元素的标签。它用于向最终用户显示此元素。默认情况下，如果此标签为空，则<em>Id</em>用于向最终用户显示此元素。它可以在不影响现有表示文件的情况下进行更改。
			</li>
		</ul>
		<p><img src="images/documentation_attributes.png" style="display:inline;margin:0px;padding:0px"></p>
		<ul>
			<li>
				<em>文档</em> ：描述文件中的所有元素都包含“ <strong>文档”</strong>类别中提供的“ <strong>文档”</strong>属性。说明符可以使用此属性向这些元素添加注释和文档。视图的最终用户看不到此属性的内容。
			</li>
			<li>
				<em>最终用户文档</em> ：此属性为最终用户描述此元素。它可以在<strong>文档</strong>类别中找到。说明符可以使用此属性向最终用户的这些元素边界添加注释和文档。
			</li>
		</ul>
		<p><img src="images/tricks.png" style="display:inline;margin:0px;padding:0px"> <em>使用<img src="images/questionMarque.png" style="display:inline;margin:0px;padding:0px">用于访问可用字段工具提示的图标。</em>
		</p>
		<h3 id="type_names">输入名称</h3>
		<p>某些<em>VSM</em>元素需要您指定一个或多个<em>类型名称</em>来配置它们，通常是来自所表示的语义域模型的类型（例如，映射定义的<em>域类</em> ）。您可以在元素的“ <em>属性”</em>表单中按绿色背景轻松识别“ <em>类型名称”</em>字段。
		</p>
		<p>
			<img border="0" src="images/domain_class.png">
			<br>类型名称的语法如下：</p>
		<ul>
			<li>
				<strong>最小语法：</strong>它是基本名称，如<code>Class</code> ，</li>
			<li>
				<strong>AQL / OCL语法：</strong>使用EMF EPackage名称的限定名称，它使用separator <code>::</code> like <code>uml::Class</code>定义类型。它是默认和<strong>推荐的</strong>语法，与在AQL中编写限定类型名称的方式一致</li>
			<li>
				<strong>遗留限定名称，如语法：</strong>它是一个限定名称，使用EMF EPackage的名称来定义类型，如<code>uml.Class</code> 。
			</li>
			<li>
				<strong>完全限定的URI</strong> ：如<code>http://www.eclipse.org/uml2/3.0.0/UML#//Class</code> 。</li>
		</ul>
		<p>使用<em>Ctrl + Space</em>快捷键可在这些字段中自动完成。建议将元模型（或更多）与表示定义明确关联，以实现更智能的完成。否则，默认情况下，它将包括可用的任何EMF元模型中的所有类型。
		</p>
		<h3 id="interpreted_expressions">解释表达式</h3>
		<p>许多<em>VSM</em>元素要求您指定<em>解释表达式</em>来配置它们。这些可以是对选择元素的查询（例如在映射中），或者用于计算值的更通用表达式（如用于元素标签的文本）。
		</p>
		<p>您可以在元素的“ <em>属性”</em>表中通过黄色背景轻松识别“ <em>解释的表达式”</em> 。对于所有此类字段，您可以使用任何支持的语言来编写表达式。有关更多详细信息，请参阅<a href="Writing_Queries.html">查询文档</a> 。
		</p>
		<p>
			<img border="0" src="images/interpreted_expressions.png">
		</p>
		<p>此外，通过单击文本字段旁边的按钮，您可以打开一个带有更大文本区域的对话框（也提供自动完成），以便更舒适地键入表达式。请注意，您可以根据需要添加换行符或表格，因为单击“确定”按钮时会删除它们。</p>
		<p>
			<img border="0" src="images/textAreaDialog.png">
		</p>
		<h3 id="feature_name">功能名称</h3>
		<p>某些<em>VSM</em>元素需要您指定<em>功能名称</em> （或<em>创建实例</em>上的<em>引用名称</em> ）来配置它们（创建实例，设置，取消设置等）。您可以通过元素的“ <em>属性”</em>表单中的浅绿色背景轻松识别“ <em>功能名称”</em>字段。
		</p>
		<p>
			<img border="0" src="images/featureName.png">
		</p>
		<p>使用<em>Ctrl + Space</em>快捷键可在这些字段中自动完成，除非无法推断当前元素类型，通常在通用工具的情况下，目标元素仅在运行时才知道。
			<br>请注意，对于“ <em>创建实例</em> <em>引用名称”</em>字段，完成将仅显示类型与“ <em>类型名称”</em>字段中指定的类型一致的<em>要素</em> 。如果未指定类型，则将显示所有可用功能。同样，如果设置了有效的<em>引用名称</em> ，则“ <em>类型名称”</em>字段的完成将仅显示与要素类型一致的类型。
		</p>
		<h3 id="translatable_messages">可翻译的消息</h3>
		<p>许多<em>VSM</em>元素提供的文本字段将在最终用户在建模项目中引用<em>VSM</em>时显示（视点名称，工具...）。从Sirius 4.0开始，可以根据用户的语言对最终用户显示的值进行本地化。支持此功能的字段称为可<em>翻译</em> <em>消息</em> ，可以通过元素<em>属性</em>表中的蓝色背景轻松识别。
		</p>
		<p>
			<img border="0" src="images/common_attributes.png">
		</p>
		<p>请注意，在上一个屏幕截图中，标签字段中的文本是灰色的，因为没有设置标签，而是使用了ID。</p>
		<p><em>VSM中</em>定义的几乎每个<em>VSM</em>元素都可以使用此功能，这些元素对于建模者的最终用户是可见的，如视点和工具名称，现在可以国际化，但不能解释为表达式。另请注意，此功能仅适用于部署为正确Eclipse插件的建模者;它不适用于直接在运行时工作空间中定义的普通VSM。
		</p>
		<p>要在建模器中使用此功能，只需使用VSM中<code>%myUniqueKey</code>形式的<em>转换键</em>引用替换名称，并在<em>Viewpoint规范项目</em>的<code>plugin.properties</code>定义值（默认值），或者locale <code>XX</code> <code>plugin_XX.properties</code> 。请注意，所选键在整个<em>Viewpoint规范项目</em>的上下文中必须是全局唯一的。
		</p>
		<p>
			<img border="0" src="images/translatable_message1.png">
		</p>
		<p>必须使用已翻译的消息将密钥添加到<code>plugin.properties</code>文件中。默认属性文件名为<code>plugin.properties</code> ，本地化版本使用后缀相应的语言代码进行标识（例如，对于美国英语<code>plugin_en_US.properties</code> ，对于法语<code>plugin_fr.properties</code> ）。底层机制与Eclipse / OSGi插件相同，因此翻译甚至可以通过物理上独立的插件片段来提供。要在运行时找到消息值，请不要忘记：</p>
		<ul>
			<li>包含二进制构建中的所有<code>plugin*.properties</code>文件（即在插件的<code>build.properties</code>文件中检查它们）;</li>
			<li>在项目的<code>MANIFEST.MF</code>设置<code>Bundle-Localization: plugin</code>标头。</li>
		</ul>
		<p>
			<img border="0" src="images/translatable_message2.png">
		</p>
		<p>具有英文本地化的Eclipse将从<code>plugin_en.properties</code>获取本地化消息，而具有法语本地化的Eclipse将从<code>plugin_fr.properties</code>获取本地化消息。
		</p>
		<table class="table table-striped table-condensed">
			<tr>
				<td>
					<img border="0" src="images/translatable_message4.png">
				</td>
				<td>
					<img border="0" src="images/translatable_message3.png">
				</td>
			</tr>
			<tr>
				<th>英语语言环境</th>
				<th>法语区域设置（在<code>plugin_fr.properties</code>有相应的翻译
				</th>
			</tr>
		</table>
		<p>请注意，使用没有专用属性文件的语言进行本地化的Eclipse将从默认的<code>plugin.properties</code>获取本地化消息。
		</p>
		<p>如果在本地化属性文件中找不到ID，或者没有属性文件，则将直接显示该ID。</p>
		<p>
			<img border="0" src="images/translatable_message5.png">
		</p>
		<p>由于国际化是可选的，如果可<em>翻译</em> <em>消息</em>不以<em>％</em>开头，它将直接显示而不考虑本地化。
		</p>
		<p>
			<img border="0" src="images/translatable_message6.png">
		</p>
		<p>仍然可以显示以<em>％</em>开头的非本地化标签，但角色需要加倍。
		</p>
		<p>
			<img border="0" src="images/translatable_message8.png">
			<br>
			<img border="0" src="images/translatable_message9.png">
		</p>
		<p>
			<em>警告</em> ：可<em>翻译</em> <em>消息</em>仅涉及向最终用户显示的<em>VSM</em>中设置的标签。Sirius准备进行国际化，但仅提供英语版本。因此， <em>VSM</em>标签可以使用其他语言，但来自Sirius的标签将保留为英语。此外，一些标签来自其他一些框架（如EMF或GMF），如果未安装本地化功能（如果存在），则标签将保留为英文。
		</p>
		<h3 id="model_operations">模型操作</h3>
		<p>每当<em>VSM</em>要求您指定行为时，例如在任何<em>工具</em>定义中，您都可以使用任何可用的<em>模型操作</em>来执行此<em>操作</em> 。有关更多详细信息，请参阅<a href="Model_Operations.html">Model操作文档</a> 。
		</p>
		<h3 id="quick_outline">快速大纲</h3>
		<p>定义<em>VSM时</em> ，快捷键可以使用快捷键<code>Ctrl</code> + <code>O</code>这允许您快速搜索显示的名称中的文本或<em>VSM</em>元素的包含的String属性。
		</p>
		<p>明星<code>*</code>是一个小丑角色，允许您搜索更复杂的模式。对此，如果在其名称中有一个单词或其中一个属性与过滤器中的文本匹配，则会找到一个元素，因此如果您还要在单词内搜索，请在模式的开头添加<code>*</code> 。此外，您可以使用<code>↑</code>和<code>↓</code>在匹配元素中导航，然后使用<code>Enter</code>转到<em>VSM中</em>的选定元素。
		</p>
		<p>
			<img border="0" src="images/quick_outline.png">
		</p>
		<h3 id="validation">VSM验证</h3>
		<p>可以验证您的<a href="../../Glossary.html#VSM"><em>Viewpoint规范模型</em></a> ，以检查您的表示，映射和工具是否已正确指定。它将帮助您找到缺失的元素或错误的元素（例如缺少必需的表达式）。
		</p>
		<p>要验证您的VSM，请打开您的<code>odesign</code>文件，右键单击顶级<em>Group</em>元素，然后选择<em>Viewpoint specification Editor&gt; Validate</em> 。将出现一个对话框，指示验证是否成功。如果没有，它将为您提供有关检测到的问题的详细信息（单击对话框的“详细信息”按钮）。如果检测到问题，它们也将添加到Eclipse <em>Problems</em>视图中。双击其中一个问题将在<a href="../../Glossary.html#VSM"><em>Viewpoint Specification Model</em></a>编辑器中选择相关元素。
		</p>
		<p>您还可以通过在<a href="../../Glossary.html#VSM"><em>Viewpoint规范模型中</em></a>右键单击一个特定元素并启动验证过程来验证它。所有元素的所有子元素也将被验证。这种细粒度验证对于本地化规范模型中的问题很有用，尤其是当它包含许多元素时。
		</p>
		<p>也可以使用按钮<img src="images/specifier-guide/complete_task.png" style="display:inline;margin:0px;padding:0px"> ，在编辑器的右上角启动验证。此图标发生变化（ <img src="images/specifier-guide/validate_model.png" style="display:inline;margin:0px;padding:0px"> ）当我们更改VSM以鼓励用户在保存之前验证VSM时。</p>
		<h3 id="dynamic">动态发展</h3>
		<p>Sirius支持动态开发<em>VSM</em> ，无需部署项目来测试它。如果在您的开发环境中安装了域模型定义（EMF元模型插件），并且只要您的VSM不使用需要部署的高级功能（例如，新<em>外部Java操作</em>的定义），您可以在开发它们时测试您的表示。这是推荐的工作方式，特别是在初始开发阶段，可以轻松地尝试不同的方法并立即查看结果。
		</p>
		<p>要做到这一点，只需在开发环境中创建一个建模项目，以及Viewpoint规范项目，并为其添加一个示例域模型。在示例项目上打开“ <em>视点选择”</em>对话框时，除了作为插件安装的视图外，您还将看到在同一工作区中开发的所有视点也可用。选择您想要的并创建样本表示。
		</p>
		<p>保持您的表示和定义它们的VSM同时打开。无论何时更改某些定义或将新元素添加到VSM中，只需保存即可。Sirius将自动检测更改，重新加载新定义并将其应用于您现有的表示。通过这种方式，您可以迭代地开发表示，例如从空图开始并添加更多元素，样式和工具，同时立即对其进行测试。</p>
		<p></p><div style="display:none">
			<br>TODO添加一个VSM（左侧）和同时打开的相应图表（右侧）的屏幕截图。确保“模型资源管理器”也可见，以显示它们对应的VSP和建模项目。
			<br></div>
		
		<p>请注意，Sirius尽力考虑VSM中的任何更改，即使对于现有和已打开的表示也是如此。有时，如果更改太复杂或者在某些角落情况下尚未支持，您可能需要关闭并重新打开表示，或者在极端情况下删除它并创建一个新表示，以便正确地考虑VSM更改。</p>
		<h4 id="reloadVSM">重新加载已安装的VSM</h4>
		<p>即使在运行时环境工作区中使用VSP是动态开发VSM的最佳方式，如果VSP位于已安装的运行时插件中（即VSP插件位于开发环境工作区中），能够从运行时重新加载它以将外部更改考虑在内。
			<br>这是通过主Eclipse工具栏中的<em>Reload安装的VSM</em>操作完成的。
			<br>点击<em>重新加载已安装的VSM</em>将在打开的表示中自动<em>生效</em> （取决于刷新选项）。
		</p>
		<p>
			<em>限制</em> ：</p>
		<ul>
			<li>仅当安装了说明符插件时，该操作才可用。</li>
			<li>仅当Eclipse Runtime是从PDE启动时（即，不是独立应用程序），该操作才可用。</li>
			<li>仅重新加载VSM。可能已在VSP中更改的Java类将更新为在调试模式下管理的普通Java类。</li>
			<li>如果在主机Eclipse中删除VSP，则可能会遇到意外的异常。</li>
		</ul>
		<h3 id="migration">从先前版本迁移</h3>
		<p><em>Viewpoint规范模型</em>可以在两个版本的Sirius之间发展。迁移过程自动完成。这意味着所有VSM都在加载时迁移，而无需用户执行任何操作。虽然未保存VSM，但下次打开时将重播自动迁移。
		</p>
	</body>
</html><html id="0525.Git-For-Eclipse-Users.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>适用于Eclipse用户的Git</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">适用于Eclipse用户的Git</th>
			</tr>
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table><hr class="navigation-separator">
		<p>这篇文章针对那些已经使用Eclipse一段时间的人，并且可能已经使用烘焙的CVS或外部SVN提供程序来存储他们的源代码。这篇文章的内容是关于Git的：作为一个Eclipse用户，它对你意味着什么，具体来说，它如何影响你从Eclipse.org获取或使用项目的方式。</p>
		<p>这篇文章不是关于Git相对于CVS / SVN，或Git与其他分布式版本控制系统（DVCS）如Mercurial（Hg）的相对优点。如果需要，其他网站可以提供这些口味。</p>
		<p>一旦你理解了CVS / SVN和Git之间的概念差异，然后开始使用Git，你可能会发现很难回头。你应该真的开始尝试，只要你认为你将在不久的将来迁移，因为使用Git就像看电视一样：一旦你发现它，很难回到黑白。</p>
		<dl>
			<dd>☞ <b>一旦开始使用DVCS，你就不太可能想要回去</b>
			</dd>
		</dl>
		<h2 id="Centralised_version_control_systems">集中版本控制系统</h2>
		<p>那么，你需要了解Git的哪些方面？嗯，CVS和SVN都称为<i>集中式</i>版本控制系统（CVCS）。也就是说，有一个主存储库，人们共享代码;每个人都从该存储库中检出他们的代码（或分支），然后检查更改。对于需要逐个发送的代码（例如，用于审阅或作为贡献修复的方式），可以创建<i>补丁</i> ，这是针对给定主存储库版本的代码差异（经常HEAD，但有时像Eclipse_35这样的分支。
		</p>
		<p>集中式版本控制系统存在两个问题，尽管它们不是很明显：</p>
		<ul>
			<li>您需要“在线”执行操作，例如diff或patch <a href="#reference-1">[1</a> ]。
			</li>
			<li>随着时间快照分支的开发继续进行（例如，当应用补丁时，HEAD与生成补丁时不同），针对特定分支生成的补丁可能相当快地过时。</li>
		</ul>
		<p>
			<a href="#ref-1">[1</a> ] <i>（关于SVN的说明：由于SVN保留了最后已知的结账，因此可以在与SVN断开连接时执行一组有限的操作，例如来自最后已知结账的差异。但是，通常情况下，您无法执行连接时可能执行的许多操作。）</i>
		</p>
		<p>对于在存储库本身（或附近）的位置使用Eclipse的人来说，第一个问题很少出现。由于全球网络的变化，同一大洲的人很少会遇到延误;此外，他们倾向于在一个组织中工作，并且在一天中的大部分时间都坐在连接到有线网络的桌面上。公路战士（那些有笔记本电脑和来自当地咖啡店的代码）往往以更频繁的断开模式运行，这将存储库功能限制在连接时。</p>
		<p>第二个问题只是补丁工作方式的工件。这些通常针对HEAD（及时快照）执行，然后稍后应用（有时几个月甚至<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=4922" target="egit_external">八年后</a> ）。虽然它们记录了它们被修补的文件版本，但是补丁本身对文件中的大变化很敏感，有时会导致补丁不适用。即使是相对简单的操作（如文件重命名）也可以将窗口格式良好的CVCS补丁抛出。
		</p>
		<h2 id="Distributed_Version_Control_Systems">分布式版本控制系统</h2>
		<p>分布式版本控制系统（DVCS）是一系列版本控制系统，不像许多人熟悉的那样。最受欢迎的两个是<a href="http://www.git-scm.org" target="egit_external">Git</a>和<a href="http://mercurial.selenic.com" target="egit_external">Hg</a> ，尽管其他（ <a href="http://darcs.net/" target="egit_external">Darcs</a> ， <a href="http://bazaar.canonical.com/en/" target="egit_external">Bazaar</a> ， <a href="http://www.bitkeeper.com/" target="egit_external">Bitkeeper</a>等）存在。在DVCS中，每个用户都拥有存储库的完整副本，包括其整个历史记录。用户可能会将更改推送到任何其他存储库或从中提取更改。虽然策略可以赋予一个或多个存储库特殊的状态，但原则上每个存储库都是DVCS模型中的一等公民。这与集中式版本控制系统形成对比，在集中式版本控制系统中，每个人都将文件检入和检出权威存储库。
		</p>
		<dl>
			<dd>☞ <b>每个用户都有一个存储库的完整副本</b>
			</dd>
		</dl>
		<p>这最初听起来不可能，尤其是如果您习惯于集中式版本控制系统，如果它们涉及基于文件的悲观锁定，则更是如此。（如果您确实想要悲观锁定，请在这里停止阅读。谢谢。）问题出现了，例如：</p>
		<ol>
			<li>如果每个人都有一个存储库的副本，那么所有的分支是否都不同？</li>
			<li>主存储库保存在哪里？</li>
			<li>存储库不是很大吗？</li>
			<li>不，我喜欢悲观的锁定。</li>
		</ol>
		<p>让我们依次回答这些问题中的每一个。（如果我错过了您最喜欢的问题，请随时在评论中添加一个。）</p>
		<ol>
			<li>是的，叉子<i>可以</i>分叉。但毕竟，无论如何，开源都可能出现分歧。没有什么能阻止我分配<code>dev.eclipse.org</code>代码库，并发布我自己的版本<a href="http://sourceforge.net/projects/rcpapps/files/maclipse/" target="egit_external">Maclipse</a> 。这里的关键是尽管叉子是可能的，但叉子<i>本身并不是坏事</i> 。毕竟，看看Linux和Android;最初，他们分享了历史，但现在却不同了。XFree86和X.Org <a href="http://www.x.org/wiki/XorgFoundation" target="egit_external">分离</a>了许可问题。MySQL分叉创建<a href="http://askmonty.org/wiki/index.php/MariaDB" target="egit_external">MariaDB</a> ，依此类推。关于福克斯的关键是最好的生存。X.Org现在是默认的X客户端，而XFree86是默认的默认值。陪审团仍然在MySQL和MariaDB之间。尽管Maclipse已被下载了<span title="实际上，大约一千五百。这比我预期的要多。">数十次</span> ，但它并未对Eclipse的增长造成影响。
				<dl>
					<dd>☞ <b>福克斯发生了</b>
					</dd>
				</dl>
			</li>
			<li>不要试图弯曲<span title="勺">主存储库</span> - 这是不可能的。相反，只想实现真相;没有<span title="勺">主存储库</span> 。事实上，有一个真实的主存储库矩阵可能。每个存储库都可以被视为图中的节点;图中的节点可以以任何方式相互连接。然而，图形通常不是一组链接，而是自组织成一个树状结构，逻辑上与一个点相关联，作为其他一切的漏斗。从某种意义上说，这是一个主存储库 - 每个人都已经做出了选择;现在你必须了解它。如果oracle干预，可以选择新主人。
				<dl>
					<dd>☞ <b>没有主存储库</b>
					</dd>
				</dl>
			</li>
			<li>鉴于没有主存储库，很明显存储库必须完全存在于DVCS中的每个节点上。这通常会导致对存储库大小的担忧，甚至考虑到存储空间很便宜。这里的一个关键点是DVCS存储库通常远<i>小于</i>其对应的CVCS存储库，这不仅仅是因为每个人都必须拥有完整的存储库才能完成任何工作。这是一个自然的结果，它们更小。但是，它们也较小，因为每个存储库包含的范围远远小于CVCS存储库。例如，大多数组织将拥有一个庞大的CVCS存储库，下面有数千个顶级“模块”（或“项目”）。由于“创建新存储库”的管理开销，通常更容易为所有内容重用相同的存储库。（SVN对它可以增长的范围进行了一些限制，CVS倾向于没有;但即便如此，主要的<a href="http://svn.apache.org/viewvc?view=revision&amp;revision=908283" target="egit_external">Apache SVN</a>也有超过900k的版本。）相比之下，DVCS通常只是一个内部有一些管理文件的目录。它不需要管理员权限或特定端口;事实上，由于没有中央服务器可言，它甚至不需要由网络协议共享。因此，与传统的CVCS存储库相比，DVCS存储库更加精细 - 并且易于创建。首先，它始终在您的机器上（没有可配置的集中式服务器），其次，您需要访问的是文件系统。通常，DVCS“存储库”通常位于Eclipse项目或项目工作集的级别。例如，虽然[ <a href="http://dev.eclipse.org/viewcvs/index.cgi/?root=RT_Project" target="egit_external">http://dev.eclipse.org/viewcvs/index.cgi/?root=RT_Project</a> CVS <span title="运行">RT</span>存储库]由<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.equinox/?root=RT_Project" target="egit_external">Equinox</a>和<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.ecf/?root=RT_Project&amp;view=log" target="egit_external">ECF</a>共享，但基于DVCS的解决方案几乎肯定会看到Equinox和ECF项目在他们自己的存储库中;也许，甚至进一步分解为（例如）ECF-Doc和ECF-Bundles。将DVCS存储库视为一个或几个Eclipse项目，而不是数百个项目。
				<dl>
					<dd><b>☞DVCS存储库要小得多，通常是因为它们只包含少量高度相关的项目</b>
					</dd>
				</dl>
			</li>
			<li>那不是问题。看，如果您想要具有悲观锁定和悲观用户的集中式DVCS的好处，那么请查看<a href="http://www-01.ibm.com/software/awdtools/clearcase/" target="egit_external">ClearCase</a> 。
				<dl>
					<dd>☞ <b>朋友们不要让朋友使用ClearCase</b>
					</dd>
				</dl>
			</li>
		</ol>
		<h2 id="How_does_it_work.3F">它是如何工作的？</h2>
		<p>有两条信息可识别CVCS中的元素;文件的<i>名称</i>及其<i>版本</i> （有时称为<i>修订版</i> ）。在CVS的情况下，每个文件都有自己的版本流（1.1,1.2,1.3），而在SVN中，每个变更集都有一个“存储库修订版”编号。标签（或分支）是符号标识符，可以附加到任何特定的文件集或存储库修订版，并且主要供人消费（例如HEAD，trunk，ECLIPSE_35）。
		</p>
		<p>这在DVCS中不起作用。由于没有中央存储库，因此没有中央存储库版本号（作为整体存储库或单个文件）。</p>
		<p>相反，DVCS在<i>变更集</i>的级别上运行。逻辑上，存储库由初始（空）状态组成，后跟许多变更集。（变更集只是对一组文件的更改;如果您认为来自CVS或SVN的“补丁”，那么您就不远了。）
		</p>
		<p>识别变更集要困难得多。我们不能使用（全局）修订号，因为不使用该概念。相反，变更集表示为其内容的散列。例如，给定变更集：</p>
		<pre>--- a / README.txt +++ b / README.txt @@ -1 +1 @@ -SVN很棒+ Git很棒</pre>
		<p>我们可以使用（例如） <code>md5</code>创建一个'hash'来生成字符串<code>0878a8189e6a3ae1ded86d9e9c7cbe3f</code> 。在提及我们与他人的变更时，我们可以使用此哈希来识别有问题的变更。</p>
		<dl>
			<dd>☞ <b>更改集由其内容的哈希标识</b>
			</dd>
		</dl>
		<p>但显然，这不能单独发挥作用。如果我们稍后进行相同的更改，会发生什么？它会有相同的更改，我们不希望相同的哈希值。</p>
		<p>会发生什么变化集包含两件事;变化本身，以及前一个变更集的后向指针。换句话说，我们最终得到的结果如下：</p>
		<pre>上一篇：48b2179994d494485b79504e8b5a6b23ce24a026 --- a / README.txt +++ b / README.txt @@ -1 +1 @@ -SVN很棒+ Git很棒</pre>
		<dl>
			<dd>☞ <b>更改集（递归）包含指向上一个变更集的指针</b>
			</dd>
		</dl>
		<p>现在，如果我们再次进行相同的更改， <i>之前的</i>值会有所不同，所以我们会得到一个不同的哈希值。我们可以建立一个论点：</p>
		<pre>上一篇：48b2179994d494485b79504e8b5a6b23ce24a026 --- a / README.txt +++ b / README.txt @@ -1 +1 @@ -SVN很棒+ Git很棒</pre>
		<pre>上一篇：8cafc7ecd01d86977d2af254fc400cee --- a / README.txt +++ b / README.txt @@ -1 +1 @@ -Git很棒+ SVN很棒</pre>
		<pre>上一篇：cba3ef5b2d1101c2ac44846dc4cdc6f4 --- a / README.txt +++ b / README.txt @@ -1 +1 @@ -Git很棒+ SVN很棒</pre>
		<p>每次，变更集的值都包含指向之前的指针，因此散列不断变化。</p>
		<p>
			<b>注意</b> ：不是使用<code>md5</code> ，如此处所示，大多数DVCS（包括Git）使用<code>sha1</code>哈希代替。此外，存储树中先前元素的确切方式及其关系并未在上面准确描述;但是，它足够好地说明了它们的组织方式。
		</p>
		<dl>
			<dd><b>☞Git变更集由SHA-1哈希标识</b>
			</dd>
		</dl>
		<h2 id="Changesets_and_branches">变更集和分支机构</h2>
		<p>鉴于变更集是一个长值，如<code>48b2179994d494485b79504e8b5a6b23ce24a026</code> ，使用它可能不友好。幸运的是，有几种方法可以解决这个问题。与其他DVCS一样，Git允许您使用变更集的缩写形式，前提是它在存储库中是唯一的。对于小型存储库，这意味着您可以通过非常短的值来引用变更集，例如<code>48b21</code>甚至<code>48</code> 。传统上，开发人员经常使用6位哈希值 - 但是大型项目（如Linux内核）往往必须使用稍大的引用才能具有唯一性。</p>
		<dl>
			<dd><b>☞Git哈希可以缩短为任何唯一的前缀</b>
			</dd>
		</dl>
		<p>存储库的当前版本只是指向树末端的指针。出于这个原因，它通常被称为<i>提示</i> ，但<code>HEAD</code>是当前存储库指向的符号标识符。类似地，任何分支都可以通过其变更集ID来引用，其中包括该变量集和所有先前的变更。默认分支通常称为<i>master</i> 。
		</p>
		<dl>
			<dd>☞ <b>默认的“trunk”在Git中称为“master”</b>
			</dd>
			<dd>☞ <b>当前分支的尖端称为“HEAD</b> ”</dd>
		</dl>
		<p>作为直接推论，在DVCS中创建分支很快。所有发生的事情是磁盘上的存储库更新为指向（已经存在的）树中的不同元素，并且您已完成。此外，在同一个存储库上的不同分支之间进行乒乓操作是微不足道的，这些分支可能包含不同的状态并且可以独立进化。</p>
		<dl>
			<dd>☞ <b>在分支之间创建和切换很快</b>
			</dd>
		</dl>
		<p>因为分支是如此之快，分支被用于CVCS的用户通常不会使用分支的东西。例如，Bugzilla中的每个错误都可能有一个与之关联的新分支;如果同时处理几个独立的功能，他们会得到自己的分支;如果您需要退回以在ECLIPSE_35分支上执行维护工作，那么您也将切换到该分支。分支的创建频率至少与CVS中的<a href="http://www.peterfriese.de/using-cvs-change-sets/" target="egit_external">变更集</a>一样频繁，如果不是这样的话。
		</p>
		<dl>
			<dd>☞ <b>为您使用的每个Bugzilla或功能项创建一个新分支</b>
			</dd>
			<dd>☞ <b>将分支视为一次性变更集</b>
			</dd>
		</dl>
		<h2 id="Merging">合并</h2>
		<p>强大的功能带来了极大的灵活性，但最终，您希望将更改转换为某种合并流（如HEAD）。无约束分支的担忧之一是后来不受约束的合并痛苦。SVN使其比CVS稍微困难一点，但除非你经常合并到HEAD，否则你很容易迷失 - 特别是当重构开始发生时。</p>
		<dl>
			<dd>☞ <b>合并CVCS很痛苦;因此分支往往不会发生</b>
			</dd>
		</dl>
		<p>幸运的是，DVCS都是关于合并的。假设变更集树中的每个节点都包含指向其前一个节点的指针（并且传递到时间的开头），它比标准的平坦CVCS差异更强大。换句话说，您不仅知道需要做出哪些改变，而且还<i>知道它们需要在历史的哪个阶段进行</i> 。因此，如果您有一个重命名文件的变更集，然后在变更集中合并，该变更集指向重命名之前的文件，则CVCS将会崩溃;但是DVCS将能够在重命名发生<i>之前</i>应用更改，然后播放更改。
		</p>
		<p>合并只是将两个（或更多）本地分支编织成一个。<a href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html" target="egit_external">git merge</a>文档中有一些图形示例;但基本上，它就像你见过的任何其他合并一样。但是，与CVCS不同，您不必指定任何有关合并的位置;树木会自动知道他们过去的分裂点，并可以从那里开始。
		</p>
		<dl>
			<dd>☞ <b>像Git这样的DVCS合并是微不足道的</b>
			</dd>
		</dl>
		<h2 id="Pulling_and_pushing">拉动和推动</h2>
		<p>到目前为止，我们还没有谈到DVCS的分布式特性。然而，隐含地，上述变化和想法都是为了支持分配。</p>
		<p>鉴于DVCS树仅仅是指向分支的指针（传递上包含一长串先前的分支），并且这些节点中的每一个都由其散列标识，那么您和我可以共享相同的修订标识符以用于公共部分我们的树。比较我们的两棵树有三种情况需要考虑：</p>
		<ul>
			<li>你的小费是我的小费的祖先</li>
			<li>我的小费是你小费的祖先</li>
			<li>我们的提示都不是直接的祖先;但是，我们都有一个共同的祖先</li>
		</ul>
		<p>前两个案件是微不足道的;如果我们同步树，它们就会变成快进合并。事实上，如果发生这种情况，你很可能不知道谁先于另一个;它会发生。</p>
		<p>最后一种情况只是稍微棘手一些;必须找到一个共同的祖先;比方说， <code>746d6c</code> 。然后我在我的提示和<code>746d6c</code>之间发送更改，并在您的提示和<code>746d6c</code>之间发送更改。这样，我们最终都会在我们的存储库中获得相同的内容。</p>
		<p>通过<i><i>推拉</i></i>操作库之间流动的变化。从本质上讲，无论是将我的修改推送给你，还是将我的修改从我身上拉下来都无关紧要;最终结果是一样的。但是，对于Eclipse.org基础结构，中央Git存储库可能只能由Eclipse提交者写入。因此，如果我提供修复，我可以要求提交者从我的存储库中提取修复程序，然后他们（在审阅之后，并且可选地重新定位）可以将修复程序推送到Eclipse.org存储库。
		</p>
		<p>DVCS的最佳部分是它为您处理所有文书工作。您不需要使用类似SVN的<code>314:321</code>标签来提醒您从何处分支;如果你最近没有更新，你甚至不必担心。一切正常。</p>
		<dl>
			<dd>☞ <b>拉动和推入像Git这样的DVCS是微不足道的</b>
			</dd>
		</dl>
		<h2 id="Cloning_and_remotes">克隆和遥控器</h2>
		<p>您可以推送（或拉取）的位置是基于每个（本地）存储库配置的。通常，如果克隆现有项目，则会自动为您设置名为<i>origin</i>的<i>远程名称</i> 。例如，如果你想获得<a href="http://git.eclipse.org/cgit.cgi/babel/org.eclipse.babel.server.git/" target="egit_external">org.eclipse.babel.server.git</a> ，那么你可以这样做：</p>
		<pre>git clone git：//git.eclipse.org/gitroot/babel/org.eclipse.babel.server.git</pre>
		<p>然后，我们可以通过从远程执行拉取来了解远程服务器上发生的最新情况：</p>
		<pre>git pull origin</pre>
		<p>......但我们不仅限于一个存储库。假设我们想在<a href="http://www.github.com" target="egit_external">GitHub上</a>创建一个单独的副本以便于分叉;我们可以通过添加另一个远程Git URL然后推送到那个来做到这一点：</p>
		<pre>git remote add github <a href="http://github.com/alblue/babel.git" target="egit_external">http://github.com/alblue/babel.git</a> git push github</pre>
		<p>我们现在可以使用<code>git push</code>和<code>git pull</code>在两个git存储库之间移动项目。默认情况下，它们都引用特殊命名的<i>origin</i> ，但您可以在命令行中指定要与之通信的任何远程。
		</p>
		<dl>
			<dd>☞Origin <b>是默认远程</b>控制器<b>的名称，但每个存储库可以有许多远程控制器。</b>
			</dd>
		</dl>
		<h2 id="Initialising.2C_committing_and_branching">初始化，提交和分支</h2>
		<p>要创建新的Git存储库，请使用<code>git init</code>命令。这将在当前目录中创建一个空存储库。它们可以但通常不会以<code>.git</code>结尾 - 通常只有存储库被推送到使用<code>.git</code>扩展名的远程服务器。如上所述，Git存储库理想情况下应仅包含一个或几个高度相关/耦合的项目。</p>
		<dl>
			<dd><b>☞'git init'在当前目录中创建一个新的存储库</b>
			</dd>
		</dl>
		<p>Git允许您提交文件，就像任何其他VCS一样。每个提交可以是单个文件，也可以是许多文件;并传递一条信息。与其他VCS不同，Git有一个单独的<i>索引</i>概念，它是一组将要提交的文件。您可以将其视为一个积极的变革集;当您处理多个文件时，您只希望将一些更改作为一个单元提交。这些文件首先将<code>git add</code>到索引，然后<code>git commit</code> ted。（如果你不喜欢这种行为，那就有一个<code>git commit -a</code>选项，它可以像CVS或SVN那样执行。）
		</p>
		<dl>
			<dd><b>☞'git add'用于添加文件和跟踪文件的更改</b>
			</dd>
			<dd><b>☞'git commit'用于提交跟踪文件</b>
			</dd>
		</dl>
		<p>要创建分支，可以使用<code>git branch</code> （创建但不切换到新分支）和<code>git checkout</code> （切换到新分支）。新分支的简写是<code>git checkout -b</code> ，它创建并切换到分支。在任何时候， <code>git branch</code>显示一个分支列表，并在当前名称旁边标记*。</p>
		<dl>
			<dd><b>☞'git branch'用于创建和列出分支</b>
			</dd>
			<dd><b>☞'git checkout'用于切换分支</b>
			</dd>
			<dd><b>☞'git checkout -b'用于创建然后切换分支</b>
			</dd>
		</dl>
		<h2 id="Worked_example">工作的例子</h2>
		<p>下面是设置初始存储库，然后将数据复制到“远程”存储库和从“远程”存储库复制数据的脚本，尽管在同一系统上的不同目录中。这些说明适用于类Unix环境（例如Windows上的Cygwin）。</p>
		<pre>$ mkdir / tmp / example $ cd / tmp / example $ git init /tmp/example/.git/中初始化的空Git存储库$ echo“Hello，world”&gt; README.txt $ git commit＃默认情况下不提交文件#On branch master ##初始提交##未跟踪文件：＃（使用“git add &lt;file&gt; ...”包括将要提交的内容）## README.txt没有添加到提交但未跟踪的文件存在（使用“ git add“to track”$ git add README.txt＃类似于团队 - &gt;添加到版本控制$＃git commit＃将提示消息$ git commit -m“添加README.txt”[master（root-commit）0dd1f35 ]添加了README.txt 1个文件已更改，1个插入（+），0个删除（ - ）创建模式100644 README.txt $ echo“Hello，solar system”&gt; README.txt $ git commit #On branch master＃已更改但未更新：＃（使用“git add &lt;file&gt; ...”来更新将要提交的内容）＃（使用“git checkout  -  &lt;file&gt; ...”来丢弃工作目录中的更改）## modified：README.txt ＃没有更改添加到提交（使用“git add”和/或“git commit -a”） $ git commit -a -m“更新了README.txt”[master 9b1939a]更新了README.txt 1个文件已更改，1个插入（+），1个删除（ - ）$ git log --graph --onon＃显示图形节点（这里没有多少）和更改信息* 9b1939a更新了README.txt * 0dd1f35添加了README.txt $ git checkout -b french 0dd1f35 #create并切换到新分支'french'切换到新分支'french'$ cat README.txt Hello，world $ echo“Bonjour，tout le monde”&gt; README.txt $ git add README.txt＃或commit -a $ git commit -m“AjoutéREADME.txt”[french 66a644c]AjoutéREADME.txt1个文件已更改， 1个插入（+），1个删除（ - ）$ git log --graph --oneline *66a644cAjoutéREADME.txt* 0dd1f35添加README.txt $ git checkout -b web 0dd1f35＃从最初创建并签出分支'web' commit $ echo' &lt;a href=" <a href="http://git.eclipse.org" target="egit_external">http://git.eclipse.org</a> "&gt; git.eclipse.org &lt;/a&gt;'&gt; index.html $ git add index.html $ git commit -m“添加了主页”[ web d47e30c]已添加主页1文件已更改，1个插入（+），0个删除（ - ）创建模式1 00644 index.html $ git checkout master $ git branch＃查看我们有哪些分支法语* master web $ git merge web #draw'web'到当前分支'master'通过递归合并。index.html | 1 + 1个文件已更改，1个插入（+），0个删除（ - ）创建模式100644 index.html $ git checkout french＃切换到'french'分支切换到分支'french'$ git merge web＃并合并到同一个通过递归合并。index.html | 1 + 1个文件已更改，1个插入（+），0个删除（ - ）创建模式100644 index.html $ git log --graph --oneline * e974231将分支'web'合并为法语| \ | * d47e30c已添加主页* | 66a644cAjoutéREADME.txt| / * 0dd1f35添加了README.txt $ git checkout master $ git log --graph --oneline * e3de4de合并分支'web'| \ | * d47e30c已添加主页* | 9b1939a更新了README.txt | / * 0dd1f35添加了README.txt $（mkdir / tmp / other; cd / tmp / other; git init）＃可以在其他进程中执行此操作$（cd / tmp / other; git config --bool core.bare true）＃需要告诉git / tmp / other是一个裸存储库，所以我们可以“推”到它初始化空的Git存储库在/tmp/other/.git/ $ git remote add other / tmp / other＃可以是一个URL over http / git $ git push other master＃push branch'master'到远程存储库'other'计数对象：11，完成。Delta压缩最多使用2个线程。压缩对象：100％（7/7），完成。写入对象：100％（11/11），981字节，完成。总计11（delta 1），重用0（delta 0）解包对象：100％（11/11），完成。to / tmp / other * [new branch] master  - &gt; master $ git push --all other＃将所有分支推送到'other'计数对象：8，完成。Delta压缩最多使用2个线程。压缩对象：100％（3/3），完成。写入对象：完成100％（5/5），567个字节。总计5（delta 0），重用0（delta 0）解包对象：100％（5/5），完成。to / tmp / other * [new branch] french  - &gt; french * [new branch] web  - &gt; web $ cd / tmp / other＃切换到'其他'存储库。 git命令现在适用于此存储库$ git config --bool core.bare false＃需要允许此存储库检出文件$ ls＃没什么可看的，但它有$ git branch french * master web $ git checkout web ＃在其他$ ls README.txt中获取'web'分支的内容index.html $ echo'&lt;h1&gt; Git rocks！&lt;/ h1&gt;'&gt;&gt; index.html $ git commit -a -m“添加了Git Rocks！“[web 510621a]添加了Git Rocks 1个文件已更改，1个插入（+），0个删除（ - ）$ cd / tmp / example＃返回第一个repo.git命令现在适用于'example'存储库$ git pull other web＃从'其他'repo'web'分支远程拉出更改：计数对象：5，完成。remote：压缩对象：100％（3/3），完成。remote：总计3（delta 0），重用0（delta 0）解包对象：100％（3/3），完成。来自/ tmp / other * branch web  - &gt; FETCH_HEAD由递归合并而成。index.html | 1 + 1个文件已更改，1个插入（+），0个删除（ - ）$ git log --graph --oneline * 146932f合并分支'web'/ tmp / other | \ | * 510621a添加了Git Rocks * | e3de4de合并分支'web'| \ \ | | / | * d47e30c已添加主页* | 9b1939a更新了README.txt | / * 0dd1f35添加了README.txt</pre>
		<h2 id="Rebasing_and_fast-forwarding">重新定位和快进</h2>
		<p>通常，您将在分支上工作一段时间，然后将其提交到存储库。您可以在任何时候做到这一点，但它被认为是很好的做法在这样做之前<i>衍合</i>当地分行。例如，您最终可以在日志中使用多个分支（使用<code>git log --graph --oneline</code> ）：</p>
		<pre>* f0fde4e合并更改I11dc6200 | \ | * 86dfb92将下一个版本标记为0.6 * | 0c8c04d合并更改I908e4c77 | \ \ | | / | / | | * 843dc8f添加对logAllRefUpdates配置参数* |的支持74ba6fc删除TODO文件并移至bugzilla * | ba7c6e8修复SUBMITTING_PATCHES以遵循Eclipse IP进程* | c5e8589修复SUBMITTING_PATCHES * |中的制表符到空格677ca7b更新SUBMITTING_PATCHES以指向贡献者指南* | 8847865文档受保护的RevObjectList *成员a0a0ce8可以清除PlotCommitList * | 4a3870f包含缺少捆绑先决条件的描述| / * 144b16d在JGit中清理MANIFEST.MF</pre>
		<p>这里发生的事情是，两个分支从变更<code>144b16d</code>分离出来，最终在<code>74ba6fc</code>和一些合并（在<code>0c8c04d</code>和<code>f0fde4e</code> ）驱动另一个分支。（您可以在<a href="http://code.google.com/p/wave-protocol/source/list" target="egit_external">Google Code的Wave协议的Hg视图中</a>看到类似的效果。）最终，虽然DVCS可以处理这些长期运行的分支和随后的合并，但人们倾向于在最终的存储库中看到更少的分支。
		</p>
		<p><i>快速</i>合并（在Git术语中）是不需要任何类型的合并操作的合并。当您从同一时间线上的较旧分支移动到较新分支时，通常会发生这种情况;例如从远程存储库更新到较新版本时。这些基本上只是将HEAD指针向下移动到分支。
		</p>
		<p>一个<i>rebase</i>将原始提交中的分支连根拔起，并重写历史记录，就像从当前时间点完成一样。例如，在上面的Git跟踪中， <code>1441b16d</code>到<code>843dc8f</code>到<code>0c8c04d</code>只是主树的一次提交。发生了变化被重订上<code>74ba6fc</code> ，那么我们就只看到那些跨越提交一个时间表。通常认为在推送到远程树之前重新定义更改以避免这种扇出是一种好习惯，但没有必要这样做。此外，rebase操作会更改树的<code>sha1</code>哈希值，这会影响已分叉存储库的人。最佳做法是频繁地在您自己的本地存储库中更改您的更改，但是一旦它们被公开（通过推送到共享存储库）以避免进一步变基。
		</p>
		<dl>
			<dd>☞ <b>重新重新种植树木;但只能在当地的分支机构上进行</b>
			</dd>
		</dl><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table>
	</body>
</html><html id="2781.org_eclipse_debug_ui_launchShortcuts.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>启动快捷方式</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">启动快捷方式</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.debug.ui.launchShortcuts<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点为选择敏感启动提供支持。扩展注册了一个快捷方式，该快捷方式出现在运行和/或调试级联菜单中，以启动工作台选择或活动编辑器。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.shortcut">快捷方式</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.shortcut">快捷方式</a> （ <a href="#e.perspective">perspective</a> *， <a href="#e.contextualLaunch">contextualLaunch</a> ？， <a href="#e.enablement">enablement</a> ？， <a href="#e.configurationType">configurationType</a> *， <a href="#e.description">description</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST快捷方式</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">模式CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">类别IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">helpContextId CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">路径CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">说明CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 指定此启动快捷方式的唯一标识符。</li>
<li><b>modes</b> - 指定此快捷方式支持的以逗号分隔的模式列表。</li>
<li><b>class</b> - 指定实现<code>org.eclipse.debug.ui.的类的完全限定名称<code>org.eclipse.debug.ui.ILaunchShortcut</code> 。3.4中的新增功能，客户端可以实现<code>org.eclipse.debug.ui.ILaunchShortcut2</code>参与上下文敏感启动资源和非资源的工件。</li>
<li><b>label</b> - 指定用于呈现此快捷方式的标签。</li>
<li><b>icon</b> - 指定用于呈现此快捷方式的图像的插件相对路径。图标是可选的，因为它取决于其他插件（即视图）来呈现它。</li>
<li><b>category</b> - 指定此快捷方式适用的启动配置类型类别。未指定时，类别为<code>null</code> （默认值）。</li>
<li><b>helpContextId</b> - 一个可选标识符，指定与此启动快捷方式关联的帮助上下文</li>
<li><b>path</b> - 用于对菜单中的启动快捷方式进行分组的可选菜单路径。启动快捷方式根据<code>path</code>属性按字母顺序分组，然后根据<code>label</code>属性在组内按字母顺序排序。未指定时，最后一个组中会出现一个快捷方式。此属性已添加到3.0.1版本中。</li>
<li><b>description</b> - 提供用户可选择的快捷方式（或将要执行的操作）的可读描述。此字段中提供的说明将作为modes属性中列出的所有模式的默认说明。此属性已在3.3版本中添加。</li>
</ul>
<br><div style="color:red;font-style:italic">不推荐使用<b>perspective</b>元素</div> <p class="code SchemaDtd">&lt;！ELEMENT <a name="e.perspective">perspective</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的观点</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc"><code>perspective</code>元素已在3.1版本中<b>弃用</b> 。顶级的Run / Debug / Profile级联菜单现在支持上下文（选择敏感）启动，客户端应该提供<code>contextualLaunch</code>元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 透视图的唯一标识符，其中将显示此启动快捷方式的菜单快捷方式。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.contextualLaunch">contextualLaunch</a> （ <a href="#e.contextLabel">contextLabel</a> *， <a href="#e.enablement">enablement</a> ？）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">包含有关向选择敏感的运行/调试/配置文件级联菜单添加快捷方式的所有说明。只有提供<code>org.eclipse.debug.ui.actions.对象<code>org.eclipse.debug.ui.actions.ILaunchable</code>适配器被认为是级联菜单。<code>org.eclipse.debug.ui.actions.ILaunchable</code>接口仅用于标记支持上下文启动的对象。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.contextLabel">contextLabel</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST contextLabel</p>
<p class="code SchemaDtdAttlist">模式IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">指定上下文启动模式的标签。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>mode</b> - 指定集合{“run”，“debug”，“profile”}中的模式</li>
<li><b>label</b> - 指定要在上下文启动菜单中显示的标签。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.configurationType">configurationType</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST配置类型</p>
<p class="code SchemaDtdAttlist">id IDREF #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素允许为此启动快捷方式指定更多关联的启动配置类型。这个元素在3.3版本中添加了。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此属性是与此启动快捷方式关联的现有启动配置类型的标识符。然后，此关联用于确定哪些启动快捷方式适用于上下文敏感启动的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.description">description</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST描述</p>
<p class="code SchemaDtdAttlist">模式CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">说明CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">为此启动快捷方式提供特定于模式的说明。这个元素在3.3中添加了。发布。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>mode</b> - 此描述适用的启动模式标识符。例如，“运行”。</li>
<li><b>description</b> - 在关联模式下调用此启动快捷方式的<b>描述</b> 。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是Java Application启动快捷方式贡献的示例，其中包含启用表达式，关联的启动配置类型ID以及运行和调试模式的描述：<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.debug.ui.launchShortcuts”</span> <span class="code SchemaTag">&gt; &lt;shortcut label =</span> <span class="code SchemaCstring">“Java Application”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“$ nl $ / icons / full / etool16 / java_app.png”</span> <span class="code SchemaTag">helpContextId =</span> <span class="code SchemaCstring">“org.eclipse.jdt。 debug.ui.shortcut_local_java_application“</span> <span class="code SchemaTag">modes =</span> <span class="code SchemaCstring">”run，debug“</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">”org.eclipse.jdt.internal.debug.ui.launcher。JavaApplicationLaunchShortcut“</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">”启动本地Java应用程序“</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">”org.eclipse.jdt.debug.ui.localJavaShortcut“</span> <span class="code SchemaTag">&gt; &lt;description description =</span> <span class="code SchemaCstring">”运行本地Java应用程序“</span> <span class="code SchemaTag">mode =</span> <span class="code SchemaCstring">”run“</span> <span class="code SchemaTag">&gt; &lt;/ description&gt; &lt;description description =</span> <span class="code SchemaCstring">“调试本地Java应用程序”</span> <span class="code SchemaTag">mode =</span> <span class="code SchemaCstring">“debug”</span> <span class="code SchemaTag">&gt; &lt;/ description&gt; &lt;contextualLaunch&gt; &lt;enablement&gt; &lt;with variable =</span> <span class="code SchemaCstring">“selection”</span> <span class="code SchemaTag">&gt; &lt;count value =</span> <span class="code SchemaCstring">“1”</span> <span class="code SchemaTag">/&gt; &lt;iterate&gt; &lt;或&gt; &lt;test property =</span> <span class="code SchemaCstring">“org.eclipse.jdt.launching.hasMain”</span> <span class="code SchemaTag">/&gt; &lt;和&gt; &lt;test property =</span> <span class="code SchemaCstring">“org.eclipse.jdt.launching.isContainer”</span> <span class="code SchemaTag">/&gt; &lt;test property =</span> <span class="code SchemaCstring">“org.eclipse.jdt.launching.hasProjectNature”</span> <span class="code SchemaTag">args =</span> <span class="code SchemaCstring">“org.eclipse.jdt.core.javanature”</span> <span class="code SchemaTag">/&gt; &lt;/ and&gt; &lt;/或&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;/ enablement&gt; &lt;/ contextualLaunch&gt; &lt;configurationType id =</span> <span class="code SchemaCstring">“org.eclipse.jdt。 launch.localJavaApplication“</span> <span class="code SchemaTag">&gt; &lt;/ configurationType&gt; &lt;/ shortcut&gt; &lt;/ extension&gt;</span></pre>

<p>在上面的示例中，将在运行和调试级联菜单中显示启动快捷方式，标签为“Java Application”。此外，仅当所选项包含main方法或是Java项目且具有<code>org.eclipse.debug.ui.actions. ，才会显示快捷方式<code>org.eclipse.debug.ui.actions.ILaunchable</code>适配器。
</p>
<p>有关属性测试器的更多信息，请参阅<code>org.eclipse.core.expressions.PropertyTester</code>
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>属性<b>类的</b>值必须是实现接口<b>org.eclipse.debug.ui的Java类的完全限定名<b>。ILaunchShortcut</b> 。3.4中的新增功能，客户端可以实现<code>org.eclipse.debug.ui.ILaunchShortcut2</code>参与上下文敏感启动资源和非资源的工件。
</p>
<p>从3.1开始，调试平台为每个启动快捷方式及其适用模式注册命令处理程序，以允许客户端为启动快捷方式定义键绑定。生成处理程序的命令ID将生成为启动快捷方式id属性，后跟一个点和适用的启动模式。例如，上面的启动快捷方式示例的命令ID将是<code>com.example.ExampleLaunchShortcutId.debug</code>用于在调试模式下启动。命令和键绑定可以定义如下，以将“ <code>ALT-SHIFT-D, E</code> ”绑定到启动快捷方式。
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.commands”</span> <span class="code SchemaTag">&gt; &lt;command name =</span> <span class="code SchemaCstring">“Debug Example Launch”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“Debug Example Launch”</span> <span class="code SchemaTag">categoryId =</span> <span class="code SchemaCstring">“org.eclipse.debug.ui.category.run”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“com。例。ExampleLaunchShortcutId.debug“</span> <span class="code SchemaTag">&gt; &lt;/ command&gt; &lt;keyBinding keySequence =</span> <span class="code SchemaCstring">”M3 + M2 + D E“</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">”org.eclipse.ui.globalScope“</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">”com.example。ExampleLaunchShortcutId.debug“</span> <span class="code SchemaTag">keyConfigurationId =</span> <span class="code SchemaCstring">”org.eclipse.ui.defaultAcceleratorConfiguration“</span> <span class="code SchemaTag">&gt; &lt;/ keyBinding&gt; &lt;/ extension&gt;</span></pre>

<p>从3.3开始，启动快捷方式现在可以指示它们将使用configurationType元素创建的启动配置类型。如果给定的启动快捷方式可以创建多种类型的启动配置，则可以使用此元素指定多个类型。<br>例：</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.debug.ui.launchShortcuts”</span> <span class="code SchemaTag">&gt; &lt;shortcut class =</span> <span class="code SchemaCstring">“MyShortcut”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“启动一个简单的程序”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“myShortcut”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“My Shortcut”</span> <span class="code SchemaTag">modes =</span> <span class="code SchemaCstring">“run”</span> <span class="code SchemaTag">&gt; &lt;configurationType id =</span> <span class="code SchemaCstring">“mylaunchtypes”</span> <span class="code SchemaTag">&gt; &lt;/ configurationType&gt; &lt;/ shortcut&gt; &lt;/ extension&gt;</span></pre>

<p>从3.3开始，启动快捷方式可以提供人类可读的描述。这用于在上下文启动过程中向新手用户提供可供选择的启动快捷方式列表。<br>可以通过以下两种方式之一提供描述：</p><ol>
<li>可以为快捷方式提供一般描述，该快捷方式将适用于快捷方式支持的所有模式</li>
<li>可以为特定模式指定每个描述</li>
</ol>适用于运行和调试模式的一般描述示例：<pre class="Example"><span class="code SchemaTag">&lt;shortcut class =</span> <span class="code SchemaCstring">“MyShortcut”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“启动一个简单的程序”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“myShortcut”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“我的快捷方式”</span> <span class="code SchemaTag">模式=</span> <span class="code SchemaCstring">“运行，调试”</span> <span class="code SchemaTag">&gt; &lt;/快捷方式&gt; &lt;/ extension&gt;</span></pre>仅适用于运行模式的说明示例：<pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.debug.ui.launchShortcuts”</span> <span class="code SchemaTag">&gt; &lt;shortcut class =</span> <span class="code SchemaCstring">“MyShortcut”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“myShortcut”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“My Shortcut”</span> <span class="code SchemaTag">modes =</span> <span class="code SchemaCstring">“run，debug”</span> <span class="code SchemaTag">&gt; &lt;description description =</span> <span class="code SchemaCstring">“运行简单程序“</span> <span class="code SchemaTag">mode =</span> <span class="code SchemaCstring">”run“</span> <span class="code SchemaTag">&gt; &lt;/ description&gt; &lt;/ shortcut&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>平台不提供启动快捷方式。请注意，虽然启动快捷方式不必与特定的启动配置类型相关联，但除非至少有一个支持快捷方式启动模式的启动配置类型，否则不会显示启动快捷菜单。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2007 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2244.sA.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="sA">
            <div class="headl">
               <div class="headr">
                  <h1>§AOT / J语法</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sA.html">§AOT / J语法</a></li>
                  <li><a href="#sA.0">§A.0关键字</a></li>
                  <li><a href="#sA.1">§A.1类定义</a></li>
                  <li><a href="#sA.2">§A.2修饰符</a></li>
                  <li><a href="#sA.3">§A.3方法绑定</a></li>
                  <li><a href="#sA.4">§A.4参数映射</a></li>
                  <li><a href="#sA.5">§A.5声明</a></li>
                  <li><a href="#sA.6">§A.6类型</a></li>
                  <li><a href="#sA.7">§A.7守护谓词</a></li>
                  <li><a href="#sA.8">§A.8优先声明</a></li>
                  <li><a href="#sA.9">§A.9价值相关类型</a></li>
                  <li><a href="#sA.10">§A.10包装和进口</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>符号</h3>
               <p>以下语法规则扩展了<a href="http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html" class="ext">Java语言规范中</a>给出的Java语法。我们采用以斜体字体（例如， <tt><em>ClassDeclaration</em></tt> ）打印非终端符号和以罗马字体（例如， <tt>类</tt> ）打印终端符号的约定。以黑色打印的名称是指原始Java语法中的定义。对象组添加以<strong class="blue">蓝色粗体</strong>打印。对于那些只是向现有规则添加新选项的规则，原始选项由椭圆（ <code>...</code> ）表示。
                  		
               </p>
            </div>
            <div class="sect depth2" id="sA.0">
               <h2 class="sect">§A.0关键字<a class="img" href="sA.0.html" title="永久链接到§A.0关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>OT / J引入的关键字具有不同的范围，这意味着在给定范围之外，这些关键字可用于常规标识符。只有这些名称是无条件的关键词：</p>
               <div class="listing plain"><pre>只读，团队，内部</pre></div>
               <div class="sect depth3" id="sA.0.1">
                  <h3 class="sect">§A.0.1Scoped关键字<a class="img" href="sA.0.1.html" title="PermaLinkto§A.0.1Scoped关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>以下名称是OT / J中的关键字，只有当它们出现在团队或角色类中时，即，在关键字<strong class="blue">团队</strong>被识别后：</p>
                  <div class="listing plain"><pre>as，base，callin，playingBy，precedence，tsuper，with，when</pre></div>
                  <p>这些名称只是分别在callin或callout绑定的上下文中的关键字（ <a href="#sA.3" title="§A.3方法绑定" class="sect">§A.3</a> ）：</p>
                  <div class="listing plain"><pre>之后，之前，替换，获取，设置</pre></div>
               </div>
               <div class="sect depth3" id="sA.0.2">
                  <h3 class="sect">§A.0.2继承范围的关键字<a class="img" href="sA.0.2.html" title="PermaLinkto§A.0.2继承范围的关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>虽然常规Java类可以自由使用OT / J的作用域关键字（第<a href="#sA.0.1" title="§A.0.1Scoped关键字" class="sect">A.0.1节</a> ），但如果角色类继承了名称为作用域关键字的特性，则会出错。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="sA.0.3">
                  <h3 class="sect">§A.0.3内部名称<a class="img" href="sA.0.3.html" title="PermaLinkto§A.0.3内部名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>编译器和运行时环境生成以前缀<code>_OT$</code>开头的内部方法和字段。在客户端代码中使用任何这些方法和字段是非法的。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="sA.1">
               <h2 class="sect">§A.1类定义<a class="img" href="sA.1.html" title="PermaLinkto§A.1类定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>类定义添加了两个新关键字<code>team</code>和<code>playedBy</code> 。使用这些关键字的类分别称为<strong>团队</strong>和<strong>绑定角色</strong> 。从绑定角色类继承的任何类（通过<code>extends</code>子句或通过隐式继承，参见
                  	<a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）也是一个受约束的角色类。
                  		
               </p>
               <table class="syntaxrule" id="sA.1.1">
                  <tr>
                     <td class="sect">§A.1.1</td>
                     <td class="rule"><span class="title">ClassDeclaration</span><br><em>[Modifiers]</em> <strong class="blue"><em>[</em> team <em>]</em></strong> class <em>Identifier [</em> extends <em>Type] [</em> implements <em>TypeList]</em><br><span class="indent5"></span> <strong class="blue"><em>[</em> playingBy <em>Type] [Guard]</em></strong> <em>ClassBody</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>playedBy</code>子句（ <strong>绑定角色</strong>类）的类可能不会被声明为静态，并且必须直接包含在具有<code>team</code>修饰符（ <strong>团队</strong>类）的类中。
                     </li>
                     <li>从团队类继承的类也必须具有<code>team</code>修饰符。
                     </li>
                     <li>有守卫的班级（见<a href="s5.4.html" title="§5.4守护谓词" class="sect">§5.4</a> ）必须是团队或角色。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.2">
               <h2 class="sect">§A.2修饰符<a class="img" href="sA.2.html" title="PermaLinkto§A.2修饰符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>方法修饰符的规则添加一个关键字： <code>callin</code> ：</p>
               <table class="syntaxrule" id="sA.2.1">
                  <tr>
                     <td class="sect">§A.2.1</td>
                     <td class="rule"><span class="title">修改</span><br>...<br><strong class="blue">呼唤</strong></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>callin</code>修饰符的方法的类可能不会被声明为static，并且必须直接包含在team类中。
                     </li>
                     <li>具有<code>callin</code>修饰符的方法可能不会出现在显式方法调用中（规则在JLS中应用）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.3">
               <h2 class="sect">§A.3方法绑定<a class="img" href="sA.3.html" title="PermaLinkto§A.3方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>通过方法绑定增强了类体中可声明的项的规则：</p>
               <table class="syntaxrule" id="sA.3.1">
                  <tr>
                     <td class="sect">§A.3.1</td>
                     <td class="rule"><span class="title">ClassBodyDeclaration</span><br>...<br><strong class="blue"><em>CalloutBinding</em></strong><br><strong class="blue"><em>CallinBinding</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.2">
                  <tr>
                     <td class="sect">§A.3.2</td>
                     <td class="rule"><span class="title">CalloutBinding</span><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind MethodSpec CalloutParameterMappings</strong></em><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind CalloutModifier FieldSpec</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.3">
                  <tr>
                     <td class="sect">§A.3.3</td>
                     <td class="rule"><span class="title">Callin绑定</span><br><em>[Identifier</em> ： <em>] [TypeArguments]</em> <strong class="blue"><em>MethodSpec</em> &lt; - <em>CallinModifier MethodSpecs</em><br><span class="indent5"></span> [ <em>Guard</em> ] <em>CallinParameterMappings</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.4">
                  <tr>
                     <td class="sect">§A.3.4</td>
                     <td class="rule"><span class="title">MethodSpec</span><br><em>识别码</em><br><em>ResultType MethodDeclarator</em><br><em>ConstructorDeclarator</em></td>
                  </tr>
               </table>
               <div class="note">请注意， <em>ResultType</em> ， <em>MethodDeclarator</em>和<em>ConstructorDeclarator</em>在Java语言规范的整体语法中不明确。为方便起见，我们参考<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">8.4节中的定义<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">。方法声明</a>和<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8" class="ext">8.8。构造函数</a> Java语言规范的声明。
                  		
               </div>
               <table class="syntaxrule" id="sA.3.5">
                  <tr>
                     <td class="sect">§A.3.5</td>
                     <td class="rule"><span class="title">MethodSpecs</span><br><strong class="blue"><em>MethodSpec [</em> ， <em>MethodSpecs]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.6">
                  <tr>
                     <td class="sect">§A.3.6</td>
                     <td class="rule"><span class="title">CalloutKind</span><br><strong class="blue">- &gt;<br>=&gt;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.7">
                  <tr>
                     <td class="sect">§A.3.7</td>
                     <td class="rule"><span class="title">CallinModifier</span><br><strong class="blue">之前</strong><br><strong class="blue">后</strong><br><strong class="blue">更换</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.8">
                  <tr>
                     <td class="sect">§A.3.8</td>
                     <td class="rule"><span class="title">CalloutModifier</span><br><strong class="blue">得到</strong><br><strong class="blue">组</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.9">
                  <tr>
                     <td class="sect">§A.3.9</td>
                     <td class="rule"><span class="title">的FieldSpec</span><br><em>[类型]标识符</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li><code>CalloutBinding</code>和<code>CallinBinding</code>只能在绑定的角色类中出现。
                     </li>
                     <li><code>CalloutBinding</code>或<code>CallinBinding</code>可能不会为其方法说明符（ <code>MethodSpec</code> ）混合标识符和完整签名（ <code>MethodDeclarationHead</code> ）。
                        					<br>将完整方法签名绑定到字段需要<code>FieldSpec</code>包含<code>Type</code> 。
                     </li>
                     <li>具有<code>replace</code>修饰符的<code>CallinBinding</code>左侧的方法说明符必须引用具有<code>callin</code>修饰符的方法。
                     </li>
                     <li>标注绑定的<code>Modifier</code>只能是<code>public</code> ， <code>protected</code>或<code>private</code>的可见性修饰符之一。短的标注绑定（即没有签名）不得指定可见性修饰符。
                     </li>
                     <li>形状<code>ConstructorDeclarator</code> <code>MethodSpec</code>仅在绑定后的callin右侧合法（参见<a href="s4.1.i.html" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.4">
               <h2 class="sect">§A.4参数映射<a class="img" href="sA.4.html" title="PermaLinkto§A.4参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.4.1">
                  <tr>
                     <td class="sect">§A.4.1</td>
                     <td class="rule"><span class="title">CalloutParameterMappings</span><br><strong class="blue">使用{ <em>CalloutParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.2">
                  <tr>
                     <td class="sect">§A.4.2</td>
                     <td class="rule"><span class="title">CallinParameterMappings</span><br><strong class="blue">与{ <em>CallinParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.3">
                  <tr>
                     <td class="sect">§A.4.3</td>
                     <td class="rule"><span class="title">CalloutParameterMappingList</span><br><strong class="blue"><em>CalloutParameterMapping [</em> ， <em>CalloutParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.4">
                  <tr>
                     <td class="sect">§A.4.4</td>
                     <td class="rule"><span class="title">CallinParameterMappingList</span><br><strong class="blue"><em>CallinParameterMapping [</em> ， <em>CallinParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.5">
                  <tr>
                     <td class="sect">§A.4.5</td>
                     <td class="rule"><span class="title">CalloutParameterMapping</span><br><em>表达式</em> <strong class="blue">- &gt;</strong> <em>标识符</em><br><strong class="blue">结果&lt; -</strong> <em>表达</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.6">
                  <tr>
                     <td class="sect">§A.4.6</td>
                     <td class="rule"><span class="title">CallinParameterMapping</span><br><em>标识符</em> <strong class="blue">&lt; -</strong> <em>表达式</em><br><em>表达</em> <strong class="blue">- &gt;</strong> <strong class="blue">结果</strong></td>
                  </tr>
               </table>
               <div class="note">
                  <h5>注意：</h5>通过定义“;”作为参数映射的一个选项，语法强制执行没有参数映射的方法绑定由“;”终止。此外，带参数映射的方法绑定可以选择性地以“;”结束，在这种情况下，它被解释为空成员声明，遵循相同的模式，Java中的非抽象方法可以选择性地具有尾随“;”。
                  		
               </div>
            </div>
            <div class="sect depth2" id="sA.5">
               <h2 class="sect">§A.5声明<a class="img" href="sA.5.html" title="PermaLink至§A.5声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.5.1">
                  <tr>
                     <td class="sect">§A.5.1</td>
                     <td class="rule"><span class="title">声明</span><br>...<br><em><strong class="blue">内</strong><br><strong class="blue">BaseCall</strong><br><strong class="blue">TSuperCall</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.2">
                  <tr>
                     <td class="sect">§A.5.2</td>
                     <td class="rule"><span class="title">内</span><br><strong class="blue">在</strong> （ <em>表达</em> ） <em>声明中</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.3">
                  <tr>
                     <td class="sect">§A.5.3</td>
                     <td class="rule"><span class="title">BaseCall</span><br><strong class="blue">基地</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">基数</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.4">
                  <tr>
                     <td class="sect">§A.5.4</td>
                     <td class="rule"><span class="title">TSuperCall</span><br><strong class="blue">tsuper</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">tsuper</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>的表达<code>Within</code>结果必须为团队类的一个实例。
                     </li>
                     <li><code>BaseCall</code>的第一种形式可能仅出现在具有<code>callin</code>修饰符的方法的主体中。标识符必须是封闭方法的名称。
                     </li>
                     <li><code>BaseCall</code>的第二种形式可能只出现在绑定角色类的构造函数中。
                     </li>
                     <li><code>TSuperCall</code>的第一种形式可能只出现在角色类的方法中。
                     </li>
                     <li><code>TSuperCall</code>的第二种形式可能只出现在角色类的构造函数中。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.6">
               <h2 class="sect">§A.6类型<a class="img" href="sA.6.html" title="PermaLinkto§A.6类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.6.1">
                  <tr>
                     <td class="sect">§A.6.1</td>
                     <td class="rule"><span class="title">类型</span><br>...<br><strong class="blue"><em>LiftingType</em></strong><br><strong class="blue"><em>AnchoredType</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.2">
                  <tr>
                     <td class="sect">§A.6.2</td>
                     <td class="rule"><span class="title">LiftingType</span><br><em>类型</em> <strong class="blue">为</strong> <em>第一</em> <em>类</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.3">
                  <tr>
                     <td class="sect">§A.6.3</td>
                     <td class="rule"><span class="title">AnchoredType</span><br><strong class="blue"><em>路径</em></strong> 。<em>类型</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.4">
                  <tr>
                     <td class="sect">§A.6.4</td>
                     <td class="rule"><span class="title">路径</span><br><em>识别码</em><br><strong class="blue"><em>路径</em></strong> 。<em>识别码</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.6.a"><span class="title">地点</span><br><code>LiftingType</code>可能仅出现在团队类的方法的参数列表中。
                        				
                     </li>
                     <li id="sA.6.b"><span class="title">角色在范围内</span><br><code>LiftingType</code>的右侧类型必须是直接包含在封闭团队类中的类（该类可以通过<a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">隐式继承</a>获取<a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">（§1.3.1。（c））</a> ）。
                        				
                     </li>
                     <li id="sA.6.c"><span class="title">团队路径</span><br><em>注意，不推荐使用§A.6.3/ 4的语法来支持<a href="#sA.9" title="§A.9价值相关类型" class="sect">§A.9</a></em> 。
                        					<br><code>AnchoredType</code>的路径必须引用团队类的实例。必须使用<code>final</code>修饰符声明路径中的每个标识符。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.7">
               <h2 class="sect">§A.7守护谓词<a class="img" href="sA.7.html" title="永久链接到§A.7Guard谓词"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.7.1">
                  <tr>
                     <td class="sect">§A.7.1</td>
                     <td class="rule"><span class="title">守护</span><br><strong class="blue"><em>[</em>基数<em>]</em>何时</strong> （ <em>表达</em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.7.2">
                  <tr>
                     <td class="sect">§A.7.2</td>
                     <td class="rule"><span class="title">MethodDeclaration</span><br>...<br><em>MethodHeader <strong class="blue">[Guard]</strong> MethodBody</em></td>
                  </tr>
               </table>
               <p>其他涉及<em><code>Guard</code></em>规则： <a href="#sA.1.1" title="§A.1.1ClassDeclaration" class="sect">ClassDeclaration（§A.1.1）</a> ， <a href="#sA.3.3" title="§A.3.3Callin绑定" class="sect">CallinBinding（§A.3.3）</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>保护中的<code>Expression</code>必须具有<code>boolean</code>类型。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.8">
               <h2 class="sect">§A.8优先声明<a class="img" href="sA.8.html" title="PermaLinkto§A.8优先声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.8.1">
                  <tr>
                     <td class="sect">§A.8.1</td>
                     <td class="rule"><span class="title">PrecedenceDeclaration</span><br><strong class="blue">优先级[after]</strong> <em>CallinNameList</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.8.2">
                  <tr>
                     <td class="sect">§A.8.2</td>
                     <td class="rule"><span class="title">CallinNameList</span><br><em>名称[，CallinNameList]</em></td>
                  </tr>
               </table>
            </div>
            <div class="sect depth2" id="sA.9">
               <h2 class="sect">§A.9价值相关类型<a class="img" href="sA.9.html" title="PermaLinkto§A.9依赖于值的类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.9.1">
                  <tr>
                     <td class="sect">§A.9.1</td>
                     <td class="rule"><span class="title">TypeParameter</span><br><em>TypeVariable [TypeBound]</em><br><strong class="blue"><em>ReferenceType名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#108850" class="ext">JLS3§4.4</a></p>
               <table class="syntaxrule" id="sA.9.2">
                  <tr>
                     <td class="sect">§A.9.2</td>
                     <td class="rule"><span class="title">ActualTypeArgument</span><br><em>引用类型</em><br><em>通配符</em><br><strong class="blue"><em>@名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#107353" class="ext">JLS3§4.5.1</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.9.a"><span class="title">ActualTypeParameter</span><br><code>@Name</code>形式的<code>ActualTypeArgument</code>只能作为简单名称类型引用的参数出现。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.10">
               <h2 class="sect">§A.10包装和进口<a class="img" href="sA.10.html" title="PermaLinkto§A.10包和导入"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.10.1">
                  <tr>
                     <td class="sect">§A.10.1</td>
                     <td class="rule"><span class="title">PackageDeclaration</span><br>...<br><strong class="blue">团队</strong>包<em>QualifiedName</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.10.2">
                  <tr>
                     <td class="sect">§A.10.2</td>
                     <td class="rule"><span class="title">进口</span><br>...<br><strong>import</strong> <strong class="blue">base</strong> <em>QualifiedName</em> ;</td>
                  </tr>
               </table>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="1903.sA.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="chapter" id="sA">
            <div class="headl">
               <div class="headr">
                  <h1>§AOT / J语法</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="sA.html">§AOT / J语法</a></li>
                  <li><a href="#sA.0">§A.0关键字</a></li>
                  <li><a href="#sA.1">§A.1类定义</a></li>
                  <li><a href="#sA.2">§A.2修饰符</a></li>
                  <li><a href="#sA.3">§A.3方法绑定</a></li>
                  <li><a href="#sA.4">§A.4参数映射</a></li>
                  <li><a href="#sA.5">§A.5声明</a></li>
                  <li><a href="#sA.6">§A.6类型</a></li>
                  <li><a href="#sA.7">§A.7守护谓词</a></li>
                  <li><a href="#sA.8">§A.8优先声明</a></li>
                  <li><a href="#sA.9">§A.9价值相关类型</a></li>
                  <li><a href="#sA.10">§A.10包装和进口</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>符号</h3>
               <p>以下语法规则扩展了<a href="http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html" class="ext">Java语言规范中</a>给出的Java语法。我们采用以斜体字体（例如， <tt><em>ClassDeclaration</em></tt> ）打印非终端符号和以罗马字体（例如， <tt>类</tt> ）打印终端符号的约定。以黑色打印的名称是指原始Java语法中的定义。对象组添加以<strong class="blue">蓝色粗体</strong>打印。对于那些只是向现有规则添加新选项的规则，原始选项由椭圆（ <code>...</code> ）表示。
                  		
               </p>
            </div>
            <div class="sect depth2" id="sA.0">
               <h2 class="sect">§A.0关键字<a class="img" href="sA.html#sA.0" title="永久链接到§A.0关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>OT / J引入的关键字具有不同的范围，这意味着在给定范围之外，这些关键字可用于常规标识符。只有这些名称是无条件的关键词：</p>
               <div class="listing plain"><pre>只读，团队，内部</pre></div>
               <div class="sect depth3" id="sA.0.1">
                  <h3 class="sect">§A.0.1Scoped关键字<a class="img" href="sA.html#sA.0.1" title="PermaLinkto§A.0.1Scoped关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>以下名称是OT / J中的关键字，只有当它们出现在团队或角色类中时，即，在关键字<strong class="blue">团队</strong>被识别后：</p>
                  <div class="listing plain"><pre>as，base，callin，playingBy，precedence，tsuper，with，when</pre></div>
                  <p>这些名称只是分别在callin或callout绑定的上下文中的关键字（ <a href="#sA.3" title="§A.3方法绑定" class="sect">§A.3</a> ）：</p>
                  <div class="listing plain"><pre>之后，之前，替换，获取，设置</pre></div>
               </div>
               <div class="sect depth3" id="sA.0.2">
                  <h3 class="sect">§A.0.2继承范围的关键字<a class="img" href="sA.html#sA.0.2" title="PermaLinkto§A.0.2继承范围的关键字"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>虽然常规Java类可以自由使用OT / J的作用域关键字（第<a href="#sA.0.1" title="§A.0.1Scoped关键字" class="sect">A.0.1节</a> ），但如果角色类继承了名称为作用域关键字的特性，则会出错。
                     			
                  </p>
               </div>
               <div class="sect depth3" id="sA.0.3">
                  <h3 class="sect">§A.0.3内部名称<a class="img" href="sA.html#sA.0.3" title="PermaLinkto§A.0.3内部名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#sA.0">↑§A.0</a></span></h3>
                  <p>编译器和运行时环境生成以前缀<code>_OT$</code>开头的内部方法和字段。在客户端代码中使用任何这些方法和字段是非法的。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="sA.1">
               <h2 class="sect">§A.1类定义<a class="img" href="sA.html#sA.1" title="PermaLinkto§A.1类定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>类定义添加了两个新关键字<code>team</code>和<code>playedBy</code> 。使用这些关键字的类分别称为<strong>团队</strong>和<strong>绑定角色</strong> 。从绑定角色类继承的任何类（通过<code>extends</code>子句或通过隐式继承，参见
                  	<a href="s1.html#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">§1.3.1。（c）</a> ）也是一个受约束的角色类。
                  		
               </p>
               <table class="syntaxrule" id="sA.1.1">
                  <tr>
                     <td class="sect">§A.1.1</td>
                     <td class="rule"><span class="title">ClassDeclaration</span><br><em>[Modifiers]</em> <strong class="blue"><em>[</em> team <em>]</em></strong> class <em>Identifier [</em> extends <em>Type] [</em> implements <em>TypeList]</em><br><span class="indent5"></span> <strong class="blue"><em>[</em> playingBy <em>Type] [Guard]</em></strong> <em>ClassBody</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>playedBy</code>子句（ <strong>绑定角色</strong>类）的类可能不会被声明为静态，并且必须直接包含在具有<code>team</code>修饰符（ <strong>团队</strong>类）的类中。
                     </li>
                     <li>从团队类继承的类也必须具有<code>team</code>修饰符。
                     </li>
                     <li>有守卫的班级（见<a href="s5.html#s5.4" title="§5.4守护谓词" class="sect">§5.4</a> ）必须是团队或角色。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.2">
               <h2 class="sect">§A.2修饰符<a class="img" href="sA.html#sA.2" title="PermaLinkto§A.2修饰符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>方法修饰符的规则添加一个关键字： <code>callin</code> ：</p>
               <table class="syntaxrule" id="sA.2.1">
                  <tr>
                     <td class="sect">§A.2.1</td>
                     <td class="rule"><span class="title">修改</span><br>...<br><strong class="blue">呼唤</strong></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>具有<code>callin</code>修饰符的方法的类可能不会被声明为static，并且必须直接包含在team类中。
                     </li>
                     <li>具有<code>callin</code>修饰符的方法可能不会出现在显式方法调用中（规则在JLS中应用）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.3">
               <h2 class="sect">§A.3方法绑定<a class="img" href="sA.html#sA.3" title="PermaLinkto§A.3方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <p>通过方法绑定增强了类体中可声明的项的规则：</p>
               <table class="syntaxrule" id="sA.3.1">
                  <tr>
                     <td class="sect">§A.3.1</td>
                     <td class="rule"><span class="title">ClassBodyDeclaration</span><br>...<br><strong class="blue"><em>CalloutBinding</em></strong><br><strong class="blue"><em>CallinBinding</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.2">
                  <tr>
                     <td class="sect">§A.3.2</td>
                     <td class="rule"><span class="title">CalloutBinding</span><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind MethodSpec CalloutParameterMappings</strong></em><br><em>[Modifier] [TypeArguments] <strong class="blue">MethodSpec CalloutKind CalloutModifier FieldSpec</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.3">
                  <tr>
                     <td class="sect">§A.3.3</td>
                     <td class="rule"><span class="title">Callin绑定</span><br><em>[Identifier</em> ： <em>] [TypeArguments]</em> <strong class="blue"><em>MethodSpec</em> &lt; - <em>CallinModifier MethodSpecs</em><br><span class="indent5"></span> [ <em>Guard</em> ] <em>CallinParameterMappings</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.4">
                  <tr>
                     <td class="sect">§A.3.4</td>
                     <td class="rule"><span class="title">MethodSpec</span><br><em>识别码</em><br><em>ResultType MethodDeclarator</em><br><em>ConstructorDeclarator</em></td>
                  </tr>
               </table>
               <div class="note">请注意， <em>ResultType</em> ， <em>MethodDeclarator</em>和<em>ConstructorDeclarator</em>在Java语言规范的整体语法中不明确。为方便起见，我们参考<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">8.4节中的定义<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="ext">。方法声明</a>和<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8" class="ext">8.8。构造函数</a> Java语言规范的声明。
                  		
               </div>
               <table class="syntaxrule" id="sA.3.5">
                  <tr>
                     <td class="sect">§A.3.5</td>
                     <td class="rule"><span class="title">MethodSpecs</span><br><strong class="blue"><em>MethodSpec [</em> ， <em>MethodSpecs]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.6">
                  <tr>
                     <td class="sect">§A.3.6</td>
                     <td class="rule"><span class="title">CalloutKind</span><br><strong class="blue">- &gt;<br>=&gt;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.7">
                  <tr>
                     <td class="sect">§A.3.7</td>
                     <td class="rule"><span class="title">CallinModifier</span><br><strong class="blue">之前</strong><br><strong class="blue">后</strong><br><strong class="blue">更换</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.8">
                  <tr>
                     <td class="sect">§A.3.8</td>
                     <td class="rule"><span class="title">CalloutModifier</span><br><strong class="blue">得到</strong><br><strong class="blue">组</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.3.9">
                  <tr>
                     <td class="sect">§A.3.9</td>
                     <td class="rule"><span class="title">的FieldSpec</span><br><em>[类型]标识符</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li><code>CalloutBinding</code>和<code>CallinBinding</code>只能在绑定的角色类中出现。
                     </li>
                     <li><code>CalloutBinding</code>或<code>CallinBinding</code>可能不会为其方法说明符（ <code>MethodSpec</code> ）混合标识符和完整签名（ <code>MethodDeclarationHead</code> ）。
                        					<br>将完整方法签名绑定到字段需要<code>FieldSpec</code>包含<code>Type</code> 。
                     </li>
                     <li>具有<code>replace</code>修饰符的<code>CallinBinding</code>左侧的方法说明符必须引用具有<code>callin</code>修饰符的方法。
                     </li>
                     <li>标注绑定的<code>Modifier</code>只能是<code>public</code> ， <code>protected</code>或<code>private</code>的可见性修饰符之一。短的标注绑定（即没有签名）不得指定可见性修饰符。
                     </li>
                     <li>形状<code>ConstructorDeclarator</code> <code>MethodSpec</code>仅在绑定后的callin右侧合法（参见<a href="s4.html#s4.1.i" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ）。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.4">
               <h2 class="sect">§A.4参数映射<a class="img" href="sA.html#sA.4" title="PermaLinkto§A.4参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.4.1">
                  <tr>
                     <td class="sect">§A.4.1</td>
                     <td class="rule"><span class="title">CalloutParameterMappings</span><br><strong class="blue">使用{ <em>CalloutParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.2">
                  <tr>
                     <td class="sect">§A.4.2</td>
                     <td class="rule"><span class="title">CallinParameterMappings</span><br><strong class="blue">与{ <em>CallinParameterMappingList [，]</em> }</strong><br><strong class="blue">;</strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.3">
                  <tr>
                     <td class="sect">§A.4.3</td>
                     <td class="rule"><span class="title">CalloutParameterMappingList</span><br><strong class="blue"><em>CalloutParameterMapping [</em> ， <em>CalloutParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.4">
                  <tr>
                     <td class="sect">§A.4.4</td>
                     <td class="rule"><span class="title">CallinParameterMappingList</span><br><strong class="blue"><em>CallinParameterMapping [</em> ， <em>CallinParameterMappingList]</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.5">
                  <tr>
                     <td class="sect">§A.4.5</td>
                     <td class="rule"><span class="title">CalloutParameterMapping</span><br><em>表达式</em> <strong class="blue">- &gt;</strong> <em>标识符</em><br><strong class="blue">结果&lt; -</strong> <em>表达</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.4.6">
                  <tr>
                     <td class="sect">§A.4.6</td>
                     <td class="rule"><span class="title">CallinParameterMapping</span><br><em>标识符</em> <strong class="blue">&lt; -</strong> <em>表达式</em><br><em>表达</em> <strong class="blue">- &gt;</strong> <strong class="blue">结果</strong></td>
                  </tr>
               </table>
               <div class="note">
                  <h5>注意：</h5>通过定义“;”作为参数映射的一个选项，语法强制执行没有参数映射的方法绑定由“;”终止。此外，带参数映射的方法绑定可以选择性地以“;”结束，在这种情况下，它被解释为空成员声明，遵循相同的模式，Java中的非抽象方法可以选择性地具有尾随“;”。
                  		
               </div>
            </div>
            <div class="sect depth2" id="sA.5">
               <h2 class="sect">§A.5声明<a class="img" href="sA.html#sA.5" title="PermaLink至§A.5声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.5.1">
                  <tr>
                     <td class="sect">§A.5.1</td>
                     <td class="rule"><span class="title">声明</span><br>...<br><em><strong class="blue">内</strong><br><strong class="blue">BaseCall</strong><br><strong class="blue">TSuperCall</strong></em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.2">
                  <tr>
                     <td class="sect">§A.5.2</td>
                     <td class="rule"><span class="title">内</span><br><strong class="blue">在</strong> （ <em>表达</em> ） <em>声明中</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.3">
                  <tr>
                     <td class="sect">§A.5.3</td>
                     <td class="rule"><span class="title">BaseCall</span><br><strong class="blue">基地</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">基数</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.5.4">
                  <tr>
                     <td class="sect">§A.5.4</td>
                     <td class="rule"><span class="title">TSuperCall</span><br><strong class="blue">tsuper</strong> 。<em>标识符</em> （ <em>参数<sub>opt</sub></em> ）<br><strong class="blue">tsuper</strong> （ <em>参数<sub>选择</sub></em> ）</td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>的表达<code>Within</code>结果必须为团队类的一个实例。
                     </li>
                     <li><code>BaseCall</code>的第一种形式可能仅出现在具有<code>callin</code>修饰符的方法的主体中。标识符必须是封闭方法的名称。
                     </li>
                     <li><code>BaseCall</code>的第二种形式可能只出现在绑定角色类的构造函数中。
                     </li>
                     <li><code>TSuperCall</code>的第一种形式可能只出现在角色类的方法中。
                     </li>
                     <li><code>TSuperCall</code>的第二种形式可能只出现在角色类的构造函数中。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.6">
               <h2 class="sect">§A.6类型<a class="img" href="sA.html#sA.6" title="PermaLinkto§A.6类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.6.1">
                  <tr>
                     <td class="sect">§A.6.1</td>
                     <td class="rule"><span class="title">类型</span><br>...<br><strong class="blue"><em>LiftingType</em></strong><br><strong class="blue"><em>AnchoredType</em></strong></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.2">
                  <tr>
                     <td class="sect">§A.6.2</td>
                     <td class="rule"><span class="title">LiftingType</span><br><em>类型</em> <strong class="blue">为</strong> <em>第一</em> <em>类</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.3">
                  <tr>
                     <td class="sect">§A.6.3</td>
                     <td class="rule"><span class="title">AnchoredType</span><br><strong class="blue"><em>路径</em></strong> 。<em>类型</em></td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.6.4">
                  <tr>
                     <td class="sect">§A.6.4</td>
                     <td class="rule"><span class="title">路径</span><br><em>识别码</em><br><strong class="blue"><em>路径</em></strong> 。<em>识别码</em></td>
                  </tr>
               </table>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.6.a"><span class="title">地点</span><br><code>LiftingType</code>可能仅出现在团队类的方法的参数列表中。
                        				
                     </li>
                     <li id="sA.6.b"><span class="title">角色在范围内</span><br><code>LiftingType</code>的右侧类型必须是直接包含在封闭团队类中的类（该类可以通过<a href="s1.html#s1.3.1.c" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">隐式继承</a>获取<a href="s1.html#s1.3.1.c" title="§1.3.1。（c）覆盖和隐式继承" class="sect">（§1.3.1。（c））</a> ）。
                        				
                     </li>
                     <li id="sA.6.c"><span class="title">团队路径</span><br><em>注意，不推荐使用§A.6.3/ 4的语法来支持<a href="#sA.9" title="§A.9价值相关类型" class="sect">§A.9</a></em> 。
                        					<br><code>AnchoredType</code>的路径必须引用团队类的实例。必须使用<code>final</code>修饰符声明路径中的每个标识符。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.7">
               <h2 class="sect">§A.7守护谓词<a class="img" href="sA.html#sA.7" title="永久链接到§A.7Guard谓词"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.7.1">
                  <tr>
                     <td class="sect">§A.7.1</td>
                     <td class="rule"><span class="title">守护</span><br><strong class="blue"><em>[</em>基数<em>]</em>何时</strong> （ <em>表达</em> ）</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.7.2">
                  <tr>
                     <td class="sect">§A.7.2</td>
                     <td class="rule"><span class="title">MethodDeclaration</span><br>...<br><em>MethodHeader <strong class="blue">[Guard]</strong> MethodBody</em></td>
                  </tr>
               </table>
               <p>其他涉及<em><code>Guard</code></em>规则： <a href="#sA.1.1" title="§A.1.1ClassDeclaration" class="sect">ClassDeclaration（§A.1.1）</a> ， <a href="#sA.3.3" title="§A.3.3Callin绑定" class="sect">CallinBinding（§A.3.3）</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li>保护中的<code>Expression</code>必须具有<code>boolean</code>类型。
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.8">
               <h2 class="sect">§A.8优先声明<a class="img" href="sA.html#sA.8" title="PermaLinkto§A.8优先声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.8.1">
                  <tr>
                     <td class="sect">§A.8.1</td>
                     <td class="rule"><span class="title">PrecedenceDeclaration</span><br><strong class="blue">优先级[after]</strong> <em>CallinNameList</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.8.2">
                  <tr>
                     <td class="sect">§A.8.2</td>
                     <td class="rule"><span class="title">CallinNameList</span><br><em>名称[，CallinNameList]</em></td>
                  </tr>
               </table>
            </div>
            <div class="sect depth2" id="sA.9">
               <h2 class="sect">§A.9价值相关类型<a class="img" href="sA.html#sA.9" title="PermaLinkto§A.9依赖于值的类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.9.1">
                  <tr>
                     <td class="sect">§A.9.1</td>
                     <td class="rule"><span class="title">TypeParameter</span><br><em>TypeVariable [TypeBound]</em><br><strong class="blue"><em>ReferenceType名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#108850" class="ext">JLS3§4.4</a></p>
               <table class="syntaxrule" id="sA.9.2">
                  <tr>
                     <td class="sect">§A.9.2</td>
                     <td class="rule"><span class="title">ActualTypeArgument</span><br><em>引用类型</em><br><em>通配符</em><br><strong class="blue"><em>@名称</em></strong></td>
                  </tr>
               </table>
               <p>见<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#107353" class="ext">JLS3§4.5.1</a></p>
               <div class="constraints">
                  <h5 class="constraints">上下文约束：</h5>
                  <ol class="constraints">
                     <li id="sA.9.a"><span class="title">ActualTypeParameter</span><br><code>@Name</code>形式的<code>ActualTypeArgument</code>只能作为简单名称类型引用的参数出现。
                        				
                     </li>
                  </ol>
               </div>
            </div>
            <div class="sect depth2" id="sA.10">
               <h2 class="sect">§A.10包装和进口<a class="img" href="sA.html#sA.10" title="PermaLinkto§A.10包和导入"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§A</a></span></h2>
               <table class="syntaxrule" id="sA.10.1">
                  <tr>
                     <td class="sect">§A.10.1</td>
                     <td class="rule"><span class="title">PackageDeclaration</span><br>...<br><strong class="blue">团队</strong>包<em>QualifiedName</em> ;</td>
                  </tr>
               </table>
               <table class="syntaxrule" id="sA.10.2">
                  <tr>
                     <td class="sect">§A.10.2</td>
                     <td class="rule"><span class="title">进口</span><br>...<br><strong>import</strong> <strong class="blue">base</strong> <em>QualifiedName</em> ;</td>
                  </tr>
               </table>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s9.html" rel="prev">&lt;&lt;§9价值依赖类</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.html" rel="next">§B版本之间的变化&gt;&gt;</a></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="0594.EMF.Edit.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<link rel="stylesheet" href="images/../../../css/book.css" type="text/css"></link>
<link rel="stylesheet" href="images/../../../css/emf-book.css" type="text/css"></link>
<title>EMF.Edit概述</title>
</head>
<body lang="EN-US" dir="ltr" xml:lang="EN-US">
<h1>EMF.Edit概述</h1>

<p>最后更新时间：2004年6月1日</p>

<p>本文档假定您熟悉基本的EMF（Eclipse Modeling Framework）概念。有关EMF的更多信息，请参阅<a href="../../references/overview/EMF.html">EMF概述</a> 。</p>


<h2>内容</h2>
<p><a href="#introduction">介绍</a><br>
<a href="#jface">在JFace查看器中显示EMF对象</a><br>
<a href="#providers">项目提供者实现类</a><br>
<a href="#commands">使用命令修改EMF模型</a><br>
<a href="#generator">使用EMF.Edit代码生成器</a></p>

<h2><a name="introduction">介绍</a></h2>

<p>如果您有一个基于EMF的模型，您已生成使用EMF生成器的代码，并且您现在已准备好将用户界面添加到模型和代码中，则可以使用EMF.Edit框架使您的工作更轻松。</p>

<p>EMF.Edit是一个Eclipse框架，包含用于为EMF模型构建编辑器的通用可重用类。它提供：</p>

<ul>
<li>内容和标签提供程序类，属性源支持以及允许使用标准桌面（JFace）查看器和属性表显示EMF模型的其他便捷类。</li>
<li>一个命令框架，包括一组通用命令实现类，用于构建支持全自动撤消和重做的编辑器。</li>
<li>一个代码生成器，能够生成为EMF模型构建完整编辑器插件所需的一切。它生成一个结构合理的编辑器，符合Eclipse EMF模型编辑器的推荐样式。然后，您可以根据需要自定义代码，而不会丢失与模型的连接。</li>
</ul>

<p>本文概述了EMF.Edit frameowrk和生成器工具的基本概念。有关更深入的信息，您可以参考框架类的文档，其中详细介绍了它们的特定行为和功能。</p>

<h2><a name="jface">在JFace查看器中显示EMF对象</a></h2>

<h3>什么是内容提供商？</h3>

<p>Eclipse用户界面框架（JFace）包括一组可重用的查看器类（例如TreeViewer，TableViewer），用于显示结构化模型。JFace查看器不是要求被查看的模型对象遵循某些特定协议（即实现某些特定接口），而是使用任何类型的对象（即任何java.lang）。对象子类）。这是可能的，因为查看者不是直接导航模型对象，而是通过称为<dfn>内容提供者</dfn>的适配器对象访问模型对象。</p>

<p>每个查看器类使用实现特定提供程序接口的内容提供程序。例如，TreeViewer使用实现以下接口的内容提供程序：</p>

<pre>公共接口ITreeContentProvider ...{public Object [] getChildren（Object object）; public Object getParent（Object object）; ...}</pre>

<p>基本结构如下图所示：</p>

<img src="images/EMF.Edit/image001.gif" border="0" width="481" height="207" alt="JFace内容提供商">

<p>就TreeViewer而言，它在屏幕上显示一个对象树（它称之为项目），除了输入（根）对象之外，所有这些对象都通过在其内容提供者上调用getChildren（）来提供。</p>

<p>尽管每个观看者都要求内容提供者实现其特定的界面，但是其他类型的观看者的处理方式类似。尽管所有查看器界面都不同，但内容提供者通常可以同时实现其中的几个，允许相同的内容提供者类用于多种查看者。</p>

<h3>为EMF模型提供内容</h3>

<p>EMF.Edit框架提供了一个通用内容提供程序实现类，可用于为EMF模型提供内容。类AdapterFactoryContentProvider通过委托给知道如何导航查看器的模型对象（项）的EMF适配器来实现内容提供者接口。例如，用于支持树查看器的EMF适配器类将实现以下EMF.Edit接口：</p>

<pre>public interface ITreeItemProvider {public Collection getChildren（Object object）; public Object getParent（Object object）; ...}</pre>

<p>请注意此接口与上述内容提供程序接口ITreeContentProvider的相似性。AdapterFactoryContentProvider通过定位然后委派给所需项目的适配器（实现项目提供程序接口）来实现内容提供程序接口。术语从对象到项目的转换是有意识的：从观察者的角度来看，它们是项目，而不是对象。</p>

<p>EMF图片如下所示：</p>

<img src="images/EMF.Edit/image002.gif" border="0" width="607" height="231" alt="AdapterFactoryContentProvider委托给项目提供者">

<p class="Note">注意：您可以使用EMF.Edit框架提供的生成器为给定的EMF模型自动生成ItemProviderAdapterFactory和ItemProvider类。稍后会详细介绍。</p>

<p>AdapterFactoryContentProvider使用适配器工厂构建，该工厂与任何其他EMF适配器工厂一样，用于创建和定位特定类型的适配器（在本例中为ItemProviders）。内容提供程序通过调用ItemProviderAdapterFactory上的adapt（item）来为getChildren（）之类的请求提供服务，该项将为指定的项创建或返回ItemProvider（适配器）。然后它只是委托给所需接口的getChildren（）方法（在本例中为ITreeItemProvider）。</p>

<p>AdapterFactoryContentProvider中的getChildren（）方法如下所示：</p>

<pre>public Object [] getChildren（Object object）{ITreeItemContentProvider adapter =（ITreeItemContentProvider）adapterFactory.adapt（object，ITreeItemContentProvider.class）; return adapter.getChildren（object）.toArray（）; }</pre>

<p>所有内容提供者方法都使用相同的模式。如前所述，AdapterFactoryContentProvider只是简单地将内容提供者方法委托给知道如何为请求提供服务的特定项提供者（适配器）。</p>

<p>在上面的getChildren（）方法中，传递给adapterFactory.adapt（）的对象是一个简单的java.lang。对象（不是org.eclipse.emf.ecore。EObject）。这是EMF.Edit框架的一个重要特性。该框架经过精心设计，以适应可能与模型本身不同的EMF模型的视图（即，抑制对象或包含其他虚拟对象的视图）。为了允许这种EMF和非EMF对象的混合，适配器工厂的框架基类提供了一个如下所示的adapt（）实现：</p>

<pre>public Object adapt（Object object，Object type）{if（object instanceof Notifier）return this.adapt（（Notifier）object，type）;否则返回对象; }</pre>

<p>如果指定的对象不是EMF通知程序<sup><a class="footnote" href="#fn1">[1]</a> <a name="ref1"> </a></sup> ，它返回对象本身。使用此设计，想要将非EMF项添加到视图的项提供程序可以简单地返回（例如，从其getChildren（）方法）它想要的任何非EMF对象。只要返回的对象实现了查看器的必需项提供程序接口（例如，ITreeItemProvider），它就会被视为所有其他EMF项。</p>

<p>设计的这一方面强调了为什么我们更喜欢调用提供者/适配器类项提供者而不是适配器。在非常重要的应用程序中，视图模型（即，查看者的内容提供者提供的模型）通常是“真实”（EMF）模型对象的混合，其项目提供者恰好是（EMF）适配器，并且“幻像”项目提供者本身就是对象的对象。因此，虽然所有适配器也是项目提供者，但反过来并不一定如此。</p>

<h3>JFace标签提供商</h3>

<p>在前面的部分中，我们描述了JFace查看器如何使用内容提供程序来获取其内容项。类似的方法用于获取观看者正在显示的项目的标签图像和文本。查看器使用另一个称为标签提供者的对象（类似于内容提供者），而不是询问项目本身的标签。例如，TreeViewer委托实现ILabelProvider接口的对象来获取树中项目的标签。</p>

<h3>为EMF对象提供标签</h3>

<p>EMF.Edit框架使用相同的机制来实现EMF模型的标签提供程序，因为它用于提供内容。通用标签提供程序实现类AdapterFactoryLabelProvider（与AdapterFactoryContentProvider完全相同）将ILabelProvider接口委托给模型的项提供程序（提供内容的相同项提供程序）。展开的图片如下所示：</p>

<img src="images/EMF.Edit/image003.gif" border="0" width="608" height="326" alt="AdapterFactoryLabelProvider委托给项目提供者">

<p>内容和标签提供程序可以（通常会）委托给同一个适配器工厂，因此也可以委托相同的项目提供程序。就内容提供者而言，项目提供者是实际完成工作的地方。</p>

<p>使用EMF.Edit提供程序类，用户可以为某些EMF模型构造TreeViewer，如下所示：</p>

<pre>myAdapterFactory = ...treeViewer = new TreeViewer（）; treeViewer.setContentProvider（new AdapterFactoryContentProvider（myAdapterFactory））; treeViewer.setLabelProvider（new AdapterFactoryLabelProvider（myAdapterFactory））;</pre>

<p>然后，可以在通常的（JFace规定的）方式中将该TreeViewer显示在编辑器窗口中。</p>

<p>到目前为止，您可能认为这一切似乎都非常简单，但仅仅因为我们所展示的是如何委托给其他人（即适配器工厂）。我们还没有实现任何方法，我们只是将它们委托给了它们。但是，EMF.Edit支持方法实现，EMF.Edit包含一个代码生成器，可为您生成大部分项目提供程序和工厂代码。在我们开始讨论之前，我们先来看看项目提供商如何完成他们的工作。</p>

<h2><a name="providers">项目提供者实现类</a></h2>

<p>如上一节所示，为EMF模型提供内容的实际工作是由附加到模型的项目提供程序适配器完成的。上图中ItemProvider适配器的数量和类型有意模糊。这是因为EMF.Edit框架为项提供程序适配器支持两种不同的模式：</p>

<ol>
<li>有状态适配器 - 模型中每个对象的一个适配器对象</li>
<li>单例适配器 - 模型中每种类型对象的一个适配器对象（如果可能，建议使用）</li>
</ol>

<p>给定模型的项目提供者可以使用这些模式中的任何一种或两者的混合来实现。</p>

<h3>有状态项提供程序适配器</h3>

<p>对于第一个模式，模型中的每个对象都与其适配器一一对应。每个适配器都有一个指针（称为目标），指向它正在适应的唯一对象。</p>

<p>图片看起来像这样：</p>

<img src="images/EMF.Edit/image004.gif" border="0" width="615" height="257" alt="有状态项提供程序适配器">

<p>如图所示，该模式使应用程序中的对象数量加倍，因此仅在需要实例来承载附加状态的应用程序中才有意义。这就是我们称之为有状态模式的原因。</p>

<h3>单例项提供程序适配器</h3>

<p>Singleton模式是一种避免大多数额外对象的更好方法。使用此模式，我们对所有相同类型的项使用单个项提供程序适配器。它看起来像这样：</p>

<img src="images/EMF.Edit/image005.gif" border="0" width="615" height="257" alt="单例项提供程序适配器">

<p>在这张图片中，对象像往常一样有适配器指针，但项目提供程序（共享）没有指向对象的指针。如果您还记得我们之前在内容提供程序部分中查看过的树项提供程序接口，您可能已经注意到所有方法都采用了额外的参数（对象）：</p>

<pre>public interface ITreeItemProvider {public Collection getChildren（Object object）; public Object getParent（Object object）; ...}</pre>

<p>object参数被添加到每个项提供程序接口，专门用于支持此模式。在有状态的情况下，此对象将始终与适配器的目标相同。</p>

<p>您可能会问自己的另一个问题是，为什么我们不支持“真正的”Singleton适配器模式 - 也就是说，所有对象只有一个适配器？答案很简单，虽然它是另一种可能的模式（与EMF.Edit框架兼容） <sup><a class="footnote" href="#fn2">[2]</a> <a name="ref2"> </a></sup>我们不鼓励它，因为完全动态的实现虽然简单，但很难定制（没有大量乱码的instanceof（）检查）。具有类型化项目提供程序类的替代方法，其继承层次结构镜像模型，提供了一个方便的调度点，用于为模型实现漂亮的面向对象的视图代码。</p>

<h2><a name="commands">使用命令修改EMF模型</a></h2>

<p>到目前为止，我们只展示了如何使用内容和标签提供商查看EMF模型。EMF.Edit框架的另一个特性是它支持基于命令的模型编辑。我们使用术语“编辑”来表示可撤销修改，而不是简单地“编写”模型。</p>

<h3>编辑域名</h3>

<p>EMF.Edit接口EditingDomain用于提供对EMF模型的编辑访问。另一个EMF.Edit实现类AdapterFactoryEditingDomain的工作方式与内容和标签提供程序类似，方法是将其实现委托给项目提供程序（通过ItemProviderAdapterFactory）：</p>

<img src="images/EMF.Edit/image006.gif" border="0" width="608" height="249" alt="编辑域名">

<p>如图所示，它还提供对命令堆栈的访问，通过该命令堆栈将对模型进行所有修改。编辑域提供两种基本服务：</p>

<ul>
<li>命令工厂</li>
<li>通用EMF.Edit命令的模型特定详细信息的提供程序（如添加，删除，复制等）。</li>
</ul>

<p>考虑编辑域的最佳方式是作为模型的修改或写入提供者，而内容和标签提供者是查看或读取提供者。这是大局：</p>

<img src="images/EMF.Edit/image007.gif" border="0" width="607" height="331" alt="读写提供者">

<h3>修改模型</h3>

<p>让我们看一个修改模型的简单示例。</p>

<p>假设类公司有一个一对多的引用，命名为部门，到类部门。要从公司中删除部门（例如，实现编辑器删除操作），我们可以简单地编写以下代码：</p>

<pre>部门d = ......公司c = ......。c.getDepartments（）除去（d）;</pre>

<p>虽然很简单，但这段代码只是简单地进行修改。</p>

<p>相反，我们使用EMF.Edit remove命令（org.eclipse.emf.edit.command。RemoveCommand）删除部门，我们会写下面的内容：</p>

<pre>部门d = ......公司c = ......EditingDomain ed = ...RemoveCommand cmd = new RemoveCommand（ed，c，CompanyPackage.eINSTANCE.getCompany_Departments（），d）; 。ed.getCommandStack（）执行（CMD）;</pre>

<p>以这种方式删除部门有几个好处：</p>

<ol>
<li>可以通过调用ed.getCommandStack（）来撤消删除。撤消（）。</li>
<li>我们可以通过检查命令堆栈上是否有命令来查明模型是否脏（例如启用保存菜单），假设所有修改都是使用命令完成的（这是EMF.Edit框架所倡导的）。
</li>
<li>我们可以通过调用cmd.canExecute（）来检查命令是否有效（例如，启用删除菜单）。</li>
</ol>

<p>通过这种方式普遍使用命令是启用EMF.Edit框架可以为您提供的各种功能的方法。</p>

<h3>使用编辑域创建命令</h3>

<p>在前面的示例中，我们使用一个简单的新调用创建了一个RemoveCommand。这很好，但不是很可重复使用;代码片段正在做一个非常具体的事情，从公司中删除一个部门。相反，如果我们想编写一个能够删除任何类型对象的可重用删除操作，我们可以通过使用EditingDomain来帮助完成这项工作。</p>

<p>EditingDomain接口包含（除其他外）命令工厂方法createCommand（），可以使用而不是new来创建命令：</p>

<pre>public interface EditingDomain {...命令createCommand（Class commandClass，CommandParameter commandParameter）; ...}</pre>

<p>要使用此方法创建命令，首先需要创建CommandParameter对象，将命令参数设置到其中，然后调用create方法，并将所需的命令类（例如，RemoveCommand.class）和参数传递给它。</p>

<p>而不是让客户端完成所有这些，我们使用在每个命令类中提供静态方便create（）方法的约定。使用静态create（）方法，您可以创建和执行RemoveCommand，如下所示：</p>

<pre>部门d = ......EditingDomain ed = ...命令cmd = RemoveCommand.create（ed，d）; 。ed.getCommandStack（）执行（CMD）;</pre>

<p>如您所见，这只是一个小的语法更改（RemoveCommand.create（）而不是新的RemoveCommand）。但是存在根本的差异。除了编辑域之外，我们只传递了一个参数（即被删除的对象），而不是之前的三个参数。注意现在如何使用这段代码来删除任何类型的对象。通过将命令的创建委托给编辑域，我们让它填写缺少的参数。</p>

<h3>编辑域如何处理createCommand（）请求？</h3>

<p>要了解它是如何工作的，让我们继续使用RemoveCommand.create（）调用。如前所述，静态create（）方法只是一种方便的方法，它委托给编辑域，如下所示：</p>

<pre>public static命令create（EditingDomain domain，Object value）{return domain.createCommand（RemoveCommand.class，new CommandParameter（null，null，Collections.singleton（value）））; }</pre>

<p>然后，AdapterFactoryEditingDomain接受请求并使用标准委托模式将其传递给项目提供者（如前面的AdapterFactorContentProvider委托的getChildren（））：</p>

<pre>public命令createCommand（Class commandClass，CommandParameter commandParameter）{Object owner = ... //获取命令的所有者对象IEditingDomainItemProvider adapter =（IEditingDomainItemProvider）adapterFactory.adapt（owner，IEditingDomainItemProvider.class）; return adapter.createCommand（owner，this，commandClass，commandParameter）; }</pre>

<p class="Note">注意：如果你看一下实际的createCommand（）方法，你会发现它实际上要复杂得多。这是因为它还旨在处理一次删除对象集合等问题。然而，这是它在概念上所做的一切。</p>

<p>createCommand（）方法使用所有者对象来访问要委托的项提供程序（即，所有者在adapterFactory.adapt（）调用中使用）。我们示例中的所有者将是公司对象（即被删除的部门的父级）。编辑域通过调用要删除的对象的项提供程序上的getParent（）方法来确定所有者。</p>

<p>所有这些的影响是最终在要删除的对象的父项的提供者（即原始代码片段中的公司c的CompanyItemProvider）上调用方法createCommand（）。因此，CompanyItemProvider可以通过执行以下操作来实现createCommand（）：</p>

<pre>公共类CompanyItemProvider ...{...public命令createCommand（final Object object，...，Class commandClass，...）{if（commandClass == RemoveCommand.class）{return new RemoveCommand（object，CompanyPackage.eINSTANCE.getCompany_Departments（），commandParameter.getCollection（））; } ...}}</pre>

<p>这将完成工作，但有更好的方法。</p>

<p>每个项提供程序类（也是EMF适配器）都扩展自EMF.Edit便捷基类ItemProviderAdapter，它提供了createCommand（）等的默认实现。它通过调用在项提供程序子类中实现的一些简单方法（不仅仅用于此目的），为EMF.Edit框架提供的所有标准命令实现createCommand（）。这是模板方法设计模式的一个示例。</p>

<p>要使RemoveCommand示例正常工作，CompanyItemProvider只需要实现以下方法：</p>

<pre>public Collection getChildrenFeatures（Object object）{return Collections.singleton（CompanyPackage.eINSTANCE.getCompany_Departments（））; }</pre>

<p>如图所示，此方法返回用于引用对象子级的一个或多个要素（在本例中，仅为deparments引用）。调用此方法后，createCommand（）的默认实现将确定要使用的功能（如果返回多个功能）并使用正确的创建RemoveCommand。</p>

<h3>覆盖命令</h3>

<p>通过编辑域创建命令的另一个好处是，它允许我们插入不同的子类或标准命令的完全不同的实现，并让标准编辑器只需要它们。例如，假设我们在从公司中删除部门时要进行一些额外的清理。实现这一目标的最简单方法可能是创建一个名为RemoveDepartmentCommand的RemoveCommand子类，如下所示：</p>

<pre>public class RemoveDepartmentCommand extends RemoveCommand {public void execute（）{super.execute（）; //做额外的事......}}</pre>

<p>那部分很容易。</p>

<p>现在，如果我们的编辑器使用静态RemoveCommand.create（）方法（调用editingDomain.createCommand（））而不是新的RemoveCommand（），那么我们可以通过覆盖项目提供程序中的createCommand（）轻松地将RemoveDepartmentCommand替换为标准的RemoveCommand。像这样：</p>

<pre>公共类CompanyItemProvider ...{...public命令createCommand（最终的Object对象，...）{if（commandClass == RemoveCommand.class）{return new RemoveDepartmentCommand（...）; } return super.createCommand（...）; }}</pre>

<p>实际上，如果我们想要专门化的命令是预定义命令之一（如RemoveCommand），则替换更加容易，因为createCommand（）的默认实现将每个命令的创建调度到特定于命令的方便方法，如下所示：</p>

<pre>public命令createCommand（最终的Object对象，...{...if（commandClass == RemoveCommand.class）返回createRemoveCommand（...）; else if（commandClass == AddCommand.class）返回createAddCommand（...）;否则......}</pre>

<p>因此，我们可以通过重写createRemoveCommand（）而不是createCommand（）方法本身来创建我们的RemoveDepartmentCommand：</p>

<pre>protected命令createRemoveCommand（...）{return new RemoveDepartmentCommand（...）; }</pre>

<p>总而言之，关键点在于编辑域是调整命令参数的钩子，包括命令类本身，因此我们可以轻松控制模型上任何编辑命令的行为。</p>

<h3>型号变更通知</h3>

<p>我们还没有谈到的一件事是变更通知。在命令更改模型中的某些内容后，我们如何让查看器刷新？答案是它使用标准EMF适配器通知和EMF.Edit提供的查看器刷新机制的组合。</p>

<p>构造时，AdapterFactoryContentProvider将自身注册为侦听器（即org.eclipse.emf.edit.provider。INotifyChangedListener）其适配器工厂（实现org.eclipse.emf.edit.provider）。IChangeNotifier接口）。适配器工厂依次将自身传递给它创建的每个项目提供程序，因此它可以是模型的中央更改通知程序。AdapterFactoryContentProvider还记录（在inputChanged（）方法中）为其提供内容的查看器，以便它在收到更改通知时更新其查看器。</p>

<p>下图显示了EMF模型对象的更改（例如，更改公司名称）将如何通过适配器工厂返回到模型的查看器。</p>

<img src="images/EMF.Edit/image008.gif" border="0" width="607" height="251" alt="型号变更通知">

<p>每当EMF对象更改状态时，都会在所有对象的适配器上调用notifyChanged（）方法，包括项提供程序（在本例中为CompanyItemProvider）。项提供程序中的notifyChanged（）方法负责确定是否应将每个事件通知传递给查看器，如果是，则应该导致哪种类型的更新。</p>

<p>为此，它在ViewerNotification中包含有趣的通知，这是一个简单的IViewerNotification接口实现。此接口扩展了基本的Notification接口，如下所示：</p>

<pre>public interface IViewerNotification扩展Notification {Object getElement（）; boolean isContentRefresh（）; boolean isLabelUpdate（）; }</pre>

<p>这些方法指定查看器中要更新的项目，是否刷新该元素下的内容，以及是否更新该元素的标签。由于项目提供程序确定对象的子项和标签，因此它还必须确定如何有效地更新查看器。</p>

<p>CompanyItemProvider类中的notifyChanged（）方法如下所示：</p>

<pre>public void notifyChanged（通知通知）{...switch（notification.getFeatureID（Company.class））{case CompanyPackage。COMPANY__NAME：fireNotifyChanged（new ViewerNotification（notification，...，false，true））;返回;案例CompanyPackage。COMPANY__DEPARTMENT：fireNotifyChanged（new ViewerNotification（notification，...，true，false））;返回; } super.notifyChanged（通知）; }</pre>

<p>在此实现中，对name属性的更改会导致标签更新，并且对部门引用的更改会导致内容刷新。任何其他更改通知对查看器都没有影响。</p>

<p>fireNotifyChanged（）方法是类ItemProviderAdapter（所有项提供程序适配器的基类）中的便捷方法，它只是将通知转发给适配器工厂<sup><a class="footnote" href="#fn3">[3]</a> <a name="ref3"> </a></sup> 。适配器工厂（更改通知程序）继续将通知分派给其所有侦听器（在此示例中，只是树查看器的内容提供程序）。最后，内容提供商按照通知的指示更新查看者。</p>

<h3>组合适配器工厂</h3>

<p>EMF模型通常通过交叉模型引用绑定在一起。每当您需要构建一个应用程序来编辑或显示跨越多个EMF模型的对象时，您将需要一个能够调整两个（或更多）模型中对象的并集的适配器工厂。</p>

<p>通常，您已经为各个型号配备了适配器工厂，您需要的只是将它们粘合在一起。另一个EMF.Edit便利类ComposedAdapterFactory可用于此目的：</p>

<img src="images/EMF.Edit/image009.gif" border="0" width="607" height="250" alt="适配器工厂组成">

<p>ComposedAdapterFactory用于为其他适配器工厂提供公共接口，它只是委托其实现。</p>

<p>要设置组合适配器工厂，您可以编写如下内容：</p>

<pre>model1AdapterFactory = ...model2AdapterFactory = ...ComposedAdapterFactory myAdapterFactory = new ComposedAdapterFactory（）; myAdapterFactory.addAdapterFactory（model1AdapterFactory）; myAdapterFActory.addAdapterFActory（model2AdapterFactory）; myContentProvider = new AdapterFactoryContentProvider（myAdapterFactory）; ...
</pre>

<h2><a name="generator">使用EMF.Edit代码生成器</a></h2>

<p class="Note">注意：有关生成EMF模型以及EMF.Edit编辑器的分步教程，请参阅<a href="../../tutorials/clibmod/clibmod.html">教程：生成EMF模型</a> 。</p>

<p>给定EMF模型定义，EMF.Edit代码生成器可以生成一个功能齐全的编辑器工具，允许您使用几个常见的查看器查看模型的实例，以及添加，删除，剪切，复制和粘贴模型对象，或修改标准属性表中的对象，都具有完全撤消/重做支持。</p>

<p>EMF.Edit生成器生成完整的工作插件，包括以下内容：</p>

<ol>
<li>ItemProviderAdapterFactory</li>
<li>ItemProviders（每个模型类一个）</li>
<li>编辑</li>
<li>ModelWizard</li>
<li>ActionBarContributor</li>
<li>插入</li>
<li>plugin.xml中</li>
<li>图标</li>
</ol>

<p>生成后，编辑器应该运行。它会出现，但它可能会或可能没有按预期工作（也就是说，生成器可能不适合您的模型的默认选择）。但是，应该很容易在几个地方调整生成的代码，以便快速启动并运行基本的工作编辑器。</p>

<p>下面将详细介绍一些更有趣的生成类。</p>

<h3>ItemProviderAdapterFactory</h3>

<p>生成的ItemProviderAdapterFactory是生成EMF模型时生成的AdapterFactory类的简单子类。
</p>

<p class="Note">注意：生成的EMF适配器工厂通过调度到特定于类型的create（）方法来创建适配器，该方法需要重写子类（如ItemProviderAdapterFactory）。EMF适配器工厂（例如，ABCAdapterFactory）使用另一个生成的类（ABCSwitch）来有效地实现调度。</p>

<p>使用有状态模式时，适配器工厂创建方法只返回一个新对象，如下所示：</p>

<pre>class ABCItemProviderAdapterFactory扩展了ABCAdapterFactoryImpl {...public Adapter createCompanyAdapter（）{return new CompanyItemProvider（this）; } ...}</pre>

<p>相反，如果使用Singleton模式，则适配器工厂还会跟踪单例实例并为每次调用返回它：</p>

<pre>protected DepartmentItemProvider departmentItemProvider; public Adapter createDepartmentAdapter（）{if（departmentItemProvider == null）{departmentItemProvider = new DepartmentItemProvider（this）; } return departmentItemProvider; }</pre>

<h3>ItemProvider类</h3>

<p>对于模型中的每个类，将生成相应的项提供程序类。生成的项目提供程序混合了支持标准查看器，命令和属性表所需的所有接口：</p>

<pre>公共类DepartmentItemProvider扩展...实现IEditingDomainItemProvider，IStructuredItemContentProvider，ITreeItemContentProvider，IItemLabelProvider，IItemPropertySource {...}</pre>

<p>如果模型类是根（即，它没有显式基类），则生成的项提供程序将从EMF.Edit项提供程序基类ItemProviderAdapter扩展：</p>

<pre>公共类EmployeeItemProvider扩展ItemProviderAdapter ...
</pre>

<p>相反，如果模型类继承自基类，则生成的项提供程序将从基础项提供程序扩展，如下所示：</p>

<pre>公共类EmployeeItemProvider扩展PersonItemProvider ...
</pre>

<p>对于多重继承类，生成的项提供程序将从第一个基类的项提供程序扩展（如在单继承的情况下），并且它将为其余的基类实现提供程序函数。</p>

<p>如果查看生成的项提供程序类，您会注意到它们的许多功能实际上是在项提供程序基类中实现的。生成的项提供程序子类的最重要的功能是：</p>

<ol>
<li>识别孩子和父母</li>
<li>设置属性描述符</li>
<li>传递“有趣”的通知事件。</li>
</ol>

<h3>编辑和模型向导</h3>

<p>生成的Editor和ModelWizard展示了如何将所有其他生成的片段与标准JFace组件放在一起以生成工作编辑器。</p>

<p>ModelWizard可用于创建模型类型的新资源。相反，如果您已经拥有了以其他方式创建的资源，则可以将其导入桌面工作区并在其上启动编辑器，完全绕过ModelWizard。</p>

<br><hr noshade="noshade" size="1">

<p><sup><a class="footnote" href="#ref1">[1]</a> <a name="fn1"> </a></sup> Notifier是EMF中的基本接口，用于可以注册适配器并向其发送通知的对象。它由EObject扩展，EObject是所有模型对象的基础接口。</p>

<p><sup><a class="footnote" href="#ref2">[2]</a> <a name="fn2"> </a></sup>实际上，EMF适配器工厂是继承驱动的，因此您可以选择使用基本适配器来处理模型中任何级别的子类，EObject是极端情况。</p>

<p><sup><a class="footnote" href="#ref3">[3]</a> <a name="fn3"> </a></sup>除了作为查看者的更改通知程序的适配器工厂之外，ItemProviderAdapter还可以具有其他（直接）侦听器，这些侦听器也在ItemProviderAdapter.fireNotifyChanged（）中调用。</p>
</body>
</html><html id="2270.CompleteOCLTutorial.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>完成OCL教程</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="Tutorials.html" title="Tutorials"></link>
<link rel="prev" href="Tutorials.html" title="Tutorials"></link>
<link rel="next" href="SafeNavigationTutorial.html" title="Safe navigation tutorial"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">完成OCL教程</h1>
<div class="section" title="完成OCL教程">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="CompleteOCLTutorial"></a>完成OCL教程</h2>
</div>
</div>
</div>
<p>本教程已针对Eclipse Mars更新：Eclipse 4.5，EMF 2.11，OCL 6.0。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一些截图可能会略微过时。</p>
</li>
</ul>
</div>
<div class="section" title="概观">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Overview2"></a>概观</h3>
</div>
</div>
</div>
<p>在这个例子中你会</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>获取完整OCL语言的概述</p>
</li>
<li class="listitem">
<p>将完整的OCL文档加载到第三方应用程序中</p>
</li>
<li class="listitem">
<p>增强派生属性的Ecore验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证Ecore模型</p>
</li>
<li class="listitem">
<p>增强UML验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证UML模型</p>
</li>
<li class="listitem">
<p>增强Xtext验证</p>
</li>
<li class="listitem">
<p>使用其他完整OCL验证验证Xtext语法</p>
</li>
</ul>
</div>
</div>
<div class="section" title="完整的OCL实用程序">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLUtility"></a>完整的OCL实用程序</h3>
</div>
</div>
</div>
<p>OCL本身几乎没用，因为没有任何模型可以操作，约束无法达到很大的效果。</p>
<p>使OCL有用的最简单方法是在模型中嵌入OCL表达式，以丰富具有更复杂行为的模型的基本结构特征。OCLinEcore为Ecore模型提供此功能。Papyrus为UML模型提供了类似的功能。</p>
<p>本教程介绍了完整的OCL语言，该语言可用于提供补充预先存在的元模型的独立文档。</p>
</div>
<div class="section" title="加载完成OCL教程示例项目">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadCompleteOCLTutorialExampleProject"></a>加载完成OCL教程示例项目</h3>
</div>
</div>
</div>
<p>本教程的所有材料都可以作为CompleteOCLTutorial示例项目的一部分提供，您可以通过使用Project Explorer的右键上下文菜单选择<span class="bold"><strong>New</strong></span> then <span class="bold"><strong>Example ...</strong></span>来加载它。这应该给出<span class="bold"><strong>New Example</strong></span>对话框，您可以在其中选择<span class="bold"><strong>OCL（OCL约束语言）插件</strong></span>和<span class="bold"><strong>Complete OCL Tutorial</strong></span> ，然后选择<span class="bold"><strong>Next</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-new-complete-ocl-tutorial1.png"></div>
<p>
				
</p>
<p>然后<span class="bold"><strong>完成</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-new-complete-ocl-tutorial2.png"></div>
<p>
				
</p>
<p>如果您没有看到这些示例项目，请按照<a class="link" href="Installation.html" title="Installing the Eclipse OCL Examples and Editors">安装OCL编辑器</a>的<a class="link" href="Installation.html" title="安装Eclipse OCL示例和编辑器">说明进行操作</a> 。
				</p>
<p>生成的项目有一些测试文件。</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-complete-ocl-tutorial-project.png"></div>
<p>
				
</p>
</div>
<div class="section" title="完整的OCL语言概述">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-language"></a>完整的OCL语言概述</h3>
</div>
</div>
</div>
<p>完整的OCL语言在本文档的<a class="link" href="CompleteOCL.html" title="完整的OCL语言">完整OCL</a>部分中有详细描述。在本教程中，我们将仅提供该语言的简要概述。如果尚未打开，请双击<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>以显示以下文本，其中提供了完整OCL语法的许多重要方面的示例。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-content.png"></div>
<p>
				
</p>
<div class="section" title="进口申报">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="importdeclarations"></a>进口申报</h4>
</div>
</div>
</div>
<p>导入语句是OMG规范中的一个严重遗漏，因为没有它，任何将完整OCL约束与外部模型对齐的尝试都依赖于特定于实现的魔法。因此，import语句是Eclipse OCL扩展，可能是未来OCL规范修订的一部分。</p>
<p>可以存在零个或多个import语句来指定外部模型元素的URI以及这些元素的别名。在示例中：</p>
<div class="literallayout">
<p>
<code class="code">import ecore：'http：//www.eclipse.org/emf/2002/Ecore#/'<br>

</code>
</p>
</div>
<p></p>
<p>
						
<code class="code">http://www.eclipse.org/emf/2002/Ecore</code>指定Ecore元模型的URI， <code class="code">#/</code>是导航到根元素（即Ecore包）的片段URI。<code class="code">ecore</code>指定此包的别名，该别名恰好与包的名称相同。在Complete OCL文档中，导入的模型元素可以通过其别名引用。
					</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>使用Ecore和UML绑定时，使用完整OCL文档的Java API支持需要特定于实现的魔法;必须通过调用代码将导入的模型加载到包注册表中。不使用导入语句。</p>
<p>在Juno发布之前，不了解import语句，因此Pivot和Ecore / UML绑定之间存在使用冲突。使用Xtext编辑器准备完整的OCL文档，或使用Pivot模型和Xtext解析器所需的import语句。但是重新使用Ecore和UML LPG解析器需要删除import语句。</p>
<p>在Juno中，LPG解析器忽略了import语句，因此它们可能会被保留。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="包上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="packagecontextdeclaration"></a>包上下文声明</h4>
</div>
</div>
</div>
<p>包上下文声明可以包括补充补充包中的模型元素的声明。</p>
<div class="literallayout">
<p>
<code class="code">包ecore<br>

<br>...<br>

<br>endpackage<br>

</code>
</p>
</div>
<p></p>
<p>这指定额外的完整OCL声明将补充<code class="code">ecore</code>包的预先存在的声明。
					</p>
<p>多个包上下文声明可用于补充多个包。</p>
<p>如果后续分类器上下文声明具有标识包的完全限定名称，则可以省略包上下文声明。</p>
</div>
<div class="section" title="分类器上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="classifiercontextdeclaration"></a>分类器上下文声明</h4>
</div>
</div>
</div>
<p>分类器上下文声明引入了补充分类器中的后续模型元素的声明。</p>
<div class="literallayout">
<p>
<code class="code">上下文EModelElement<br>

</code>
</p>
</div>
<p></p>
<p>分类器上下文由<code class="code">context</code>或<code class="code">endpackage</code>终止。
					</p>
</div>
<div class="section" title="功能定义">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="featuredefinitions"></a>功能定义</h4>
</div>
</div>
</div>
<p>可以定义其他操作和属性以在完整OCL文档中使用。可以使用这些特征，就好像它们是补充元模型的一部分一样。</p>
<div class="literallayout">
<p>
<code class="code">def：asError（verdict：Boolean）：Boolean =<br>如果判决然后是真的其他null endif<br>

<br>def：hasDerivation：Boolean = eAnnotations-&gt; select（source.startsWith（<br>'http://www.eclipse.org/emf/2002/Ecore/OCL'）） - &gt; notEmpty（）<br>

</code>
</p>
</div>
<p></p>
<p>定义以新功能名称开头，然后是操作参数和功能类型，后跟一个评估操作或属性的OCL表达式。</p>
<p>对于诸如<code class="code">hasDerivation</code>的属性，属性定义<code class="code">hasDerivation</code>与无参数操作定义<code class="code">hasDerivation()</code>之间的差异非常小。属性定义和用法是两个字符更短，可能看起来更自然。操作定义的优点是它可以在派生类中重载。
					</p>
</div>
<div class="section" title="类不变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="classinvariants"></a>类不变量</h4>
</div>
</div>
</div>
<p>可以对互补的元模型强加不变量。不变量包含不变量的名称，后跟一个OCL表达式，当满足不变量时，该表达式计算为true。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsTransient：hasDerivation意味着瞬态<br>

</code>
</p>
</div>
<p></p>
<p>在已加载补充完整OCL文档的应用程序中验证模型时，将执行这些不变量。在<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;Load Document Menu Action">OCL-&gt;加载文档菜单操作中</a>解释了这一点的<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;加载文档菜单操作">重要性</a> 。
					</p>
<p>通过使用let变量或重新使用<code class="code">hasDerivation</code> helper属性，可以显着增强约束的可读性。
					</p>
</div>
<div class="section" title="自定义消息">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="custommessages"></a>自定义消息</h4>
</div>
</div>
</div>
<p>Eclipse OCL支持对不变量的两个扩展，允许自定义验证失败消息和严重性。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsVolatile（<br>必须为派生特征'+ self.toString（））指定'“volatile”：<br>asError（hasDerivation意味着volatile）<br>

</code>
</p>
</div>
<p></p>
<p>不变名称后面可以是带括号的OCL表达式，该表达式计算要用作验证失败消息的String。</p>
<p>验证失败的严重性可以由不变表达式评估的非真值控制。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="code">false</code>返回表示警告严重性</p>
</li>
<li class="listitem">
<p><code class="code">null</code>返回表示错误严重性</p>
</li>
<li class="listitem">
<p><code class="code">invalid</code>返回表示致命严重性</p>
</li>
</ul>
</div>
<p>有关详细<a class="link" href="Integration.html#Integration-Messages" title="Custom Validation Messages">信息</a> ，请参阅<a class="link" href="Integration.html#Integration-Messages" title="自定义验证消息">自定义验证消息</a> 。
					</p>
</div>
<div class="section" title="操作和属性上下文声明">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="operationandpropertycontextdeclarations"></a>操作和属性上下文声明</h4>
</div>
</div>
</div>
<p>完整的OCL还允许完成补充元模型中的不完整操作或属性声明。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>可以为属性指定初始值表达式或派生值约束。</p>
</li>
<li class="listitem">
<p>可以为操作指定正文表达式和前置条件/后置条件约束。</p>
</li>
</ul>
</div>
<p>这些设施的用途有限，因为OCLinEcore避免了对不完整元模型的需求。</p>
</div>
</div>
<div class="section" title="OCL-&gt;加载文档菜单操作">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LoadCompleteOCLResource"></a> OCL-&gt;加载文档菜单操作</h3>
</div>
</div>
</div>
<p>上面的主要免责声明是，完整OCL仅补充了已加载完整OCL的应用程序中的补充元模型。</p>
<p>在Juno发布之前，这意味着Complete OCL仅可用于自定义Java应用程序，因为没有标准建模应用程序会加载补充文档。</p>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作使完整的OCL文档可以加载到各种应用程序中。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-load-complete-ocl-resource-menu.png"></div>
<p>
				
</p>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作被添加到应用程序的右按钮菜单中，可从当前选择访问ResourceSet。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>已经观察到额外的菜单操作并不总是立即可用，因此如果您没有看到它，请<span class="bold"><strong>按Esc</strong></span>取消菜单，选择与模型对象相对应的内容并再次右键单击。
					</p>
</blockquote>
</div>
<p></p>
<p>在火星中，合适的应用是</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>一个由Ecore元模型生成的编辑器</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>样本Ecore编辑器</p>
</li>
<li class="listitem">
<p>UML模型编辑器</p>
</li>
<li class="listitem">
<p>Papyrus模型编辑器</p>
</li>
<li class="listitem">
<p>你的模型编辑器</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>由Xtext生成的编辑器</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>Xtext编辑器</p>
</li>
<li class="listitem">
<p>MWE2编辑器</p>
</li>
<li class="listitem">
<p>OCLinEcore编辑器</p>
</li>
<li class="listitem">
<p>你的DSL编辑器</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p><span class="bold"><strong>OCL-&gt;加载文档</strong></span>菜单操作激活“ <span class="bold"><strong>加载完成OCL文档”</strong></span>对话框，您可以在其中浏览已注册的完整OCL文档，文件系统或工作区，以便加载一个或多个完整的OCL文档，或者通常可以更方便地拖动和从操作系统资源管理器或Eclipse Explorer中删除它们。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-load-complete-ocl-resource-dialog.png"></div>
<p>
				
</p>
<p>单击<span class="bold"><strong>确定</strong></span>后加载文档。
				</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>在幕后，有必要围绕所有补充包安装全局包装器。这些包装器对已请求补充的ResourceSet敏感，因此尽管这会对在其他应用程序中使用补充包产生很小的性能损失，但它不应影响其他应用程序的功能行为。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="示例Ecore的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-EcoreComplements"></a>示例Ecore的完整OCL补充</h3>
</div>
</div>
</div>
<p>Sample Ecore Editor已经获得了许多有用的验证规则，因此对于许多用户而言，仅调用<span class="bold"><strong>Validate</strong></span>就足够了。但如果不是呢？也许您有一些希望应用的样式约定。也许内置规则是不够的。
				</p>
<p>在Juno和<span class="bold"><strong>OCL-&gt; Load Document</strong></span>功能之前，您唯一的选择是查看Ecore编辑器并创建自定义变体。现在，您可以使用Complete OCL扩展Sample Ecore Editor。
				</p>
<p>我们将重新访问我们刚刚检查过的<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span>文档，并使用它来纠正Sample Ecore Editor对派生属性的不适当检查。该文档提供了六个不变量，其中至少有三个检测用户在Indigo发布周期中遇到的问题。
				</p>
<div class="section" title="DerivationIsVolatile">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsVolatile"></a> DerivationIsVolatile</h4>
</div>
</div>
</div>
<p>EMF代码生成模板具有<code class="code">volatile</code>的简单处理。非易失性变量具有由<code class="code">get</code>操作返回的关联字段。这会覆盖可能提供的任何派生。
					</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsVolatile：asError（hasDerivation意味着volatile）<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断如果EStructuralFeature具有派生，则还存在volatile声明以避免忽略派生。</p>
<p>此问题非常严重，基本表达式包含在<code class="code">asError</code>操作中，以将默认的<code class="code">true</code> / <code class="code">false</code> okay / warning severity转换为<code class="code">true</code> / <code class="code">null</code> okay / error severity。
					</p>
</div>
<div class="section" title="DerivationIsTransient">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsTransient"></a> DerivationIsTransient</h4>
</div>
</div>
</div>
<p>EMF代码生成模板具有类似的简单<code class="code">transient</code>处理。非瞬态变量将序列化为模型保存的一部分。这通常不合适，因为派生值是多余的，并且可以在再次加载模型时重新计算。
					</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsTransient：hasDerivation意味着瞬态<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断由于默认的非瞬态声明而导致派生未被序列化。</p>
</div>
<div class="section" title="DerivationIsNotComposed">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsNotComposed"></a> DerivationIsNotComposed</h4>
</div>
</div>
</div>
<p>组成由EMF直接处理，并且不清楚定义组成的替代含义是否合适。很可能EMF不允许使用备用语义。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsNotComposed：asError（hasDerivation意味着不包含）<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断派生是否试图指定备用组合语义，并在发生这种情况时报告错误。</p>
</div>
<div class="section" title="DerivationWithOppositeHasOppositeDerivation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationWithOppositeHasOppositeDerivation"></a> DerivationWithOppositeHasOppositeDerivation</h4>
</div>
</div>
</div>
<p>对立面也由EMF直接处理，但可以替换此功能。但是，如果替换了正向功能，则EMF的默认反向功能不太可能是合适的。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationWithOppositeHasOppositeDerivation：<br>hasDerivation和eOpposite &lt;&gt; null意味着eOpposite.hasDerivation<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们想要诊断重新定义相反的前向语义的派生也重新定义了相应的反向语义。</p>
</div>
<div class="section" title="DerivationIsUninitialized">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationIsUninitialized"></a> DerivationIsUninitialized</h4>
</div>
</div>
</div>
<p>可以将属性的初始值指定为简单默认值或派生表达式。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationIsUninitialized：<br>hasDerivation意味着defaultValue.oclIsUndefined（）<br>

</code>
</p>
</div>
<p></p>
<p>我们希望通过默认值诊断派生表达式的遮挡。</p>
</div>
<div class="section" title="DerivationDoesNotResolveProxies">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DerivationDoesNotResolveProxies"></a> DerivationDoesNotResolveProxies</h4>
</div>
</div>
</div>
<p>派生表达式不是引用。</p>
<div class="literallayout">
<p>
<code class="code">inv DerivationDoesNotResolveProxies：<br>hasDerivation意味着不是resolveProxies<br>

</code>
</p>
</div>
<p></p>
<p>因此，我们可以诊断EMF代理解析逻辑是否未被抑制。</p>
</div>
</div>
<div class="section" title="使用额外的完整OCL验证Ecore">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-EcoreValidation"></a>使用额外的完整OCL验证Ecore</h3>
</div>
</div>
</div>
<p>在上<a class="link" href="CompleteOCLTutorial.html#CompleteOCLTutorial-EcoreComplements" title="示例Ecore的完整OCL补充">一节中，</a>我们描述了额外的完整OCL验证约束，以检测派生属性的样本Ecore诊断不足的问题。我们现在将这些约束应用于测试文件。
				</p>
<p>选择<span class="bold"><strong>EcoreTestFile.ecore</strong></span>并使用右键菜单<span class="bold"><strong>打开</strong></span> <span class="bold"><strong>With With</strong></span> <span class="bold"><strong>&gt; Sample Ecore Model Editor</strong></span> 。这可能是使用左键双击的默认设置，但如果使用OCLinEcore编辑器打开，则所需的验证将不起作用（在Juno中）。
				</p>
<p>现在右键单击Sample Ecore Editor窗格，如<a class="link" href="CompleteOCLTutorial.html#LoadCompleteOCLResource" title="OCL-&gt;加载文档菜单操作">OCL-&gt; Load Document Menu Action中所述，</a>并加载<span class="bold"><strong>ExtraEcoreValidation.ocl</strong></span> 。编辑器树中显示了一个额外的资源。
				</p>
<p>选择一个模型元素（如<span class="bold"><strong>Bad</strong></span>包）并使用右键菜单调用<span class="bold"><strong>Validate</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-validation.png"></div>
<p>
				
</p>
<p>这显示错误。根据约束的评估顺序，您可能还会看到一个或两个警告。您应该使用“ <a class="link" href="ValidityView.html" title="有效性观点（Luna中的新内容）">有效性视图”</a>查看所有故障。
				</p>
<p>如果我们现在使用OCLinEcore编辑器打开<span class="bold"><strong>EcoreTestFile.ecore</strong></span> ，我们可以看到<span class="bold"><strong>瞬态</strong></span> <span class="bold"><strong>和易失性</strong></span>关键字确实缺失。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-ecore-oclinecore.png"></div>
<p>
				
</p>
</div>
<div class="section" title="编辑完整的OCL">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-Updating"></a>编辑完整的OCL</h3>
</div>
</div>
</div>
<p>您可以编辑完整OCL以试验备用约束或消息。</p>
<p>然而，完整的OCL补充了元模型，EMF不支持元模型的实时修改。因此，必须重新启动Sample Ecore Editor并重新加载修改后的Complete OCL文档才能利用这些更改。</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>在将来的版本中可能会出现这种解决方案。</p>
</blockquote>
</div>
<p></p>
</div>
<div class="section" title="示例UML的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-UMLComplements"></a>示例UML的完整OCL补充</h3>
</div>
</div>
</div>
<p><a class="link" href="CompleteOCLTutorial.html#CompleteOCLTutorial-EcoreValidation" title="使用额外的完整OCL验证Ecore">使用额外的完整OCL验证Ecore中</a>描述的Sample Ecore Editor验证的扩展适用于EMF工具生成的任何树编辑器。
				</p>
<p><span class="bold"><strong>ExtraUMLValidation.ocl</strong></span>文件提供了一个非常简单的样式检查，类名以大写字母开头。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-uml-content.png"></div>
<p>
				
</p>
<p>导入UML元模型并为Class分类器指定不变量，该分类器完全限定以避免需要周围的包上下文声明。</p>
<p>您可以使用UML模型编辑器打开<span class="bold"><strong>PapyrusTestFile.uml</strong></span> ，加载<span class="bold"><strong>ExtraUMLValidation.ocl</strong></span> ，选择<span class="bold"><strong>模型</strong></span> ，然后以与Ecore示例相同的方式<span class="bold"><strong>验证</strong></span> 。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-uml-validation.png"></div>
<p>
				
</p>
<p>遗憾的是，Papyrus UML编辑器不使用EValidator框架，因此将完整的OCL文档加载到Papyrus中无法增强验证功能。要使用其他完整OCL功能，您可以在UML模型编辑器中加载和验证，然后启动Papyrus编辑器，然后在图表元素上显示问题标记。或者，您可以与Papyrus同时使用<a class="link" href="ValidityView.html" title="有效性观点（Luna中的新内容）">Validity View</a> 。
				</p>
</div>
<div class="section" title="示例Xtext的完整OCL补充">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLTutorial-XtextComplements"></a>示例Xtext的完整OCL补充</h3>
</div>
</div>
</div>
<p>Xtext编辑器使用EValidator，因此可以将完整的OCL文档加载到Xtext编辑器中，包括Xtext本身，以提供增强的验证。</p>
<p><span class="bold"><strong>ExtraXtextValidation.ocl</strong></span>文件提供了一些演示样式检查。
				</p>
<p>
					
</p>
<div class="mediaobject">
<img src="images/4300-extra-xtext-content.png"></div>
<p>
				
</p>
<p>导入Xtext根包并在<span class="bold"><strong>xtext</strong></span>包的包声明上下文中，为四个类提供不变量。这些都是约束如何使用Xtext模型的示例。不建议用户将所有这些约束用于真正的语法。
				</p>
<div class="section" title="NoAnonymousImports">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="NoAnonymousImports"></a> NoAnonymousImports</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context ReferencemMetamodel<br>inv NoAnonymousImports：别名&lt;&gt; null<br>

</code>
</p>
</div>
<p></p>
<p>此不变量诊断是否有任何import语句省略<code class="code">as xxxx</code>模型名称。
					</p>
</div>
<div class="section" title="NoActions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="NoActions"></a> NoActions</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">上下文行动<br>inv NoActions：false<br>

</code>
</p>
</div>
<p></p>
<p>只要使用<code class="code">{xxx}</code>操作语句，此不变量就会诊断出来。
					</p>
</div>
<div class="section" title="CamelCaseName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="CamelCaseName"></a> CamelCaseName</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context ParserRule<br>inv CamelCaseName：name.matches（'[AZ] [A-Za-z] *'）<br>

</code>
</p>
</div>
<p></p>
<p>此不变量验证解析器规则的名称以大写字母开头并仅使用字母。</p>
</div>
<div class="section" title="UpperName">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="UpperName"></a> UpperName</h4>
</div>
</div>
</div>
<div class="literallayout">
<p>
<code class="code">context xtext :: TerminalRule<br>inv UpperName：name = name.toUpperCase（）<br>

</code>
</p>
</div>
<p></p>
<p>此不变量验证终端规则的名称是否为大写。</p>
<p>您可以使用Xtext Editor打开<span class="bold"><strong>XtextTestFile.xtext</strong></span> ，加载<span class="bold"><strong>ExtraXtextValidation.ocl</strong></span> ，然后以与Ecore示例相同的方式<span class="bold"><strong>验证</strong></span> 。
					</p>
<p>其他验证在编辑器中显示为警告标记。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/4300-extra-xtext-validation.png"></div>
<p>
					
</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>不幸的是，Xtext对于其Concrete Syntax树没有一个很好的toString（）方法，所以错误元素的描述有点不优雅。</p>
</blockquote>
</div>
<p></p>
<p>您可以编辑Xtext测试文件以删除import语句中的“as ecore”，并查看其他完整OCL约束是否有助于编辑器的持续功能。</p>
</div>
</div>
<div class="section" title="完整的OCL编辑器">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="CompleteOCLEditor"></a>完整的OCL编辑器</h3>
</div>
</div>
</div>
<p>将为现有或新的* .ocl文件自动调用Complete OCL编辑器。您可以使用<span class="bold"><strong>New-&gt; File</strong></span>或部分内容文件使用<span class="bold"><strong>New-&gt; Other ...</strong></span>后跟<span class="bold"><strong>OCL</strong></span>和<span class="bold"><strong>Complete OCL File</strong></span>创建一个空文件。该编辑器基于Xtext，因此您可以在许多其他Eclipse编辑器中找到大多数工具。
				</p>
</div>
<div class="section" title="皇家和忠诚的例子">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="RoyalandLoyalExample"></a>皇家和忠诚的例子</h3>
</div>
</div>
</div>
<p>皇家和忠诚的例子首先由Jos Warmer和Anneke Kleppe在<span class="emphasis"><em>“对象约束语言：让你的模型为MDA做好准备”中提供</em></span> ，随后在许多教程中使用。该示例提供了完整OCL和基本OCL的实质示例。通过调用<span class="bold"><strong>New-&gt; Example ...-&gt; OCL（Object Constraint Language）插件</strong></span>可以获得这些模型。
				</p>
</div>
<div class="section" title="摘要">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Summary2"></a>摘要</h3>
</div>
</div>
</div>
<p>为了说明如何使用Complete OCL，我们有</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>检查了完整的OCL语言</p>
</li>
<li class="listitem">
<p>检查约束以纠正导出特征的Ecore验证不充分</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强Ecore模型的验证</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强UML模型的验证</p>
</li>
<li class="listitem">
<p>加载完整的OCL约束以增强Xtext语法的验证</p>
</li>
</ul>
</div>
</div>
</div>
</body>
</html><html id="3404.tools.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8"></meta>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
<meta name="generator" content="Asciidoctor 1.5.6.1"></meta>
<title>VIATRA中的查询开发工具</title>
<link rel="stylesheet" href="asset?aid=0"></link>
<link rel="stylesheet" href="./asciidoctor.css"></link>
</head>
<body class="article" dir="ltr">
<div id="header">
<h1>VIATRA中的查询开发工具</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#query-tests">1。查询测试框架</a>
<ul class="sectlevel2">
<li><a href="#_basic_concepts">1.1。基本概念</a></li>
<li><a href="#_incremental_scenarios">1.2。增量方案</a></li>
<li><a href="#_supporting_plain_java_objects_in_substitutions">1.3。在替换中支持普通Java对象</a></li>
<li><a href="#_specifying_custom_serialization_for_emf_objects">1.4。为EMF对象指定自定义序列化</a></li>
</ul>
</li>
<li><a href="#query-optimization">2。调试和分析图模式</a>
<ul class="sectlevel2">
<li><a href="#rete-visualizer">2.1。Rete Visualizer</a></li>
<li><a href="#local-search-debugger">2.2。本地搜索调试器</a></li>
<li><a href="#query-profiling">2.3。Rete网络的内存优化</a></li>
</ul>
</li>
<li><a href="#viatra-maven-plugin">3。Maven整合</a>
<ul class="sectlevel2">
<li><a href="#_repository">3.1。知识库</a></li>
<li><a href="#_viatra_maven_plugin">3.2。 viatra  -  Maven的插件</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query-tests"><a class="link" href="#query-tests">1。查询测试框架</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>有一个专门用于测试Viatra查询的测试框架。它是在考虑以下用例的情况下开发的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试Viatra查询引擎本身</p>
</li>
<li>
<p>为用户提供回归测试框架以测试模式</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_basic_concepts"><a class="link" href="#_basic_concepts">1.1。基本概念</a></h3>
<div class="paragraph">
<p>该框架允许用户使用不同的引擎实现或预定义的结果集（所谓的快照）来比较模式执行的结果。它定义了一个方便的<a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/query/tests/org.eclipse.viatra.query.testing.core/src/org/eclipse/viatra/query/testing/core/api/ViatraQueryTest.xtend">内部DSL</a>来定义测试用例。测试用例的描述包括以下部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试什么</p>
<div class="ulist">
<ul>
<li>
<p>生成的查询规范</p>
</li>
<li>
<p>模式组</p>
</li>
<li>
<p>通用模式组（可能直接从.vql文件解析）</p>
</li>
</ul>
</div>
</li>
<li>
<p>输入模型</p>
</li>
<li>
<p>执行方法</p>
<div class="ulist">
<ul>
<li>
<p>通过Rete或LocalSearch引擎</p>
</li>
<li>
<p>来自快照</p>
</li>
</ul>
</div>
</li>
<li>
<p>假设（可选）</p>
<div class="ulist">
<ul>
<li>
<p>检查所有给定的执行方法是否支持给定的模式（即测试用例是否适用）</p>
</li>
</ul>
</div>
</li>
<li>
<p>断言</p>
<div class="ulist">
<ul>
<li>
<p>检查所有执行方法提供的结果是否对每个模式都相同。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">例</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">ViatraQueryTest。 //入口点测试（SomeQuerySpecification :: instance）。和（AnotherQuerySpecification）。//在（modelURI）上测试的模式。//实例模型（可选;快照模型引用输入模型）和（快照）。//将快照模型存储的准备结果与（新的ReteBackendFactory）进行比较。//比较Rete引擎assumeInputs产生的结果。 //检查给定的快照和后端工厂是否对被测模式有效。引发JUnit假设错误，否则assertEquals //计算每个给定快照和模式执行的差异。如果出现差异，则抛出JUnit断言失败</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_incremental_scenarios"><a class="link" href="#_incremental_scenarios">1.2。增量方案</a></h3>
<div class="paragraph">
<p>该框架支持测试场景，在使用modify方法修改模型后可以再次检查结果：</p>
</div>
<div class="listingblock">
<div class="title">在模型操作后重新检查</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">ViatraQueryTest。 //入口点测试（SomeQuerySpecification :: instance）。和（AnotherQuerySpecification）。//在（modelURI）上测试的模式。//实例模型（可选;快照模型引用输入模型）和（快照）。//将快照模型存储的准备结果与（新的ReteBackendFactory）进行比较。//比较Rete引擎assertEqualsThen产生的结果。 // assertEqualsThen不返回void modify（Type，[name ==“John”]，[age = 35]）。//给定操作在给定条件的每个实例上执行，给定条件的计算结果为true。与（snapshotAfterModification）。//任何修改操作都会导致以前加载的所有快照失效。的assertEquals</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_supporting_plain_java_objects_in_substitutions"><a class="link" href="#_supporting_plain_java_objects_in_substitutions">1.3。在替换中支持普通Java对象</a></h3>
<div class="paragraph">
<p>在某些情况下，需要将纯Java对象添加到Query Snapshot模型中。但是，这些元素的序列化和比较可能与使用测试框架的域相关。在这种情况下，框架允许用户通过JavaObjectAccess元素定义应该如何处理某些普通Java类型。这些元素使框架能够序列化，反序列化和比较某些类型的POJO。以下示例演示了如何将这些Access对象注册到框架中。</p>
</div>
<div class="paragraph">
<p>在此示例中，元模型包含“CustomInteger”类型属性。'CustomInteger'是一种扩展'Integer'的java类型。以下片段显示了“访问”类型定义的方式。</p>
</div>
<div class="listingblock">
<div class="title">访问自定义属性</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">公共类CustomIntegerAccess扩展JavaObjectAccess {public CustomIntegerAccess（）{super（CustomInteger.class）; } //基于CustomInteger对象创建Substitution对象@Override public SerializedJavaObjectSubstitution toSubstitution（Object value）{SerializedJavaObjectSubstitution sub = SnapshotFactory.eINSTANCE.createSerializedJavaObjectSubstitution（）; if（valueofof CustomInteger）{sub.setType（getType（）。getName（））; sub.setValue（（（CustomInteger）value）.integerValue（）+“”）; } return sub; //计算哈希码（等式检查所需）@Override public int calculateHash（SerializedJavaObjectSubstitution substitution）{return Objects.hashCode（Integer.parseInt（substitution.getValue（）））; } //检查两个替换是否相等（假设它们各自定义'CustomInteger'）@Override public boolean equals（SerializedJavaObjectSubstitution a，SerializedJavaObjectSubstitution b）{if（a.getType（）。equals（getType（）。getName（）） &amp;&amp; b.getType（）。equals（getType（）。getName（）））{int aVal = Integer.parseInt（a.getValue（））; int bVal = Integer.parseInt（b.getValue（））;返回aVal == bVal; } return false; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">使用CustomIntegerAccess</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">...Map &lt;String，JavaObjectAccess&gt; objectAccess = Maps.newHashMap（）; map.put（CustomInteger.class.getName（），new CustomIntegerAccess（））; ViatraQueryTest.test（specs，new SnapshotHelper（objectAccess））。on（new EMFScope（[MODEL]））。with（[SNAPSHOT]）。assertEquals（）; ...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specifying_custom_serialization_for_emf_objects"><a class="link" href="#_specifying_custom_serialization_for_emf_objects">1.4。为EMF对象指定自定义序列化</a></h3>
<div class="paragraph">
<p>在快照生成器的默认配置中，任何EMF对象都将转换为通用EMF替换。但是，在某些情况下，用户可能希望指定（列表）自定义函数，这些函数定义应如何在快照中表示EMF对象。</p>
</div>
<div class="paragraph">
<p>该框架允许以期望以用户定义的方式处理的类型（EClass）索引的映射的形式注册这样的自定义函数，其中相应的映射值存储替换函数。期望这些函数接收EObject并返回String。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何从CPS元模型为ApplicationType类指定简单的自定义函数，以及如何设置相应的测试用例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">customMap.put（CyberPhysicalSystemPackage。文字。APPLICATION_TYPE，[at | （作为ApplicationType）.identifier]）ViatraQueryTest.test（ApplicationTypesQuerySpecification.instance，snapshotHelper（customMap））。on（new EMFScope（[MODEL]））。with（[SNAPSHOT]）。somesertEquals</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_coverage_analysis_and_reporting"><a class="link" href="#_coverage_analysis_and_reporting">1.4.1。覆盖率分析和报告</a></h4>
<div class="paragraph">
<p>从VIATRA 1.6开始（参见<a href="http://bugs.eclipse.org/514628">错误514628</a> ），您可以将分析器添加到测量对象，该对象可以测量查询执行的各种指标。例如，您可以在测试期间分析覆盖范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">static var CoverageAnalyzer coverage; @BeforeClass static def void before（）{coverage = new CoverageAnalyzer（）; } @Test def void testApplicationTypes（）{ViatraQueryTest.test（ApplicationTypesQuerySpecification.instance）.analyzeWith（coverage）//分析coverage .with（new ReteBackendFactory）//第一组匹配应来自使用Rete后端的查询评估.with（快照）//第二组匹配应来自快照.assertEquals //断言匹配集相等}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在运行测试之后，您可以使用<code>CoverageAnalyzer#getCoverage()</code>获取分析的覆盖率，或使用<code>CoverageReporter</code>报告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">@AfterClass static def void after（）{CoverageReporter.reportHtml（coverage，new File（“coverage.html”））}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关完整示例，请参阅<a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/frameworktests/org.eclipse.viatra.examples.cps.tests/src/org/eclipse/viatra/examples/cps/tests/BasicCpsTest.xtend">CPS框架测试</a> 。</p>
</div>
<div class="sect4">
<h5 id="_interpreting_the_coverage_report"><a class="link" href="#_interpreting_the_coverage_report">1.4.1.1。解读覆盖率报告</a></h5>
<div class="paragraph">
<p>覆盖率报告如下所示： <a href="https://hudson.eclipse.org/viatra/job/viatra-framework-tests/lastSuccessfulBuild/artifact/cps/frameworktests/org.eclipse.viatra.examples.cps.tests/BasicCpsTest_coverage.html">CPS框架测试覆盖率报告</a></p>
</div>
<div class="paragraph">
<p>元素（模式，模式体或约束）可以是：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">覆盖</dt>
<dd>
<p>属于它的Rete节点在查询执行期间至少有一个匹配</p>
</dd>
<dt class="hdlist1">裸露</dt>
<dd>
<p>属于它的Rete节点在任何查询执行期间都没有匹配</p>
</dd>
<dt class="hdlist1">没有代表</dt>
<dd>
<p>它没有在Rete网络中表示，这通常意味着优化器删除了它，因为它是多余的。</p>
</dd>
<dt class="hdlist1">没有错误代表</dt>
<dd>
<p>它应该在Rete网络中表示，但它被删除的原因不明;如果您遇到此问题，请报告问题，包括您的查询文件和覆盖率报告。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请注意，虽然覆盖了每个约束，但可以揭示模式主体，因为属于约束的Rete节点在<em>不同的</em>查询执行期间可能具有匹配，这意味着不会立即满足约束。</p>
</div>
<div class="paragraph">
<p>模式的聚合覆盖度量以下列方式计算：覆盖元素的数量/表示的（覆盖/未覆盖）元素的数量</p>
</div>
<div class="paragraph">
<p>1.6中的已知限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>只有Rete后端支持覆盖率测量</p>
</li>
<li>
<p>由于Rete评估的不确定性，结果可能是不确定的</p>
</li>
<li>
<p>约束以其内部PQuery表示形式显示（请参阅<a href="http://bugs.eclipse.org/515723" class="bare">http://bugs.eclipse.org/515723</a> ）</p>
</li>
</ul>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query-optimization"><a class="link" href="#query-optimization">2。调试和分析图模式</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="rete-visualizer"><a class="link" href="#rete-visualizer">2.1。Rete Visualizer</a></h3>
<div class="ulist">
<div class="title">安装</div>
<ul>
<li>
<p>从VIATRA更新站点安装<strong>查询可视化</strong>功能组。</p>
<div class="ulist">
<ul>
<li>
<p>在VIATRA 1.6之前，此功能依赖于GEF4 Zest的预发布版本; GEF更新站点提供的版本无效。使用VIATRA更新站点中的版本。</p>
</li>
<li>
<p>自从使用VIATRA 1.6 GEF 5</p>
<div class="ulist">
<ul>
<li>
<p>需要JavaFX支持</p>
</li>
<li>
<p>e（fx）clipse运行时和GEF5是必需的。它们都可以从氧气释放列车中获得。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">用法</div>
<ul>
<li>
<p>转到<strong>窗口</strong> | <strong>显示视图</strong> | <strong>其他...，</strong>然后选择<strong>Rete算法展示台</strong> 。</p>
</li>
<li>
<p>在“ <em>查询结果”</em>视图中加载实例模型和模式。</p>
</li>
<li>
<p>单击模式名称以使其可视化。</p>
</li>
<li>
<p>要更改可视化的Rete网络，请卸载模式并使用绿色开始按钮加载。</p>
</li>
<li>
<p>您可以通过单击向下指向的三角形并转到“ <strong>布局”</strong>菜单来更改<strong>布局</strong> 。
<span class="image"><img src="./images/tools/rete_visualizer.png" alt="rete visualizer"></span></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="local-search-debugger"><a class="link" href="#local-search-debugger">2.2。本地搜索调试器</a></h3>
<div class="ulist">
<div class="title">安装</div>
<ul>
<li>
<p>“查询可视化”功能组中提供了“本地搜索调试器工具”。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">用法</div>
<ul>
<li>
<p>在Eclipse中打开Local Search Debugger视图</p>
</li>
<li>
<p>在Query Explorer中加载模型和查询定义</p>
</li>
<li>
<p>在查询资源管理器中选择查询</p>
</li>
<li>
<p>通过在Local Search Debugger视图的工具栏上调用该命令来运行本地搜索调试器。该命令从查询资源管理器中读取选择并启动匹配：初始化并显示计划。</p>
</li>
<li>
<p>使用视图工具栏上的指定命令步进或运行匹配。也可以在需要时添加断点。</p>
</li>
<li>
<p>显示的搜索计划的状态显示执行的状态，而已经找到的匹配和当前的变量替换可以在视图提供的Zest查看器中看到。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="query-profiling"><a class="link" href="#query-profiling">2.3。Rete网络的内存优化</a></h3>
<div class="paragraph">
<p>如果您有大量模式，并且发现增量查询评估看起来非常慢或使用的内存比预期的多，那么在发生问题时采用实例模型并独立评估每个模式的占用空间是很有用的。当然，调用其他模式的模式也会包含这些模式的足迹，但仍然可以看到差异。</p>
</div>
<div class="paragraph">
<p>我们提供了一个简单的JUnit测试，用于使用VIATRA Query： <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/query/tests/org.eclipse.viatra.query.testing.core/src/org/eclipse/viatra/query/testing/core/QueryPerformanceTest.xtend">QueryPerformanceTest.xtend</a>的测试框架轻松执行此热点评估。阅读JavaDoc以获取更多详细信息，同时可以在此处找到有关其用法的示例，以了解我们的UML代理查询： <a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/integration/tests/org.eclipse.viatra.integration.uml.test/src/org/eclipse/viatra/integration/uml/test/UMLSurrogateQueryPerformanceTest.java">UMLSurrogateQueryPerformanceTest.java</a></p>
</div>
<div class="paragraph">
<p>请注意，如果您运行测试并使用分析器（例如<a href="https://www.yourkit.com/java/profiler/index.jsp">YourKit</a>或<a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control）</a> ，则可以通过查看堆大小图，选择超出的部分并查看当前跟踪以查看正在查询的查询来轻松识别有问题的模式。建成。</p>
</div>
<div style="page-break-after:always"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viatra-maven-plugin"><a class="link" href="#viatra-maven-plugin">3。Maven整合</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>VIATRA Query支持通过从vql文件生成模式匹配器代码，在基于Maven的构建中构建VIATRA Query项目。</p>
</div>
<div class="ulist">
<div class="title">要求</div>
<ul>
<li>
<p>maven编译器要求Maven 3.1正常运行。在某些情况下，Maven 3.0.5就足够了，但是这个版本存在一些问题。Maven 3.0之前的版本根本不起作用。有关详细信息，请参见<a href="http://bugs.eclipse.org/478437" class="bare">http://bugs.eclipse.org/478437</a> 。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">已知限制</div>
<ul>
<li>
<p>不支持集成组件的代码生成（例如，验证框架，派生特性）。见<a href="http://bugs.eclipse.org/434794" class="bare">http://bugs.eclipse.org/434794</a></p>
</li>
<li>
<p>VIATRA Query项目不能从Maven Central获得，只能从repo.eclipse.org获得。</p>
</li>
<li>
<p>没有maven原型支持：无法自动生成无Eclipse项目，与VIATRA Query一起使用。但是，可以使用现有编译器构建手动创建的项目。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_repository"><a class="link" href="#_repository">3.1。知识库</a></h3>
<div class="paragraph">
<p>可以从Eclipse maven存储库获得Maven组件，其中包含以下URL：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发布： <a href="https://repo.eclipse.org/content/repositories/viatra-releases/" class="bare">https</a> ： <a href="https://repo.eclipse.org/content/repositories/viatra-releases/" class="bare">//repo.eclipse.org/content/repositories/viatra-releases/</a> （无限期保留）</p>
</li>
<li>
<p>仅限快照： <a href="http://repo.eclipse.org/content/repositories/viatra-snapshots/" class="bare">http</a> ： <a href="http://repo.eclipse.org/content/repositories/viatra-snapshots/" class="bare">//repo.eclipse.org/content/repositories/viatra-snapshots/</a> （30天后清除）*组合存储库： <a href="https://repo.eclipse.org/content/groups/viatra/" class="bare">https</a> ： <a href="https://repo.eclipse.org/content/groups/viatra/" class="bare">//repo.eclipse.org/content/groups/viatra/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下maven项目可供使用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">org.eclipse.viatra：viatra查询运行时</dt>
<dd>
<p>VIATRA查询运行时的依赖项，不支持通用API</p>
</dd>
<dt class="hdlist1">org.eclipse.viatra：viatra查询语言</dt>
<dd>
<p>VIATRA查询的依赖项，支持通用API（需要更多依赖项 - 仅在需要时使用）</p>
</dd>
<dt class="hdlist1">org.eclipse.viatra：viatra  -  Maven的插件</dt>
<dd>
<p>不应将Maven代码生成器添加到编译类路径中</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>要使用VIATRA Query功能，请将存储库和所需的依赖项添加到Maven项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;！ - 在项目的pom.xml文件中使用它 - &gt; &lt;properties&gt; &lt;！ - 最好将VIATRA框架版本指定为属性（例如在父pom中）并在整个构建过程中使用它 - &gt; &lt;viatra.version&gt; 1.2.1 &lt;/viatra.version&gt; &lt;/ properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra-query-runtime &lt;/ artifactId &gt; &lt;version&gt; $ {viatra.version} &lt;/ version&gt; &lt;/ dependency&gt; &lt;！ - 需要更多依赖项 - 仅在需要时使用 - &gt; &lt;dependency&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt; artifactId&gt; viatra-query-language &lt;/ artifactId&gt; &lt;version&gt; $ {viatra.version} &lt;/ version&gt; &lt;/ dependency&gt; &lt;/ dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt; viatra &lt;/ id&gt; &lt;url&gt; https ：//repo.eclipse.org/content/groups/viatra2/ &lt;/ url&gt; &lt;/ repository&gt; &lt;/ repositories&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_viatra_maven_plugin"><a class="link" href="#_viatra_maven_plugin">3.2。 viatra  -  Maven的插件</a></h3>
<div class="paragraph">
<p>maven插件需要来自使用过的EMF包的信息，另外EMF包也应该能够加载。因此，重要的是添加对EPackages和Genmodel的引用以及相应的依赖项。</p>
</div>
<div class="paragraph">
<p>从1.5开始，可以使用项目依赖项而无需明确声明它们。当您使用的元模型不可用作Maven工件时，这会有所帮助。</p>
</div>
<div class="ulist">
<div class="title">补充说明</div>
<ul>
<li>
<p>包引用通过.genmodel文件的文件路径（通常通过platform：/ resource URI）或类路径上可用的Ecore Package类的完全限定名称添加。请注意，如果类与查询文件位于同一插件中，则基于类的引用将不起作用，因为编译将在稍后的构建阶段发生，而不是生成。还要注意不要在一个反应器中混合基于类的包和基于genmodel的机制，因为它可能导致奇怪的错误。</p>
</li>
<li>
<p>导入的每个包都必须列在元模型部分中。不需要列出明确列出的包可传递使用的包。</p>
</li>
<li>
<p>显式依赖声明是可传递的，因此您无需在所有POM.XML文件中指定所有依赖项。请注意，在某些情况下，如果您的genmodel需要的版本高于viatra-maven-plugin提供的版本，则需要在特定版本（例如emf.core）中添加额外的依赖项。这样，您可以重新定义生成器使用的EMF版本。</p>
</li>
<li>
<p>如果Maven项目中的模式文件从其所依赖的另一个项目导入模式，请确保包含导入模式的文件包含在依赖项的Maven工件中。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">示例POM.XML（基于<a href="http://git.eclipse.org/c/viatra/org.eclipse.viatra.git/tree/query/tests/org.eclipse.viatra.query.runtime.cps.tests/pom.xml">CPS示例</a> ）</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt; viatra &lt;/ id&gt; &lt;url&gt; https://repo.eclipse.org/content/groups/viatra/ &lt;/ url&gt; &lt;/ pluginRepository&gt; &lt;/ pluginRepositories&gt; &lt;build&gt; &lt;plugins &gt; &lt;！ - 使用maven-clean-plugin删除以前生成的代码 - &gt; &lt;plugin&gt; &lt;groupId&gt; org.apache.maven.plugins &lt;/ groupId&gt; &lt;artifactId&gt; maven-clean-plugin &lt;/ artifactId&gt; &lt;version &gt; 2.5 &lt;/ version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt; clean &lt;/ phase&gt; &lt;goals&gt; &lt;goal&gt; clean &lt;/ goal&gt; &lt;/ goals&gt; &lt;configuration&gt; &lt;filesets&gt; &lt;fileset&gt; &lt;！ - 生成的代码文件夹 - &gt; &lt;directory&gt; src-gen &lt;/ directory&gt; &lt;includes&gt; &lt;include&gt; ** / * &lt;/ include&gt; &lt;/ includes&gt; &lt;/ fileset&gt; &lt;/ filesets&gt; &lt;/ configuration&gt; &lt;/ execution&gt; &lt;/执行&gt; &lt;/ plugin&gt; &lt;！ - 设置生成器 - &gt; &lt;插件&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra-maven-plugin &lt;/ artifactId&gt; &lt;version&gt; $ {viatra。 version} &lt;/ version&gt; &lt;！ - 将执行绑定到代码生成生命周期阶段 - &gt; &lt;执行&gt; &lt;执行&gt; &lt;目标&gt; &lt;目标&gt;生成&lt;/ goal&gt; &lt;/ goals&gt; &lt;/ execution&gt; &lt;/ executions&gt; &lt;结构&gt; &lt;！ - 输出目录 - 必需 - &gt; &lt;outputDirectory&gt; src-gen &lt;/ outputDirectory&gt; &lt;metamodels&gt; &lt;metamodel&gt; &lt;！ - 根据元模型定义的位置选择以下选项之一 - &gt; &lt;！ -  - （a）EMF EPackage的Java类 - 如果生成的EMF代码在类路径中，则使用此类 - &gt; &lt;packageClass&gt; org.eclipse.viatra.examples.cps.cyberPhysicalSystem。CyberPhysicalSystemPackage &lt;/ packageClass&gt; &lt;！ - （b）用于生成EMF模型类的genmodel文件 - 如果EMF模型位于同一项目中，请使用此文件 - &gt; &lt;！ -  &lt;genmodelUri&gt; model / model.genmodel &lt;/ genmodelUri &gt;  - &gt; &lt;/ metamodel&gt; &lt;/ metamodels&gt; &lt;！ - 从1.5开始，您可以使用项目依赖项而不是特定的Maven依赖项 - 可选 - &gt; &lt;useProjectDependencies&gt; true &lt;/ useProjectDependencies&gt; &lt;/ configuration&gt; &lt;dependencies&gt; &lt;！ -  cps域项目（包含生成的EPackage）所需的依赖关系，除非您设置useProjectDependencies  - &gt; &lt;dependency&gt; &lt;groupId&gt; org.eclipse.viatra.examples.cps &lt;/ groupId&gt; &lt;artifactId&gt; org。 eclipse.viatra.examples.cps.model &lt;/ artifactId&gt; &lt;version&gt; 1.2.0 &lt;/ version&gt; &lt;/ dependency&gt; &lt;/ dependencies&gt; &lt;/ plugin&gt; &lt;/ plugins&gt; &lt;/ build&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_language_extension_support"><a class="link" href="#_language_extension_support">3.2.1。语言扩展支持</a></h4>
<div class="paragraph">
<p>从VIATRA 2.0开始，viatra-maven编译器可以理解自定义注释并验证它们。为了支持这些功能，必须将新的<code>viatra-query-language-extensions</code> maven模块添加到项目的依赖项中。</p>
</div>
<div class="listingblock">
<div class="title">自定义注释支持</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugins&gt; &lt;！ - 使用maven-clean-plugin删除以前生成的代码 - &gt; &lt;！ - 设置生成器 - &gt; &lt;plugin&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra -maven-plugin &lt;/ artifactId&gt; &lt;version&gt; $ {viatra.version} &lt;/ version&gt; &lt;configuration&gt; ...&lt;/ configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra-query-language-extensions &lt;/ artifactId&gt; &lt;version&gt; $ {viatra.version} &lt;/ version&gt; &lt; / dependency&gt; &lt;/ dependencies&gt; &lt;/ plugin&gt; &lt;/ plugins&gt; &lt;/ build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">绑定到注释的代码生成器功能，例如在验证框架或基于查询的派生功能支持的情况下，在Maven编译器中仍然不可用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting"><a class="link" href="#_troubleshooting">3.2.2。故障排除</a></h4>
<div class="paragraph">
<div class="title">循环连接</div>
<p>在包含多个模式定义文件的项目中，您可能会收到如下错误消息：</p>
</div>
<div class="paragraph">
<p><code>错误：检测到循环链接：PatternCall.patternRef→PatternCall.patternRef</code></p>
</div>
<div class="paragraph">
<p>这是我们正在努力解决的已知问题;有关潜在问题的详细信息，请参阅<a href="http://bugs.eclipse.org/464120" class="bare">http://bugs.eclipse.org/464120</a>和<a href="http://bugs.eclipse.org/480652" class="bare">http://bugs.eclipse.org/480652</a> 。</p>
</div>
<div class="paragraph">
<p>作为解决方法，我们建议明确定义所有参数的类型，因为这可以避免此问题。如果这还不够，则必须确保按调用顺序处理vql文件：所有模式在模式调用中使用之前都要进行处理。这可以通过在vql文件之间移动模式，或通过重命名.vql文件来实现，以便从其他文件调用模式的文件的字典名称应该比引用的文件大。</p>
</div>
<div class="paragraph">
<p>例如，假设您有一个包含两个查询的查询文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">// util.vql模式utilityPattern（...）{find anotherUtilityPattern（...）;模式anotherUtilityPattern（...）{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环链接发生在<code>utilityPattern</code>调用<code>anotherUtilityPattern</code> 。搜索<code>utilityPattern</code>调用者！我们假设它在这个文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">// logic.vql模式myPattern（...）{find utilityPattern（...）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你必须重命名<code>util.vql</code>到<code>a_util.vql</code>和<code>logic.vql</code>到<code>b_logic.vql</code> ，所以前者是前后期处理。</p>
</div>
<div class="paragraph">
<div class="title">模棱两可的类型</div>
<p>如果在验证期间出现类型错误，例如<code>ERROR:foo cannot be resolved.</code>或<code>ERROR:Ambiguous variable type defintions: [Foo, Bar], type cannot be selected</code>虽然查询文件在Eclipse中有效，但<code>ERROR:Ambiguous variable type defintions: [Foo, Bar], type cannot be selected</code> ，请使用文本编辑器打开ecore / genmodel文件中的交叉引用。如果它们的URI是基于工作空间的，即它们以<code>platform:/resource</code>开头，则必须通过在viatra-maven-plugin配置中包含URI映射（从1.6开始）将这些URI映射到绝对<code>file:</code> URI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-vql" data-lang="vql">&lt;plugin&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra-maven-plugin &lt;/ artifactId&gt; &lt;configuration&gt; ...&lt;uriMappings&gt; &lt;uriMapping&gt; &lt;sourceUri&gt; platform：/resource/school/model/school.ecore &lt;/ sourceUri&gt; &lt;targetUri&gt; file：/ $ {project.basedir} /school/model/school.ecore &lt;/ targetUri&gt; &lt; / uriMapping&gt; &lt;uriMapping&gt; &lt;sourceUri&gt; platform：/resource/school/model/school.genmodel &lt;/ sourceUri&gt; &lt;targetUri&gt; file：/ $ {project.basedir} /school/model/school.genmodel &lt;/ targetUri&gt; &lt; / uriMapping&gt; &lt;/ uriMappings&gt; &lt;/ configuration&gt; &lt;/ plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">一个类型的多个定义</div>
<p>如果你得到错误<code>ERROR:Variable foo has a type Foo which has multiple definitions: 'file://C:\project\model/../../anotherProject/model/usedMetamodel.ecore' — 'file://C:\project\../anotherProject/model/usedMetamodel.ecore'</code>确保viatra-maven-plugin配置中的genmodelUri <strong>正好</strong>是与.genmodel文件中的URI相同，例如，如果您的<code>metamodel.ecore</code>位于<code>model</code>子文件夹中，则这将是具有正确相对URI的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt; &lt;groupId&gt; org.eclipse.viatra &lt;/ groupId&gt; &lt;artifactId&gt; viatra-maven-plugin &lt;/ artifactId&gt; &lt;configuration&gt; &lt;metamodels&gt; &lt;metamodel&gt; &lt;genmodelUri&gt; model / ../../ anotherProject / model / usedMetamodel.genmodel &lt;/ genmodelUri&gt; &lt;/ metamodel&gt; &lt;/ metamodels&gt; &lt;/ configuration&gt; &lt;/ plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果使用URI映射<strong>后</strong> ，URI应该相同。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html><html id="3332.Sequence Diagrams.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>序列图</title>
		<link type="text/css" rel="stylesheet" href="../../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SpecifyingSequenceDiagramEditors">指定序列图编辑器</h1>
		<ol class="toc" style="list-style:disc">
			<li>
				<a href="#SpecifyingSequenceDiagramEditors">指定序列图编辑器</a>
				<ol style="list-style:disc">
					<li>
						<a href="#introduction">介绍</a>
					</li>
					<li>
						<a href="#semantics">序列图语义</a>
					</li>
					<li>
						<a href="#restrictions">限制和限制</a>
					</li>
					<li>
						<a href="#prerequisites">先决条件</a>
						<ol style="list-style:disc">
							<li>
								<a href="#Interaction">相互作用</a>
							</li>
							<li>
								<a href="#LifelineandInstancerole">生命线和实例角色</a>
							</li>
							<li>
								<a href="#Execution">执行</a>
							</li>
							<li>
								<a href="#Message">信息</a>
							</li>
							<li>
								<a href="#SingleEventEndandCompoundEventEnd">SingleEventEnd和CompoundEventEnd</a>
							</li>
							<li>
								<a href="#Ordering">订购</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#sd_description">序列图说明</a>
					</li>
					<li>
						<a href="#DefaultLayer">默认图层</a>
					</li>
					<li>
						<a href="#mappings">映射</a>
						<ol style="list-style:disc">
							<li>
								<a href="#InstanceRole">实例角色</a>
							</li>
							<li>
								<a href="#Executions">处决</a>
							</li>
							<li>
								<a href="#BasicMessages">基本信息</a>
							</li>
						</ol>
					</li>
					<li>
						<a href="#tools">工具</a>
						<ol style="list-style:disc">
							<li>
								<a href="#JavaServices">Java服务</a>
							</li>
							<li>
								<a href="#CreationTools">创作工具</a>
							</li>
							<li>
								<a href="#eventReorderTool">事件重新排序工具</a>
							</li>
							<li>
								<a href="#instanceRoleReorderTool">实例角色重新排序工具</a>
							</li>
							<li>
								<a href="#OtherTools">其他工具</a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<h2 id="introduction">介绍</h2>
		<p>本文档介绍如何使用Sirius指定序列图建模器。它是为希望在自己的元模型上指定序列图的软件架构师编写的。</p>
		<p>本教程基于一个示例，即UML序列图编辑器的规范。生成的图表在<em>Obeo UML Behavioral</em>观点（可从<a href="https://github.com/ObeoNetwork/UML-Modeling" target="_blank">https://github.com/ObeoNetwork/UML-Modeling</a>免费获得）中获得，该观点基于Eclipse Foundation的<a href="http://wiki.eclipse.org/MDT-UML2" target="_blank">UML2元模型</a> 。
		</p>
		<h2 id="semantics">序列图语义</h2>
		<p>顾名思义，序列图用于表示有序的元素序列。通常，它们代表一些实体在<em>一段时间内</em>发送和接收的<em>事件</em> 。规范案例是UML序列图（符号来自），它表示在软件系统中的对象之间交换的消息。
		</p>
		<p>最重要的结果是，与经典图表中发生的情况相反， <em>序列图上元素的相对图形位置具有强烈的意义</em> 。这对于垂直放置和生命线的从左到右顺序都是如此。然而，在另一个上面或下面放置消息对它们所代表的事件的排序具有强烈的影响，因此对所表示的底层语义模型的结构具有强烈的影响。Sirius努力确保您在序列图上看到的内容（根据元素的垂直排序和生命线的水平排序）始终对应于所表示事件的语义顺序。
		</p>
		<p>这有两种方式：</p>
		<ul>
			<li>假设图表已同步（即您处于<em>自动刷新</em>模式或自上次语义更改后手动刷新），Sirius将始终以与事件的语义顺序兼容的方式组织图表上的元素：如果您看到执行<em>E1</em>置于另一个执行<em>E2</em>之上，可以确定<em>E1</em>对应的事件发生在语义模型中的<em>E2</em>事件之前。
			</li>
			<li>对称地，或许更重要的是，序列图上的<em>移动</em>元素可以触发底层语义模型的变化，以反映您更改的位置隐含的新事件顺序。这与其他图表中的情况非常不同，其他元素的大多数图形重新定位仅仅是装饰性的。保持上面的示例，将图形上的执行<em>E2</em>移动到<em>E1</em>之上将触发语义模型的改变以在<em>E1</em>的事件之前移动<em>E2</em>的相应事件。
			</li>
		</ul>
		<p>与其他图表相比，序列图的大多数特定特征和限制源于这种强有力的保证，即您在图上看到的元素的图形（垂直）顺序始终与存在于其中的事件的语义顺序完全匹配。底层模型和您在图上看到的实例角色的水平顺序与底层模型中存在的相应元素的语义顺序完全匹配。</p>
		<p>从说明者的角度来看，这意味着序列图只能在元模型上定义，在元模型中，您可以提供所表示事件的总排序，并且您可以以可预测的方式重新排序这些元素（请参阅<a href="#eventReorderTool">事件重新排序工具</a>和<a href="#instanceRoleReorderTool">实例角色重新排序工具</a>以获取详细信息）。
		</p>
		<h2 id="restrictions">限制和限制</h2>
		<p>为了保证上述强有力的保证，在序列图上不支持甚至完全禁用正常图表上的某些功能。基本上，任何能够使普通图表上的图表都无法在图表上显示的有意义的语义元素是被禁止的。这将使Sirius无法一致地跟踪这些不可见元素相对于可见元素的“位置”。</p>
		<ul>
			<li>
				<em>图层</em> ：序列图可以定义可选图层，只要它们在选择或取消选择时不会使图形元素在图表上显示或消失。例如，在调色板中提供新工具的图层很好。
			</li>
			<li>
				<em>过滤器</em> ：不支持在启用时隐藏序列图中元素的过滤器。
			</li>
			<li>
				<em>隐藏/显示</em> ：不支持显式隐藏元素。UI中禁用了操作。</li>
			<li>
				<em>Pin / Unpin</em> ：固定图形元素对序列图的自动布局没有影响。即使元素已被标记为固定，Sirius也必须能够根据需要以图形方式移动它，以便保持元素的图形顺序与语义顺序同步。UI中禁用了操作。</li>
		</ul>
		<h2 id="prerequisites">先决条件</h2>
		<p>与任何Sirius图一样，用于序列图的语义模型定义了必须映射到图形元素的一些元素和关系，以便在序列图上表示。对于UML2建模器，语义模型在<code>.uml</code>文件中定义，并在<code>uml2.odesign</code> Viewpoint规范文件中定义。
		</p>
		<p>架构师的工作是映射UML2交互，生命线，执行和消息。即使Sirius中对序列图的支持不专用于UML2，这些四种元素（或类似元素）必须由序列元模型提供，以便在Sirius中表示为序列图。</p>
		<h3 id="Interaction">相互作用</h3>
		<p>交互是所有序列图元素的语义容器。</p> 
		<img border="0" src="images/interaction.png">
		<p>在UML2中，交互由<code>Interaction</code>类型的元素表示。
		</p>
		<h3 id="LifelineandInstancerole">生命线和实例角色</h3>
		<p>实例角色和生命线代表交互中的一个参与者。</p> 
		<img border="0" src="images/lifeline.png">
		<p>在UML2中，实例角色和生命线由<code>Lifeline</code>类型的一个元素表示。
		</p>
		<h3 id="Execution">执行</h3>
		<p>执行通常表示参与者生命周期中的一段时间。执行由三个元素组成：</p>
		<ul>
			<li>
				<em>执行开始</em> ： <em>执行</em>的开始发生;</li>
			<li>
				<em>执行</em> ：自行执行（执行的持续时间）;</li>
			<li>
				<em>执行完成</em> ： <em>执行完成</em> 。
			</li>
		</ul> 
		<img border="0" src="images/execution.png">
		<p>在UML2中，执行由<code>Execution Specification</code>类型的元素表示，执行开始和结束由抽象类型<code>Occurrence Specification</code>定义。
		</p>
		<h3 id="Message">信息</h3>
		<p>该消息表示交互生命线之间的一种通信。消息由三个元素组成：</p>
		<ul>
			<li>
				<em>消息发送</em> （或<em>源</em> ）：消息的发送发生;</li>
			<li>
				<em>消息</em> ：消息本身（通信类型，例如同步/异步调用）;</li>
			<li>
				<em>消息接收</em> （或<em>目标</em> ）：消息的接收发生</li>
		</ul> 
		<img border="0" src="images/message.png">
		<p>在UML2中，消息由<code>Message Specification</code>类型的元素表示，消息发送和接收由一个抽象类型的<code>Occurrence Specification</code>定义。
		</p>
		<h3 id="SingleEventEndandCompoundEventEnd">SingleEventEnd和CompoundEventEnd</h3>
		<p>Sirius内部管理为每次交互定义的开始/结束执行发生和发送者/接收者消息发生的列表。所有这些事件都是<code>EventEnds</code>列表中包含的事件结束。
		</p>
		<p><code>eventEnd</code>包含两个属性：</p>
		<ul>
			<li>
				<code>semanticEvent</code> ：指向可能是消息或执行的语义事件，</li>
			<li>
				<code>semanticEnd</code> ：指向语义事件的一个连接端，即可以是消息发送者，消息接收者，执行开始或执行完成的语义元素。
			</li>
		</ul>
		<p><code>EventEnds</code>有两种：</p>
		<ul>
			<li>
				<code>SingleEventEnd</code> ：是一个元素，仅用作一个执行/消息的开始/发送或完成/接收。在UML2中，执行可以由<code>Execution Occurrence Specification</code>启动或完成，消息可以由<code>Message occurrence Specification</code>发送或接收。
			</li>
			<li>
				<code>CompoundEventEnd</code> ：是表示消息和执行组合的元素。存在这种<code>EventEnd</code>以便以图形方式将消息与执行相关联。由于<code>CompoundEventEnd</code>是一个<code>EventEnd</code> ，它包含两个属性：<ul>
					<li>
						<code>semanticEvent</code>指向消息或执行。
					</li>
					<li>
						<code>semanticEnd</code>指向<code>MixEnd</code>元素。
					</li>
				</ul>
			</li>
		</ul>
		<p>根据元模型的定义方式， <code>MixEnd</code>可以表示为：</p>
		<ul>
			<li>一个<code>SingleEventEnd</code> ：这是在UML2的情况下， <code>Execution Specification</code>可与类型的开始/结束元素定义<code>Execution Occurrence Specification</code>或<code>Message Occurrence Specification</code>
			</li>
			<li>2个<code>SingleEventEnds</code> ：一个<code>SingleEventElement</code>指向该消息和一个<code>SingleEventElement</code>它指向执行。
			</li>
		</ul> 
		<img border="0" src="images/event_ends.png">
		<p><code>Operation_0</code>消息在<code>Operation_0()</code>执行的左边界结束，因为<code>Operation_0_receiver</code>与执行开始相关联。否则，该消息将与生命线相关联。例如， <code>Message_3</code>是一个未链接到执行的简单消息。因此， <code>Message_3_receiver</code>是<code>SingleEventEnd</code>并附加到生命线。
		</p>
		<p>因此，对于异步调用，我们得到：</p>
		<ul>
			<li>一个<code>SingleEventEnd</code>用于发送消息： <code>Operation_0_sender</code>
				<ul>
					<li>
						<code>semanticEvent</code> = <code>Operation_0</code>消息</li>
					<li>
						<code>semanticEnd</code> = <code>Operation_0_sender</code>消息发生规范</li>
				</ul>
			</li>
			<li>一个<code>CompoundEventEnd</code>用于<code>Operation_0</code>消息接收和<code>Operation_0</code>执行<code>startingEnd</code>由一个<code>SingleEventEnd</code> = <code>Operation_receiver</code>
				<ul>
					<li>
						<code>semanticEvent</code> = <code>Operation_0</code>消息</li>
					<li>
						<code>semanticEnd</code> = <code>Operation_0_receiver</code>消息发生规范</li>
				</ul>
			</li>
			<li>一个<code>SingleEventEnd</code>用于执行完成： <code>Operation_0_finish</code>
				<ul>
					<li>
						<code>semanticEvent</code> = <code>Operation_0</code>执行</li>
					<li>
						<code>semanticEnd</code> = <code>Operation_0_finish</code>执行发生规范</li>
				</ul>
			</li>
		</ul>
		<h3 id="Ordering">订购</h3>
		<p>在Sirius序列图中，元素是完全有序的。</p>
		<p>在内部，Sirius维护着三个有序集：</p>
		<ul>
			<li>两个用于垂直排序：一个对图形元素进行排序的图形集，一个对语义元素进行排序的语义集。</li>
			<li>一个用于水平排序，一个语义集，用于对语义实例角色进行排序（实例角色的图形排序可用，无需大量计算）。</li>
		</ul> 
		<img border="0" src="images/orderings.png">
		<p>为了提供功能图，每个语义/图形排序必须始终保持一致。创建工具和重新排序工具必须管理语义顺序。下一节将给出更多解释。</p>
		<h2 id="sd_description">序列图说明</h2>
		<p>首先，在现有视点的odesign文件中，您必须创建一种新的表示形式：序列图描述。</p> 
		<img border="0" src="images/new_description.png"> 
		<img border="0" src="images/description_properties.png">
		<p>对于其他表示，您可以定义强制属性：</p>
		<ul>
			<li>
				<em>Id</em> ：Sirius中图表类型的唯一标识符</li>
			<li>
				<em>标签</em> ：用于向最终用户显示信息</li>
			<li>
				<em>域类</em> ：表示序列图容器的语义元素的类型</li>
		</ul>
		<p>有关每个属性的完整说明，请查看“ <em>帮助”&gt;“Sirius说明程序指南”&gt;“参考指南”&gt;“表示”&gt;“序列图”</em> 。
		</p>
		<p>要理解的最重要的属性是<em>Ends Ordering</em>和<em>Instance Roles Ordering</em> 。
		</p> 
		<img border="0" src="images/ends_ordering.png">
		<p>在序列图中，图形元素按时间顺序排序，此顺序至关重要。维护和更新元素全局顺序将是您稍后创建的所有工具的主要目的。您的工具必须始终保持语义元素的顺序，并根据此，Sirius管理图形表示顺序。</p>
		<p>序列图中的有序元素使用<em>Ends Ordering</em>和<em>Instance Roles Ordering</em>字段定义。当您打开交互的序列图时，Sirius将使用这些属性自动对图形元素进行排序。
		</p>
		<p><em>结束排序</em>处理事件的垂直顺序。它用表达式指定必须如何排序语义元素。这些元素应该是execution1开始/结束和消息发送/接收事件。
		</p>
		<p>此表达式存在特定变量： <code>eventEnds</code> 。变量<code>eventEnds</code>包含当前交互存在的所有<code>EventEnds</code>的列表。
		</p>
		<p>注意： <em>Ends Ordering</em>表达式的评估应仅返回<code>eventEnds</code>列表中包含的元素。
		</p>
		<p><em>实例角色排序</em>处理实例角色/生命线的水平顺序。它用表达式指定必须如何排序语义元素。这些元素应该是将被表示为实例角色的语义元素。
		</p>
		<p>如果我们看一下UML2元模型，则在<code>Interaction</code>中定义的片段引用包含所有执行事件和消息出现。执行发生和消息出现是<code>EventEnd</code>元素。但片段引用还包含一些其他类型的元素作为执行规范。为了使<em>Ends Ordering</em>属性只引用<code>EventEnd</code>元素，我们需要做一个片段元素和eventEnds的交集（使用Acceleo或使用<code>service:</code>委托给Java服务:)。</p>
		<p>此外， <code>Interaction</code>中定义的生命线参考包含代表生命线和实例角色的所有<code>Lifeline</code> 。
		</p> 
		<img border="0" src="images/ends_ordering_visual.png">
		<p>对于UML Modeler， <em>Ends Ordering</em>表达式将返回下图，有序列表： <code>[Operation_0_sender, Operation_0_receiver, Operation_0_finish, test_sender, test_receiver, test_reply_sender, test_reply_receiver, Message_3_sender, Message_3 _receiver]</code> 。
			<br>并且<em>实例角色订购</em>表达式将返回下面的图表，有序列表： <code>[producers, consumers]</code> 。
		</p>
		<h2 id="DefaultLayer">默认图层</h2>
		<p>序列图描述完成后，您可以添加默认图层。</p> 
		<img border="0" src="images/default_layer.png">
		<p>下一步是定义映射和管理交互元素的所有工具。</p>
		<h2 id="mappings">映射</h2>
		<p>我们想在序列图上表示四个不同的元素，然后将映射关联到每个元素：</p>
		<ul>
			<li>
				<em>实例</em> ：实例角色映射</li>
			<li>
				<em>生命周期</em> ：执行映射</li>
			<li>
				<em>执行</em> ：执行映射</li>
			<li>
				<em>消息</em> ：基本消息映射</li>
		</ul> 
		<img border="0" src="images/mappings.png">
		<h3 id="InstanceRole">实例角色</h3>
		<p>首先，创建实例角色映射。它以图形方式对应于生命线顶部的方框。</p> 
		<img border="0" src="images/new_instance_role_mapping.png">
		<p>设置必需属性<em>Id</em> ， <em>Label</em>和<em>Domain类</em> ：</p> 
		<img border="0" src="images/instance_role_mapping_properties.png">
		<p>语义候选表达式是一个Acceleo表达式，返回将为其评估映射的语义元素，然后图形元素将表示图上的语义元素。</p>
		<p>不要忘记为实例角色映射创建新样式。</p>
		<img border="0" src="images/instance_role_mapping_style.png">
		<h3 id="Executions">处决</h3>
		<p>当您有一个由start，duration和finish元素组成的元素时，将使用执行映射。</p>
		<p>我们将定义执行映射：</p> 
		<img border="0" src="images/new_execution_mapping.png">
		<p>首先，为生命线执行创建执行映射。这代表了生命线的虚线。</p> 
		<img border="0" src="images/execution_mapping_properties1.png">
		<p>并为执行创建执行映射。这表示生命线或其他执行的执行方块。</p> 
		<img border="0" src="images/execution_mapping_properties2.png">
		<p>设置强制属性：</p>
		<ul>
			<li>
				<em>Id</em> ， <em>Label</em> ， <em>Domain类</em>
			</li>
			<li>
				<em>语义候选者表达式</em> ：返回与当前执行相关联的第一级执行的表达式。
			</li>
		</ul> 
		<img border="0" src="images/execution_mappings_visual.png">
		<p>这里，调用java service1 executionSemanticCandidates（）。</p>
		<ul>
			<li>
				<em>启动End Finder表达式</em> ：定义执行开始的语义元素</li>
			<li>
				<em>Finishing End Finder Expression</em> ：定义执行完成的语义元素</li>
		</ul>
		<p>Sirius使用结束查找器表达式以图形方式将执行链接到其开始和结束元素，并在创建和重新排序操作期间查找重新附加拖动元素的位置。</p>
		<p>由于执行可以递归地包含其他执行，因此不要忘记通过设置属性Reused bordered node mappings来导入自身的映射：</p> 
		<img border="0" src="images/execution_mapping_reused.png">
		<p>对于两个执行映射，不要忘记创建新样式：</p> 
		<img border="0" src="images/execution_mapping_style.png">
		<h3 id="BasicMessages">基本信息</h3>
		<p>现在，我们将定义基本的消息映射：</p> 
		<img border="0" src="images/new_message_mapping.png">
		<p>创建基本消息映射：</p> 
		<img border="0" src="images/new_basic_message_mapping.png"> 
		<img border="0" src="images/basic_message_mapping_properties.png">
		<p>设置强制属性：</p>
		<ul>
			<li>
				<em>Id</em> ， <em>Label</em> ， <em>Domain类</em>
			</li>
			<li>
				<em>语义候选者表达式</em> ：用于获取交互中定义的所有消息的表达式</li>
			<li>
				<em>语义元素</em> ：将一组逻辑语义元素与图形元素相关联。例如，在这里我们关联到图形消息类型的语义元素<code>Message</code> ，类型的消息发送事件<code>Message Occurrence Specification</code>和消息接收类型的事件<code>Message Occurrence Specification</code> 。Sirius将使用此信息：<ul>
					<li>在属性视图中显示关联的语义元素，</li>
					<li>监听相关元素更改，以便在必要时刷新</li>
					<li>如果没有特定的删除工具，则删除关联的元素。</li>
				</ul>
			</li>
			<li>
				<em>源/目标映射</em> ：可以是消息的源/目标的图形映射列表。可以将几个映射定义为消息的源映射或目标映射。在UML2中，生命线映射和执行映射可以是消息的源/目标。在下图中，可以选择消费者生命线和<code>compute()</code>执行作为获取消息的源。可以选择生成器生命线和获取执行作为获取消息的目标。
			</li>
		</ul> 
		<img border="0" src="images/basic_message_mapping_visual1.png">
		<ul>
			<li>
				<em>源/目标查找器表达式</em> ：必须返回源/目标语义元素的表达式，即消息的源/目标上下文。在UML2中，表达式返回是生命线或执行的例子。在下图中，计算执行是消息get的语义源元素，get执行是语义目标元素。
			</li>
		</ul> 
		<img border="0" src="images/basic_message_mapping_visual2.png">
		<ul>
			<li>
				<em>发送/接收结束查找器表达式</em> ：必须返回表示消息发送方/接收方的语义元素的表达式。
			</li>
		</ul> 
		<img border="0" src="images/basic_message_mapping_visual3.png">
		<h4 id="LostandFoundMessages">失物招领消息</h4>
		<p>标准节点映射，即当前序列图描述的一层的直接子节点，可用于表示未知消息结束。应使用通用工具创建丢失和找到的消息。</p>
		<h2 id="tools">工具</h2>
		<h3 id="JavaServices">Java服务</h3>
		<p>要在Acceleo表达式中使用java服务，必须在odesign中定义服务：</p> 
		<img border="0" src="images/java_service.png">
		<h3 id="CreationTools">创作工具</h3>
		<p>定义新部分以添加创建工具：</p> 
		<img border="0" src="images/new_creation_tool_section.png">
		<h4 id="CreateLifeline">创建生命线</h4>
		<p>应使用与实例角色映射关联的实例角色创建工具创建生命线。</p> 
		<img border="0" src="images/lifeline_creation_tool.png">
		<p><code>predecessor</code>变量在全局实例角色排序中表示新实例角色之前的元素。
		</p>
		<h4 id="CreateExecution">创建执行</h4>
		<p>可以使用<em>执行创建工具</em>创建<em>执行</em> 。
		</p> 
		<img border="0" src="images/new_execution_creation_tool.png">
		<p>可以在工具定义中使用以下变量：</p>
		<ul>
			<li>
				<code>container</code> ：将以图形方式包含新执行的元素（生命线或执行），在下面的示例中，容器将是get（）执行。
			</li>
			<li>
				<code>startingEndPredecessor</code>和<code>finishingEndPredecessor</code> ：表示在全局事件结束列表中，新执行开始之前的元素和新执行结束之前的元素。获取与事件结束相关联的相应语义结束元素： <code>startingEndPredecessor.semanticEnd</code>或<code>finishingEndPredecessor.semanticEnd</code> 。
			</li>
		</ul> 
		<img border="0" src="images/execution_creation_tool_visual.png">
		<p>在上面的示例中，我们要在现有的get执行上创建一个新的<code>BehaviorExecution_2</code> 。因此， <code>startingEndPredecessor</code>和<code>finishingEndPredecessor</code>将指向<code>get_receiver</code>消息发生。此变量表示与新元素的<code>startingEnd</code> （ <code>BehaviorExecution_2_start</code> ）和<code>finishingEnd</code> （ <code>BehaviorExecution_2_finish</code> ）之前的图形元素相关联的语义元素（ <code>get_receiver</code> ）。
		</p>
		<h4 id="MessageCreationTool">消息创建工具</h4>
		<p>可以使用Message Creation Tool创建消息。</p> 
		<img border="0" src="images/new_message_creation_tool.png">
		<p>可以在工具定义中使用以下变量：</p>
		<ul>
			<li>
				<code>source</code> ：与消息发送相关的语义元素;</li>
			<li>
				<code>target</code> ：与消息接收关联的语义元素;</li>
			<li>
				<code>startingEndPredecessor</code>和<code>finishingEndPredecessor</code> ：表示在全局事件结束列表中，新消息发送之前的元素和新消息接收之前的元素。
			</li>
		</ul> 
		<img border="0" src="images/message_creation_tool_visual.png">
		<p>在此示例中，我们希望从现有计算执行到生产者生命线创建新的<code>Message_1</code> 。因此， <code>startingEndPredecessor</code>和<code>finishingEndPredecessor</code>将指向<code>get_finish</code>执行发生。这些变量表示与新元素的<code>startingEnd</code> （ <code>Message_1_sender</code> ）和<code>finishingEnd</code> （ <code>Message_1_receiver</code> ）之前的图形元素相关联的语义元素（ <code>get_finish</code> ）。
		</p>
		<p>
			<strong>前提。</strong> 对于许多其他工具，可以为消息创建工具定义前提条件。根据前提条件表达式，该工具仅允许在特定条件下创建元素。前提条件被定义为解释表达式。
		</p> 
		<img border="0" src="images/message_creation_precondition.png">
		<p>一个变量可用于Acceleo表达式：$ preTarget。此变量是与当前由鼠标悬停的图形元素关联的语义元素。</p>
		<h3 id="eventReorderTool">事件重新排序工具</h3>
		<p>当用户移动或更改图表上图形元素的大小时，将调用此工具。</p>
		<p>可以并且必须为消息和执行映射指定单个唯一事件重新排序工具。该工具的目的是重新同步图形排序和语义排序。当用户重新排序图形元素时，图形元素的全局顺序改变，然后工具必须根据这些改变对语义元素重新排序。</p> 
		<img border="0" src="images/new_reorder_tool.png">
		<p>此工具可以访问表达式中可用的以下两个变量：</p>
		<ul>
			<li>
				<code>startingEndPredecessorAfter</code> ：在全局事件结束列表中表示移动元素start / send之前的元素。它是，在移动<strong>后</strong> ，会直接被移动的元件的<strong>起始端</strong> （顶部） <strong>之前</strong>的事件;</li>
			<li>
				<code>finishingEndPredecessorAfter</code> ：在全局事件结束列表中表示移动元素完成/接收之前的元素。它是，在移动<strong>之后</strong> ，将被移动的元件的<strong>精加工端部</strong> （底部）直接<strong>之前</strong>的事件。
			</li>
		</ul> 
		<img border="0" src="images/reorder_tool_visual1.png">
		<p>在此示例中，我们希望在<code>Message_0</code>之后移动get执行。因此， <code>startingEndPredecessorAfter</code>变量将指向<code>compute_finish</code>执行发生。此变量表示在执行get之后与<code>startingEnd</code> （ <code>get_start</code> ）之前的图形元素关联的语义元素（ <code>compute_finish</code> ）。<code>finishingEndPredecessorAfter</code>变量将指向<code>get_start</code>执行发生。此变量表示在执行get之后与<code>finishingEnd</code> （ <code>get_finish</code> ）之前的图形元素关联的语义元素（ <code>get_start</code> ）。
		</p>
		<p>现在，我们将看一个更复杂的重新排序操作。</p> 
		<img border="0" src="images/reorder_tool_visual2.png">
		<p>在此示例中，我们希望在<code>Message_1</code>之后移动get执行。的get执行链接到获取同步信息，从而获取所述执行<code>startingEnd</code>是<code>compoundEvent</code>表示<code>get_receiver</code>消息发生。当我们移动执行时，还必须移动相关的消息。在这种情况下， <code>startingEndPredecessorAfter</code>变量将指向<code>compute_finish</code>执行发生。此变量表示在执行get之后与<code>startingEnd</code> （ <code>get_send</code> ）之前的图形元素关联的语义元素（ <code>compute_finish</code> ）。<code>finishingEndPredecessorAfter</code>变量将指向<code>get_receiver</code>消息发生。此变量表示在执行get之后与<code>finishingEnd</code> （ <code>get_finish</code> ）之前的图形元素关联的语义元素（ <code>get_receiver</code> ）。
		</p>
		<h3 id="instanceRoleReorderTool">实例角色重新排序工具</h3>
		<p>当用户在图表上水平移动实例角色时，将调用此工具。</p>
		<p>可以并且必须为实例角色映射指定单个唯一事件重新排序工具。该工具的目的是重新同步图形排序和语义排序。当用户重新排序图形实例角色时，图形实例角色的全局顺序会发生变化，然后工具必须根据这些更改对语义实例角色进行重新排序。</p> 
		<img border="0" src="images/new_instance_role_reorder_tool.png">
		<p>此工具可以访问表达式中可用的以下两个变量：</p>
		<ul>
			<li>
				<code>predecessorBefore</code> ：表示在全局实例角色中排序先前在移动的实例角色之前的元素。它是在移动<strong>之前</strong>直接位于移动元素<strong>之前</strong>的元素;</li>
			<li>
				<code>predecessorAfter</code> ：表示在全局实例角色中排序移动的实例角色之前的元素。它是，在移动<strong>后</strong> ，会直接被移动的元件<strong>之前</strong>的事件;</li>
		</ul> 
		<img border="0" src="images/instance_role_reorder_tool_visual1.png">
		<p>在此示例中，我们希望在<code>producers</code>实例角色之后移动<code>consumers</code>实例角色。因此， <code>predecessorAfter</code>变量将指向<code>producers</code>执行发生。此变量表示与移动后的<code>consumers</code>实例角色之前的图形元素关联的语义元素（ <code>producers</code> ）。<code>predecessorBefore</code>变量将为null，因为<code>consumers</code>是排序的第一个元素。
		</p>
		<h3 id="OtherTools">其他工具</h3>
		<p>删除工具，编辑标签工具，图表创建和图表导航工具没有特定的内容，请查看Sirius Specifier Guide。</p>
	</body>
</html>