<html id="3184.Scale.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 比例</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">类型比例</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。规模</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Scale.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Scale.html#constructor">比例</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Scale.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Scale.html#getMaximum">getMaximum</a></b> （）</div>
                <div class="description">返回接收器允许的最大值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Scale.html#getMinimum">getMinimum</a></b> （）</div>
                <div class="description">返回接收器允许的最小值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Scale.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">返回'选择'，它是接收者的位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Scale.html#setSelection">setSelection</a></b> （选择）</div>
                <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Scale.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Scale.html#event:Selection">选择</a></b>
                </div>
                <div class="description">更改窗口小部件选择时发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>比例</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getMaximum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMaximum</b> （）</div>
          <div class="description">返回接收器允许的最大值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最大值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getMinimum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMinimum</b> （）</div>
          <div class="description">返回接收器允许的最小值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最小值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getSelection</b> （）</div>
          <div class="description">返回'选择'，它是接收者的位置。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>选择</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （选择）</div>
          <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{int}</span> <b>选择</b>
                  
                </dt>
                <dd>新选择（必须为零或更大）</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Selection"> </a>
          <div class="fixedFont">

          
          <b>选择</b>

          </div>
          <div class="description">更改窗口小部件选择时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Selection">SWT.Selection</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="3350.Event-matching-and-trace-synchronization.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass开发人员指南 - 事件匹配和跟踪同步</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">事件匹配和跟踪同步</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="CTF-Parser.html" title="CTF Parser">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Analysis-Framework.html" title="分析框架">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">CTF Parser</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">分析框架</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Event_matching_and_trace_synchronization">事件匹配和跟踪同步</h1>
		<p>事件匹配包括从跟踪中获取事件并将其链接到可能不同的跟踪中的另一个事件。想到的示例是匹配从一个跟踪机器发送到另一个跟踪机器的网络数据包。这些匹配可用于同步跟踪。</p>
		<p>跟踪同步包括在不同的机器上获取具有不同时间参考的跟踪，并找到用于转换某些跟踪的时间戳的公式，以便它们都具有相同的时间参考。</p>
		<h2 id="Event_matching_interfaces">事件匹配接口</h2>
		<p>以下是事件匹配中涉及的主要部分的描述。这些类都在<i>org.eclipse.tracecompass.tmf.core.event.matching</i>包中：</p>
		<ul>
			<li>
				<b>ITmfEventMatching</b> ：控制事件匹配过程</li>
			<li>
				<b>ITmfMatchEventDefinition</b> ：描述事件的匹配方式</li>
			<li>
				<b>IMatchProcessingUnit</b> ：处理匹配的事件</li>
		</ul>
		<h2 id="Implementation_details_and_how_to_extend_it">实现细节以及如何扩展它</h2>
		<h3 id="ITmfEventMatching_interface_and_derived_classes">ITmfEventMatching接口和派生类</h3>
		<p>此接口控制事件匹配本身。他们唯一的公共方法是<i>matchEvents</i> 。实现类需要管理如何设置跟踪以及任何初始化或完成过程。
		</p>
		<p>这是该接口的一个具体实现： <b>TmfEventMatching</b> 。它对跟踪和匹配事件发出请求，其中<i>原因</i>事件可以与<i>效果</i>事件唯一匹配。它在源事件和目标事件之间创建<b>TmfEventDependency</b> 。依赖关系被添加到处理单元。
		</p>
		<p>要匹配需要其他机制的事件（例如，一系列事件可以与另一系列事件匹配），需要添加另一个实现<b>ITmfEventMatching的</b>类。它很可能还需要一个新的<b>ITmfMatchEventDefinition</b>实现。
		</p>
		<h3 id="ITmfMatchEventDefinition_interface_and_its_derived_classes">ITmfMatchEventDefinition接口及其派生类</h3>
		<p>这些类描述了如何将特定事件实际匹配在一起。</p>
		<p><b>canMatchTrace</b>方法将告诉定义是否与给定跟踪兼容。
		</p>
		<p><b>getEventKey</b>方法将返回唯一标识此事件的事件的键，并将匹配另一个事件的键。
		</p>
		<p>该方法<b>getDirection</b>指示此事件是否是被一个从相反的方向相匹配的<i>原因</i>或<i>效果</i>事件。
		</p>
		<p>作为示例，在<i>org.eclipse.tracecompass.internal.lttng2.kernel.core.event.matching</i>包中实现了两个具体的网络匹配定义，用于匹配TCP数据包的两种兼容方法（请参阅<i>跟踪同步</i>的跟踪指南针用户指南）关于那些匹配方法的信息）。每个事件都告诉CTF跟踪的元数据中需要存在哪些事件，以使这种匹配方法适用。它还返回每个事件的字段值，这些事件将唯一匹配2个事件。
		</p>
		<p>例如，每个<b>IMatchEventDefinition都</b>需要使用以下代码注册到<b>TmfEventMatching</b>类</p>
		<pre>TmfEventMatching.registerMatchObject（new TcpEventMatching（））;</pre>
		<h3 id="IMatchProcessingUnit_interface_and_derived_classes">IMatchProcessingUnit接口和派生类</h3>
		<p>虽然匹配事件本身就是一个练习，但它是如何处理真正使这个功能变得有趣的匹配。这是<b>IMatchProcessingUnit</b>接口的工作。
		</p>
		<p>
			<b>TmfEventMatches</b>提供了一个默认实现，它只存储匹配项来计算它们。获得新匹配时，将使用匹配调用<i>addMatch</i> ，处理单元可以执行任何需要执行的操作。
		</p>
		<p>匹配处理单元本身可以是分析。例如，跟踪同步是通过这样的处理单元完成的。只需要在TmfEventMatching构造函数中设置处理单元。</p>
		<h2 id="Code_examples">代码示例</h2>
		<h3 id="Using_network_packets_matching_in_an_analysis">在分析中使用网络数据包匹配</h3>
		<p>此示例显示了如何创建内联处理单元以在两个事件之间创建链接。在此示例中，代码已使用事件请求，因此此处无需调用<i>matchEvents</i>方法，该方法仅创建另一个请求。</p>
		<pre>class MyAnalysis扩展了TmfAbstractAnalysisModule {private TmfNetworkEventMatching tcpMatching; ...protected void executeAnalysis（）{IMatchProcessingUnit matchProcessing = new IMatchProcessingUnit（）{@ Override public void matchingEnded（）{} @Override public void init（ITmfTrace [] fTraces）{} @Override public int countMatches（）{return 0; } @Override public void addMatch（TmfEventDependency match）{log.debug（“我们得到了一个tcp匹配！“+ match.getSourceEvent（）。getContent（）+”“+ match.getDestinationEvent（）。getContent（））; TmfEvent source = match.getSourceEvent（）; TmfEvent destination = match.getDestinationEvent（）; / *创建一个链接这两个事件* /}}; ITmfTrace [] traces = {getTrace（）}; tcpMatching = new TmfEventMatching（traces，matchProcessing）; tcpMatching.initMatching（）; MyEventRequest request = new MyEventRequest（this，i）; getTrace（）。 sendRequest（request）;} public void analyzeEvent（TmfEvent event）{...tcpMatching.matchEvent（event，0）; ...} ...} MyEventRequest扩展TmfEventRequest {private final MyAnalysis分析; MyEventRequest（MyAnalysis analysis，int traceno）{super（CtfTmfEvent.class，TmfTimeRange。ETERNITY，0，TmfDataRequest.ALL_DATA，ITmfDataRequest.ExecutionType。前景）; this.analysis = analysis; } @Override public void handleData（final ITmfEvent event）{super.handleData（event）;如果（事件！= null）{analysis.analyzeEvent（event）; }}}</pre>
		<h3 id="Match_events_from_UST_traces">匹配来自UST痕迹的事件</h3>
		<p>假设使用LTTng-UST检测客户端 - 服务器应用程序。在服务器和不同计算机上的一些客户端上收集跟踪。可以使用网络事件匹配来同步跟踪。</p>
		<p>以下元数据描述了这些事件：</p>
		<pre>event {name =“myapp：send”; id = 0; stream_id = 0; loglevel = 13; fields：= struct {integer {size = 32; align = 8; signed = 1; encoding = none; base = 10; } _发送至;整数{size = 64; align = 8; signed = 1; encoding = none; base = 10; } _messageid;整数{size = 64; align = 8; signed = 1; encoding = none; base = 10; } _data; }; }; event {name =“myapp：receive”; id = 1; stream_id = 0; loglevel = 13; fields：= struct {integer {size = 32; align = 8; signed = 1; encoding = none; base = 10; } _from;整数{size = 64; align = 8; signed = 1; encoding = none; base = 10; } _messageid;整数{size = 64; align = 8; signed = 1; encoding = none; base = 10; } _data; }; };</pre>
		<p>需要为这两个事件编写事件匹配定义，如下所示：</p>
		<pre>公共类MyAppUstEventMatching实现ITmfMatchEventDefinition {public class MyEventMatchingKey实现IEventMatchingKey {private static final HashFunction HF = checkNotNull（Hashing.goodFastHash（32））; private final int fTo;私人决赛长期; public MyEventMatchingKey（int to，long id）{fTo = to; fId = id; } @Override public int hashCode（）{return HF.newHasher（）.putInt（fTo）.putLong（fId）.hash（）。asInt（）; } @Override public boolean equals（@Nullable Object o）{if（o instanceof MyEventMatchingKey）{MyEventMatchingKey key =（MyEventMatchingKey）o; return（key.fTo == fTo &amp;&amp; key.fId == fId）; } return false; @Override public Direction getDirection（ITmfEvent event）{String evname = event.getType（）。getName（）; if（evname.equals（“myapp：receive”））{return Direction。影响; } else if（evname.equals（“myapp：send”））{return Direction。原因; } return null; } @Override public IEventMatchingKey getEventKey（ITmfEvent event）{IEventMatchingKey key; if（evname.equals（“myapp：receive”））{key = new MyEventMatchingKey（event.getContent（）。getField（“from”）。getValue（），event.getContent（）。getField（“messageid”）。getValue （））; } else {key = new MyEventMatchingKey（event.getContent（）。getField（“sendto”）。getValue（），event.getContent（）。getField（“messageid”）。getValue（））; }返回键; } @Override public boolean canMatchTrace（ITmfTrace trace）{Set &lt;String&gt; events = ImmutableSet.of（“myapp：receive”，“myapp：send”）;如果（！（trace instanceof ITmfTraceWithPreDefinedEvents））{return false; } ITmfTraceWithPreDefinedEvents ktrace =（ITmfTraceWithPreDefinedEvents）trace;设置&lt;String&gt; traceEvents = TmfEventTypeCollectionHelper.getEventName（ktrace.getContainedEventTypes（））; traceEvents.retainAll（事件）;回来！traceEvents.isEmpty（）; }}</pre>
		<p>必须在跟踪同步发生之前运行以下代码，例如在插件的Activator中：</p>
		<pre>TmfEventMatching.registerMatchObject（new MyAppUstEventMatching（））;</pre>
		<p>现在，仅在实验中添加跟踪并单击“ <b>同步跟踪”</b>菜单项将使用新的事件匹配定义来同步跟踪。
		</p>
		<h2 id="Trace_synchronization">跟踪同步</h2>
		<p>跟踪同步类和接口位于<i>org.eclipse.tracecompass.tmf.core.synchronization</i>包中。
		</p>
		<h3 id="Synchronization_algorithm">同步算法</h3>
		<p>同步算法用于同步跟踪之间匹配的事件的跟踪。在同步之后，在具有不同时间参考的不同机器上进行的跟踪看到它们的时间戳被修改，使得它们都使用相同的时间参考（通常，至少一条迹线的时间）。对于来自不同机器的跟踪，不可能实现完美的同步，因此结果是考虑网络延迟的最佳近似。</p>
		<p>抽象类<b>SynchronizationAlgorithm</b>是匹配的处理单元。新的同步算法必须扩展这一算法，它已经包含了为不同的跟踪获取时间戳转换的函数。
		</p>
		<p><i>全增量凸壳</i>同步算法是默认的同步算法。
		</p>
		<p>虽然同步系统提供了更多的同步算法，但还没有办法选择一个，实验的跟踪同步使用默认算法。要测试新的同步算法，应该直接调用同步，如下所示：</p>
		<pre>SynchronizationAlgorithm syncAlgo = new MyNewSynchronizationAlgorithm（）; syncAlgo = SynchronizationManager.synchronizeTraces（syncFile，traces，syncAlgo，true）;</pre>
		<h3 id="Timestamp_transforms">时间戳转换</h3>
		<p>时间戳转换是用于将时间戳从跟踪转换为引用时间的公式。<b>ITmfTimestampTransform</b>是实现添加新转换的接口。
		</p>
		<p>以下类实现此接口：</p>
		<ul>
			<li>
				<b>TmfTimestampTransform</b> ：默认转换。它无法实例化，它有一个静态对象<i>TmfTimestampTransform。IDENTITY</i> ，返回原始时间戳。
			</li>
			<li>
				<b>TmfConstantTransform</b> ：只是对时间戳应用偏移量，因此公式为： <i>f（t）= t + c</i>其中<i>c</i>是要应用的偏移量。
			</li>
			<li>
				<b>TmfTimestampTransformLinear</b> ：使用线性公式转换时间戳： <i>f（t）= at + b</i> ，其中<i>a</i>和<i>b</i>由同步算法计算。
			</li>
		</ul>
		<p>这些类不能直接访问，要创建任何时间戳转换，需要使用<b>TimestampTransformFactory</b>实用程序类中的一种方法。
		</p>
		<p>可以扩展用于其他时间戳变换的接口，例如具有变换，其中公式将在跟踪过程中改变。</p>
		<h2 id="Todo">去做</h2>
		<p>这是一个尚未实现的功能列表，可以增强跟踪同步和事件匹配：</p>
		<ul>
			<li>能够选择同步算法</li>
			<li>实现Masoume Jabbarifar的最小生成树算法（关于尚未发布的主题的文章）以自动选择最佳参考跟踪</li>
			<li>将时间戳变换作为实验上下文的一部分，而不是对每个跟踪进行时间戳转换，以便跟踪的特定分析（如状态系统）位于原始跟踪中，但仅在实验分析需要时进行转换。</li>
			<li>添加更多视图以显示同步信息（目前只有文本统计信息可用）</li>
		</ul><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="CTF-Parser.html" title="CTF Parser">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="Developer-Guide.html" title="Trace Compass开发人员指南">
						<img alt="Trace Compass开发人员指南" border="0" src="images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Analysis-Framework.html" title="分析框架">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">CTF Parser</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">分析框架</td>
			</tr>
		</table>
	</body>
</html><html id="3186.Slider.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 滑块</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">键入滑块</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。滑块</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Slider.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Slider.html#constructor">滑块</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Slider.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Slider.html#getMaximum">getMaximum</a></b> （）</div>
                <div class="description">返回接收器允许的最大值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Slider.html#getMinimum">getMinimum</a></b> （）</div>
                <div class="description">返回接收器允许的最小值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Slider.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">返回'选择'，它是接收者的位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Slider.html#setSelection">setSelection</a></b> （选择）</div>
                <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Slider.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Slider.html#event:Selection">选择</a></b>
                </div>
                <div class="description">更改窗口小部件选择时发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>滑块</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>3.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getMaximum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMaximum</b> （）</div>
          <div class="description">返回接收器允许的最大值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最大值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getMinimum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMinimum</b> （）</div>
          <div class="description">返回接收器允许的最小值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最小值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getSelection</b> （）</div>
          <div class="description">返回'选择'，它是接收者的位置。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>选择</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （选择）</div>
          <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{int}</span> <b>选择</b>
                  
                </dt>
                <dd>新选择（必须为零或更大）</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Selection"> </a>
          <div class="fixedFont">

          
          <b>选择</b>

          </div>
          <div class="description">更改窗口小部件选择时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Selection">SWT.Selection</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="3347.Component-Interaction.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass开发人员指南 - 组件交互</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">组件交互</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="View-Tutorial.html" title="查看教程">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Generic-State-System.html" title="通用国家制度">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">查看教程</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">通用国家制度</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Component_Interaction">组件交互</h1>
		<p>TMF为不同组件提供了使用信号相互交互的机制。信号可以携带特定于每个信号的信息。</p>
		<p>TMF信号管理器处理组件的注册和向其预期接收器广播信号。</p>
		<p>组件可以注册为VIP接收器，这将确保他们将在非VIP接收器之前接收信号。</p>
		<h2 id="Sending_Signals">发送信号</h2>
		<p>为了发送信号，必须创建信号的实例并将其作为参数传递给要分派的信号管理器。每个可以处理信号的组件都会收到它。发送者不需要知道接收者。</p>
		<pre>TmfExampleSignal signal = new TmfExampleSignal（this，...）; TmfSignalManager.dispatchSignal（信号）;</pre>
		<p>如果发送方是类TmfComponent的实例，则可以使用广播方法：</p>
		<pre>TmfExampleSignal signal = new TmfExampleSignal（this，...）;广播（信号）;</pre>
		<h2 id="Receiving_Signals">接收信号</h2>
		<p>为了接收任何信号，接收器必须首先向信号管理器注册。接收器可以注册为普通接收器或VIP接收器。</p>
		<pre>TmfSignalManager.register（本）; TmfSignalManager.registerVIP（本）;</pre>
		<p>如果接收器是类TmfComponent的实例，它将自动注册为构造函数中的普通接收器。</p>
		<p>当接收器被销毁或丢弃时，它应该从信号管理器中注销自己。</p>
		<pre>TmfSignalManager.deregister（本）;</pre>
		<p>为了实际接收和处理任何特定信号，接收器必须使用@TmfSignalHandler注释并实现在广播信号时将被调用的方法。方法的名称无关紧要。</p>
		<pre>@TmfSignalHandler public void example（TmfExampleSignal signal）{...}</pre>
		<p>如果需要，信号源可以被一个组件用来过滤掉并忽略当组件也是信号接收器时自己广播的信号，但只有当它被另一个组件发送时才需要处理它。或组件的另一个实例。</p>
		<h2 id="Signal_Throttling">信号限制</h2>
		<p>TmfComponent实例可以缓冲信号的调度，以便只有在指定的延迟之后排队的最后一个信号没有任何其他信号排队被发送到接收器。被延迟内的较新信号抢占的所有信号都被丢弃。</p>
		<p>必须首先初始化信号调节器：</p>
		<pre>final int delay = 100; // ms ms TmfSignalThrottler throttler = new TmfSignalThrottler（this，delay）;</pre>
		<p>然后发送信号应该通过节流器排队：</p>
		<pre>TmfExampleSignal signal = new TmfExampleSignal（this，...）; throttler.queue（信号）;</pre>
		<p>当不再需要节流器时，应该处理掉：</p>
		<pre>throttler.dispose（）;</pre>
		<h2 id="Ignoring_inbound.2Foutbound_signals">忽略入站/出站信号</h2>
		<p>可以阻止发送或接收某些信号。</p>
		<p>阻止所有传入信号到对象：</p>
		<pre>TmfSignalManager.addIgnoredInboundSignal（objectInstance，TmfSignal.class）;</pre>
		<p>阻止源自对象的所有传出信号：</p>
		<pre>TmfSignalManager.addIgnoredOutboundSignal（objectInstance，TmfSignal.class）;</pre>
		<p>阻塞信号过滤基于类型层次结构。阻止<code>TmfSignal.class</code>将阻止从TmfSignal派生的所有信号。阻塞<code>TmfTraceSelectedSignal</code>将阻止此类型的所有信号以及来自<code>TmfTraceSelectedSignal</code>派生信号</p>
		<p>删除忽略规则或全部清除它们：</p>
		<pre>TmfSignalManager.removeIgnoredOutboundSignal（对象源，Class &lt;？扩展TmfSignal&gt; signal）TmfSignalManager.removeIgnoredInboundSignal（对象监听器，Class &lt;？扩展TmfSignal&gt; signal）TmfSignalManager.clearIgnoredOutboundSignalList（Object source）TmfSignalManager.clearIgnoredInboundSignalList（Object listener）</pre>
		<h2 id="Signal_Reference">信号参考</h2>
		<p>以下是框架中定义的内置信号列表。</p>
		<h3 id="TmfStartSynchSignal">TmfStartSynchSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示信号广播的开始。在内部，数据提供程序在收到相应的TmfEndSynchSignal信号之前不会触发事件请求。这允许合并由广播信号的多个接收器触发的请求。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>在将信号发送到所有接收器之前由TmfSignalManager发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfDataProvider收到。</p>
		<h3 id="TmfEndSynchSignal">TmfEndSynchSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示信号广播的结束。在内部，数据提供程序触发自收到相应的TmfStartSynchSignal信号以来接收和缓冲的所有待处理事件请求。这允许合并由广播信号的多个接收器触发的请求。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>在向所有接收器发送信号后由TmfSignalManager发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfDataProvider收到。</p>
		<h3 id="TmfTraceOpenedSignal">TmfTraceOpenedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示已在编辑器中打开跟踪。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>创建时由TmfEventsEditor实例发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfTrace，TmfExperiment，TmfTraceManager和每个显示跟踪数据的视图接收。显示跟踪数据的组件应处理此信号。</p>
		<h3 id="TmfTraceSelectedSignal">TmfTraceSelectedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示迹线已成为当前选定的迹线。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>收到焦点时由TmfEventsEditor实例发送。组件可以发送此信号以使跟踪编辑器显示在前面。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfTraceManager和每个显示跟踪数据的视图接收。显示跟踪数据的组件应处理此信号。</p>
		<h3 id="TmfTraceClosedSignal">TmfTraceClosedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示跟踪编辑器已关闭。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>处理时由TmfEventsEditor实例发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfTraceManager和每个显示跟踪数据的视图接收。显示跟踪数据的组件应处理此信号。</p>
		<h3 id="TmfTraceRangeUpdatedSignal">TmfTraceRangeUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示已更新跟踪的有效时间范围。这会触发跟踪索引到范围的结尾。在流式传输的上下文中，该结束时间被认为是保证完全接收所有事件的安全时间。对于非流式跟踪，结束时间设置为无穷大，表示可以立即读取所有事件。此信号应触发任何希望利用请求合并的跟踪事件处理。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由TmfExperiment和非流式TmfTrace发送。当特定实现确定新的安全时间时，流跟踪应在TmfTrace子类中发送此信号。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由TmfTrace，TmfExperiment和处理跟踪事件的组件接收。需要处理跟踪事件的组件应该处理此信号。</p>
		<h3 id="TmfTraceUpdatedSignal">TmfTraceUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示已为跟踪索引新事件。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>当新事件被编入索引并且事件数已更改时，由TmfCheckpointIndexer发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要通知新跟踪事件计数的组件接收。</p>
		<h3 id="TmfSelectionRangeUpdatedSignal">TmfSelectionRangeUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示已选择新的时间或时间范围。它包含开始和结束时间。如果选择单个时间，则开始和结束时间相同。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由允许用户选择时间或时间范围的任何组件发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要通知当前所选时间或时间范围的任何组件接收。</p>
		<h3 id="TmfWindowRangeUpdatedSignal">TmfWindowRangeUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示已设置新的时间范围窗口。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由允许用户设置时间范围窗口的任何组件发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要通知当前可见时间范围窗口的任何组件接收。</p>
		<h3 id="TmfEventFilterAppliedSignal">TmfEventFilterAppliedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示过滤器已应用于迹线。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>应用过滤器时由TmfEventsTable发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由显示跟踪数据且需要通知应用过滤器的任何组件接收。</p>
		<h3 id="TmfEventSearchAppliedSignal">TmfEventSearchAppliedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示搜索已应用于跟踪。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>应用搜索时由TmfEventsTable发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由显示跟踪数据且需要通知应用搜索的任何组件接收。</p>
		<h3 id="TmfTimestampFormatUpdateSignal">TmfTimestampFormatUpdateSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示时间戳格式首选项已更新。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>更改默认时间戳格式首选项时由TmfTimestampFormat发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要刷新其新时间戳格式的显示的任何组件接收。</p>
		<h3 id="TmfStatsUpdatedSignal">TmfStatsUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示统计数据模型已更新。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>处理新统计数据时由统计提供程序发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由统计信息查看者和需要通知统计信息更新的任何组件接收。</p>
		<h3 id="TmfPacketStreamSelected">TmfPacketStreamSelected</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示用户已选择要分析的分组流。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>当用户选择新的数据包流时，由流列表视图发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由分析数据包流的视图接收。</p>
		<h3 id="TmfStartAnalysisSignal">TmfStartAnalysisSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示分析已开始。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>当分析模块开始执行分析时由分析模块发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要通知分析开始或需要接收分析模块的组件接收。</p>
		<h3 id="TmfCpuSelectedSignal">TmfCpuSelectedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示用户已选择CPU核心。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由允许用户选择CPU的任何组件发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由显示特定于所选CPU的信息的查看者接收。</p>
		<h3 id="TmfThreadSelectedSignal">TmfThreadSelectedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示用户已选择线程。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由允许用户选择线程的任何组件发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由显示特定于所选线程的信息的查看者接收。</p>
		<h3 id="TmfSymbolProviderUpdatedSignal">TmfSymbolProviderUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示用户已更新符号映射。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>当有更多信息时，由符号提供者或管理者发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由显示特定于映射符号的信息的查看者接收，通常是函数调用。</p>
		<h3 id="TmfTraceSynchronizedSignal">TmfTraceSynchronizedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>该信号用于指示跟踪同步已完成。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>跟踪同步后通过实验发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由需要通知跟踪同步的任何组件接收。</p>
		<h3 id="TmfMarkerEventSourceUpdatedSignal">TmfMarkerEventSourceUpdatedSignal</h3>
		<p>
			<i>目的</i>
		</p>
		<p>此信号用于指示标记事件源已更新。</p>
		<p>
			<i>发件人</i>
		</p>
		<p>由触发标记事件源更改的组件发送。</p>
		<p>
			<i>接收器</i>
		</p>
		<p>由于标记事件源的更改而需要刷新标记的任何组件接收。</p>
		<h2 id="Debugging">调试</h2>
		<p>TMF具有内置的Eclipse跟踪支持，用于调试组件之间的信号交互。要启用它，请打开“ <b>运行/调试配置...”</b>对话框，选择配置，单击“ <b>跟踪”</b>选项卡，选择插件<b>org.eclipse.tracecompass.tmf.core</b> ，然后检查<b>信号</b>项。
		</p>
		<p>发送和接收的所有信号都将记录到Eclipse主目录中的文件TmfTrace.log中。</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="View-Tutorial.html" title="查看教程">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="Developer-Guide.html" title="Trace Compass开发人员指南">
						<img alt="Trace Compass开发人员指南" border="0" src="images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Generic-State-System.html" title="通用国家制度">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">查看教程</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">通用国家制度</td>
			</tr>
		</table>
	</body>
</html><html id="2449.WritingCode.html" dir="ltr"></html><html dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="iso-8859-1"></meta>
    <title>编写代码</title>
    <link rel="stylesheet" type="text/css" href="../help.css"></link>
  </head>
<body dir="ltr">
<div><h1>配置源表单和文件名扩展名</h1><p>Photran支持固定格式和自由格式的Fortran代码。Photran还支持C预处理程序指令，例如Fortran代码中的＃define，＃ifdef，＃include，__ FILE__和__LINE__。
</p><blockquote><small>
<i>固定表格是为打卡设计的旧表格。它在Fortran 77和早期程序中更常见，尽管它仍然是Fortran 2003的一部分。固定形式，“c”，“C”，“*”或“！“在第1列中表示注释;第1列到第5列用于语句标签;第6列中的字符表示连续行;程序语句包含在第7列到第72列中。第72列之后的任何内容都将被忽略。（尽管第72列是在Fortran标准中指定的，但大多数编译器允许您更改它以允许更长的行; Photran也允许您更改它，如下一节所述。）
</i></small>
</blockquote><p>Photran使用文件扩展名来确定文件是固定格式还是自由格式，以及它是否是C预处理的。默认文件扩展名如下。
</p><table cellspacing="0" cellpadding="5" border="1" align="center"><tr><td> 
<b>文件名扩展名</b></td><td> 
<b>来源表格/预处理</b></td></tr><tr><td>.f，.fix，.for，.fpp，.ftn<br>。F， 。F77 ,.FIX ,.FOR ,.FTN ,.FPP，.fpp</td><td>固定来源表格</td></tr><tr><td>.f08，.f03，.f95，.f90</td><td>包含INCLUDE行的免费源表单<br>
</td></tr><tr><td>。F08 ,.F03 ,.F95 ,.F90</td><td>带有C预处理程序指令的自由源表单</td></tr></table><h2>配置源表单/文件名扩展关联</h2><p>上面列出的文件扩展名是新Fortran项目的默认值。要改变它们：</p><ol><li>在Fortran Projects视图中，右键单击项目，然后选择Properties。
</li><li>在左侧的树中，导航到Fortran General&gt; Source Form。
</li><li>对于要更改的每个文件扩展名，请从下拉框中选择相应的源表单。
</li><li>单击“确定”关闭对话框。
</li></ol><p><center>
<img src="../images/Photran-source-form-config.png"></center>
</p><h2>添加其他文件扩展名</h2><p>可以通过更改Eclipse Content Type首选项来添加其他文件扩展名。
</p><ol><li>单击窗口&gt;首选项...（Eclipse&gt; Preferences ...在Mac OS X上）。
<ol><li>在右窗格的“内容类型：”树中，导航到“文本”&gt;“Fortran源文件”。
</li></ol></li><li>单击添加...按钮。
</li><li>要使具有“.fre”文件扩展名的所有文件都被识别为Fortran源代码， <i>请</i>在对话框中输入<i>* .fre</i> 。您也可以通过省略*来指定单个文件名。字首;例如，输入<i>old-fortran-code.txt</i>将使任何名为old-fortran-code.txt的文件被识别为Fortran源代码，而不是其他.txt文件。
</li><li>单击“确定”关闭对话框。
</li></ol><p><b>有关配置内容类型的更多信息，</b>请单击Eclipse中的“帮助”&gt;“帮助内容”，然后导航到<b>Workbench用户指南&gt;参考&gt;首选项&gt;内容类型。
</b></p><h1>配置固定表格线宽</h1><p>虽然自由源形式允许线任意长，但是在固定形式中，存在预定的最大线宽。通常，这是72个字符（即，第72列之后的任何内容都被忽略并视为注释），尽管大多数编译器允许您更改此字符以允许更长的行。Photran允许您更改它。要更改固定格式源中的最大线宽...
</p><ol><li>打开工作台首选项。在Windows或Linux上，单击窗口&gt;首选项;在Mac OS X上，单击Eclipse&gt; Preferences。
</li><li>展开Fortran类别，然后选择Editor。
</li><li>更改标记为“固定表格行长度”的字段的值。该值必须至少为72。
</li></ol><p>如果您有任何固定的表单编辑器打开，关闭并重新打开它们;请注意，最右边的灰色垂直条已移动到指示的列，并且解析器（构造“大纲”视图）已相应调整。
<b>注意：</b>这是工作区范围的首选项：它会影响工作区中的所有固定表单文件。目前无法针对每个项目或每个文件调整此设置。
</p><h1>Fortran透视</h1><p>当您编写Fortran代码时，通常您将使用Fortran透视图。当您创建一个新的Fortran项目（如上所述）时，向导将询问您是否要切换到Fortran透视图，或者您可以通过单击Window&gt; Open Perspective&gt; Other ...并从列表中选择Fortran来手动执行此操作。 。
<b>有关透视图的更多信息，</b>请单击Eclipse中的“帮助”&gt;“帮助内容”，然后导航到“ <b>Workbench用户指南”&gt;“概念”&gt;“透视图”。
</b> Eclipse教程还介绍了透视图，可以在<b>Workbench用户指南&gt;入门&gt;基础教程中找到。
</b>特别要注意，您可以通过单击“窗口”&gt;“显示视图”&gt;“其他...”并从“显示视图”对话框中选择新视图来向透视图添加视图。您还可以将当前透视图重置为其原始布局：从菜单栏中，选择“窗口”&gt;“重置透视图”。默认情况下，Fortran透视图包含用于编辑代码的中心区域以及以下视图：</p><ul><li><b>Fortran项目</b>视图显示您的项目以及其中的所有文件和文件夹。
</li><li>如果Photran可以识别它们，则<b>Problems</b>视图将显示Fortran编译器的错误。（这需要配置<i>错误解析器，</i>本手册的其他部分对此进行了描述。）
</li><li><b>Console</b>视图显示Fortran编译器的输出。运行Fortran程序时，其输出也会显示在Console视图中。
</li><li><b>“</b> <a href="http://wiki.eclipse.org/PTP/photran/documentation/photran7advanced">光子高级功能”手册中</a>介绍了<b>Fortran声明</b>视图。
</li><li>“ <b>大纲”</b>视图显示程序的高级结构，即包含它的子程序，模块，派生类型等。
</li><li><b>Make Targets</b>视图允许您在自定义Makefile中定义的特定目标上快速运行<b>make</b> 。
</li></ul><p><b>有关Make Targets视图的更多信息，请</b>单击Eclipse中的Help&gt; Help Contents，然后导航到<b>C / C ++ Development用户指南&gt;参考&gt; C / C ++视图和编辑器&gt; Make Targets视图。
</b></p><h1>Fortran项目视图</h1><p>Fortran项目视图以树结构显示项目文件。在此视图中，您可以执行以下操作：</p><ul><li>在Fortran编辑器中打开文件</li><li>管理现有文件（剪切，粘贴，删除，移动或重命名）</li><li>创建新项目，文件或文件夹</li><li>导入或导出文件和项目</li><li>浏览Fortran文件中的高级结构</li><li>在新窗口中打开项目</li><li>执行一些多文件重构（例如，介绍隐式无;请参阅<a href="http://wiki.eclipse.org/PTP/photran/documentation/photran7advanced">Photran高级功能手册</a> ）</li></ul><p>双击文件名或右键单击文件并从上下文菜单中选择“打开方式”，即可打开文件。通过右键单击文件并从上下文菜单中选择操作来执行大多数其他操作。Fortran项目视图类似于C / C ++项目视图。
<b>有关Fortran项目视图的更多信息，</b>请单击Eclipse中的“帮助”&gt;“帮助内容”并导航到“ <b>C / C ++开发用户指南”&gt;“参考”&gt;“C / C ++视图和编辑器”&gt;“C / C / C ++项目”视图中的文档。 <b>C ++ Projects视图。
</b></p><h1>使用Fortran编辑器和Fortran透视图</h1><h2>大纲视图</h2><p><center>
<img src="../images/Photran-outline-view.PNG" alt="大纲视图"></center>在Fortran编辑器中打开Fortran文件时，Outline视图显示该文件的结构元素的大纲：子程序，主程序，模块，派生类型等.Outline视图记录了文件的内容类型（自由格式）或固定形式）;它还会在代码中出现错误时注明。要将Outline视图添加到当前透视图，请转到Window&gt; Show View&gt; Other ...&gt; General&gt; Outline。
<center>
<img src="../images/Photran-outline-view-error.PNG" alt="大纲错误"></center>
</p><h2>Fortran编辑器概述</h2><p>Fortran编辑器包含许多功能。要注意的主要功能是编辑器顶部的水平标尺，代码折叠和语法高亮。<b>水平标尺</b>以字符为单位测量编辑器的宽度：编辑器中的每列都有一个符号（ -  / +）或数字。每五个字符显示一个加号（+），每十个字符编号。也可以打开第80列的<b>打印边距</b> （灰色垂直线）;这将在下面标题为“配置编辑器”的部分中进一步讨论。<center>
<img src="../images/Photran-editor-ruler.PNG" alt="编辑统治者"></center>
<b>代码折叠</b>也支持免费的形式编辑器，但打开代码折叠将禁用水平标尺;如何做到这一点也在下面描述。打开折叠时，编辑器左边缘将显示一个减号（ - ），旁边是每个程序，功能，子程序等;单击减号将暂时将该实体的显示折叠为单行。
<center>
<img src="../images/Photran-editor-folding-1.PNG" alt="编辑折叠"></center>编辑器还支持<b>语法突出显示。
</b>当您在Fortran中编写程序时，您会注意到不同的颜色应用于注释，标识符，内在函数，关键字和字符串，以使代码更具可读性。可以在Fortran编辑器首选项中更改前面提到的每个代码组件的颜色（这将在下面的“配置编辑器”一节中讨论）。通常，编辑器甚至可以区分关键字“if”和名为“if”的变量。但是，它并不完美;它使用比驱动Outline视图和所有<a href="http://wiki.eclipse.org/PTP/photran/documentation/photran7advanced">高级功能</a>的实际Fortran解析器更快但不太可靠的启发式算法。
</p><h2>注释/取消注释</h2><p>Photran可以评论或取消注释一个Fortran语句块，放置一个感叹号（！）在陈述之前或分别删除它。在Fortran编辑器中选择语句。然后右键单击所选内容，并从上下文菜单中选择“注释/取消注释”。
<center>
<img src="../images/Photran-comment-action.png"></center>
</p><h2>设置书签</h2><p>书签是Eclipse功能，允许您在文件中标记重要行，然后使用“书签”视图快速跳转到这些行。要设置书签，请右键单击编辑器左侧的灰色栏（位于书签所在的行），然后从弹出菜单中选择“添加书签...”。通过将光标定位在该行上，也可以将书签放置在一行上，转到菜单栏中的编辑&gt;添加书签....在对话框中键入所需的书签名称，然后单击“确定”。蓝色书签将显示在编辑器左侧的灰色栏中。然后可以在“书签”视图中查看书签（“窗口”&gt;“显示视图”&gt;“其他...”，在“常规”文件夹中选择“书签”）。
</p><h2>转到行（Ctrl + L）</h2><p>“Go To Line ...”功能允许您在Fortran编辑器中打开时跳转到文件中的特定行号。在菜单栏中，转到导航&gt;转到行...（或按热键，Windows / Linux上的Ctrl + L或Mac上的Command + L）以打开“转到行”对话框。键入要导航到的行，然后单击“确定”。光标将移动到指定行的开头。
</p><h2>配置编辑器</h2><p><center>
<img src="../images/TheEditor.png"></center>
</p><h3>选择水平标尺与折叠</h3><p>Fortran编辑器既可以显示水平标尺，也可以启用代码折叠，但不能同时启用。要确定将启用哪个，请转到菜单栏中的“窗口”&gt;“首选项”。展开Fortran并选择Editor。选中相应的框以在自由格式和/或固定格式的Fortran编辑器中启用折叠。
</p><h3>设置语法突出显示的颜色</h3><p>可以在Fortran编辑器首选项中修改Fortran语法突出显示的颜色。要修改颜色设置，请转到菜单栏中的“窗口”&gt;“首选项”。展开Fortran并选择Editor。此页面提供了注释，标识符，内在函数，关键字和字符串的颜色选择器。
</p><h3>显示打印边距</h3><p>编辑者可以选择在指定列处显示灰色垂直条;通常，这在列80中设置以充当视觉“打印边缘”。要启用打印边距显示，请转到菜单栏中的窗口&gt;首选项。在常规下，展开编辑器，然后选择文本编辑器。选中“显示打印边距”复选框。或者，您也可以更改将显示打印边距的列。单击“应用”，打印边距现在应显示在编辑器中。
</p><h3>设置固定形式的线长</h3><p>在固定格式中，Fortran指定经过第72列（默认）的任何内容都是注释。但是，可以将其更改为72以外的值。要更改线条的长度，请转到菜单栏中的“窗口”&gt;“首选项”。在Fortran下，选择编辑器。将标记为“固定线条长度”的字段的值更改为所需的线条长度。请注意，行的长度的可接受范围是72-999（含）。
</p><h3>将制表符转换为空格</h3><p>要启用将标签转换为空格，请转到菜单栏中的“窗口”&gt;“首选项”。在常规下，展开编辑器，然后选择文本编辑器。选中“为选项卡插入空格”框，让Eclipse自动将Tabs转换为空格。请注意，这仅适用于您键入的<i>新</i>选项卡;它不会更改您现有的文件。
</p><blockquote><small>只要选项卡全部出现在一行的开头，就很容易用现有文件中的空格替换制表符。（对于行中间的标签，这不会很正常。）（1）将光标移动到文件的开头; （2）点击编辑&gt;查找/替换...; （3）在“查找”框中，键入“\ t”（不带引号）; （4）在“替换为”框中，键入4或8个空格（每个制表符将替换为您键入的内容，因此如果键入四个空格，则每个制表符将替换为四个空格）; （5）选择搜索：转发和范围：全部; （6）检查“正则表达式”框; （7）单击全部替换。这将用空格替换每个制表符。</small>
</blockquote><h3>显示空格</h3><p>可以通过转到窗口&gt;首选项来显示空白字符。在“常规”&gt;“编辑器”&gt;“文本编辑器”下，选中“显示空白字符”旁边的框，然后单击“应用”。现在，空格，制表符和换行符将分别显示为浅灰色双角引号（»），点（·）和段落符号（¶）。
</p><h3>设置字体</h3><p>Photran使用与基本Eclipse文本编辑器相同的字体。要更改它，请单击菜单栏中的“窗口”&gt;“首选项”。在“常规”下，展开“外观”，然后选择“颜色和字体”。搜索您想要的字体。
<center>
<img src="../images/fonts.png"></center>
</p><h3>显示行号</h3><p>行号可以在编辑器的“文本编辑器”首选项页面中显示。转到窗口&gt;首选项。在“常规”&gt;“编辑器”&gt;“文本编辑器”下，选中“显示行号”框，然后单击“应用”。
<center>
<img src="../images/Text_Editors.png"></center>
</p><h3>代码模板</h3><p>代码模板用于使编码更快更容易。输入您输入的任何内容的第一个字母后，按Ctrl + Space键将显示一个选项列表。转到Windows&gt;首选项&gt; Fortran&gt;模板以管理您想要的模板。
<center>
<img src="../images/Code_Templates.png"></center>
</p></div>
</body>
</html><html id="3318.extensions-provide_tabbar_extensions.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>扩展 -  provide_tabbar_extensions</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SiriusProvidetabbarextensions">Sirius  - 提供标签栏扩展</h1>
		<h2 id="Goals">目标</h2>
		<p>所有Sirius图编辑器的顶部区域都填充了<em>tab-bar</em> ，可以访问图表及其元素上的许多操作。标签栏的内容取决于当前选择是图表本身（即没有选择元素）还是一个或多个图表元素。
		</p>
		<p>选择图表本身（而不是特定元素）时，选项卡栏包含以下按钮：<br>	
			<img border="0" src="images/tabbar01.png">
		</p>
		<p>当至少选择一个元素时，选项卡栏包含一组不同的操作：<br>	
			<img border="0" src="images/tabbar02.png">
		</p>
		<p>Sirius允许定义新操作并在选项卡栏的末尾添加它们。</p>
		<h2 id="Addanewtabbaritem">添加新的标签栏项目</h2>
		<p>Sirius要求工作台的<code>IMenuService</code>服务用提供的贡献填充选项卡栏。此服务依赖于<code>org.eclipse.ui.menus</code>扩展点。
		</p>
		<p>Sirius将标签栏定义为具有id <em>org.eclipse.sirius.diagram.ui.tabbar</em>的工具栏。
			<br>必须使用<em>工具栏</em>方案和Sirius选项卡栏ID声明对tab-bar的菜单贡献。
		</p>
		<p>您可以使用<em>locationUri</em>的插入点部分来组织您的贡献。Sirius定义了<em>添加</em>组，该组和所有贡献将放在标签栏的末尾。
		</p>
		<p>您可以选择何时使用<em>visibleWhen</em>元素和一些属性测试器使您的贡献可见（参见示例）：显示用于图表选择的菜单或仅在具有特定描述的某个图表上显示，...Sirius定义了几个属性测试器，如<em>org.eclipse.sirius.diagram.ui.isDDiagram</em>和<em>org.eclipse.sirius.diagram.ui.isDDiagramElement</em> ，但您可以定义自己的域特定测试器。
		</p>
		<h3 id="Provideyourtabbaritemsusingtheorg.eclipse.ui.menusextensionpoint">使用<code>org.eclipse.ui.menus</code>扩展点提供标签栏项</h3>
		<p>有关更多详细信息，请参阅此扩展点文档。</p>
		<h3 id="Provideyouroperationusingtheorg.eclipse.ui.commandsextensionpoint">使用<code>org.eclipse.ui.commands</code>扩展点提供您的操作</h3>
		<p>有关更多详细信息，请参阅此扩展点文档。</p>
		<h3 id="Example">例</h3>
		<p>以下示例为选项卡栏定义了一个新按钮。只有在图表中选择了与特定描述相对应的元素时，才会显示该贡献。</p>
		<p>您必须在plugin.xml文件中添加菜单贡献。</p>
		<p>	
			<img border="0" src="images/tabbar_extension_plugin_xml.png">
		</p>
		<p>第一步是创建菜单贡献以引用现有命令：</p>
		<pre>&lt;extension point =“org.eclipse.ui.menus”&gt; &lt;menuContribution allPopups =“false”locationURI =“toolbar：org.eclipse.sirius.diagram.ui.tabbar？after = additions“&gt; &lt;command commandId =”org.example.myproject.command.id“icon =”images / action.gif“id =”org.eclipse.sirius.diagram.tabbar.test.action.on.diagramelement“ label =“DDiagramElement上的操作”tooltip =“DDiagramElement上的操作”&gt; &lt;！ -  [...]一个可见的元素将在以后添加以控制可见性 - &gt; &lt;/ command&gt; &lt;/ menuContribution&gt; &lt;/ extension &gt;</pre>
		<p><em>locationURI</em>引用带有<code>toolbar:org.eclipse.sirius.diagram.ui.tabbar</code>的Sirius tabbar <code>toolbar:org.eclipse.sirius.diagram.ui.tabbar</code>和插入点<code>?after=additions</code> 。
			<br>command元素引用现有的<em>commandID</em> ，并定义自己的菜单ID（可用作其他贡献<em>locationURI中的</em>插入/组织点），其标签和工具提示。如果引用的命令上存在键绑定，则工作台会将其添加到工具提示中。
		</p>
		<p>然后，您可以使用可见的when元素控制贡献的可见性。</p>
		<pre>&lt;！ -  [...]继续上面的示例 - &gt; &lt;visibleWhen checkEnabled =“false”&gt; &lt;和&gt; &lt;with variable =“activeEditorId”&gt; &lt;equals value =“org.eclipse.sirius.diagram.ui 。部分。SiriusDiagramEditorID“/&gt; &lt;/ with&gt; &lt;with variable =”activeEditor“&gt; &lt;test property =”org.eclipse.sirius.sample.tabbar.isConcernedEditor“/&gt; &lt;/ with&gt; &lt;with variable =”selection“&gt; &lt;iterate ifEmpty =“false”operator =“或”&gt; &lt;和&gt; &lt;test property =“org.eclipse.sirius.diagram.ui.isDDiagramElement”/&gt; &lt;test property =“org.eclipse.sirius.sample.tabbar.shouldActivateTabbarExtension”/ &gt; &lt;/和&gt; &lt;/ iterate&gt; &lt;/ with&gt; &lt;/ and&gt; &lt;/ visibleWhen&gt; &lt;/ command&gt;</pre>
		<p>示例贡献声明了四个条件以启用其可见性：</p>
		<ul>
			<li>它使用工作台变量<em>activeEditorId</em>和Sirius Diagram Editor id检查活动编辑器是Sirius Diagram Editor。
			</li>
			<li>如果活动编辑器应该触发贡献可见性，它会询问属性测试器（请参阅下一节中的示例属性测试器说明）</li>
			<li>它使用元素之间的“OR”运算符和空选择的错误结果迭代选择：<ul>
					<li>它使用Sirius预定义属性测试器来检查所选元素是否为图元素。</li>
					<li>它询问属性测试器当前元素是否应该触发贡献可见性（参见下一节的样本属性测试器说明）</li>
				</ul>
			</li>
		</ul>
		<p>属性测试器在plug-in.xml文件中定义。它们定义了命名空间，一些属性以及它们可以测试的元素类型。</p>
		<pre>&lt;extension point =“org.eclipse.core.expressions.propertyTesters”&gt; &lt;propertyTester class =“org.eclipse.sirius.sample.tabbar。SampleTestTabbarExtensionActivationPropertyTester“id =”org.eclipse.sirius.sample.tabbar。ActiveExtensionTester“namespace =”org.eclipse.sirius.sample.tabbar“properties =”shouldActivateTabbarExtension“type =”org.eclipse.gmf.runtime.diagram.ui.editparts。IGraphicalEditPart“&gt; &lt;/ propertyTester&gt; &lt;propertyTester class =”org.eclipse.sirius.sample.tabbar。SampleTestTabbarExtensionActivationPropertyTester“id =”org.eclipse.sirius.sample.tabbar。ConcernEditorTester“namespace =”org.eclipse.sirius.sample.tabbar“properties =”isConcernedEditor“type =”org.eclipse.ui。IEditorPart“&gt; &lt;/ propertyTester&gt; &lt;/ extension&gt;</pre>
		<p>这是相应属性测试器的实现。<em>isConcerned</em>属性将导致检查当前编辑器的<code>DiagramDescription</code> id。<em>shouldActivateTabbarExtension</em>将导致检查所选域对象的属性。
		</p>
		<pre><code>包org.eclipse.sirius.sample.tabbar; import org.eclipse.core.expressions。PropertyTester; import org.eclipse.emf.ecore。的EClass; import org.eclipse.emf.ecore。EObject; import org.eclipse.sirius.diagram。DDiagram; import org.eclipse.sirius.diagram。DRepresentation; import org.eclipse.sirius.diagram.edit.api.part。IDiagramElementEditPart; import org.eclipse.sirius.ui.business.api.dialect。DialectEditor; / ** *样品属性测试仪。* * @author mporhel * / public class SampleTestTabbarExtensionActivationPropertyTester扩展了PropertyTester {public boolean test（Object receiver，String property，Object [] args，Object expectedValue）{if（“isConcernedEditor”.equals（property））{//在with中调用activeEditor元素if（receiver instanceof DialectEditor）{DRepresentation activeRepresentation =（（DialectEditor）receiver）.getRepresentation（）; if（activeRepresentation instanceof DDiagram）{// VSM编辑器中的id属性：meta //模型中的名称。return“diagram.description.sample.id”.equals（（（DDiagram）activeRepresentation）.getDescription（）。getName（））; else if（“shouldActivateTabbarExtension”.equals（property））{if（receiver instanceof IDiagramElementEditPart）{EObject domainElement =（（IDiagramElementEditPart）receiver）.resolveTargetSemanticElement（）; // sample condition返回domainElement instanceof EClass &amp;&amp;（（EClass）domainElement）.isAbstract（）;返回false; }}</code></pre>
		<p>仅当选择包含抽象<code>EClass</code>并且活动编辑器对应于预期描述ID时，才会将新按钮添加到选项卡栏：</p>
		<p>	
			<img border="0" src="images/tabbar_extension_result.png">
		</p>
		<h2 id="contributeFullTabbar">提供完整的自定义标签栏</h2>
		<p>Sirius可以提供整个定制标签栏。为此，开发人员必须提供<code>org.eclipse.sirius.diagram.ui.tools.api.editor.tabbar.ITabbarContributor</code>到<code>org.eclipse.sirius.diagram.ui.tabbarContributor</code>扩展点。存在<code>ITabbarContributor</code>的抽象实现： <code>org.eclipse.sirius.diagram.ui.tools.api.editor.tabbar.AbstractTabbarContributor</code> 。此实现包含受保护的方法，允许创建默认Sirius选项卡栏的一个或多个贡献。有关每个项目的更多详细信息，请参阅用户手册中的<a href="../user/diagrams/Diagrams.html#ref_tabbar">标签栏</a>部分。
		</p>
		<p>以下是<code>ITabbarContributor</code>实现的示例。此示例提供了两个不同的选项卡栏，无论选择是在图表元素（例如节点还是容器）上完成，还是在图表上完成（没有特定选择）。如果在Edge上完成选择，则选项卡栏将为空，因为样本不返回任何contributionItem。
		</p>
		<pre><code>公共类TestTabbarExt扩展AbstractTabbarContributor {private ArrayList &lt;IContributionItem&gt; diagramContributionItems; private ArrayList &lt;IContributionItem&gt; diagramElementContributionItems; @Override public List &lt;IContributionItem&gt; getContributionItems（ISelection selection，IDiagramWorkbenchPart part，ToolBarManager manager）{List &lt;IContributionItem&gt; contributionsItems = new ArrayList &lt;IContributionItem&gt;（）; if（选择instanceof IStructuredSelection）{Object firstElement =（（IStructuredSelection）selection）.getFirstElement（）; if（abstractElement instanceof AbstractDDiagramEditPart）{contributionItems = getDiagramContributionItem（part，manager）; } else if（firstElement instanceof IAbstractDiagramNodeEditPart）{contributionItems = getDiagramElementContributionItem（part，manager）;返回contributionItems; } @Override public boolean accept（ISelection selection）{boolean accept = false; if（selection == null）{accept = true; } else if（selection instanceof IStructuredSelection）{Object firstElement =（（IStructuredSelection）selection）.getFirstElement（）; if（firstElement instanceof AbstractDDiagramEditPart || firstElement instanceof IAbstractDiagramNodeEditPart）{accept = true; } return accept; } @Override public List &lt;IContributionItem&gt; getContributionItems（IDiagramWorkbenchPart part，ToolBarManager manager）{return getDiagramContributionItem（part，manager）; private List &lt;IContributionItem&gt; getDiagramContributionItem（IDiagramWorkbenchPart part，ToolBarManager manager）{if（diagramContributionItems == null）{diagramContributionItems = new ArrayList &lt;IContributionItem&gt;（）; diagramContributionItems.add（createArrangeMenuManager（部分））; diagramContributionItems.add（createSelectMenuManager（））; diagramContributionItems.add（createLayerContribution（part，manager））; diagramContributionItems.add（createZoomInContribution（部分））; diagramContributionItems.add（createZoomOutContribution（部分））; diagramContributionItems.add（createZoomContribution（部分））; diagramContributionItems.add（createSelectPinnedElementsContribution（部分））; diagramContributionItems.add（createSelectHiddenElementsContribution（部分））; diagramContributionItems.add（createFilterContribution（part，manager））; diagramContributionItems.add（createPasteFormatContribution（部分））; diagramContributionItems.add（createRefreshContribution（））; diagramContributionItems.add（createSaveAsImageContributionItem（））; diagramContributionItems.add（createModeMenuManagerContributionItem（部分））; diagramContributionItems.add（createCopyAppearancePropertiesContribution（部分））; diagramContributionItems.add（createCopyFormatContribution（部分））; } return diagramContributionItems; private List &lt;IContributionItem&gt; getDiagramElementContributionItem（IDiagramWorkbenchPart part，ToolBarManager manager）{if（diagramElementContributionItems == null）{diagramElementContributionItems = new ArrayList &lt;IContributionItem&gt;（）; diagramElementContributionItems.add（createArrangeMenuManager（部分））; diagramElementContributionItems.add（createAlignMenuManager（））; diagramElementContributionItems.add（createHideElementLabelContribution（部分））; diagramElementContributionItems.add（createHideElementContribution（部分））; diagramElementContributionItems.add（createDeleteFromDiagramContribution（部分））; diagramElementContributionItems.add（createDeleteFromModelContribution（部分））; IContributionItem pinElementContributionItem = createPinElementContribution（part）; diagramElementContributionItems.add（pinElementContributionItem）; diagramElementContributionItems.add（createUnPinElementContribution（part，pinElementContributionItem））; diagramElementContributionItems.add（createFontColorContribution（部分））; diagramElementContributionItems.add（createPasteFormatContribution（部分））; diagramElementContributionItems.add（createBoldFontStyleContribution（部分））; diagramElementContributionItems.add（createItalicFontStyleContribution（部分））; diagramElementContributionItems.add（createFontDialogContribution（部分））; diagramElementContributionItems.add（createFillColorContribution（部分））; diagramElementContributionItems.add（createLineColorPropertyContribution（部分））; diagramElementContributionItems.add（createResetStylePropertyContribution（部分））; diagramElementContributionItems.add（createSetStyleToWorkspaceImageContribution（部分））; diagramElementContributionItems.add（createSaveAsImageContributionItem（））; diagramElementContributionItems.add（createDistributeContribution（））; diagramElementContributionItems.add（createModeMenuManagerContributionItem（部分））; diagramElementContributionItems.add（createRouterContribution（））; diagramElementContributionItems.add（createCopyAppearancePropertiesContribution（部分））; diagramElementContributionItems.add（createCopyFormatContribution（部分））; diagramElementContributionItems.add（createSizeBothContribution（部分））; diagramElementContributionItems.add（createAutoSizeContribution（部分））; } return diagramElementContributionItems; }}</code></pre>
	</body>
</html><html id="1902.s9.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s8.html" rel="prev">&lt;&lt;§8加入点查询</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sA.html" rel="next">§AOT / J语法&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="chapter" id="s9">
            <div class="headl">
               <div class="headr">
                  <h1>§9价值依赖类</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s9.html">§9价值依赖类</a></li>
                  <li><a href="#s9.1">§9.1使用值参数定义类</a></li>
                  <li><a href="#s9.2">§9.2使用带有值参数的类</a></li>
                  <li><a href="#s9.3">§9.3限制和限制</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>概括外化角色</h3>
               <div class="line"></div>
               <div class="term">键入值参数</div>
               <div class="termdesc">除了常规泛型之外，类可以声明表示对象值的参数。这样的值参数被称为此类的<strong>类型锚</strong> ，该类的类型被称为<strong>锚定</strong>到此参数。
               </div>
               <div class="line"></div>
               <div class="term">价值依赖类</div>
               <div class="termdesc">声明一个或多个值参数的类取决于其锚点表示的运行时实例。
               </div>
               <div class="line"></div>
               <div class="term">外化角色</div>
               <div class="termdesc">外化角色的概念（ <a href="s1.html#s1.2.2" title="§1.2.2外化角色" class="sect">§1.2.2</a> ）是这里提出的概念的一个特例。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s9.1">
               <h2 class="sect">§9.1使用值参数定义类<a class="img" href="s9.html#s9.1" title="PermaLinkto§9.1使用值参数定义类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.9.1" title="§A.9.1TypeParameter" class="syntax">→语法§A.9.1</a></div>
               <div class="subsect depth3" id="s9.1.a">
                  <h4 class="subsect">（a） <span class="title">价值参数声明</span><a class="img" href="s9.html#s9.1.a" title="PermaLink到（a）值参数声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在标记泛型类的参数的尖括号内，也可以声明值参数。与类型参数相反，值参数表示为一对两个标识符：类型和自由名称，例如，</p>
                  <div class="listing plain"><pre><b>class</b> MyClass <em>&lt;YourType aName&gt;</em> {...</pre></div>
                  <p>请注意，值参数仅对类有效，对接口无效。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.1.b">
                  <h4 class="subsect">（b） <span class="title">价值参数申请</span><a class="img" href="s9.html#s9.1.b" title="PermaLink到（b）值参数应用程序"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在给定的类（ <code>MyClass</code> ）中，参数名称（ <code>aName</code> ）可以像给定类型的最终字段（ <code>YourType</code> ）一样使用。与常规final字段相比，甚至在执行构造函数之前就会发生对此名称的赋值。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.1.c">
                  <h4 class="subsect">（c） <span class="title">角色类型作为依赖类型</span><a class="img" href="s9.html#s9.1.c" title="PermaLink到（c）角色类型作为依赖类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>任何角色类型都可以解释为值依赖类型，但是，在角色类型的声明中，value参数仍然是隐式的：它与封闭的团队实例相同。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s9.2">
               <h2 class="sect">§9.2使用带有值参数的类<a class="img" href="s9.html#s9.2" title="PermaLinkto§9.2使用带有值参数的类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.9.2" title="§A.9.2ActactTypeArgument" class="syntax">→语法§A.9.2</a></div>
               <p>当使用声明一个或多个值参数（类型锚点）的类时，必须提供相应的<strong>锚值</strong> 。
                  		
               </p>
               <div class="sect depth3" id="s9.2.1">
                  <h3 class="sect">§9.2.1参数替换<a class="img" href="s9.html#s9.2.1" title="PermaLinkto§9.2.1参数替换"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s9.2">↑§9.2</a></span></h3>
                  <p><code>MyClass&lt;YourType p&gt;</code>类的类型锚的替换表示为<code>MyClass&lt;@v&gt;</code> 。在这个术语中， <code>v</code>必须是一个符合值参数“ <code>YourType p</code> ”声明的值，即， <code>v</code>必须具有静态类型<code>YourType</code> 。
                     	<br>替换类型锚的传递值必须是声明为<code>final</code>的变量的路径。显然，只有这样一个路径中的第一个元素可以是局部变量或方法参数，所有其他元素都必须是字段。需要最终变量的原因在于类型检查，如下所述。
                     			
                  </p>
                  <div class="note">
                     <h5>注意：</h5><a href="s1.html#s1.2.2.b" title="§1.2.2。（b）具有锚定类型的声明" class="sect">§1.2.2。（b）</a>中定义的外部化角色是具有值参数的类型的特例，其中值是封闭团队的实例。
                     			
                  </div>
                  <div class="subsect depth4" id="s9.2.1.a">
                     <h4 class="subsect">（a） <span class="title">实例约束类型参数</span><a class="img" href="s9.html#s9.2.1.a" title="PermaLink到（a）实例约束类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>除了正常使用之外，还可以将值参数嵌套到常规类型参数中：</p>
                     <div class="listing plain"><pre><b>class</b> MyClass &lt;YourType aName，DependentParam &lt; <em>@aName</em> &gt;&gt; {...</pre></div>
                     <p>这里，类型参数<code>DependentParam</code>被约束为锚定到<code>aName</code> 。
                        				
                     </p>
                     <p>如果将value参数用作常规类型参数的约束，则对type参数的任何替换也必须提供与value参数匹配的值。上面的类可以像这样应用：</p>
                     <div class="listing plain"><pre><b>final</b> YourType anchor = <b>new</b> YourType（）; MyClass <em>&lt;@anchor，YourDependent &lt; <strong>@anchor</strong> &gt;&gt;</em></pre></div>
                     <p>在声明元素（类或方法）中，表示实例约束类型参数的类型变量的应用程序必须逐字重复锚，即，此处不执行替换。
                        				
                     </p>
                  </div>
               </div>
               <div class="sect depth3" id="s9.2.2">
                  <h3 class="sect">§9.2.2类型一致性<a class="img" href="s9.html#s9.2.2" title="PermaLinkto§9.2.2类型一致性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s9.2">↑§9.2</a></span></h3>
                  <p>仅当两种类型的锚引用<i>相同的对象时，</i>才认为两种依赖于值的类型（锚定类型）是一致<i>的</i> 。编译器必须能够静态分析此锚标识。
                     			
                  </p>
                  <div class="subsect depth4" id="s9.2.2.a">
                     <h4 class="subsect">（a） <span class="title">类型锚的替代品</span><a class="img" href="s9.html#s9.2.2.a" title="PermaLink to（a）类型锚的替代"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>仅考虑两次替换来确定锚点身份：</p>
                     <ol>
                        <li>如果方法签名使用<code>this</code>作为其任何类型的锚，则类型检查此方法的应用程序将执行以下替换：<br>一个简单的<code>this</code>表达是由该方法的应用程序的实际呼叫目标取代。
                           <br>合格的<code>Outer.this</code>表达式由调用目标的相应封闭实例替换。
                        </li>
                        <li>传递上遵循从<code>final</code>标识符到另一个<code>final</code>标识符的分配，即，如果<code>t1, t2</code>是最终的，则在赋值<code>t1=t2</code> ，类型<code>C&lt;@t1&gt;</code>和<code>C&lt;@t2&gt;</code>被认为是相同的。否则<code>C&lt;@t1&gt;</code>和<code>C&lt;@t2&gt;</code>是不可通约的。
                           					<br>将实际参数附加到方法调用中的形式参数也被视为关于此规则的赋值。
                        </li>
                     </ol>
                  </div>
                  <div class="subsect depth4" id="s9.2.2.b">
                     <h4 class="subsect">（b） <span class="title">原始类型的一致性</span><a class="img" href="s9.html#s9.2.2.b" title="PermaLink（b）原始类型的一致性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在证明锚点相同之后，使用标准Java规则检查原始类型的兼容性。
                        				
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s9.3">
               <h2 class="sect">§9.3限制和限制<a class="img" href="s9.html#s9.3" title="PermaLink至§9.3限制和限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="subsect depth3" id="s9.3.a">
                  <h4 class="subsect">（a） <span class="title">没有压倒一切</span><a class="img" href="s9.html#s9.3.a" title="永久链接到（a）没有覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>无法覆盖在团队外部声明的值参数的类型，因为角色可以是。因此，隐式继承不适用于这些类型。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.3.b">
                  <h4 class="subsect">（b） <span class="title">只有第一个参数</span><a class="img" href="s9.html#s9.3.b" title="PermaLink到（b）只有第一个参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <div class="note">
                     <p>目前，只有类的第一个参数可以是值参数。将来可能会删除此限制。
                     </p>
                  </div>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s8.html" rel="prev">&lt;&lt;§8加入点查询</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sA.html" rel="next">§AOT / J语法&gt;&gt;</a></td>
            </tr>
         </table>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="2229.s9.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s8.html" rel="prev">&lt;&lt;§8加入点查询</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sA.html" rel="next">§AOT / J语法&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
         <div class="chapter" id="s9">
            <div class="headl">
               <div class="headr">
                  <h1>§9价值依赖类</h1>
               </div>
            </div>
            <div id="toc-box">
               <ul class="toc-box">
                  <li><a href="s9.html">§9价值依赖类</a></li>
                  <li><a href="#s9.1">§9.1使用值参数定义类</a></li>
                  <li><a href="#s9.2">§9.2使用带有值参数的类</a></li>
                  <li><a href="#s9.3">§9.3限制和限制</a></li>
               </ul>
            </div>
            <div class="intro">
               <h3>概括外化角色</h3>
               <div class="line"></div>
               <div class="term">键入值参数</div>
               <div class="termdesc">除了常规泛型之外，类可以声明表示对象值的参数。这样的值参数被称为此类的<strong>类型锚</strong> ，该类的类型被称为<strong>锚定</strong>到此参数。
               </div>
               <div class="line"></div>
               <div class="term">价值依赖类</div>
               <div class="termdesc">声明一个或多个值参数的类取决于其锚点表示的运行时实例。
               </div>
               <div class="line"></div>
               <div class="term">外化角色</div>
               <div class="termdesc">外化角色的概念（ <a href="s1.2.2.html" title="§1.2.2外化角色" class="sect">§1.2.2</a> ）是这里提出的概念的一个特例。
               </div>
               <div class="line"></div>
            </div>
            <div class="sect depth2" id="s9.1">
               <h2 class="sect">§9.1使用值参数定义类<a class="img" href="s9.1.html" title="PermaLinkto§9.1使用值参数定义类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.9.1" title="§A.9.1TypeParameter" class="syntax">→语法§A.9.1</a></div>
               <div class="subsect depth3" id="s9.1.a">
                  <h4 class="subsect">（a） <span class="title">价值参数声明</span><a class="img" href="s9.1.a.html" title="PermaLink到（a）值参数声明"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在标记泛型类的参数的尖括号内，也可以声明值参数。与类型参数相反，值参数表示为一对两个标识符：类型和自由名称，例如，</p>
                  <div class="listing plain"><pre><b>class</b> MyClass <em>&lt;YourType aName&gt;</em> {...</pre></div>
                  <p>请注意，值参数仅对类有效，对接口无效。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.1.b">
                  <h4 class="subsect">（b） <span class="title">价值参数申请</span><a class="img" href="s9.1.b.html" title="PermaLink到（b）值参数应用程序"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>在给定的类（ <code>MyClass</code> ）中，参数名称（ <code>aName</code> ）可以像给定类型的最终字段（ <code>YourType</code> ）一样使用。与常规final字段相比，甚至在执行构造函数之前就会发生对此名称的赋值。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.1.c">
                  <h4 class="subsect">（c） <span class="title">角色类型作为依赖类型</span><a class="img" href="s9.1.c.html" title="PermaLink到（c）角色类型作为依赖类型"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>任何角色类型都可以解释为值依赖类型，但是，在角色类型的声明中，value参数仍然是隐式的：它与封闭的团队实例相同。
                     			
                  </p>
               </div>
            </div>
            <div class="sect depth2" id="s9.2">
               <h2 class="sect">§9.2使用带有值参数的类<a class="img" href="s9.2.html" title="PermaLinkto§9.2使用带有值参数的类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="syntaxlink"><a href="sA.html#sA.9.2" title="§A.9.2ActactTypeArgument" class="syntax">→语法§A.9.2</a></div>
               <p>当使用声明一个或多个值参数（类型锚点）的类时，必须提供相应的<strong>锚值</strong> 。
                  		
               </p>
               <div class="sect depth3" id="s9.2.1">
                  <h3 class="sect">§9.2.1参数替换<a class="img" href="s9.2.1.html" title="PermaLinkto§9.2.1参数替换"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s9.2">↑§9.2</a></span></h3>
                  <p><code>MyClass&lt;YourType p&gt;</code>类的类型锚的替换表示为<code>MyClass&lt;@v&gt;</code> 。在这个术语中， <code>v</code>必须是一个符合值参数“ <code>YourType p</code> ”声明的值，即， <code>v</code>必须具有静态类型<code>YourType</code> 。
                     	<br>替换类型锚的传递值必须是声明为<code>final</code>的变量的路径。显然，只有这样一个路径中的第一个元素可以是局部变量或方法参数，所有其他元素都必须是字段。需要最终变量的原因在于类型检查，如下所述。
                     			
                  </p>
                  <div class="note">
                     <h5>注意：</h5><a href="s1.2.2.b.html" title="§1.2.2。（b）具有锚定类型的声明" class="sect">§1.2.2。（b）</a>中定义的外部化角色是具有值参数的类型的特例，其中值是封闭团队的实例。
                     			
                  </div>
                  <div class="subsect depth4" id="s9.2.1.a">
                     <h4 class="subsect">（a） <span class="title">实例约束类型参数</span><a class="img" href="s9.2.1.a.html" title="PermaLink到（a）实例约束类型参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>除了正常使用之外，还可以将值参数嵌套到常规类型参数中：</p>
                     <div class="listing plain"><pre><b>class</b> MyClass &lt;YourType aName，DependentParam &lt; <em>@aName</em> &gt;&gt; {...</pre></div>
                     <p>这里，类型参数<code>DependentParam</code>被约束为锚定到<code>aName</code> 。
                        				
                     </p>
                     <p>如果将value参数用作常规类型参数的约束，则对type参数的任何替换也必须提供与value参数匹配的值。上面的类可以像这样应用：</p>
                     <div class="listing plain"><pre><b>final</b> YourType anchor = <b>new</b> YourType（）; MyClass <em>&lt;@anchor，YourDependent &lt; <strong>@anchor</strong> &gt;&gt;</em></pre></div>
                     <p>在声明元素（类或方法）中，表示实例约束类型参数的类型变量的应用程序必须逐字重复锚，即，此处不执行替换。
                        				
                     </p>
                  </div>
               </div>
               <div class="sect depth3" id="s9.2.2">
                  <h3 class="sect">§9.2.2类型一致性<a class="img" href="s9.2.2.html" title="PermaLinkto§9.2.2类型一致性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#s9.2">↑§9.2</a></span></h3>
                  <p>仅当两种类型的锚引用<i>相同的对象时，</i>才认为两种依赖于值的类型（锚定类型）是一致<i>的</i> 。编译器必须能够静态分析此锚标识。
                     			
                  </p>
                  <div class="subsect depth4" id="s9.2.2.a">
                     <h4 class="subsect">（a） <span class="title">类型锚的替代品</span><a class="img" href="s9.2.2.a.html" title="PermaLink to（a）类型锚的替代"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>仅考虑两次替换来确定锚点身份：</p>
                     <ol>
                        <li>如果方法签名使用<code>this</code>作为其任何类型的锚，则类型检查此方法的应用程序将执行以下替换：<br>一个简单的<code>this</code>表达是由该方法的应用程序的实际呼叫目标取代。
                           <br>合格的<code>Outer.this</code>表达式由调用目标的相应封闭实例替换。
                        </li>
                        <li>传递上遵循从<code>final</code>标识符到另一个<code>final</code>标识符的分配，即，如果<code>t1, t2</code>是最终的，则在赋值<code>t1=t2</code> ，类型<code>C&lt;@t1&gt;</code>和<code>C&lt;@t2&gt;</code>被认为是相同的。否则<code>C&lt;@t1&gt;</code>和<code>C&lt;@t2&gt;</code>是不可通约的。
                           					<br>将实际参数附加到方法调用中的形式参数也被视为关于此规则的赋值。
                        </li>
                     </ol>
                  </div>
                  <div class="subsect depth4" id="s9.2.2.b">
                     <h4 class="subsect">（b） <span class="title">原始类型的一致性</span><a class="img" href="s9.2.2.b.html" title="PermaLink（b）原始类型的一致性"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                     <p>在证明锚点相同之后，使用标准Java规则检查原始类型的兼容性。
                        				
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect depth2" id="s9.3">
               <h2 class="sect">§9.3限制和限制<a class="img" href="s9.3.html" title="PermaLink至§9.3限制和限制"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a> <span class="toplink"><a href="#top">↑§9</a></span></h2>
               <div class="subsect depth3" id="s9.3.a">
                  <h4 class="subsect">（a） <span class="title">没有压倒一切</span><a class="img" href="s9.3.a.html" title="永久链接到（a）没有覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <p>无法覆盖在团队外部声明的值参数的类型，因为角色可以是。因此，隐式继承不适用于这些类型。
                     			
                  </p>
               </div>
               <div class="subsect depth3" id="s9.3.b">
                  <h4 class="subsect">（b） <span class="title">只有第一个参数</span><a class="img" href="s9.3.b.html" title="PermaLink到（b）只有第一个参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
                  <div class="note">
                     <p>目前，只有类的第一个参数可以是值参数。将来可能会删除此限制。
                     </p>
                  </div>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s8.html" rel="prev">&lt;&lt;§8加入点查询</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sA.html" rel="next">§AOT / J语法&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="0027.ScriptingWithJava.23.2.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>如何创建事件处理程序类并将其添加到Java项目中</title>
    <link rel="StyleSheet" href="css/ScriptingWithJava.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ScriptingWithJava.23.1.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="ScriptingWithJava.23.3.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h4 class="N_hth_HowToHelp"><a name="182543">如何创建事件处理程序类并将其添加到Java项目中</a></h4>
      <p class="b_Body"><a name="182544">本节描述使用Eclipse Java开发环境为可编写脚本的BIRT元素创建事件处理程序类的过程。这些步骤假定Java透视图是打开的，并且工作区中存在Java项目。</a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="255727">将org.eclipse.birt.report.engine_ &lt;version&gt; .jar添加到Java项目中，如以下步骤所述：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="255763">在Navigator中，选择一个Java项目，然后选择“文件”</a> <span class="Dingbat">→“</span>属性”。在Properties中，选择Java Build Path <span class="Dingbat">→</span> Libraries。在Java Build Path中，选择Add External JARs。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="255769">在JAR Selection中，导航到Eclipse / plugins目录。在默认的Eclipse安装中，此目录位于以下位置：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="cfi2_CodeFirstIndent2"><a name="255543">&lt;ECLIPSE_INSTALL&gt; \蚀\插件</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="315585">选择org.eclipse.birt.core_ &lt;version&gt; .jar。使用control-click选择org.eclipse.birt.report.engine_ &lt;version&gt; .jar。选择打开。出现Java Build Path，</a> <a href="#315594" title="如何创建事件处理程序类并将其添加到Java项目中">如图23-1</a> 所示</a> 。选择确定。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i3_Image3"><a name="315592"><img class="Default" src="images/JavaProjectPropertiesDialog.png" alt="图23-1构建路径中的报表引擎JAR文件" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3TitleFirst">
        <b class="Bold">图23-1</b> <a name="315594">构建路径中的报表引擎JAR文件</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257077">选择Java项目，然后选择“文件”</a> <span class="Dingbat">→“</span>新建” <span class="Dingbat">→“</span>类”。</div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257081">要设置Java类属性，请在New Java Class中执行以下步骤：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="260496">通过选择“源文件夹”旁边的“浏览”按钮，导航到希望Java源文件所在的文件夹。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="260497">如果新Java类是包的一部分，请在Package中键入完全限定的包名。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="191234">在“名称”中，键入类的名称。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="191235">在“修改器”中，选择“公共”</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="191236">选择要扩展的ROM元素事件适配器类：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173199999999997pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="256987">选择Superclass旁边的Browse按钮。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173199999999997pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="257017">在“超类选择”的“选择类型”中，键入ROM元素的事件适配器类的名称。例如，对于label元素，键入LabelEventAdapter，</a> <a href="#295509" title="如何创建事件处理程序类并将其添加到Java项目中">如图23-2</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i4_Image4"><a name="257021"><img class="Default" src="images/superclassSelection.png" alt="图23-2选择超类" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc4_FigCall4Title">
        <b class="Bold">图23-2</b> <a name="295509">选择超类</a></div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173199999999997pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="295510">选择确定。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="295512">在New Java Class中，选择Generate comments。New Java Class看起来类似于</a> <a href="#255894" title="How to create an event handler class and add it to the Java project">图23-3</a> 中</a> <a href="#255894" title="如何创建事件处理程序类并将其添加到Java项目中">所示的类</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="255892"><img class="Default" src="images/JavaClass.png" alt="图23-3 New Java Class final属性" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图23-3</b> <a name="255894">New Java Class final属性</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257151">选择完成。出现Java编辑器，类似于</a> <a href="#210837" title="如何创建事件处理程序类并将其添加到Java项目中">图23-4中</a> 所示的编辑器</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="182568"><img class="Default" src="images/MyLabelClass.png" alt="图23-4 Java编辑器中的新类" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图23-4</b> <a name="210837">Java编辑器中的新类</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="182569">为事件处理程序类添加事件处理程序方法。导入所有必需的类。</a><a href="#210863" title="如何创建事件处理程序类并将其添加到Java项目中">图23-5</a>显示了添加onPrepare（）方法，该方法将标签的背景颜色设置为红色。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="188765"><img class="Default" src="images/MyLabelClass2.png" alt="图23-5 Java编辑器中的onPrepare（）方法" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图23-5</b> <a name="210863">Java编辑器中的onPrepare（）方法</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732pt;white-space:nowrap">
                <span class="zAuto_0023Format">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="257243">选择文件</a> <span class="Dingbat">→</span>保存。</div>
            </td>
          </tr>
        </table>
      </div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="0474.about.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
    <title>Eclipse公共许可证 -  2.0版</title>
    <style type="text/css">body {
  margin: 1.5em 3em;
}
h1 {
  font-size: 1.5em;
}
h2 {
  font-size: 1em;
  margin-bottom: 0.5em;
  margin-top: 1em;
}
p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
ul, ol {
  list-style-type: none;
}
</style>
  </head>
  <body dir="ltr">
    <h1>Eclipse Public License  -  v 2.0</h1>
    <p>随附程序根据本ECLIPSE公共许可证（“协议”）的条款提供。任何使用，复制或分发本程序即表示接受方接受本协议。</p>
    <h2 id="definitions">1。定义</h2>
    <p>“贡献”是指：</p>
    <ul>
      <li>a）在初始贡献者的情况下，根据本协议分发的初始内容，以及</li>
      <li>b）对于每个后续的贡献者：<ul>
          <li>i）对计划的更改，以及</li>
          <li>ii）该计划的补充;</li>
        </ul>本程序的此类更改和/或添加内容源自该特定贡献者并由该特定贡献者分发。如果贡献者由此类贡献者本身或代表此类贡献者行事的任何人添加到“计划”中，则“贡献者”来自“贡献者”。贡献不包括对本程序的非修改工作的更改或添加。
      </li>
    </ul>
    <p>“贡献者”指分发本程序的任何个人或实体。</p>
    <p>“许可专利”是指由贡献者许可的专利权利要求，单独使用或出售其贡献或与本程序结合使用时必然会受到侵犯。
    </p>
    <p>“程序”是指根据本协议分发的会费。
    </p>
    <p>“收件人”指根据本协议或任何二级许可（如适用）接收本程序的任何人，包括贡献者。
    </p>
    <p>“衍生作品”是指基于（或源自）本程序的任何作品，无论是源代码还是其他形式，其编辑修订，注释，阐述或其他修改整体上代表原件作者的作品。
    </p>
    <p>“修改后的作品”是指源代码或其他形式的任何作品，由于对本程序内容的添加，删除或修改而产生，包括为了清楚起见，源代码表单中包含任何内容的任何新文件该计划。Modified Works不得仅包含本程序的声明，接口，类型，类，结构或文件的作品，仅用于链接，通过名称或子类本程序或其修改的作品。
    </p>
    <p>“分发”是指a）分发或b）以任何能够转移副本的方式提供的行为。
    </p>
    <p>“源代码”是指优先用于修改的程序形式，包括但不限于软件源代码，文档源和配置文件。
    </p>
    <p>“二级许可证”是指GNU通用公共许可证，2.0版或该许可证的任何更高版本，包括初始贡献者确定的任何例外或其他权限。
    </p>
    <h2 id="grant-of-rights">2。授予权利</h2>
    <ul>
      <li>a）在遵守本协议条款的前提下，每个贡献者特此授予收件人非独家，全球，免版税的版权许可，以复制，准备衍生作品，公开展示，公开表演，分发和再许可此类贡献者的贡献，如果有的话，和这样的衍生作品。
      </li>
      <li>b）在遵守本协议条款的前提下，每个贡献者特此授予收件人在许可专利下的非独家，全球免版税专利许可，以制作，使用，销售，提议销售，进口和以其他方式转让此类贡献者的贡献（如果有）源代码或其他形式。如果在贡献者添加贡献时，此专利许可应适用于贡献与计划的组合，此类添加导致此类组合由许可专利涵盖。专利许可不适用于包括贡献的任何其他组合。本协议未授权任何硬件本身。
      </li>
      <li>c）接受方理解尽管每个贡献者都将许可授予此处所列的贡献，但任何贡献者均不保证本程序不侵犯任何其他实体的专利或其他知识产权。对于任何其他实体基于侵犯知识产权或其他方式提出的索赔，每个贡献者均不对收件人承担任何责任。作为行使本协议授予的权利和许可的条件，每个接收方在此承担全部责任以确保所需的任何其他知识产权（如果有）。例如，如果要求第三方专利许可允许收件人分发本程序，则在分发本程序之前，收件人有责任获得该许可。
      </li>
      <li>d）根据其知识，每个贡献者代表其在贡献中拥有足够的版权权利（如果有的话），以授予本协议中规定的版权许可。
      </li>
      <li>e）尽管有任何二级许可的条款，但由于接收方根据二级许可的条款收到本程序，因此没有贡献者向任何接收方（本协议中规定的除外）提供额外的授权（如果第3节的条款。
      </li>
    </ul>
    <h2 id="requirements">3。要求</h2>
    <p>3.1如果贡献者以任何形式分发本程序，则：</p>
    <ul>
      <li>a）根据第3.2节，该程序也必须作为源代码提供，并且贡献者必须随附本程序，并声明该程序的源代码可在本协议下获得，并通知接收者如何获取该程序。在通常用于软件交换的媒介上或通过媒体的合理方式;和</li>
      <li>b）投稿人可以根据与本协议不同的许可分发本程序，前提是该许可：<ul>
          <li>i）代表所有其他贡献者有效地否认所有明示或暗示的保证和条件，包括所有权和非侵权的保证或条件，以及适销性和特定用途适用性的暗示保证或条件;</li>
          <li>ii）有效地代表所有其他贡献者排除对损害的所有责任，包括直接，间接，特殊，偶然和后果性损害，例如利润损失;</li>
          <li>iii）不试图根据第3.2节限制或改变源代码中的接收者权利;和</li>
          <li>iv）要求任何一方随后分发本程序，使其符合本节第3条的要求。
          </li>
        </ul>
      </li>
    </ul>
    <p>3.2当本程序作为源代码分发时：</p>
    <ul>
      <li>a）必须根据本协议提供，或者如果程序（i）与其他材料合并在一个单独的文件或根据二级许可证提供的文件中，以及（ii）源代码附带的初始贡献者通知如果在本协议的附录A中有所描述，则该程序可根据此类二级许可证的条款提供，并且</li>
      <li>b）本协议的每份副本必须包含本协议的副本。</li>
    </ul>
    <p>3.3贡献者不得从他们分发的本程序的任何副本中删除或更改本程序中包含的任何版权，专利，商标，归属声明，免责声明或责任限制（“通知”），前提是贡献者可以添加他们的拥有适当的通知。
    </p>
    <h2 id="commercial-distribution">4。商业分布</h2>
    <p>软件的商业分销商可以接受关于最终用户，商业伙伴等的某些责任。虽然本许可旨在促进本程序的商业用途，但在商业产品中包含本程序的贡献者应以不对其他贡献者产生潜在责任的方式这样做。因此，如果贡献者在商业产品中包含该计划，则此类贡献者（“商业贡献者”）特此同意为任何损失，损害和成本（统称为“损失”）的所有其他贡献者（“受弥补的贡献者”）进行辩护和赔偿。由于第三方针对受弥补的贡献者提起的索赔，诉讼和其他法律诉讼而引起的，这些行为或疏忽是由于该商业贡献者在商业产品发行中分发该程序所造成的。本节中的义务不适用于与任何实际或涉嫌侵犯知识产权有关的任何索赔或损失。为了获得资格，受弥补的贡献者必须：a）及时以书面形式通知商业贡献者此类索赔，以及b）允许商业贡献者控制并与商业贡献者合作进行辩护和任何相关的和解谈判。受弥补的贡献者可自费参与任何此类索赔。
    </p>
    <p>例如，贡献者可能在商业产品中包含该程序，产品X.该贡献者当时是商业贡献者。如果该商业贡献者随后提出履约索赔或提供与产品X相关的保证，则这些履约索赔和保证仅为商业贡献者的责任。根据本节，商业贡献者必须针对与这些履约索赔和保证相关的其他贡献者提出索赔，如果法院要求任何其他贡献者支付任何损害赔偿金，则商业贡献者必须支付这些损害赔偿金。
    </p>
    <h2 id="warranty">5。没有保修</h2>
    <p>除非本协议明确规定，并且在适用法律允许的范围内，本程序按“原样”提供，不附带任何明示或暗示的担保或条件，包括但不限于任何担保或所有权，非侵权，适销性或适用于特定用途的条件。每个接收方全权负责确定使用和分发本程序的适当性，并承担与本协议下行使权利相关的所有风险，包括但不限于程序错误的风险和成本，遵守适用法律，损坏或数据，程序或设备丢失，操作不可用或中断。
    </p>
    <h2 id="disclaimer">6。责任免责声明</h2>
    <p>除非本协议明确规定，并且在适用法律允许的范围内，任何接受者或任何贡献者均不对任何直接，间接，偶然，特殊，惩戒性或后果性损害（包括但不限于利润损失）承担任何责任，然而，无论是合同，严格责任，还是侵权行为（包括疏忽或其他行为），无论是以何种方式使用或分发本程序或行使此处授予的任何权利，即使有任何合理责任，也不论是否属于合同，严重责任或侵权（包括疏忽或其他）这种损害的可能性。</p>
    <h2 id="general">7。一般</h2>
    <p>如果本协议的任何条款在适用法律下无效或不可执行，则不应影响本协议其余条款的有效性或可执行性，且未经双方进一步采取行动，此类条款应在最低程度上进行改革。必须使此类规定有效且可执行。
    </p>
    <p>如果收件人针对任何实体（包括诉讼中的交叉索赔或反索赔）提起专利诉讼，指称本程序本身（不包括本程序与其他软件或硬件的组合）侵犯了此类收件人的专利，则授予此类收件人的权利根据第2（b）条的规定，自提起诉讼之日起终止。
    </p>
    <p>如果收件人未能遵守本协议的任何重要条款或条件，并且在发现此类不合规后的合理时间内未能解决此类失败，则本协议下的所有收件人的权利均应终止。如果本协议下的所有接收方权利终止，则接收方同意在合理可行的情况下尽快停止使用和分发本程序。但是，接收方在本协议下的义务以及接收方授予的与本程序相关的任何许可将继续存在并继续存在。
    </p>
    <p>允许每个人复制和分发本协议的副本，但为了避免不一致，本协议受版权保护，并且只能以下列方式进行修改。协议管家保留随时发布本协议新版本（包括修订版）的权利。协议管家之外的任何人均无权修改本协议。Eclipse Foundation是最初的协议管理员。Eclipse Foundation可以将作为协议管理员的职责分配给合适的单独实体。协议的每个新版本都将给出一个与众不同的版本号。本程序（包括贡献）可能始终根据收到该协议的协议版本进行分发。此外，在发布新版协议后，贡献者可以选择在新版本下分发程序（包括其贡献）。
    </p>
    <p>除非上述第2节（a）和第2节（b）明确规定，否则接收方不得以任何暗示，禁止反言或其他方式明确，不接受本协议下任何贡献者的知识产权。本协议未明确授予的本程序中的所有权利均予以保留。本协议中的任何内容均不得由任何非贡献者或收件人的实体强制执行。根据本协议，不会创建第三方受益权。
    </p>
    <h2 id="exhibit-a">附表A  - 二级许可证申报表</h2>
    <p>“当Eclipse公共许可证，2.0版中规定的此类可用性条件得到满足时，此源代码也可以在以下二级许可证下提供：{name license（s），version（s），exception of exceptions或additional权限}。“
    </p>
    <blockquote>
      <p>仅包括本协议的副本（包括本附件A）不足以在二级许可下许可源代码。
      </p>
      <p>如果不可能或不希望将通知放在特定文件中，那么您可以将通知包含在收件人可能会查找此类通知的位置（例如相关目录中的LICENSE文件）中。
      </p>
      <p>您可以添加其他准确的版权所有权通知。</p>
    </blockquote>
  </body>
</html><html id="3173.Button.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 按钮</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">键入按钮</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。按键</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Button.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Button.html#constructor">按钮</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Button.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Button.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">如果选择了接收者，则返回<code>true</code> ，否则返回false。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Button.html#getText">getText</a></b> （）</div>
                <div class="description">返回小部件文本。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Button.html#setSelection">setSelection</a></b> （已选中）</div>
                <div class="description">设置接收器的选择状态，如果它是<code>CHECK</code> ， <code>RADIO</code>或<code>TOGGLE</code> 。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Button.html#setText">setText</a></b> （文本）</div>
                <div class="description">将接收器文本设置为给定的字符串。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Button.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Button.html#event:Selection">选择</a></b>
                </div>
                <div class="description">选择窗口小部件时发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>按钮</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{boolean}</span> <b>getSelection</b> （）</div>
          <div class="description">如果选择了接收者，则返回<code>true</code> ，否则返回false。
<p>当接收器是<code>CHECK</code>或<code>RADIO</code>类型时，选中它时会选中它。当它是<code>TOGGLE</code>类型时，它被推入时被选中。如果接收者是任何其他类型，则此方法返回false。
</p>
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{boolean}</span>选择状态</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getText"> </a>
          <div class="fixedFont">

          <span class="light">{string}</span> <b>getText</b> （）</div>
          <div class="description">返回小部件文本。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{string}</span>小部件文本</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （已选中）</div>
          <div class="description">设置接收器的选择状态，如果它是<code>CHECK</code> ， <code>RADIO</code>或<code>TOGGLE</code> 。<p>当接收器是<code>CHECK</code>或<code>RADIO</code>类型时，选中它时会选中它。当它是<code>TOGGLE</code>类型时，它被推入时被选中。
</p>
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{boolean}已</span> <b>选中</b>
                  
                </dt>
                <dd>新的选择状态</dd>
              
              </dl>
            
            
            
            
            
            
            

          <hr>
        
          <a name="setText"> </a>
          <div class="fixedFont">

          
          <b>setText</b> （文本）</div>
          <div class="description">将接收器文本设置为给定的字符串。
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{string}</span> <b>文字</b>
                  
                </dt>
                <dd>新文本</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Selection"> </a>
          <div class="fixedFont">

          
          <b>选择</b>

          </div>
          <div class="description">选择窗口小部件时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Selection">SWT.Selection</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="2379.DocScope.html" dir="ltr"></html><html dir="ltr">

<head>
<title>范围（Oomph设置文档）</title>

<link rel="stylesheet" href="../book.css"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Scopes (Oomph Setup Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>领域</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="DocConceptOverview.html" title="落后于上下文"><img src="../../images/backward.png" border="0"></a> <a href="DocInfrastructure.html" title="转发基础设施"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p><a href="../../javadoc/org/eclipse/oomph/setup/Scope.html" title="org.eclipse.oomph.setup中的接口"><code>scope</code></a>是用于对相关<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a>进行分组的粗粒度单位。范围是分层结构的，并且基于该分层结构从它们<a href="DocTaskComposition.html#ScopeList.scopeList" title="Oomph设置文档中的部分">收集</a>任务。它们存储在<a href="DocSetupResource.html" title="Oomph设置文档中的文章">资源中</a> 。

<a name="DocScope.properties">领域<p>每个范围都具有以下属性：</p><ul>

<a name="DocScope.name">
<li>必需<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getName()" title="org.eclipse.oomph.setup中的方法。范围"><code>attribute</code></a> ，应该是小写名称，即类似于限定Java包名称的单个组件。范围的分层<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getParentScope()" title="org.eclipse.oomph.setup中的方法。范围"><code>containment</code></a>结构基于'。'引入<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getQualifiedName()" title="org.eclipse.oomph.setup中的方法。范围"><code>qualified</code></a>名称属性。分隔的范围名称，因此建议使用小写范围名称。
 </li>

<a name="DocScope.label">
<li>可选的<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getLabel()" title="org.eclipse.oomph.setup中的方法。范围"><code>label</code></a>属性，应该是可包含空格和标点符号的标题案例名称。
 </li>

<a name="DocScope.description">
<li>可选<a href="../../javadoc/org/eclipse/oomph/setup/Scope.html#getDescription()" title="org.eclipse.oomph.setup中的方法。范围"><code>description</code></a>属性，其描述可以是任意描述性日志。
 </li>

<a name="DocScope.footer">
</a></a></a></a></ul>
 </a></p>

<h2><a name="DocProductCatalog"></a> 1产品目录</h2>
<p>一个<a href="../../javadoc/org/eclipse/oomph/setup/ProductCatalog.html" title="org.eclipse.oomph.setup中的接口"><code>product catalog</code></a>是一个<a href="../../javadoc/org/eclipse/oomph/setup/ProductCatalog.html#getProducts()" title="org.eclipse.oomph.setup中的方法。产品目录"><code>container</code></a>的<a href="DocScope.html#DocProduct" title="Oomph设置文档中的章节">产品</a> ，以及一个<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a>的所有<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a> ，以安装任何这些产品。

<a name="DocProductCatalog.example">例如，为<a href="https://www.eclipse.org/downloads/">Eclipse的下载页面</a>上提供的所有包生成了Eclipse产品目录。换句话说，您可以使用Oomph来安装您通常从Eclipse.org下载并解压缩的任何软件包版本。

<a name="DocProductCatalog.self">如果产品<a href="../user/wizard/DocInstallWizard.html" title="Article in Oomph Setup Documentation">安装</a>了Oomph，但实际上并未由Oomph <a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装</a> ，则始终存在一个合成的所谓自我产品目录，其中包含<a href="DocScope.html#DocProduct.self" title="Oomph设置文档中的部分">自产品</a> 。

<a name="DocProductCatalog.footer">它存储在<a href="DocSetupResource.html#ProductCatalogResource" title="Oomph设置文档中的章节">项目目录资源中</a> 。
 </a></a></a></p>

<h3><a name="DocProduct"></a> 1.1产品</h3>
<p>一个<a href="../../javadoc/org/eclipse/oomph/setup/Product.html" title="org.eclipse.oomph.setup中的接口"><code>product</code></a>是一个<a href="../../javadoc/org/eclipse/oomph/setup/Product.html#getVersions()" title="org.eclipse.oomph.setup中的方法。产品"><code>container</code></a>的产品<a href="DocScope.html#DocVersion" title="Oomph设置文档中的章节">版本</a> ，以及一个<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a>的所有<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a> ，以安装任何这些版本的产品。

<a name="DocProduct.example">例如，每个Eclipse <a href="http://www.eclipse.org/downloads/packages/release/Luna/R">包</a>的<a href="DocScope.html#DocProductCatalog.example" title="Oomph设置文档中的部分">Eclipse</a>产品目录中都有一个产品。

<a name="DocProduct.self">如果产品<a href="../user/wizard/DocInstallWizard.html" title="Article in Oomph Setup Documentation">安装</a>了Oomph，但实际上并未由Oomph <a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装</a> ，则<a href="DocScope.html#DocProductCatalog.self" title="Oomph设置文档中的部分">自产品目录</a>中始终存在一个合成的所谓自我产品，其中包含<a href="DocScope.html#DocVersion.self" title="Oomph设置文档中的部分">自产品版本</a> 。

<a name="DocProduct.footer">
</a></a></a></p>

<h4><a name="DocVersion"></a> 1.1.1产品版本</h4>
<p>产品<a href="../../javadoc/org/eclipse/oomph/setup/ProductVersion.html" title="org.eclipse.oomph.setup中的接口"><code>version</code></a>是安装特定版本产品的所有<a href="DocTask.html" title="Oomph设置文档中的文章">任务</a>的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a> 。

<a name="DocVersion.example">例如， <a href="DocScope.html#DocProductCatalog.example" title="Oomph设置文档中的部分">Eclipse产品目录</a>中的<a href="DocScope.html#DocProduct.example" title="Oomph设置文档中的部分">Eclipse Standard产品</a>中有一个产品版本，用于安装Eclipse Standard <a href="https://www.eclipse.org/downloads/packages/eclipse-standard-44/lunar">Luna</a>软件包。
 </a></p>

<a name="DocVersion.self">如果产品<a href="../user/wizard/DocInstallWizard.html" title="Article in Oomph Setup Documentation">安装</a>了Oomph但实际上并未由Oomph <a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装</a> ，则<a href="DocScope.html#DocProductCatalog.self" title="Oomph设置文档中的部分">自产品目录</a>中的<a href="DocScope.html#DocProduct.self" title="Oomph设置文档中的部分">自产品中</a>始终存在合成的所谓产品版本。它通过<a href="DocTask.html#DocP2Task" title="Oomph设置文档中的章节">p2任务</a>捕获有关该产品安装的可安装单元的所有信息，以及可用于更新该产品安装中的这些单元的所有更新p2站点。
 

<h2><a name="DocProjectCatalog"></a> 2项目目录</h2>
<p>一个<a href="../../javadoc/org/eclipse/oomph/setup/Project.html" title="org.eclipse.oomph.setup中的接口"><code>project catalog</code></a>是一个<a href="../../javadoc/org/eclipse/oomph/setup/ProjectContainer.html#getProjects()" title="org.eclipse.oomph.setup中的方法。ProjectContainer"><code>container</code></a>用于<a href="DocScope.html#DocProject" title="Oomph设置文档中的章节">项目</a>以及一个<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a>同时为任务提供任何这些项目和任务的工作空间来安装任何这些项目的工作所需的工具。例如，有一个Eclipse项目目录，用于配置在Eclipse.org上托管的各种项目。它存储在<a href="DocSetupResource.html#ProjectCatalogResource" title="Oomph设置文档中的章节">项目目录资源中</a> 。
 </p>

<h3><a name="DocProject"></a> 2.1项目</h3>
<p><a href="../../javadoc/org/eclipse/oomph/setup/Project.html" title="org.eclipse.oomph.setup中的接口"><code>project</code></a>是<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流</a>的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a> ，也是<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a>用于为任何这些流配置工作空间的任务以及安装处理任何这些流所需的工具的任务。例如，Eclipse项目目录中有一个项目用于配置Oomph项目本身。项目可以选择{包含嵌套项目。它存储在<a href="DocSetupResource.html#ProjectResource" title="Oomph设置文档中的章节">项目资源中</a> 。
 </p>

<a name="DocProject.nested">项目可以选择包含<a href="../../javadoc/org/eclipse/oomph/setup/ProjectContainer.html#getProjects()" title="Method in org.eclipse.oomph.setup.ProjectContainer"><code>nested</code></a>项目，这些<a href="../../javadoc/org/eclipse/oomph/setup/ProjectContainer.html#getProjects()" title="org.eclipse.oomph.setup中的方法。ProjectContainer"><code>nested</code></a>项目可以存储在单独的<a href="DocSetupResource.html#ProjectResource" title="Oomph设置文档中的章节">项目资源中</a> ，也可以存储在与<a href="../../javadoc/org/eclipse/oomph/setup/Project.html#getParentProject()" title="Method in org.eclipse.oomph.setup.Project"><code>containing</code></a>项目相同的资源<a href="../../javadoc/org/eclipse/oomph/setup/Project.html#getParentProject()" title="org.eclipse.oomph.setup中的方法。项目"><code>containing</code></a> 。
 

<h4><a name="DocStream"></a> 2.1.1流</h4>
<p><a href="../../javadoc/org/eclipse/oomph/setup/Stream.html" title="org.eclipse.oomph.setup中的接口"><code>stream</code></a>是用于为特定流配置工作空间的任务的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a> ，以及用于安装使用该特定流所需的工具的任务。例如，Eclipse项目目录中的Oomph项目中有一个流，用于配置Oomph项目的Git <a href="http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/">master</a>分支的源代码。

</p><h2><a name="DocInstallation"></a> 3安装</h2>
<p><a href="../../javadoc/org/eclipse/oomph/setup/Installation.html" title="org.eclipse.oomph.setup中的接口"><code>installation</code></a>是用于配置特定已安装Eclipse产品的任务的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a> 。但是，它的主要功能是指定对产品<a href="DocScope.html#DocVersion" title="Oomph设置文档中的章节">版本</a>的引用。为该产品版本<a href="DocTaskComposition.html" title="Article in Oomph Setup Documentation">收集</a>的任务<a href="DocTaskComposition.html" title="Oomph设置文档中的文章">将</a>针对该已安装的产品<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">执行</a> 。<a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装程序向导</a>根据<a href="../user/wizard/DocProductPage.html" title="Oomph设置文档中的文章">产品页面</a>上的所选产品版本创建实例。即使Oomph尚未安装产品安装，当存在Oomph时，也会自动创建安装实例以引用合成<a href="DocScope.html#DocVersion.self" title="Oomph设置文档中的部分">自</a>产品版本。
 </p>

<h2><a name="DocWorkspace"></a> 4个工作区</h2>
<p><a href="../../javadoc/org/eclipse/oomph/setup/Workspace.html" title="org.eclipse.oomph.setup中的接口"><code>workspace</code></a>是用于配置特定Eclipse工作空间的任务的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a> 。它的主要功能是指定对项目<a href="DocScope.html#DocStream" title="Oomph设置文档中的章节">流的</a>零个或多个引用。任务<a href="DocTaskComposition.html" title="Oomph设置文档中的文章">聚集</a>为每个项目流被<a href="DocTaskExecution.html" title="Oomph设置文档中的文章">执行</a>为工作空间以及为用于打开工作区安装的产品。<a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装程序向导</a>基于<a href="../user/wizard/DocProjectPage.html" title="Oomph设置文档中的文章">项目页面</a>上的选定项目流创建实例。<a href="../user/wizard/DocInstallWizard.html" title="Oomph设置文档中的文章">安装程序</a>和<a href="../user/wizard/DocImportWizard.html" title="Oomph设置文档中的文章">项目</a>向导</p>

<h2><a name="DocUser"></a> 5个用户</h2>
<p><a href="../../javadoc/org/eclipse/oomph/setup/User.html" title="org.eclipse.oomph.setup中的接口"><code>user</code></a>是任务的<a href="../../javadoc/org/eclipse/oomph/setup/SetupTaskContainer.html#getSetupTasks()" title="org.eclipse.oomph.setup中的方法。SetupTaskContainer"><code>container</code></a>用于配置每个已安装的Eclipse产品以及最终用户使用的每个打开的工作空间。它提供了一个机会，可以使用所有Eclipse产品和工作区自定义用户体验的各个方面。它还为以下内容提供支持：</p><ul>
 <li>记录每个工具自动安装的工具的已<a href="../../javadoc/org/eclipse/oomph/setup/User.html#getAcceptedLicenses()" title="org.eclipse.oomph.setup中的方法。用户"><code>accepted license</code></a> ，即，一旦许可被接受，就可以记录它以避免任何涉及该特定许可的未来提示。
 </li>记录关于未签名内容的处理的<a href="../../javadoc/org/eclipse/oomph/setup/User.html#getUnsignedPolicy()" title="org.eclipse.oomph.setup中的方法。用户"><code>policy</code></a> ，即，一旦接受未签名的内容，就可以记录接受以避免任何涉及未签名内容的未来提示。
 
 <li>记录配置选项（所谓的<a href="../../javadoc/org/eclipse/oomph/setup/User.html#getAttributeRules()" title="org.eclipse.oomph.setup中的方法。用户"><code>attribute rules</code></a> ，用于定制物理存储存储库，工作空间和安装的位置和方式。
 </li>
 </ul>

<p align="right">
<a href="DocConceptOverview.html" title="落后于上下文"><img src="../../images/backward.png" border="0"></a> <a href="DocInfrastructure.html" title="转发基础设施"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="Oomph Setup Documentation">Oomph Setup Documentation</a> > <a href="index.html" title="Category in Oomph Setup Documentation">Concepts</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（Loehne，Germany）和其他人。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v2.0条款提供，可从http://www.eclipse.org/legal/epl-v20.html获取。</div>
</a></a></body>
</html><html id="0931.ch05s01s01s05s03.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>5.1.1.5.3。�拖放表组件</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula Reference Manual"></link>
<link rel="up" href="ch05s01s01s05.html" title="5.1.1.5.�Drag and drop"></link>
<link rel="prev" href="ch05s01s01s05s02.html" title="5.1.1.5.2.�Drag and Drop in List Components"></link>
<link rel="next" href="ch05s01s01s05s04.html" title="5.1.1.5.4.�Drag and Drop in Tree Components"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">5.1.1.5.3。�拖放表组件</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch05s01s01s05s02.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">5.1.1.5。�拖放</th>
<td width="20%" align="right">� <a href="ch05s01s01s05s04.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula参考手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch05.html">操作</a></span> &gt; <span class="breadcrumb-link"><a href="ch05s01.html">可在大多数应用程序上使用的</a></span> <span class="breadcrumb-link"><a href="ch05.html">操作</a></span> &gt; <span class="breadcrumb-link"><a href="ch05s01s01.html">执行行为的操作</a></span> &gt; <span class="breadcrumb-link"><a href="ch05s01s01s05.html">拖放</a></span> &gt; <span class="breadcrumb-node">在表组件中拖放</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="actionDragAndDropTableComponents"></a> 5.1.1.5.3。�拖放表组件</h4></div></div></div>
<p><span class="emphasis"><em>拖动单元格</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会拖动您指定的表格单元格。
        </p></li>
<li class="listitem"><p>单元格由行和列值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>将保留指定的鼠标按钮，并拖动单元格。
        </p></li>
<li class="listitem"><p>您必须通过<span class="emphasis"><em>放置</em></span>操作执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s55.html" title="4.55。�鼠按钮">鼠标按钮</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s54.html" title="4.54。�修正键">修改键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s66.html" title="4.66。行">行</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s67.html" title="4.67。�行操作员">行操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s08.html" title="4.8。柱">柱</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s09.html" title="4.9。�柱操作员">列操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s95.html" title="4.95。X坐标">X坐标</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s96.html" title="4.96。X-单位">X-单位</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s97.html" title="4.97。Y坐标">Y坐标</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s98.html" title="4.98。Y单位">Y单位</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p>如果要拖动多个项目，请在使用拖动操作之前使用操作选择要拖动的项目。
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>从列拖动单元格</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会拖动您指定的表格单元格。
        </p></li>
<li class="listitem"><p>单元格由其列和单元格中的值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>将保留指定的鼠标按钮，并拖动单元格。
        </p></li>
<li class="listitem"><p>您必须通过<span class="emphasis"><em>放置</em></span>操作执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s55.html" title="4.55。�鼠按钮">鼠标按钮</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s54.html" title="4.54。�修正键">修改键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s08.html" title="4.8。柱">柱</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s09.html" title="4.9。�柱操作员">列操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s88.html" title="4.88。值">值</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s91.html" title="4.91。�值运算符">价值运营商</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s69.html" title="4.69。�搜索类型">搜索类型</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p>如果要拖动多个项目，请在使用拖动操作之前使用操作选择要拖动的项目。
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>从行拖动单元格</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会拖动您指定的表格单元格。
        </p></li>
<li class="listitem"><p>单元格由其行和单元格中的值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>将保留指定的鼠标按钮，并拖动单元格。
        </p></li>
<li class="listitem"><p>您必须通过<span class="emphasis"><em>放置</em></span>操作执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s55.html" title="4.55。�鼠按钮">鼠标按钮</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s54.html" title="4.54。�修正键">修改键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s66.html" title="4.66。行">行</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s67.html" title="4.67。�行操作员">行操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s88.html" title="4.88。值">值</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s91.html" title="4.91。�值运算符">价值运营商</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s69.html" title="4.69。�搜索类型">搜索类型</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p>如果要拖动多个项目，请在使用拖动操作之前使用操作选择要拖动的项目。
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>落在细胞上</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会将拖动的项目拖放到您指定的单元格上。
        </p></li>
<li class="listitem"><p>应该发生丢弃的单元格由其行和列值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>您指定的鼠标按钮松开，单元格被删除。
        </p></li>
<li class="listitem"><p>使用<span class="emphasis"><em>拖动</em></span>操作来执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s66.html" title="4.66。行">行</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s67.html" title="4.67。�行操作员">行操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s08.html" title="4.8。柱">柱</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s09.html" title="4.9。�柱操作员">列操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s95.html" title="4.95。X坐标">X坐标</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s96.html" title="4.96。X-单位">X-单位</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s97.html" title="4.97。Y坐标">Y坐标</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s98.html" title="4.98。Y单位">Y单位</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s18.html" title="4.18。�下降前延迟">下降前延迟</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>从列中删除单元格</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会将拖动的项目拖放到您指定的单元格上。
        </p></li>
<li class="listitem"><p>应该发生丢弃的单元格由其列和单元格中的值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>您指定的鼠标按钮松开，单元格被删除。
        </p></li>
<li class="listitem"><p>使用<span class="emphasis"><em>拖动</em></span>操作来执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s08.html" title="4.8。柱">柱</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s09.html" title="4.9。�柱操作员">列操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s88.html" title="4.88。值">值</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s91.html" title="4.91。�值运算符">价值运营商</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s69.html" title="4.69。�搜索类型">搜索类型</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s18.html" title="4.18。�下降前延迟">下降前延迟</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>从行中删除单元格</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作会将拖动的项目拖放到您指定的单元格上。
        </p></li>
<li class="listitem"><p>应该发生丢弃的单元格由其行和单元格中的值指定。
        </p></li>
<li class="listitem"><p>光标在单元格上移动。
        </p></li>
<li class="listitem"><p>您指定的鼠标按钮松开，单元格被删除。
        </p></li>
<li class="listitem"><p>使用<span class="emphasis"><em>拖动</em></span>操作来执行此操作。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s66.html" title="4.66。行">行</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s67.html" title="4.67。�行操作员">行操作员</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s88.html" title="4.88。值">值</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s91.html" title="4.91。�值运算符">价值运营商</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s69.html" title="4.69。�搜索类型">搜索类型</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s18.html" title="4.18。�下降前延迟">下降前延迟</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具包不支持此操作。
  </strong></span></td>
</tr></tbody>
</table>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="3306.extensions-properties_provide_custom_widget_basic.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>扩展 -  properties_provide_custom_widget_basic</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SiriusPropertiesBasicCustomWidget">Sirius Properties  - 基本自定义小部件</h1>
		<h2 id="Goal">目标</h2>
		<p>使用基本自定义窗口小部件方法，我们的目标是使用最少的代码快速创建自定义窗口小部件，即使它只为指定者创建基本用户界面以使用我们的窗口小部件。在此示例中，我们将尝试创建一个简单的表窗口小部件。</p>
		<h2 id="Strategy">战略</h2>
		<p>为了创建自定义窗口小部件，我们必须考虑将与我们的工作交互的两种用户，Sirius说明符和最终用户。通过这种基本方法，我们将为最终用户创建一个漂亮的表窗口小部件，但我们对于我们可以为说明符提供的内容有点限制。</p>
		<h3 id="Specificationofthecustomwidget">自定义小部件的规范</h3>
		<p>Eclipse Sirius中Properties视图支持的实现基于Eclipse EEF项目。虽然两个项目密切相关，但EEF可以在没有Eclipse Sirius的情况下使用，为了提供基本的自定义小部件，我们只需要为EEF运行时做出贡献。Eclipse EEF和Eclipse Sirius都能够让说明符定义具有自定义窗口小部件描述的自定义窗口小部件。</p>
		<p>Eclipse Sirius中的这个自定义窗口小部件描述与odesign文件中的任何其他窗口小部件一样被操纵。在此窗口小部件中，您可以指定窗口小部件的以下属性：</p>
		<ul>
			<li>识别码</li>
			<li>labelExpression</li>
			<li>helpExpression</li>
			<li>isEnabledExpression</li>
			<li>customExpressions</li>
			<li>customOperations</li>
			<li>样式</li>
			<li>conditionalStyles</li>
		</ul>
		<p>这些属性中的大多数都继承自窗口小部件的描述（identifier，labelExpression，helpExpression，isEnabledExpression），其他属性特定于自定义窗口小部件描述（customExpressions，customOperations，style，conditionalStyles）。为了向Sirius说明符提供基本的自定义窗口小部件，您必须向她/他指明用于窗口小部件，其表达式及其操作的正确标识符。例如，我们将指定为了使我们的自定义表小部件工作，指定者必须使用标识符为<code>com.example.awesomeproject.sirius.properties.ext.widgets.table</code>的自定义小部件描述。
		</p>
		<p>为了提供表的实现，我们需要使用Eclipse EEF的生命周期管理器提供程序扩展点。此扩展点允许您使用生命周期管理器定义自定义窗口小部件的外观和行为。</p>
		<h3 id="Extensioncontribution">扩展贡献</h3>
		<p>您必须首先创建一个名为<code>com.example.awesomeproject.eef.ide.ui.ext.widgets.table</code>的Eclipse插件，该插件将包含生命周期管理器的提供程序。在Eclipse EEF中，生命周期管理器用于创建窗口小部件的用户界面并管理其生命周期（添加侦听器，刷新，删除侦听器，处置等），同时使用控制器来定义其行为。控制器不是强制性的，但强烈建议使用。要创建生命周期管理器提供程序，您必须定义以下扩展名。
		</p>
		<pre>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;？eclipse版本=“3.4”？&gt; &lt;plugin&gt; &lt;extension point =“org.eclipse.eef.ide.ui.eefLifecycleManagerProvider”&gt; &lt;descriptor class =“com.example.awesomeproject.eef.ide.ui.ext.widgets.table.internal。TableLifecycleManagerProvider“description =”％tableLifecycleManagerProvider。描述“id =”com.example.awesomeproject.eef.ide.ui.ext.widgets.table“label =”％tableLifecycleManagerProvider。标签“&gt; &lt;/ descriptor&gt; &lt;/ extension&gt; &lt;/ plugin&gt;</pre>
		<p>
			<br>要使代码编译，您必须至少添加一些依赖项（必需的Bundle）到以下插件：</p>
		<ul>
			<li>org.eclipse.eef</li>
			<li>org.eclipse.eef.core</li>
			<li>org.eclipse.eef.ide.ui</li>
			<li>org.eclipse.sirius.common.interpreter</li>
		</ul>
		<h3 id="EEFlifecyclemanagerprovider">EEF生命周期管理器提供商</h3>
		<p>
			<br>属性标签和描述都应该是国际化的，并且类应该引用实现IEEFLifecycleManagerProvider的Java类。我们的生命周期管理器提供程序将有两个方法，一个用于指示它是否可以处理EEF运行时给出的描述，另一个用于为此描述返回适当的生命周期管理器。在我们的示例中，我们要支持的唯一描述是具有标识符<code>com.example.awesomeproject.sirius.properties.ext.widgets.table</code>的自定义窗口小部件。
		</p>
		<pre>package com.example.awesomeproject.eef.ide.ui.ext.widgets.table.internal; import org.eclipse.eef。EEFControlDescription; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.ide.ui.api.widgets。IEEFLifecycleManager; import org.eclipse.eef.ide.ui.api.widgets。IEEFLifecycleManagerProvider; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager;公共类TableLifecycleManagerProvider实现IEEFLifecycleManagerProvider {/ ** *支持的控件描述的标识符。* / private static final String SUPPORTED_ID =“com.example.awesomeproject.sirius.properties.ext.widgets.table”; // $ NON-NLS-1 $ @Override public boolean canHandle（EEFControlDescription controlDescription）{//仅支持具有正确标识符的自定义小部件返回SUPPORTED_ID.equals（controlDescription.getIdentifier（））&amp;&amp; controlDescription instanceof EEFCustomWidgetDescription; } @Override public IEEFLifecycleManager getLifecycleManager（EEFControlDescription controlDescription，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{if（controlDescription instanceof EEFCustomWidgetDescription）{return new TableLifecycleManager（（EEFCustomWidgetDescription）controlDescription，variableManager，interpreter，contextAdapter）;抛出新的IllegalArgumentException（）; }}</pre>
		<p>
			<br>要创建生命周期管理器，EEF运行时允许我们访问多个变量：</p>
		<ul>
			<li>controlDescription：我们支持的控件的描述</li>
			<li>variableManager：可用于此控件的变量，我们可以使用它来添加新变量，甚至可以使用新变量创建子上下文</li>
			<li>解释器：用于运行Sirius说明符给出的表达式的解释器</li>
			<li>contextAdapter：用于运行模型修改的包装器，具有可选的事务支持</li>
		</ul>
		<h3 id="EEFlifecyclemanager">EEF生命周期管理器</h3>
		<p>生命周期管理器必须实现<code>IEEFLifecycleManager</code>接口，但对于自定义小部件，更容易扩展其默认的抽象实现，在我们的例子中是<code>org.eclipse.eef.ide.ui.api.widgets.AbstractEEFWidgetLifecycleManager</code> 。
		</p>
		<pre>package com.example.awesomeproject.eef.ide.ui.ext.widgets.table.internal; import java.util.function。消费者; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef。EEFWidgetDescription; import org.eclipse.eef.common.ui.api。IEEFFormContainer; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.core.api.controllers。IEEFWidgetController; import org.eclipse.eef.ide.ui.api.widgets。AbstractEEFWidgetLifecycleManager; import org.eclipse.emf.edit.provider。ComposedAdapterFactory; import org.eclipse.emf.edit.ui.provider。AdapterFactoryLabelProvider; import org.eclipse.jface.viewers。ArrayContentProvider; import org.eclipse.jface.viewers。DelegatingStyledCellLabelProvider; import org.eclipse.jface.viewers。IStructuredSelection; import org.eclipse.jface.viewers。TableViewer的; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager; import org.eclipse.swt。SWT; import org.eclipse.swt.events。SelectionEvent; import org.eclipse.swt.events。SelectionListener中; import org.eclipse.swt.widgets。综合; import org.eclipse.swt.widgets。控制; import org.eclipse.swt.widgets。表; import com.example.awesomeproject.eef.core.ext.widgets.table.internal。TableController;公共类TableLifecycleManager扩展AbstractEEFWidgetLifecycleManager {private EEFCustomWidgetDescription description;私有TableViewer tableViewer;私有的ComposedAdapterFactory组成的AdapterFactory; private SelectionListener onClickListener;私有TableController控制器; private Consumer &lt;Object&gt; newValueConsumer; public TableLifecycleManager（EEFCustomWidgetDescription description，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{super（variableManager，interpreter，contextAdapter）; this.description = description; } @Override protected void createMainControl（Composite parent，IEEFFormContainer formContainer）{Table table = formContainer.getWidgetFactory（）。createTable（parent，SWT.READ_ONLY | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER | SWT.SINGLE）; this.tableViewer = new TableViewer（table）; this.composedAdapterFactory = new ComposedAdapterFactory（ComposedAdapterFactory。描述。注册。实例）; this.tableViewer.setContentProvider（ArrayContentProvider.getInstance（））; this.tableViewer.setLabelProvider（new DelegatingStyledCellLabelProvider（new AdapterFactoryLabelProvider。StyledLabelProvider（this.composedAdapterFactory，this.tableViewer）））; this.controller = new TableController（description，variableManager，interpreter，editingContextAdapter）; } @Override public void aboutToBeShown（）{super.aboutToBeShown（）; this.newValueConsumer =（newValue） - &gt; this.tableViewer.setInput（newValue）; this.controller.onNewValue（this.newValueConsumer）; this.onClickListener = new SelectionListener（）{@ Override public void widgetSelected（SelectionEvent event）{Object selection =（（IStructuredSelection）TableLifecycleManager.this.tableViewer.getSelection（））。getFirstElement（）; TableLifecycleManager.this.controller.handleClick（选择）; } @Override public void widgetDefaultSelected（SelectionEvent event）{Object selection =（（IStructuredSelection）TableLifecycleManager.this.tableViewer.getSelection（））。getFirstElement（）; TableLifecycleManager.this.controller.handleClick（选择）; }}; 。this.tableViewer.getTable（）addSelectionListener（this.onClickListener）; } @Override public void refresh（）{super.refresh（）; this.controller.refresh（）; } @Override public void aboutToBeHidden（）{super.aboutToBeHidden（）; this.controller.removeValueConsumer（）; this.newValueConsumer = null; 。this.tableViewer.getTable（）removeSelectionListener（this.onClickListener）; this.onClickListener = null; } @Override protected IEEFWidgetController getController（）{return this.controller; } @Override protected EEFWidgetDescription getWidgetDescription（）{return this.description; } @Override protected Control getValidationControl（）{return this.tableViewer.getTable（）; } @Override public void dispose（）{super.dispose（）; this.composedAdapterFactory.dispose（）; } @Override protected void setEnabled（boolean isEnabled）{this.tableViewer.getTable（）。setEnabled（isEnabled）; }}</pre>
		<p>
			<br>生命周期管理器将首先创建表窗口小部件的控件，并将初始化该表的控制器。
		</p>
		<h3 id="EEFcontroller">EEF控制器</h3>
		<p>控制器不是必需的，但它会为我们处理几个键问题，例如通过扩展适当的抽象类，它可以处理小部件的验证规则。对于基本的自定义小部件，强烈建议扩展<code>org.eclipse.eef.core.api.controllers.AbstractEEFCustomWidgetController</code> 。控制器没有任何理由依赖于用户界面，因此它将在另一个Eclipse插件中创建，该插件可以在不依赖于用户界面特定插件的情况下使用。该插件将命名为<code>com.example.awesomeproject.eef.core.ext.widgets.table</code> 。它至少取决于以下插件：</p>
		<ul>
			<li>org.eclipse.eef</li>
			<li>org.eclipse.eef.core</li>
			<li>org.eclipse.sirius.common.interpreter</li>
		</ul>
		<pre>package com.example.awesomeproject.eef.core.ext.widgets.table.internal; import java.util.function。消费者; import java.util。HashMap的; import java.util。地图; import org.eclipse.eef。EEFCustomWidgetDescription; import org.eclipse.eef.core.api。EditingContextAdapter; import org.eclipse.eef.core.api.controllers。AbstractEEFCustomWidgetController; import org.eclipse.eef.core.api.utils。EvalFactory; import org.eclipse.sirius.common.interpreter.api。IInterpreter; import org.eclipse.sirius.common.interpreter.api。IVariableManager; public class TableController扩展AbstractEEFCustomWidgetController {private static final String VALUE_EXPRESSION_ID =“valueExpression”; // $ NON-NLS-1 $ private static final String ON_CLICK_EXPRESSION_ID =“onClickExpression”; // $ NON-NLS-1 $ private static final String SELECTION_VARIABLE_NAME =“selection”; // $ NON-NLS-1 $ private Consumer &lt;Object&gt; newValueConsumer; public TableController（EEFCustomWidgetDescription description，IVariableManager variableManager，IInterpreter interpreter，EditingContextAdapter contextAdapter）{super（description，variableManager，interpreter，contextAdapter）; } @Override protected EEFCustomWidgetDescription getDescription（）{return this.description; } @Override public void refresh（）{super.refresh（）; this.newEval（）。call（this.getCustomExpression（VALUE_EXPRESSION_ID）。get（），this.newValueConsumer）; public void handleClick（Object object）{this.editingContextAdapter.performModelChange（（） - &gt; {String onClickExpression = this.getCustomExpression（ON_CLICK_EXPRESSION_ID）.get（）; Map &lt;String，Object&gt; variables = new HashMap &lt;String，Object&gt;（ ）; variables.putAll（this.variableManager.getVariables（））; variables.put（SELECTION_VARIABLE_NAME，object）; EvalFactory.of（this.interpreter，variables）.call（onClickExpression）;}）; public void onNewValue（Consumer &lt;Object&gt; consumer）{this.newValueConsumer = consumer; public void removeValueConsumer（）{this.newValueConsumer = null; }}</pre>
		<p>
			<br>这里的控制器将处理两种不同的情况。首先，它将对刷新做出反应，以便计算表小部件的新值。为此，它将查找带有标识符<code>valueExpression</code>的表达式，它将执行它。一旦执行，它将把结果提供给<code>newValueConsumer</code> 。在表生命周期管理器中，我们在方法<code>aboutToBeShown</code>中将此新值使用者设置为lambda，该lambda将为表设置新输入。每次生命周期管理器将被框架刷新时，它对<code>super.refresh()</code>调用将触发控制器的刷新（以及其他事情），这将计算要显示的新值并将此值赋予回调（消费者） ）由生命周期管理员注册。
		</p>
		<p>其次，控制器将用于处理表中的点击。为此，它有一个名为<code>handleClick</code>的方法，它将使用表中的选定对象进行调用。然后，控制器将使用标识符<code>onClickExpression</code>带有变量的表达式，以及专门针对此用例的附加变量。名为<code>selection</code>的附加变量将用于访问<code>onClickExpression</code>的当前选择。
		</p>
		<p>现在，您的最终用户可以使用您的两个插件使用自定义窗口小部件描述在其“属性”视图中创建表。</p>
	</body>
</html><html id="0566.Doc04_CheckingOut.html" dir="ltr"></html><html dir="ltr">

<head>
<title>从存储库签出（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Checking Out from Repositories (CDO Model Repository Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>从存储库中签出</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="Doc03_UsingBranches.html" title="落后于分支机构"><img src="../../images/backward.png" border="0"></a> <a href="Doc05_UsingCheckouts.html" title="转发使用结帐"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Eike Stepper</p>
<p>为了能够在CDO存储库中使用模型，需要从该存储库中检出它们。结帐表示以下信息的<i>命名</i>组合：</p><ul>
 <li>已配置的存储库（有关如何创建和配置存储库的详细信息，请参阅<a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">创建存储库和连接</a> ），</li><li>一个<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html" title="org.eclipse.emf.cdo.common.branch中的接口"><code>branch point</code></a> ，从什么决定<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getBranch()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>branch</code></a> ，并从什么<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranchPoint.html#getTimeStamp()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranchPoint"><code>time</code></a>结帐的模型显示，和</li><li>一个对象，用作结帐模型树的根对象。默认情况下，这是存储库的<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOView.html#getRootResource()" title="org.eclipse.emf.cdo.view中的方法。CDOView"><code>root resource</code></a> 。
 </li></ul>
 <p>启动结帐流程最明显的方法是在<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图中</a>选择存储库或分支，打开上下文菜单并选择Checkout操作或Checkout As操作。<a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">CDO Checkout Wizard</a> ， <a href="Doc05_UsingCheckouts.html#Doc_DuplicatingCheckouts" title="CDO模型存储库文档中的章节">Duplicating Checkouts</a>和<a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">History Integration</a>中介绍了其他方法。
 </p><p>Checkout操作不涉及进一步的对话交互，但会立即创建一个<a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">事务</a>签出，其中包含所有设置的默认值。以下部分详细介绍了不同的<a href="Doc01_UserInterface.html#Doc_CheckoutWizard" title="CDO模型存储库文档中的章节">结帐向导</a>页面。
 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutRepository" title="CDO模型存储库文档中的章节">选择存储库</a></td></tr>
<tr><td>2</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutType" title="CDO模型存储库文档中的章节">选择结帐类型</a></td></tr>
<tr><td></td><td>2.1</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">在线交易结账</a></td></tr>
<tr><td></td><td>2.2</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_HistoricalCheckouts" title="CDO模型存储库文档中的章节">在线历史结帐</a></td></tr>
<tr><td></td><td>2.3</td><td class="te" colspan="3"><a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">离线结账</a></td></tr>
<tr><td>3</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutBranchPoint" title="CDO模型存储库文档中的章节">选择分支点</a></td></tr>
<tr><td>4</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutRootObject" title="CDO模型存储库文档中的章节">选择根对象</a></td></tr>
<tr><td>五</td><td class="te" colspan="4"><a href="Doc04_CheckingOut.html#Doc_CheckoutName" title="CDO模型存储库文档中的章节">命名结帐</a></td></tr>
</table>



<h2><a name="Doc_CheckoutRepository"></a> 1选择存储库</h2>
<p>结帐向导的第一页显示在当前工作空间中配置的存储库列表。New Repository按钮打开存储库向导，在<a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">创建存储库和连接</a>中对此进行了说明。
 </p><p align="center"><img src="checkout-wizard-repository.png">

 </p><p>请注意，如果工作台选择在打开向导时隐含了特定存储库（例如，在<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图中</a>选择了存储库或分支），则会自动跳过此第一个向导页面。在这种情况下，“后退”按钮返回到存储库选择页面，并允许更改原始选择。
 </p><p>选择或创建存储库以通过按下“下一步”按钮或双击所选存储库进行检出后，将进入“ <a href="Doc04_CheckingOut.html#Doc_CheckoutType" title="CDO模型存储库文档中的章节">选择结帐类型”</a> 。

</p><h2><a name="Doc_CheckoutType"></a> 2选择结帐类型</h2>
<p>结帐向导的第二页允许选择要创建的结帐类型：</p><p align="center"><img src="checkout-wizard-type.png">

 </p><p>选择所需的结帐类型后，按“下一步”按钮或双击所选的结帐类型将前进到“ <a href="Doc04_CheckingOut.html#Doc_CheckoutBranchPoint" title="CDO模型存储库文档中的章节">选择分支点”</a> 。
 </p><p>以下部分描述了不同类型的结帐以及在何种条件下可以使用它们。

</p><h3><a name="Doc_TransactionalCheckouts"></a> 2.1在线交易结账</h3>
<p>在线事务检出基于对存储库的在线<a href="../../javadoc/org/eclipse/emf/cdo/transaction/CDOTransaction.html" title="org.eclipse.emf.cdo.transaction中的接口"><code>transaction</code></a> ，并支持在<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer中</a>修改存储库的资源树和模型元素，以及在受支持的模型编辑器中修改模型资源。此类检出始终在已配置分支的浮动<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>head</code></a>运行，并显示其他用户实时提交给该分支的更改。
 </p><p>可以为任何类型的存储库创建在线事务检出。术语“在线”反映了这种类型的结账需要<a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接的</a>存储库这一事实。在线结帐不会以任何形式在本地存储模型状态。如果关联的存储库已断开连接，则也会关闭在线结帐。
 </p><p>这是默认的结帐类型，提供CDO前所未有的实时模型协作功能。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranch" title="CDO模型存储库文档中的章节">切换结账的分支</a></li>
</ul>


<h3><a name="Doc_HistoricalCheckouts"></a> 2.2在线历史结帐</h3>
<p>在线历史签出基于对存储库的在线<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOView.html" title="org.eclipse.emf.cdo.view中的接口"><code>view</code></a> ，并支持通过<a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO Time Machine View</a>审核存储库的资源树和模型元素。此类型的检出始终在配置的分支的已配置时间戳上运行。由于该时间戳的模型的历史状态是不可变的，因此不显示其他用户提交给该分支的更改。
 </p><p>只能为具有<b>审核</b>或<b>分支</b> <a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">版本控制模式的</a>存储库创建在线历史签出。术语“在线”反映了这种类型的结账需要<a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接的</a>存储库这一事实。在线结帐不会以任何形式在本地存储模型状态。如果关联的存储库已断开连接，则也会关闭在线结帐。
 </p><p>这是结帐类型，提供CDO前所未有的实时时间旅行功能。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranchPoint" title="CDO模型存储库文档中的章节">切换结账的时间戳</a></li>
</ul>


<h3><a name="Doc_OfflineCheckouts"></a> 2.3离线结账</h3>
<p>脱机签出基于存储库本地复制的<a href="../../javadoc/org/eclipse/emf/cdo/transaction/CDOTransaction.html" title="org.eclipse.emf.cdo.transaction中的接口"><code>transaction</code></a> ，并支持在<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer中</a>修改存储库的资源树和模型元素，以及修改受支持的模型编辑器中的模型资源。这种类型的检出始终在配置的分支的浮动<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>head</code></a>运行。在执行<a href="Doc05_UsingCheckouts.html#Doc_OfflineUpdate" title="CDO模型存储库文档中的章节">更新操作</a>之前，不会显示其他用户对该分支提交的更改。
 </p><p>只能为具有<a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">ID生成</a>选项<b>UUID的</b>存储库创建脱机签出。术语“离线”反映了这种类型的结账不需要<a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接的</a>存储库这一事实。脱机检出将模型状态复制到本地数据库中。如果关联的存储库已断开连接，则脱机签出将保持完全正常运行（Checkin或Update等操作除外，这些操作需要活动的存储库连接）。
 </p><p>这是结帐类型，提供CDO前所未有的离线建模功能。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc05_UsingCheckouts.html#Doc_UsingOfflineCheckouts" title="CDO模型存储库文档中的章节">使用脱机结帐</a></li>
</ul>


<h2><a name="Doc_CheckoutBranchPoint"></a> 3选择分支点</h2>
<p>存储库可以包含来自许多不同分支和时间戳的模型和模型元素的状态。结帐向导的第三页允许选择结帐的分支点来创建：</p><p align="center"><img src="checkout-wizard-branchpoint.png">

 </p><p>对于<a href="Doc04_CheckingOut.html#Doc_TransactionalCheckouts" title="CDO模型存储库文档中的章节">事务检出</a> ，时间戳隐含为所选分支的<a href="../../javadoc/org/eclipse/emf/cdo/common/branch/CDOBranch.html#getHead()" title="org.eclipse.emf.cdo.common.branch中的方法。CDOBranch"><code>head</code></a> ，因此向导页面缩减为：</p><p align="center"><img src="checkout-wizard-branch.png">

 </p><p>选择所需分支并选择所需时间戳后，按“下一步”按钮或双击所选分支前进到“ <a href="Doc04_CheckingOut.html#Doc_CheckoutRootObject" title="CDO模型存储库文档中的章节">选择根对象”</a> 。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranchPoint" title="CDO模型存储库文档中的章节">切换结账的时间戳</a></li>
	<li><a href="Doc05_UsingCheckouts.html#Doc_SwitchingBranch" title="CDO模型存储库文档中的章节">切换结账的分支</a></li>
	<li><a href="Doc05_UsingCheckouts.html#Doc_SwitchNewBranch" title="CDO模型存储库文档中的章节">切换到新分支</a></li>
</ul>


<h2><a name="Doc_CheckoutRootObject"></a> 4选择根对象</h2>
<p>CDO <b>不</b>支持<i>部分检出</i> ，即概念，所有行动将始终在库中的所有模型和模型元素进行操作。但是，通过选择与存储库的<a href="../../javadoc/org/eclipse/emf/cdo/view/CDOView.html#getRootResource()" title="org.eclipse.emf.cdo.view中的方法。CDOView"><code>root resource</code></a>不同的根对象，可以将<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer中</a>结帐时显示的文件夹，资源和模型元素限制为此根对象的子项。视觉上，checkout节点等效于所选的根对象：</p><p align="center"><img src="checkout-wizard-rootobject.png">

 </p><p>选择所需的根对象后，按“下一步”按钮或双击所选的根对象前进到<a href="Doc04_CheckingOut.html#Doc_CheckoutName" title="CDO模型存储库文档中的章节">命名结帐</a> 。

</p><h2><a name="Doc_CheckoutName"></a> 5命名结帐</h2>
<p>结帐的第五页和最后一页允许查看先前页面的选择并更改结帐的建议名称/标签以创建：</p><p align="center"><img src="checkout-wizard-name.png">

 </p><p>按Finish按钮将关闭向导并按指定创建新的结帐。</p><p><b>也可以看看：</b></p>
<ul>
	<li><a href="Doc05_UsingCheckouts.html#Doc_RenamingCheckouts" title="CDO模型存储库文档中的章节">重命名结帐</a></li>
	<li><a href="Doc05_UsingCheckouts.html" title="CDO模型存储库文档中的文章">使用Checkout</a></li>
</ul>


<p align="right">
<a href="Doc03_UsingBranches.html" title="落后于分支机构"><img src="../../images/backward.png" border="0"></a> <a href="Doc05_UsingCheckouts.html" title="转发使用结帐"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="2952.bundle_manifest.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">

<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2005, 2011. This page is made available under license. Full for details see the LEGAL in the documentation book that contains this page."></meta>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<link rel="STYLESHEET" href="../../book.css" type="text/css" charset="ISO-8859-1"></link>
<title>OSGi Bundle Manifest</title>
</head>

<body dir="ltr">

<div class="Section1">

<h1>OSGi Bundle Manifest标题</h1>

<p><i>版本3.3  - 最新修订于2011年4月27日</i></p>

<p>捆绑包可以在名为META-INF / MANIFEST.MF的清单文件中携带有关其自身的描述性信息。OSGi R4.3 Framework规范定义了一组清单头，例如Export-Package和Bundle-Classpath，捆绑开发人员使用它来提供有关捆绑包的描述性信息。Equinox OSGi框架实现了完整的OSGi R4.3框架规范和所有Core Framework服务。OSGi R4.3核心框架服务包括以下内容：</p>
<ul>
  <li>包管理服务规范（不建议使用） - 考虑使用新的org.osgi.framework.wiring包</li>
  <li>URL处理程序服务规范</li>
  <li>开始级别服务规范（不建议使用） - 考虑使用新的org.osgi.framework.startlevel包</li>
  <li>条件权限管理规范</li>
  <li>权限管理服务规范</li>
</ul>
  <p>OSGi R4.3概要规范中定义了许多可选服务。Equinox OSGi Framework实现中不包含可选服务。有关OSGi R4.3清单头和服务的信息，请参阅<a href="http://www.osgi.org/Download/Release4V43">OSGi规范</a> 。</p>

<h2>Eclipse Bundle Manifest标题</h2>

<p>Eclipse OSGi Framework支持许多其他bundle清单头和指令。bundle开发人员可以使用这些额外的头文件和指令来利用Eclipse OSGi Framework的一些附加功能，这些功能未被指定为标准OSGi R4 Framework的一部分。
</p>
<h3>其他出口包装指令</h3>

<p>Eclipse OSGi Framework支持Export-Package头的其他指令。这些指令用于指定导出包的访问限制规则。请参阅<a href="runtime-options.html#osgiresolvermode">osgi.resolverMode</a>以配置Eclipse OSGi Framework以在运行时强制执行访问限制规则。
</p>

<h4>x-internal指令</h4>

<p>可以在Export-Package标头中使用x-internal指令来指定包是否为内部包。插件开发环境将阻止其他捆绑包使用内部包。如果未指定x-internal指令，则使用默认值'false'。x-internal指令必须使用以下语法：</p>

<pre>x-internal :: =（'true'|'false'）</pre>

<p>以下是x-internal指令的示例：</p>

<pre>Export-Package：org.eclipse.foo.internal;的x内部：=真</pre>

<h4>x-friends指令</h4>

<p>可以在Export-Package标头中使用x-friends指令来指定允许访问包的包列表。插件开发环境将阻止其他捆绑包使用该包。x-friends指令必须使用以下语法：</p>

<pre>x-friends :: ='“'（target-bundle）（'，'target-bundle）*'”'target-bundle :: =包符号名称</pre>

<p>以下是x-friends指令的示例：</p>

<pre>Export-Package：org.eclipse.foo.formyfriends; x-friends：=“org.eclipse.foo.friend1，org.eclipse.foo.friend2”</pre>

<p>该示例指定仅鼓励捆绑org.eclipse.foo.friend1和org.eclipse.foo.friend2使用org.eclipse.foo.formyfriends包。x-internal包优先于x-friends指令。如果x-internal指令指定'true'，那么插件开发环境将阻止所有bundle使用该包，即使它们被指定为朋友也是如此。
</p>

<h3>Eclipse-LazyStart标头</h3>

<p>Eclipse-LazyStart标头用于指定是否应在从该捆绑包访问第一个类或资源之前启动捆绑包。此功能允许Eclipse在第一次需要时懒惰地激活bundle。使用此模型，Eclipse可以使用尽可能少的活动包启动。Eclipse-LazyStart标头必须使用以下语法：</p>

<pre>Eclipse-LazyStart :: =（'true'|'false'）（';''exceptions''=''''exceptions-list'“'）？exceptions-list :: =逗号'，'分隔的包列表</pre>

<p>当Eclipse的使用LazyStart是真实的，“例外”属性<b>会不会</b>造成当类是从他们加载束被激活包的列表。当Eclipse-LazyStart为false时，'exceptions'属性指定一个包列表，这些包<b>将</b>导致从它们加载类时激活包。例外规则适用于列出的包中的所有类。激活bundle时，将调用bundle的BundleActivator.start（BundleContext）方法。
</p>
<p>如果未在bundle清单中定义Eclipse-LazyStart标头，则使用默认值'false'。以下是Eclipse-LazyStart标头的示例：</p>

<pre>Eclipse-LazyStart：true; exceptions =“org.eclipse.foo1，org.eclipse.foo2”</pre>

<p>该示例指定必须为从此包加载的任何类激活此包，但包'org.eclipse.foo1'和'org.eclipse.foo2'中的类除外。
</p>

<p>Eclipse 3.4中不推荐使用Eclipse-AutoStart和Eclipse-LazyStart头文件。从OSGi R4.1规范开始，OSGi规范采用了延迟激活策略。新的OSGi包清单标头Bundle-ActivationPolicy可用于指定延迟激活策略。
</p>

<p>Equinox Framework 3.4或更高版本将继续支持已弃用的Eclipse-LazyStart和Eclipse-AutoStart标头。希望捆绑包在其他OSGi Framework实现中工作的捆绑开发人员应将Bundle-ActivationPolicy标头添加到其清单中。在大多数情况下，您只需添加以下标头：</p>

<pre>Bundle-ActivationPolicy：懒惰</pre>

<p>如果'exceptions'属性与Eclipse-LazyStart或Eclipse-AutoStart标头一起使用，那么'include'或'exclude'指令可以与Bundle-ActivationPolicy标头一起使用。请考虑以下Eclipse-LazyStart标头：</p>

<pre>Eclipse-LazyStart：true; exceptions =“org.eclipse.foo1，org.eclipse.foo2”</pre>

<p>等效的Bundle-ActivationPolicy标头如下：</p>

<pre>Bundle-ActivationPolicy：懒惰; exclude：=“org.eclipse.foo1，org.eclipse.foo2”</pre>

<p>以下是使用带异常属性的false值的Eclipse-LazyStart标头示例：</p>

<pre>Eclipse-LazyStart：false; exceptions =“org.eclipse.foo1，org.eclipse.foo2”</pre>

<p>等效的Bundle-ActivationPolicy标头如下：</p>

<pre>Bundle-ActivationPolicy：懒惰; include：=“org.eclipse.foo1，org.eclipse.foo2”</pre>

<h3>Eclipse-PlatformFilter标头</h3>

<p>Eclipse-PlatformFilter用于为bundle指定平台过滤器。平台过滤器必须在运行的平台中评估为true才能允许解析捆绑包。Eclipse-PlatformFilter标头必须使用以下语法：</p>

<pre>Eclipse-PlatformFilter :: =有效的LDAP过滤字符串</pre>

<p>Framework支持对以下系统属性进行过滤：</p>

<ul type="disc">
 <li><b>osgi.nl</b> - 平台语言设置。</li>
 <li><b>osgi.os</b> - 平台操作系统。</li>
 <li><b>osgi.arch</b> - 平台架构。</li>
 <li><b>osgi.ws</b> - 平台窗口系统。</li>
</ul>

<p>以下是Eclipse-PlatformFilter标头的示例：</p>

<pre>Eclipse-PlatformFilter：（＆（osgi.ws = win32）（osgi.os = win32）（osgi.arch = x86））</pre>

<p>此示例指定只有在平台属性为osgi.ws = win32和osgi.os = win32和osgi.arch = x86时才能解析此捆绑包。换句话说，在x86架构上运行的平台，使用win32操作系统和win32窗口系统。
</p>

<h3>Eclipse-BuddyPolicy标头</h3>

<p>Eclipse-BuddyPolicy标头用于指定包的伙伴类加载策略。Eclipse-BuddyPolicy标头必须使用以下语法：</p>

<pre>Eclipse-BuddyPolicy :: =（policy-name）（'，'policy-name）* policy-name :: =（'dependent'|'global'|'registered'|'app'|'ext'|''boot' |'父母'）</pre>

<p>以下是Eclipse-BuddyPolicy标头的示例：</p>

<pre>Eclipse-BuddyPolicy：依赖</pre>

<h3>Eclipse-RegisterBuddy标题</h3>

<p>Eclipse-RegisterBuddy标头用于声明一个逗号分隔的包的符号名称列表，该包应该是注册伙伴。具有指定符号名称的bundle必须使用已<b>注册的</b>伙伴策略（由Eclipse-BuddyPolicy指定）头，以使此bundle成为注册伙伴。
</p>
<p>请注意，在捆绑<b>X</b>成为另一个捆绑<b>Y</b>的注册伙伴之前，必须满足以下条件：</p>
<ul>
 <li>包<b>Y</b>必须指定<b>注册的</b>伙伴策略（即Eclipse-BuddyPolicy：已注册）</li>
 <li>包<b>X</b>必须在Eclipse-RegisterBuddy头中指定<b>Y</b>的符号名称（即Eclipse-RegisterBuddy：Y）</li>
 <li>捆绑<b>X</b>必须依赖于捆绑<b>Y</b>导出的包。这可以通过Require-Bundle或Import-Package约束来实现。</li>
</ul>
<p>Eclipse-RegisterBuddy标头的语法如下：</p>

<pre>Eclipse-RegisterBuddy :: =（target-bundle）（'，'target-bundle）* target-bundle :: =包符号名称</pre>

<p>以下是Eclipse-RegisterBuddy标头的示例：</p>

<pre>Eclipse-RegisterBuddy：org.eclipse.foo.bundle1，org.eclipse.foo.bundle2</pre>

<h3>Eclipse-ExtensibleAPI标头</h3>

<p>Eclipse-ExtensibleAPI用于指定主机包是否允许片段包向主机添加其他API。如果主机包想要允许片段将其他包添加到主机的API，则应使用此标头。如果未指定此标头，则使用默认值“false”。请注意，此标头仅供工具（PDE）用于构建正确的构建类路径。<b>运行时根本不使用此标头。</b>  在运行时，始终允许片段将其他包，类和资源添加到主机的API。Eclipse-ExtensibleAPI标头必须使用以下语法：</p>

<pre>Eclipse-ExtensibleAPI :: =（'true'|'false'）</pre>

<p>以下是Eclipse-ExtensibleAPI标头的示例：</p>

<pre>Eclipse-ExtensibleAPI：true</pre>

<h3>Eclipse-BundleShape标题</h3>

<p>Eclipse-BundleShape标头用于指定捆绑包在将捆绑包配置到Eclipse安装时应使用的部署形状。
<b>运行时根本不使用此标头。</b>  此标头仅供构建和配置系统用于确定如何部署捆绑包。Eclipse-BundleShape标头必须使用以下语法：</p>

<pre>Eclipse-BundleShape :: =（'jar'|'dir'）</pre>

<p>“jar”值表示捆绑应该部署为jar。“dir”值表示在部署到Eclipse安装时，应将该包解压缩到目录中。
</p>

<p>如果产品使用PDE构建基于功能的产品，那么，如果指定，feature.xml文件中的unpack属性的值优先于Eclipse-BundleShape标头。
</p>

<p>以下是Eclipse-BundleShape标头的示例：</p>

<pre>Eclipse-BundleShape：jar</pre>

<h3>Eclipse-GenericCapability标头</h3>

<p>
<b>注意：</b>不推荐使用Eclipse-GenericCapability标头。OSGi R4.3核心框架规范包括一个新的头<b>提供能力</b> ，可用于指定捆绑提供的通用功能。Equinox将继续支持Eclipse-GenericCapability标头和新的OSGi Provide-Capability标头。
</p>
<p>Eclipse-GenericCapability标头用于指定包的通用功能。通用功能可用于描述捆绑包的功能，系统中的其他捆绑包可能需要这些功能（使用Eclipse-GenericRequire标头）。通用功能具有名称和功能类型。能力类型由提供该功能的捆绑包定义。功能还可以具有一组类型匹配属性，用于在解析Eclipse-GenericRequire标头时进行匹配。匹配属性可以是以下类型之一; [string |版本| uri |长|双|组]。set类型可用于将一组字符串定义为逗号分隔的字符串列表。Eclipse-GenericCapability标头必须使用以下语法：</p>

<pre>Eclipse-GenericCapability :: = capability（'，'capability）* capability :: = typed-name（';'typed-name）*（';'typed-param）* typed-name :: = name（'：' capability-type）typed-param :: = typed-key'='quouted-string typed-key :: = name（'：'[string | version | uri | long | double | set]）</pre>

<p>以下是Eclipse-GenericCapability标头的示例，该标头可用于指定具有OSGi服务org.acme.stuff的包。SomeService实现：</p>

<pre>Eclipse-GenericCapability：org.acme.stuff。SomeService：osgi.service;版本：版本= “1.0.1”</pre>

<h3>Eclipse-GenericRequire标头</h3>

<p>
<b>注意：</b>不推荐使用Eclipse-GenericRequire标头。OSGi R4.3核心框架规范包括一个新的标头<b>Require-Capability</b> ，可用于指定另一个bundle提供的通用功能的要求。Equinox将继续支持Eclipse-GenericRequire标头和新的OSGi Require-Capability标头。
</p>

<p>Eclipse-GenericRequire标头用于指定对另一个包提供的通用功能的要求（使用Eclipse-GenericCapability标头）。通用要求具有名称和功能类型。能力类型由提供该功能的捆绑包定义。通用要求可以指定LDAP过滤器字符串，该字符串用作选择过滤器以解决匹配的通用功能。Eclipse-GenericRequire标头必须使用以下语法：</p>

<pre>Eclipse-GenericRequire :: = generic-require（'，'generic-require）* generic-require :: = typed-name（';'typed-name）*（';'selection-filter'='quoated-ldapFilter） （';'optional'='[true | false]）（';'multiple'='[true | false]）typed-name :: = name（'：'capability-type）</pre>

<p>以下是Eclipse-GenericRequire标头的示例，该标头可用于指定依赖于OSGi服务org.acme.stuff的包。SomeService实现：</p>

<pre>Eclipse-GenericRequire：org.acme.stuff。SomeService：osgi.service;选择过滤器= “（版本&gt; = 1.0.1）”</pre>

<h3>通用别名</h3>
<p><a href="runtime-options.html#osgigenericAliases">osgi.genericAliases</a>选项可用于将现有OSGi清单头映射到Eclipse-GenericCapability和Eclipse-GenericRequire清单头。例如，请考虑以下清单标头</p>
<pre>出口服务：org.acme.stuff。SomeService Import-Service：org.acme.stuff。SomeService</pre>

<p>可以使用以下属性将这些头映射到Eclipse-GenericCapability和Eclipse-GenericRequire头：</p>
<pre>osgi.genericAliases =出口 - 服务：进口服务：osgi.service</pre>
<p>这将涵盖以下通用标头：</p>
<pre>Eclipse-GenericRequire：org.acme.stuff。SomeService：osgi.service Eclipse-GenericCapability：org.acme.stuff。SomeService：osgi.service</pre>

<h3>插件类标题</h3>

<p>Plugin-Class标头仅用于支持为Eclipse 2.1平台开发的插件。此标头用于指定将使用旧的Eclipse 2.1激活模型激活插件的类名。为Eclipse 3.0或更高版本开发的新捆绑包不应使用此标头。以下是Plugin-Class标头的示例：</p>

<pre>Plugin-Class：org.eclipse.foo。FooPlugin</pre>

</div>

</body>

</html><html id="2301.OCLinPapyrus.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>UML中的OCL（使用Papyrus）</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="UsersGuide.html" title="Users Guide"></link>
<link rel="prev" href="Integration.html" title="OCL Integration"></link>
<link rel="next" href="OCLExamplesforUML.html" title="OCL Constraint Examples for UML (using Papyrus)"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">UML中的OCL（使用Papyrus）</h1>
<div class="section" title="UML中的OCL（使用Papyrus）">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="OCLinPapyrus"></a> UML中的OCL（使用Papyrus）</h2>
</div>
</div>
</div>
<p>（本文档适用于Papyrus 1.0.0。）</p>
<p>可以使用OCL来定义UML模型的行为</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>运作机构</p>
</li>
<li class="listitem">
<p>属性派生/初始化程序</p>
</li>
<li class="listitem">
<p>用户模型实例要观察的类不变量</p>
</li>
<li class="listitem">
<p>用户模型元素要观察的构造型不变量</p>
</li>
<li class="listitem">
<p>国家机器的守卫</p>
</li>
</ul>
</div>
<div class="section" title="UML集成">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinPapyrus-UML-integration"></a> UML集成</h3>
</div>
</div>
</div>
<p>尽管UML元模型广泛使用OCL来指定其自身的良构，但是没有明确的能力在UML中使用OCL。通过ValueSpecification类和OpaqueExpression扩展的灵活性，可以使用OCL或任何其他语言。</p>
<p>元模型指定ValueSpecification的使用，只要可以通过各种技术合理地提供值。例如，可以通过LiteralString或LiteralInteger提供简单值。OpaqueExpression有更多有趣的值，它有两个有趣的列表功能，一个是语言名称，另一个是相应语言中的字符串主体。这些列表提供了以各种语言提供实现的能力。实际上只使用一个，如果省略语言名称，则假定实现默认值为OCL。</p>
<p>诸如“name.toUpper（）”之类的行为的指定可以通过OpaqueExpression来实现，其中语言是Sequence（'OCL'）而body是Sequence（'name.toUpper（）'）。因此，OCL以文本形式嵌入，该文本形式不了解OCL元模型中的类。</p>
<p>OCL Java API的用户可以通过利用扩展ValueSpecification并将功能委托给OCLExpression的OCL的ExpressionInOCL类来避免产生OCL解析成本的需要。</p>
</div>
<div class="section" title="类图">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinPapyrus-Class-Diagram"></a>类图</h3>
</div>
</div>
</div>
<div class="section" title="类不变量">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-Class-Invariant"></a>类不变量</h4>
</div>
</div>
</div>
<p>类不变量指定对于类的所有格式良好的实例必须为true的约束。它在Papyrus中指定，通过：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在类图上创建约束节点</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择调色板上的约束</p>
</li>
<li class="listitem">
<p>点击你想要的图表</p>
</li>
<li class="listitem">
<p>单击您想要的类作为约束上下文</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>可选择替换自动生成的约束名称</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>在“属性”视图中键入新名称</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>使用OCL文本定义约束规范</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>键入F2（或再次单击）以打开Essential OCL编辑器</p>
</li>
<li class="listitem">
<p>输入所需的约束文本</p>
</li>
<li class="listitem">
<p>单击编辑器外部以关闭</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-class-invariant.png"></div>
<p>
					
</p>
<p>«Context»链接提供了Properties视图中Context选择的图形视图。它是定义OCL <code class="code">self</code>类型的上下文，因此定义了受约束的内容。
					</p>
<p>您可以使用如上所述的直接编辑或“属性视图”编辑OCL文本。（请注意，编辑器在第一次使用时具有显着的启动时间，因此请耐心等待）。</p>
<p>您的OCL文本条目会自动验证;如果不满意，将在Constraint上显示错误或警告标记。一旦纠正了错误，您可能需要调用<span class="bold"><strong>Validate-&gt; Model Tree</strong></span>来使标记消失。
					</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-class-invariant-error.png"></div>
<p>
					
</p>
</div>
<div class="section" title="操作前提，后置条件和身体">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-Operation-Constraints"></a>操作前提，后置条件和身体</h4>
</div>
</div>
</div>
<p>前提条件指定在操作执行开始之前必须满足的约束。</p>
<p>后置条件指定在操作执行完成后必须满足的约束。后置条件可以使用保留的参数名称<code class="code">result</code>来引用OCL允许的一个结果。 @pre后缀可用于在执行操作之前引用变量的状态。
					</p>
<p>在OCL中，body-expression将查询操作的功能定义为结果类型值表达式，例如<code class="code">some-computation</code> 。相比之下，在UML中，正文条件将操作的功能定义为对结果的布尔值约束，例如<code class="code">result = (some-computation)</code> 。Papyrus支持OCL解释，因此可以省略<code class="code">result = (...)</code>包装器。
					</p>
<p>在Papyrus中，一旦确定了手术，就可以得到先决条件，后置条件和身体状况</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在类图上创建约束节点</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择调色板上的约束</p>
</li>
<li class="listitem">
<p>点击你想要的图表</p>
</li>
<li class="listitem">
<p>键入Esc，因为无法将上下文链接绘制到操作</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>可选择替换自动生成的约束名称</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>在“属性”视图中键入新名称</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>定义约束上下文</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择操作</p>
</li>
<li class="listitem">
<p>使用适当的添加元素（+图标）作为前置条件或后置条件，或使用正文条件<span class="bold"><strong>...</strong></span>浏览器来定位约束</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>使用OCL文本定义约束规范</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>键入F2（或再次单击）以打开Essential OCL编辑器</p>
</li>
<li class="listitem">
<p>输入所需的约束文本</p>
</li>
<li class="listitem">
<p>单击编辑器外部以关闭</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>请注意，必须通过将约束分配给前置条件/后置条件/主体条件角色之一来指定操作约束的上下文。约束上下文的赋值直接无法将约束分配给其角色。</p>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-operation-constraints.png"></div>
<p>
					
</p>
<p>请注意，在Papyrus 1.0中，没有刻板印象显示前置条件/后置条件/身体条件角色。</p>
<p>请注意，前置条件和后置条件的OCL表达式应该是布尔值。结果值的身体表达形式应该用于身体状况。</p>
<p>操作的拥有类型用作OCL的<code class="code">self</code>上下文。
					</p>
<p>如果提供了身体状况，则操作应该是查询。</p>
<p>
						
<span class="italic">在Luna中，在后置条件中使用<code class="code">result</code>错误地报告未知属性。错误可以忽略。
						</span>
					
</p>
</div>
<div class="section" title="属性初始化器">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-Property-Initializers"></a>属性初始化器</h4>
</div>
</div>
</div>
<p>其值为OCL表达式字符串的OpaqueExpression可用于定义Property初始值设定项的默认值或派生值。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>选择属性以使属性视图相关</p>
</li>
<li class="listitem">
<p>单击“为默认值创建新对象（+图标）”</p>
</li>
<li class="listitem">
<p>从菜单中选择OpaqueExpression</p>
</li>
<li class="listitem">
<p>单击语言的添加元素（+图标）</p>
</li>
<li class="listitem">
<p>在左窗格中选择OCL，然后单击向右箭头以移动到右窗格</p>
</li>
<li class="listitem">
<p>单击确定</p>
</li>
<li class="listitem">
<p>在大窗格中输入OCL文本</p>
</li>
<li class="listitem">
<p>单击确定</p>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-property-constraint.png"></div>
<p>
					
</p>
<p>
						
<span class="italic">不幸的是，在Luna中，上下文似乎没有为编辑器正确设置，因此<code class="code">self</code>出错并且没有语法帮助。
						</span>
					
</p>
</div>
<div class="section" title="配置文件约束">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-Profile-Constraint"></a>配置文件约束</h4>
</div>
</div>
</div>
<p>Profile Constraint与Class Invariant非常相似。但是，由于Profile是Constraint是在M2处绘制的，因此可以在M1处对其进行评估以检查UML类图是否一致。相比之下，在M1处绘制的类不变量可以通过M0处的用户工具来评估以验证用户模型。它在Papyrus中指定，通过：</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在配置文件图上创建约束节点</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择调色板上的约束</p>
</li>
<li class="listitem">
<p>点击你想要的图表</p>
</li>
<li class="listitem">
<p>单击您想要的Stereotype作为Constraint上下文</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>可选择替换自动生成的约束名称</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>在“属性”视图中键入新名称</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>使用OCL文本定义约束规范</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择约束</p>
</li>
<li class="listitem">
<p>键入F2（或再次单击）以打开Essential OCL编辑器</p>
</li>
<li class="listitem">
<p>输入所需的约束文本</p>
</li>
<li class="listitem">
<p>单击编辑器外部以关闭</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-profile-constraint.png"></div>
<p>
					
</p>
<p>也可以在“属性”视图中编辑OCL文本。</p>
</div>
</div>
<div class="section" title="状态机图">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLinPapyrus-StateMachine-Diagram"></a>状态机图</h3>
</div>
</div>
</div>
<p>StateMachine图的主要元素是StateMachine，它是一个Type，但通常不具有Properties。因此，应将StateMachine定义为包含类型的嵌套类型。这可以通过将StateMachine拖动为Class的子级来在Papyrus Model Explorer中实现。</p>
<div class="section" title="Statemachine Constraint">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-State-Constraint"></a> Statemachine Constraint</h4>
</div>
</div>
</div>
<p>约束可以以类似于Class的方式应用于Statemachine，以指定Statemachine的不变量。</p>
</div>
<div class="section" title="Statemachine Transition Guard">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="OCLinPapyrus-Transition-Guard"></a> Statemachine Transition Guard</h4>
</div>
</div>
</div>
<p>可以通过将约束与转换相关联来指定Statemachine Transition的保护条件。转换应该已经存在，并且Statemachine应该是OCL <code class="code">self</code>的合适类型的嵌套类型。保护条件由Papyrus提取</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>在StateMachine Diagram上创建一个Constraint Node</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>选择调色板上的约束</p>
</li>
<li class="listitem">
<p>点击你想要的图表</p>
</li>
<li class="listitem">
<p>可选择输入所需的约束文本</p>
</li>
<li class="listitem">
<p>键入Esc以关闭编辑器</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>可选择替换自动生成的约束名称</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>如果尚未选择约束，请选择约束</p>
</li>
<li class="listitem">
<p>在“属性”视图中键入新名称</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>定义约束上下文</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>如果尚未选择约束，请选择约束</p>
</li>
<li class="listitem">
<p>使用Properties视图中的Context <span class="bold"><strong>...</strong></span>浏览器来定位转换</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>使用OCL文本定义约束规范</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>如果尚未选择约束，请选择约束</p>
</li>
<li class="listitem">
<p>键入F2（或再次单击）以打开Essential OCL编辑器</p>
</li>
<li class="listitem">
<p>输入所需的约束文本</p>
</li>
<li class="listitem">
<p>单击编辑器外部以关闭</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>
						
</p>
<div class="mediaobject">
<img src="images/1710-transition-guard.png"></div>
<p>
					
</p>
<p>必需的Transition被指定为Transition的Guard。</p>
<p>Statemachine的拥有类型定义了OCL的<code class="code">self</code> 。在没有拥有类型的情况下， <code class="code">self</code>将是未定义的，并且OCL约束验证将失败。因此，您必须确保StateMachine具有Class父级，并且Class具有所需的属性;此示例的<code class="code">name</code> 。使用类图定义类和属性后。该</p>
</div>
</div>
</div>
</body>
</html><html id="3290.tutorial_existingdemo.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr">
 <head>
  <meta charset="UTF-8"></meta>
  <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="generator" content="Asciidoctor 1.5.5"></meta>
  <title>导入Scout演示应用程序</title>
  <link rel="stylesheet" href="asset?aid=0"></link>
  <link rel="stylesheet" href="css/eclipse.css"></link>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css"></link>
  <link rel="stylesheet" href="css/coderay-eclipse.css"></link>
 </head>
 <body class="article" dir="ltr">
  <table border="0" class="navigation" style="width:100%" summary="navigation">
   <tr>
    <td align="left" colspan="1" rowspan="1" style="width:30%"><a href="tutorial_helloworld.html" shape="rect" title="Hello World Tutorial"><img alt="以前" border="0" src="images/prev.gif"></a></td>
    <td align="center" colspan="1" rowspan="1" style="width:40%"></td>
    <td align="right" colspan="1" rowspan="1" style="width:30%"><a href="sdk.html" shape="rect" title="侦察工具"><img alt="下一个" border="0" src="images/next.gif"></a></td>
   </tr>
   <tr>
    <td align="left" colspan="1" rowspan="1" style="width:30%">Hello World Tutorial</td>
    <td align="center" colspan="1" rowspan="1" style="width:40%"></td>
    <td align="right" colspan="1" rowspan="1" style="width:30%">侦察工具</td>
   </tr>
  </table>
  <div id="header">
  </div>
  <div id="content">
   <div class="sect2">
    <h3 id="import-the-scout-demo-applications"><a class="anchor" href="#import-the-scout-demo-applications"></a>导入Scout演示应用程序</h3>
    <div class="paragraph">
     <p>在本教程中，您将学习如何将Scout演示应用程序导入工作区。本教程包含以下两部分：</p>
    </div>
    <div class="ulist">
     <ul>
      <li> <p>安装Scout演示应用程序</p> </li>
      <li> <p>从IDE运行Scout演示</p> </li>
     </ul>
    </div>
    <div class="sect3">
     <h4 id="install-the-scout-demo-application"><a class="anchor" href="#install-the-scout-demo-application"></a>安装Scout演示应用程序</h4>
     <div class="paragraph">
      <p>在本教程的第一部分中，我们使用<a href="https://wiki.eclipse.org/Eclipse_Installer" target="_blank">Oomph Eclipse安装程序</a>工具导入演示应用程序。</p>
     </div>
     <div class="paragraph">
      <p>在Eclipse IDE中打开<em class="wizard">导入</em>向导与菜单<span class="menuseq"><span class="menu">文件</span> ▸ <span class="menuitem">导入...。</span></span>这将打开<a href="#img-oomph_existing_project">如图1</a>所示的对话框。接下来，在文件夹<em class="folder">Oomph</em>下，选择<em class="folder">Projects into Workspace</em>节点，然后单击<b class="button">Next</b>按钮。</p>
     </div>
     <div id="img-oomph_existing_project" class="imageblock">
      <div class="content">
       <img src="images/oomph_existing_project.png" alt="oomph现有项目">
      </div>
      <div class="title">图1。Eclipse中的导入向导。
      </div>
     </div>
     <div class="paragraph">
      <p><em class="wizard">Eclipse Importer</em>包含文件夹层次结构<em class="folder">Eclipse Projects</em> ， <em class="folder">Scout</em>和<em class="folder">Scout Demo App</em> ， <a href="#img-oomph_exiting_projects1">如图2</a>所示。您可以在搜索过滤器中输入“Scout Demo”以轻松查找项目。</p>
     </div>
     <div id="img-oomph_exiting_projects1" class="imageblock">
      <div class="content">
       <img src="images/oomph_exiting_projects1.png" alt="oomph退出项目1">
      </div>
      <div class="title">图2。进口商“项目”步骤的顶部。
      </div>
     </div>
     <div class="paragraph">
      <p>现在，根据以下步骤将所需项目添加到列表中以进行导入。</p>
     </div>
     <div class="ulist">
      <ul>
       <li> <p>[1]选择“Scout Demo App”元素。</p> </li>
       <li> <p>[2]使用<b class="button">“添加项目”</b> （向下箭头）按钮将其添加到项目列表中。</p> </li>
       <li> <p>[3]将Stream调整为与Eclipse IDE匹配的里程碑版本，例如。2016年1月的“霓虹灯（M4发布）”。</p> </li>
      </ul>
     </div>
     <div id="img-oomph_exiting_projects2" class="imageblock">
      <div class="content">
       <img src="images/oomph_exiting_projects2.png" alt="oomph退出项目2">
      </div>
      <div class="title">图3。进口商“项目”步骤的底部部分。
      </div>
     </div>
     <div class="paragraph">
      <p>Eclipse导入器中的项目选择<a href="#img-oomph_exiting_projects2">如图3</a>所示，单击<b class="button">Next</b>按钮。</p>
     </div>
     <div class="paragraph">
      <p>在Eclipse导入器的<em class="wizard">Variables</em>对话框中，必须指定许多Oomph变量。如果您已将Oomph用于其他目的，则此步骤可能看起来不同或为空（例如，在先前的Oomph会话中设置了所有变量时）。</p>
     </div>
     <div class="paragraph">
      <p>确保通过激活左下角的<code>Show all Variables</code>复选框<code>Show all Variables</code> ， <a href="#img-oomph_exiting_variables">如图4</a>所示。</p>
     </div>
     <div id="img-oomph_exiting_variables" class="imageblock">
      <div class="content">
       <img src="images/oomph_exiting_variables.png" alt="oomph退出变量">
      </div>
      <div class="title">图4.导入器的“变量”步骤。
      </div>
     </div>
     <div class="admonitionblock warning">
      <table>
       <tbody>
        <tr>
         <td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
         <td class="content">在您的情况下， <a href="#img-oomph_exiting_variables">图4中</a>的变量可能以不同的顺序显示。</td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="paragraph">
      <p>在继续之前，请确保为您的用例设置了所有显示的变量。对于下面提出的设置，我们假设我们只需要对托管Scout演示应用程序的git存储库进行读访问。</p>
     </div>
     <div class="ulist">
      <ul>
       <li> <p><code>Git clone location rule</code> ：“位于工作区文件夹中名为'.git / &lt;repo&gt;'的文件夹中”</p> </li>
       <li> <p><code>Target Platform</code> ：“无”</p> </li>
       <li> <p><code>JRE 1.7 Location</code> ：Java 7 JRE的路径</p> </li>
       <li> <p><code>JRE 1.8 Location</code> ：Java 8 JRE的路径</p> </li>
       <li> <p><code>Scout Demo App Github repository</code> ：“HTTPS（读写）”如果您已经拥有GitHub帐户。否则使用“HTTPS（只读，匿名）”</p> </li>
      </ul>
     </div>
     <div class="paragraph">
      <p>完成变量设置后，单击“ <b class="button">下一步”</b> 。这将导致“ <em class="wizard">确认”</em>对话框。单击“ <b class="button">完成”</b>可以完成最后一步。</p>
     </div>
     <div class="paragraph">
      <p>Oomph安装程序首先确保所有必需的Scout组件和M2E连接器都可用。如果缺少一个或多个组件，Oomph将首先下载并安装它们。这会触发重启请求， <a href="#img-oomph_restart">如图5</a>所示。</p>
     </div>
     <div id="img-oomph_restart" class="imageblock">
      <div class="content">
       <img src="images/oomph_restart.png" alt="嗯重启">
      </div>
      <div class="title">图5。安装后重新启动IDE。
      </div>
     </div>
     <div class="paragraph">
      <p>要完成安装，请单击“ <b class="button">完成”</b> 。如果需要重新启动IDE，请在<em class="wizard">Eclipse Launcher</em>对话框中选择相同的工作区。</p>
     </div>
     <div class="paragraph">
      <p>重启后，Oomph将继续下载并安装Scout演示应用程序，显示Eclipse导入器对话框中的进度。下载和安装完成后，您可以单击“ <b class="button">完成”</b>按钮关闭对话框。</p>
     </div>
     <div class="sect4">
      <h5 id="setup-result"><a class="anchor" href="#setup-result"></a>设置结果</h5>
      <div class="paragraph">
       <p>在“Scout Demo App”的设置之后，很多项目在工作区中实现（参见<a href="#img-oomph_workingsets">图6中</a>的屏幕截图）。这些项目分为三个工作组：</p>
      </div>
      <div class="dlist">
       <dl>
        <dt class="hdlist1">演示应用程序：联系人</dt>
        <dd>
         <p>与Scout演示应用程序“Contacts”对应的项目。</p>
        </dd>
        <dt class="hdlist1">演示应用程序：小部件</dt>
        <dd>
         <p>与Scout Demo Application“Widgets”对应的项目。</p>
        </dd>
        <dt class="hdlist1">演示文档</dt>
        <dd>
         <p>侦察文档和包含文档中包含的大部分代码片段的项目。</p>
        </dd>
       </dl>
      </div>
      <div id="img-oomph_workingsets" class="imageblock">
       <div class="content">
        <img src="images/oomph_workingsets.png" alt="oomph工作集">
       </div>
       <div class="title">图6。“Scout Demo App”设置后工作区中的项目。
       </div>
      </div>
      <div class="paragraph">
       <p>如果没有看到工作集，则可能需要从菜单中选择“ <span class="menuseq"><span class="menu">顶级元素</span> ▸ <span class="menuitem">工作集</span></span> ”， <a href="#img-workingsets_top_level">如图7所示。</a></p>
      </div>
      <div id="img-workingsets_top_level" class="imageblock">
       <div class="content">
        <img src="images/workingsets_top_level.png" alt="工作组顶级">
       </div>
       <div class="title">图7。在“包资源管理器”中选择“工作集”作为“顶级元素”。
       </div>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="run-the-contacts-demo-application"><a class="anchor" href="#run-the-contacts-demo-application"></a>运行“联系人演示应用程序”</h4>
     <div class="paragraph">
      <p>通过在我们的工作区中安装Scout演示，我们现在可以从IDE中启动应用程序了。</p>
     </div>
     <div class="sect4">
      <h5 id="start-the-application-in-the-ide"><a class="anchor" href="#start-the-application-in-the-ide"></a>在IDE中启动该应用程序</h5>
      <div class="paragraph">
       <p>在IDE的<em class="wizard">Package Explorer</em>视图中，打开Maven模块<code>org.eclipse.scout.contacts.all.app.dev</code> 。要运行Contacts应用程序，请使用文件<code>contacts-all-dev.launch</code>上的<em class="menu">Run As</em>上下文菜单， <a href="#img-oomph_run_contacts_all">如图8</a>所示。</p>
      </div>
      <div id="img-oomph_run_contacts_all" class="imageblock">
       <div class="content">
        <img src="images/run_contracts_all_dev.png" alt="运行合同所有开发">
       </div>
       <div class="title">图8。启动Contacts应用程序。
       </div>
      </div>
      <div class="paragraph">
       <p>一旦Contacts应用程序的启动顺序完成，Eclipse IDE中的控制台视图应<a href="#img-oomph_contacts_console">如图9所示</a> 。</p>
      </div>
      <div id="img-oomph_contacts_console" class="imageblock">
       <div class="content">
        <img src="images/oomph_contacts_console.png" alt="oomph联系控制台">
       </div>
       <div class="title">图9。启动Contacts演示后的控制台视图。
       </div>
      </div>
     </div>
     <div class="sect4">
      <h5 id="use-the-contacts-demo-in-a-browser"><a class="anchor" href="#use-the-contacts-demo-in-a-browser"></a>在浏览器中使用“联系人演示”</h5>
      <div class="paragraph">
       <p>通过IDE中运行的Contacts演示，可以通过URL <a href="http://localhost:8082/" class="bare" target="_blank">http：// localhost：8082 /</a>在您喜欢的浏览器中打开应用程序。要获得<a href="#img-contacts_persons_alice">图10</a>中<a href="#img-contacts_persons_alice">所示</a>的屏幕，首先单击<em class="folder">Persons</em>节点，然后双击''Alice''行。</p>
      </div>
      <div id="img-contacts_persons_alice" class="imageblock">
       <div class="content">
        <img src="images/contacts_persons_alice.png" alt="联系人爱丽丝">
       </div>
       <div class="title">图10。联系人应用程序。
       </div>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="what-s-next"><a class="anchor" href="#what-s-next"></a>下一步是什么？</h4>
     <div class="paragraph">
      <p>使用“联系人”应用程序。这提供了典型Scout应用程序的良好概述。您可以浏览数据，打开不同的表单并添加/更改实体。</p>
     </div>
     <div class="paragraph">
      <p>还快速查看代码。包含节点<em class="folder">Persons</em>和<em class="folder">Organizations</em>的应用程序左侧的列表在<span class="java">ContactOutline</span>类中实现，如<a href="#lst-contacts_outline">清单1</a>所示。</p>
     </div>
     <div id="lst-contacts_outline" class="listingblock">
      <div class="title">清单1。ContactOutline实现。
      </div>
      <div class="content">
       <pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ContactOutline</span> <span class="directive">扩展</span> AbstractOutline <span class="annotation">{@覆盖</span> <span class="directive">保护</span> <span class="type">无效</span> execCreateChildPages（ <span class="predefined-type">名单</span> &lt;的iPage &lt;？&gt;&gt; pageList）{ <span class="comment">//要在此大纲的导航区域中显示的页面</span> pageList.add（ <span class="keyword">new</span> PersonTablePage（））; <i class="conum" data-value="1"></i> <b>（1）</b> pageList.add（ <span class="keyword">new</span> OrganizationTablePage（））; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> getConfiguredTitle（）{ <span class="keyword">return</span> TEXTS.get（ <span class="string"><span class="delimiter">“</span> <span class="content">Contacts</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Override</span> <span class="directive">protected</span> <span class="predefined-type">String</span> getConfiguredIconId（）{ <span class="keyword">return</span> Icons。类别; }}</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>如果您单击了“ <em class="folder">人员”</em>节点，则会显示包含所有可用人员的页面。此页面在<span class="java">PersonTablePage</span>类中实现，显示/ <span class="java">编辑人员</span>的对话框在<span class="java">PersonForm</span>类中<span class="java">实现</span> 。</p>
     </div>
     <div class="paragraph">
      <p>这是<a href="tutorial.html#tutorial">入门</a>指南的结束。</p>
     </div>
     <hr>
     <div class="paragraph">
      <p>你想改进这份文件吗？看看GitHub上的<a href="https://github.com/BSI-Business-Systems-Integration-AG/org.eclipse.scout.docs/blob/releases/9.0.x/docs/build/eclipse_help/src/docs/tutorial_existingdemo.adoc" target="_blank">消息来源</a> 。</p>
     </div>
    </div>
   </div>
  </div>
  <table border="0" class="navigation" style="width:100%" summary="navigation">
   <tr>
    <td align="left" colspan="1" rowspan="1" style="width:30%"><a href="tutorial_helloworld.html" shape="rect" title="Hello World Tutorial"><img alt="以前" border="0" src="images/prev.gif"></a></td>
    <td align="center" colspan="1" rowspan="1" style="width:40%"><a href="scout_user_guide.html" shape="rect" title="Eclipse Scout用户指南"><img alt="Eclipse Scout用户指南" border="0" src="images/home.gif"></a></td>
    <td align="right" colspan="1" rowspan="1" style="width:30%"><a href="sdk.html" shape="rect" title="侦察工具"><img alt="下一个" border="0" src="images/next.gif"></a></td>
   </tr>
   <tr>
    <td align="left" colspan="1" rowspan="1" style="width:30%">Hello World Tutorial</td>
    <td align="center" colspan="1" rowspan="1" style="width:40%"></td>
    <td align="right" colspan="1" rowspan="1" style="width:30%">侦察工具</td>
   </tr>
  </table>
  <div id="footer">
   <div id="footer-text">版本9.0<br>最后更新时间2018-04-03 14:49:24 CEST</div>
  </div>
 </body>
</html><html id="3140.org_eclipse_ui_decorators.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>装饰</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">装饰</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.decorators<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>2.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于将装饰器添加到订阅装饰器管理器的视图。从2.1开始，有一个轻量级装饰器的概念，它将处理装饰器的图像管理。也可以声明一个轻量级的装饰器，它在启用时只需覆盖一个图标，不需要插件的实现。<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.decorator">装饰</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.decorator">装饰器</a> （ <a href="#e.description">描述</a> ？， <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST装饰</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">objectClass CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">适应性（真|假）</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">轻量级（true | false）</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">位置（TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT | UNDERLAY | REPLACE）&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 将用于标识此装饰器的唯一名称。</li>
<li><b>label</b> - 将在工作台窗口菜单中用于表示此装饰器的可翻译名称。</li>
<li><b>class</b> - 实现<samp>org.eclipse.jface.viewers的类的完全限定名称<samp>。ILabelDecorator</samp>如果<b><i>轻量级</i></b>为false或<samp>org.eclipse.jface.viewers。如果轻量级为true， 则为ILightweightLabelDecorator</samp> 。默认值为false。如果没有<b><i>类</i></b>元素，则假定它是轻量级的。在没有装饰器类的情况下，这被认为是声明性的。当使用<code>IDecoratorManager#update()</code>更改这些值时，需要显式更新具有基于会话属性，持久属性或项目描述值（如性质）的启用的声明式装饰器。</li>
<li><i style="color:red">不推荐使用的</i> <b>objectClass</b> - 将应用此装饰器的类的完全限定名称。在2.1中弃用。将此值作为启用的一部分。</li>
<li><b>adaptable</b> - 一个标志，指示可以适应除objectClass之外的对象的类型是否应使用此对象贡献。对于非轻量级装饰器，如果objectClass适应IResource，则此标志仅具有效果。对于轻量级装饰器，只要通过适配器管理器定义适应性，就支持对任何objectClass的适应性（请参阅类org.eclipse.runtime。IAdapterManager）。默认值为false。</li>
<li><b>state</b> - 一个标志，指示装饰器是否默认打开。默认值为false。</li>
<li><b>轻量级</b> - 轻量级标志表示装饰器是声明式的或实现<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。</li>
<li><b>icon</b> - 如果装饰器是<b><i>轻量级的</i></b>并且未指定<b><i>类，</i></b>则这是要应用的叠加图像的路径</li>
<li><b>location</b> - 如果装饰器是<b><i>轻量级的，</i></b>这是应用装饰器的位置。默认为BOTTOM_RIGHT。在3.4中添加了一个新的可能值REPLACE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！元素<a name="e.description">描述</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个可选的子元素，其主体应包含提供装饰器简短描述的文本。这将显示在Decorators首选项页面中，因此建议包含此选项。默认值为空String。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是装饰器的示例：<p>一个完整的装饰。插件开发人员必须处理自己的图像支持。
</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。DecoratorContributor“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>


<p>轻量级装饰。有一个具体的类，但由于它是一个ILightweightLabelDecorator，它只需要提供文本和ImageDescriptor，因此不需要资源处理。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。LightweightDecoratorContributor“</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p>一个声明性的轻量级装饰器。没有具体的类，因此它提供了一个图标和一个象限来应用该图标。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.declarative.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Declarative Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“ icons / full / declarative.gif“</span> <span class="code SchemaTag">location =</span> <span class="code SchemaCstring">”TOP_LEFT“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>class</samp>属性的值必须是实现<samp>org.eclipse.jface.viewers的类的完全限定名<samp>。ILabelDecorator</samp> （如果轻量级为false）或<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。声明性装饰器不需要任何插件激活，应尽可能使用。非轻量级装饰器最终将被弃用。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>插件可以使用此扩展点来添加要应用于使用装饰器管理器作为其标签装饰器的视图的新装饰器。要使用装饰器管理器，请使用IViewPart.getDecoratorManager（）的结果作为DecoratingLabelProvider实例的装饰器。资源导航器目前正在使用它。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2005 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="0460.changes.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
  <link rel="stylesheet" href="../book.css" type="text/css" charset="ISO-8859-1"></link>
  <title>更改日志</title>
</head>

<body dir="ltr">

<h1>EclEmma更改日志</h1>

<h2>版本3.1.2（2019/03/12）</h2>

<ul>
  <li>升级到JaCoCo 0.8.3（Eclipse Bug 543890）。</li>
</ul>

<h2>版本3.1.1（2018/09/12）</h2>

<ul>
  <li>Dark主题中调整的默认颜色（Eclipse Bug 533264）。</li>
  <li>升级到JaCoCo 0.8.2，它提供对Java 11的支持（Eclipse Bug 537807）。</li>
</ul>

<h2>版本3.1.0（2018/06/27）</h2>
<ul>
  <li>升级到JaCoCo 0.8.1，它提供对Java 10的支持并过滤掉各种编译器生成的工件，否则需要不必要的，有时甚至是不可能的技巧，以避免部分或错过覆盖，例如try-with资源语句的字节码的一部分（ Eclipse Bug 529391,532770）。</li>
  <li>为了与Eclipse Photon UI保持一致，在上下文和运行菜单中添加了“Coverage As”图标（Eclipse Bug 530668）。</li>
</ul>

<h2>版本3.0.1（2017/11/14）</h2>
<ul>
  <li>修复了“转储执行数据”对话框中的<code>NullPointerException</code>和<code>ArrayIndexOutOfBoundsException</code> （Eclipse Bug 519126,519149）。</li>
  <li>为了与“运行”菜单中的其他项保持一致，“Coverage Last Launched”和“Coverage ...”项已相应地重命名为“Coverage”和“Coverage Configurations ...”（Eclipse Bug 517712）。</li>
  <li><code>ContextualLaunchableTester</code>记录的错误消息现在包含委托快捷方式ID（Eclipse Bug 526701）。</li>
</ul>

<h2>版本3.0.0（2017/06/28）</h2>
<p>这是Eclipse Foundation旗下的第一个版本。EclEmma现在是一个官方的Eclipse.org项目，包含在几个Eclipse Oxygen（4.7）软件包中。
</p>
<ul>
  <li>HiDPI图标（Eclipse Bug 507724）。</li>
  <li>从<i>Coverage</i>视图导入/导出会话上下文菜单现在直接打开相应的向导。自Eclipse 4.3（Eclipse Bug 507907）以来，情况就不再如此。</li>
  <li>会话导入和导出现在一致地命名，并已移至类别<i>运行/调试</i> （Eclipse Bug 507696）。</li>
  <li>使用SWTBot进行自动UI测试。</li>
  <li>对早于3.8的Eclipse版本的支持结束。</li>
  <li>升级到JaCoCo 0.7.9。</li>
  <li>升级到ASM 5.2。</li>
</ul>

<h2>版本2.3.3（2016/02/23）</h2>
<ul>
  <li>升级到JaCoCo 0.7.6。</li>
  <li>升级到ASM 5.0.4。</li>
  <li>使用异常堆栈跟踪记录错误（GitHub＃106）。</li>
</ul>

<h2>版本2.3.2（2014/09/14）</h2>
<ul>
  <li>修改了带注释的源文件编辑时的内部错误（GitHub＃90）。</li>
  <li>升级到JaCoCo 0.7.2以获得Java 8 lambda表达式支持。</li>
</ul>

<h2>版本2.3.1（2014/05/11）</h2>
<ul>
  <li>修复了Eclipse 4.4（GitHub＃83）中与ASM新捆绑包的ASM 5.0.1依赖冲突。</li>
  <li>升级到JaCoCo 0.7.1以获得完整的Java 8支持。</li>
</ul>

<h2>版本2.3.0（2014/03/19）</h2>
<ul>
  <li>现在支持Java 8。</li>
  <li>升级到JaCoCo 0.7.0。</li>
</ul>

<h2>版本2.2.1（2013/06/09）</h2>
<ul>
  <li>用于启动TestNG测试和套件的键盘快捷键（GitHub＃1）。</li>
  <li>新会话导入选项，用于从JaCoCo代理（GitHub＃2）导入执行数据。</li>
  <li>新的会话导入选项，用于从URL导入执行数据（GitHub＃13）。</li>
  <li>不要在Scala函数元素上失败（GitHub＃32）。</li>
  <li>如果丢失输出文件夹（GitHub＃38），请不要失败。</li>
  <li>升级到JaCoCo 0.6.3。</li>
</ul>

<h2>版本2.2.0（2012/10/26）</h2>
<ul>
  <li>EclEmma项目已移至<a href="https://github.com/jacoco/eclemma">GitHub</a> 。</li>
  <li>升级到JaCoCo 0.6.0。</li>
  <li>在<i>Coverage</i>视图中更正菜单标签。</li>
  <li>SF＃1968604： <i>Coverage</i>视图显示图形条形图而不是图标，以显示代码覆盖率。</li>
</ul>

<h2>版本2.1.4（2012/08/01）</h2>
<ul>
  <li>升级到JaCoCo 0.5.9。</li>
  <li>SF＃3549343：更正HTML报告的源文件夹命名。</li>
</ul>

<h2>版本2.1.3（2012/07/12）</h2>
<ul>
  <li>升级到JaCoCo 0.5.8。</li>
  <li>Eclipse Bugzilla＃383367：修复Eclipse 4.2的coverage视图中的下拉菜单。</li>
  <li>Trac＃158：使用M2E时JaCoCo Maven目标的生命周期映射。</li>
  <li>Trac＃203：EclEmma功能现在依赖于Eclipse 3.5或更高版本，以确保在安装时进行版本检查。</li>
</ul>

<h2>版本2.1.2（2012/05/09）</h2>
<ul>
  <li>自Eclipse <a href="http://bugs.eclipse.org/227877">问题227877</a>以来对Eclipse 3.8（Juno）的支持已得到解决。</li>
  <li>SF＃3522048：升级到JaCoCo 0.5.7。</li>
  <li>SF＃3510762：支持Scala应用程序启动。供稿人：Joachim Hofer。</li>
  <li>固定的默认设置（启用）用于自动打开<i>Coverage</i>视图。</li>
</ul>

<h2>版本2.1.1（2012/04/09）</h2>
<ul>
  <li>Trac＃195：不要根据名称排除输出文件夹。这导致某些设置中的空覆盖数据结果。非常感谢Dominik Stadler分析这个bug。</li>
  <li>避免在<i>Coverage</i>视图中将列宽恢复为零。</li>
</ul>

<h2>版本2.1.0（2012/02/26）</h2>
<ul>
  <li>对于长时间运行的进程，现在可以收集中间覆盖数据转储，而无需终止正在测试的应用程序。此功能允许所谓的<i>差分代码覆盖</i> ，这是Kaitlin Duck Sherwood在她的论文“ <i><a class="extern" href="http://www.cs.ubc.ca/cgi-bin/tr/2008/TR-2008-14">减少代码导航努力与差分代码覆盖率”中</a></i>提出的一种技术。</li>
  <li>Trac＃168：JaCoCo执行数据文件的新编辑器。</li>
  <li>Trac＃190： <i>Coverage</i>视图选项<i>Hide Unused Types</i>已被推广为<i>Hide Unused Elements</i> 。</li>
  <li>SF＃3489951：不处理团队提供程序文件夹中的类文件。</li>
  <li>SF＃3487904：在新的和空的启动配置中避免使用NPE。</li>
  <li>SF＃3477725：不得多次将Java代理添加到插件启动配置中。</li>
</ul>

<h2>版本2.0.1（2011/12/28）</h2>
<ul>
  <li>包含<code>org.objectweb.asm</code>包与EclEmma功能包，因为此包在所有Eclipse发行版中都不可用。</li>
</ul>

<h2>版本2.0.0（2011/12/18）</h2>
<p>EclEmma的第一个版本由JaCoCo而不是EMMA支持。这为EclEmma增加了一些增强功能和新功能。
</p>
<ul>
  <li>分支覆盖范围：分支覆盖范围显示在属性页面上，可以在<i>Coverage</i>视图中选择。对于源编辑器，有一个新注释标记带分支的行。新的工具提示以每行为基础提供有关分支的详细信息。</li>
  <li>没有类文件检测：使用JaCoCo Java类仅在内存中检测，这意味着修改后的类文件将不再写入文件系统。因此，不再需要“就地检测”模式及其缺点（不需要重新构建，可以分析JAR文件）。由于所有类文件的检测，程序现在立即启动而没有延迟。</li>
  <li>即使源类文件的输出位置相同，也可以单独选择源文件夹。</li>
</ul>

<h2>版本1.5.3（2011/05/05）</h2>
<ul>
  <li>SF＃3297297：修复了没有行号属性编译的类文件的NullPointerException。</li>
  <li>SF＃3297292：修复了EclEmma插件类文件版本。</li>
</ul>

<h2>版本1.5.2（2011/04/15）</h2>
<ul>
  <li>SF＃3055347：状态为<code>NO_COVERAGE_DATA_ERROR</code>错误消息错误。</li>
  <li>SF＃2881882：修复了丢失块NLS密钥的拼写错误。</li>
</ul>

<h2>版本1.5.1（2010/08/18）</h2>
<ul>
  <li>为确保完整性并避免安装警告，分布式EclEmma插件现已由Mountainminds GmbH＆Co。KG签署。</li>
  <li>与Groovy-Eclipse插件结合使用Groovy代码的源代码突出显示。</li>
  <li>SF＃2934564：只需打开启动对话框中的“Coverage”选项卡，就不会再修改启动配置。现在仅在实际修改对话框时才会显示保存警告。</li>
  <li>SF＃3037143：从修补的emma.jar清单中删除无效的标头。</li>
</ul>

<h2>版本1.5.0（2010/06/24）</h2>
<ul>
  <li>SF＃2881882：覆盖范围视图和覆盖范围属性页面现在有一个新列，显示未覆盖的项目数。</li>
</ul>

<h2>版本1.4.3（2009/10/18）</h2>
<ul>
  <li>SF＃2855643：修复了由于SWTBot启动快捷方式的ID错误导致的处理程序冲突。</li>
</ul>

<h2>版本1.4.2（2009/08/19）</h2>
<ul>
  <li>SF＃2800744：支持SWTBot测试启动器。</li>
  <li>SF＃2807365：Mac上的“Coverage Last Launched”快捷方式现在是CTRL + SHIFT + F11，不再与“Run Last Launched”的快捷方式冲突。</li>
</ul>

<h2>版本1.4.1（2009/03/05）</h2>
<ul>
  <li>SF＃2664838：修复了分析包含嵌套参数化签名的Java源文件的异常。</li>
</ul>

<h2>版本1.4.0（2009/03/03）</h2>
<ul>
  <li>SF＃1823843：在签名中正确识别带有类型变量和参数化类型的方法。</li>
  <li>SF＃2495620：覆盖范围视图可以从“显示在”菜单中打开，由匿名提供。</li>
  <li>SF＃2226932，＃2080402：几个首选项，用于指定默认情况下将检测的类路径条目。</li>
  <li>SF＃2570132：支持RAP JUnit启动器，由Holger Staudacher提供。</li>
  <li>可以将Coverage视图的选定内容复制到剪贴板。</li>
</ul>

<h2>版本1.3.2（2008/07/15）</h2>
<ul>
  <li>Coverage视图中使用的本机排序指示器（仅限Eclipse 3.2及更高版本）。</li>
  <li>SF＃1966443：主要“运行”菜单的固定加速器，由Alexey Stratonnikov提供。</li>
  <li>SF＃1966764：导入不包含元数据的外部会话文件时出现正确的错误消息。</li>
  <li>SF＃1995077：覆盖会话导入对话框中的“全选”和“取消全选”按钮，以便更好地支持大型项目集。</li>
</ul>

<h2>版本1.3.1（2008/03/05）</h2>
<ul>
  <li>SF＃1899238：会话导入对话框中的新选项允许使用外部元数据。</li>
  <li>SF＃1824465：报告编码现在是UTF-8以支持扩展字符集。</li>
  <li>SF＃1836551：忽略不再在项目类路径上的会话中的类路径条目。</li>
  <li>SF＃1822092：在Coverage和Import对话框中更好地标记和排序类路径条目。</li>
</ul>

<h2>版本1.3.0（2007/09/11）</h2>
<ul>
  <li>Java代码覆盖率的首选项页面。</li>
  <li>所有EclEmma视图和对话框中的上下文相关帮助。</li>
  <li>覆盖范围视图中的新操作“全部折叠”。</li>
  <li>输入对象选择已移至coverage视图的下拉菜单中。</li>
  <li>SF＃1774547：在覆盖范围视图中添加了“当前选择链接”选项，由Brock Janiczak提供。</li>
  <li>SF＃1762836：其他插件可能会为自定义启动类型添加覆盖支持。现在公开了必需的EclEmma API。供稿人：John Ruud。</li>
  <li>SF＃1764140：在上下文菜单中添加了“Coverage As”，由Brock Janiczak提供。</li>
  <li>SF＃1774550：在覆盖视图中观察JFace打开模式，由Brock Janiczak提供。</li>
</ul>

<h2>版本1.2.2（2007/07/03）</h2>
<ul>
  <li>SF＃1701683：修复了Eclipse 3.3版本的抽象方法错误。</li>
</ul>

<h2>版本1.2.1（2007/06/25）</h2>
<ul>
  <li>SF＃1701683：修复了Eclipse 3.3的抽象方法错误。</li>
  <li>SF＃1725100：正确处理没有文档提供程序的文本编辑器。</li>
</ul>

<h2>版本1.2.0（2007/04/12）</h2>
<ul>
  <li>SF＃1618360：EclEmma现在附带了修补版的EMMA，以避免某些Eclipse / JDK环境中的启动失败。</li>
  <li>SF＃1690088：支持Equinox OSGi框架发布。</li>
  <li>覆盖范围属性页现在过滤掉总计为零的计数器。</li>
  <li>文档更新：可用的启动模式，coverage属性页，coverage装饰器。</li>
</ul>

<h2>版本1.1.0（2007/02/25）</h2>
<ul>
  <li>SF＃1664476：Geoffrey Wiseman提议的覆盖视图中未使用类型的过滤选项。</li>
  <li>SF＃1659429：Java元素的可选覆盖装饰器，由Benjamin Muskalla提供。</li>
  <li>SF＃1657454：默认密钥绑定，由heaththegreat提供。</li>
  <li>所有Java元素的新属性页“Coverage”。</li>
  <li>将“属性”操作添加到coverage视图的上下文菜单中。</li>
</ul>

<h2>版本1.0.0（2007/01/15）</h2>
<p>由于EclEmma现已推出超过三个月，已下载超过3,000次，我已尝试修复许多报告的问题，这是第一个1.0版本的时间！
</p>
<ul>
  <li>添加了EclEmma功能。</li>
  <li>创建了Eclipse更新站点http://update.eclemma.org/。</li>
  <li>SF＃1633361：修复了Eclipse 3.3M4的启动快捷方式。</li>
  <li>SF＃1619413：正确处理VM参数中的空格。</li>
</ul>

<h2>版本0.1.8（2006/12/18）</h2>
<ul>
  <li>改进的覆盖率分析运行得更快。</li>
  <li>SF＃1613378：修复了Mac OS X上的JUnit插件测试。</li>
  <li>SF＃1601699：修复了在缺少* .em文件的情况下导出的会话导出。</li>
</ul>

<h2>版本0.1.7（2006/11/19）</h2>
<ul>
  <li>coverage视图现在还具有方法和类覆盖的计数器。</li>
  <li>为了与其他计数器保持一致，重新定义了线路覆盖范围如果一行包含至少一个覆盖的基本块，则该行现在被视为已覆盖。</li>
  <li>SF＃1595879：现在为所有coverage启动提供了命令，可以在首选项对话框中将其分配给键盘快捷键。</li>
</ul>

<h2>版本0.1.6（2006/10/31）</h2>
<ul>
  <li>SF＃1584899：修复了对Eclipse应用程序启动的支持</li>
  <li>SF＃1584496：外部终止的进程不收集覆盖信息。这个事实已经记录在案，并在相应的错误对话框中提到。</li>
  <li>SF＃1583900：当没有为检测指定类时，coverage启动对话框中会显示一条错误消息。</li>
</ul>

<h2>版本0.1.5（2006/10/18）</h2>
<ul>
  <li>文档：删除了开发人员文档（现在可在www.eclemma.org上获得）。</li>
  <li>文档：添加了支持部分。</li>
  <li>文档：现在使用Apache Jakarta公共代码显示所有示例。</li>
  <li>SF＃1574659：报告导出向导显示其他错误和警告，以确保正确输入目标。</li>
  <li>SF＃1576462：在覆盖启动期间未写入覆盖数据文件时显示错误。</li>
  <li>SF＃1574682：修复了Eclipse 3.2.x的JUnit插件启动。</li>
</ul>

<h2>版本0.1.4（2006/09/30）</h2>
<p>这是源树移动到SourceForge后的第一个版本。现在可以在SVN存储库<code>https://svn.sourceforge.net/svnroot/eclemma</code>找到完整的源代码。插件本身不再包含源代码。
</p>
<ul>
  <li>SF＃1568370：在Web工具平台的“J2EE”透视图中添加了“Coverage”操作集。</li>
  <li>启动对话框：为要修改的类添加了“全选”和“取消全选”按钮。</li>
  <li>SF＃1565364：在分析仅部分没有行信息的元数据时修复了NPE。</li>
</ul>

<h2>版本0.1.3（2006/09/18）</h2>
<ul>
  <li>在线文档：更新和新章节。</li>
  <li>会话导入：为外部启动的EMMA覆盖文件添加了导入向导。</li>
  <li>会话导出：添加导出向导，以EMMA支持的格式导出会话数据（* .html，*。xml，* .txt，* .es）。</li>
  <li>覆盖范围视图：添加了上下文菜单。</li>
  <li>覆盖范围视图：在上下文菜单中添加“刷新”操作（F5）。用于重新加载导入的外部启动的覆盖数据。</li>
  <li>覆盖范围视图：新操作“合并会话”。</li>
  <li>添加了键盘支持：可以在键首选项中配置<i>Coverage</i>视图中的“Delete”，“Open Declaration”和“Refresh”，“Coverage Last Launched”和“Coverage ...”。</li>
  <li>修复了参数化类型（Java 1.5）的内部错误。</li>
  <li>为TestNG测试运行添加了实验支持。</li>
</ul>

<h2>版本0.1.2（2006/08/29）</h2>
<p>预览版本，包括在线文档和一些内部清理。
</p>
<ul>
  <li>在线帮助页面初稿。</li>
  <li>完成NLS支持。</li>
  <li>coverage启动对话框中类路径条目的新标签。</li>
  <li>尝试检测已检测的类时，启动失败并显示有意义的错误消息。</li>
</ul>

<h2>版本0.1.1（2006/08/25）</h2>
<p>预览版本具有其他功能，例如支持PDE启动和选择检测类。清理和澄清内部结构。
</p>

<h2>版本0.1.0（2006/08/09）</h2>
<p>一些朋友和同事最初的测试用于测试目的。它是在Eclipse 3.1.1下开发的，一些成功的测试发生在Eclipse 3.2.0中。
</p>

</body>
</html><html id="3852.307_special_languages.html" dir="ltr"></html><html dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
	<title>典型语言配置</title>
	<link href="book.css" rel="stylesheet" type="text/css"></link>
	<link href="code.css" rel="stylesheet" type="text/css"></link>
	<link rel="home" href="index.html" title=""></link>
</head>
<body dir="ltr">

<h1 id="special-languages">典型语言配置</h1>

<h2 id="case-insensitive-languages">案例不敏感语言</h2>

<p>在某些情况下，例如，如果您的<em>SHIFT</em>键被破坏，您可能需要设计不区分大小写的语言。为此，Xtext为其某些<a href="302_configuration.html#generator-fragment">生成器片段</a>提供了选项。</p>

<p>对于不区分大小写的关键字，请打开MWE工作流并启用ignoreCase属性：</p>

<pre><code class="language-mwe2">...StandardLanguage {... other config parserGenerator = {options = {ignoreCase = true}}}对于不区分大小写的元素名称，也要在作用域中使用* ignoreCase *选项：```mwe2 scopeProvider = {ignoreCase = true}</code></pre>

<h2 id="whitespace-aware-languages">空白感知语言</h2>

<p>一些语言设计者喜欢使用缩进来构造代码块，而不是用大括号<code>{ ... }</code>来包围它们，这些键盘很难用某些类型的键盘输入。这种语言的一个众所周知的例子是<a href="https://www.python.org">Python</a> 。另一个众所周知的例子是随Xtext一起提供的<em>家庭自动化</em>语言（自2.8版本起），可通过<em>文件→新建→示例→Xtext示例→Xtext家庭自动化示例获得</em> 。</p>

<pre><code class="language-ruleengine">设备窗口可以打开，关闭设备加热器可以打开，关闭，错误规则'节省能源'当Window.open然后开火（Heater.off）println（'另一个便士到存钱罐！“）</code></pre>

<p><code>'Save energy'</code>规则包含一个包含两个操作的代码块，这些操作由这些操作的等压缩表示。嵌套块也是可能的：</p>

<pre><code class="language-ruleengine">当Heater.error然后var String报告执行时，规则'报告错误'执行Thread.sleep（500）report = HeaterDiagnostic.readError while（report == null）println（report）</code></pre>

<p>在您的语言中包含空白感知块的第一步是通过编写<code>'synthetic:&lt;terminal name&gt;'</code>形式<code>'synthetic:&lt;terminal name&gt;'</code>终端在语法中使用<em>合成令牌</em> ：</p>

<pre><code class="language-xtext">终端开始：'合成：开始';终端END：'合成：END';</code></pre>

<p>这些终端可用于标记代码块的边界。Home Automation示例从<a href="305_xbase.html">Xbase</a>继承表达式并重新定义块表达式的语法：</p>

<pre><code class="language-xtext">XBlockExpression返回xbase :: XExpression：{xbase :: XBlockExpression} BEGIN（表达式+ = XExpressionOrVarDeclaration';'？）* 结束;</code></pre>

<p>在运行工作流之后，在子包<code>parser.antlr</code>生成<code>AbstractIndentationTokenSource</code>的存根实现，例如<code>RuleEngineTokenSource</code> 。您可以在此处指定应将哪个终端规则应用于合成令牌。对于家庭自动化语言，选择了<code>WS</code> （空白）规则，这带来了如上所示的缩进感知。</p>

<p>在使用空白感知语言的情况下， <a href="303_runtime_concepts.html#formatting">格式化程序</a>必须适合生成正确反映文档结构的空白，或者必须取消激活。否则，自动格式化可能会产生具有不同语义甚至语法错误的代码。了解我们如何在homeautomation示例中自定义格式化程序。</p>

<h2 id="java-independent-languages">语言独立于JDT</h2>

<p>以下部分描述了如何使您的语言独立于Eclipse的Java Development Toolkit（JDT）。</p>

<p>在您的语言的<em>UIModule中</em> ，您必须覆盖两个绑定。首先，删除对组件的绑定，并支持<em>'classpath：'</em> URI协议，即</p>

<pre><code class="language-java">@Override public Class &lt;？extends IResourceForEditorInputFactory&gt; bindIResourceForEditorInputFactory（）{return ResourceForIEditorInputFactory.class; } @Override public Class &lt;？extends IResourceSetProvider&gt; bindIResourceSetProvider（）{return SimpleResourceSetProvider.class; }</code></pre>

<p>其次，配置全局范围提供程序以扫描项目根文件夹而不是Java项目的类路径。</p>

<pre><code class="language-java">@Override public Provider &lt;IAllContainersState&gt; provideIAllContainersState（）{return org.eclipse.xtext.ui.shared。Access.getWorkspaceProjectsState（）; }</code></pre>

<p>其余步骤将向您展示如何为您的语言调整项目向导，如果您已生成一个。执行此操作的最佳方法是在<em>ui</em>项目的<em>src /</em>文件夹中创建生成的<em>IProjectCreator</em>的新子类，并在那里应用必要的更改。首先，通过使用空主体覆盖<em>configureProject来</em>删除JDT项目配置。</p>

<p>接下来要重新定义应该应用于语言项目的项目性质和构建器。</p>

<p>在这种情况下，只需以这种方式删除JDT：</p>

<pre><code class="language-java">protected String [] getProjectNatures（）{return new String [] {“org.eclipse.pde。PluginNature“，”org.eclipse.xtext.ui.shared.xtextNature“};} protected String [] getBuilders（）{return new String [] {”org.eclipse.pde。ManifestBuilder“，”org.eclipse.pde。SchemaBuilder“};}</code></pre>

<p>之后，您必须绑定新的<em>IProjectCreator</em></p>

<pre><code class="language-java">@Override public Class &lt;？扩展IProjectCreator&gt; bindIProjectCreator（）{return JDTFreeMyDslProjectCreator.class; }</code></pre>

<p>现在，您的语言及其IDE现在不再依赖于JDT。</p>

<h2 id="expressions">使用Xtext解析表达式</h2>

<p>使用Xtext解析简单的类似XML的结构语言是不费脑子的。但是，解析嵌套表达式通常被认为是复杂的。这是由于它们的递归性质以及Xtext使用的解析器技术的属性而产生的感知。您必须避免使用左递归解析器规则。由于底层的Antlr解析器使用自上而下的方法，如果你有一个左递归语法，它将无休止地递归。</p>

<p>我们来看一下解析一个简单的算术表达式：</p>

<p><code>2 + 20 * 2</code></p>

<p>如果您稍微了解EBNF并且不考虑避免左递归，运算符优先级或关联性，那么您可能会编写如下语法：</p>

<pre><code class="language-xtext">表达式：表达式'+'表达式|表达式'*'表达式| INT;</code></pre>

<p>这个语法将是递归的，因为解析器从上到下从左到右读取语法，并且无限地调用表达式规则而不消耗任何字符，即改变解析器的基础状态。虽然这种语法可以为自下而上的解析器编写，但您仍然需要处理运算符优先级。这就是定义乘法具有比例如加法更高的优先级。</p>

<p>在Xtext中，您可以在对这样的语法进行左因式分解时隐式定义优先级。左因子意味着你通过应用某个习语来摆脱左递归，这将在下面描述。</p>

<p>这是上面的表达式语言的左因式语法（尚未使用Xtext）：</p>

<pre><code class="language-xtext">增加：乘法（'+'乘法）*;乘法：NumberLiteral（'*'NumberLiteral）*; NumberLiteral：INT;</code></pre>

<p>正如您所看到的，主要区别在于它使用了三个规则而不是一个规则，如果您仔细观察一下，您会发现存在某种委托模式。规则Addition不会调用自身，而是调用Multiplication。运算符优先级由委托顺序定义。规则越晚称为更高的优先级。这至少是前两个具有左递归性质的规则的情况（但我们现在已经将它们考虑在内）。最后一条规则不是递归的，这就是为什么你可以在不应用这种模式的情况下实现它。</p>

<p>下一个任务是允许用户通过添加括号来显式调整优先级，例如写入类似<code>(2 + 20) * 2</code> 。所以让我们添加对它的支持（注意语法仍然不能使用Xtext）：</p>

<pre><code class="language-xtext">增加：乘法（'+'乘法）*;乘法：主要（'*'主要）*;主要：NumberLiteral | '（'加法'）'; NumberLiteral：INT;</code></pre>

<p>再一次：如果您有一些在左侧进行递归的构造，则需要根据运算符优先级将其放入委托链中。模式始终是相同的：将委托递归到具有下一个更高优先级的规则的事物。</p>

<h3 id="construction-of-an-ast">构建AST</h3>

<p>现在避免了左递归，解析器应该生成一个合适的语法树。在Xtext中，每个规则都返回一个值。生产规则返回AST节点（即EObject的实例），枚举规则返回枚举文字和数据类型规则以及终端规则返回简单值，如字符串。Xtext可以自动推断某些规则是否是生产规则，即构造并返回AST节点，或者它是否是返回值的数据类型规则。上面的语法只包含数据类型规则，所有这些规则都返回纯字符串。为了构造AST，我们需要为语法添加赋值和动作。</p>

<p>可以使用<code>returns</code>关键字显式指定规则的返回类型，但如果类型的名称与规则的名称相同，则可以推断出规则的返回类型。那是</p>

<pre><code class="language-xtext">NumberLiteral：...;</code></pre>

<p>是一种简短的形式</p>

<pre><code class="language-xtext">NumberLiteral返回NumberLiteral：...;</code></pre>

<p>但是在上面的表达式语法的情况下，所有规则都需要返回相同的类型，因为它们是递归的。为了使语法有效，必须显式添加一个公共返回类型（但语法仍然缺少一些位）：</p>

<pre><code class="language-xtext">加法返回表达式：乘法（'+'乘法）*;乘法返回表达式：Primary（'*'Primary）*;主要返回表达式：NumberLiteral | '（'加法'）'; NumberLiteral：INT;</code></pre>

<p>Xtext的AST类型推断机制将推断出两种类型：Expression和NumberLiteral。必须添加赋值和操作以存储AST中的所有重要信息，并为加法和乘法表达式创建合理的子类型。完全工作的Xtext语法是这样的：</p>

<pre><code class="language-xtext">加法返回表达式：乘法（{Addition.left = current}'+'right =乘法）*;乘法返回表达式：Primary（{Multiplication.left = current}'*'right = Primary）*;主要返回表达式：NumberLiteral | '（'加法'）'; NumberLiteral：value = INT;</code></pre>

<p>这是解析器处理以下表达式的方式：</p>

<pre><code class="language-java">（1 + 20）* 2</code></pre>

<p>它始终以第一条规则（加法）开头。其中第一个元素是对Multiplication的未分配规则调用，而Multiplication又调用Primary。小学现在有两种选择。第一个是调用NumberLiteral，它只包含一个名为'value'的特性的赋值。'value'的类型必须与INT规则的返回类型兼容。</p>

<p>但是，因为示例表达式中的第一个标记是左括号'（'解析器将采用主要的第二个替代：它消耗'（'并调用规则加法。现在值'1'是先行标记，并且再次添加调用乘法和乘法调用Primary。这次解析器采用第一种方法，因为INT规则消耗了“1”。</p>

<p>一旦解析器命中一个赋值，它就会检查是否已经创建了当前规则的AST节点。否则，它将根据当前规则的返回类型创建一个，即NumberLiteral。Xtext生成器创建了EClass'RumberLiteral'，之前可以实例化它。该类型还将具有一个名为int的类型的属性，它将获得值“1”的设置。这就是Java等价物的样子：</p>

<pre><code class="language-java">// value = INT if（current == null）current = new NumberLiteral（）; current.setValue（ruleINT（））; ...
</code></pre>

<p>既然规则已经完成，生成的EObject将返回到调用规则Primary，后者又将对象返回到其自己的调用者。在Multiplication中，已成功解析规则Primary并返回NumberLiteral的实例。规则的其余部分（括号内的所有内容）都是所谓的组。右括号后面的星号表示该部分可以消耗零次或多次。在该组中使用的第一个标记是乘法运算符'*'。不幸的是，在当前输入中，接受的下一个标记是加号'+'，因此该组根本不被使用，并且该规则返回从先前未分配的规则调用返回的NumberLiteral。</p>

<p>在规则Addition中有一个类似的组，但这次它需要正确的运算符。解析器进入组。组中的第一个元素是已分配的操作。它将创建一个Addition类型的新实例，并将要返回的对象分配给特征“left”。在Java中，这可能是这样的：</p>

<pre><code class="language-java">//乘法规则调用current = ruleMultiplication（）; // {Addition.left = current}加法temp = new Addition（）; temp.setLeft（电流）; current = temp; ...
</code></pre>

<p>因此，该规则现在将返回一个Addition实例，该实例的NumberLiteral设置为其属性左侧。接下来，解析器使用'+'运算符。操作符本身不存储在AST中，因为存在显式的Addition类型。它隐含地包含这些信息。赋值<code>right=Multiplication</code>再次调用规则乘法，并将其结果对象（值为20的NumberLite）分配给属性<code>right</code> 。之后匹配右括号，消耗并再次减少解析器堆栈。</p>

<p>解析器现在处于规则乘法中，并且在前瞻中具有乘法运算符'*'。它进入组并应用操作。最后，它调用Primary规则，生成NumberLiteral的另一个实例（value = 2），将其指定为Multiplication的'right'操作数，并将乘法返回到规则Addition，后者又返回相同的对象，因为没有任何内容留给解析。</p>

<p>生成的AST如下所示：</p>

<p><img src="images/expression-ast.png" alt=""></p>

<p>可视化和解释细节。</p>

<h3 id="associativity">关联性</h3>

<p>还有一个值得一提的话题，即关联性。存在左右相关性以及非相关性。该示例实现了左关联性。当有两个具有相同优先级的中缀操作时，关联性告诉解析器如何构造AST。以下示例取自相应的维基百科条目：</p>

<p>考虑表达式a~b~c。如果运算符〜具有左关联性，则该表达式将被解释为（a~b）~c并从左到右进行求值。如果运算符具有正确的关联性，则表达式将被解释为〜（b~c）并从右向左进行计算。如果运算符是非关联的，则表达式可能是语法错误，或者它可能具有某些特殊含义。最常见的变体是左关联性：</p>

<pre><code class="language-xtext">加法返回表达式：乘法（{Addition.left = current}'+'right =乘法）*;</code></pre>

<p>使用略微修改的模式完成右关联性。请注意数量运算符以及对组中规则本身的调用：</p>

<pre><code class="language-xtext">加法返回表达式：乘法（{Addition.left = current}'+'right = Addition）？;</code></pre>

<p>非关联性可以以类似的方式实现，但这次最终规则调用不是立即递归的，而是委托给下一个优先级：</p>

<pre><code class="language-xtext">加法返回表达式：乘法（{Addition.left = current}'+'right =乘法）？;</code></pre>

<p>有时在解析器级别允许关联性更方便，但稍后禁止使用验证。这允许更具描述性的诊断。此外，整个解析过程不依赖于错误恢复，但编辑器通常会更宽容。</p>

<hr>

<p><strong><a href="308_emf_integration.html">下一章：与EMF和其他EMF编辑器集成</a></strong></p>


</body>
</html><html id="3135.org_eclipse_ui_bindings.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>绑定</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">绑定</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.bindings<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p><code>org.eclipse.ui.bindings</code>扩展点用于声明绑定和方案。方案是一个或多个绑定的集合。绑定是某组条件，某些用户输入和触发命令之间的映射。
</p>
<p>所有绑定都需要某种触发器，它们处于活动状态的上下文以及它们存在的方案。如果您不确定选择哪种上下文，请将其留空。它将默认为<code>"org.eclipse.ui.contexts.window"</code>上下文。此上下文意味着绑定将应用于任何Eclipse主窗口。当上下文变为活动状态时，绑定也将变为活动状态。来自子上下文的绑定将覆盖父上下文的绑定。有关上下文的更多信息，请参阅<code>org.eclipse.ui.contexts</code>扩展点。
</p>
<p>如果绑定未定义命令标识符，则它是删除标记。这意味着如果满足所有条件，它将取消在相同上下文中具有相同触发器的任何绑定。例如，该机制可用于改变特定平台上的绑定。
</p>
<p>一种类型的绑定是<code>key</code>绑定（即键盘快捷键）。例如，将<code>Ctrl+C</code>绑定到<code>Copy</code>被视为<code>key</code>绑定。键绑定的触发器是一系列键击。
</p>
<p>方案是一组这些绑定到最终用户可以选择的集合中。例如，用户可能希望使用默认方案，但他们可能还需要Emacs样式方案或简约方案。
</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.scheme">scheme</a> *， <a href="#e.key">key</a> *， <a href="#e.sequenceModifier">sequenceModifier</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.scheme">scheme</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计划</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">parentId IDREF #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>方案是最终用户可以选择使用的一组绑定。
</p>
<p>方案可以从父方案继承绑定。这旨在使插件开发人员更容易创建自定义绑定集。子方案中定义的活动绑定将始终覆盖父方案中的活动绑定（如果它们具有相同的触发器）。该技术用于在工作台中提供Emacs方案。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此方案的唯一标识符。</li>
<li><b>name</b> - 此方案的名称，因为它应显示给最终用户。该值应该被翻译。</li>
<li><b>description</b> - 此方案的描述，因为它将显示给最终用户。该值应该被翻译。</li>
<li><b>parentId</b> - 此方案的父级的标识符。如果没有父级，则不要指定此属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.key">键</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST键</p>
<p class="code SchemaDtdAttlist">序列CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">schemeId IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">contextId IDREF“org.eclipse.ui.contexts.window”</p>
<p class="code SchemaDtdAttlist">commandId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">平台CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">locale CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>某些键盘输入和命令触发之间的绑定。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>序列</b> -<p>此绑定的关键序列。该键序列应包含一个或多个键击。击键用空格分隔。击键由一个或多个同时按下的键组成。这应该是零个或多个修饰键，以及另一个键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。由于<code>M2+M3+&lt;Letter&gt;</code> （ <code>Alt+Shift+&lt;Letter&gt;</code> ）在MacOS X上保留用于写入特殊字符，因此对于<code>platform="carbon"</code> ，此类绑定通常未定义，并重新定义为<code>M1+M3+&lt;Letter&gt;</code> 。
</p>
<p>实际的键通常简单地指定为ASCII字符，大写。因此，例如<code>F</code>或<code>,</code>是这种键的示例。但是，有一些特殊的钥匙;没有可打印ASCII表示的键。以下是当前特殊键的列表： <code>ARROW_DOWN</code> ， <code>ARROW_LEFT</code> ， <code>ARROW_RIGHT</code> ， <code>ARROW_UP</code> ， <code>BREAK</code> ， <code>BS</code> ， <code>CAPS_LOCK</code> ， <code>CR</code> ， <code>DEL</code> ， <code>END</code> ， <code>ESC</code> ， <code>F1</code> ， <code>F2</code> ， <code>F3</code> ， <code>F4</code> ， <code>F5</code> ， <code>F6</code> ， <code>F7</code> ， <code>F8</code> ， <code>F9</code> ， <code>F10</code> ， <code>F11</code> ， <code>F12</code> ， <code>F13</code> ， <code>F14</code> ， <code>F15</code> ， <code>FF</code> ， <code>HOME</code> ， <code>INSERT</code> ， <code>LF</code> ， <code>NUL</code> ， <code>NUM_LOCK</code> ， <code>NUMPAD_0</code> ， <code>NUMPAD_1</code> ， <code>NUMPAD_2</code> ， <code>NUMPAD_3</code> ， <code>NUMPAD_4</code> ， <code>NUMPAD_5</code> ， <code>NUMPAD_6</code> ， <code>NUMPAD_7</code> ， <code>NUMPAD_8</code> ， <code>NUMPAD_9</code> ， <code>NUMPAD_ADD</code> ， <code>NUMPAD_DECIMAL</code> ， <code>NUMPAD_DIVIDE</code> ， <code>NUMPAD_ENTER</code> ， <code>NUMPAD_EQUAL</code> ， <code>NUMPAD_MULTIPLY</code> ， <code>NUMPAD_SUBTRACT</code> ， <code>PAGE_UP</code> ， <code>PAGE_DOWN</code> ， <code>PAUSE</code> ， <code>PRINT_SCREEN</code> ， <code>SCROLL_LOCK</code> ， <code>SPACE</code> ， <code>TAB</code>和<code>VT</code> 。</p>
<p>我们还了解一些常见特殊键的替代名称。例如，我们接受<code>ESC</code>和<code>ESCAPE</code> ， <code>CR</code> ， <code>ENTER</code>和<code>RETURN</code>都是相同的。
</p>
<p>强烈建议您保持密钥序列的简短。一两个是你应该需要的最多。使用上下文为应用程序的不同部分提供不同含义的键序列。最多，您不应使用包含四个以上击键的任何键序列。
</p></li>
<li><b>schemeId</b> - 此键绑定处于活动状态的方案的标识符。</li>
<li><b>contextId</b> - 此键绑定处于活动状态的上下文的标识符。请参阅<code>org.eclipse.ui.contexts</code>扩展点。如果未指定，则默认为<code>org.eclipse.ui.contexts.window</code> 。</li>
<li><b>commandId</b> -<p>触发此绑定时应执行的命令的标识符。
</p>
<p>如果未指定命令标识符，则这是删除标记。这意味着当此绑定变为活动状态时，具有相同序列，平台和区域设置的相同上下文中的任何绑定都将变为非活动状态。如果未指定删除的平台或区域设置，则它将匹配任何平台或区域设置。
</p></li>
<li><b>platform</b> - 此绑定适用的平台。应该以与<code>SWT.getPlatform()</code>的字符串相同的方式指定平台。例如，以下字符串被认为是有效的： <code>win32</code> ， <code>gtk</code> ， <code>motif</code> ， <code>carbon</code>和<code>photon</code> 。</li>
<li><b>locale</b> - 应用此绑定的语言环境。这对于更改与特定于语言环境的输入法编辑器（IME）冲突的绑定很有用。语言环境的指定方式与<code>Locale.toString()</code>相同。例如， <code>"en"</code>或<code>"en_CA"</code>都被理解。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">id IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">执行时应传递给命令的参数名称和值。这允许以某种方式限定命令。例如，“Show View”命令可能接受视图id作为参数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 命令所理解的参数名称。这不是可翻译的名称，而是名称 - 值映射的关键。</li>
<li><b>value</b> - 参数的值。此值是一个自由格式的字符串，但它应该由命令解析。请参阅该命令以查看它希望这些值采用的格式。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.sequenceModifier">sequenceModifier</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST sequenceModifier</p>
<p class="code SchemaDtdAttlist">找到CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">替换CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">平台CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">序列修饰符转换此扩展名上的键绑定。如果此扩展中定义的键绑定以'find'字符串开头，则它将用'replace'字符串替换该部分。如果键绑定中的平台是“平台”中的平台之一或者未指定键绑定中的平台，则会发生此替换，但当前平台是“平台”中指定的平台之一</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>找到</b> -<p>必须替换的键序列。此键序列应包含一个或多个修改键，而不包含实际键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。
</p></li>
<li><b>替换</b> -<p>将被替换的键序列。此键序列应包含一个或多个修改键，而不包含实际键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。
</p></li>
<li><b>platforms</b> - 要应用修饰符的平台的逗号分隔值。应该以与<code>SWT.getPlatform()</code>的字符串相同的方式指定单个平台字符串。例如，以下字符串被认为对平台有效： <code>win32</code> ， <code>gtk</code> ， <code>motif</code> ， <code>carbon</code>和<code>photon</code> 。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.bindings”</span> <span class="code SchemaTag">&gt; &lt;sequenceModifier find =</span> <span class="code SchemaCstring">“M1 + M2”</span> <span class="code SchemaTag">replace =</span> <span class="code SchemaCstring">“M2 + M3”</span> <span class="code SchemaTag">platforms =</span> <span class="code SchemaCstring">“cocoa，carbon”</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">“M2 + F5”</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">“example.commandId”</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">“org.eclipse.ui.defaultAcceleratorConfiguration”</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">“org.eclipse.ui.contexts.dialog”</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">“M1 + M2 + 8”</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">“another.example.commandId “</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">”org.eclipse.ui.defaultAcceleratorConfiguration“</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">”org.eclipse.ui.contexts.window“</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">”M2 + F7“</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">”other.commandId“</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">”default.id“</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">“org.eclipse.ui.contexts.dialog”</span> <span class="code SchemaTag">/&gt; &lt;scheme name =</span> <span class="code SchemaCstring">“Default”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“Eclipse的默认快捷方式”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“default.id”</span> <span class="code SchemaTag">/&gt; &lt;/ extension&gt;</span></pre>在这个例子中，在win32上， <code>another.example.commandId</code>将被绑定到<b>M1 + M2 + 8</b> ，但是在cocoa上它将被绑定到<b>M2 + M3 + 8</b> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>没有用于定义绑定的公共API。为了尝试实现用户的稳定性，仅通过扩展点定义绑定。如果您是RCP应用程序，则应该能够在<code>WorkbenchAdvisor</code>覆盖此行为。
</p>
<p>要使绑定生效，您必须已定义<a href="org_eclipse_ui_commands.html">命令</a> 。要使绑定起作用，该命令必须具有活动<a href="org_eclipse_ui_handlers.html">处理程序</a> 。处理程序可以通过编程方式注册;请参阅<a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>扩展点。
</p>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2009 IBM Corporation等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从<a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>获取<a href="http://www.eclipse.org/legal/epl-v10.html">。</a>

</p>
</body>
</html><html id="2863.org_eclipse_ui_bindings.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>绑定</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">绑定</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.bindings<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.1<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6><p><code>org.eclipse.ui.bindings</code>扩展点用于声明绑定和方案。方案是一个或多个绑定的集合。绑定是某组条件，某些用户输入和触发命令之间的映射。
</p>
<p>所有绑定都需要某种触发器，它们处于活动状态的上下文以及它们存在的方案。如果您不确定选择哪种上下文，请将其留空。它将默认为<code>"org.eclipse.ui.contexts.window"</code>上下文。此上下文意味着绑定将应用于任何Eclipse主窗口。当上下文变为活动状态时，绑定也将变为活动状态。来自子上下文的绑定将覆盖父上下文的绑定。有关上下文的更多信息，请参阅<code>org.eclipse.ui.contexts</code>扩展点。
</p>
<p>如果绑定未定义命令标识符，则它是删除标记。这意味着如果满足所有条件，它将取消在相同上下文中具有相同触发器的任何绑定。例如，该机制可用于改变特定平台上的绑定。
</p>
<p>一种类型的绑定是<code>key</code>绑定（即键盘快捷键）。例如，将<code>Ctrl+C</code>绑定到<code>Copy</code>被视为<code>key</code>绑定。键绑定的触发器是一系列键击。
</p>
<p>方案是一组这些绑定到最终用户可以选择的集合中。例如，用户可能希望使用默认方案，但他们可能还需要Emacs样式方案或简约方案。
</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.scheme">scheme</a> *， <a href="#e.key">key</a> *， <a href="#e.sequenceModifier">sequenceModifier</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.scheme">scheme</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计划</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">描述CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">parentId IDREF #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>方案是最终用户可以选择使用的一组绑定。
</p>
<p>方案可以从父方案继承绑定。这旨在使插件开发人员更容易创建自定义绑定集。子方案中定义的活动绑定将始终覆盖父方案中的活动绑定（如果它们具有相同的触发器）。该技术用于在工作台中提供Emacs方案。
</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此方案的唯一标识符。</li>
<li><b>name</b> - 此方案的名称，因为它应显示给最终用户。该值应该被翻译。</li>
<li><b>description</b> - 此方案的描述，因为它将显示给最终用户。该值应该被翻译。</li>
<li><b>parentId</b> - 此方案的父级的标识符。如果没有父级，则不要指定此属性。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.key">键</a> （ <a href="#e.parameter">参数</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST键</p>
<p class="code SchemaDtdAttlist">序列CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">schemeId IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">contextId IDREF“org.eclipse.ui.contexts.window”</p>
<p class="code SchemaDtdAttlist">commandId IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">平台CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">locale CDATA #IMPLIED&gt;</p>
<p></p>
<div class="ConfigMarkupElementDesc">
<p>某些键盘输入和命令触发之间的绑定。</p></div>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>序列</b> -<p>此绑定的关键序列。该键序列应包含一个或多个键击。击键用空格分隔。击键由一个或多个同时按下的键组成。这应该是零个或多个修饰键，以及另一个键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。由于<code>M2+M3+&lt;Letter&gt;</code> （ <code>Alt+Shift+&lt;Letter&gt;</code> ）在MacOS X上保留用于写入特殊字符，因此对于<code>platform="carbon"</code> ，此类绑定通常未定义，并重新定义为<code>M1+M3+&lt;Letter&gt;</code> 。
</p>
<p>实际的键通常简单地指定为ASCII字符，大写。因此，例如<code>F</code>或<code>,</code>是这种键的示例。但是，有一些特殊的钥匙;没有可打印ASCII表示的键。以下是当前特殊键的列表： <code>ARROW_DOWN</code> ， <code>ARROW_LEFT</code> ， <code>ARROW_RIGHT</code> ， <code>ARROW_UP</code> ， <code>BREAK</code> ， <code>BS</code> ， <code>CAPS_LOCK</code> ， <code>CR</code> ， <code>DEL</code> ， <code>END</code> ， <code>ESC</code> ， <code>F1</code> ， <code>F2</code> ， <code>F3</code> ， <code>F4</code> ， <code>F5</code> ， <code>F6</code> ， <code>F7</code> ， <code>F8</code> ， <code>F9</code> ， <code>F10</code> ， <code>F11</code> ， <code>F12</code> ， <code>F13</code> ， <code>F14</code> ， <code>F15</code> ， <code>FF</code> ， <code>HOME</code> ， <code>INSERT</code> ， <code>LF</code> ， <code>NUL</code> ， <code>NUM_LOCK</code> ， <code>NUMPAD_0</code> ， <code>NUMPAD_1</code> ， <code>NUMPAD_2</code> ， <code>NUMPAD_3</code> ， <code>NUMPAD_4</code> ， <code>NUMPAD_5</code> ， <code>NUMPAD_6</code> ， <code>NUMPAD_7</code> ， <code>NUMPAD_8</code> ， <code>NUMPAD_9</code> ， <code>NUMPAD_ADD</code> ， <code>NUMPAD_DECIMAL</code> ， <code>NUMPAD_DIVIDE</code> ， <code>NUMPAD_ENTER</code> ， <code>NUMPAD_EQUAL</code> ， <code>NUMPAD_MULTIPLY</code> ， <code>NUMPAD_SUBTRACT</code> ， <code>PAGE_UP</code> ， <code>PAGE_DOWN</code> ， <code>PAUSE</code> ， <code>PRINT_SCREEN</code> ， <code>SCROLL_LOCK</code> ， <code>SPACE</code> ， <code>TAB</code>和<code>VT</code> 。</p>
<p>我们还了解一些常见特殊键的替代名称。例如，我们接受<code>ESC</code>和<code>ESCAPE</code> ， <code>CR</code> ， <code>ENTER</code>和<code>RETURN</code>都是相同的。
</p>
<p>强烈建议您保持密钥序列的简短。一两个是你应该需要的最多。使用上下文为应用程序的不同部分提供不同含义的键序列。最多，您不应使用包含四个以上击键的任何键序列。
</p></li>
<li><b>schemeId</b> - 此键绑定处于活动状态的方案的标识符。</li>
<li><b>contextId</b> - 此键绑定处于活动状态的上下文的标识符。请参阅<code>org.eclipse.ui.contexts</code>扩展点。如果未指定，则默认为<code>org.eclipse.ui.contexts.window</code> 。</li>
<li><b>commandId</b> -<p>触发此绑定时应执行的命令的标识符。
</p>
<p>如果未指定命令标识符，则这是删除标记。这意味着当此绑定变为活动状态时，具有相同序列，平台和区域设置的相同上下文中的任何绑定都将变为非活动状态。如果未指定删除的平台或区域设置，则它将匹配任何平台或区域设置。
</p></li>
<li><b>platform</b> - 此绑定适用的平台。应该以与<code>SWT.getPlatform()</code>的字符串相同的方式指定平台。例如，以下字符串被认为是有效的： <code>win32</code> ， <code>gtk</code> ， <code>motif</code> ， <code>carbon</code>和<code>photon</code> 。</li>
<li><b>locale</b> - 应用此绑定的语言环境。这对于更改与特定于语言环境的输入法编辑器（IME）冲突的绑定很有用。语言环境的指定方式与<code>Locale.toString()</code>相同。例如， <code>"en"</code>或<code>"en_CA"</code>都被理解。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.parameter">参数</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参数</p>
<p class="code SchemaDtdAttlist">id IDREF #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">执行时应传递给命令的参数名称和值。这允许以某种方式限定命令。例如，“Show View”命令可能接受视图id作为参数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 命令所理解的参数名称。这不是可翻译的名称，而是名称 - 值映射的关键。</li>
<li><b>value</b> - 参数的值。此值是一个自由格式的字符串，但它应该由命令解析。请参阅该命令以查看它希望这些值采用的格式。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.sequenceModifier">sequenceModifier</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST sequenceModifier</p>
<p class="code SchemaDtdAttlist">找到CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">替换CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">平台CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">序列修饰符转换此扩展名上的键绑定。如果此扩展中定义的键绑定以'find'字符串开头，则它将用'replace'字符串替换该部分。如果键绑定中的平台是“平台”中的平台之一或者未指定键绑定中的平台，则会发生此替换，但当前平台是“平台”中指定的平台之一</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>找到</b> -<p>必须替换的键序列。此键序列应包含一个或多个修改键，而不包含实际键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。
</p></li>
<li><b>替换</b> -<p>将被替换的键序列。此键序列应包含一个或多个修改键，而不包含实际键。键由<code>+</code>字符分隔。
</p>
<p>识别的修饰键是<code>M1</code> ， <code>M2</code> ， <code>M3</code> ， <code>M4</code> ， <code>ALT</code> ， <code>COMMAND</code> ， <code>CTRL</code>和<code>SHIFT</code> 。“M”修饰符键是表示键的独立于平台的方式，这些通常是优选的。<code>M1</code>是MacOS X上的<code>COMMAND</code>键，以及大多数其他平台上的<code>CTRL</code>键。<code>M2</code>是<code>SHIFT</code>键。<code>M3</code>是MacOS X上的<code>Option</code>键，大多数其他平台上的<code>ALT</code>键。<code>M4</code>是MacOS X上的<code>CTRL</code>键，在其他平台上未定义。
</p></li>
<li><b>platforms</b> - 要应用修饰符的平台的逗号分隔值。应该以与<code>SWT.getPlatform()</code>的字符串相同的方式指定单个平台字符串。例如，以下字符串被认为对平台有效： <code>win32</code> ， <code>gtk</code> ， <code>motif</code> ， <code>carbon</code>和<code>photon</code> 。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.bindings”</span> <span class="code SchemaTag">&gt; &lt;sequenceModifier find =</span> <span class="code SchemaCstring">“M1 + M2”</span> <span class="code SchemaTag">replace =</span> <span class="code SchemaCstring">“M2 + M3”</span> <span class="code SchemaTag">platforms =</span> <span class="code SchemaCstring">“cocoa，carbon”</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">“M2 + F5”</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">“example.commandId”</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">“org.eclipse.ui.defaultAcceleratorConfiguration”</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">“org.eclipse.ui.contexts.dialog”</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">“M1 + M2 + 8”</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">“another.example.commandId “</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">”org.eclipse.ui.defaultAcceleratorConfiguration“</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">”org.eclipse.ui.contexts.window“</span> <span class="code SchemaTag">/&gt; &lt;key sequence =</span> <span class="code SchemaCstring">”M2 + F7“</span> <span class="code SchemaTag">commandId =</span> <span class="code SchemaCstring">”other.commandId“</span> <span class="code SchemaTag">schemeId =</span> <span class="code SchemaCstring">”default.id“</span> <span class="code SchemaTag">contextId =</span> <span class="code SchemaCstring">“org.eclipse.ui.contexts.dialog”</span> <span class="code SchemaTag">/&gt; &lt;scheme name =</span> <span class="code SchemaCstring">“Default”</span> <span class="code SchemaTag">description =</span> <span class="code SchemaCstring">“Eclipse的默认快捷方式”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“default.id”</span> <span class="code SchemaTag">/&gt; &lt;/ extension&gt;</span></pre>在这个例子中，在win32上， <code>another.example.commandId</code>将被绑定到<b>M1 + M2 + 8</b> ，但是在cocoa上它将被绑定到<b>M2 + M3 + 8</b> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><p>没有用于定义绑定的公共API。为了尝试实现用户的稳定性，仅通过扩展点定义绑定。如果您是RCP应用程序，则应该能够在<code>WorkbenchAdvisor</code>覆盖此行为。
</p>
<p>要使绑定生效，您必须已定义<a href="org_eclipse_ui_commands.html">命令</a> 。要使绑定起作用，该命令必须具有活动<a href="org_eclipse_ui_handlers.html">处理程序</a> 。处理程序可以通过编程方式注册;请参阅<a href="org_eclipse_ui_handlers.html">org.eclipse.ui.handlers</a>扩展点。
</p>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2009 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="2076.s3.2.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s3.1.html" rel="prev">&lt;&lt;§3.1标注方法绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s3.3.html" rel="next">§3.3升降&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s3.html" rel="section">§3标注绑定</a></div>
         <div class="sect depth2" id="s3.2">
            <h2 class="sect">§3.2标注参数映射<a class="img" href="s3.2.html" title="PermaLink至§3.2Sallout参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="syntaxlink"><a href="sA.html#sA.4.1" title="§A.4.1CalloutParameterMappings" class="syntax">→语法§A.4.1</a></div>
            <div class="subsect depth3" id="s3.2.a">
               <h4 class="subsect">（a） <span class="title">与条款</span><a class="img" href="s3.2.a.html" title="PermaLink到（a）with子句"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果callout绑定中的方法指示符是签名（不仅仅是方法名称），则可以使用<code>with{...}</code>子子句映射参数和返回值。仅当封闭角色是类而不是接口时，才会发生参数映射。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.2.b">
               <h4 class="subsect">（b） <span class="title">映射一个参数</span><a class="img" href="s3.2.b.html" title="PermaLink到（b）映射一个参数"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>对于提供的基本方法的每个参数，只有一个参数映射定义，实际将哪个值传递给基本方法。Callout参数映射具有以下形式：</p>
               <div class="listing plain"><pre><i>表达式</i> <b>- &gt;</b> <i>base_method_parameter_name</i></pre></div>
            </div>
            <div class="subsect depth3" id="s3.2.c">
               <h4 class="subsect">（c） <span class="title">结果映射</span><a class="img" href="s3.2.c.html" title="PermaLink到（c）结果映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>callout方法的返回值可以由结果映射提供：</p>
               <div class="listing plain"><pre>结果<b>&lt; -</b> <i>表达式</i></pre></div>
               <p>结果映射的右侧表达式可以使用特殊标识符<code>result</code>来引用base方法返回的值。
                  		<br>在使用参数映射进行绑定的方法中，使用<code>result</code>作为常规方法参数的名称是错误的。
                  			
               </p>
               <h5 class="listing">示例代码（标注参数映射）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre>整数absoluteValue（整数整数） <b>- &gt;</b> <b>int</b> abs（ <b>int</b> i） <em><b>with</b> {</em></pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>integer.intValue（） <b>- &gt;</b> i，</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>  <em>结果</em> <b>&lt; -</b> <b>新</b>整数（ <em>结果</em> ）</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre><em>}</em></pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth3" id="s3.2.d">
               <h4 class="subsect">（d） <span class="title">可见名称</span><a class="img" href="s3.2.d.html" title="永久链接到（d）可见名称"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>出现在参数映射表达式中的每个标识符必须是：</p>
               <ul>
                  <li>角色实例范围内可见的功能。</li>
                  <li>角色方法的参数（用于参数映射）。</li>
                  <li>特殊名称<code>result</code> （用于结果映射）。
                  </li>
                  <li>在结果映射中，也可以使用特殊名称<code>base</code>来引用绑定的基本实例（前提是绑定的方法不是静态的）。
                  </li>
               </ul>
               <p>基本方法参数的名称（即映射后的名称）仅在<a href="#s3.2.b" title="§3.2。（b）映射一个参数" class="sect">§3.2。（b）中</a>给出的位置是合法的。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.2.e">
               <h4 class="subsect">（e） <span class="title">隐式参数映射</span><a class="img" href="s3.2.e.html" title="PermaLink到（e）隐式参数映射"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果应省略参数映射，则必须满足以下条件：</p>
               <ol>
                  <li>角色方法的每个方法参数必须符合基本方法的相应参数， <em>并且</em></li>
                  <li>基本方法的结果类型必须符合角色方法的结果类型。
                  </li>
               </ol>
               <p>这里的一致性包括翻译多态性（参见<a href="s3.3.d.html" title="§3.3。（d）打字规则" class="sect">§3.3。（d）</a> ）。
                  		<br>没有参数映射的参数对应由声明顺序而不是名称确定。
                  	    <br>但是，可以隐式执行两项调整：</p>
               <ul>
                  <li>如果角色方法具有比基本方法更多的参数，则可以静默忽略未使用的尾随参数。
                  </li>
                  <li>如果role方法返回<code>void</code> ，则可以静默忽略base方法的任何结果。
                  </li>
               </ul>
            </div>
            <h5 class="listing">示例代码（带参数映射的标注）：</h5>
            <div class="listing example frame">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">1</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>课</b> MyTeamA {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">2</td>
                     <td><pre>  <b>公共</b> <b>抽象</b> <b>类</b> Role1 {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">3</td>
                     <td><pre>    <b>abstract</b> <b>void</b> payEuro（float euro）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">4</td>
                     <td><pre>    <b>abstract</b> float earnEuro（）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">五</td>
                     <td><pre>    <b>void</b> idle（ <b>int</b> seconds）{ <span class="comment">/ *什么都不做* /</span> };</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">6</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">7</td>
                     <td><pre>Role1 boss，worker = <span class="comment">//初始化省略</span></pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">8</td>
                     <td><pre>  <b>public</b> <b>void</b> transaction（）{</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">9</td>
                     <td><pre>boss.payEuro（worker.earnEuro（））;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">10</td>
                     <td><pre>boss.idle（123）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">11</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">12</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">13</td>
                     <td><pre><b>public</b> <b>class</b> Staff { <span class="comment">//基类</span></pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">14</td>
                     <td><pre>  <b>public</b> <b>void</b> payDM（float dm）{...};</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">15</td>
                     <td><pre>  <b>public</b> float earnDM（）{...};</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">16</td>
                     <td><pre>  <b>public</b> <b>int</b> doze（）{...};</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">17</td>
                     <td><pre>  <span class="comment">//省略了其他方法</span></pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">18</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">19</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>类</b> MySubTeam <b>扩展了</b> MyTeamA {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">20</td>
                     <td><pre>  <b>公共</b> <b>类</b>角色1 <b>扮演</b>员工{</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">21</td>
                     <td><pre>    <b>void</b> payEuro（float euro） <b>- &gt;</b> <b>void</b> payDM（float dm） <b>with</b> {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">22</td>
                     <td><pre>欧元* 1.95583f <b>- &gt;</b> dm</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">23</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">24</td>
                     <td><pre>float earnEuro（） <b>- &gt;</b> float earnDM（） <b>with</b> {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">25</td>
                     <td><pre>结果<b>&lt; -</b> result / 1.95583f</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">26</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">27</td>
                     <td><pre>idle <b>=&gt;</b> doze; <span class="comment">//覆盖idle（）的现有实现</span></pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">28</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">29</td>
                     <td><pre>  <b>void</b> doit（）{</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">三十</td>
                     <td><pre>交易（）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">31</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">32</td>
                     <td><pre>}</pre></td>
                  </tr>
               </table>
            </div>
            <div class="codecomment">
               <h5>功效：</h5>
               <ul>
                  <li>类<code>MyTeamA</code>是声明性完整的，可以进行类型检查，因为它只使用在此上下文中可见或声明的方法。但是， <code>MyTeamA.Role1</code>不能被实例化，因为它是抽象的。
                  </li>
                  <li>第30行具有调用<code>transaction</code>的正常效果。
                  </li>
                  <li>执行<code>transaction</code> ，使用方法<code>earnDM()</code> （第24行中的绑定声明<code>worker.earnEuro()</code>将<code>worker.earnEuro()</code>的调用转发到相应的基础对象。结果由“ <code>result / 1.95583f</code> ”（第25行）转换。
                  </li>
                  <li>在同一个<code>transaction</code>执行中，使用方法<code>payDM()</code> （第21行中的绑定声明<code>boss.payEuro()</code>将<code>boss.payEuro()</code>的调用转发到相应的基础对象。参数<code>euro</code>由“ <code>euro * 1.95583f</code> ”（第22行）转换。
                  </li>
                  <li>方法<code>idle</code>被转发到<code>doze</code>而没有任何参数映射。这需要<code>doze</code>以具有符合<code>idle</code>签名的签名。在这种情况下，将忽略角色参数和基本结果。<br>使用<code>=&gt;</code>运算符，此绑定将覆盖现有的<code>idle</code>实现。
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s3.1.html" rel="prev">&lt;&lt;§3.1标注方法绑定</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s3.3.html" rel="next">§3.3升降&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s3.html" rel="section">§3标注绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="2874.org_eclipse_ui_decorators.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>装饰</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">装饰</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.decorators<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>2.0<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>此扩展点用于将装饰器添加到订阅装饰器管理器的视图。从2.1开始，有一个轻量级装饰器的概念，它将处理装饰器的图像管理。也可以声明一个轻量级的装饰器，它在启用时只需覆盖一个图标，不需要插件的实现。<p>如果扩展点支持，则可以分别使用元素<samp>启用</samp>和<samp>可见性</samp>来定义动作的启用和/或可见性。这两个元素包含一个布尔表达式，该表达式被计算以确定启用和/或可见性。
</p><p><samp>启用</samp>和<samp>可见性</samp>元素的语法相同。两者都只包含一个布尔表达式子元素。在最简单的情况下，这将是一个<samp>对象类</samp> <samp><samp>，objectState，pluginState，</samp></samp>或<samp>systemProperty</samp>元件。在更复杂的情况下，可以组合<samp>and</samp> ， <samp>or</samp>和<samp>not</samp>元素以形成布尔表达式。两个<samp>和</samp> ，和<samp>或</samp>元件必须含有2子元素。<samp>not</samp>元素必须只包含1个子元素。
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.decorator">装饰</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符</li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.decorator">装饰器</a> （ <a href="#e.description">描述</a> ？， <a href="#e.enablement">启用</a> ？）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST装饰</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">objectClass CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">适应性（真|假）</p>
<p class="code SchemaDtdAttlist">state（true | false）</p>
<p class="code SchemaDtdAttlist">轻量级（true | false）</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">位置（TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT | UNDERLAY | REPLACE）&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 将用于标识此装饰器的唯一名称。</li>
<li><b>label</b> - 将在工作台窗口菜单中用于表示此装饰器的可翻译名称。</li>
<li><b>class</b> - 实现<samp>org.eclipse.jface.viewers的类的完全限定名称<samp>。ILabelDecorator</samp>如果<b><i>轻量级</i></b>为false或<samp>org.eclipse.jface.viewers。如果轻量级为true， 则为ILightweightLabelDecorator</samp> 。默认值为false。如果没有<b><i>类</i></b>元素，则假定它是轻量级的。在没有装饰器类的情况下，这被认为是声明性的。当使用<code>IDecoratorManager#update()</code>更改这些值时，需要显式更新具有基于会话属性，持久属性或项目描述值（如性质）的启用的声明式装饰器。
<br>如果标签装饰器为装饰创建图像描述符，则必须确保将相同的实例用于相同的装饰对象，或者使用相应地实现<code>#equals</code>和<code>#hashCode</code>的图像描述符实现。</li>
<li><i style="color:red">不推荐使用的</i> <b>objectClass</b> - 将应用此装饰器的类的完全限定名称。在2.1中弃用。将此值作为启用的一部分。</li>
<li><b>adaptable</b> - 一个标志，指示可以适应除objectClass之外的对象的类型是否应使用此对象贡献。对于非轻量级装饰器，如果objectClass适应IResource，则此标志仅具有效果。对于轻量级装饰器，只要通过适配器管理器定义适应性，就支持对任何objectClass的适应性（请参阅类org.eclipse.runtime。IAdapterManager）。默认值为false。</li>
<li><b>state</b> - 一个标志，指示装饰器是否默认打开。默认值为false。</li>
<li><b>轻量级</b> - 轻量级标志表示装饰器是声明式的或实现<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。</li>
<li><b>icon</b> - 如果装饰器是<b><i>轻量级的</i></b>并且未指定<b><i>类，</i></b>则这是要应用的叠加图像的路径</li>
<li><b>location</b> - 如果装饰器是<b><i>轻量级的，</i></b>这是应用装饰器的位置。默认为BOTTOM_RIGHT。在3.4中添加了一个新的可能值REPLACE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！元素<a name="e.description">描述</a> （#PCDATA）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">一个可选的子元素，其主体应包含提供装饰器简短描述的文本。这将显示在Decorators首选项页面中，因此建议包含此选项。默认值为空String。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的启用。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.visibility">可视性</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不能</a> | <a href="#e.objectClass">对象类</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于定义扩展的可见性。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.and">和</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其两个子元素表达式求值结果的布尔OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">不</a> （ <a href="#e.and">和</a> | <a href="#e.or">或</a> | <a href="#e.not">不</a> | <a href="#e.objectClass">的objectClass</a> | <a href="#e.objectState">objectState</a> | <a href="#e.pluginState">pluginState</a> | <a href="#e.systemProperty">systemProperty</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的布尔NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectClass">objectClass</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectClass</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的类或接口。如果选择中的每个对象都实现指定的类或接口，则表达式将计算为true。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 类或接口的完全限定名称。仅当选择内的所有对象都实现此类或接口时，表达式才会被计算为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.objectState">objectState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST objectState</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估当前选择中每个对象的属性状态。如果选择中的每个对象都具有指定的属性状态，则表达式将计算为true。要评估此类表达式，选择中的每个对象都必须实现或适应<samp>org.eclipse.ui。IActionFilter</samp>接口。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 对象属性的名称。可接受的名称反映了对象类型，并且应该由声明对象类型的插件公开声明。@see IResourceActionFilter获取支持的常量列表</li>
<li><b>value</b> - 对象属性的必需值。应公开声明对象属性的可接受值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.pluginState">pluginState</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST pluginState</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值（已安装|已激活）“已安装”&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估插件的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 插件注册表中可能存在或可能不存在的插件的标识符。</li>
<li><b>value</b> - 插件所需的状态。插件的状态可以是以下之一： <samp>已安装</samp> （相当于“已解决”的OSGi概念）或已<samp>激活</samp> （相当于“活动”的OSGi概念）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemProperty">systemProperty</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemProperty</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估某些系统属性的状态。从<samp>java.lang中检索属性值<samp>。系统</samp> 。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 系统属性的名称。</li>
<li><b>value</b> - 系统属性的必需值。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是装饰器的示例：<p>一个完整的装饰。插件开发人员必须处理自己的图像支持。
</p>
<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。DecoratorContributor“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>


<p>轻量级装饰。有一个具体的类，但由于它是一个ILightweightLabelDecorator，它只需要提供文本和ImageDescriptor，因此不需要资源处理。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">class =</span> <span class="code SchemaCstring">“com.xyz。LightweightDecoratorContributor“</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">”true“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p>一个声明性的轻量级装饰器。没有具体的类，因此它提供了一个图标和一个象限来应用该图标。
</p>

<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.decorators”</span> <span class="code SchemaTag">&gt; &lt;decorator id =</span> <span class="code SchemaCstring">“com.xyz.lightweight.declarative.decorator”</span> <span class="code SchemaTag">label =</span> <span class="code SchemaCstring">“XYZ Lightweight Declarative Decorator”</span> <span class="code SchemaTag">state =</span> <span class="code SchemaCstring">“false”</span> <span class="code SchemaTag">lightweight =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">icon =</span> <span class="code SchemaCstring">“ icons / full / declarative.png“</span> <span class="code SchemaTag">location =</span> <span class="code SchemaCstring">”TOP_LEFT“</span> <span class="code SchemaTag">&gt; &lt;enablement&gt; &lt;objectClass name =</span> <span class="code SchemaCstring">”org.eclipse.core.resources。IResource“</span> <span class="code SchemaTag">/&gt; &lt;/ enablement&gt; &lt;/ decorator&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>class</samp>属性的值必须是实现<samp>org.eclipse.jface.viewers的类的完全限定名<samp>。ILabelDecorator</samp> （如果轻量级为false）或<samp>org.eclipse.jface.viewers。ILightweightLabelDecorator</samp> 。尽可能晚地加载此类，以避免在真正需要之前加载整个插件。声明性装饰器不需要任何插件激活，应尽可能使用。非轻量级装饰器最终将被弃用。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>插件可以使用此扩展点来添加要应用于使用装饰器管理器作为其标签装饰器的视图的新装饰器。要使用装饰器管理器，请使用IViewPart.getDecoratorManager（）的结果作为DecoratingLabelProvider实例的装饰器。资源导航器目前正在使用它。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2002,2014 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0535.User-Guide.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>EGit用户指南</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">EGit用户指南</th>
			</tr>
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">概念</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Getting_Started">入门</h1>
		<h2 id="Overview">概观</h2>
		<p>如果您不熟悉Git或分布式版本控制系统，那么您可能希望首先阅读<a href="../../EGit/Git_For_Eclipse_Users/Git-For-Eclipse-Users.html" title="适用于Eclipse用户的EGit / Git">Git for Eclipse Users</a> 。更多背景和详细信息可以在在线书籍<a href="https://git-scm.com/book/en/v2" target="egit_external">Pro Git中找到</a> 。
		</p>
		<p>如果您来自CVS，您可以找到Git <a href="http://wiki.eclipse.org/Platform-releng/Git_Workflows" title="Platform-releng/Git Workflows" target="egit_external">Platform-releng / Git Workflows的</a>常见CVS工作<a href="http://wiki.eclipse.org/Platform-releng/Git_Workflows" title="Platform-releng / Git工作流程" target="egit_external">流程</a> 。
		</p>
		<h3 id="The_Preferences_Dialog">首选项对话框</h3>
		<p>您将在Eclipse中进行的许多配置都可以在“首选项”对话框中找到。从名为“首选项”的菜单项中自然产生“首选项”对话框。但是“首选项”菜单项有点难以找到。首选项位于“文件”或“编辑”菜单下，但位于“窗口”菜单下。</p>
		<ul>
			<li>单击<b>窗口&gt;首选项</b>
			</li>
		</ul>
		<p>在“首选项”对话框中，特定的git选项在表面上<i>也不</i>可见，但可以在“团队”标题下找到。您还可以在首选项对话框中找到Git项目，方法是在框中输入<code>git</code>作为过滤字符串，最初表示<i>类型过滤器文本</i> 。
		</p>
		<h2 id="Basic_Tutorial:_Adding_a_project_to_version_control">基础教程：将项目添加到版本控制</h2>
		<h3 id="Configuration">组态</h3>
		<h4 id="Identifying_yourself">识别自己</h4>
		<p>每当更改存储库的历史记录时（从技术上讲，无论何时创建提交），Git都会跟踪创建该提交的用户。标识由名称（通常是人名）和电子邮件地址组成。此信息存储在专用键下的文件<code>~/.gitconfig</code> 。
			<br>
		</p>
		<p>在您创建第一次提交时，EGit会要求您提供此信息。默认情况下，此对话框仅显示一次，直到您创建新工作区或勾选Git Preference页面上的“显示初始配置对话框”复选框：</p>
		<p>
			<img border="0" src="images/Egit-0.11-initialConfigurationDialog.png">
		</p>
		<p>如果您想稍后再次查看，也可以取消选中“不再显示此对话框”。</p>
		<p>您可以随时使用Git配置更改此信息，而不是使用此对话框：<br>
		</p>
		<ul>
			<li>单击<b>窗口&gt;首选项&gt;团队&gt; Git&gt;配置</b>
			</li>
			<li>单击<b>New Entry</b>并输入键值对<code>user.email</code>和<code>user.name</code>
				<br>
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-email.png">
		</p>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-name.png">
		</p>
		<h4 id="Setting_up_the_Home_Directory_on_Windows">在Windows上设置主目录</h4>
		<p>将环境变量<code>HOME</code>添加到环境变量中。</p>
		<ol>
			<li>在Windows 7中，在开始菜单中键入“environment”。</li>
			<li>选择“为您的帐户编辑环境变量”。</li>
			<li>在“用户变量”下，单击“新建”按钮。</li>
			<li>在名称字段中输入“HOME”。</li>
			<li>在值字段中输入“％USERPROFILE％”或其他路径。</li>
			<li>单击确定，然后再次单击确定。您刚刚在Windows上添加了主目录。&lt;br /&gt;</li>
			<li>文件&gt;退出，然后重新启动应用程序。</li>
		</ol>
		<p>请注意，如果您使用<a href="http://www.cygwin.com/" target="egit_external">Cygwin</a> ，则应该已经设置了<code>HOME</code> 。例如，如果您将Cygwin安装到<code>C:\cygwin</code>并且您的用户名是Fred，那么Cygwin应该已经将<code>HOME</code>设置为<code>C:\cygwin\home\Fred</code> （或类似的东西）。您可以通过在Windows命令提示符下输入<code>echo %HOME%</code>或在Cygwin shell中输入<code>echo $HOME</code>来验证这一点。
		</p>
		<p>EGit需要此路径来查找用户配置（.gitconfig）。<code>HOME</code>应指向您的主目录，例如<code>C:\Users\Tom</code> 。
			<b>确保正确的情况！</b> 例如<code>C:\users</code>而不是<code>C:\Users</code>可能会导致问题！
		</p>
		<p>如果未定义<code>HOME</code>变量，则将通过连接<code>HOMEDRIVE</code>和<code>HOMEPATH</code>来计算主目录。</p>
		<p>如果未定义<code>HOME</code>和<code>HOMEDRIVE</code> ，则将使用<code>HOMESHARE</code> 。</p>
		<p>如果未明确定义<code>HOME</code>则EGit会显示警告。请记住，如果在Eclipse运行时设置HOME环境变量，您仍会看到以下警告。您必须重新启动Eclipse才能识别HOME值。</p>
		<p>
			<img border="0" src="images/Egit_no_home.png">
		</p>
		<h4 id="Pointing_out_the_System_wide_configuration">指出系统范围的配置</h4>
		<p>如果您使用Git for Windows作为EGit的伴侣，请确保EGit知道Git的安装位置，以便它可以找到“系统范围设置”，例如如何设置core.autocrlf。转到设置并在Team&gt; Git&gt; Configuration下查看，然后在System Settings选项卡下查看。</p>
		<p>如果您在安装Git for Windows时从命令行提示符中选择了一个选项来使用Git，那么系统范围设置的位置将填入路径并且一切正常。如果没有，请使用“浏览”按钮找到Git的安装位置，例如C：\ Program Files（x86）\ Git。</p>
		<p>此建议也适用于其他Git包装的用户，例如Cygwin或TortoiseGit下的Git。</p>
		<p>理论上，非Windows用户应检查此设置，但系统范围的设置通常不在非Windows平台上使用。</p>
		<h3 id="Create_Repository">创建存储库</h3>
		<ul>
			<li>创建一个新的Java项目<code>HelloWorld</code> 。（在这种情况下，项目是在Eclipse Workspace之外构建的。）</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-project.png">
		</p>
		<ul>
			<li>选择项目，单击<b>文件&gt;团队&gt;共享项目</b> 。
			</li>
			<li>选择存储库类型<b>Git</b> ，然后单击<b>Next</b> 。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-share.png">
		</p>
		<ul>
			<li>要配置Git存储库，请选择新项目<code>HelloWorld</code> 。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-create-project.png">
		</p>
		<ul>
			<li>单击<b>Create Repository</b>以初始化<code>HelloWorld</code>项目的新Git存储库。如果您的项目已经驻留在现有Git存储库的工作树中，则会自动选择存储库。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-project-created.png">
		</p>
		<ul>
			<li>单击“ <b>完成”</b>关闭向导。
			</li>
			<li>项目后面的装饰器文本“[master]”显示该项目在<i>主</i>分支上的存储库中跟踪，问号装饰器显示<code>.classpath</code>和<code>.project</code>以及<code>.settings</code>文件尚未受版本控制。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-shared-project.png">
		</p>
		<h3 id="Track_Changes">跟踪变化</h3>
		<ul>
			<li>单击项目节点上的<b>团队&gt;添加到索引</b> 。（此菜单项在旧版本的Egit上命名为<b>Add</b> 。）
			</li>
			<li><i>+</i>装饰器显示现在项目的文件已添加到版本控制中。
			</li>
			<li>将“bin”文件夹标记为“Git忽略”，方法是右键单击它并选择<b>Team&gt; Ignore</b>或在项目文件夹中创建文件<code>.gitignore</code> ，其中包含以下内容：</li>
		</ul>
		<pre>/箱</pre>
		<ul>
			<li>这将从Git的跟踪文件列表中排除<code>bin</code>文件夹。</li>
			<li>将<code>.gitignore</code>添加到版本控制（ <b>团队&gt;添加</b> ）：</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-getstarted-ignore-added.png">
		</p>
		<ul>
			<li>您可能必须设置Package Explorer过滤器才能看到Package Explorer中显示的<code>.gitignore</code> 。要访问过滤器，请选择Package Explorer选项卡右边缘的向下箭头以显示View Menu。</li>
		</ul>
		<p>
			<img border="0" src="images/Pe_downarrow1.png">
		</p>
		<ul>
			<li>从“视图”菜单中选择“ <b>过滤器...</b> ”，您将看到“Java元素过滤器”对话框。取消选择顶部条目以显示以。开头的文件。 （期间）如<code>.gitignore</code> 。
			</li>
		</ul>
		<ul>
			<li>在项目上下文菜单中单击<b>Team&gt; Commit</b> 。
			</li>
			<li>输入解释您的更改的提交消息，第一行（后面跟一个空行）将成为此提交的短日志。默认情况下，作者和提交者来自主目录中的<code>.gitconfig</code>文件。</li>
			<li>您可以单击<b>Add Signed-off-by</b>添加<i>Signed-off-by：</i>标记。
			</li>
			<li>如果您要更改其他作者，则可以更改作者字段以提供作者的姓名和电子邮件地址。</li>
			<li>单击“ <b>提交”</b>以提交第一个更改。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-commit.png">
		</p>
		<ul>
			<li>请注意，由于您的提交，已提交文件的装饰器已更改。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-commited.png">
		</p>
		<h3 id="Inspect_History">检查历史</h3>
		<ul>
			<li>从上下文菜单中单击<b>团队&gt;在历史记录</b>中显示以检查资源的历史记录：</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-getstarted-history1.png">
		</p>
		<ul>
			<li>创建一个新的Java类<code>Hello.java</code>并实现它。</li>
			<li>将其添加到版本控制并提交更改。</li>
			<li>改进您的实现并提交改进的类。</li>
			<li>资源历史记录现在应该显示此类的2个提交。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.9-getstarted-application.png">
		</p>
		<p>
			<img border="0" src="images/Egit-0.11-getstarted-history2.png">
		</p>
		<ul>
			<li>单击历史记录视图中的<b>比较模式</b>切换按钮。
			</li>
			<li>双击历史记录视图的“资源”列表中的<code>src/Hello.java</code> ，以在“比较视图”中打开上次提交的更改。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.11-getstarted-compare.png">
		</p>
		<p>
			<br>

			<b>恭喜你，你刚刚使用Git掌握了你的第一个项目！</b>

			<br>
			<br>
		</p>
		<h2 id="GitHub_Tutorial">GitHub教程</h2>
		<h3 id="Create_Local_Repository">创建本地存储库</h3>
		<ul>
			<li>按照<a href="http://wiki.eclipse.org/EGit/User_Guide/Getting_Started" title="EGit /用户指南/入门" target="egit_external">EGit /用户指南/入门</a>创建一个新的本地存储库（使用您的内容而不是演示项目）。
			</li>
		</ul>
		<h3 id="Create_Repository_at_GitHub">在GitHub上创建存储库</h3>
		<ul>
			<li>在GitHub上创建一个新的存储库：</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-create-repo.png">
		</p>
		<p>在下一个屏幕上，您可以看到可用于访问新的新存储库的URL：</p>
		<ul>
			<li>单击<b>SSH</b>以选择<i>SSH协议</i> 。它可用于读写访问。
			</li>
			<li>单击<b>HTTP</b>以选择<i>HTTP协议</i> 。它还可以用于读写访问。
			</li>
			<li>单击<b>Git只读</b>以选择用于克隆的匿名<i>git协议</i> 。这是git支持的最有效的协议。由于<i>git协议</i>不支持身份验证，因此通常用于提供对公共存储库的高效只读访问。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-cloneurl.png">
		</p>
		<h3 id="Eclipse_SSH_Configuration">Eclipse SSH配置</h3>
		<ul>
			<li>打开Eclipse Preference对话框（ <b>Window&gt; Preferences</b> ）。导航到并展开“网络连接”选项，然后选择“SSH”。确保您的SSH2主目录配置正确（通常是<tt>〜/ .ssh</tt> ）并包含SSH2密钥：</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-ssh-preferences.png">
		</p>
		<ul>
			<li>如果您还没有SSH密钥，则可以在此对话框的第二个选项卡上生成它们（ <b>密钥管理</b> ）。使用好的密码来保护您的私钥，有关详细信息，请参阅<a href="http://help.github.com/working-with-key-passphrases/" target="egit_external">“使用密钥密码”</a> 。
			</li>
			<li>将您的公共SSH密钥上传到您的<a href="https://github.com/settings/keys" target="egit_external">GitHub帐户</a>或<a href="https://gitlab.com/profile/keys" target="egit_external">GitLab配置文件</a>设置。
			</li>
		</ul>
		<p>有关高级SSH配置的更多信息（例如使用Putty或其他带有EGit的SSH代理）可在<a href="http://wiki.eclipse.org/EGit/FAQ#SSH_config" title="例如：It / FAQ＃ssh_config中" target="egit_external">EGit FAQ（SSH部分）中找到</a> 。
		</p>
		<h3 id="Push_Upstream">推动上游</h3>
		<ul>
			<li>单击<b>Team&gt; Remote&gt; Push ...</b>并复制并粘贴新GitHub存储库的SSH URL。
			</li>
			<li>如果您位于不允许SSH流量的防火墙后面，请改用GitHub HTTPS URL并提供GitHub用户和密码，而不是使用上传的公共SSH密钥。要将凭据存储到Eclipse安全存储中，请单击“ <b>在Secure Store中存储”</b> 。
			</li>
			<li>
				<b>注意：</b>许多HTTP代理配置为阻止包含用户名的HTTP URL，因为在HTTP URL中公开用户名被视为安全风险。在这种情况下，从HTTP URL中删除用户名，并仅在用户字段中提供。它将作为HTTP标头发送。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-pushurl.png">
		</p>
		<ul>
			<li>单击<b>下一步</b> ，在第一个连接上接受GitHub的主机密钥。
			</li>
		</ul>
		<ul>
			<li>输入SSH密钥的密码，然后单击“ <b>确定”</b> 。</li>
		</ul>
		<ul>
			<li>在下一个向导页面上，单击“ <b>添加所有分支规范”</b>以将本地分支名称映射到目标存储库中的相同分支名称（以一对一的方式）。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-push-refspec.png">
		</p>
		<ul>
			<li>单击<b>下一步</b> 。推送确认对话框将显示将推送到目标存储库的更改的预览。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-push-preview.png">
		</p>
		<ul>
			<li>单击“ <b>完成”</b>以确认您要推送这些更改。
			</li>
		</ul>
		<ul>
			<li>下一个对话框报告推送操作的结果。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-pushresult.png">
		</p>
		<ul>
			<li>将浏览器指向GitHub存储库，以查看新的存储库内容是否已到达。</li>
		</ul>
		<p>
			<img border="0" src="images/Egit-0.10-github-pushed-repo.png">
		</p>
		<p>
			<br>
		</p>
		<h2 id="EclipseCon_2012_Git_Tutorial">EclipseCon 2012 Git教程</h2>
		<p>在<a href="https://docs.google.com/open?id=0B4F_gjXVrHZVRXkydE0xVFBRRkc1WUpEcXdwQ2I1dw" target="egit_external">此处</a>查找所有练习和幻灯片。
		</p>
		<p>按照<a href="https://docs.google.com/document/d/1UCbNCvljiInc6-vwBsHHzOQ1ItC10f1bFAOi8T30DJ8/edit" target="egit_external">练习＃1</a>准备Git教程。
		</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Concepts.html" title="概念">
						<img alt="下一个" border="0" src="../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">概念</td>
			</tr>
		</table>
	</body>
</html><html id="0134.iv-HowToLinkTwoReports.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>如何链接两个报告</title>
    <link rel="StyleSheet" href="css/viewing.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="iv-HowToCreateAHyperlinkToLinkTwoSections.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="iv-HowToCreateATOCEntry.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h4 class="N_hth_HowToHelp"><a name="350395">如何链接两个报告</a></h4>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="350396">在源报告中，选择源报告元素。“属性编辑器”显示所选报表元素的属性。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="350401">在属性编辑器的“属性”下，选择“超链接”。将显示超链接属性，</a> <a href="#350410" title="如何链接两个报告">如图18-6</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="350408"><img class="Default" src="images/hyperlink.png" alt="图18-6超链接属性" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图18-6</b> <a name="350410">超链接属性</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="350412">选择编辑。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="350414">在“超链接选项”中，完成以下任务：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350417">在“选择超链接”类型中，选择“钻取”。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350419">在“选择目标报告”中，完成以下任务之一：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="350420">选择Report Design，然后选择Browse For File按钮并导航到目标报表设计。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="350421">选择“报告文档”，然后选择“浏览文件”按钮并导航到目标报告文档。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i2_Indent2"><a name="350422">如果目标报告具有参数，则启用报告参数。</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350424">要在目标报告中设置报告参数的值，请执行以下步骤：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n3_NumList3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n3_NumList3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray2">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n3_NumList3_inner"><a name="350425">选择“参数”列标题下方的字段。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n3_NumList3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n3_NumList3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray2">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n3_NumList3_inner"><a name="350426">从此字段的下拉列表中选择参数名称。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n3_NumList3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n3_NumList3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray2">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n3_NumList3_inner"><a name="350427">选择Required列标题下方的字段。如果目标报告需要此参数的值，则会出现复选标记。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n3_NumList3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n3_NumList3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray2">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n3_NumList3_inner"><a name="350428">选择“值”列标题下方的字段。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n3_NumList3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n3_NumList3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray2">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n3_NumList3_inner"><a name="350429">在此字段中键入表达式，或选择省略号按钮以构建表达式。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i2_Indent2"><a name="350430">要在目标报表设计中设置其余参数的值，请在“报表参数”中的其他空行中执行这些步骤。</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350433">在“选择目标锚点”中，完成以下任务之一：</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="350435">选择目标书签，然后从下拉列表中选择书签。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="b3_Bullet3_outer" style="margin-left:28.3464566929134pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="b3_Bullet3_inner" style="width:14.173228346456703pt;white-space:nowrap">
                <img src="Bullet.png" alt="*" border="0" width="6" height="6">
              </div>
            </td>
            <td width="100%">
              <div class="b3_Bullet3_inner"><a name="350437">在目标报告中选择目录条目，然后从下拉列表中选择目录条目。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <p class="N_si_ScanIcon"><a name="350441"><img class="Default" src="images/expressionbldrbutton.png" alt="Expression Builder按钮" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350444">在“创建与目标书签匹配的链接表达式”中，选择“表达式”构建器按钮并构建表达式，例如row [“CUSTOMERNAME”]。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350446">在“显示目标报告”中，选择一个选项，指示要在其中显示目标报告的窗口或框架。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350448">要选择非HTML的输出格式，请选择“格式化目标报告”。然后，在格式化目标报告中，选择一个可用选项。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="350451">在“工具提示”中，键入描述超链接的帮助消息。当用户将鼠标指针放在超链接上时，会出现此消息。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a href="#350461" title="如何链接两个报告" name="350455">图18-7</a>显示了“超链接选项”中的示例条目。</div>
      <p class="i2_Image2"><a name="350459"><img class="Default" src="images/hyperopt2.png" alt="图18-7超链接属性追溯选项示例条目" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图18-7</b> <a name="350461">超链接属性追溯选项示例条目</a></div>
      <div class="N_i_Indent1"><a name="350463">选择确定。</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="3103.launcher.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="copyright" content="Copyright (c) 2007, 2019 EclipseSource. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
  <title>从IDE启动RAP应用程序</title>
  <link rel="stylesheet" href="../../../PRODUCT_PLUGIN/book.css" type="text/css"></link>
</head>
<body dir="ltr">

  <h1>从IDE启动RAP应用程序</h1>

  <p>RAP工具提供了两个专用的启动程序，可直接从IDE启动RAP应用程序：用于片段和<a href="rwt-standalone.html">独立应用程序</a>的<em>RWT Launcher</em> ，以及用于<a href="application-setup.html#osgi">基于OSGi的应用程序</a>的<em>RAP Launcher</em> 。后者也可以使用普通的<em>OSGi Launcher</em>在没有RAP工具的情况下<em>启动</em> 。
  </p>

  <p>
    <b>内容：</b>
  </p>
  <ul>
    <li><a href="#rwt-launcher">使用RWT启动器</a></li>
    <li><a href="#rap-launcher">使用RAP启动器</a></li>
    <li><a href="#osgi-launcher">使用OSGi启动器</a></li>
    <li><a href="#troubleshooting">故障排除</a></li>
  </ul>

  <h2><a name="rwt-launcher"></a>使用RWT启动器</h2>

  <p>RWT Launcher是启动RAP应用程序的最简单方法。它不需要<a href="application-setup.html#osgi">OSGi</a> ， <a href="application-configuration.html">应用程序配置</a>或<a href="branding.html">品牌</a> ，只需要一个<a href="hello-world.html#entrypoint">入口点</a> 。因此，此方法不允许多个入口点或应用程序的任何自定义（例如，使用自定义主题）。
  </p>
  <ol>
    <li>选择包含要启动的入口点的Java类（例如，在<em class="UILabel">Package Explorer中</em> ）。
    </li>
    <li>在菜单栏中选择<em class="UILabel">“运行”&gt;“运行方式”&gt;“RWT应用程序</em> ”，或在文件的上下文菜单中选择<em class="UILabel">“运行方式”&gt;“RWT应用程序</em> <em class="UILabel">”</em> 。
    </li>
    <li>该应用程序将在浏览器视图中启动和打开。
    </li>
  </ol>
  <p>在RWT启动程序启动应用程序之前，它会终止同一应用程序的任何可能正在运行的实例。成功启动后，您应该在Console视图中看到如下消息：<br>
    <code style="color:red">INFO: Started SocketListener on 0.0.0.0:&lt;port&gt;</code> 。
  </p>

  <h3>进一步启动配置选项</h3>

  <p>每当您按上述方法启动应用程序时，都会创建<em>启动配置</em>并将其添加到“ <em class="UILabel">运行”&gt;“运行历史记录”</em>菜单中。创建的启动配置基于Java项目和IDE首选项。稍后可以使用自定义或其他参数对其进行编辑和优化。
  </p>

  <p>要创建新的启动配置或更改现有<em class="UILabel">配置</em> ，请选择<em class="UILabel">“运行”&gt;“运行配置...”</em>或<em class="UILabel">“运行”&gt;“调试配置...”</em> 。这将打开一个对话框，允许您创建，修改和删除不同类型的启动配置。要创建新的RWT应用程序启动配置， <em class="UILabel">请</em>从左侧的启动配置类型列表中选择<em class="UILabel">RWT Application</em> ，然后按工具栏中的“ <em class="UILabel">新建”</em>按钮。右侧的选项卡允许您控制启动的特定方面。
  </p>

  <p>在<em class="UILabel">Main</em>选项卡上，您可以控制启动的以下方面：</p>
  <ul>
    <li><em class="UILabel">项目</em>字段表示包含要启动的入口点的项目。您不必指定项目，但这样做可以选择默认的类路径，源查找路径和JRE。
    </li>
    <li><em class="UILabel">应用程序入口点</em>允许您指定应启动的内容。对于简单用例，请选择<em class="UILabel">“运行入口点类”，</em>并在“类名”字段中指定实现<em><a href="../reference/api/org/eclipse/rap/rwt/application/EntryPoint.html">EntryPoint</a></em>接口的类。
      <br>如果您需要更多控制或甚至想要运行任意Web应用程序，请选择<em class="UILabel">从web.xml运行</em>并在位置字段中输入<em class="UILabel">web.xml</em>的路径。
    </li>
    <li>“ <em class="UILabel">在浏览器中打开”</em>组允许您控制是否应在成功启动后在浏览器中打开应用程序。应用程序可以在内部浏览器中打开，即嵌入在Eclipse IDE中，也可以在外部浏览器中打开。可以在IDE的<em>Web浏览器</em>首选项中配置外部浏览器应用程序。链接<em class="UILabel">配置浏览器...</em>让你跳到那里。<em class="UILabel">Servlet Path</em>用于构造将在浏览器中打开的URL。如果您要启动<em>入口点</em> ，则可以自由选择任意路径。从<em>web.xml</em>启动应用程序时，它必须指向web.xml中定义的一个servlet。
    </li>
    <li>在“ <em class="UILabel">服务器设置”中</em> ，您可以选择启动应用程序的固定网络端口，会话超时和上下文路径。
      <p>
        <em class="UILabel">使用固定端口</em>配置，您可以选择固定网络端口来启动应用程序。如果您不配置端口，启动器将选择一个空闲端口，每次启动时可能会有所不同。
      </p>
      <p>
        <em class="UILabel">会话超时</em>以分钟为单位指定servlet会话超时。如果未选中该复选框，则会话将永不过期。
      </p>
      <p>
        <em class="UILabel">Context Path</em>为Web应用程序选择可选的上下文路径。上下文路径是Web应用程序URL的一部分，例如<code style="white-space:nowrap">http://&lt;server&gt;:&lt;port&gt;/contextPath/servletPath</code> 。在servlet容器中，每个Web应用程序都可以在其自己的上下文路径中使用。通过此设置，您可以模拟生产环境中可访问应用程序的相同上下文路径。
      </p>
    </li>
    <li>
      <p>选项<em class="UILabel">Start in development mode</em>选择将传递给客户端的RWT JavaScript库的变体。如果启用了开发模式，则客户端会以其原始的，可读的形式维护JavaScript代码。如果关闭，则通过压缩JavaScript代码来优化客户端的速度和大小。它还会将非关键JavaScript错误打印到浏览器控制台，而不是崩溃整个客户端。
      </p>
    </li>
  </ul>

  <p>有关其他选项卡的说明，请参阅<a href="/help/topic/org.eclipse.jdt.doc.user/tasks/tasks-java-local-configuration.htm">创建Java应用程序启动配置</a>主题
  </p>

  <h2><a name="rap-launcher"></a>使用RAP启动器</h2>

  <p>RAP Launcher基于<a href="/help/topic/org.eclipse.pde.doc.user/guide/tools/launchers/equinox_launcher.htm">OSGi Launcher</a>并向其添加<em class="UILabel">Main</em>标签页。请注意，RAP Launcher仅在选择Equinox OSGi Framework时有效，这是页面<em class="UILabel">Bundles</em>上的默认设置。
  </p>

  <h3>在浏览器中打开</h3>
  <p>此设置允许您控制是否应在成功启动后在浏览器中打开应用程序。应用程序可以在内部浏览器中打开，即嵌入在Eclipse IDE中，也可以在外部浏览器中打开。外部浏览器应用程序可以在IDE的<em>Web浏览器</em>首选项中<em class="UILabel">配置</em> ，链接<em class="UILabel">配置浏览器...</em>允许您直接跳转到那里。
  </p>
  <p><em class="UILabel">Servlet Path</em>字段允许您配置将在浏览器中打开的URL。哪个路径映射到<a href="application-configuration.html">应用程序配置中配置的</a>入口点。
  </p>

  <h3>服务器设置</h3>
  <p>
    <em class="UILabel">使用固定端口</em>配置，您可以选择固定网络端口来启动应用程序。如果您不配置端口，启动器将选择一个空闲端口，每次启动时可能会有所不同。
  </p>
  <p>
    <em class="UILabel">会话超时</em>以秒为单位指定servlet会话超时。如果未选中该复选框，则会话将永不过期。
  </p>
  <p>
    <em class="UILabel">Context Path</em>为Web应用程序选择可选的上下文路径。上下文路径是Web应用程序URL的一部分，例如<code>http://&lt;server&gt;:&lt;port&gt;/contextPath/servletPath</code> 。在servlet容器中，每个webapp都可以在其自己的上下文路径中使用。通过此设置，您可以模拟生产环境中可访问应用程序的相同上下文路径。
  </p>
  <p>选项<em class="UILabel">Start in development mode</em>选择将传递给客户端的RWT JavaScript库的变体。如果启用了开发模式，则客户端会以其原始的，可读的形式维护JavaScript代码。如果关闭，则通过压缩JavaScript代码来优化客户端的速度和大小。它还会将非关键JavaScript错误打印到浏览器控制台，而不是崩溃整个客户端。
  </p>

  <h3>实例区</h3>
  <p>实例区域位置设置程序参数以定义<em><a href="/help/topic/org.eclipse.platform.doc.isv/reference/misc/runtime-options.html">osgi.instance.area</a></em> 。Bundles使用此位置来存储其状态位置数据。</p>

  <h3>必需的插件</h3>
  <p>在Bundles选项卡中，需要激活以下bundle：</p>

  <p>
    <b>基本RAP捆绑包</b>
  </p>
  <ul>
    <li><em>org.eclipse.rap.rwt</em></li>
    <li>
      <em>org.eclipse.rap.rwt.osgi</em></li>
  </ul>

  <p>
    <b>基本的Equinox OSGi平台</b>
  </p>
  <ul>
    <li><em>org.eclipse.osgi</em></li>
    <li><em>org.eclipse.osgi.services</em></li>
    <li><em>org.eclipse.equinox.console</em> （OSGi控制台）<ul>
        <li><em>org.apache.felix.gogo.command</em> （equinox.console要求）</li>
        <li><em>org.apache.felix.gogo.shell</em> （equinox.console要求）</li>
        <li><em>org.apache.felix.gogo.runtime</em> （equinox.console要求）</li>
      </ul>
    </li>
    <li><em>org.eclipse.equinox.http.jetty</em></li>
    <li><em>org.eclipse.equinox.http.servlet</em></li>
    <li><em>org.eclipse.equinox.ds</em> （启用声明性服务）<ul>
        <li><em>org.eclipse.equinox.util</em> （equinox.ds需要）</li>
      </ul>
    </li>
  </ul>

  <p>
    <b>Jetty servlet容器</b>
  </p>
  <ul>
    <li><em>org.eclipse.jetty.continuation</em></li>
    <li><em>org.eclipse.jetty.http</em></li>
    <li><em>org.eclipse.jetty.io</em></li>
    <li><em>org.eclipse.jetty.security</em></li>
    <li><em>org.eclipse.jetty.server</em></li>
    <li><em>org.eclipse.jetty.servlet</em></li>
    <li><em>org.eclipse.jetty.util</em></li>
  </ul>

  <p>
    <b>Servlet API</b> （部署到servlet容器时删除）</p>
  <ul>
    <li><em>的javax.servlet</em></li>
  </ul>

  <p>
    <b>可选的RAP捆绑包</b> （需要其他平台捆绑包 - 见下文）</p>
  <ul>
    <li><em>org.eclipse.rap.jface</em></li>
    <li><em>org.eclipse.rap.jface.databinding</em></li>
    <li><em>org.eclipse.rap.ui</em></li>
    <li><em>org.eclipse.rap.ui.forms</em></li>
    <li><em>org.eclipse.rap.ui.views</em></li>
    <li><em>org.eclipse.rap.ui.workbench</em></li>
  </ul>

  <p>
    使用JFace或Workbench的应用程序所需的<b>Eclipse平台捆绑包</b> （可能只需要一个子集，请检查实际的依赖关系）</p>
  <ul>
    <li><em>com.ibm.icu</em></li>
    <li><em>org.eclipse.core.commands</em></li>
    <li><em>org.eclipse.core.contenttype</em></li>
    <li><em>org.eclipse.core.databinding</em></li>
    <li><em>org.eclipse.core.databinding.beans</em></li>
    <li><em>org.eclipse.core.databinding.observable</em></li>
    <li><em>org.eclipse.core.databinding.property</em></li>
    <li><em>org.eclipse.core.expressions</em></li>
    <li><em>org.eclipse.core.jobs</em></li>
    <li><em>org.eclipse.core.runtime</em></li>
    <li><em>org.eclipse.equinox.app</em></li>
    <li><em>org.eclipse.equinox.common</em></li>
    <li><em>org.eclipse.equinox.registry</em></li>
    <li><em>org.eclipse.equinox.preferences</em></li>
    <li><em>org.eclipse.equinox.http.registry</em></li>
  </ul>

  <p>要启动现有启动配置，您可以使用启动快捷键<em class="UILabel">Alt + Shift + X，R</em> （运行）和<em class="UILabel">Alt + Shift + D，R</em> （调试）。
  </p>

  <h2><a name="osgi-launcher"></a>使用OSGi启动器</h2>

  <p>或者，您也可以使用普通的OSGi Launcher来启动RAP应用程序。在这种情况下，您必须自己设置必要的系统属性和程序参数。至少，您必须使用此VM参数为服务器指定HTTP端口：</p>
  <pre>-Dorg.osgi.service.http.port = &lt;PORT&gt;</pre>
  <p>要在开发模式下运行RAP，还要添加此系统属性：</p>
  <pre>-Dorg.eclipse.rap.rwt.developmentMode =真</pre>

  <h3>上下文路径</h3>
  <p>要模拟生产环境，可以使用上下文路径启动应用程序，例如<em>http：// localhost：8080 / contextPath / servletName</em> 。</p>
  <pre>-Dorg.eclipse.equinox.http.jetty.context.path = &lt;context path&gt;</pre>
  <p>有效的上下文路径以斜杠开头，不以斜杠结尾。在上面的示例中，上下文路径将是<code>/contextPath</code> 。默认值为根上下文，即URL不包含contextPath段。
  </p>

  <h3>Servlet引擎日志</h3>
  <p>默认情况下，servlet引擎（即Jetty）配置为禁止大多数日志记录信息。可以通过将此VM参数添加到启动配置来更改此设置：</p>
  <pre>-Dorg.eclipse.equinox.http.jetty.log.stderr.threshold = &lt;log level&gt;</pre>
  <p>有效的日志级别包括<em>debug</em> ， <em>info</em> ， <em>warn</em> ， <em>error</em>和<em>off</em> 。默认值是<em>警告</em> 。
  </p>

  <h2><a name="troubleshooting"></a>故障排除</h2>

  <ul>
    <li>
      <p>
        <b>不支持的JRE版本</b>
      </p>
      <p>
        <code style="color:red">java.lang中。UnsupportedClassVersionError：.class文件中的错误版本号</code>
      </p>
      <p>启动程序需要JavaSE 1.6或更高版本。如果您的项目配置了JRE &lt;1.6，则启动器将尝试以匹配的JRE开始。如果在IDE中配置了1.5 JRE，它将失败，并出现如上所示的异常。在这种情况下，请编辑启动配置并将JRE设置为Java 6或更高版本。
      </p>
    </li>
    <li id="trouble_jee">
      <p>
        <b>不支持的操作模式</b>
      </p>
      <p>
        <code style="color:red">java.lang中。UnsupportedOperationException：SimpleLifeCycle不支持Display＃sleep（）</code>
      </p>
      <p>RWT启动程序在<a href="application-setup.html#compat">JEE兼容模式下</a>启动应用程序。此模式不支持<code>Display.sleep()</code> ，具体来说，它不支持SWT主循环。启动SWT代码段时，可能不会使用此代码：</p>
      <pre class="lang-java">而（！shell.isDisposed（））{if（！）display.readAndDispatch（））display.sleep（）; } display.dispose（）;</pre>
      <p>建议扩展<a href="../reference/api/org/eclipse/rap/rwt/application/AbstractEntryPoint.html">AbstractEntryPoint，</a>而不是直接实现<a href="../reference/api/org/eclipse/rap/rwt/application/EntryPoint.html">EntryPoint</a>接口。使用AbstractEntryPoint，无论使用哪种操作模式，都不需要主循环。
      </p>
    </li>
    <li id="trouble_swt">
      <p>
        <b>UI不会对用户输入做出反应</b>
      </p>
      <p>如果应用程序以<a href="application-setup.html#compat">SWT兼容模式</a>启动并且不存在SWT主循环，则会发生这种情况。基本上与<a href="#trouble_jee">上述问题</a>相反。添加<a href="#trouble_jee">主循环</a>或扩展<a href="../reference/api/org/eclipse/rap/rwt/application/AbstractEntryPoint.html">AbstractEntryPoint</a>而不是实现<a href="../reference/api/org/eclipse/rap/rwt/application/EntryPoint.html">EntryPoint</a>接口。
      </p>
    </li>
    <li>
      <p>
        <b>404错误页面</b>
      </p>
      <p>浏览器中可能会显示404页面有两个原因。URL不正确（检查servlet路径），或者浏览器打开的速度比应用程序启动的速度快。在这种情况下，只需按F5（刷新）。
      </p>
    </li>

  </ul>

</body>
</html><html id="2249.sB.1.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.2.html" rel="next">§B.2版本之间的增加&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
         <div class="sect depth2" id="sB.1">
            <h2 class="sect">§B.1版本之间的段落发生了变化<a class="img" href="sB.1.html" title="PermaLinkto§B.1版本之间的段落发生了变化"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="subsect depth3" id="sB.1.1">
               <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.1.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s3.2.a.html" title="§3.2。（a）with clause" class="sect">§3.2。（a）</a> ： <strong>参数映射</strong><p>禁止角色接口中的参数映射。
                        			
                     </p>
                  </li>
                  <li><a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）</a> ： <strong>替换绑定</strong><p>禁止不安全地使用多态和原始类型转换。
                        			
                     </p>
                  </li>
                  <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法的签名</strong><p>使两个方法通用，以便可以使用返回值而无需进行转换。
                        				
                     </p>
                  </li>
                  <li><a href="s7.2.html" title="§7.2受限制的角色" class="sect">§7.2</a> ：受<strong>限制的角色</strong><p>改进的解释。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.2">
               <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.1.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.1.e.html" title="§1.2.1。（e）角色特征" class="sect">§1.2.1。（e）</a> ： <strong>角色特征的可见性</strong><p>添加了澄清说明角色可以始终访问其封闭团队有权访问的所有功能。
                        				
                     </p>
                  </li>
                  <li><a href="s2.1.2.e.html" title="§2.1.2。（e）没有自由类型参数" class="sect">§2.1.2。（e）</a> ： <strong>通用角色/基础</strong><p>放宽了有关通用绑定角色的规则。这种变化也包含了先前在<a href="s4.1.b.html" title="§4.1.(b) Prerequisite: Class binding" class="sect">§4.1中</a>的具体限制<a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">。（b）</a> 。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.i.html" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a>和<a href="s3.5.f.html" title="§3.5。（f）速记定义" class="sect">§3.5。（f）</a> ： <strong>速记标注的可见性</strong><p>由速记标注绑定定义的角色方法现在可以指定可见性修饰符（另请参见<a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ），否则它将继承其绑定基本方法/字段的可见性修饰符。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断标注的可见性</strong><p>推断为标注绑定的角色方法是<code>public</code> （通过接口推断）或从自我调用/字段访问推断的<code>private</code> 。
                        				
                     </p>
                  </li>
                  <li><a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>没有明确使用推断的字段</strong><p>已添加澄清说明，无法显式调用为推断的字段调用生成的访问器方法。
                        				
                     </p>
                  </li>
                  <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>没有通用角色的callin</strong><p>已经明确规定，通用角色无法定义callin绑定。
                        				
                     </p>
                  </li>
                  <li><a href="s4.2.d.html" title="§4.2。（d）Callin方法" class="sect">§4.2。（d）</a> ： <strong>Callin方法</strong><p>稍微改写并扩展规则以明确表示使用第二级callin绑定确实可以拦截callin方法。
                        				
                     </p>
                  </li>
                  <li><a href="s6.1.a.html" title="§6.1。（a）与角色登记处的接口" class="sect">§6.1。（a）</a> ： <strong>反射方法<code>getAllRoles</code></strong><p>更高精度：仅回答<em>绑定</em>角色。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.3">
               <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.1.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字的语法</strong><p>以前，不支持语法<code>R&lt;@t&gt;.class</code> 。此限制已被删除。
                        					
                     </p>
                  </li>
                  <li><a href="s1.3.html" title="§1.3角色类的获取和隐式继承" class="sect">§1.3</a> ： <strong>团队扩展非团队类</strong><p>以前， <code>org.objectteams.Team</code>是所有团队课程的超级班级。因此，团队无法扩展非团队类。通过引入所有团队的新超类型，界面<code>org.objectteams. ，已经消除了这一限制<code>org.objectteams.ITeam</code> 。当成员被移动到新界面时，此更改也会影响<a href="s6.html" title="§6ObjectTeams API" class="sect">§6中的</a>某些段落。
                        					
                     </p>
                  </li>
                  <li><a href="s1.5.e.html" title="§1.5。（e）不同超级之间的优先权" class="sect">§1.5。（e）</a> ： <strong>不同隐式超级之间的优先权</strong><p>纠正了不同超级中优先级规则的不一致性：主要规则一直是隐式继承比显式继承更强，但是，对于不同隐式超级中的优先级，定义了不同的规则。<br>这已被改变，使得不同的隐<em>式</em>超级优先于其封闭团队的优先级，使得来自<em>隐式</em>超级团队的角色与来自<em>显式</em>超级团队的角色更紧密相关。
                        					
                     </p>
                  </li>
                  <li><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）</a> ： <strong>放宽了对基类循环的规则</strong><p><a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">§2.1.2。（b）中</a>定义的基类循环不再是错误，而是可配置警告。但是，在存在基类循环的情况下，不允许调用（第<a href="s2.4.2.html" title="§2.4.2 Role creation via a regular constructor" class="sect">3.1节</a> <a href="s3.1.a.html" title="§3.1。（a）先决条件：类绑定" class="sect">（a）</a> ）和基本构造函数调用（第<a href="s2.4.2.html" title="§2.4.2通过常规构造函数创建角色" class="sect">2.4.2节</a> ）。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a> ： <strong>更改了角色绑定歧义的处理</strong><p>明确的绑定歧义不再是（可抑制的）编译器错误，而是由声明<code>org.objectteams.的需要发出信号<code>org.objectteams.LiftingFailedException</code> 。通过这种方式，诊断可以从团队中非常不特定的位置移动到那些在运行时可能因提升失败而受到影响的应用程序。虽然通常不建议忽略任何<code>LiftingFailedException</code>但在<a href="s2.3.4.b.html" title="§2.3.4.(b) Definite ambiguity" class="sect">§2.3.4。（b）中</a>提到的一些<a href="s2.3.4.b.html" title="§2.3.4。（b）明确的歧义" class="sect">极端</a>情况下，捕获此异常仍然有意义。
                        					
                     </p>
                  </li>
                  <li><a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ： <strong>进一步限制callin绑定后的结果映射</strong><p>澄清<code>after</code> callin绑定<code>after</code>无法使用<code>-&gt;</code>标记来映射结果值。
                        					
                     </p>
                  </li>
                  <li><a href="s4.8.a.html" title="§4.8。（a）优先权声明" class="sect">§4.8。（a）</a> ： <strong>影响callin绑定<code>after</code>优先声明。</strong><p>虽然以前优先声明的效果不明确，但已经定义优先声明中元素的顺序会影响它们的<em>优先级，</em>类似于<a href="s5.1.html" title="§5.1团队激活的影响" class="sect">§5.1</a> 。这意味着与先前的实现相比， <code>after</code>绑定的执行顺序现在是颠倒的。为了在程序中可视化，现在必须使用关键字<code>after</code>标记后绑定的优先声明。
                        					
                     </p>
                  </li>
                  <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ， <a href="s4.10.a.html" title="§4.10。（a）新鲜型参数" class="sect">§4.10。（a）</a> ： <strong>通用的callin绑定</strong><p><a href="s4.10.e.html" title="§4.10.(e) Propagating type parameters" class="sect">稍作</a>修改，为新段落<a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）留出</a>空间。
                     </p>
                  </li>
                  <li><a href="s5.4.1.a.html" title="§5.4.1。（a）方法绑定警卫" class="sect">§5.4.1。（a）</a> ： <strong>定期装订守卫的范围</strong><p>在常规方法绑定防护中删除了关于特殊标识符<code>result</code>的错误句子。由于在评估保护之前应用了参数映射，因此可以通过结果映射（ <a href="s4.4.c.html" title="§4.4。（c）映射基本方法的结果" class="sect">§4.4。（c）</a> ）访问结果值。此外，这句话实际上混淆了基础和角色方面。
                        	
                     </p>
                  </li>
                  <li><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="sect">§A.3.2</a> ， <a href="sA.html#sA.3.3" title="§A.3.3Callin绑定" class="sect">§A.3.3</a> ： <strong>语法：泛型方法绑定</strong><p>方法绑定中可能的类型参数的位置已经明确。</p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.1.4">
               <h4 class="subsect">（4） <span class="title">在OTJLD 1.3和OTJLD 1.4之间</span><a class="img" href="sB.1.4.html" title="PermaLink to（4）OTJLD 1.3和OTJLD 1.4之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s2.1.2.d.html" title="§2.1.2。（d）基础进口" class="sect">§2.1.2。（d）</a> ： <strong>没有按需基础进口</strong><p>已经澄清，基础进口不能是按需进口（使用通配符） <code>.*</code> ）。
                        					
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="sB.2.html" rel="next">§B.2版本之间的增加&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2015-06-09</div>
   </body>
</html><html id="0555.Doc03_ViewProviders.html" dir="ltr"></html><html dir="ltr">

<head>
<title>查看提供程序（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="View Providers (CDO Model Repository Documentation)";
    }
}
</script>

<link rel="stylesheet" href="../../editor.css" type="text/css" charset="UTF-8"></link>

<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>

<script src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.1/themes/smoothness/jquery-ui.css"></link>

<script>
$(function() {
$( ".resizable" ).resizable({ handles:"s,e,se", autoHide:true });
});
</script>

<script type="text/javascript">
function maximize(id)
{
  e = document.getElementById('max_' + id);
  c1 = document.getElementById('editor_content_1_' + id);
  c2 = document.getElementById('editor_content_2_' + id);
  pv = document.getElementById('max_pv_' + id);
  if (e.className == 'max')
  {
    e.className = 'rst';
    e.setAttribute('title', 'Restore');
    c1.setAttribute('style_orig', c1.getAttribute('style'));
    c1.setAttribute('style', 'border:2px solid #99b4d1; border-top:none;');
    c2.setAttribute('style', '');
    if (pv != null)
    {
      pv.setAttribute('width_orig', pv.getAttribute('width'));
      pv.setAttribute('width', '');
    }
  }
  else
  {
    e.className = 'max';
    e.setAttribute('title', 'Maximize');
    c1.setAttribute('style', c1.getAttribute('style_orig'));
    c1.setAttribute('style_orig', '');
    c2.setAttribute('style', 'overflow:scroll; width:100%; height:100%;');
    if (pv != null)
    {
      pv.setAttribute('width', pv.getAttribute('width_orig'));
      pv.setAttribute('width_orig', '');
    }
  }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="../index.html" title="Category in CDO Model Repository Documentation">Programmer's Guide</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">Developing Client Applications</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>查看提供商</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="Doc02_PreparingModels.html" title="向后准备CDO的EMF模型"><img src="../../../images/backward.png" border="0"></a> <a href="../server/index.html" title="转发到处理服务器"><img src="../../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Victor Roldan Betancort</p>
<p><a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProvider.html" title="org.eclipse.emf.cdo.view中的接口"><code>view provider</code></a>允许客户端将自定义逻辑注入<a href="../../../javadoc/org/eclipse/emf/cdo/eresource/CDOResourceFactory.html" title="org.eclipse.emf.cdo.eresource中的接口"><code>resource factory</code></a> mechansim，能够处理整个<a href="../../../javadoc/org/eclipse/emf/cdo/session/CDOSession.html" title="org.eclipse.emf.cdo.session中的接口"><code>session</code></a>并<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOView.html" title="org.eclipse.emf.cdo.view中的接口"><code>view</code></a>实例化过程。这允许透明地通过<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/ResourceSet.html" title="org.eclipse.emf.ecore.resource中的接口" target="_blank"><code>resource set</code></a> API获得<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/Resource.html" title="org.eclipse.emf.ecore.resource中的接口" target="_blank"><code>resources</code></a> ，而无需任何先前的CDO客户端API代码。视图提供程序自动在<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/resource/ResourceSet.html#getResource(org.eclipse.emf.common.util.URI, boolean)" title="org.eclipse.emf.ecore.resource中的方法。的ResourceSet" target="_blank"><code>ResourceSet.getResource()</code></a>调用的中间启动，忘记了在幕后发生的整个开放会话/开放事务过程。
 </p><p>当将CDO与基于EMF的框架和工具集成在一起时，这非常有用，这些框架和工具本身并不是为CDO方案准备的。
 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="3"><a href="Doc03_ViewProviders.html#ProviderImplementation" title="CDO模型存储库文档中的章节">实现View Provider</a></td></tr>
<tr><td>2</td><td class="te" colspan="3"><a href="Doc03_ViewProviders.html#ContributeProviderProgrammatically" title="CDO模型存储库文档中的章节">以编程方式提供视图提供程序</a></td></tr>
<tr><td>3</td><td class="te" colspan="3"><a href="Doc03_ViewProviders.html#ContributeProviderUsingExtensionPoint" title="CDO模型存储库文档中的章节">使用扩展点贡献视图提供者</a></td></tr>
</table>



<h2><a name="ProviderImplementation"></a> 1实现View Provider</h2>
<p>客户端应该实现<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProvider.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProvider</code></a>接口，或者实现<a href="../../../javadoc/org/eclipse/emf/cdo/view/AbstractCDOViewProvider.html" title="org.eclipse.emf.cdo.view中的类"><code>AbstractCDOViewProvider</code></a>类的子类，它提供了通用功能。
 </p><p>下面的示例显示了一个简单的实现，它打开了一个到本地服务器的<b>新</b> <a href="../../../javadoc/org/eclipse/emf/cdo/session/CDOSession.html" title="org.eclipse.emf.cdo.session中的接口"><code>session</code></a>和该会话上的<b>新</b> <a href="../../../javadoc/org/eclipse/emf/cdo/transaction/CDOTransaction.html" title="org.eclipse.emf.cdo.transaction中的接口"><code>transaction</code></a> 。
 </p><p>
 

</p><div class="snippet" align="left" style="margin-left:24px">
  <a name="snippet_ProviderImplementation_1"></a>
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td width="25px"><div style="position:relative"><img src="../../../images/editor-1.png"><img src="../../../images/formatter-java.gif" style="position:absolute;top:5px;left:5px"></div></td>
      <td width="1px" style="background-image:url(../../../images/editor-2.png);background-repeat:repeat-x"><font face="Segoe UI,Arial" size="-1">ExampleViewProvider.java</font></td>
      <td width="1px"><img src="../../../images/editor-3.png"></td>
      <td align="right" style="background-image:url(../../../images/editor-4.png);background-repeat:repeat-x"></td>
      <td align="center" width="16" style="background-image:url(../../../images/editor-4.png);background-repeat:repeat-x"><a href="javascript:void(0);" id="max_ProviderImplementation_1" class="max" title="最大化">     </a></td>
      <td width="6px"><img src="../../../images/editor-5.png"></td>
    </tr>
    <tr>
      <td colspan="6" align="left" valign="top" style="border:1px solid #a0a0a0;border-top:none" nowrap="">
        <div id="editor_content_1_ProviderImplementation_1" class="ui-widget-content resizable" style="width:600px;height:300px;border:2px solid #99b4d1;border-top:none">
          <div id="editor_content_2_ProviderImplementation_1" style="overflow:scroll;width:100%;height:100%">
            <code>
            <a name="callout_ProviderImplementation_1_1_code" href="#callout_ProviderImplementation_1_1" alt="示例提供程序捕获形状为“cdo.local：”的所有URI。" title="示例提供程序捕获形状为“cdo.local：”的所有URI。"><img src="../../../images/callout-1.png" width="16" height="16" border="0" align="top"></a> <font color="#7f0055"><b>新的</b></font> AbstractCDOViewProvider（ <font color="#2a00ff">“cdo \\。local：。*”</font> ， <font color="#990000">100</font> ）<br>{<br>
              <font color="#7f0055"><b>私有</b></font> IManagedContainer容器;<br>
            <br>
              <a name="callout_ProviderImplementation_1_2_code" href="#callout_ProviderImplementation_1_2" alt="使用CDOViewProviderRegistry注册提供程序。" title="使用CDOViewProviderRegistry注册提供程序。"><img src="../../../images/callout-2.png" width="16" height="16" border="0" align="top"></a> <font color="#7f0055"><b>public</b></font> CDOView getView（URI uri，ResourceSet resourceSet）<br>{<br>
                <font color="#7f0055"><b>if</b></font> （container == <font color="#7f0055"><b>null</b></font> ）<br>{<br>container = <font color="#7f0055"><b>new</b></font> ManagedContainer（）;<br>Net4jUtil.prepareContainer（容器）;<br>TCPUtil.prepareContainer（容器）;<br>container.activate（）;<br>}<br>
            <br>
                <font color="#7f0055"><b>int</b></font> startIndex = uri.toString（）。indexOf（ <font color="#990000">'：'</font> ）;<br>String repoName = uri.toString（）。substring（startIndex）;<br>
            <br>IConnector connector =（IConnector）container.getElement（ <font color="#2a00ff">“org.eclipse.net4j.connectors”</font> ， <font color="#2a00ff">“tcp”</font> ， <font color="#2a00ff">“localhost”</font> ）;<br>
            <br>CDONet4jSessionConfiguration config = CDONet4jUtil.createNet4jSessionConfiguration（）;<br>config.setConnector（连接器）;<br>config.setRepositoryName（repoName）;<br>
            <br>CDOSession session = config.openNet4jSession（）;<br>
                <font color="#7f0055"><b>return</b></font> session.openTransaction（）;<br>}<br>};</code>

          </div>
        </div>
      </td>
    </tr>
  </table>
</div>
<p>
</p><div style="margin-left:24px">
<a name="callout_ProviderImplementation_1_1" href="#callout_ProviderImplementation_1_1_code" alt="跳转到片段..." title="跳转到片段..."><img src="../../../images/callout-1.png" width="16" height="16" border="0" align="top"></a>示例提供程序捕获形状为“cdo.local： <reponame>”的所有URI <reponame>。

</reponame></div>
<div style="margin-left:24px">
<a name="callout_ProviderImplementation_1_2" href="#callout_ProviderImplementation_1_2_code" alt="跳转到片段..." title="跳转到片段..."><img src="../../../images/callout-2.png" width="16" height="16" border="0" align="top"></a>使用<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProviderRegistry.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProviderRegistry</code></a>注册提供程序。

</div>

<p>


</p><h2><a name="ContributeProviderProgrammatically"></a> 2以编程方式提供视图提供程序</h2>
<p>客户端的视图提供程序实现可以通过编程方式提供给<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProviderRegistry.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProviderRegistry</code></a> ，如以下示例所示：</p><p>
 

</p><div class="snippet" align="left" style="margin-left:24px">
  <a name="snippet_ContributeProviderProgrammatically_1"></a>
  <table border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td width="25px"><div style="position:relative"><img src="../../../images/editor-1.png"><img src="../../../images/formatter-java.gif" style="position:absolute;top:5px;left:5px"></div></td>
      <td width="1px" style="background-image:url(../../../images/editor-2.png);background-repeat:repeat-x"><font face="Segoe UI,Arial" size="-1">ProviderContribution.java</font></td>
      <td width="1px"><img src="../../../images/editor-3.png"></td>
      <td align="right" style="background-image:url(../../../images/editor-4.png);background-repeat:repeat-x"></td>
      <td align="center" width="16" style="background-image:url(../../../images/editor-4.png);background-repeat:repeat-x"><a href="javascript:void(0);" id="max_ContributeProviderProgrammatically_1" class="max" title="最大化">     </a></td>
      <td width="6px"><img src="../../../images/editor-5.png"></td>
    </tr>
    <tr>
      <td colspan="6" align="left" valign="top" style="border:1px solid #a0a0a0;border-top:none" nowrap="">
        <div id="editor_content_1_ContributeProviderProgrammatically_1" class="ui-widget-content resizable" style="width:600px;height:300px;border:2px solid #99b4d1;border-top:none">
          <div id="editor_content_2_ContributeProviderProgrammatically_1" style="overflow:scroll;width:100%;height:100%">
            <code>
            <font color="#3f7f5f">//实例化您的视图提供程序</font><br>CDOViewProvider viewProvider = <a name="callout_ContributeProviderProgrammatically_1_1_code" href="#callout_ContributeProviderProgrammatically_1_1" alt="获取目标CDOViewProvider实现。" title="获取目标CDOViewProvider实现。"><img src="../../../images/callout-1.png" width="16" height="16" border="0" align="top"></a> org.eclipse.emf.internal.cdo.view。PluginContainerViewProvider。实例;<br>
            <br>
            <font color="#3f7f5f">//将实例添加到注册表</font><br>
            <a name="callout_ContributeProviderProgrammatically_1_2_code" href="#callout_ContributeProviderProgrammatically_1_2" alt="将提供程序实例添加到CDOViewProviderRegistry。" title="将提供程序实例添加到CDOViewProviderRegistry。"><img src="../../../images/callout-2.png" width="16" height="16" border="0" align="top"></a> CDOViewProviderRegistry。INSTANCE.addViewProvider（viewProvider）;</code>

          </div>
        </div>
      </td>
    </tr>
  </table>
</div>
<p>
</p><div style="margin-left:24px">
<a name="callout_ContributeProviderProgrammatically_1_1" href="#callout_ContributeProviderProgrammatically_1_1_code" alt="跳转到片段..." title="跳转到片段..."><img src="../../../images/callout-1.png" width="16" height="16" border="0" align="top"></a>获取目标<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProvider.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProvider</code></a>实现。

</div>
<div style="margin-left:24px">
<a name="callout_ContributeProviderProgrammatically_1_2" href="#callout_ContributeProviderProgrammatically_1_2_code" alt="跳转到片段..." title="跳转到片段..."><img src="../../../images/callout-2.png" width="16" height="16" border="0" align="top"></a>将提供程序实例添加到<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProviderRegistry.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProviderRegistry</code></a> 。

</div>

<p>


</p><h2><a name="ContributeProviderUsingExtensionPoint"></a> 3使用扩展点贡献视图提供者</h2>
<p>还可以使用<code>org.eclipse.emf.cdo.viewProviders</code>扩展点来提供特定的<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProvider.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProvider</code></a>实现。客户指定：</p><p>
 </p><ul>
 <li>实现<a href="../../../javadoc/org/eclipse/emf/cdo/view/CDOViewProvider.html" title="org.eclipse.emf.cdo.view中的接口"><code>CDOViewProvider</code></a>接口的强制<b><code>class</code></b> 。
 </li><li>一个强制性<b>正则表达式</b>字符串，指示应与提供的提供程序匹配的<a href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/common/util/URI.html" title="org.eclipse.emf.common.util中的类" target="_blank"><code>URIs</code></a>的形状。
 </li><li>可选的<b><code>priority</code></b>整数值，用于指示与匹配相同正则表达式的其他实现相比的首选项。值越大表示优先级越高，Integer＃MAX_VALUE为最大优先级值，Integer＃MIN_VALUE为最小值。
 </li></ul>

<p align="right">
<a href="Doc02_PreparingModels.html" title="向后准备CDO的EMF模型"><img src="../../../images/backward.png" border="0"></a> <a href="../server/index.html" title="转发到处理服务器"><img src="../../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="../index.html" title="Category in CDO Model Repository Documentation">Programmer's Guide</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">Developing Client Applications</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="1978.s1.5.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="s1.4.html" rel="prev">&lt;&lt;§1.4姓名冲突</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a></div>
         <div class="sect depth2" id="s1.5">
            <h2 class="sect">§1.5团队和角色嵌套<a class="img" href="s1.5.html" title="PermaLinkto§1.5团队和角色嵌套"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <p>类的多级嵌套仅受以下规则的限制。
               		
            </p>
            <h5 class="listing">示例代码（嵌套）：</h5>
            <div class="listing example frame" id="l1.5">
               <table class="listing">
                  <tr class="line odd">
                     <td class="ln">1</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>类</b> SuperOuter {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">2</td>
                     <td><pre>  <b>公共</b> <em><b>团队</b> <b>类</b> RoleAndTeam</em> {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">3</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> InnerRole {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">4</td>
                     <td><pre>Runnable foo（）{ <b>return</b> null; }</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">五</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">6</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">7</td>
                     <td><pre>  <b>公共</b> <em><b>团队</b> <b>类</b> RoleAndTeamSub</em> <b>扩展</b> <strong>RoleAndTeam</strong> {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">8</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> InnerRole {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">9</td>
                     <td><pre>Runnable foo（）{ <b>throw</b> <b>new</b> RuntimeException（）; }</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">10</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">11</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">12</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">13</td>
                     <td><pre><b>公共</b> <b>团队</b> <b>课</b> OuterTeam <b>扩展</b> SuperOuter {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">14</td>
                     <td><pre>  <b>公共</b> <em><b>团队</b> <b>类</b> RoleAndTeam</em> {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">15</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> InnerRole {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">16</td>
                     <td><pre>Runnable foo（）{</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">17</td>
                     <td><pre>        <b>class</b> Local {};</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">18</td>
                     <td><pre>        <b>返回</b> <b>new</b> Runnable（）{ <span class="comment">//匿名类定义</span></pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">19</td>
                     <td><pre>          <b>public</b> <b>void</b> run（）{}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">20</td>
                     <td><pre>};</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">21</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">22</td>
                     <td><pre>      <span class="comment">// <span class="error">类IllegalMember {}</span></span></pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">23</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">24</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">25</td>
                     <td><pre>  <b>公共</b> <em><b>团队</b> <b>类</b> RoleAndTeamSub</em> {</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">26</td>
                     <td><pre>    <b>受保护的</b> <b>类</b> InnerRole {</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">27</td>
                     <td><pre>Runnable foo（）{</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">28</td>
                     <td><pre>        <em>RoleAndTeamSub.tsuper</em> .foo（）;</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">29</td>
                     <td><pre>        <b>return</b> <em>OuterTeam.tsuper</em> .foo（）;</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">三十</td>
                     <td><pre>};</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">31</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line even">
                     <td class="ln">32</td>
                     <td><pre>}</pre></td>
                  </tr>
                  <tr class="line odd">
                     <td class="ln">33</td>
                     <td><pre>}</pre></td>
                  </tr>
               </table>
            </div>
            <div class="subsect depth3" id="s1.5.a">
               <h4 class="subsect">（a） <span class="title">嵌套团队</span><a class="img" href="s1.5.a.html" title="PermaLink（a）嵌套团队"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果角色类也使用<code>team</code>修饰符进行标记，则它可能包含下一级嵌套的角色。
                  			
               </p>
               <div class="codecomment">
                  <ul>
                     <li>在上面的示例（ <a href="#l1.5" class="listing">清单1.5</a> ）中，从第14行开始的类<code>RoleAndTeam</code>是<code>OuterTeam</code>的角色，同时包含另一个角色<code>InnerRole</code>的团队</li>
                  </ul>
               </div>
               <p>这种混合角色和团队具有两种类的所有属性。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s1.5.b">
               <h4 class="subsect">（b） <span class="title">嵌套的角色类</span><a class="img" href="s1.5.b.html" title="PermaLink到（b）嵌套的角色类"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>常规角色类（即，未标记为<code>team</code> ，见上文）可能包含本地类型（请参阅<a href="http://java.sun.com/docs/books/jls/second_edition/html/statements.doc.html#247766" class="ext">JLS§14.3</a> - 在示例中：类<code>Local</code> ），匿名类型（ <a href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#252986" class="ext">JLS§15.9.5</a> - 在示例中：类定义在第18-20行但没有成员类型（ <a href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#246026" class="ext">JLS§8.5</a> - 在示例中：非法类<code>IllegalMember</code> ）。
                  			<br>结果是，常规角色的嵌套类型不能在其封闭角色的范围之外使用。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s1.5.c">
               <h4 class="subsect">（c） <span class="title">禁止循环</span><a class="img" href="s1.5.c.html" title="（c）禁止循环的永久链接"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>嵌套团队可能不会扩展自己的封闭团队。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s1.5.d">
               <h4 class="subsect">（d） <span class="title">禁止姓名冲突</span><a class="img" href="s1.5.d.html" title="（d）禁止姓名冲突的永久链接"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>嵌套团队可以从多个源继承角色：其显式超级团队以及来自不同嵌套级别的任何隐式超类（角色）。如果来自不同来源的团队继承了两个或多个与隐式继承无关的同名角色，则这是非法的名称冲突。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s1.5.e">
               <h4 class="subsect">（e） <span class="title">不同超级之间的优先权</span><a class="img" href="s1.5.e.html" title="永久链接到（e）不同超级之间的优先权"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果角色从多个超级角色（super和tsuper）继承相同的功能，则隐式继承的版本始终会覆盖任何显式继承的功能，即具有相同简单名称的角色与具有不同名称的角色更紧密相关。
               </p>
               <p>此外，单独的隐式继承可能会生成角色类继承的几个候选方法。这是团队嵌套的结果，如果外部团队也参与继承关系，则每个嵌套级别可以再添加一个tsuper角色。在这种情况下，从封闭团队的<em>隐式</em>超级团队继承的角色与从<em>显式</em>超级团队继承的角色更紧密相关。如果需要，此规则将在内部应用，直到找到确实涉及显式团队继承的嵌套级别。<br>因此，当通过完全限定名称比较类时，最长的通用后缀将确定最接近的关系。例如， <code>SuperOuter.RoleAndTeamSub。InnerRole</code>是InnerRole</code>最近的祖先<code>SubOuter.RoleAndTeamSub。InnerRole</code>因为两者共享名称后缀<code>RoleAndTeamSub.InnerRole</code> 。
                  			
               </p>
               <div class="codecomment">
                  <table>
                     <colgroup span="1">
                        <col align="left" span="1">
                        <col align="center" span="1">
                     </colgroup>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <p>在上面的例子中（ <a href="#l1.5" class="listing">清单1.5</a> ）角色<code class="small">OuterTeam.RoleAndTeamSub。InnerRole</code>有两个直接的tsuper角色： <code class="small">OuterTeam.RoleAndTeam。InnerRole</code>和<code class="small">SuperOuter.RoleAndTeamSub。InnerRole</code> 。没有第27-30行定义的方法<code>foo</code> ，封闭类<code class="small">OuterTeam.RoleAndTeamSub。InnerRole</code>将继承<code>SuperOuter.定义的方法<code>foo</code> <code>SuperOuter.RoleAndTeamSub。InnerRole</code> （第9行），因为公用名后缀为<code>RoleAndTeamSub.InnerRole</code>创造了一种更强大的关系，使该类成为最接近的祖先。
                           </p>
                        </td>
                        <td rowspan="1" colspan="1"><img src="../images/team_nesting_hor.png" alt="示例图团队嵌套"></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth3" id="s1.5.f">
               <h4 class="subsect">（f） <span class="title">合格的tsuper</span><a class="img" href="s1.5.f.html" title="永久链接到（f）合格的tsuper"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>嵌套团队中的角色可以通过类型名称限定关键字<code>tsuper</code> （参见<a href="s1.3.1.f.html" title="§1.3.1。（f）tsuper" class="sect">上面的§1.3.1。（f）</a> ），以便在不同的隐式超类中进行选择。术语<code>OuterTeam.tsuper</code>在封闭团队“ <code>OuterTeam</code> ”的显式超类（此处为： <code>SuperOuter</code> ）的上下文中求值为对应的隐式超类。一个方法调用<code>OuterTeam.tsuper.m()</code>的计算结果为内的方法版本<code>SuperOuter</code>最佳对应于含有tsuper呼叫当前方法。
                  			
               </p>
               <div class="codecomment">
                  <ul>
                     <li>在上面的示例（ <a href="#l1.5" class="listing">清单1.5</a> ）中，第28行选择<code>RoleAndTeamSub</code>超类中的方法版本（即在<code>RoleAndTeam</code> ），解析为<code>OuterTeam.RoleAndTeam。InnerRole.foo()</code> 。
                     </li>
                     <li>第29行从<code>SuperOuter</code>解析为<code>SuperOuter.的上下文中选择相应的方法<code>SuperOuter.RoleAndTeamSub。InnerRole.foo()</code>与非限定<code>tsuper</code>调用具有相同的语义。
                        					
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="s1.4.html" rel="prev">&lt;&lt;§1.4姓名冲突</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s1.html" rel="section">§1团队和角色</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="1747.ATL-Architecture.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>ATL开发人员指南 -  ATL架构</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">ATL架构</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="ATL Developer Guide.html" title="ATL源代码">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="ATL-Bugzilla.html" title="ATL Bugzilla">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">ATL源代码</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">ATL Bugzilla</td>
			</tr>
		</table><hr>
		<h1 id="ATL_Architecture">ATL架构</h1>
		<p>ATL架构包括：</p>
		<ul>
			<li><a href="ATL-Architecture.html#Core">核心</a> ，以抽象的方式描述ATL概念</li>
			<li><a href="ATL-Architecture.html#Parser">解析器</a>和<a href="ATL-Architecture.html#Compiler">编译器</a>
			</li>
			<li>
				<a href="ATL-Architecture.html#ATL_Virtual_Machine">虚拟机</a> ，允许执行转换</li>
			<li>IDE：编辑器，调试器，透视图，全部基于以前的组件</li>
		</ul>
		<p>以下模式描述了ATL组件及其在执行转换期间的角色。</p>
		<p>
			<img border="0" src="images/ATL_compilation_process.JPG">
		</p>
		<p>ATL VM插入ATL编译器和使用的框架（EMF，MDR）之间，允许模块化。因此，ATL语言的更改仅涉及ATL编译器。</p>
		<h2 id="Core">核心</h2>
		<p>此模式描述了ATL Core以及它与LaunchConfigurations，Ant任务等工具的交互方式。</p>
		<p>
			<img border="0" src="images/ATL_Core_Architecture.png">
		</p>
		<ul>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/IModel.java?root=Modeling_Project&amp;view=markup">IModel</a>是适用于ATL变换的模型的适应表示。它提供了查找元素，创建新元素等方法......
			</li>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/IReferenceModel.java?root=Modeling_Project&amp;view=markup">IReferenceModel</a>接口扩展了IModel，并且是IModel的特定版本，它代表了元模型。它定义了特定于元模型的操作，这些操作对ATL转换很有用</li>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/ModelFactory.java?root=Modeling_Project&amp;view=markup">ModelFactory</a>专用于模型和参考模型创建</li>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/IInjector.java?root=Modeling_Project&amp;view=markup">IInjector</a> ， <a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/IExtractor.java?root=Modeling_Project&amp;view=markup">IExtractor</a>接口提供了一种加载和保存以前由modelFactory创建的模型的方法</li>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/launch/ILauncher.java?root=Modeling_Project&amp;view=markup">ILauncher</a>接口专用于由ATL虚拟机实现：它定义了参数化和启动转换的方法</li>
		</ul>
		<h3 id="Services">服务</h3>
		<p>为了简化ATL Core的使用并减少代码重复，提供了两种服务： <a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/service/CoreService.java?root=Modeling_Project&amp;view=markup">CoreService</a>和<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core/src/org/eclipse/m2m/atl/core/service/LauncherService.java?root=Modeling_Project&amp;view=log">LauncherService</a> 。
		</p>
		<h4 id="CoreService">CoreService</h4>
		<p>此实用程序类为Core实现提供了查找eclipse扩展或内部存储的方法。这些实现可以注册到CoreService中以供独立使用。例如，我们在这里注册使用EMF特定VM启动转换所需的扩展：</p>
		<pre>CoreService.registerLauncher（new EMFVMLauncher（））; CoreService.registerFactory（“EMF”，EMFModelFactory.class）; CoreService.registerExtractor（“EMF”，new EMFExtractor（））; CoreService.registerInjector（“EMF”，new EMFInjector（））;</pre>
		<h4 id="LauncherService">LauncherService</h4>
		<p>启动器服务允许从一组参数（如路径映射和模型名称映射）启动转换：这与启动配置和ant任务密切相关，因为它允许在任何虚拟机上启动转换。</p>
		<h3 id="EMF_interactions">EMF互动</h3>
		<p>ATL Core的主要实现是EMF，它由ATL本身用于解析和编译。它在<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.emf/?root=Modeling_Project">org.eclipse.m2m.atl.core.emf</a>插件下定义。
		</p>
		<p>以下是使用ATL EMF专用进样器/提取器的说明。对于两者，我们使用EMF表示法来选择资源：</p>
		<table border="1">
			<tr>
				<th>资源类型</th>
				<th>ATL EMF API语法</th>
				<th>例</th>
			</tr>
			<tr>
				<th>文件系统资源</th>
				<td>文件：/ &lt;路径&gt;</td>
				<td>文件：/ d：/eclipse/workspace/mmproject/sample_metamodel.ecore</td>
			</tr>
			<tr>
				<th>EMF uri</th>
				<td>&lt;URI&gt;</td>
				<td>
					<a href="http://www.eclipse.org/uml2/2.1.0/UML">http://www.eclipse.org/uml2/2.1.0/UML</a>
				</td>
			</tr>
			<tr>
				<th>路径映射</th>
				<td>路径映射：&lt;路径&gt;</td>
				<td>路径映射：//PROFILE/sample_profile.uml#_0</td>
			</tr>
			<tr>
				<th>工作区资源</th>
				<td>平台：/资源/ &lt;路径&gt;</td>
				<td>平台：/resource/mmproject/sample_metamodel.ecore</td>
			</tr>
			<tr>
				<th>插件资源</th>
				<td>平台：/插件/ &lt;路径&gt;</td>
				<td>平台：/plugin/mmproject/sample_metamodel.ecore</td>
			</tr>
		</table>
		<p>以下是一个用法示例：</p>
		<pre>ModelFactory factory = CoreService.createModelFactory（“EMF”）; IReferenceModel umlMetamodel = factory.newReferenceModel（）; injector.inject（umlMetamodel，“http://www.eclipse.org/uml2/2.1.0/UML”）;</pre>
		<p>根据上表，您可以使用另一种表示法来加载模型：</p>
		<pre>injector.inject（sampleMetamodel，“file：/ D：/eclipse/workspace/mmproject/sample_metamodel.ecore”）;</pre>
		<h3 id="Examples_of_use">使用示例</h3>
		<ul>
			<li><a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.core.ui/src/org/eclipse/m2m/atl/core/ui/launch/AtlLaunchConfigurationDelegate.java?root=Modeling_Project&amp;view=markup">ATL启动配置委托</a>和<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/tests/org.eclipse.m2m.atl.tests/src/org/eclipse/m2m/atl/tests/unit/TestNonRegressionTransfo.java?root=Modeling_Project&amp;view=markup">ATL非回归测试</a>是使用<a href="ATL-Architecture.html#LauncherService">Launcher服务</a>启动的示例。
			</li>
			<li>public2private示例（ <a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/examples/org.eclipse.m2m.atl.examples.public2private.ui/src/org/eclipse/m2m/atl/examples/public2private/ui/PrivatizeAction.java?root=Modeling_Project&amp;view=markup">UI部分</a> ）显示了如何直接使用Core</li>
		</ul>
		<h2 id="ATL_Virtual_Machine">ATL虚拟机</h2>
		<p>ATL VM是一个<a href="ATL-Architecture.html#ASM_format">字节码</a>解释器，用于管理OCL和ATL类型层次结构。提供完整的ATL VM规范： <a href="http://www.eclipse.org/m2m/atl/doc/ATL_VMSpecification[v00.01].pdf">ATL_VMSpecification</a> 。该规范包含对ATL VM功能的精确描述，但没有描述实现。目的是允许任何开发人员使用任何语言创建ATL VM。<a href="http://wiki.eclipse.org/ATL_Standard_Library">Native Library</a> （org.eclipse.m2m.atl.engine.vm.nativelib包）收集ATL VM使用的所有基本类型定义：OCL类型和ATL特定类型。两者都定义在同一级别，并使用反射。OCL出现在ATL架构的几个层面：</p>
		<ul>
			<li>nativelib实现</li>
			<li>OCL包中的ATL，ACG和TCS元模型</li>
		</ul>
		<p>以下架构显示ATL VM正在运行：</p>
		<p>
			<img border="0" src="images/ATL_ASMInterpreter.JPG">
		</p>
		<p>在ATL VM初始化期间，每个操作都被注册到Map中。ExecEnv类包含虚拟执行环境。它处理操作映射，该映射记录了转换使用的所有操作。它包含给定执行所使用的每个信息，如模型，并为每次执行重新创建。根据类型，操作按顺序执行到帧中。例如，在ATL中，append（）方法的调用直接映射到对ASMSequence类中相应方法的调用。</p>
		<p>Frame存储并抛出所有错误消息。当StackFrame专用于本机方法时，ASMStackFrame专用于ASM方法。调用方法Frame.printstacktrace时，执行错误来自ATL VM。</p>
		<p>此时ATL VM有两种实现方式。</p>
		<h3 id="Regular_VM">常规VM</h3>
		<p>常规VM是ATL虚拟机的第一个版本。使用模型处理程序从使用的模型管理框架中抽象出实现。模型处理程序包含一个专用于模型访问的抽象层。此访问由两个类实现：ASMModel和ASMModelElement。</p>
		<p>ATL包含三个与不同模型处理程序相对应的插件驱动程序：EMF，MDR，UML2。每个插件都实现了那些抽象类：</p>
		<ul>
			<li>AtlModelHandler：执行基本任务“newModel”，“saveModel”，“loadModel”</li>
			<li>ASMModel：getElementsByType实现，面向框架的“newModelElement”方法等...</li>
			<li>ASMModelElement：“allInstances”实现等...</li>
		</ul>
		<p>输入和输出模型使用相同的API加载，并与“isTarget”属性区分开来。该API实现了“getMetaElementsByName”方法，该方法对应于“findme”ASM指令。</p>
		<p>此VM实现仍在ATL中使用，因为它与多个部分紧密相关。但是常规VM存在很多性能问题，特别是因为模型处理程序架构。</p>
		<h3 id="EMF-specific_VM">EMF特定的VM</h3>
		<p>特定于EMF的VM是对常规VM的重新定义，它通过避免EObjects换行来解决许多性能问题。其API允许直接将EMF资源视为模型，而无需像以前在常规VM中那样进行复杂加载。</p>
		<h3 id="ASM_format">ASM格式</h3>
		<p>ASM语言是一种汇编语言，适用于模型处理。低水平的ASM允许模块化设施，旨在提供更简单的模型管理可能性。ASM的当前文件格式是XML。因此，它不允许关心任何语法，只关注字节码。ASM文件仅包含名称和字符串常量。没有Ecore参考。这些由启动配置和AMMA Megamodel解决，具有名称绑定。</p>
		<h4 id="Serialization">序列化</h4>
		<p>ASM转换以一种提高性能和抢占二进制文件等进一步序列化的方式进行序列化。ASMXMLWriter类是一个ASM提取器，用于将ASM保存到文件中。序列化计算常量池，它通过在ASM文件的顶部生成有序常量列表来分解常量，值和方法调用。ASMWriter是父抽象类，它允许二进制实现ASM注入和提取。</p>
		<h4 id="Instructions">说明</h4>
		<p>所有指令都解释为ATL VM规范。以下是其中一些的详细信息：</p>
		<ul>
			<li>getasm指令检索ATL上下文模块，即ATL的“thisModule”等价物。</li>
			<li>N表示本机类型，特定于ATL</li>
			<li>TransientLink是可追溯性链接</li>
			<li>所有函数如“getLinkBySourceElement”都在nativelib中实现</li>
			<li>对象创建：<ul>
					<li>“new”指令有两个参数：元模型名称和分类器类型。然后它在输出模型中创建这种类型的元素（只允许一个）。这些参数在字节码中不可用，因为它们在调用指令之前被压入堆栈。</li>
					<li>我们可以注意到ATL只允许一个输出模型，但ATL VM可以扩展两个允许许多其他模型。</li>
					<li>可以在ATL VM中实现删除指令</li>
					<li>ATL提供newInstance方法，该方法直接映射到Model Handler方法。此方法不会生成新方法，因为调用是动态的。主要优点是newInstance直接应用于类，并且不使用ATL VM堆栈（否则它应该存储类元素）。</li>
				</ul>
			</li>
		</ul>
		<h2 id="Parser">分析器</h2>
		<p>使用TCS中定义的解析器完成ATL解析，该解析器输出符合ATL元模型的ATL模型。然后，ATL-WFR转换（由引擎解释）生成问题模型。此模型生成由编辑器解释的错误并转换为标记，在每个编译的ATL文件中可见。</p>
		<p>要手动解析（或提取）ATL文件，请参阅<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.engine/src/org/eclipse/m2m/atl/engine/parser/AtlParser.java?root=Modeling_Project&amp;view=markup">ATLParser</a>类。
		</p>
		<p>请注意，当ATL解析器实现IInjector和IExtractor接口时，它可以在<a href="http://wiki.eclipse.org/ATL/User_Guide#ATL_ant_tasks">ATL ant任务中</a>用于解析或提取atl文件（只需将“ATL”指定为注入器/提取器名称）。
		</p>
		<h2 id="Compiler">编译器</h2>
		<p>有两种版本的ATL编译器可用：2004和<a href="http://wiki.eclipse.org/ATL_2006" title="ATL_2006">2006</a> 。2006版ATL编译器使用<a href="ATL-Architecture.html#ACG_.28ATL_VM_Code_Generator.29">ACG</a> 。 2004版使用了ATP，这是历史上的ACG前身。
		</p>
		<p>要手动编译ATL文件，请参阅<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.m2m/org.eclipse.m2m.atl/plugins/org.eclipse.m2m.atl.engine/src/org/eclipse/m2m/atl/engine/compiler/AtlDefaultCompiler.java?root=Modeling_Project&amp;view=markup">AtlDefaultCompiler</a>类。
		</p>
		<h3 id="ACG_.28ATL_VM_Code_Generator.29">ACG（ATL VM代码生成器）</h3>
		<p>ACG是面向编译器的DSL，旨在使创建面向<a href="ATL-Architecture.html#ATL_Virtual_Machine">ATL VM</a>的编译器变得更加容易。使用ACG描述的编译器生成ASM文件，并包含ASM指令的描述，以便为来自编译文件的每种类型的输入元素生成。因此，这种编译器的输入是描述编译文件（例如，ATL文件）的内容的模型。
		</p>
		<p>编译时，ACG文件使用访问者设计模式查看输入模型。ACG是自举的：存在ACG.acg文件并描述ACG编译器。由于ACG文件精确描述了ASM指令，因此ACG.acg文件相当简单。</p>
		<p>提供<a href="http://wiki.eclipse.org/ACG" title="ACG">完整的ACG文档</a> 。
		</p>
		<p>以下架构将ACG放置在AMMA平台中。</p>
		<p>
			<img border="0" src="images/AMMA_bootstrap.JPG">
		</p><hr>
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="ATL Developer Guide.html" title="ATL源代码">
						<img alt="以前" border="0" src="images/images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="ATL Developer Guide.html" title="ATL开发人员指南">
						<img alt="ATL开发人员指南" border="0" src="images/images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="ATL-Bugzilla.html" title="ATL Bugzilla">
						<img alt="下一个" border="0" src="images/images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">ATL源代码</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">ATL Bugzilla</td>
			</tr>
		</table>
	</body>
</html><html id="2254.sB.2.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a> <a href="sB.1.html" rel="prev">&lt;&lt;§B.1版本之间的段落发生了变化</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
         <div class="sect depth2" id="sB.2">
            <h2 class="sect">§B.2版本之间的增加<a class="img" href="sB.2.html" title="PermaLinkto§B.2版本之间的增加"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="subsect depth3" id="sB.2.1">
               <h4 class="subsect">（1） <span class="title">在OTJLD 1.0和OTJLD 1.1之间</span><a class="img" href="sB.2.1.html" title="PermaLink（1）在OTJLD 1.0和OTJLD 1.1之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.4.c.html" title="§1.2.4。（c）类文字" class="sect">§1.2.4。（c）</a> ： <strong>角色类文字</strong><p>使现有功能显式化并为外化角色引入新的限定类文字。
                        				
                     </p>
                  </li>
                  <li><a href="s3.1.j.html" title="§3.1。（j）推断出的标注" class="sect">§3.1。（j）</a>和<a href="s3.5.h.html" title="§3.5。（h）推断出的标注" class="sect">§3.5。（h）</a> ： <strong>推断出的标注</strong><p>新功能。
                        				
                     </p>
                  </li>
                  <li><a href="s4.6.a.html" title="§4.6。（a）超级班的私人方法" class="sect">§4.6。（a）</a> ： <strong>来自超级类的Callin绑定私有方法</strong><p>添加了必要的限制。
                        				
                     </p>
                  </li>
                  <li><a href="s4.9.html" title="§4.9Callin继承" class="sect">§4.9</a> ： <strong>Callin继承</strong><p>澄清了指定不充分或解释不充分的问题，具体而言：</p>
                     <ul>
                        <li>callin绑定对遗传或被覆盖的基本方法的影响（ <a href="s4.9.1.html" title="§4.9.1基础侧继承" class="sect">§4.9.1</a> ）。
                        </li>
                        <li>callin绑定和基本方法与协变返回类型的<a href="s4.9.3.html" title="§4.9.3 Covariant return types" class="sect">相互作用</a> （ <a href="s4.9.3.html" title="§4.9.3协变返回类型" class="sect">§4.9.3</a> ）</li>
                     </ul>
                  </li>
                  <li><a href="s4.10.html" title="§4.10通用callin绑定" class="sect">§4.10</a> ： <strong>通用替换绑定</strong><p>通过使用类型参数调整<a href="s4.5.d.html" title="§4.5。（d）打字规则" class="sect">§4.5。（d）中</a>引入的替换绑定的类型安全性，并具有所需的灵活性。
                        				
                     </p>
                  </li>
                  <li><a href="s7.2.b.html" title="§7.2。（b）受限阵列" class="sect">§7.2。（b）</a> ： <strong>受限制的阵列</strong><p>添加了必要的限制。
                        				
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.2">
               <h4 class="subsect">（2） <span class="title">在OTJLD 1.1和OTJLD 1.2之间</span><a class="img" href="sB.2.2.html" title="PermaLink（2）在OTJLD 1.1和OTJLD 1.2之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s1.2.2.h.html" title="§1.2.2。（h）外化创作" class="sect">§1.2.2。（h）</a> ： <strong>外化创作</strong><p>使用值参数和更改的标题添加了替代语法。</p>
                  </li>
                  <li><a href="s1.2.5.f.html" title="§1.2.5。（f）进口角色档案" class="sect">§1.2.5。（f）</a> ： <strong>角色文件中的导入</strong><p>添加了缺少的规则，用于定义角色文件中的导入效果。</p>
                  </li>
                  <li><a href="s1.3.1.c.html" title="§1.3.1.(c) Overriding and implicit inheritance" class="sect">§1.3.1。（c）</a> ： <strong>@</strong> <a href="s1.3.1.c.html" title="§1.3.1。（c）覆盖和隐式继承" class="sect">Override</a> <strong>角色注释</strong><p>常规的<code>@Override</code>注释（Java≥5）也已扩展为适用于角色类。
					
                     </p>
                  </li>
                  <li><a href="s1.3.1.k.html" title="§1.3.1。（k）协变返回类型" class="sect">§1.3.1。（k）</a> ： <strong>协变返回类型</strong><p>在存在隐式和显式继承的情况下协变返回类型的必要约束。
                        					
                     </p>
                  </li>
                  <li><a href="s2.1.2.c.html" title="§2.1.2。（c）基类解封装" class="sect">§2.1.2。（c）</a> ： <strong>绑定到最终基类</strong><p>已经补充说，绑定到最终基类现在也被视为解封装。
                        					
                     </p>
                  </li>
                  <li><a href="s2.2.f.html" title="§2.2。（f）模糊降低" class="sect">§2.2。（f）</a> ： <strong>模糊降低</strong><p>添加了一个诊断来检测可能意图降低但由于声明的类型是<code>java.lang.而失败的情况<code>java.lang.Object</code> ，这使得潜在的降低翻译变得不必要并且因此是模糊的。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.2.e.html" title="§2.3.2。（e）通用宣布解除" class="sect">§2.3.2。（e）</a> ： <strong>通用声明提升</strong><p>支持将不相关的基类型传递到声明提升的相同方法中。
                        					
                     </p>
                  </li>
                  <li><a href="s2.6.g.html" title="§2.6。（g）通过基准参考进行解封装" class="sect">§2.6。（g）</a> ： <strong>通过基准参考进行解封装</strong><p>将解封装扩展到两个以上的位置。
                        					
                     </p>
                  </li>
                  <li><a href="s4.3.f.html" title="§4.3。（f）基本超级电话" class="sect">§4.3。（f）</a> ： <strong>基本超级呼叫</strong><p>支持base直接调用绑定基本方法的超级版本，从而绕过精确绑定的基本方法以及与此基本方法或其超级版本相关的任何其他callins。
                        					
                     </p>
                  </li>
                  <li><a href="s5.4.b.html" title="§5.4。（b）无副作用" class="sect">§5.4。（b）</a> ： <strong>守卫谓词的副作用</strong><p>将有关未来功能的先前注释迁移到常规段落。</p>
                  </li>
                  <li><a href="s5.4.c.html" title="§5.4。（c）例外情况" class="sect">§5.4。（c）</a> ： <strong>守卫谓词的例外情况</strong><p>澄清从保护谓词抛出的异常的影响。</p>
                  </li>
                  <li><strong>§6.2</strong> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ： <strong>LiftingVetoException</strong><p>添加了大部分内部<code>LiftingVetoException</code>文档以及它如何在客户端代码中实际使用。
                        				    
                     </p>
                  </li>
                  <li><a href="s6.2.e.html" title="§6.2。（e）角色迁移" class="sect">§6.2。（e）</a> ： <strong>角色迁移</strong><p>添加了两个接口，以将迁移功能添加到角色类。
                        				    
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.3">
               <h4 class="subsect">（3） <span class="title">在OTJLD 1.2和OTJLD 1.3之间</span><a class="img" href="sB.2.3.html" title="PermaLink（3）在OTJLD 1.2和OTJLD 1.3之间"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a> ：将<strong>角色绑定到基接口</strong><p><a href="s2.1.1.html" title="§2.1.1绑定接口" class="sect">§2.1.1</a>中提到的实施限制已被大部分删除。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.1.d.html" title="§2.3.1。（d）微调角色实例化" class="sect">§2.3.1。（d）</a> ： <strong>微调角色实例化</strong><p>已经定义了注释用于修改提升的语义以便提高性能。此外，还添加了一个新的部分作为<a href="s6.3.html" title="§6.3注释" class="sect">§6.3，</a>以总结本文档中定义的注释类型。
                        					
                     </p>
                  </li>
                  <li><a href="s2.3.5.html" title="§2.3.5解除问题的后果" class="sect">§2.3.5</a> ： <strong>解除问题的后果</strong><p>在<a href="s2.3.4.html" title="§2.3.4绑定含糊不清" class="sect">§2.3.4</a>澄清了<code>LiftingFailedException</code> （ <code>LiftingFailedException</code> <a href="s6.2.d.html" title="§6.2。（d）例外情况" class="sect">。（d）</a> ）确实是一个经过检查的异常之后，又添加了一个子节来定义这种异常在各种程序情况下的后果。
                        					
                     </p>
                  </li>
                  <li><a href="s3.1.k.html" title="§3.1。（k）通用方法的标注" class="sect">§3.1。（k）</a> ： <strong>通用方法的标注</strong><p>添加了关于callout绑定如何引用泛型基本方法的规则。
                        					
                     </p>
                  </li>
                  <li><a href="s4.1.b.html" title="§4.1。（b）先决条件：类绑定" class="sect">§4.1。（b）</a> ： <strong>Callin以“不可授予的”角色进行约束</strong><p>现在甚至可以在“unliftable”角色中定义Callin绑定。
                        	
                     </p>
                  </li>
                  <li><a href="s4.1.h.html" title="§4.1。（h）封闭类的方法" class="sect">§4.1。（h）</a> ： <strong>绑定团队方法</strong><p>callin绑定<code>before</code>和<code>after</code>现在也可以绑定到封闭类的方法。
                        	
                     </p>
                  </li>
                  <li><a href="s4.8.d.html" title="§4.8。（d）多个优先权陈述" class="sect">§4.8。（d）</a> ： <strong>合并优先声明时的顺序</strong><p>阐明了如何合并多个优先级声明，这是未指定的，因为C3算法需要有序输入，但未指定此顺序。
                        					
                     </p>
                  </li>
                  <li><a href="s4.10.e.html" title="§4.10。（e）传播类型参数" class="sect">§4.10。（e）</a> ： <strong>在callin绑定中传播类型参数</strong><p>除了捕获协变返回类型之外，callin绑定还可以声明类型参数，以便将通用性从其基本方法传播到角色方法。
                        	
                     </p>
                  </li>
                  <li><a href="s5.3.d.html" title="§5.3。（d）配置隐式激活" class="sect">§5.3。（d）</a> ： <strong>配置隐式激活</strong><p>添加了用于配置隐式团队激活的机制。默认值已更改为不应用隐式激活。<a href="s5.3.html" title="§5.3隐式团队激活" class="sect">§5.3中</a>也增加了相应的注释</p>
                  </li>
                  <li><a href="s9.2.1.a.html" title="§9.2.1。（a）实例约束类型参数" class="sect">§9.2.1。（a）</a> ： <strong>实例约束类型参数</strong><p>类型锚现在也可以应用于类型参数，从而在类型参数上表达一种新的约束。
                        	
                     </p>
                  </li>
               </ul>
            </div>
            <div class="subsect depth3" id="sB.2.4">
               <h4 class="subsect">（4） <span class="title">OTJLD 1.3之后</span><a class="img" href="sB.2.4.html" title="PermaLink至（4）OTJLD 1.3之后"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <ul>
                  <li><a href="s4.1.i.html" title="§4.1。（i）致电建设者" class="sect">§4.1。（i）</a> ： <strong>致电建设者</strong><p>绑定后的callin现在也可以应用于基类的构造函数。
                        					
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <table class="nav">
            <tr>
               <td class="back"><a href="sB.1.html" rel="prev">&lt;&lt;§B.1版本之间的段落发生了变化</a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="sB.html" rel="section">§B版本之间的变化</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="3309.extensions-provide_custom_aird_editor_pages.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>扩展 -  provide_custom_aird_editor_pages</title>
		<link type="text/css" rel="stylesheet" href="../resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="../resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="SiriusProvidecustomairdeditorpages">Sirius  - 提供自定义播放的编辑器页面</h1>
		<h2 id="Goals">目标</h2>
		<p>Sirius提供了一个带有默认页面的aird编辑器，允许处理视点和表示以及语义模型。它是最终用户的任何Sirius项目的切入点。</p>
		<p>可以向aird编辑器实例提供自定义页面，以显示默认页面中不可用的不同信息。它可以是从商业信息到通信信息的任何东西。自定义页面提供的功能如下：</p>
		<ul>
			<li>自定义页面可以替换默认页面或任何其他贡献页面。</li>
			<li>自定义页面可以位于其他页面之前或之后。</li>
			<li>自定义页面可以动态更新。即，由于您的页面实例，使用编辑器打开的aird资源集的任何更改，您可以告诉编辑器执行重新排序，删除或编辑页面选项卡刷新命令以及您的类在内部完成的刷新。</li>
			<li>只有当您的页面指定了所需的上下文时，自定义页面才会由空中编辑器显示。它没有指定这样的上下文，页面将始终显示在空中编辑器中。</li>
			<li>更新命令计算和内部刷新可以推迟到您的页面可见时，以避免在浏览其他页面时出现性能问题，而不使用您的页面。如果在刷新或计算更新命令时执行大量计算，这将非常有用。</li>
		</ul>
		<p>Sirius提供两种不同的方式为aird编辑器提供自定义页面：</p>
		<ul>
			<li>以<code>PageRegistry</code>作为入口点的API。
			</li>
			<li>与<code>sessionEditorPageProvider</code>扩展点相同的API作为入口点。
			</li>
		</ul>
		<h2 id="UsingtheAPItoprovidecustompages">使用API提供自定义页面</h2>
		<p>API由以下类组成：</p>
		<ul>
			<li><code>AbstractSessionEditorPage</code>
			</li>
			<li><code>PageProvider</code>
			</li>
			<li><code>PageUpdateCOmmand</code>
			</li>
			<li><code>PositioningKind</code>
			</li>
			<li><code>PageUpdateCommandBuilder</code>
			</li>
			<li><code>PageRegistry</code>
			</li>
		</ul>
		<p>并在封装<code>org.eclipse.sirius.ui.editor.api.pages</code>从插件<code>org.eclipse.sirius.ui.editor</code>
		</p>
		<p>要使用此API提供自定义页面，您必须：</p>
		<ol>
			<li>如果需要，构建扩展<code>AbstractSessionEditorPage</code>自定义页面，并在<code>PageUpdateCommandBuilder</code>的帮助下。
			</li>
			<li>创建一个<code>PageProvider</code> ，它将提供您的自定义页面以及您想要的其他自定义页面。
			</li>
			<li>直接在<code>PageRegistry</code>或使用提供的扩展点注册<code>PageProvider</code> 。
			</li>
			<li>启动运行时并打开建模项目的播出编辑器。如果您的自定义页面所需的显示上下文存在，则它将是可见的。</li>
		</ol>
		<p>Sirius Debug页面示例：<br>
			<img border="0" src="images/customPageApi_debugPage_example.png">
		</p>
		<h3 id="pagePositioning">页面定位</h3>
		<p>在提供自定义页面时，您可以在不同的上下文中告知与您的页面相对应的编辑器选项卡与其他页面选项卡的位置：</p>
		<ul>
			<li>页面由<code>PageProvider</code>初始化时
			</li>
			<li>当重新排序命令更新页面位置时，响应空中编辑器的会话资源集事件或页面可见性更新。</li>
		</ul>
		<p>无论上下文是什么，您总是需要提供两种信息来定位您的页面关于其他人：</p>
		<ul>
			<li>页面的<b>ID</b>将相对于页面放置。可以在<code>org.eclipse.sirius.ui.editor.访问默认的播出编辑器页面ID <code>org.eclipse.sirius.ui.editor.SessionEditorPlugin。DEFAULT_PAGE_ID</code>
			</li>
			<li>您想要实现的那种定位。不同的类型由enum <code>org.eclipse.sirius.ui.editor.api.pages.定义<code>org.eclipse.sirius.ui.editor.api.pages.PageProviderRegistry。PositioningKind</code> ：<ul>
					<li><code>BEFORE</code>类型会将页面选项卡放在目标页面选项卡之前的空中编辑器中。例如，在<i>概述</i>之前使用调试页面：</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/customPageApi_debugPage_before.png">
		</p>
		<ul>
			<li>
				<ul>
					<li><code>AFTER</code>类型会将页面选项卡放在目标页面选项卡后面的播出编辑器中。例如，在<i>概述</i>之后的调试页面：</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/customPageApi_debugPage_after.png">
		</p>
		<ul>
			<li>
				<ul>
					<li><code>REPLACE</code>类型将通过页面选项卡替换aird编辑器中的目标页面选项卡。例如，使用调试页面替换默认页面<em>概述</em> ：</li>
				</ul>
			</li>
		</ul>
		<p>
			<img border="0" src="images/customPageApi_debugPage_replace.png">
		</p>
		<p>如果在定位页面时，通风编辑器中不存在用于定位自定义页面的ID标识的页面，则页面将添加到最左侧位置。</p>
		<h3 id="Buildingthecustompage">构建自定义页面</h3>
		<p>要构建自定义页面，您需要创建一个扩展<code>org.eclipse.sirius.ui.editor.api.pages.的类<code>org.eclipse.sirius.ui.editor.api.pages.AbstractSessionEditorPage</code>也扩展了<code>FormPage</code> 。
			<br>页面的UI创建部分由<code>FormPage</code>的方法处理，方法为<code>createFormContent(IManagedForm managedForm)</code>作为入口点。
			<br><code>AbstractSessionEditorPage</code>抽象类带来以下方法实现：</p>
		<ul>
			<li>
				<code>可选&lt;PageUpdateCommand&gt; pageChanged（boolean）</code>
			</li>
			<li>
				<code>可选&lt;PageUpdateCommand&gt; resourceSetChanged（ResourceSetChangeEvent）</code>
			</li>
			<li>
				<code>可选&lt;PositioningKind&gt; getPositioning（）</code>
			</li>
			<li>
				<code>可选&lt;String&gt; getLocationId（）</code>
			</li>
		</ul>
		<p>还有一个<code>NotificationFilter getFilterForPageRequesting()</code>方法，其默认行为可以被覆盖。
		</p>
		<h4 id="resourceSetChanged">resourceSetChanged</h4>
		<p>每当资源集事件发生在其会话的资源集上时，aird编辑器就会调用此方法。事件可以是关于播出文件或加载的资源或视点的更改。</p>
		<p>根据change事件调用时，您可以在内部刷新图形组件。您还可以使用构建器<code>PageUpdateCommandBuilder</code>返回编辑器需要执行的<code>PageUpdateCommand</code>列表以更新页面。例如：</p>
		<pre><code>return Optional.of（new PageUpdateCommandBuilder（）。removePage（）。build（））;</code></pre>
		<p>此构建器允许您构建拥有空中编辑器必须执行的命令。构建的命令可以执行以下命令中的一个或组合：</p>
		<ul>
			<li>REMOVE命令（ <code>PageUpdateCommandBuilder removePage()</code> ）：当空中编辑器执行此命令时，您的页面将从编辑器中删除。
			</li>
			<li>REORDER命令（ <code>PageUpdateCommandBuilder reorderPage(PositioningKind positioningKind, String targetPageId)</code> ）：当aird编辑器执行此命令时，您的页面将被放置在定义的位置。要了解有关定位的更多信息，请阅读<a href="#pagePositioning">页面定位</a>部分  
			</li>
			<li>RENAME命令<code>PageUpdateCommandBuilder renameTab(String newLabel)</code> ：当aird编辑器执行此命令时，拥有页面的编辑器选项卡将使用给定的命令更新其标签。
			</li>
		</ul>
		<p>如果构建的命令包含remove命令和重新排序，重命名或两个命令，则将执行remove命令但不执行其他命令。</p>
		<p>如果您不需要使用此功能，则必须返回<code>Optional.empty()</code> 。
		</p>
		<h4 id="pageChanged">pageChanged</h4>
		<p>当您的页面变得可见（即已选中）时，将使用true作为参数调用此方法。当选择除您之外的任何其他页面时，将调用false作为参数。</p>
		<p>当您知道最终用户看不到您的页面时，您可以使用该参数来避免对模型更改进行繁重的计算，并将其推迟到稍后，当它再次可见时（即，当调用pageChanged时为<code>true</code> ）。
		</p>
		<p>根据change事件调用时，您还可以在内部刷新图形组件。您还可以使用构建器<code>PageUpdateCommandBuilder</code>返回编辑器需要执行的<code>PageUpdateCommand</code>列表以更新页面。请参阅<a href="#resourceSetChanged">resourceSetChanged</a>部分以获取有关命令的详细信息。
		</p>
		<p>如果您只想在页面可见时应用页面更新，并且如果满足关于会话的某些条件，那么您有责任跟踪自上次选择页面以来调用<code>resourceSetChanged(ResourceSetChangeEvent)</code>以了解某些内容必须完成更新。
		</p>
		<p>如果您不需要使用此功能，则必须返回<code>Optional.empty()</code> 。
		</p>
		<h4 id="getFilterForPageRequesting">getFilterForPageRequesting</h4>
		<p>使用<code>AbstractSessionEditorPage</code>的默认实现定义的此方法允许阻止对您不想考虑的事件调用<code>AbstractSessionEditorPage.resourceSetChanged(ResourceSetChangeEvent)</code> ，因为您知道您的页面不会刷新这些事件。
		</p>
		<p>默认情况下，过滤器<code>org.eclipse.emf.transaction.NotificationFilter的。NOT_TOUCH</code> 。此过滤器确保在所有事件的通知未更改任何值时不会调用此过滤器。
		</p>
		<p>您可以覆盖此方法以提供自己的过滤器。</p>
		<h4 id="getPositioning">getPositioning</h4>
		<p>创建页面时将使用此方法将其放置在其他页面中。请参阅<a href="#pagePositioning">页面定位</a>部分，了解更多有关定位的工作原理。
		</p>
		<p>它定义了要实现的定位类型。</p>
		<p>如果您不想将页面相对于另一个页面定位，则可以返回<code>Optional.empty()</code> 。在这种情况下，您的页面将被添加到最左侧的位置（第一个位置）。
		</p>
		<h4 id="getLocationId">getLocationId</h4>
		<p>创建页面时将使用此方法将其放置在其他页面中。请参阅<a href="#pagePositioning">页面定位</a>部分，了解更多有关定位的工作原理。
		</p>
		<p>它定义了您的页面应该相对于其定位的页面ID。</p>
		<p>如果您不想将页面相对于另一个页面定位，则可以返回<code>Optional.empty()</code> 。在这种情况下，您的页面将被添加到最左侧的位置（第一个位置）。
		</p>
		<h3 id="BuildingthePageProvider">构建PageProvider</h3>
		<p>PageProvider的职责是：</p>
		<ul>
			<li>提供你想要的所有自定义页面Sirius。</li>
			<li>给出它提供的页面的id。</li>
		</ul>
		<p>要构建自定义页面，您需要创建一个扩展<code>org.eclipse.sirius.ui.editor.api.pages.的类<code>org.eclipse.sirius.ui.editor.api.pages.PageProvider</code> 。
			<br>这个抽象类带来了以下实现方法：</p>
		<ul>
			<li>
				<code>Map &lt;String，Supplier &lt;AbstractSessionEditorPage &gt;&gt; getPages（SessionEditor）</code>
			</li>
			<li>
				<code>NotificationFilter getFilterForPageRequesting（）</code>
			</li>
			<li>
				<code>boolean提供（String）</code>
			</li>
		</ul>
		<h4 id="getPages">GETPAGES</h4>
		<p>此方法返回扩展<code>AbstractSessionEditorPage</code>以初始化的所有自定义页面实例。
		</p>
		<p>此方法必须将页面ID的映射返回给其初始化页面新实例的供应商。</p>
		<p>例如，使用调试页面：</p>
		<pre><code>Map &lt;String，Supplier &lt;AbstractSessionEditorPage &gt;&gt; resultMap = new HashMap &lt;&gt;（）; resultMap.put（DebugPage。PAGE_ID，（） - &gt; {返回新的DebugPage（编辑器，DebugPage。PAGE_ID，DEBUG_PAGE_TITLE）; }）; return resultMap;</code></pre>
		<p>您可以使用给定参数来确定是否应该提供您的页面。您可以访问编辑器<code>org.eclipse.sirius.ui.editor.SessionEditor</code>询问您的提供商的页面。通过此参数，您可以使用方法<code>org.eclipse.sirius.ui.editor.访问其会话<code>org.eclipse.sirius.ui.editor.SessionEditor.getSession()</code> 。您还可以使用任何类似<code>PlatformUI</code>单例来了解您的页面是否应该立即创建。
		</p>
		<p>如果未验证显示可从会话计算的页面所需的条件，则不应返回此页面的新实例。</p>
		<p>在以下情况下调用该方法：</p>
		<ul>
			<li>播出的编辑器已创建。</li>
			<li>如果事件的所有通知未被方法<code>getFilterForPageRequesting</code>返回的过滤器过滤，则从编辑器会话的资源集中发生资源集事件。
			</li>
			<li>从提供程序注册表添加或删除<code>PageProvider</code> 。
			</li>
		</ul>
		<h4 id="getFilterForPageRequesting2">getFilterForPageRequesting</h4>
		<p>使用<code>PageProvider</code>的默认实现定义的此方法允许阻止对您不想考虑的事件调用<code>PageProvider.getPages(SessionEditor)</code> ，因为您知道不会满足显示页面的初始条件。
		</p>
		<p>默认情况下，过滤器<code>org.eclipse.emf.transaction.NotificationFilter的。NOT_TOUCH</code> 。此过滤器确保在事件未更改任何值时不会调用此过滤器。
		</p>
		<p>您可以覆盖此方法以提供自己的过滤器。</p>
		<h4 id="provides">提供</h4>
		<p>此方法告知您的提供程序是否可以创建给定id的页面实例作为参数。在计算页面位置时使用它。</p>
		<p>警告：如果您没有为您提供的页面的ID返回true，那么定位可能不是您所期望的。</p>
		<h3 id="Pagestatussynchronization">页面状态同步</h3>
		<p>只有在满足某些初始条件时，才能在编辑器的给定位置创建页面。这种机制涉及以下方法：</p>
		<ul>
			<li>
				<code>PageProvider.getPages（SessionEditor）</code>
			</li>
			<li>
				<code>AbstractSessionEditorPage.getPositioning（）</code>
			</li>
			<li>
				<code>AbstractSessionEditorPage.getLocationId（）</code>
			</li>
		</ul>
		<p>您还可以通过对会话的资源集事件做出反应来动态更改页面位置，甚至可以告诉编辑器删除不再有用的页面。这种机制涉及以下方法：</p>
		<ul>
			<li>
				<code>AbstractSessionEditorPage.resourceSetChanged（ResourceSetChangeEvent）</code>
			</li>
			<li>
				<code>AbstractSessionEditorPage.pageChanged（布尔）</code>
			</li>
		</ul>
		<p>所以我们有两个不同的机制允许页面定位，如果不小心可能会发生冲突。
			<br>例如，可以在验证条件A时动态删除<code>AbstractSessionEditorPage</code>页面。但是， <code>PageProvider</code>的页面创建初始条件也是A.在这种情况下，如果第一次验证A，则会创建页面。然后，如果第二次验证A，则将动态删除页面并再次创建。
		</p>
		<p>因此，为了避免冲突，页面位置和创建/移除必须在最具体的条件<code>PageProvider</code>并在较具体<code>AbstractSessionEditorPage</code>
		</p>
		<p>例如，如果在验证条件A和B时可以从<code>PageProvider</code>创建页面，则只有在<code>PageProvider</code>情况下才能动态删除此页面！A或！B已经过验证，但是如果另一个条件被验证为C或者不是！C。</p>
		<h3 id="RegisteringthePageProvider">注册PageProvider</h3>
		<p>当您提供自定义页面的PageProvider完成后，您必须将其注册到Sirius，以便可以在空中编辑器中显示您的页面。
			<br>您可以通过两种方式使用<code>PageRegistry</code>或扩展点来实现此<code>PageRegistry</code> 。
		</p>
		<h4 id="Programmaticregistering">程序化注册</h4>
		<p><code>PageRegistry</code>是包含空中编辑器使用的所有<code>PageProvider</code>的注册表。
			<br>要使用，您的提供商可以在此注册表中注册。
		</p>
		<p>您可以通过调用方法<code>org.eclipse.sirius.ui.editor.编程方式执行此操作<code>org.eclipse.sirius.ui.editor.SessionEditorPlugin.getPlugin().getPageRegistry().addPageProvider(parameter)</code>以页面提供程序的新实例作为参数。
		</p>
		<h4 id="Declarativeregistering">声明性注册</h4>
		<p>扩展点<code>org.eclipse.sirius.ui.editor.sessionEditorPageProvider</code>允许您定义在Sirius填充播出编辑页面时应考虑的页面提供程序的类：</p>
		<p>
			<img border="0" src="images/customPageApi_debugPage_extensionPoint.png">
		</p>
	</body>
</html><html id="2067.s3.1.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
      <link rel="stylesheet" type="text/css" href="../css/ot.css"></link>
      <link rel="stylesheet" type="text/css" href="../css/otjld.css"></link>
      <title>OT / J语言定义v1.3.1</title>
   </head>
   <body class="otdt" dir="ltr">
      <div id="content">
         <table class="nav">
            <tr>
               <td class="back"><a id="top"></a></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s3.2.html" rel="next">§3.2标注参数映射&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s3.html" rel="section">§3标注绑定</a></div>
         <div class="sect depth2" id="s3.1">
            <h2 class="sect">§3.1标注方法绑定<a class="img" href="s3.1.html" title="PermaLinkto§3.1Callout方法绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h2>
            <div class="syntaxlink"><a href="sA.html#sA.3.2" title="§A.3.2CalloutBinding" class="syntax">→语法§A.3.2</a></div>
            <p>角色类可以通过声明<strong>标注</strong>绑定来获取其任何（预期）方法的实现。
               		
            </p>
            <div class="subsect depth3" id="s3.1.a">
               <h4 class="subsect">（a） <span class="title">先决条件：类绑定</span><a class="img" href="s3.1.a.html" title="PermaLink到（a）先决条件：类绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>callout绑定要求封闭类是根据<a href="s2.1.html" title="§2.1播放了关系" class="sect">§2.1</a>绑定到基类的角色类。但是，如果角色涉及基类循环（参见<a href="s2.1.2.b.html" title="§2.1.2.(b) Cycles" class="sect">§2.1.2。（b）</a> ），则<a href="s2.1.2.b.html" title="§2.1.2。（b）周期" class="sect">不允许调用绑定</a> 。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.b">
               <h4 class="subsect">（b） <span class="title">定义</span><a class="img" href="s3.1.b.html" title="永久链接到（b）定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>callout绑定将抽象角色方法（“预期方法”）映射到具体的基本方法（“提供的方法”）。它可能出现在允许使用功能声明的任何位置的角色类中。它表示为</p>
               <div class="listing plain"><pre><i>expected_method_designator</i> <b>- &gt;</b> <i>provided_method_designator;</i></pre></div>
               <p>结果是，对角色方法的任何调用都将使用提供的基本方法转发到关联的基础对象。
                  			
               </p>
               <h5 class="listing">示例代码（标注）：</h5>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre><b>团队</b> <b>类</b>公司{</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">2</td>
                        <td><pre>  <b>公共</b> <b>类</b>员工<b>playyPy</b> Person {</pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">3</td>
                        <td><pre>    <b>abstract</b> String getIdentification（）;</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">4</td>
                        <td><pre>    <span class="comment">// callout绑定见下文...</span></pre></td>
                     </tr>
                     <tr class="line odd">
                        <td class="ln">五</td>
                        <td><pre>}</pre></td>
                     </tr>
                     <tr class="line even">
                        <td class="ln">6</td>
                        <td><pre>}</pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="subsect depth3" id="s3.1.c">
               <h4 class="subsect">（c） <span class="title">各种方法指示符</span><a class="img" href="s3.1.c.html" title="PermaLink to（c）各种方法指示符"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>方法指示符可以是方法名称</p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">4</td>
                        <td><pre>getIdentification <em>- &gt;</em> getName;</pre></td>
                     </tr>
                  </table>
               </div>
               <p><strong>或</strong>完整的方法签名，包括参数声明和返回类型声明，但不包括任何修饰符和声明的异常。
                  			
               </p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">4</td>
                        <td><pre>String getIdentification（） <em>- &gt;</em> String getName（）;</pre></td>
                     </tr>
                  </table>
               </div>
               <div class="codecomment">
                  <h5>功效：</h5>
                  <ul>
                     <li>第4行声明了角色方法<code>getIdentification()</code>的标注绑定，为第3行中定义的抽象方法提供了实现。
                     </li>
                     <li>结合第2行中的角色绑定，这具有以下效果：</li>
                     <li>对<code>Employee.getIdentification</code>任何调用都将转发给方法<code>Person.getName</code> 。
                     </li>
                  </ul>
               </div>
               <p>标注绑定的两端必须使用相同类型的指示符，即，具有和不具有签名的指示符可以不混合。
                  	    <br>每个方法指示符必须唯一地选择一个方法。如果方法指示符包含签名，则此签名必须与现有方法的签名完全匹配，即，不对此匹配应用隐式转换。如果涉及重载，则<em>必须</em>使用签名来消除歧义。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.d">
               <h4 class="subsect">（d） <span class="title">继承角色方法声明</span><a class="img" href="s3.1.d.html" title="PermaLink to（d）角色方法声明的继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>由callout绑定的role方法可以在与绑定相同的类中声明，也可以从超类或超级接口继承。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.e">
               <h4 class="subsect">（e） <span class="title">标注覆盖</span><a class="img" href="s3.1.e.html" title="永久链接到（e）标注覆盖"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果继承的角色方法是具体的，则关于此方法的callout绑定必须使用标记“ <code>=&gt;</code> ”而不是“ <code>-&gt;</code> ”，以声明此绑定覆盖现有实现。
                  	    <br>对抽象方法使用“ <code>=&gt;</code> ”运算符是一个错误。
                  		<br>callout-bind与绑定在同一个类中实现的方法也是一个错误（并且无论如何都没用）。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.f">
               <h4 class="subsect">（f） <span class="title">标注绑定的继承</span><a class="img" href="s3.1.f.html" title="PermaLink to（f）callout绑定的继承"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>Callout绑定沿着显式和隐式继承继承。可以使用“ <code>=&gt;</code> ”覆盖继承的标注绑定。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.g">
               <h4 class="subsect">（g） <span class="title">重复绑定</span><a class="img" href="s3.1.g.html" title="PermaLink到（g）重复绑定"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果角色类对同一角色方法具有多个标注绑定，则会出错。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.h">
               <h4 class="subsect">（h） <span class="title">宣布例外</span><a class="img" href="s3.1.h.html" title="PermaLink到（h）声明的例外"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果要由<strong>callout</strong>绑定的基本方法在其<code>throws</code>子句中声明未由相应的角色方法声明的任何异常，则会出错。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.i">
               <h4 class="subsect">（i） <span class="title">速记定义</span><a class="img" href="s3.1.i.html" title="PermaLink（i）速记定义"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>其方法指示符指定完整方法签名的callout绑定不需要现有的角色方法。如果没有找到与这种callout绑定的预期方法匹配的角色方法，则隐式生成新方法。如果绑定的基本方法是静态的，则新方法是静态的，并且它声明与绑定的基本方法相同的异常。
                  			
               </p>
               <p>速记标注可以选择声明<strong>可见性修饰符</strong> ，否则生成的方法将继承绑定基础方法的可见性修饰符。没有设置其他修饰符。如果标注覆盖了继承的方法或标注，则它不得降低继承的方法/标注的可见性。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.j">
               <h4 class="subsect">（j） <span class="title">推断标注</span><a class="img" href="s3.1.j.html" title="PermaLink到（j）推断的标注"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>如果非抽象角色类继承抽象方法，则编译器会尝试推断出用于实现抽象方法的标注绑定。同样，如果无法解析角色类中的自调用，编译器会尝试推断出一个callout来解析自调用。<br>推断搜索绑定基类中的方法，使其成为可能</p>
               <ol>
                  <li>两种方法都有相同的名称</li>
                  <li>两种方法都有相同数量的参数</li>
                  <li>abstract role方法的每个参数都直接与base方法的相应参数兼容，或者使用装箱/拆箱或降低。
                  </li>
               </ol>
               <p>从界面推断出的标注具有<code>public</code>可见性，从自我呼叫推断出的标注具有<code>private</code>可见性。
                  
               </p>
               <p>默认推断的标注绑定被禁用，即编译器必须将这些绑定报告为错误。但是，编译器应该允许配置报告以仅生成警告（可以使用<code>@SuppressWarnings("inferredcallout")</code>注释来抑制），或者完全忽略诊断。
                  			
               </p>
            </div>
            <div class="subsect depth3" id="s3.1.k">
               <h4 class="subsect">（k） <span class="title">标注通用方法</span><a class="img" href="s3.1.k.html" title="PermaLink to（k）Callout to generic method"><img src="../images/permalink.png" alt="" style="vertical-align:text-top;margin-left:5px"></a></h4>
               <p>在提到通用基本方法时</p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">1</td>
                        <td><pre>&lt;T&gt; T bm（T a）</pre></td>
                     </tr>
                  </table>
               </div>
               <p>标注绑定可以传播方法的通用性，如</p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">2</td>
                        <td><pre>&lt;T&gt; T rm（T a） <b>- &gt;</b> T bm（T a）;</pre></td>
                     </tr>
                  </table>
               </div>
               <p>或者它可以提供类型参数的有效替换，如</p>
               <div class="listing example frame">
                  <table class="listing">
                     <tr class="line odd">
                        <td class="ln">2</td>
                        <td><pre>String rm（String a） <b>- &gt;</b> String bm（String a）;</pre></td>
                     </tr>
                  </table>
               </div>
            </div>
            <p>callout绑定要么将实现附加到先前声明的方法，要么将转发方法添加到角色类<a href="#s3.1.i" title="§3.1.(i) Shorthand definition" class="sect">（</a>上面的<a href="#s3.1.i" title="§3.1。（i）速记定义" class="sect">§3.1。（i）</a> ）。除此实现外，callout-bound方法与常规方法没有区别。
               		
            </p>
            <p>当我们说，callout绑定定义<strong>转发</strong>这意味着控制被传递给基础对象。相反，通过<strong>委托</strong>语义控制<em>将</em>保留在角色对象中，从而从角色开始再次调度自调用。自己的标注绑定不支持委派。但是，结合使用callin绑定的方法覆盖（参见<a href="s4.html" title="§4Callin绑定" class="sect">§4</a> ），可以轻松实现委派的效果。
               		
            </p>
         </div>
         <table class="nav">
            <tr>
               <td class="back"></td>
               <td class="top"><a href="index.html" rel="contents">↑目录↑</a></td>
               <td class="next"><a href="s3.2.html" rel="next">§3.2标注参数映射&gt;&gt;</a></td>
            </tr>
         </table>
         <div class="breadcrumb"><a class="nav" href="s3.html" rel="section">§3标注绑定</a></div>
      </div>
      <div id="footer">
         <hr><a class="w3c img" href="http://jigsaw.w3.org/css-validator/check/referer" shape="rect"><img src="../images/valid-css2-blue.png" alt="有效的CSS！" height="31" width="88"></a><a class="w3c img" href="http://validator.w3.org/check?uri=referer" shape="rect"><img src="../images/valid-xhtml10-blue.png" alt="有效的XHTML 1.0严格" height="31" width="88"></a><address>©Stephan Herrmann，Christine Hundt，Marco Mosconi</address>OT / J版本1.3.1  - 最后修改时间：2013-05-28</div>
   </body>
</html><html id="2820.org_eclipse_help_toc.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>目录（TOC）</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">目录（TOC）</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.help.toc将此<p></p>
<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>用于注册单个插件的在线帮助文稿。

<p>每个提供帮助文件的插件通常应该执行以下操作：</p><ul>
<ul>
<li>创建TOC文件，描述帮助的内容和必要的主题交错。请参阅以下语法。</li>

<li>plugin.xml文件应该扩展<tt>org.eclipse.help.toc</tt>扩展点并指定TOC文件。</li>
</ul>
</ul>
<p>可选地，可以使用<code>index</code>元素预先建立和注册搜索索引，以便提高第一次搜索尝试的性能。每个插件只能注册一个索引 - 多个<code>index</code>元素将导致未定义的行为。</p><p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.toc">toc</a> | <a href="#e.tocProvider">tocProvider</a> | <a href="#e.index">index</a> | <a href="#e.tocIcon">tocIcon</a> | <a href="#e.placeholder">占位符</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.toc">toc</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST toc</p>
<p class="code SchemaDtdAttlist">文件CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">primary（true | false）“false”</p>
<p class="code SchemaDtdAttlist">extradir CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">类别CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过提供XML文件提供的toc贡献</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>file</b> - 包含此插件的联机帮助的目录或部分的TOC文件的名称。
<p>
<i><b>toc文件的配置标记：</b></i>
</p><p><tt>&lt;！ELEMENT toc（主题|锚点|链接）*&gt;</tt>
<br><tt>&lt;！ATTLIST toc link_to CDATA #IMPLIED&gt;</tt>
<br><tt>&lt;！ATTLIST toc标签CDATA #REQUIRED&gt;</tt>
<br><tt>&lt;！ATTLIST toc主题CDATA #IMPLIED&gt;</tt>
<br><tt>&lt;！ATTLIST toc排序CDATA #IMPLIED&gt;</tt>
<br><tt>&lt;！ATTLIST toc图标CDATA #IMPLIED&gt;</tt>
</p><p><tt>&lt;！ELEMENT主题（主题|锚点|链接）*&gt;</tt>
<br><tt>&lt;！ATTLIST主题标签CDATA #REQUIRED&gt;</tt>
<br><tt>&lt;！ATTLIST主题href CDATA #IMPLIED&gt;</tt>
<br><tt>&lt;！ATTLIST主题排序CDATA #IMPLIED&gt;</tt>
<br><tt>&lt;！ATTLIST主题图标CDATA #IMPLIED&gt;</tt>
</p><p><tt>&lt;！ELEMENT锚EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST锚ID ID #REQUIRED&gt;</tt>
</p><p><tt>&lt;！ELEMENT链接EMPTY&gt;</tt>
<br><tt>&lt;！ATTLIST链接tOC CDATA #REQUIRED&gt;</tt>
</p><p>通常，需要提供联机帮助的插件将定义自己的TOC文件。最后，帮助系统配置为作为某些操作启动，并且可以使用TOC文件的路径来执行此操作。
</p><p><b>主题元素</b>
</p><p>所有帮助主题元素都作为toc容器元素的一部分提供。它们可以具有分层结构，也可以列为平面列表。
</p><p>主题元素是目录结构的主力。topic元素有两种典型用法：</p><p>1。提供文档文件的链接 - 通常是HTML文件。
<br>2。充当其他toc的容器，无论是在同一个清单中还是在另一个清单中。
</p><p><b><i>1。主题为链接</i></b>
<br>最简单的主题用法是作为文档文件的链接。
</p><p><tt>&lt;topic label =“一些概念文件”href =“concepts / some_file.html”/&gt;</tt>
</p><p>href属性与清单文件所属的插件相关。如果需要访问另一个插件中的文件，可以使用该语法</p><p><tt>&lt;topic label =“另一个插件中的主题”href =“../ other.plugin.id/concepts/some_other_file.html”/&gt;</tt>
</p><p><b><i>2。作为容器的主题</i></b>
<br>主题的下一个最常见用途是将其用作其他toc的容器。容器主题本身也可以始终引用特定文件。
</p><p><tt>&lt;topic label =“集成开发环境”href =“concepts / ciover.htm”&gt;</tt>
<br><tt>&lt;topic label =“启动IDE”href =“concepts / blah.htm”/&gt;</tt>
<br><tt>...</tt>
<br><tt>&lt;/主题&gt;</tt>
</p><p>如果sort属性为true，则子主题将按字母顺序排序。</p><p>可选的icon属性允许使用org.eclipse.help.toc扩展名中&lt;tocIcon&gt;元素定义的不同图标。</p>
<p><b>链接元素</b>
</p><p>link元素允许链接另一个toc文件中定义的目录。来自toc属性中指定的toc文件的所有主题都将出现在内容列表中，就好像它们是直接定义而不是链接元素一样。要包含来自api.xml文件的toc，您可以编写</p><p><tt>&lt;topic label =“References”&gt;</tt>
<br><tt>...</tt>
<br><tt>&lt;link toc =“api.xml”/&gt;</tt>
<br><tt>...</tt>
<br><tt>&lt;/主题&gt;</tt>
</p><p><b>锚元素</b>
</p><p>anchor元素定义了一个点，允许将其他toc文件链接到此导航并进行扩展，而无需使用link元素并从此处引用其他toc文件。要允许在“ZZZ”文档后面插入更多主题的目录，您可以按如下方式定义锚点：</p><p><tt>...</tt>
<br><tt>&lt;topic label =“zzz”href =“zzz.html”/&gt;</tt>
<br><tt>&lt;anchor id =“moreapi”/&gt;</tt>
<br><tt>...</tt>
</p><p><b>toc元素</b>
</p><p>toc元素是一个目录，用于对此文件中定义的主题和其他元素进行分组。标签在向用户显示时标识用户的目录。</p><p>可选主题属性是描述TOC的主题文件的路径。</p>
<p>如果sort属性为true，则子主题将按字母顺序排序。</p><p>可选的icon属性允许使用org.eclipse.help.toc扩展名中&lt;tocIcon&gt;元素定义的不同图标。</p><p>可选的link_to属性允许将来自此文件的toc链接到导航层次结构中较高的另一个toc文件。link_to属性的值必须在另一个toc文件中指定一个锚点。要将myapi.xml中的toc链接到另一个插件中指定的api.xml文件，您将使用该语法</p><p><tt>&lt;toc link_to =“../ anotherPlugin / api.xml #moreapi”label =“我的工具API”/&gt;</tt>
<br><tt>...</tt>
<br><tt>&lt;toc /&gt;</tt>
</p><p>其中#name将toc文件名与锚标识符分开。
</p>
<p><b>过滤器</b>
</p><p><a href="../../guide/ua_dynamic_filters.htm">过滤器</a>可用于使TOC的某些部分成为条件。过滤器的一种可能用途是仅在安装特定插件时显示一组主题。
</p>
<br></li>
<li><b>primary</b> - 指定TOC文件是否是主目录，是否为主目录，或者不是主目录，是否要集成到另一个目录中。</li>
<li><b>extradir</b> - 指定包含与目录关联的其他文档的目录的插件相对路径。即使文档不在目录中，也可以通过文档搜索索引和访问此目录中的所有帮助文档以及所有子目录。注意：目录必须在声明插件中（例如“../my.other.plugin/path”无效）</li>
<li><b>category</b> - 指定此TOC所属的TOC类别。这仅适用于主要TOC。类别用于将相关书籍组合在一起。该值必须是唯一标识类别的字符串。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.tocProvider">tocProvider</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST tocProvider</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">（ <b>自3.3起</b> ）通过插入代码来实现toc贡献</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> -  toc提供程序的实现类。该类必须实现<samp>org.eclipse.help。AbstractTocProvider</samp>接口。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.index">索引</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST指数</p>
<p class="code SchemaDtdAttlist">路径CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">（ <b>自3.1起</b> ）一个可选元素，允许声明由此插件提供的文档创建的预构建搜索索引。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>path</b> - 预构建搜索索引的插件相对路径。路径引用的索引必须存在。丢失的索引将在日志文件中标记。请注意，每个区域设置必须具有不同的索引。如果插件为多个语言环境提供索引目录，则应使用标准Eclipse NLS查找附加语言环境。 （例如<code>index/</code> ， <code>nl/ja/JP/index/</code> ， <code>nl/en/US/index/</code>等）。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.tocIcon">tocIcon</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST tocIcon</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">openIcon CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">closedIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">leafIcon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">altText CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">（ <b>自3.5起</b> ）一个可选元素，允许为toc中的元素指定图标。一旦声明了tocIcon，就可以使用“icon”属性在topic或toc中指定它，例如&lt;toc label =“Sample Table of contents”topic =“html / toc.html”icon =“myicon”&gt;</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 此图标的唯一ID。通常，此id将包含声明它的插件的名称。</li>
<li><b>openIcon</b> - 用于已扩展其孩子的toc或主题的图标的路径。</li>
<li><b>closedIcon</b> - 用于已扩展其孩子的toc或主题的图标的路径。如果没有提供openIcon将被使用。</li>
<li><b>leafIcon</b> - 用于没有子项的toc或主题的图标的路径。如果没有提供，将使用openIcon。</li>
<li><b>altText</b> - 将在Web演示文稿中的img标记的“alt”属性中使用的文本。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.placeholder">占位符</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST占位符</p>
<p class="code SchemaDtdAttlist">插件CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">placeholderPage CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">占位符用于安装文档的产品，作为附加步骤。占位符指定一个帮助页面，如果打开了帮助并且未安装文档包，则该页面将显示给用户。通常，此帮助页面将包含有关如何安装文档的信息。每个占位符指定捆绑包或捆绑包列表以及如果未安装列表中的一个或多个捆绑包，将显示帮助页面</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>plugin</b> - 这是一个占位符的帮助插件的名称。</li>
<li><b>placeholderPage</b> - 未安装插件时显示的页面。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是使用<samp>toc</samp>扩展点的示例。

<p>（在文件<tt>plugin.xml中</tt> ）</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.help.toc”</span> <span class="code SchemaTag">&gt; &lt;toc file =</span> <span class="code SchemaCstring">“toc1.xml”</span> <span class="code SchemaTag">primary =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">/&gt; &lt;toc file =</span> <span class="code SchemaCstring">“toc2.xml”</span> <span class="code SchemaTag">primary =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">category =</span> <span class="code SchemaCstring">“myCategory”</span> <span class="code SchemaTag">/ &gt; &lt;toc file =</span> <span class="code SchemaCstring">“task.xml”</span> <span class="code SchemaTag">/&gt; &lt;toc file =</span> <span class="code SchemaCstring">“sample.xml”</span> <span class="code SchemaTag">extradir =</span> <span class="code SchemaCstring">“samples”</span> <span class="code SchemaTag">/&gt; &lt;index path =</span> <span class="code SchemaCstring">“index /”</span> <span class="code SchemaTag">/&gt; &lt;/ extension&gt;</span></pre>


<p>（在文件<tt>maindocs.xml中</tt> ）</p><blockquote><tt>&lt;toc label =“帮助系统示例”&gt;</tt>
<br><tt>&lt;topic label =“简介”href =“intro.html”/&gt;</tt>
<br><tt>&lt;topic label =“任务”&gt;</tt>
<br><tt>&lt;topic label =“创建项目”href =“tasks / task1.html”&gt;</tt>
<br><tt>&lt;topic label =“创建Web项目”href =“tasks / task11.html”/&gt;</tt>
<br><tt>&lt;topic label =“创建Java项目”href =“tasks / task12.html”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;link toc =“task.xml”/&gt;</tt>
<br><tt>&lt;topic label =“测试项目”href =“tasks / taskn.html”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;topic label =“Samples”&gt;</tt>
<br><tt>&lt;topic label =“创建Java项目”href =“samples / sample1.html”&gt;</tt>
<br><tt>&lt;topic label =“启动向导”href =“samples / sample11.html”/&gt;</tt>
<br><tt>&lt;topic label =“设置选项”href =“samples / sample12.html”/&gt;</tt>
<br><tt>&lt;topic label =“完成创建项目”href =“samples / sample13.html”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;anchor id =“samples”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;/ TOC&gt;</tt></blockquote>

<p><br>（在文件<tt>tasks.xml中</tt> ）</p><blockquote><tt>&lt;toc label =“建立项目”&gt;</tt>
<br><tt>&lt;topic label =“构建项目”href =“build / building.html”&gt;</tt>
<br><tt>&lt;topic label =“构建Web项目”href =“build / web.html”/&gt;</tt>
<br><tt>&lt;topic label =“构建Java项目”href =“build / java.html”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;/ TOC&gt;</tt></blockquote>

<p><br>（在文件<tt>samples.xml中</tt> ）</p><blockquote><tt>&lt;toc link_to =“maindocs.xml＃samples”label =“使用编译工具”&gt;</tt>
<br><tt>&lt;topic label =“编译工具示例”href =“compilesample / example.html”&gt;</tt>
<br><tt>&lt;topic label =“Step 1”href =“compilesample / step1.html”/&gt;</tt>
<br><tt>&lt;topic label =“Step 2”href =“compilesample / step2.html”/&gt;</tt>
<br><tt>&lt;topic label =“Step 3”href =“compilesample / step3.html”/&gt;</tt>
<br><tt>&lt;topic label =“Step 4”href =“compilesample / step4.html”/&gt;</tt>
<br><tt>&lt;/主题&gt;</tt>
<br><tt>&lt;/ TOC&gt;</tt></blockquote>


<p>假设存在更多以“samples”开头的路径的文档，它们将不会显示在导航树中，但可以使用搜索进行访问。这是由于<tt>plugin.xml</tt>文件中的元素<tt>&lt;toc file =“sample.xml”extradir =“samples”/&gt;中</tt>存在“extradir”属性。例如，搜索“创建Java项目”可能会返回文档“其他创建Java项目的方法”，其路径为<tt>samples / sample2.html。</tt>

</p><p>
<b><em>国际化</em></b>可以翻译TOC XML文件，并将生成的副本（带有翻译的标签）放在nl / &lt;language&gt; / &lt;country&gt;或nl / &lt;language&gt;目录中。&lt;language&gt;和&lt;country&gt;代表语言环境代码中使用的双字母语言和国家/地区代码。例如，繁体中文翻译应放在nl / zh / TW目录中。nl / &lt;language&gt; / &lt;country&gt;目录的优先级高于nl / &lt;language&gt;。只有在nl / &lt;language&gt; / &lt;country&gt;中找不到文件时，才会使用驻留在nl / &lt;language&gt;中的文件。最后将搜索插件的根目录。
</p><p>doc.zip中包含的文档可以通过创建doc.zip文件进行本地化，该文件包含文档的翻译版本，并将doc.zip放入<br>nl / &lt;language&gt; / &lt;country&gt;或nl / &lt;language&gt;目录。在默认为插件目录之前，帮助系统将查找此目录下的文件。
<br> 
</p>
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6><samp>org.eclipse.help的一个实现<samp>。如果使用<samp>tocProvider，</samp>则必须提供AbstractTocProvider</samp> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>Eclipse平台提供的帮助系统UI的默认实现完全支持此扩展点。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2000,2006 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="0962.ch05s01s02s01.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>5.1.2.1。�输入文字（通用组件）</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula Reference Manual"></link>
<link rel="up" href="ch05s01s02.html" title="5.1.2.�Actions that send keyboard interaction (key presses, text input)"></link>
<link rel="prev" href="ch05s01s02.html" title="5.1.2.�Actions that send keyboard interaction (key presses, text input)"></link>
<link rel="next" href="ch05s01s02s02.html" title="5.1.2.2.�Enter Text in Table Components"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">5.1.2.1。�输入文字（通用组件）</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch05s01s02.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">5.1.2。�发送键盘交互的动作（按键，文本输入）</th>
<td width="20%" align="right">� <a href="ch05s01s02s02.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula参考手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch05.html">操作</a></span> &gt; <span class="breadcrumb-link"><a href="ch05s01.html">可在大多数应用程序上使用的</a></span> <span class="breadcrumb-link"><a href="ch05.html">操作</a></span> &gt; <span class="breadcrumb-link"><a href="ch05s01s02.html">发送键盘交互的操作（按键，文本输入）</a></span> &gt; <span class="breadcrumb-node">输入文本（常规组件）</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="actionsThatSendKeyboardInteractionGeneral"></a> 5.1.2.1。�输入文字（通用组件）</h4></div></div></div>
<p><span class="emphasis"><em>在文本组件上输入文本</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作可将文本输入组件。
        </p></li>
<li class="listitem"><p>您要输入的文本作为参数提供。
        </p></li>
<li class="listitem">
<p>这通过以下方式实现：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>如果组件尚未准备好支持键盘输入，请单击该组件一次。
              </p></li>
<li class="listitem"><p>在当前光标位置输入文本。
              </p></li>
</ul></div>
<p>
        </p>
</li>
<li class="listitem"><p>要删除组件中已有的任何文本，请使用“ <span class="emphasis"><em>替换文本</em></span> ”操作。
        </p></li>
<li class="listitem"><p>要在上一个文本之前/之后输入文本，请参阅“ <span class="emphasis"><em>文本字段</em></span> ”组件中的“ <span class="emphasis"><em>在模式之前/之后插入文本</em></span> ”。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li></ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具箱中的组合框不支持此操作</strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>输入焦点所在的文本（在应用程序组件上）</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作可将文本输入到当前具有焦点的组件中。
        </p></li>
<li class="listitem"><p>您要输入的文本作为参数提供。
        </p></li>
<li class="listitem"><p>此操作与“ <span class="emphasis"><em>外部输入文本</em></span> ”之间的区别在于，此处检查击键到达组件的位置。
        </p></li>
<li class="listitem"><p>对支持的组件使用此操作，对外部对话框中的组件使用“ <span class="emphasis"><em>外部输入文本</em></span> ”操作，例如文件选择器。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li></ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>在HTML AUT中，此操作只能与字母数字字符一起使用。此外，如果焦点当前不在浏览器上，则此操作将不会成功。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>替换文字</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作替换文本字段中已有的任何文本。
        </p></li>
<li class="listitem"><p>您要输入的文本作为参数提供。
        </p></li>
<li class="listitem">
<p>这通过以下方式实现：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>选择组件中已有的任何文本。
              </p></li>
<li class="listitem"><p>输入您指定的文本。这有效地覆盖了组件中的先前文本。
              </p></li>
</ul></div>
<p>
        </p>
</li>
<li class="listitem"><p>这意味着组件中的任何先前文本都将被删除。
        </p></li>
<li class="listitem"><p>要在上一个文本之前/之后输入文本，请参阅“ <span class="emphasis"><em>文本字段</em></span> ”组件中的“ <span class="emphasis"><em>在模式之前/之后插入文本</em></span> ”。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li></ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>HTML工具箱中的组合框不支持此操作</strong></span></td>
</tr></tbody>
</table>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果在表上使用此操作，则文本将输入到当前选定的单元格中。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>按任意键</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>此操作允许您将键命令发送到应用程序。
        </p></li>
<li class="listitem"><p>这对于诸如�DELETE�，�ENTER�等操作非常有用。</p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s54.html" title="4.54。�修正键">修改键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s07.html" title="4.7。�基础密钥">基本密钥</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>在Swing下，此操作仅支持美国字符集。在SWT下，您可以在Windows下使用任何字符集，但Linux下的非美国字符存在一些问题。
  </strong></span></td>
</tr></tbody>
</table>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>在HTML中，在Firefox上，不能使用键�F5�和�ESCAPE�。
  </strong></span></td>
</tr></tbody>
</table>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>在Linux系统上工作的用户应该增加测试系统上的密钥重复延迟或完全删除它。否则，某些Linux系统可能会重复按键操作，这可能导致在测试执行期间产生不需要的操作。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>外部输入文本</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作将文本输入到不受支持的对话框中（例如文件选择器）。
        </p></li>
<li class="listitem"><p>可以将击键发送到这些对话框，但不能检查它们是否已到达。
        </p></li>
<li class="listitem"><p>要使此操作起作用，对话框必须处于焦点，并且光标必须位于要填充的文本字段中。
        </p></li>
<li class="listitem"><p>将此操作与“外部键组合”操作结合使用，可将键组合发送到本机对话框，以便在测试期间使用文件选择器。</p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li></ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p>
    <span class="strong"><strong>SWT和RCP AUT中的原生对话框</strong></span>
  </p>
<p>在SWT和RCP AUT中，此操作只能输入ASCII字符（大小写字母和数字）。
  </p>
<p>要输入空格，句点和斜杠等字符，请使用<span class="emphasis"><em>外键组合操作</em></span> 。
  </p>
<p>我们建议使用复制到剪贴板操作来帮助填写SWT和RCP AUT中的本机对话框。然后，使用�CTRL+V�作为<span class="emphasis"><em>外部键组合</em></span>操作，可以简单地将<span class="emphasis"><em>复制到剪贴板</em></span>的字符串输入到对话框的文本字段中。
  </p>
<p><span class="emphasis"><em>外部按任意键</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作将组合键发送到不受支持的对话框（例如文件选择器）。
        </p></li>
<li class="listitem"><p>可以将击键发送到这些对话框，但无法检查它是否已到达。
        </p></li>
<li class="listitem"><p>要使此操作起作用，对话框必须处于焦点。
        </p></li>
<li class="listitem"><p>将此操作与“ <span class="emphasis"><em>外部输入文本</em></span> ”操作结合使用，以便在测试期间使用文件选择器。</p></li>
<li class="listitem"><p>您可能需要的一些击键包括<span class="emphasis"><em>ENTER，SPACE，PERIOD</em></span>和/。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s54.html" title="4.54。�修正键">修改键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s07.html" title="4.7。�基础密钥">基本密钥</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p><span class="emphasis"><em>设置切换键</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem">
<p>使用此操作可以打开或关闭以下键：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>大写锁定</p></li>
<li class="listitem"><p>数字键盘（的第一个键</p></li>
<li class="listitem"><p>滚动锁</p></li>
</ul></div>
<p>
        </p>
</li>
<li class="listitem"><p>您可以指定（de）激活哪个键以及是否应该打开或关闭该功能。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s40.html" title="4.40。关键">键</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s02.html" title="4.2。�激活密钥">激活密钥</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="102" height="89" src="../images/img1.jpg"></td>
<td class="topbotline"><span class="strong"><strong>由于当前的Java限制，在Linux下进行测试时不支持此操作。这意味着在Linux下进行测试时，包含此操作的任何测试步骤都将失败。
  </strong></span></td>
</tr></tbody>
</table>
<p><span class="emphasis"><em>在索引后插入文本</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作可将文本插入文本区域。
        </p></li>
<li class="listitem"><p>输入要插入的文本以及应插入的位置。
        </p></li>
<li class="listitem"><p>使用索引给出位置。
        </p></li>
<li class="listitem">
<p>这通过以下方式实现：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>将光标定位在您指定的索引处。
              </p></li>
<li class="listitem"><p>输入文字。
              </p></li>
</ul></div>
<p>
        </p>
</li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s37.html" title="4.37。指数">指数</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
<p><span class="emphasis"><em>在Pattern之前/之后插入文本</em></span></p>
<p>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc">
<li class="listitem"><p>使用此操作可将文本插入文本区域。
        </p></li>
<li class="listitem"><p>输入要插入的文本以及是否应在输入的模式之前或之后插入。
        </p></li>
<li class="listitem">
<p>这通过以下方式实现：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>将光标定位在您指定的位置。
              </p></li>
<li class="listitem"><p>输入文字。
              </p></li>
</ul></div>
<p>
        </p>
</li>
<li class="listitem"><p>如果未找到模式，则不插入文本。
        </p></li>
<li class="listitem">
<p>参数：</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle">
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s76.html" title="4.76。文本">文本</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s62.html" title="4.62。模式">图案</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s59.html" title="4.59。操作者">操作者</a>
              </p></li>
<li class="listitem"><p>
                <a class="xref" href="../parameters/ch04s39.html" title="4.39。�插入图案后">插入图案后</a>
              </p></li>
</ul></div>
<p>
        </p>
</li>
</ul></div>
<p>
  </p>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="1639.Developers-Guide.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Libhover开发人员指南</title>
		<link type="text/css" rel="stylesheet" href="../../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">Libhover开发人员指南</th>
			</tr>
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table><hr class="navigation-separator">
		<h2 id="Introduction">介绍</h2>
		<p>Linux Tools项目中的Libhover插件提供了一个通用接口，用于为库提供C和C ++悬停帮助。该插件使用CDT（C / C ++ Developer Tools）帮助扩展来向CDT注册自己。当在编辑器中显示C或C ++文件并发生悬停事件时，CDT将调用Libhover插件来获取信息。反过来，Libhover插件提供自己的扩展，允许最终用户指定一组有效的悬停使用。可以通过Project-&gt; Properties-&gt; C / C ++ General-&gt; Documentation页面为C / C ++项目启用或禁用每个悬停库。显示有效悬停的列表，用户可以根据需要检查或取消检查。请注意，Libhover帮助供应商设置悬停帮助的语言，因此C项目将忽略任何C ++悬停库。对于C ++项目，C和C ++库的悬停都是有效的，因此它们都将显示在“文档”页面上。</p>
		<h2 id="Libhover_Extension">Libhover扩展</h2>
		<p>Libhover插件添加了一个新的org.eclipse.linuxtools.cdt.libhover.library扩展，用于插件。让我们来看一个为glibc C库指定libhover帮助的例子：</p>
		<pre>&lt;extension id =“library”name =“Glibc C Library”point =“org.eclipse.linuxtools.cdt.libhover.library”&gt; &lt;library docs =“http://www.gnu.org/software/libc/manual /html_node/index.html“location =”./ data / glibc-2.7-2.libhover“name =”glibc library“type =”C“&gt; &lt;/ library&gt;; &lt;/扩展&gt;;</pre>
		<p>字段如下：</p>
		<ul>
			<li>id  - 此扩展的唯一ID（必填）<br> 
			</li>
			<li>name  - 扩展名（必填）</li>
			<li>图书馆 - 图书馆的详细信息（1个或更多）<ul>
					<li>docs  - 外部帮助文档的URL位置（可选）</li>
					<li>location  -  libhover二进制数据的位置（URL或插件的相对位置）（必需）</li>
					<li>name  - 将出现在此悬停帮助的C / C ++ Documentation页面中的名称（必需）</li>
					<li>type  - （C，C ++或ASM）之一（必需）</li>
				</ul>
			</li>
		</ul>
		<p>请注意，可以在声明扩展名的插件的本地指定位置。这显然节省了在悬停事件之前访问数据的时间。</p>
		<h2 id="Libhover_Data">Libhover数据</h2>
		<p>那么Libhover的数据是什么？Libhover数据仅仅是以二进制格式存储的Java序列化类。Java序列化允许用户在文件中保存和恢复类。Libhover类实际上是org.eclipse.linuxtools.cdt.libhover。LibhoverInfo：<br> 
		</p>
		<p>
			<br> 
		</p>
		<pre>公共类LibHoverInfo实现Serializable {private static final long serialVersionUID = 1L; public HashMap &lt;String，ClassInfo&gt; classes = new HashMap &lt;String，ClassInfo&gt;（）; public HashMap &lt;String，TypedefInfo&gt; typedefs = new HashMap &lt;String，TypedefInfo&gt;（）; public TreeMap &lt;String，FunctionInfo&gt; functions = new TreeMap &lt;String，FunctionInfo&gt;（）; }</pre>
		<p>
			<br>该类只是从名称到C ++类的映射集合，名称到C ++ typedef，名称到C函数。AC库悬停信息只会填写最后一张地图，而C ++库悬停信息通常只会填写前两张。
		</p>
		<h2 id="C_Library_Data">C图书馆数据</h2>
		<p>最简单的Libhover数据形式是C函数。看看org.eclipse.linuxtools.cdt.libhover。FunctionInfo：</p>
		<p>
			<br> 
		</p>
		<pre>public class FunctionInfo实现Serializable {private static final long serialVersionUID = 1L;私有字符串名称;私有字符串原型; private String desc; private String returnType; private ArrayList &lt;String&gt;标头; private ArrayList &lt;FunctionInfo&gt; children; }</pre>
		<p>
			<br>我们看到该类由String字段组成，其中包含将在悬停窗口中拼凑在一起的函数数据。原型不包括外括号。desc字段是函数的描述，可以被视为html格式。children字段用于将来支持C ++重载函数。这是因为我们在HashMap中按名称查找函数以使其快速引用。当函数名称重载（仅限C ++）时，我们会注册地图中找到的第一个函数，并使用children字段以无特定顺序存储所有其他函数。目前，Libhover查找机制不支持重载函数，但如果需要，可以添加此功能。所有字段都可以通过get和set方法访问（例如getName（），setDesc（））。
		</p>
		<h3 id="C_Library_Hover_Utility">C库悬停实用程序</h3>
		<p>
			<br>为了帮助构建C库悬停数据，已经创建了一个实用程序，它将采用xml并以带有后缀“.libhover”的文件形式创建libhover二进制数据。该实用程序位于org.eclipse.linuxtools.cdt.libhover插件中，位于org.eclipse.linuxtools.cdt.libhover.utils中。BuildFunctionInfos.java。将该文件作为Java应用程序运行（它具有静态main方法）并将两个参数传递给它：</p>
		<ol>
			<li>要解析的xml文件的URL或文件位置</li>
			<li>应该放置输出的位置</li>
		</ol>
		<p>完成后，您可以将.libhover文件放在插件中，并使用Libhover Library扩展指定本地位置。</p>
		<p>引用的XML文件必须遵循以下xml结构：</p>
		<pre>&lt;！DOCTYPE描述[&lt;！ELEMENT描述（构造）*&gt; &lt;！ELEMENT构造（结构|功能）*&gt; &lt;！ATTLIST构造id ID #REQUIRED类型CDATA #REQUIRED&gt; &lt;！ELEMENT结构（概要？，元素？）？&gt; &lt;！ELEMENT元素（元素*）&gt; &lt;！ELEMENT元素（概要*）&gt; &lt;！ATTLIST元素内容CDATA #REQUIRED&gt; &lt;！ELEMENT简介（#PCDATA）*&gt; &lt;！ELEMENT函数（原型，标题？，简介）&gt; &lt;！ATTLIST函数返回类型CDATA #REQUIRED&gt; &lt;！ELEMENT原型（参数+）？&gt; &lt;！ELEMENT参数（#PCDATA）*&gt; &lt;！ATTLIST参数内容CDATA #REQUIRED&gt; &lt;！ELEMENT标题（标题+）？&gt; &lt;！ELEMENT标题（#PCDATA）*&gt; &lt;！ATTLIST头文件名CDATA #REQUIRED&gt;]&gt;</pre>
		<p>请注意，函数ID需要以“function-”为前缀。例如，对于C atexit函数：</p>
		<pre>&lt;descript&gt; &lt;construct id =“function-atexit”type =“function”&gt; &lt;function returntype =“int”&gt; &lt;prototype&gt; &lt;parameter content =“void（* function）（void）”/&gt; &lt;/ prototype&gt; &lt; headers&gt; &lt;header filename =“stdlib.h”/&gt; &lt;/ headers&gt; &lt;synopsis&gt;＆lt; CODE＆gt; atexit＆lt; / CODE＆gt;函数注册函数＆lt; VAR＆gt;函数＆lt; / VAR＆gt;在正常程序终止时调用。＆lt; VAR＆gt;函数＆lt; / VAR＆gt;被调用时没有参数。＆LT峰; br＆GT;＆LT峰; br＆GT;来自＆lt; CODE＆gt; atexit＆lt; / CODE＆gt;的返回值如果函数无法注册，则成功为零，非零。&lt;/ synopsis&gt; &lt;/ function&gt; &lt;/ construct&gt; &lt;/ descriptions&gt;</pre>
		<p>另请注意，概要输出为html。要指定html标记，需要使用＆lt;和＆gt;作为分隔符代替“＆lt”和“＆gt”。在前面的示例中，VAR标记用于变量引用，CODE标记用于函数名称，br标记用于强制分段符。所有这些都使得悬停在显示时看起来更有趣。</p>
		<p>
			<br>对于glibc，编写了一个解析器来解析glibc / manual目录并处理texinfo文件以形成上面的xml文件格式。
		</p>
		<h2 id="C.2B.2B_Library_Hover">C ++库Hover</h2>
		<p>C ++库悬停数据更复杂，因为不能仅通过名称访问成员。首先需要知道访问成员的类和调用的签名，因为成员名称可以重载。由于成员实际上可能属于调用中使用的给定类的基类，或者类可能是另一个类或模板实例的typedef，因此会出现其他复杂性。模板实例很棘手，因为参数化类型会发生替换。</p>
		<p>实用程序org.eclipse.linuxtools.cdt.libhover.libstdcxx。创建DoxygenCPPInfo以解析libstdc ++库的Doxygen文档输出。如果您可以使用相同的格式获取库文档，那么您需要做的就是使用该实用程序，传递两个参数：</p>
		<ol>
			<li>Doxygen xml输入的位置</li>
			<li>放置输出libhover数据文件的位置</li>
		</ol>
		<p>如果做不到这一点，您将需要创建自己的库悬停信息。让我们看一下org.eclipse.linuxtools.cdt.libhover中感兴趣的领域。的ClassInfo</p>
		<pre>公共类ClassInfo实现Serializable {private static final long serialVersionUID = 1L; private String templateParms []; private String className;私有字符串包括; private ArrayList &lt;ClassInfo&gt; baseClasses; private HashMap &lt;String，MemberInfo&gt; members; private ArrayList &lt;ClassInfo&gt; children; }</pre>
		<p>以下描述了每个字段：</p>
		<ul>
			<li>templateParms  - 用于存储此类的模板参数（例如，A &lt;_T，_U，Integer&gt;将存储“_T”和“_U”。真实类型不属于此列表。这些是在描述文本中执行替换所需的（例如，可以将成员函数的返回值指定为模板参数）。</li>
			<li>className  - 这是包含模板规范的类的名称。templateParms中的任何模板参数都替换为通用正则表达式“[a-zA-Z0-9 _：*] +”，这允许我们在模板上进行快速正则表达式匹配（例如A &lt;Integer，Double&gt;将匹配A &lt;_T ，_U&gt;。</li>
			<li>include  - 这是包含此类的头文件的名称</li>
			<li>baseClasses  - 此类的任何基类的ClassInfo数据</li>
			<li>成员 - 将成员名称映射到MemberInfo（当存在重载时，每个名称只有1个与MemberInfo链接）。</li>
			<li>children  - 这是与此类同名的模板类集</li>
		</ul>
		<p>请注意，用于散列LibhoverInfo类映射中的ClassInfo的名称是类名减去任何模板规范。</p>
		<p>TypedefInfo只是一种查找我们正在寻找的实际类的方法：</p>
		<pre>公共类TypedefInfo实现Serializable {private static final long serialVersionUID = 1L; private String [] templates; private String typedefName; private String transformedType; private ArrayList &lt;TypedefInfo&gt; children = null; };</pre>
		<ul>
			<li>typedefName  -  typedef的名称，其中任何模板参数都替换为通用正则表达式字符串“[a-zA-Z0-9 _：*] +”</li>
			<li>templates  - 这是转换后的类名称中的模板参数集</li>
			<li>transformedType  -  typedef转换为的内容</li>
			<li>children  - 当存在多个同名的typedef时使用（例如，部分模板）</li>
		</ul>
		<p>假设typedef将使用与它所代表的类相同的模板参数。例如，如果我们有A &lt;_T，_U&gt;类，我们可以有一个typedef B &lt;_T&gt;，它转换为A &lt;_T，Integer&gt;。</p>
		<p>MemberInfo类与FunctionInfo类非常相似：</p>
		<pre>public class MemberInfo实现Serializable {private static final long serialVersionUID = 1L;私有字符串名称;私有字符串原型; private String desc; private String returnType; private String [] paramTypes; private ArrayList &lt;MemberInfo&gt; children; };</pre>
		<p>并包含感兴趣的实际悬停数据。以下是感兴趣的领域：</p>
		<ul>
			<li>名称 - 成员名称</li>
			<li>原型 - 原型减去外括号</li>
			<li>desc  -  html格式的成员描述</li>
			<li>returnType  - 成员函数的返回类型</li>
			<li>paramTypes  - 只有这个函数的参数类型的数组，没有模板替换。该数组与模板类型结合使用以验证我们是否使用了正确的成员（例如A &lt;_T的_（_T，_ U），_ U&gt;是A &lt;Integer的（整数k，双L）的匹配，双&gt;类）。</li>
			<li>children  - 与此名称相同的成员（即重载方法签名）</li>
		</ul>
		<h2 id="Devhelp_Library_Hover">Devhelp图书馆哈弗</h2>
		<p>org.eclipse.linuxtools.cdt.libhover.devhelp插件添加了对动态处理已格式化以供devhelp API浏览器使用的已安装文档的支持。</p>
		<p>文档由gtk-doc生成，可以是C代码中特殊格式的注释，也可以是gtk-doc解析头文件后创建的模板文件。从这些文件中，gtk-doc创建一个Docbook xml文件或sgml文件，可用于创建html。各种软件包使用安装在公共区域的文档形式，供devhelp API浏览器查找。</p>
		<p>Devhelp libhover插件在Libhover-&gt; devhelp下提供了一个新的首选项页面</p>
		<p>提供了一个文本条目，用于指定在当前系统上安装devhelp文档的位置（默认为/ usr / share / gtk-doc）。提供了一个附加按钮来启动devhelp libhover文档的生成（或重新生成）。按下按钮可启动可以放入后台或取消的Eclipse作业。</p>
		<p>作业的结果替换当前加载的当前devhelp libhover二进制数据。</p>
		<p>要以可以使用的格式创建文档，请参阅<a href="http://library.gnome.org/devel/gtk-doc-manual/stable/">gtk-doc手册</a>
		</p>
		<h2 id="Libhover_Logic">Libhover逻辑</h2>
		<p>对于C hover，Libhover将获得要查找的C函数的名称以及已启用的C HelpBook列表。这些HelpBook对应于已启用且由Libhover插件注册的Project-&gt; Properties-&gt; C / C ++ General-&gt; Documentation项目（这些项目对应于Libhover Library扩展包含的“C”类型库悬停信息） 。对于列表中的每个C库信息，Libhover会在FunctionInfo映射中查找名称。如果找到任何FunctionInfo，它将转换为所需的CDT格式。否则，返回null。</p>
		<p>对于C ++，它更复杂。CDT在编辑器中提供悬停所针对的位置。由此，Libhover查询CDT索引器以获取悬停的上下文，其中包括类名和成员签名。获取后，Libhover首先在TypdefInfo映射中查找类名。如果找到它并且这不是模板化的typedef，则转换后的名称将用作类名。对于模板，将逐个检查TypedefInfo及其所有子项，以获取typedef名称与给定typedef的正则表达式匹配。请记住，对于模板参数，我们在typedef名称中替换了通用的正则表达式字符串。</p>
		<p>现在我们有了一个班级名称。我们使用该类名来访问ClassInfo映射。如果我们不匹配，我们返回null。否则，我们可能必须解析模板，因此我们执行类名与正在讨论的类名的正则表达式匹配，我们再次使用通用正则表达式字符串替换模板参数。如果不匹配，我们返回null。</p>
		<p>现在我们有一个ClassInfo，只需找到有问题的成员。我们首先搜索ClassInfo的直接成员，如果需要，然后我们开始查看基类。我们首先按名称访问MemberInfo映射。如果我们匹配，我们需要检查MemberInfo是否有子节点，指示重载。如果发生了重载，我们需要检查每个成员的参数类型和返回类型以找到匹配项。如果我们被迫查看基类，则应用相同的检查。假设基类本身不是typedef。如果将来需要修改它，那么baseClasses列表将是String类型，然后必须执行新的转换。</p>
		<p>找到正确的MemberInfo后，详细信息将用于提供CDT悬停信息。在原型，返回类型和成员函数的名称中替换任何模板参数。目前，这种替换不是在成员描述上执行的，尽管如果需要可以简单地添加。</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Updating-This-Document.html" title="更新本文档">
						<img alt="下一个" border="0" src="../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%"></td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">更新本文档</td>
			</tr>
		</table>
	</body>
</html><html id="0628.DOT-User-Guide.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>GEF DOT用户指南</title>
		<link type="text/css" rel="stylesheet" href="../../book.css"></link>
	</head>
	<body dir="ltr">
		<p>
			<em>非wiki读者注意：本文档是从Eclipse wiki生成的 - 如果你有更正或补充，如果你在<a href="https://github.com/eclipse/gef/wiki/DOT" target="doc_external">原始的wiki页面中</a>添加它们会很棒</em> 。
		</p>
		<h3 id="introduction">介绍</h3>
		<p><a href="DOT.html">DOT</a>组件提供<a href="http://www.graphviz.org" target="doc_external">Graphviz DOT</a>创作环境，包括<em>DOT编辑器</em> ， <em>DOT图表视图</em> ， <em>DOT首选项页面</em>和<em>Sync Graphviz导出</em>切换按钮到Eclipse UI。 <em>DOT编辑器</em>可用于编辑<a href="https://graphviz.gitlab.io/_pages/doc/info/lang.html" target="doc_external">Graphviz * .dot文件</a> ，而<em>DOT Graph View</em>允许使用<a href="Zest.html">Zest</a>在Eclipse中渲染它们。 <em>Sync Graphviz Export</em>功能使用<a href="https://graphviz.gitlab.io/download/" target="doc_external">Graphviz本机可执行文件</a>将* .dot文件导出为不同的图像格式，例如* .pdf，* .png，* .svg ...等，可以在<em>DOT首选项页面</em>上配置。
		</p>
		<p>Graphviz DOT创作环境提供了一种简单的方法来可视化在Eclipse中运行的任何类型程序的* .dot文件输出（例如，可视化和调试内部数据结构，结果等）。如果Eclipse工作空间中的* .dot文件出现或更新，则<em>DOT图表视图</em>和图像导出也会自动显示/更新。
		</p><small>请注意，* DOT Editor *和* DOT Graph View *的[Zest]（Zest）渲染目前仍然仅限于支持DOT语言的一个子集（参见[＃454629]（https：// bugs.eclipse.org/bugs/show_bug.cgi?id=454629），[＃321775]（https://bugs.eclipse.org/bugs/show_bug.cgi?id=321775）和[＃441352]（https ：//bugs.eclipse.org/bugs/show_bug.cgi？id = 441352）详情）。</small>
		<h3 id="dot-editor">DOT编辑器</h3>
		<p>DOT编辑器是一个基于<a href="https://www.eclipse.org/Xtext/" target="doc_external">Xtext</a>的文本编辑器，为Eclipse工作台UI中的* .dot文件注册。它提供以下���支持以下功能：</p>
		<ol>
			<li>
				<strong>语法突出显示：</strong> <em>DOT编辑器</em>为不同的点语言元素使用不同的视觉样式（不同的颜色和字体）。关键字 - 例如'graph'，'digraph'，'subgraph'，'node'，'edge'等等。 - 以粗体表示，点属性名称显示为蓝色，其值显示为棕色（如果引用则显示为红色），而嵌入的单行/多行注释以绿色突出显示。这种文本修饰不仅可以更容易区分不同的点语言元素，还可以帮助用户在当前打开的点文件中找到可能的错误：缺少结束双引号或非正确关闭的多行注释。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_01_Syntax_Highlighting.png“DOT编辑器语法突出显示”）</code></pre>
		<ol>
			<li>
				<strong>内容助手 - 自动完成：</strong> <em>DOT编辑器</em>能够提供有关如何完成用户刚开始键入的语句/表达式的建议。可以使用键盘快捷键<code>CTRL + SPACE</code>在打开的点文件中的任何位置调用内容助手。根据当前光标位置，仅提供在给定上下文中有意义的那些语言元素：图形上下文中的图形属性名称，边缘上下文中的边缘属性名称以及特定属性上下文中的所有可能属性值。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_02_Content_Assistant.png“DOT编辑内容助手”）</code></pre>
		<ol>
			<li>
				<strong>模板建议：</strong> <em>DOT编辑器</em>能够通过单个内容助手操作一次性插入复杂模板。例如，“边缘模板”可用于插入定向/非定向边缘以及源节点和目标节点的相应占位符变量。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_03_Template_Proposals.png“DOT Editor Template Proposals”）</code></pre>
		<ol>
			<li>
				<strong>自动编辑：</strong> <em>DOT编辑器</em>通过自动插入/删除一些元素来帮助用户，例如当用户插入/删除开头的元素时插入/删除闭合元素：关闭双引号，右括号，右括号，关闭花括号。自动缩进功能可确保新行的缩进感知：在图形定义中按下<code>ENTER</code>键可以在后续新行中正确缩进光标。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_04_AutoEditing.png“DOT编辑器自动编辑”）</code></pre>
		<ol>
			<li>
				<strong>悬停：</strong> <em>DOT编辑器</em>能够在将<strong>鼠标</strong>悬停在某个元素上时提供其他信息。当用户例如在颜色值上移动鼠标时，将出现悬停弹出窗口，其中包含颜色预览，颜色方案，颜色名称和颜色代码信息。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_05_Hovering.png“DOT编辑器悬停”）</code></pre>
		<ol>
			<li>
				<strong>错误检查 - 背景验证：</strong> <em>DOT编辑器</em>在用户<em>编辑时</em>连续验证打开的点文件，即使文件尚未保存。当编辑器发出警告/错误时，例如，如果语言元素已弃用/无效，则会在黄色/红色中突出显示包含警告/错误的相应部分。它还会在编辑器的左侧和右侧放置一些警告/错误标记以及有意义的消息，并使用所有已识别的问题填充“问题视图”。通过这种支持，用户可以容易地识别需要修复的点文件的部分。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_06_Error_Checking.png“DOT编辑器错误检查”）</code></pre>
		<ol>
			<li>
				<strong>快速修复<em>：DOT</em></strong>的<em>编辑器</em>是能够自动修复，同时编辑一个文件点用户提出的问题，某些情况下。在这种情况下，编辑器向用户提供所谓的快速修正。此功能可通过警告/错误标记或在编辑器或相应的“问题视图”条目中使用键盘快捷键<code>CTRL + 1</code> 。应用这样的quickfix可以例如用有效的点属性值替换无效的点属性值。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_07_Quickfixes.png“DOT编辑器快速修正”）</code></pre>
		<ol>
			<li>
				<strong>格式化：</strong> <em>DOT编辑器</em>能够格式化（也称为漂亮打印）打开的点文件的内容。可以通过编辑器的<code>Source -&gt; Format</code>上下文菜单或通过键盘快捷键<code>CTRL + SHIFT + F</code>调用格式化程序。它会自动更正缩进，插入/删除空格/换行符，而不会更改基础语义模型。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_08_Formatting.png“DOT编辑器格式”）</code></pre>
		<ol>
			<li>
				<strong>大纲视图：</strong> <em>DOT编辑器</em>提供当前打开的点文件的主要组件的分层概述。默认情况下，“大纲视图”以点文件中定义的顺序表示图形节点和边以及它们的属性，但允许用户按字母顺序对元素进行排序。此外，它还可以帮助用户快速从Outline视图中的元素跳转到编辑器中的相应元素。通过切换“使用编辑器链接”模式将“大纲视图”选项与编辑器选择同步时，“大纲视图”中元素的选择会自动在编辑器中选择相应的文本元素（反之亦然）。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_09_Outline_View.png“DOT编辑器大纲视图”）</code></pre>
		<ol>
			<li>
				<strong>快速大纲视图：</strong> <em>DOT编辑器</em>还提供快速大纲视图。<code>CTRL + O</code>键盘快捷键在弹出窗口中打开“大纲视图”。快速大纲视图还支持使用通配符符号（如*或CamelCase搜索）搜索元素。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_10_Quick_Outline_View.png“DOT编辑器快速大纲视图”）</code></pre>
		<ol>
			<li>
				<strong>折叠：</strong> <em>DOT编辑器</em>支持折叠当前打开的点文件的某些部分。此功能对于大点文件隐藏不必要的细节（例如属于特定边缘的属性）尤其方便。将鼠标悬停在折叠部分上仍然可以让用户在不明确展开隐藏部分的情况下查看隐藏部分。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_11_Folding.png“DOT编辑器折叠”）</code></pre>
		<ol>
			<li>
				<strong>超链接导航：</strong> <em>DOT编辑器</em>为点语言元素提供超链接支持。它可以在点文件中的引用之间导航。您可以<code>CTRL + click</code>或<code>CTRL + click</code> <code>F3</code>例如在边缘的源/目标节点上直接跳转到相应的节点定义。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_12_Hyperlink_Navigation.png“DOT编辑器超链接导航”）</code></pre>
		<ol>
			<li>
				<strong>标记出现：</strong> <em>DOT编辑器</em>能够突出显示打开的点文件中某个元素的所有出现。一旦用户在启用“切换标记出现次数”按钮时通过双击选择文本编辑器中的元素，所有出现的内容都会在编辑器右侧用相应的标记突出显示。该功能例如用于突出显示引用某个节点的所有边缘。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_13_Marking_Occurrences.png“DOT编辑器标记出现次数”）</code></pre>
		<ol>
			<li>
				<strong>查找引用：</strong> <em>DOT编辑器</em>能够在整个工作空间中找到引用某个元素的所有引用。在所选元素上调用“查找引用”上下文菜单会列出“搜索视图”中的所有引用。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_14_Find_References.png“DOT编辑器查找参考”）</code></pre>
		<ol>
			<li>
				<strong>重命名重构：</strong> <em>DOT编辑器</em>还提供点语言元素的重命名重构支持。在所选元素上调用“重命名元素”上下文菜单或使用键盘快捷键<code>ALT + SHIFT + R</code>触发就地链接编辑包含验证和预览。执行的动作甚至跨语言/文件边界将所选元素（例如，节点）与所有引用（例如，在边缘中）重命名。通过<code>Edit -&gt; Undo Rename Element</code>子菜单或使用键盘快捷键<code>CTRL + Z</code> ，“重命名元素”操作甚至可以撤消。</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_15_Rename_Refactoring.png“DOT编辑器重命名重构”）</code></pre>
		<ol>
			<li>
				<strong>添加/切换注释：</strong> <em>DOT编辑器</em>在点文件中的任何位置接受单行（以//符号开头）和多行（由/ * * /符号包围）注释。用户甚至可以使用切换注释键盘快捷键<code>CTRL + /</code>来注释/取消注释编辑器中的当前行/当前选定的行。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_16_Adding_Toggling_Comments.png“DOT编辑器添加/切换注释”）</code></pre>
		<ol>
			<li>
				<strong>TODO / FIXME / XXX语句：</strong> <em>DOT编辑器</em>能够在注释中识别特殊标签（例如TODO，FIXME，XXX）。它在编辑器的左侧和右侧放置相应的标记符号，并使用所有已识别的标记填充“任务视图”。此功能可帮助用户在点文件中标记需要更多关注的位置。“TODO”标签通常标记以后的工作，后期修订或以后的重新考虑。'FIXME'标签通常放在一段伪造，破损并需要返工的代码附近。'XXX'标签通常会标记出虚假但有效的内容。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_17_TODO_FIXME_XXX_statements.png“DOT编辑器TODO / FIXME / XXX语句”）</code></pre>
		<ol>
			<li>
				<strong>首选项：</strong> <em>DOT编辑器</em>可以通过<code>Window -&gt; Preferences -&gt; Dot</code>首选项页面进行自定义。它们可以更改默认语法着色样式，以定义其他模板提议等。</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_18_Preferences.png“DOT编辑器首选项”）</code></pre>
		<ol>
			<li>
				<strong>与其他编辑器集成：</strong> <em>DOT编辑器</em>被注册为* .dot文件的默认编辑器，并在用户通过双击打开点文件时使用。但是，通过<code>Open With -&gt; Other</code>上下文菜单，可以使用'Sample Ecore Model Editor'，'Sample Reflective Ecore Model Editor'，...等打开* .dot文件。检查文本点文件的内存中树结构表示（抽象语法树 -  AST）。甚至可以将所选编辑器指定为Eclipse Workbench UI中所有* .dot文件的默认编辑器。</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_19_Integration_with_other_editors.png“DOT编辑器与其他编辑器集成”）</code></pre>
		<ol>
			<li>
				<strong>同步Graphviz导出：</strong> <em>DOT编辑器</em>还通过工具栏中的切换按钮提供<em>Sync Graphviz导出</em>选项，如果启用，则自动将图像文件（.pdf，.png，.svg ...等）存储到目录中包含.dot文件，并使用关联的外部图像查看器（如果有）打开它。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_20_Sync_Graphviz_Export.png“DOT编辑器同步Graphviz导出”）</code></pre>
		<pre><code>导出依赖于执行本机Graphviz点二进制，可以在“Windows  - &gt;首选项 - &gt;点 - &gt; Graphviz”首选项页面下配置。</code></pre>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_20_Graphviz_Preference_Page.png“DOT Editor Graphviz Preference Page”）</code></pre>
		<ol>
			<li>
				<strong>可视化DOT图：</strong>可以通过<em>DOT编辑器</em>的<code>Show In -&gt; DOT Graph</code>上下文菜单打开<em>DOT图表视图</em> ，以显示包含的DOT图形定义。
			</li>
		</ol>
		<pre><code>！[]（images / dot-user-guide / DOT_Editor_21_Show_in_DOT_Graph_View.png“DOT编辑器在DOT图表视图中显示”）</code></pre>
		<h3 id="dot-graph-view">DOT图表视图</h3>
		<p><em>DOT图形视图</em> （ <code>Window -&gt; Show View -&gt; Other... -&gt; Visualization -&gt; DOT Graph</code> ）能够显示* .dot文件中包含的DOT图形，嵌入在其他文件中，或与.dot文件同步当前正在活动的<em>DOT编辑器中进行编辑</em> 。例如加载</p>
		<pre><code>/ * *示例Graphviz DOT图* / digraph {edge [dir = both] 1 2 [shape =钻石样式=填充fillcolor =“/ greys3 / 2”fontcolor =“blue”] 3 4 [shape = circle xlabel =“external节点标签“style =”bold，dashed“] 5 [shape = box label =”internal node label“] 1  - &gt; 2 [style = dashed headlabel =”head label“taillabel =”tail label“] 3  - &gt; 2 [ style = dotted，label =“edge label”] 2  - &gt; 4 [arrowtail = box] 4  - &gt; 5 [arrowhead = teeodot] 2  - &gt; 5 [arrowhead = vee，xlabel =“external edge label”]}</code></pre>
		<p>DOT图形定义到<em>DOT图形视图中的</em>结果可以是<strong>“本机模式”</strong>表示（当配置点可执行文件时，它用于布局），或者在<strong>“模拟模式”</strong>表示中（当未配置点可执行文件时，使用类似的<a href="Layout.html">布局</a>算法模拟<a href="Layout.html">布局</a> 。
		</p>
		<p>
			<img alt="" title="DOT图表视图原生/模拟" border="0" src="images/dot-user-guide/DOT_Graph_View_01_native_emulated.png">
		</p>
		<p>当用户保存当前修改的点文件时， <em>DOT编辑器</em>还能够自动通知<em>DOT图表视图</em> 。使用“使用DOT编辑器链接”功能，无需手动触发图形可视化，即可在<em>DOT图表视图中</em>重新渲染当前编辑的点文件。
		</p>
		<p>
			<img alt="" title="使用DOT编辑器进行DOT图表视图链接" border="0" src="images/dot-user-guide/DOT_Graph_View_02_Link_with_DOT_Editor.png">
		</p>
		<p><em>DOT图表视图</em>甚至可以用于可视化嵌入在其他文件中的DOT图形定义。这些文件可以通过'Load * .dot文件（或带有嵌入式DOT的文件）'工具栏按钮加载到<em>DOT图表视图中</em> ，例如，可以<a href="http://fsteeg.wordpress.com/2010/01/07/visual-textual-documentation-with-dot-and-zest-in-eclipse/" target="doc_external">在源代码注释</a>或<a href="http://fsteeg.wordpress.com/2010/02/07/diagrams-in-wiki-markup-with-mylyn-wikitext-dot-and-zest/" target="doc_external">wiki标记中</a>显示DOT图形定义：</p>
		<p>
			<img alt="" title="DOT图表视图嵌入式点图" border="0" src="images/dot-user-guide/DOT_Graph_View_03_Embedded_Dot_graph.png">
		</p>
	</body>
</html><html id="1778.propertyaccessors.html" dir="ltr"></html><html lang="en-us" dir="ltr" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<meta name="DC.Type" content="reference"></meta>
<meta name="DC.Title" content="Property Accessors"></meta>
<meta name="abstract" content=""></meta>
<meta name="description" content=""></meta>
<meta name="DC.Relation" scheme="URI" content="../reference/oqlsyntax.html"></meta>
<meta name="copyright" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Rights.Owner" type="primary" content="Copyright (c) 2008, 2010 SAP AG and others. All rights reserved. This program and the accompanying materials are made available under the terms of the Eclipse Public License v1.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v10.html "></meta>
<meta name="DC.Format" content="XHTML"></meta>
<meta name="DC.Identifier" content="propertyaccessors"></meta>
<meta name="DC.Language" content="en-us"></meta>
<link rel="stylesheet" type="text/css" href="../styles/commonltr.css"></link>
<title>物业配件</title>
</head>
<body id="propertyaccessors" dir="ltr">


	<h1 class="title topictitle1">物业配件</h1>

	
	

	<div class="body refbody"><p class="shortdesc"></p>

		<div class="section"><h2 class="title sectiontitle">访问堆对象的字段</h2>
			
			<p class="p">使用简单的点表示法访问堆对象的属性：</p>

			<p class="p">[&lt;别名&gt;。 ] &lt;field&gt;。 &lt;字段&gt;。&lt;字段&gt;</p>

			<p class="p">可以在<a class="xref" href="oqlsyntaxfrom.html">FROM子句中</a>定义<strong class="ph b">别名</strong> ，以标识当前对象，即SQL类比中的行，OQL语句在其上运行。如果没有别名，则假定该字段是当前对象的字段之一。
				<strong class="ph b">字段</strong>是堆转储中Java对象的属性。使用<a class="xref" href="tipsandtricks.html#oqlcompletion">OQL自动完成</a>或<span class="keyword cmdname">Object Inspector</span>查找<span class="keyword cmdname">对象</span>的可用字段。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">访问Java Bean属性</h2>
			
			<p class="p">[&lt;别名&gt;。 ] @ &lt;属性&gt; ...</p>

			<p class="p">使用@符号，OQL访问Memory Analyzer使用的底层Java对象的属性，以表示堆转储中的对象。通过Bean Introspection解析属性。使用<a class="xref" href="tipsandtricks.html#oqlcompletion">OQL自动完成</a>来查找公共bean名称。下表列出了一些常用的Java属性。
			</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__javabean_prop" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="22.22222222222222%">任何堆对象</td>

					<td valign="top" class="stentry" width="22.22222222222222%"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#method_summary">我反对</a></td>

					<td valign="top" class="stentry" width="22.22222222222222%">OBJECTID</td>

					<td valign="top" class="stentry" width="33.33333333333333%">快照对象的id</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">objectAddress</td>

					<td valign="top" class="stentry">快照对象的地址</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">类</td>

					<td valign="top" class="stentry">这个对象的Java类</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">clazz中</td>

					<td valign="top" class="stentry">这个对象的IClass。另请参见classof（object）。</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">usedHeapSize</td>

					<td valign="top" class="stentry">浅堆大小</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">retainedHeapSize</td>

					<td valign="top" class="stentry">保留堆大小</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">显示名称</td>

					<td valign="top" class="stentry">显示名称</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">类对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#method_summary">iCLASS非</a></td>

					<td valign="top" class="stentry">classLoaderId</td>

					<td valign="top" class="stentry">类加载器的id</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">任何数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IArray.html#method_summary">IArray</a></td>

					<td valign="top" class="stentry">长度</td>

					<td valign="top" class="stentry">数组的长度</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">原始数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#method_summary">IPrimitiveArray</a></td>

					<td valign="top" class="stentry">valueArray</td>

					<td valign="top" class="stentry">数组中的值</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">参考数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObjectArray.html#method_summary">IObjectArray</a></td>

					<td valign="top" class="stentry">referenceArray</td>

					<td valign="top" class="stentry">数组中的对象（作为长值，对象的地址）使用get（）访问特定元素并使用OBJECTS转换为对象。</td>

				</tr>
</table>

		</div>

		<div class="section"><h2 class="title sectiontitle">调用Java方法</h2>
			
			<pre class="pre codeblock">[&lt;别名&gt;。 ] @ &lt;method&gt;（[&lt;expression&gt;，&lt;expression&gt;]）...</pre>

			<p class="p">Adding（）强制OQL将其解释为Java方法调用。通过反射执行调用。下表列出了Memory Analyzer用于表示堆转储中的对象的底层Java对象的一些常见Java方法。
			</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__javabean_prop" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="22.22222222222222%">$ {}快照</td>

					<td valign="top" class="stentry" width="22.22222222222222%"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#method_summary">ISnapshot</a></td>

					<td valign="top" class="stentry" width="22.22222222222222%">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#getClasses()">getClasses（）</a></pre>

					</td>

					<td valign="top" class="stentry" width="33.33333333333333%">所有课程的集合</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/ISnapshot.html#getClassesByName(java.util.regex.Pattern, boolean)">getClassesByName（String name，boolean includeSubClasses）</a></pre>

					</td>

					<td valign="top" class="stentry">一组课程</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">类对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#method_summary">iCLASS非</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#hasSuperClass()">hasSuperClass（）</a></pre>

					</td>

					<td valign="top" class="stentry">如果类具有超类，则结果为true</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry"> </td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IClass.html#isArrayType()">isArrayType（）</a></pre>

					</td>

					<td valign="top" class="stentry">如果类是数组类型，则结果为true</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">任何堆对象</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#method_summary">我反对</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IObject.html#getObjectAddress()">getObjectAddress（）</a></pre>

					</td>

					<td valign="top" class="stentry">快照对象的地址为长整数</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">原始数组</td>

					<td valign="top" class="stentry"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#method_summary">IPrimitiveArray</a></td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock"><a class="xref" href="../../../ntopic/org.eclipse.mat.ui.help/doc/org/eclipse/mat/snapshot/model/IPrimitiveArray.html#getValueAt(int)">getValueAt（int index）</a></pre>

					</td>

					<td valign="top" class="stentry">数组中的值</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">Java原始数组，Java对象数组或Java列表（从反射返回）</td>

					<td valign="top" class="stentry">[]或列表</td>

					<td valign="top" class="stentry">
						<pre class="pre codeblock">get（int index）</pre>

					</td>

					<td valign="top" class="stentry">数组或列表中的值</td>

				</tr>
</table>

		</div>

		<div class="section"><h2 class="title sectiontitle">阵列访问</h2>
			
			<p class="p">Memory Analyzer 1.3或更高版本允许从快照直接访问数组样式和对象数组，以及从反射方法调用获得的Java数组和Java列表。符号是<samp class="ph codeph">[index]</samp> 。索引是从零开始的整数。如果数组为null或索引超出范围，则结果为null。
			</p>

			<p class="p">Memory Analyzer 1.4或更高版本允许使用符号<samp class="ph codeph">[index1：index2]</samp>进行数组范围访问，其中index1和index2包含在内。如果值为负，则将它们视为从数组末尾开始的索引，因此-1表示最后一个条目。这意味着整个数组可以作为<samp class="ph codeph">[0：-1]</samp>的列表进行访问。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从原始数组中读取值（来自堆转储）</h2>
			
			<pre class="pre codeblock">SELECT s [2] FROM int [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s.getValueAt（2）FROM int [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。这将从具有至少3个元素的所有int []数组中读取索引2处元素的值。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从对象数组中读取对象（来自堆转储）</h2>
			
			<pre class="pre codeblock">SELECT s [2] FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。
			<samp class="ph codeph">s [2]</samp>是一个IObject，因此可以访问字段和Java bean属性</p>

			<pre class="pre codeblock">SELECT OBJECTS s [2] FROM java.lang。对象[] s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。<span class="keyword">OBJECTS</span>转换对象以提供树视图而不是表结果。我们不需要<span class="keyword">WHERE</span>子句，因为超出范围的访问返回null并且<span class="keyword">OBJECTS</span>跳过空值。</p>

			<pre class="pre codeblock">SELECT OBJECTS s。@ referenceArray.get（2）FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.1或更高版本。这将读取所有Object []数组中索引2处的元素的长地址，该数组至少包含3个元素并将它们转换为对象。
			</p>

			<pre class="pre codeblock">SELECT OBJECTS s.getReferenceArray（2,1）FROM java.lang。Object [] s WHERE（s。@ length&gt; 2）</pre>

			<p class="p">此方法适用于Memory Analyzer 1.1或更高版本。它从所有Object []数组开始，从索引2开始读取long [] 1元素数组，这些数组至少包含3个元素，并将这些数组的内容转换为对象。
			</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从Java数组中读取（Memory Analyzer内部对象）</h2>
			
			<pre class="pre codeblock">SELECT s。@GCRoots [2] FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s.get（2）FROM OBJECTS $ {snapshot} s WHERE s。@ GCRoots。@ length&gt; 2</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">从Java列表中读取（Memory Analyzer内部对象）</h2>
			
			<pre class="pre codeblock">SELECT s。@ GCRoots.subList（1,3）[1] FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于Memory Analyzer 1.3或更高版本。</p>

			<pre class="pre codeblock">SELECT s。@ GCRoots.subList（1,3）.get（1）FROM OBJECTS $ {snapshot} s</pre>

			<p class="p">此方法适用于所有版本的Memory Analyzer。</p>

		</div>

		<div class="section"><h2 class="title sectiontitle">阅读子阵列</h2>
			
			<pre class="pre codeblock">SELECT s，s.count，s.offset，s.value [s.offset]，s.value [s.offset：（（s.offset + s.count） -  1）]，s.value [s.offset ：（（s.offset + 0） -  1）]，s.value [0：-1] .subList（s.offset，（s.offset + 0）），s.value [s.offset：-1] .subList（0，s.count）FROM java.lang。字符串</pre>

			<p class="p">此方法适用于Memory Analyzer 1.4或更高版本。</p>

			<p class="p">这显示了如何使用<samp class="ph codeph">[0：-1]</samp>将整个数组转换为列表，以及如何使用数组范围<samp class="ph codeph">[offset：offset + count-1]</samp>在<samp class="ph codeph">offset = 0</samp>和<samp class="ph codeph">count = 0</samp>时使用意外结果而不是空列表它给出了整个数组。一旦整个数组转换为列表<samp class="ph codeph">，</samp>使用<samp class="ph codeph">subList（offset，offet + count）</samp>将得到预期的结果。
			</p>

		</div>

		<div class="section"><!--no heading--><h2 class="title sectiontitle">
		</h2>
		
		</div>

		<div class="section"><h2 class="title sectiontitle">内置OQL功能</h2>
			
			<pre class="pre codeblock">&lt;function&gt;（&lt;parameter&gt;）</pre>

			<p class="p">内置功能。</p>

			<table cellpadding="4" cellspacing="0" id="propertyaccessors__oql_functions" border="1" class="simpletable" summary=""><tr class="strow">
					<td valign="top" class="stentry" width="40%">
						<pre class="pre codeblock">toHex（数字）</pre>

					</td>

					<td valign="top" class="stentry" width="60%">将数字打印为十六进制</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">toString（对象）</pre>

					</td>

					<td valign="top" class="stentry">返回对象的值，例如String的内容等。</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">支配者（对象）</pre>

					</td>

					<td valign="top" class="stentry">物体立即由物体支配</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">outbounds（对象）</pre>

					</td>

					<td valign="top" class="stentry">出境推荐人</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">inbounds（对象）</pre>

					</td>

					<td valign="top" class="stentry">入境推荐人</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">classof（对象）</pre>

					</td>

					<td valign="top" class="stentry">当前对象的类</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">支配者（对象）</pre>

					</td>

					<td valign="top" class="stentry">直接支配者，如果没有，则为-1</td>

				</tr>
<tr class="strow">
					<td valign="top" class="stentry">
						<pre class="pre codeblock">eval（表达式）</pre>

					</td>

					<td valign="top" class="stentry">（Memory Analyzer 1.4或更高版本中的实验）评估参数并返回它。允许数组/方法访问子选择或表达式的结果可能很有用。
					</td>

				</tr>
</table>


		</div>

	</div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a class="link" href="../reference/oqlsyntax.html">OQL语法</a></div>
</div>
</div>

</body>
</html><html id="1714.SystemTap-Graphing.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>SystemTap用户指南 -  SystemTap图形</title>
		<link type="text/css" rel="stylesheet" href="../../../book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">SystemTap图形</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="SystemTap-IDE.html" title="SystemTap IDE">
						<img alt="以前" border="0" src="../../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="Copyright-Information.html" title="版权信息">
						<img alt="下一个" border="0" src="../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">SystemTap IDE</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">版权信息</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="SystemTap_Graphing">SystemTap图形</h1>
		<h2 id="Getting_Started_2">入门</h2>
		<h3 id="Introduction">介绍</h3>
		<p>在使用<b>图形</b>运行配置下启动SystemTap脚本时，启用<b>此脚本运行</b>选项<b>的输出，</b>可以以图形形式绘制其输出。（如果您不熟悉如何加载或编写SystemTap脚本，请查看SystemTap IDE用户指南中的<a href="SystemTap-IDE.html#IDE_Tutorial">IDE教程</a> 。）有多种图形类型可用于绘制SystemTap脚本的输出：</p>
		<ul>
			<li>
				<a href="#Scatter_Graph">散点图</a>
			</li>
			<li>
				<a href="#Line_Graph">线形图</a>
			</li>
			<li>
				<a href="#Area_Graph">面积图</a>
			</li>
			<li>
				<a href="#Bar_Graph">条状图</a>
			</li>
			<li>
				<a href="#Pie_Graph">饼图</a>
			</li>
		</ul>
		<p>只要脚本运行，就可以通过在脚本的运行配置中创建脚本，或者在使用脚本运行脚本运行后实例化这些图表类型。 <img border="0" src="images/New_wiz.gif">在图形选择器视图中<a href="#Create_Graph_Wizard">创建图形</a>向导。有关如何使用“运行配置”和正则表达式从脚本输出中捕获数据以及如何在图形中绘制数据的信息，请参阅<a href="SystemTap-IDE.html#Lesson_3:_Running_Your_Script">第3课：运行脚本</a> 。
		</p>
		<h3 id="Graphing_Tutorial">图形教程</h3>
		<p>本教程从<a href="SystemTap-IDE.html#Lesson_3:_Running_Your_Script">第3课：运行脚本的</a>位置开始，提供了有关图形配置的更多信息。如果您已经按照该教程进行操作，请单击<b>“运行方式” - &gt;“运行配置...”，</b>然后查看先前创建的配置。如果没有，请立即关注该教程，并在完成后返回此处。
		</p>
		<p>在选择配置的情况下打开“运行配置”菜单后，单击“ <b>图形”</b>选项卡。在窗口的底部，标记为<b>Graph Set＃</b>的部分显示为当前选择的<b>正则表达式</b>创建的所有图形的列表（ <b>图形集＃中的＃</b>表示选择了哪个表达式）。还有一组与图形配置相关的按钮：</p>
		<ul>
			<li>
				<b>添加...</b> - 打开“ <a href="#Create_Graph_Wizard">创建图”</a>向导，以允许您创建新图。
			</li>
			<li>
				<b>重复</b> - 当选择条目列表中的一个图形（通过单击它）时，此按钮会创建该图形的副本。
			</li>
			<li>
				<b>编辑...</b> - 当选择条目列表中的某个图形时，此按钮允许您使用“ <a href="#Create_Graph_Wizard">编辑图形”</a>向导<a href="#Create_Graph_Wizard">编辑</a>该图形的设置。
			</li>
			<li>
				<b>删除</b> - 删除当前选定的图表。
			</li>
		</ul>
		<p>
			<b>注意：</b>您创建的每个正则表达式都有自己的图表集。创建和编辑图形时，“ <b>图形集＃”</b>部分中可见的唯一图形将是用于当前在“ <b>正则表达式”</b>组合框中选择的表达式的图形。
		</p>
		<h4 id="Create_Graph_Wizard">创建图表向导</h4>
		<p><b>创建图形</b> （或<b>编辑图形</b>向导）用于创建新图形或编辑现有图形。它允许您设置图形的所有属性，例如标题，图形类型和系列数据。
		</p>
		<ul>
			<li>
				<b>图表类型</b> - 要绘制的图表类型。有关可用<a href="#Data_Graph_Types">图表类型</a>的列表，请参阅<a href="#Data_Graph_Types">图表类型</a> ，以及每种图表类型的说明。
			</li>
			<li>
				<b>标题</b> - 图形选择器视图中显示时图形的标题。
			</li>
			<li>
				<b>X系列</b> - 将提供图形X系列数据的数据类。此数据可以来自正则表达式的一个捕获组（显示为用户定义的标题），或者，如果设置为<b>行号</b> ，则图形将为每个输出行/行绘制一个新数据点。与正则表达式匹配。
			</li>
			<li>
				<b>Y Series 0</b> - 将提供相对于X轴的图形Y系列数据的数据类。必须使用正则表达式中的捕获组。
			</li>
			<li>
				<b>Y系列1,2,3</b> ......  - 如果在正则表达式中包含多个捕获组，则可以选择为图形提供多个Y系列数据，每个数据都将相对于同一X系列绘制您之前指定的轴。它们将在图表上显示为一组单独的数据点，标题为标题。如果您不想包含任何额外的Y系列值，请选择<b>NA</b> 。</li>
		</ul>
		<p>请注意，两个不同的系列可能不共享相同的数据选择。</p>
		<h2 id="Concepts_2">概念</h2>
		<h3 id="Data_Table">数据表</h3>
		<p>数据表是在使用图表选项运行脚本时始终可用的视图。它最初开始为空并填充，因为它收到最初从脚本解析的控制台信息。数据表是每种其他图表类型产生的数据结构的可视化。</p>
		<p>
			<img border="0" src="images/SystemtapGraphDataView.png">
		</p>
		<p>只要<b>自动调整大小列</b>选项（在Preferences-&gt; SystemTap-&gt; Graphing-&gt; Data Table中）已被停用，就可以通过拖动列标题之间的分隔线随意调整数据表的列数。此外，可以<a href="#Importing_a_Data_Set">保存和加载</a>数据表中的信息，而无需重新运行脚本。此外，如果脚本的输出已保存到文件中，用户可以填充数据表而无需运行脚本;请参阅<a href="#Opening_Script_Output">打开脚本输出</a> 。右键单击数据表可提供包含以下选项的菜单：</p>
		<ul>
			<li>
				<b>格式为...</b> - 根据用户右键单击的列，这允许用户将该列的数据格式化为以下之一：<ul>
					<li>未格式化 - 未应用格式。</li>
					<li>串</li>
					<li>日期</li>
					<li>双</li>
					<li>十六进制</li>
					<li>八进制</li>
					<li>二进制</li>
				</ul>
			</li>
			<li>
				<b>添加过滤器...</b> - 向数据表添加<a href="#Filters">过滤器</a> 。
			</li>
			<li>
				<b>删除过滤器...</b> - 从数据表中删除<a href="#Filters">过滤器</a> 。
			</li>
			<li>
				<b>手动调整大小</b> - 允许用户调整列宽，而不会根据最大值弹回最小值。
			</li>
		</ul>
		<h3 id="Data_Graph_Types">数据图类型</h3>
		<p>目前，SystemTap插件中内置了五种图形类型。</p>
		<p>填充数据表后，可以使用“ <a href="#Create_Graph_Wizard">创建图”</a>向导实例化这些图类型。Graphing Perspective可以支持来自一个数据表的多个图。每个都会更新，可以通过在图形选择器视图中浏览每个图表集顶部显示的选项卡来查看。
		</p>
		<h4 id="Scatter_Graph">散点图</h4>
		<p>散点图使用笛卡尔坐标来显示两个或更多定量变量的关系。所有值必须为数字。</p>
		<p>
			<img border="0" src="images/Scatter.png">
		</p>
		<h4 id="Line_Graph">线形图</h4>
		<p>线图传统上理想地用于水平描绘时间上的非累积数据。所有值必须为数字。</p>
		<p>
			<img border="0" src="images/Line.png">
		</p>
		<h4 id="Area_Graph">面积图</h4>
		<p>区域图传统上是水平描绘非累积数据（例如时间）的理想选择。所有值必须为数字。</p>
		<p>
			<img border="0" src="images/Area.png">
		</p>
		<h4 id="Bar_Graph">条状图</h4>
		<p>条形图通常使用条形来显示频率或值。通过将字符串值应用于x轴，可以将标签赋予条形。但是，Y轴值必须是数字。</p>
		<p>
			<img border="0" src="images/Bar.png">
		</p>
		<h4 id="Pie_Graph">饼图</h4>
		<p>饼图使用饼图来显示百分比。为每个提供的数据系列绘制一个饼图。通过将字符串值应用于x轴，可以将标题赋予切片。但是，Y轴值必须是数字。</p>
		<p>
			<img border="0" src="images/Pie.png">
		</p>
		<h3 id="Filters">过滤器</h3>
		<p>过滤器是您可以在数据表上设置的屏幕，用于限制您希望使用的样品数量。过滤器经常用于限制可用的大量信息，以使数据表和图形更加实质和易于管理。</p>
		<p>存在以下选项以使用数据表中的过滤器：</p>
		<ul>
			<li>
				<b>添加过滤器...</b> - 向数据表添加过滤器。可以一次应用多个过滤器。
			</li>
			<li>
				<b>删除过滤器...</b> - 从数据表中删除过滤器。所有当前应用的过滤器都会列在下拉菜单中;用户可以选择要删除哪些。
			</li>
		</ul>
		<p>选择<b>添加过滤器时，</b>您会看到以下对话框：</p>
		<p>
			<img border="0" src="images/StapDataFilters.png">
		</p>
		<p>以下是每种过滤器类型的细分，以及每种过滤器类型如何影响此样本数据集的示例：</p>
		<p>
			<img border="0" src="images/UnfilteredDataset.png">
		</p>
		<ul>
			<li>
				<b>匹配过滤器</b> - 此过滤器可以删除或保留所选选定列的值与所选值匹配的数据集中的所有内容。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Match.png">
		</p>
		<p>结果：</p>
		<p>
			<img border="0" src="images/Match2.png">
		</p>
		<ul>
			<li>
				<b>范围过滤器</b> - 此过滤器保留所选值范围内或外的数据集中的所有内容。请注意，可以通过将下限或上限留空来使用无界范围。
			</li>
		</ul>
		<p>
			<img border="0" src="images/Range.png">
		</p>
		<p>结果：</p>
		<p>
			<img border="0" src="images/Range2.png">
		</p>
		<ul>
			<li>
				<b>排序过滤器</b> - 此过滤器将根据所选列对数据集进行排序。没有数据</li>
		</ul>
		<p>除去。</p>
		<p>
			<img border="0" src="images/Sort.png">
		</p>
		<p>结果：</p>
		<p>
			<img border="0" src="images/Sort2.png">
		</p>
		<ul>
			<li>
				<b>唯一过滤器</b> - 此过滤器将删除该数据集中共享公共的所有合并条目</li>
		</ul>
		<p>所选列中的值。已删除行的数据将根据所选的聚合方法聚合在一起。</p>
		<p>
			<img border="0" src="images/Unique.png">
		</p>
		<ul>
			<li>
				<ul>
					<li>
						<b>Average Aggregate</b> - 此汇总将返回合并的所有项目的平均值。
					</li>
					<li>
						<b>Count Aggregate</b> - 此聚合将返回合并的项目数。
					</li>
					<li>
						<b>Max Aggregate</b> - 此聚合将返回合并的所有项目的最大值。
					</li>
					<li>
						<b>Min Aggregate</b> - 此汇总将返回合并的所有项目的最小值。
					</li>
					<li>
						<b>Sum Aggregate</b> - 此汇总将返回合并的所有项目的总和。
					</li>
				</ul>
			</li>
		</ul>
		<h3 id="Graph_Interaction">图形交互</h3>
		<h4 id="Graph_Options">图表选项</h4>
		<p>每个<a href="#Data_Graph_Types">图表类型</a>都有类似的选项，可以在图形选择器视图中使用：</p>
		<ul>
			<li>
				<b>图例</b> - 此选项可打开和关闭图例，在显示多个系列的图表类型中尤其有用。
			</li>
			<li>
				<b>图形滚动/缩放</b> - 可以缩放和滚动任何图形轴。提供不同的控制以用于导航连续轴和离散轴。
			</li>
		</ul>
		<p>
			<img border="0" src="images/GraphNavBefore.png">
		</p>
		<p>要放大/缩小连续轴（即散点/线/面积图），请使用+/-按钮或图形左侧/下方的比例尺。要滚动查看区域，请使用提供的水平/垂直滚动条。</p>
		<p>
			<img border="0" src="images/GraphNavAfter.png">
		</p>
		<p>专用控件可用于缩放和滚动离散轴，即条形图的条形或饼图的饼图。</p>
		<p>
			<img border="0" src="images/BarNavBefore.png">
		</p>
		<p>使用图表下方的<b>放大/缩小</b>按钮执行<b>缩放</b> 。要向左或向右滚动，请分别单击<b>&lt;</b>或<b>&gt;</b> 。要跳转到轴的开头或结尾，请分别单击<b>&lt;&lt;</b>或<b>&gt;&gt;</b> 。
		</p>
		<p>
			<img border="0" src="images/BarNavAfter.png">
		</p>
		<p>使用<a href="SystemTap-IDE.html#Preferences">“首选项”</a>配置其他图形设置，例如网格线和可查看的数据项。
		</p>
		<h4 id="Graph_Coordinate_Tooltips">图形坐标工具提示</h4>
		<p>将鼠标悬停在图表上的任何数据点上，以显示有关该点坐标的详细信息。此功能适用于所有图表类型。</p>
		<p>
			<img border="0" src="images/LineChartTooltip.png">
		</p>
		<h2 id="Graphing_Tasks">图形化任务</h2>
		<h3 id="Importing.2FExporting_Data_Sets">导入/导出数据集</h3>
		<p>数据集由图表集的数据表的内容组成。用户可能不时希望保留此数据以便在以后的日期/时间继续工作或与其他人共享发现。“导入和导出”选项提供了一种简单的方法。</p>
		<p>要保存数据集，请在查看要保存的图表集数据的其中一个选项卡（数据表或其中一个图表）时单击“ <b>导出数据集”</b>工具栏按钮。要加载和显示以前导出的数据集，请使用“ <b>导入数据集”</b>工具栏按钮，该按钮始终可用。
		</p>
		<p>
			<img border="0" src="images/DataSetImportExport.png"> <i>查看图表集时出现的数据集工具栏按钮。（蓝/左：出口。红色/右：进口。）</i>
		</p>
		<p>
			<img border="0" src="images/DataSetImportOnly.png"> <i>未显示图表集时出现的“导入数据集”按钮。</i>
		</p>
		<p>在任何一种情况下，都会出现一个文件对话框，允许用户选择文件系统中应该导出/导入数据集的路径。</p>
		<h3 id="Saving_a_Graph_Image">保存图形图像</h3>
		<p>可以将图形保存为图像文件。为此，请查看要保存的图形，然后单击工具栏中显示的“ <b>保存图形”</b>按钮。这将打开一个对话框，用户可以在其中导航到他们希望保存图像文件的位置。
		</p>
		<p>
			<img border="0" src="images/SaveStapGraphButton.png">
		</p>
		<h2 id="Reference_2">参考</h2>
		<h3 id="Frequently_Asked_Questions_2">经常问的问题</h3>
		<p>本节详细介绍了与图形脚本输出相关的常见问题。</p>
		<p>
			<b>我可以同时制作多个图表吗？他们同时更新吗？</b>
		</p>
		<p>答：是的，是的。在要创建绘图的脚本的“运行配置”中，您可以一次创建多个图形。此外，在运行启用图形的脚本后，您可以通过单击“图形选择器视图”中的“图形向导”按钮来创建多个附加图形。</p>
		<p>
			<b>我可以提高图表更新的速度吗？</b>
		</p>
		<p>答：是的。默认情况下，它设置为每秒一次，但您可以在<a href="SystemTap-IDE.html#Preferences">“首选项”中</a>增加此值。
		</p>
		<p>
			<b>有没有办法保存或导出图形图像？</b>
		</p>
		<p>答：是的。每当您查看图形时，工具栏中都会出现“ <b>保存图形”</b>按钮。单击它将允许您保存当前焦点的图形。
		</p>
		<p>
			<b>如果我想保留此数据以便稍后进行操作，该怎么办？</b>
		</p>
		<p>答：在查看数据表或其中一个提供数据的图表时，可以使用“ <b>导出数据集”</b>工具栏按钮。单击此按钮可将焦点数据表的内容保存到.set文件中。稍后可以使用工具栏上的“ <b>导入数据集”</b>按钮（始终可用）加载此类文件。
		</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="SystemTap-IDE.html" title="SystemTap IDE">
						<img alt="以前" border="0" src="../../../images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="User-Guide.html" title="SystemTap用户指南">
						<img alt="SystemTap用户指南" border="0" src="../../../images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="Copyright-Information.html" title="版权信息">
						<img alt="下一个" border="0" src="../../../images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">SystemTap IDE</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">版权信息</td>
			</tr>
		</table>
	</body>
</html><html id="0022.ScriptingReference.24.6.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>BirtMath</title>
    <link rel="StyleSheet" href="css/ScriptingReference.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ScriptingReference.24.5.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="ScriptingReference.24.7.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h2 class="RH1_Class"><a name="267940">BirtMath</a>类</h2>
      <p class="b_Body"><a name="267941">BirtMath类提供了操作数字数据的功能，例如，添加，减去，复数，除数和舍入数字。数字是一个通用对象，可以在“编辑数据绑定”对话框的“数据类型”字段中转换为另一种类型。这个类是静态的。应用程序无法创建该类的实例。</a></p>
      <h3 class="RH2_Method"><a name="267942">BirtMath.add</a></h3>
      <p class="b_Body"><a name="267943">此函数返回两个数字的总和。</a></p>
      <p class="N_sb_ScanBold"><a name="267944">句法</a></p>
      <div class="rs_RSyntax"><a name="267945">编号BirtMath.add（编号n1，编号n2）</a></div>
      <p class="N_sb_ScanBold"><a name="267946">参数</a></p>
      <p class="RParameter"><a name="267947">N1</a></p>
      <p class="bn_BodyNoLead"><a name="267948">数字对象。计算中使用的第一个数字。</a></p>
      <p class="RParameter"><a name="270526">N2</a></p>
      <p class="bn_BodyNoLead"><a name="270530">计算中使用的第二个数字。</a></p>
      <p class="N_sb_ScanBold"><a name="267949">返回</a></p>
      <p class="b_Body"><a name="267950">数字对象。添加n1和n2会产生的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="267951">例</a></p>
      <p class="b_Body"><a name="267952">以下示例返回SalesTotal和Shipping字段中的值的总和：</a></p>
      <div class="cf_CodeFirst"><a name="267953">BirtMath.add（row [“SalesTotal”]，行[“Shipping”]）</a></div>
      <h3 class="RH2_Method"><a name="271050">BirtMath.ceiling</a></h3>
      <p class="b_Body"><a name="271051">此函数将数字向上舍入，从0开始，到最接近的指定倍数。</a></p>
      <p class="N_sb_ScanBold"><a name="271052">句法</a></p>
      <div class="rs_RSyntax"><a name="271053">编号BirtMath.ceiling（编号n，编号重要性）</a></div>
      <p class="N_sb_ScanBold"><a name="271054">参数</a></p>
      <p class="RParameter"><a name="271055">ñ</a></p>
      <p class="bn_BodyNoLead"><a name="271056">数字对象。四舍五入的数字。</a></p>
      <p class="RParameter"><a name="271057">意义</a></p>
      <p class="bn_BodyNoLead"><a name="271058">数字对象。多个到圆n到。</a></p>
      <p class="N_sb_ScanBold"><a name="271059">返回</a></p>
      <p class="b_Body"><a name="271060">数字对象。四舍五入产生的数字。如果n是重要性的精确倍数，则不会发生舍入。</a></p>
      <p class="N_sb_ScanBold"><a name="271061">例子</a></p>
      <p class="b_Body"><a name="271062">BirtMath.ceiling（）通常用于舍入价格。例如，为避免处理便士，您可以使用以下表达式将价格字段中的价格舍入到最接近的镍：</a></p>
      <div class="cf_CodeFirst"><a name="271063">BirtMath.ceiling（row [“Price”]，0.05）</a></div>
      <p class="b_Body"><a name="271395">如果Price值为20.52，则表达式返回20.55。</a></p>
      <p class="b_Body"><a name="271406">以下表达式将价格四舍五入到最接近的角钱：</a></p>
      <div class="cf_CodeFirst"><a name="271412">BirtMath.ceiling（row [“Price”]，0.1）</a></div>
      <p class="b_Body"><a name="271407">如果Price值为20.52，则表达式返回20.60。如果Price值为20.40，则表达式返回20.40。不会发生舍入，因为20.40是0.1的倍数。</a></p>
      <p class="b_Body"><a name="271501">以下表达式将价格四舍五入到最接近的美元：</a></p>
      <div class="cf_CodeFirst"><a name="271502">BirtMath.ceiling（row [“Price”]，1）</a></div>
      <p class="b_Body"><a name="271518">如果Price值为20.30，则表达式返回21。</a></p>
      <h3 class="RH2_Method"><a name="270549">BirtMath.divide</a></h3>
      <p class="b_Body"><a name="270550">此函数返回将一个数字除以另一个数字的结果。</a></p>
      <p class="N_sb_ScanBold"><a name="270551">句法</a></p>
      <div class="rs_RSyntax"><a name="270552">编号BirtMath.divide（编号红利，编号除数）</a></div>
      <p class="N_sb_ScanBold"><a name="270553">参数</a></p>
      <p class="RParameter"><a name="270554">股利</a></p>
      <p class="bn_BodyNoLead"><a name="270555">数字对象。要分割的数量。</a></p>
      <p class="RParameter"><a name="270556">除数</a></p>
      <p class="bn_BodyNoLead"><a name="270557">数字对象。分红的数量。</a></p>
      <p class="N_sb_ScanBold"><a name="270558">返回</a></p>
      <p class="b_Body"><a name="270559">数字对象。将除数除以除数得出的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="270560">例子</a></p>
      <p class="b_Body"><a name="270561">以下示例显示了划分特定数字的结果：</a></p>
      <div class="cf_CodeFirst"><a name="271010">BirtMath.divide（10,2）//返回5</a></div>
      <div class="co_Code"><a name="271019">BirtMath.divide（2,10）//返回0.2</a></div>
      <p class="b_Body"><a name="271007">以下示例返回“总计”字段中的值除以“数量”字段中的值的结果：</a></p>
      <div class="cf_CodeFirst"><a name="270562">BirtMath.divide（行[“Total”]，行[“Quantity”]）</a></div>
      <h3 class="RH2_Method"><a name="271580">BirtMath.mod</a></h3>
      <p class="b_Body"><a name="271581">此函数返回数字除以除数后的余数。</a></p>
      <p class="N_sb_ScanBold"><a name="271582">句法</a></p>
      <div class="rs_RSyntax"><a name="271583">编号BirtMath.mod（编号，编号除数）</a></div>
      <p class="N_sb_ScanBold"><a name="271584">参数</a></p>
      <p class="RParameter"><a name="271585">数</a></p>
      <p class="bn_BodyNoLead"><a name="271586">数字对象。要分割的数量。</a></p>
      <p class="RParameter"><a name="271587">除数</a></p>
      <p class="bn_BodyNoLead"><a name="271588">数字对象。第一个数字的分割数。您必须指定非零数字。</a></p>
      <p class="N_sb_ScanBold"><a name="271589">返回</a></p>
      <p class="b_Body"><a name="271590">数字后面的余数除以除数。</a></p>
      <p class="N_sb_ScanBold"><a name="271591">例子</a></p>
      <p class="b_Body"><a name="271592">以下示例显示函数为特定数字返回的结果：</a></p>
      <div class="cf_CodeFirst"><a name="274476">BirtMath.mod（10,3）//返回1</a></div>
      <div class="co_Code"><a name="274483">BirtMath.mod（10,5）//返回0</a></div>
      <div class="co_Code"><a name="274514">BirtMath.mod（10,6）//返回4</a></div>
      <p class="b_Body"><a name="274193">以下示例检查“成绩”字段中的数字是奇数还是偶数。当除数为2时，函数对偶数返回0，对奇数返回1。</a></p>
      <div class="cf_CodeFirst"><a name="271593">BirtMath.mod（行[“等级”]，2）</a></div>
      <h3 class="RH2_Method"><a name="270911">BirtMath.multiply</a></h3>
      <p class="b_Body"><a name="270913">此函数返回两个数字的乘法。</a></p>
      <p class="N_sb_ScanBold"><a name="270914">句法</a></p>
      <div class="rs_RSyntax"><a name="270600">编号BirtMath.multiply（编号n1，编号n2）</a></div>
      <p class="N_sb_ScanBold"><a name="270601">参数</a></p>
      <p class="RParameter"><a name="270940">N1</a></p>
      <p class="bn_BodyNoLead"><a name="270941">数字对象。计算中使用的第一个数字。</a></p>
      <p class="RParameter"><a name="270942">N2</a></p>
      <p class="bn_BodyNoLead"><a name="270943">数字对象。计算中使用的第二个数字。</a></p>
      <p class="N_sb_ScanBold"><a name="270944">返回</a></p>
      <p class="b_Body"><a name="270945">数字对象。乘以n1和n2得到的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="270946">例</a></p>
      <p class="b_Body"><a name="270947">以下示例返回QuantityOrdered和PriceEach字段中的值相乘结果：</a></p>
      <div class="cf_CodeFirst"><a name="270948">BirtMath.multiply（row [“QuantityOrdered”]，row [“PriceEach”]）</a></div>
      <h3 class="RH2_Method"><a name="274568">BirtMath.round</a></h3>
      <p class="b_Body"><a name="274569">此函数将数字四舍五入为指定的位数。</a></p>
      <p class="N_sb_ScanBold"><a name="274570">句法</a></p>
      <div class="rs_RSyntax"><a name="274571">编号BirtMath.round（编号，编号dec）</a></div>
      <p class="N_sb_ScanBold"><a name="274572">参数</a></p>
      <p class="RParameter"><a name="274573">数</a></p>
      <p class="bn_BodyNoLead"><a name="274614">数字对象。圆的数量。</a></p>
      <p class="RParameter"><a name="274615">十二月</a></p>
      <p class="bn_BodyNoLead"><a name="274616">数字对象。要舍入的数字位数。如果省略此参数，则该函数假定为0。</a></p>
      <p class="N_sb_ScanBold"><a name="274577">返回</a></p>
      <p class="b_Body"><a name="274578">数字对象。一个四舍五入到指定位数的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="274579">例子</a></p>
      <p class="b_Body"><a name="274580">以下示例显示函数为特定数字返回的结果：</a></p>
      <div class="cf_CodeFirst"><a name="274581">BirtMath.round（1545.50）//返回1546</a></div>
      <div class="co_Code"><a name="274695">BirtMath.round（1545.56,1）//返回1545.6</a></div>
      <div class="co_Code"><a name="274650">BirtMath.round（1545.23,1）//返回1545.2</a></div>
      <div class="co_Code"><a name="274582">BirtMath.round（1545.50，-1）//返回1550</a></div>
      <p class="b_Body"><a name="274584">以下示例对PriceEstimate字段中的值进行舍入以返回整数：</a></p>
      <div class="cf_CodeFirst"><a name="274585">BirtMath.round（row [“PriceEstimate”]，0）</a></div>
      <h3 class="RH2_Method"><a name="274754">BirtMath.roundDown</a></h3>
      <p class="b_Body"><a name="274755">此函数将数字向下舍入到指定的位数。</a></p>
      <p class="N_sb_ScanBold"><a name="274756">句法</a></p>
      <div class="rs_RSyntax"><a name="274757">编号BirtMath.roundDown（编号，编号dec）</a></div>
      <p class="N_sb_ScanBold"><a name="274758">参数</a></p>
      <p class="RParameter"><a name="274759">数</a></p>
      <p class="bn_BodyNoLead"><a name="274760">数字对象。圆的数量。</a></p>
      <p class="RParameter"><a name="274761">十二月</a></p>
      <p class="bn_BodyNoLead"><a name="274762">数字对象。将数字向下舍入的位数。如果省略此参数，则该函数假定为0。</a></p>
      <p class="N_sb_ScanBold"><a name="274763">返回</a></p>
      <p class="b_Body"><a name="274764">数字对象。一个向下舍入到指定位数的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="274765">例子</a></p>
      <p class="b_Body"><a name="274766">以下示例显示函数为特定数字返回的结果：</a></p>
      <div class="cf_CodeFirst"><a name="274767">BirtMath.roundDown（1545.50）//返回1545</a></div>
      <div class="co_Code"><a name="274768">BirtMath.roundDown（1545.56,1）//返回1545.5</a></div>
      <div class="co_Code"><a name="274769">BirtMath.roundDown（1545.23,1）//返回1545.2</a></div>
      <div class="co_Code"><a name="274770">BirtMath.roundDown（1545.50，-1）//返回1540</a></div>
      <p class="b_Body"><a name="274771">以下示例向下舍入PriceEstimate字段中的值以返回整数：</a></p>
      <div class="cf_CodeFirst"><a name="274772">BirtMath.roundDown（row [“PriceEstimate”]，0）</a></div>
      <h3 class="RH2_Method"><a name="275084">BirtMath.roundUp</a></h3>
      <p class="b_Body"><a name="275085">此函数将数字四舍五入到指定的位数。</a></p>
      <p class="N_sb_ScanBold"><a name="275086">句法</a></p>
      <div class="rs_RSyntax"><a name="275087">编号BirtMath.roundUp（编号，编号dec）</a></div>
      <p class="N_sb_ScanBold"><a name="275088">参数</a></p>
      <p class="RParameter"><a name="275089">数</a></p>
      <p class="bn_BodyNoLead"><a name="275090">数字对象。四舍五入的数字。</a></p>
      <p class="RParameter"><a name="275091">十二月</a></p>
      <p class="bn_BodyNoLead"><a name="275092">数字对象。圆数最多的位数。如果省略此参数，则该函数假定为0。</a></p>
      <p class="N_sb_ScanBold"><a name="275093">返回</a></p>
      <p class="b_Body"><a name="275094">数字对象。一个数字四舍五入到指定的位数。</a></p>
      <p class="N_sb_ScanBold"><a name="275095">例子</a></p>
      <p class="b_Body"><a name="275096">以下示例显示函数为特定数字返回的结果：</a></p>
      <div class="cf_CodeFirst"><a name="275097">BirtMath.roundUp（1545.50）//返回1546</a></div>
      <div class="co_Code"><a name="275098">BirtMath.roundUp（1545.56,1）//返回1545.6</a></div>
      <div class="co_Code"><a name="275099">BirtMath.roundUp（1545.23,1）//返回1545.3</a></div>
      <div class="co_Code"><a name="275100">BirtMath.roundUp（1545.50，-1）//返回1550</a></div>
      <p class="b_Body"><a name="275101">以下示例将PriceEstimate字段中的值向上舍入以返回整数：</a></p>
      <div class="cf_CodeFirst"><a name="275102">BirtMath.roundUp（row [“PriceEstimate”]，0）</a></div>
      <h3 class="RH2_Method"><a name="275121">BirtMath.safeDivide</a></h3>
      <p class="b_Body"><a name="275122">此函数返回将一个数字除以另一个数字的结果，从而防止除零条件。</a></p>
      <p class="N_sb_ScanBold"><a name="275123">句法</a></p>
      <div class="rs_RSyntax"><a name="275124">编号BirtMath.safeDivide（编号红利，编号除数，对象ifZero）</a></div>
      <p class="N_sb_ScanBold"><a name="275125">参数</a></p>
      <p class="RParameter"><a name="275126">股利</a></p>
      <p class="bn_BodyNoLead"><a name="275127">数字对象。要分割的数量。</a></p>
      <p class="RParameter"><a name="275128">除数</a></p>
      <p class="bn_BodyNoLead"><a name="275129">数字对象。分红的数量。</a></p>
      <p class="RParameter"><a name="275490">ifZero</a></p>
      <p class="bn_BodyNoLead"><a name="275502">宾语。除数为零时返回的值。</a></p>
      <p class="N_sb_ScanBold"><a name="275130">返回</a></p>
      <p class="b_Body"><a name="275131">数字对象。数字对象。将除数除以除数得出的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="275132">例子</a></p>
      <p class="b_Body"><a name="275133">以下示例显示函数为特定数字返回的结果：</a></p>
      <div class="cf_CodeFirst"><a name="275134">BirtMath.safeDivide（10,2,0）//返回5</a></div>
      <div class="co_Code"><a name="275520">BirtMath.safeDivide（10,0,0）//返回0</a></div>
      <p class="b_Body"><a name="275521">以下示例返回“收入”字段中的值除以“卷”字段中的值的结果。如果Volume值为0，则该函数返回0。</a></p>
      <div class="cf_CodeFirst"><a name="275517">BirtMath.safeDivide（row [“Revenue”]，row [“Volume”]，0）</a></div>
      <h3 class="RH2_Method"><a name="270972">BirtMath.subtract</a></h3>
      <p class="b_Body"><a name="270974">此函数返回从另一个数字中减去一个数字的结果。</a></p>
      <p class="N_sb_ScanBold"><a name="270975">句法</a></p>
      <div class="rs_RSyntax"><a name="270976">编号BirtMath.subtract（编号n1，编号n2）</a></div>
      <p class="N_sb_ScanBold"><a name="270977">参数</a></p>
      <p class="RParameter"><a name="270978">N1</a></p>
      <p class="bn_BodyNoLead"><a name="270979">数字对象。要减去的数字。</a></p>
      <p class="RParameter"><a name="270980">N2</a></p>
      <p class="bn_BodyNoLead"><a name="270981">数字对象。要从n1减去的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="270982">返回</a></p>
      <p class="b_Body"><a name="270983">数字对象。从n1中减去n2得到的数字。</a></p>
      <p class="N_sb_ScanBold"><a name="270984">例</a></p>
      <p class="b_Body"><a name="271028">以下示例显示了减去特定数字的结果：</a></p>
      <div class="cf_CodeFirst"><a name="271029">BirtMath.subtract（12,4）//返回8</a></div>
      <div class="co_Code"><a name="271030">BirtMath.subtract（4,12）//返回-8</a></div>
      <p class="b_Body"><a name="271031">以下示例返回从“总计”字段中的值中减去“折扣”字段中的值的结果：</a></p>
      <div class="cf_CodeFirst"><a name="271032">BirtMath.subtract（row [“Total”]，row [“Discount”]）</a></div>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html><html id="0585.logical-model.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>逻辑模型</title>
		<style type="text/css">.info {
  border: 1px solid #3c78b5;
  background-color: #d8e4f1;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.note {
  border: 1px solid #f0c000;
  background-color: #ffffce;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.panel {
  border: 1px solid #ccc;
  background-color: #ffffce;
  margin: 10px;
  padding: 0px 6px 0px 6px;
}
.tip {
  border: 1px solid #090;
  background-color: #dfd;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
.warning {
  border: 1px solid #c00;
  background-color: #fcc;
  margin: 20px;
  padding: 0px 6px 0px 6px;
}
</style>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/bootstrap.css"></link>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.emf.compare.doc/help/resources/custom.css"></link>
	</head>
	<body dir="ltr">
		<h1 id="Logical_Model">逻辑模型</h1>
		<h2 id="Eclipse">日食</h2>
		<h3 id="What_is_a_logical_model_.3F">什么是逻辑模型？</h3>
		<p>我们将“逻辑模型”命名为一组<b>物理资源</b> ，形成一个连贯的业务相关模型。例如，我们可以说给定的Java类只有在与所有导入的类链接时才形成一个连贯的逻辑模型。
		</p>
		<p>对于EMF，我们将内存中加载的EMF资源命名为<i>逻辑资源</i> （或<i>模型</i> ），而不是仅仅是磁盘上此模型序列化的<i>物理资源</i> （或<i>文件</i> ）。给定的EMF模型可以引用许多其他模型，如果这些其他模型没有加载到内存中，它将是不连贯的，甚至有时会被破坏。在EMF中，给定模型可以序列化为单个文件，在磁盘上的多个文件中<i>分段</i> ，或<i>引用</i>多个文件。逻辑模型只有在可以访问整个物理文件集时才是一致的。
		</p>
		<p>如果我们反过来，逻辑模型是一组相互引用的元素：</p>
		<table>
			<tr>
				<td align="center">
					<img align="middle" border="1" src="../images/Logical_Model.png">
				</td>
			</tr>
			<tr>
				<td align="center">逻辑模型是一组相互关联的元素。</td>
			</tr>
		</table>
		<p>当这些元素在磁盘上序列化时，只要可以解析这些文件之间的引用，它们就可以分割为多个文件：</p>
		<table>
			<tr>
				<td align="center">
					<img align="middle" border="1" src="../images/Logical_Model_Split.png">
				</td>
			</tr>
			<tr>
				<td align="center">逻辑模型分为文件<i>A</i> ， <i>B</i> ， <i>C</i> ， <i>D</i> ， <i>E</i> ， <i>F</i>和<i>G.</i></td>
			</tr>
		</table>
		<h3 id="Eclipse_Team">Eclipse团队</h3>
		<p>Eclipse Team项目（在本文档中称为“Team”）提供了一个名为“模型提供者”的API。该API允许实现者在其案例中定义什么是“逻辑模型”的语义。简而言之，它允许我们将任意数量的物理资源链接到给定的“起始”文件。</p>
		<p>从技术上讲，这是通过一个可以由任何人实现的扩展点完成的，它将使文件（工作空间<i>IResource</i> ）适应一组文件（Team <i>ResourceTraversal</i> ）。任何调用工作空间文件操作的人都可以查询模型提供程序，以确定是否可以针对单个文件执行此操作，或者是否应该针对一组文件执行此操作。
		</p>
		<h3 id="Limitations">限制</h3>
		<p>Team仅提供用于定义逻辑模型的API。然后，客户有责任在调用操作时正确查询模型提供程序。在EMF Compare的上下文中，我们对“比较”操作感兴趣。这些操作由存储库提供程序（CVS，EGit，Subversive，Subclipse，Clearcase ...）提供。在这些操作的代码中，他们有责任查询模型提供者，以确定是否可以单独比较所选文件......或者是否需要将它们与一组其他文件进行比较。</p>
		<ul>
			<li>CVS插件并不一贯使用它。例如，当在作为逻辑模型一部分的文件上使用“与最新的HEAD相比”时，它将“看到”逻辑模型并打开“同步”透视图而不是比较编辑器：这就是预期的结果。但是，当用户从同步视图中要求查看差异时（右键单击然后选择“在比较编辑器中打开”）...CVS不会查询逻辑模型，仅比较文件（另请参阅<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=345415">错误345415</a> ）。
			</li>
			<li>EGit，Subversive和Subclipse插件从不向模型提供者查询任何比较操作。</li>
		</ul>
		<h2 id="EMF_Compare">EMF比较</h2>
		<p>在EMF比较的情况下，上述限制是一个显示阻止。EMF模型不能简单地简化为单个文件，因为在尝试合并它们时会完全破坏它们的一致性。</p>
		<h3 id="Chosen_solution">选择解决方案</h3>
		<p>EMF Compare现在使用自己的实现来实现同一目标，我们将其命名为<i>同步模型</i> 。简而言之，EMF Compare不会期望存储库提供程序查询模型提供程序，而是采用它所提供的文件（或文件集），并通过查询同步模型将其扩展为完整的逻辑模型。
		</p>
		<p>此自定义实现还允许我们不仅解析给定物理文件的整个逻辑模型，还允许确定此模型的哪些<b>部分</b>应包含在比较范围中。实际上，在EMF的语义下，如果我们可以确定两个物理文件在它们的两个不同的修订中是二进制相同的，那么我们也知道它们所代表的逻辑模型的各个部分本身是相同的。没有必要比较它们。这使我们能够节省时间和记忆，一举两得。
		</p>
		<h3 id="How_it_works">这个怎么运作</h3>
		<p>当用户在其工作空间中选择文件<i>A</i>并要求将其与远程修订（例如，“来自HEAD的最新”）进行比较时，存储库提供程序（在本例中为CVS） <i>将</i>在所选修订中获取<i>A</i>的远程内容（我们称之为<i>A</i> '）。获取远程修订后，存储库提供程序会认为他的工作已完成并提供EMF比较两个文件（A和A'）并让它开始自己的工作。当A的逻辑模型仅跨越单个文件时，这很好并且花花公子......但如果A引用另一个文件B，则比较将不一致，因为EMF Compare对逻辑模型进行操作，而不是对其序列化形式进行操作。
		</p>
		<p>因此，EMF Compare不会立即启动它所馈送文件的比较。在进行任何进一步的工作之前，它将使用这些文件查询同步模型，以便将它们扩展到整个逻辑模型。</p>
		<ul>
			<li>对于本地文件（A），它将把它作为EMF <i>资源</i>加载并解析所有交叉引用。在解决过程中，我们将能够跟踪“起点”A所需的所有“其他”文件。在上面的例子中，我们最终得到一个包含A和B的集合。</li>
			<li>对于远程文件（A'），它将尝试加载资源的流式修订，然后在正确的修订中向存储库提供程序查询A'所需的其他文件。如果修订先于（或等于）我们最初提供的A'修订版，则该修订版被视为“正确”。这将引导我们到包含A'和B'的集合。</li>
		</ul>
		<p>解决完整的逻辑模型后，EMF Compare可以正确地进行比较工作。由于我们知道构成我们模型的所有文件，因此我们还能够安全地合并差异而不会影响整体的一致性。</p>
		<p>但是，即使我们可以在此时启动EMF比较，同步模型也为我们提供了更多可能性。EMF模型可以跨越数千个物理文件，有时相当于如此大量的元素，如果我们试图将它作为一个整体加载，它就不适合机器的内存。同步模型知道如何检索所有这些文件的内容;它也可以用于<i>将</i>设置<i>最小化</i>到仅真正改变的设置。实际上，我们认为二进制相同的文件会产生逻辑模型的片段，这些片段也将严格相同。通过删除这些“相同”的片段，我们可以极大地限制我们将加载到内存中的逻辑模型的大小，将其压缩到适合我们在剩余片段上启动比较之前的大小。
		</p>
		<p>换句话说，同步模型允许我们将模型与时间和内存成本进行比较，该时间和内存成本相对于实际变更集的大小而不是依赖于输入模型的大小。</p>
		<h4 id="Example">例</h4>
		<p>让我们考虑以下示例：</p>
		<table border="1" cellpadding="5" cellspacing="0">
			<tr>
				<th align="center" colspan="2">起源</th>
			</tr>
			<tr>
				<td align="center" colspan="2">
					<img align="middle" border="0" src="../images/EMFC_Logic_origin.png">
				</td>
			</tr>
			<tr>
				<th align="center">剩下</th>
				<th align="center">对</th>
			</tr>
			<tr>
				<td>
					<img align="middle" border="0" src="../images/EMFC_Logic_left.png">
				</td>
				<td>
					<img align="middle" border="0" src="../images/EMFC_Logic_right.png">
				</td>
			</tr>
		</table>
		<p>三个边中的每一个都是由7个片段组成的EMF模型。
			<i>原产地</i>是<i>左边</i>和<i>右边</i>的共同祖先。蓝色片段是实际存在差异的片段（因此D和G在“左”副本中被修改，而在“右”副本中仅修改了B）。
		</p>
		<p>为了将这三个模型进行比较，我们通常需要在内存中加载所有21个片段。但是，在同步模型的帮助下，我们可以将其缩小到仅修改的片段。那么，我们真正加载的是每个三个方面的以下片段：</p>
		<p>
			<img align="middle" border="0" src="../images/EMFC_Logic_loaded_fragments.png">
		</p>
		<p>换句话说，我们实际上只从初始21中加载了9个片段。如果我们认为所有片段具有相同的“重量”，则相当于减少58％的内存使用量。这仅适用于小型车型;对于超大型号，保存的内存比例确实在上升。当然，我们没有加载到内存中的所有这些对象都是我们不再需要比较的对象，带来令人难以置信的性能提升以及内存增益。</p>
		<h4 id="Some_numbers">一些数字</h4>
		<p>当我们得到EMF Compare 1.3时，我们对一些具有已知元素数量的UML模型进行了一些性能快照。以下是三种测试模型的结构规格。 “fragment”是碎片文件的数量，其余是样本包含的UML元素（在片段中展开）：</p>
		<table border="1" cellspacing="0">
			<tr>
				<th> </th>
				<th>小</th>
				<th>公称</th>
				<th>大</th>
			</tr>
			<tr>
				<td>片段</td>
				<td>99</td>
				<td>399</td>
				<td>947</td>
			</tr>
			<tr>
				<td>磁盘大小（MB）</td>
				<td>1.37</td>
				<td>8.56</td>
				<td>49.9</td>
			</tr>
			<tr>
				<td></td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td>包</td>
				<td>97</td>
				<td>389</td>
				<td>880</td>
			</tr>
			<tr>
				<td>类</td>
				<td>140</td>
				<td>578</td>
				<td>2169</td>
			</tr>
			<tr>
				<td>原始类型</td>
				<td>581</td>
				<td>5370</td>
				<td>17152</td>
			</tr>
			<tr>
				<td>数据类型</td>
				<td>599</td>
				<td>5781</td>
				<td>18637</td>
			</tr>
			<tr>
				<td>国家机器</td>
				<td>55</td>
				<td>209</td>
				<td>1311</td>
			</tr>
			<tr>
				<td>状态</td>
				<td>202</td>
				<td>765</td>
				<td>10156</td>
			</tr>
			<tr>
				<td>依赖</td>
				<td>235</td>
				<td>2522</td>
				<td>8681</td>
			</tr>
			<tr>
				<td>转变</td>
				<td>798</td>
				<td>3106</td>
				<td>49805</td>
			</tr>
			<tr>
				<td>操作</td>
				<td>1183</td>
				<td>5903</td>
				<td>46029</td>
			</tr>
			<tr>
				<td>
					<b>元素总数</b>
				</td>
				<td>3890</td>
				<td>24623</td>
				<td>154820</td>
			</tr>
		</table>
		<p>以下是比较每个模型大小（模型被复制，随机修改，然后将副本与其原始版本进行比较）和两个版本的EMF比较所需的时间和内存。'旧'1.3，以及2.1完全使用逻辑模型功能。</p>
		<h5 id="EMF_Compare_1.3">EMF比较1.3</h5>
		<p>请注意，这些是“CPU时间”度量：我们使用Java分析器来测量比较过程的持续时间，而不考虑实际的挂起时间：我们测量了CPU在此过程中处于活动状态的时间。由于EMF Compare 1不是多线程的，这意味着这些数字略低于用户对同一操作实际感知的时间。（请参阅维基百科上的<a href="http://en.wikipedia.org/wiki/Wall_clock_time">壁垒时间</a>和<a href="http://en.wikipedia.org/wiki/System_time">系统时间</a> 。）
		</p>
		<table border="1" cellspacing="0">
			<tr>
				<th> </th>
				<th>小</th>
				<th>公称</th>
				<th>大</th>
			</tr>
			<tr>
				<td>时间（秒）</td>
				<td>6</td>
				<td>22</td>
				<td>125</td>
			</tr>
			<tr>
				<td>最大堆（MB）</td>
				<td>555</td>
				<td>1019</td>
				<td>2100</td>
			</tr>
		</table>
		<p>这些数字可以分为以下三个主要阶段：</p>
		<p>
			<img align="middle" border="0" src="../images/EMFC_1.3_Perf_Breakdown.png">
		</p>
		<p>这意味着EMF Compare的内存管理在我们处理大型模型时就会受到限制（加载模型需要超过2GB的堆空间来“称重”磁盘上的50 MB）。此外，主时间汇是差分过程，也可以缩小到明显有太多的对象要比较的事实：对于双向比较，我们加载模型两次，进行三向比较，模型的三个实例被加载到内存中。不仅如此，我们在所有模型上迭代两次（一个用于匹配，一个用于差分）。</p>
		<p>完整的报告可以从<a href="http://www.eclipse.org/emf/compare/doc/compare_scalability.pdf">这里</a>下载。
		</p>
		<h5 id="EMF_Compare_2.1">EMF比较2.1</h5>
		<p>请注意，这些是“壁挂时间”测量：我们使用秒表来计算比较的持续时间，从点击“与...相互比较”操作到比较编辑器的开头。</p>
		<table border="1" cellspacing="0">
			<tr>
				<th> </th>
				<th>小</th>
				<th>公称</th>
				<th>大</th>
			</tr>
			<tr>
				<td>时间（秒）</td>
				<td>五</td>
				<td>13</td>
				<td>48</td>
			</tr>
			<tr>
				<td>最大堆（MB）</td>
				<td>262</td>
				<td>318</td>
				<td>422</td>
			</tr>
		</table>
		<p>这些数字可分为5个主要阶段：</p>
		<ol>
			<li>模型解析：从给定的“起点”（在上面的例子中，片段<i>A</i> ）中，找到整个逻辑模型比较所需的所有其他片段。
			</li>
			<li>范围缩小：从组成逻辑模型的片段集中，找到实际<i>可以</i>呈现差异的片段（上例中的<i>B</i> ， <i>D</i>和<i>G</i> ），然后将这些片段加载到内存中。
			</li>
			<li>匹配：迭代两个（或三个）加载的逻辑模型，以便将元素一起映射到二乘（或三乘三）。</li>
			<li>差异：匹配阶段告诉我们哪些元素匹配在一起（左侧逻辑模型中的C1类和右侧逻辑模型中的类C1'）。差异阶段将尝试确定这两个元素是否相等或者它们是否存在差异（例如，类的名称从<i>C1</i>更改为<i>C1</i> '）</li>
			<li>后处理：现在我们知道了模型之间的所有差异，我们仍然需要确定等价 - 表示相同变化的两个差异（例如，相反参考的差异） - ，要求 - 差异取决于另一个（例如，加在包P1的一类C1的依赖于另外包P1的） - ，矛盾冲突的-a变化在<i><i>左右</i></i>车型进行了比原点...
			</li>
		</ol>
		<p>
			<img align="middle" border="0" src="../images/EMFC_2.1_Perf_Breakdown.png">
		</p>
		<p>好的，这个图表对解释没有多大帮助。模型解析时间完全使其他比较阶段相形见绌。这实际上是我们EMF的目标比较2： <i>模型解析</i>代表EMF比较的大部分I / O操作，我们的目标是将实际比较减少到最短时间。因此，我们不仅大大提高了内存成本（只有400MB的堆空间来比较需要超过2GB的内容与EMF Compare 1），但我们也在很大程度上缩短了比较时间（和可扩展性）。
		</p>
		<h3 id="Limitations_2">限制</h3>
		<p>有效地使用我们自己的实现允许我们绕过一些上述限制，因为在我们的特定情况下我们不再依赖于存储库提供者。</p>
		<p>但是，如果我们可以在比较期间强制执行模型的一致性，那么这种方法仍然没有考虑与模型协作的其他方面。即使比较和合并两个链接的模型很好，但仍然是存储库提供者负责查询团队的模型提供者，以便“提交”，“推送”甚至“替换”整个模型而不是单个物理文件。因此，尽管我们修正了适用于比较行为的限制，但上述大部分限制仍然存在。</p>
		<h3 id="Improvement_Axes">改进轴</h3>
		<p>如同所示<a href="#EMF_Compare_2.1">上述图表</a>中，最重要的剩余时间水槽是逻辑模型的分辨率。这部分是由于在此阶段执行的I / O操作，但首先是由于我们使用的文件（UML片段）的XMI表示解析为EMF模型。EMF Compare需要实际将逻辑模型的所有片段作为EMF模型片段加载，以确定其跨资源引用，这些引用代表依次需要的逻辑模型的其他部分。通过解析原始XMI数据以查找所有这些跨资源引用而无需解析它们所属的实际EMF元素，可以改进此阶段。
		</p>
	</body>
</html><html id="3187.Spinner.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 旋转器</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">键入微调器</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。微调</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Spinner.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Spinner.html#constructor">微调</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Spinner.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Spinner.html#getMaximum">getMaximum</a></b> （）</div>
                <div class="description">返回接收器允许的最大值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Spinner.html#getMinimum">getMinimum</a></b> （）</div>
                <div class="description">返回接收器允许的最小值。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Spinner.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">返回'选择'，它是接收者的位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Spinner.html#getText">getText</a></b> （）</div>
                <div class="description">返回包含接收者文本字段内容副本的字符串，如果没有内容则返回空字符串。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Spinner.html#setSelection">setSelection</a></b> （选择）</div>
                <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Spinner.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Spinner.html#event:Modify">修改</a></b>
                </div>
                <div class="description">更改窗口小部件文本时发送</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Spinner.html#event:Selection">选择</a></b>
                </div>
                <div class="description">更改窗口小部件选择时发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>微调</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getMaximum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMaximum</b> （）</div>
          <div class="description">返回接收器允许的最大值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最大值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getMinimum"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getMinimum</b> （）</div>
          <div class="description">返回接收器允许的最小值。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>最小值</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{int}</span> <b>getSelection</b> （）</div>
          <div class="description">返回'选择'，它是接收者的位置。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int}</span>选择</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getText"> </a>
          <div class="fixedFont">

          <span class="light">{string}</span> <b>getText</b> （）</div>
          <div class="description">返回包含接收者文本字段内容副本的字符串，如果没有内容则返回空字符串。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{string}</span>接收者的文字</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （选择）</div>
          <div class="description">将'selection'（接收者的值）设置为必须大于或等于零的参数。
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{int}</span> <b>选择</b>
                  
                </dt>
                <dd>新选择（必须为零或更大）</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Modify"> </a>
          <div class="fixedFont">

          
          <b>修改</b>

          </div>
          <div class="description">更改窗口小部件文本时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Modify">SWT.Modify</a></dd>
              
              </dl>
            

          <hr>
        
          <a name="event:Selection"> </a>
          <div class="fixedFont">

          
          <b>选择</b>

          </div>
          <div class="description">更改窗口小部件选择时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Selection">SWT.Selection</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="2903.org_eclipse_ui_ide_markerSupport.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>标记支持</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">标记支持</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.ui.ide.markerSupport<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.2<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>标记支持扩展点定义了工作台工具的扩展，这些工具显示标记，例如问题，书签和任务视图。<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">分机</a> （ <a href="#e.problemFilter">problemFilter</a> *， <a href="#e.markerTypeCategory">markerTypeCategory</a> *， <a href="#e.markerGrouping">markerGrouping</a> *， <a href="#e.markerGroupingEntry">markerGroupingEntry</a> *， <a href="#e.markerAttributeGrouping">markerAttributeGrouping</a> *， <a href="#e.markerContentGenerator">markerContentGenerator</a> *， <a href="#e.markerField">markerField</a> *， <a href="#e.markerContentGeneratorExtension">markerContentGeneratorExtension</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.problemFilter">problemFilter</a> （ <a href="#e.selectedType">selectedType</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST problemFilter</p>
<p class="code SchemaDtdAttlist">启用（true | false）</p>
<p class="code SchemaDtdAttlist">范围（ON_ANY | ON_SELECTED_ONLY | ON_SELECTED_AND_CHILDREN | ON_ANY_IN_SAME_CONTAINER）</p>
<p class="code SchemaDtdAttlist">onDescription CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">严重性（错误|警告|信息）</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">问题过滤器是可以应用于问题视图的过滤器。@deprecated in 3.4。使用markerFieldConfiguration并将其绑定到您指定的markerContentGenerator。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>enabled</b> - 默认情况下是否启用此过滤器。如果未指定此值，则值为true。</li>
<li><b>scope</b> - 过滤器的范围。ON_ANY之一：工作台中的任何项目ON_SELECTED_ONLY：当前所选项目ON_SELECTED_AND_CHILDREN：当前所选项目及其子项ON_ANY_IN_SAME_CONTAINER：与选择具有相同顶级容器的任何项目</li>
<li><b>onDescription</b> - 要检查的问题的描述。如果此值前面带有！检查将检查描述是否包含此字符串。</li>
<li><b>severity</b> - 启用此过滤器的问题的严重性。如果未设置此值，则不会按严重性进行过滤。严重性可以是以下值之一：ERROR，WARNING或INFO。</li>
<li><b>name</b> - 过滤器的可读名称。</li>
<li><b>id</b> - 过滤器的唯一ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.selectedType">selectedType</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST selectedType</p>
<p class="code SchemaDtdAttlist">markerId IDREF #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">selectedTypes是此过滤器中默认选择的标记类型的ID。如果没有选定的类型，则启用所有标记类型。默认情况下，禁用此过滤器中未指定的所有类型。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>markerId</b> - 默认情况下启用的标记的ID。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerTypeCategory">markerTypeCategory</a> （ <a href="#e.markerTypeReference">markerTypeReference</a> ）+&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerTypeCategory</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerTypeCategory是用于将标记类型分组到单个类别中的元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>name</b> - 标签是将呈现给用户的可读名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerTypeReference">markerTypeReference</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerTypeReference</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerTypeReference是对使用org.eclipse.core.resources中的扩展点定义的markerType的引用。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -  markerType的id</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerAttributeGrouping">markerAttributeGrouping</a> （ <a href="#e.markerAttributeMapping">markerAttributeMapping</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerAttributeGrouping</p>
<p class="code SchemaDtdAttlist">markerType IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">属性CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">defaultGroupingEntry CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerAttributeGrouping是特定markerType的属性映射的定义。在顶级定义的markerAttributeGroupings仅应用于问题视图以与3.4之前的API兼容。通常建议将markerAttributeGrouping定义为markerGroup的子元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>markerType</b> - 此分组适用的markerType的id。</li>
<li><b>attribute</b> - 该属性是要测试的属性的名称。如果未指定，则仅检查defaultGroupingEntry。</li>
<li><b>defaultGroupingEntry</b> -  defaultGroupingEntry是不满足接收器中任何markerAttributeMappings的分组的可选类别。当属性值与映射不匹配或属性不可用时，将应用此默认值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerGrouping">markerGrouping</a> （ <a href="#e.markerGroupingEntry">markerGroupingEntry</a> ， <a href="#e.markerAttributeGrouping">markerAttributeGrouping</a> *）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerGrouping</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerGrouping是支持它的标记视图的分组criterea的定义。假设顶级标记分组属于问题内容生成器。markerGrouping通常被指定为markerContentGenerator的子节点。如果可能，建议markerContentGenerator定义自己的markerGroupings。请注意，只有问题视图支持markerGroupings 3.4之前。如果markerGrouping具有id org.eclipse.ui.ide.types，则将使用内部类型标记分组。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>label</b> - 标签是人类可读的字符串，用于在此标记分组的Group By-&gt;菜单中创建条目。</li>
<li><b>id</b> -  id是markerGrouping的不可翻译标识符。在markerGroupingEntry中引用。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerAttributeMapping">markerAttributeMapping</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerAttributeMapping</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">markerGroupingEntry CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerAttributeMapping将标记属性映射到名称。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 该值是此映射中使用的属性的值。</li>
<li><b>markerGroupingEntry</b> - 此属性值映射到的markerGroupingEntry的id。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerGroupingEntry">markerGroupingEntry</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerGroupingEntry</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">markerGrouping CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">标签CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">优先级CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerGroupingEntry是markerGrouping中某个条目的规范。顶级markerGroupingEntry只能应用于顶级markerGrouping以与3.4之前的API兼容。建议将markerGroupingEntry指定为markerGrouping的子元素。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -  markerGroupingEntry的id。在markerAttributeGrouping中引用。</li>
<li><b>markerGrouping</b> -  markerGrouping是此条目将添加到的markerGrouping的id。如果将此属性定义为markerGrouping的子元素，则此属性是可选的。</li>
<li><b>label</b> - 条目的可转换标签。</li>
<li><b>priority</b> - 条目的优先级。优先级越高，列表中的优先级越高。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerContentGenerator">markerContentGenerator</a> （ <a href="#e.markerFieldReference">markerFieldReference</a> +， <a href="#e.markerTypeReference">markerTypeReference</a> +， <a href="#e.markerFieldConfiguration">markerFieldConfiguration</a> *， <a href="#e.markerGrouping">markerGrouping</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerContentGenerator</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">defaultMarkerGrouping CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerContentGenerator是org.eclipse.ui.views.markers实例的标记内容的定义。MarkerSupportView。此元素是实验性的，如有更改，恕不另行通知。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -  id属性是markerContentGenerator的唯一ID。</li>
<li><b>name</b> -  name属性是内容生成器的可读名称。</li>
<li><b>defaultMarkerGrouping</b> -  defaultMarkerGrouping是默认情况下要使用的分组的ID。必须将此分组定义为markerContentGenerator的子元素</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerField">markerField</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerField</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">class CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">icon CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">filterClass CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">filterConfigurationClass CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerField是org.eclipse.ui.views.markers的定义。MarkerField用于定义列</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 字段的唯一ID</li>
<li><b>class</b> - 类是用于实例化字段的类型。</li>
<li><b>name</b> - 名称是字段的可读名称。</li>
<li><b>icon</b> - 图标是图标的插件相对路径。</li>
<li><b>filterClass</b> -  filterClass是在启用时对此字段进行过滤的类。如果未指定，则不会根据此字段进行过滤。</li>
<li><b>filterConfigurationClass</b> -  filterConfigurationClass是一个可选区域，用于在过滤器对话框中配置字段。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerFieldReference">markerFieldReference</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerFieldReference</p>
<p class="code SchemaDtdAttlist">id IDREF #REQUIRED</p>
<p class="code SchemaDtdAttlist">visible（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerFieldReference是对markerContentGenerator中markerField的引用。markersView中的列按照指定markerFieldReferences的顺序创建。这也是字段的默认sortOrder。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> -  id是被引用的markerField的id。</li>
<li><b>visible</b> - 可见标志指示接收器是否可见。如果未设置此标志，则值为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerFieldConfiguration">markerFieldConfiguration</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerFieldConfiguration</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">名称CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">范围（ON_ANY | ON_SELECTED_ONLY | ON_SELECTED_AND_CHILDREN | ON_ANY_IN_SAME_CONTAINER）</p>
<p class="code SchemaDtdAttlist">enabled（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerFieldConfiguration是默认情况下要添加到markerContentGenerator的配置的定义，例如Problems视图中的All Errors配置。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 分组的ID。</li>
<li><b>name</b> - 分组的可读名称。</li>
<li><b>values</b> - 值是一个类，它指定要在封闭markerContentGenerator的markerField的filterClass中设置的值。</li>
<li><b>范围</b> - 分组的范围ON_ANY之一：工作台中的任何项目ON_SELECTED_ONLY：当前所选项目ON_SELECTED_AND_CHILDREN：当前所选项目及其子项ON_ANY_IN_SAME_CONTAINER：在与选择具有相同顶级容器的任何项目上。如果未设置此值，则值为ON_ANY</li>
<li><b>enabled</b> - 启用标志确定默认情况下接收器是否已打开。如果未指定此值，则假定为true。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.markerContentGeneratorExtension">markerContentGeneratorExtension</a> （ <a href="#e.markerGrouping">markerGrouping</a> *， <a href="#e.markerFieldConfiguration">markerFieldConfiguration</a> *）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST markerContentGeneratorExtension</p>
<p class="code SchemaDtdAttlist">id CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">generatorId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">markerContentGeneratorExtension是现有markerContentGenerator的扩展。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>id</b> - 接收者的id</li>
<li><b>generatorId</b> - 要扩展的生成器的id</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6>以下是标记支持中的问题过滤器定义的示例。此示例仅显示所选元素及其子元素的java警告，并过滤掉具有字符串NON-NLS的元素<p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.ui.ide.markerSupport”</span> <span class="code SchemaTag">&gt; &lt;problemFilter name =</span> <span class="code SchemaCstring">“Warnings”</span> <span class="code SchemaTag">id =</span> <span class="code SchemaCstring">“org.eclipse.example.warningFilter”</span> <span class="code SchemaTag">enabled =</span> <span class="code SchemaCstring">“true”</span> <span class="code SchemaTag">scope =</span> <span class="code SchemaCstring">“ON_SELECTED_AND_CHILDREN”</span> <span class="code SchemaTag">onDescription =</span> <span class="code SchemaCstring">“！NON-NLS“</span> <span class="code SchemaTag">severity =</span> <span class="code SchemaCstring">”WARNING“</span> <span class="code SchemaTag">&gt; &lt;selectedType markerId =</span> <span class="code SchemaCstring">”org.eclipse.core.resources.problemmarker“</span> <span class="code SchemaTag">/&gt; &lt;/ problemFilter&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6>严重性markerGrouping默认情况下在org.eclipse.ui.ide插件中提供。
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2005,2011 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3104.look-and-feel.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="copyright" content="Copyright (c) 2009, 2019 EclipseSource. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."></meta>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
  <title>RAP的外观和感觉</title>
  <link rel="stylesheet" href="../../../PRODUCT_PLUGIN/book.css" type="text/css"></link>
</head>
<body dir="ltr">

  <h1>RAP的外观和感觉</h1>
  <p>
  <i><strong>注意：</strong>这是关于工作台的交互设计API，而不是控制特定小部件外观的<a href="theming.html">主题</a> API。</i>
  </p>
  <p>RAP提供了一个额外的API来更改工作台应用程序的外观。本文是使用所谓的“交互设计API”来控制WorkbenchWindow外观的分步指南。所有外观和感觉工件都可以捆绑到一个单独的插件中，并在不触及应用程序本身的情况下为现有应用程序做出贡献。
  </p>

  <p>让我们看一下具有自定义外观的RAP应用程序：</p>
  <p>
    <img src="../images/interactiondesign/newLook.png" alt="RAP应用程序与业务主题">
  </p>

  <h2>入门</h2>
  <p>这些是我们将要合作的元素。
  </p>
  <ul>
    <li>WorkbenchWindow组件，例如ToolBar，MenuBar和ViewToolbar。
    </li>
    <li>Stacks的演示文稿，换句话说，视图和编辑器的外观和感觉。稍后您将看到交互设计API如何允许您即时进行独立于堆栈的更改。
    </li>
    <li>图形布局。当您更改应用程序的外观时，通常还需要更改图形布局中的元素，例如移动菜单栏或透视切换器，或选择其他字体。
    </li>
    <li>使用<em>org.eclipse.rap.ui.branding</em>扩展点与入口点关联。
    </li>
    <li>可重复使用的Web组件。诸如应用程序标题之类的元素很可能在其Web版本中重用。布局信息也可以重用于Web组件。因此，开发人员不需要开发许多不同的Web组件，他可以使用下面描述的技术来创建可以在许多应用程序中重用的组件。
    </li>
  </ul>

  <p>最后，对于良好外观和感觉的另一个重要要求是更改交互概念以匹配新UI。为此，API提供了一种称为个性化的自动服务。例如，它默认隐藏所有ViewActions，并使其可见性可自定义。
  </p>

  <h2>WorkbenchWindow组件</h2>
  <p>最好的起点是创建一个PresentationFactory。您需要为<em>org.eclipse.ui.presentationFactories</em>扩展点创建扩展。
  </p>
  <p>
    <img src="../images/interactiondesign/presentationFactoryExt.png" alt="PresentationFactory Extensions">
  </p>
  <p>这与plugin.xml中显示的相同。
  </p>
  <pre class="lang-xml">&lt;extension point =“org.eclipse.ui.presentationFactories”&gt; &lt;factory class =“org.eclipse.rap.presentation.example。PresentationFactoryImpl“id =”org.eclipse.rap.presentation“name =”RAP Presentation“&gt; &lt;/ factory&gt; &lt;/ extension&gt;</pre>

  <p>presentationFactory包含以下属性：</p>
  <ul>
    <li>
      <b>类</b><br>该类引用了<em>org.eclipse.rap.ui.interactiondesign的实现<em>。PresentationFactory</em> 。不要从原始的<em>org.eclipse.ui.presentation扩展是非常重要的<em>。AbstractPresentationFactory</em>作为此类不支持此处描述的概念。
    </li>
    <li>
    <b>名称</b><br>PresentationFacotry实现的可读名称。
    </li>
  </ul>
  <p><em>org.eclipse.rap.ui.interactiondesign。PresentationFactory</em>是抽象的，因此您需要实现其抽象方法。大多数是为不同的管理器创建方法，例如，MenuBar MenuManager或ToolBar的管理器。ToolBar或MenuBar管理器是一个贡献管理器，它在控件中实现自身及其项目。在这些实现中，您可以更改组件的外观，例如使用图标和文本设置工具栏样式或使其透明。
  </p>

  <h2>Stacks的演示文稿</h2>
  <p>如果您不熟悉原始的AbstractPresentationFactory，您可以考虑阅读StackPresentations。您可以在<a href="http://www.eclipse.org/articles/Article-UI-Workbench/workbench.html">Inside the Workbench</a>文章中找到partstack的基本概述。
    <br>可以使用StackPresentations更改partstack的外观。在之前的PresentationFactory中，演示文稿必须以编程方式实现。交互设计API允许您将StackPresentations声明为扩展点<em>org.eclipse.rap.ui.stackPresentations</em>的扩展。<br>
    <img src="../images/interactiondesign/stackPresentationExt.png" alt="StackPresentation扩展">
  </p>
  <p>这与plugin.xml中显示的相同。
  </p>
  <pre class="lang-xml">&lt;extension point =“org.eclipse.rap.ui.stackPresentations”&gt; &lt;stackPresentation id =“org.eclipse.rap.presentation.macBarStackPresentation”class =“org.eclipse.rap.presentation.example.stacks。MacBarStackPresentation“name =”MacBar“type =”view“actionClass =”org.eclipse.rap.presentation.example.configaction。ExampleConfigAction“actionIcon =”icons / configAction.png“menuIcon =”icons / menuIcon.gif“&gt; &lt;/ stackPresentation&gt; &lt;/ extension&gt;</pre>
  <p>
    <b>stackPresentation</b>包含以下属性：</p>
  <ul>
    <li>
      <b>类</b><br>要向后兼容Eclipse 3.4或更早版本，可以实现<em>org.eclipse.ui.presentation。StackPresentation</em> 。但要使用交互设计API的所有功能<em>org.eclipse.rap.ui.interactiondesign。ConfigurableStack</em> 。应该实施。ConfigurableStack是一个抽象类，并提供其他方法，即获取零件的ToolbarManager。<br>零件ToolbarManager包含零件工具栏的所有操作，并添加了个性化功能。要创建干净的UI，所有操作都是不可见的，但用户可以在运行时更改此可见性。<br>ConfigurableStack的另一个好处是能够在运行时更改堆栈的外观而无需重新加载整个应用程序。因此它提供了一个名为<em>setCurrentStackPresentation（String id）的方法</em> 。id应该是扩展中定义的表示的id。当您调用此方法时，您将整个堆栈的表示更改为使用给定ID定义的表示。重新加载自动发生。
    </li>
    <li>
      <b>类型</b><br>堆栈有三种类型。Editor-，view-和standaloneViewStacks。您可以使用以下参数为特定类型定义演示文稿：view，standaloneView，editor。
    </li>
    <li>
      <b>actionClass</b><br>这应该是<em>org.eclipse.rap.ui.interactiondesign的实现<em>。ConfigurationAction</em> 。这是一个提供个性化方法的抽象类。例如，您可以使用它来实现弹出对话框，该对话框允许用户配置viewaction可见性或堆栈的表示。要在ConfigurableStack中应用配置更改，您需要实现接口<em>org.eclipse.rap.ui.interactiondesign。IConfigurationChangedListener</em>并在ConfigurationAction中注册它。
    </li>
    <li>
      <b>actionIcon</b><br>ConfigurationAction可以包含一个可以用作图标的图标，即按钮的图标。该图标与<em>ConfigurationAction</em>相关联。
    </li>
    <li>
      <b>menuIcon</b><br>这是视图菜单的图标，可用于替换标准三角形。要访问此映像，请使用ConfigurableStack中的<em>getMenuIcon（）</em>方法。
    </li>
  </ul>

  <h2>图形布局</h2>
  <p>RAP提供了定义图形布局的功能，您可以在其中控制元素，例如工作台组件的位置，如工具栏，菜单栏或透视切换器。WorkbenchWindowAdvisors <em>createWindowContents（Shell）</em>方法是一种方法，但这种技术的结果是外观和应用程序代码之间的固定耦合。<br>您现在可以使用<em>org.eclipse.rap.ui.interactiondesign分离应用程序代码和外观<em>。IWindowComposer</em>接口。<em>org.eclipse.rap.ui.interactiondesign的实现<em>。PresentationFactory</em>定义了在WorkbenchWindow中调用的<em>createWindowComposer（）</em>方法。这是顾问方法的简单替代，导致应用程序元素之间的松散耦合。<br>为了组织图形，颜色，字体和位置数据等图形布局信息，创建了以下注册表。
    <em>org.eclipse.rap.ui.interactiondesign.layout。LayoutRegistry</em><br>LayoutRegistry是一个单例对象，它包含<em>org.eclipse.rap.ui.interactiondesign.model表示的所有现有布局<em>。布局</em>和<em>org.eclipse.rap.ui.interactiondesign.model。布局集</em> 。可以通过为扩展点<em>org.eclipse.rap.ui.layouts</em>创建扩展来声明布局。<br>
    <img src="../images/interactiondesign/layoutExt.png" alt="布局扩展">
  </p>
  <p>这与plugin.xml中显示的相同。
  </p>
<pre class="lang-xml">&lt;extension point =“org.eclipse.rap.ui.layouts”&gt; &lt;layout id =“org.eclipse.presentation.example.layout”name =“Example Layout”&gt; &lt;layoutSet class =“org.eclipse.rap.presentation .example.layoutset。HeaderLayoutSet2“id =”header.layoutset“name =”Header2“&gt; &lt;/ layoutSet&gt; &lt;/ layout&gt; &lt;/ extension&gt;</pre>
  <p>布局包含以下属性：</p>
  <ul>
    <li>
      <b>ID</b><br>此id可用于从LayoutRegistry获取Layout对象。
    </li>
    <li>
      <b>名称</b><br>此布局的可读名称。
    </li>
  </ul>
  <p>每个布局都可以有多个layoutSets：<br>
    <b>元素layoutSet</b><br>layoutSet是以下类的表示形式： <em>org.eclipse.rap.ui.interactiondesign.layout.model。布局集</em> 。该对象包含上述信息。每个layoutSet最多只有一个Layout作为父级，并具有以下属性：</p>
  <ul>
    <li>
      <b>ID</b><br>此id可用于使用<em>getLayoutSet（String id）</em>方法从Layout获取LayoutSet对象。
    </li>
    <li>
      <b>类</b><br>这应该是以下接口的实现：<br>
      <em>org.eclipse.rap.ui.interactiondesign.layout。ILayoutSetInitializer</em> 。此接口包含一个方法，用于声明LayoutSet对象的布局信息。在LayoutRegistry初始化期间将调用所有IlayoutSetInitializers。
    </li>
    <li>
      <b>overridesId</b><br>此可选属性应为现有LayoutSet标识。它的值将用于覆盖LayoutSet。这很有用，即如果bundle定义了一个提供Logo的LayoutSet。比另一个包可以覆盖此LayoutSet并提供它自己的徽标。
    </li>
  </ul>
  <p>以下是声明性布局的示例用例。<br>按钮应以特定字体显示其文本。您可以在上面描述的扩展上定义布局和layoutSet，而不是直接在源代码中定义字体。让我们先创建两个id。<br>对于Layout = <em>org.eclipse.layout</em><br>对于layoutSet = <em>org.eclipse.layoutSet</em><br>要定义字体，可以在IlayoutSetInitializer实现中调用<em>LayoutSet.addFont（String key，Font font）</em>方法。我们使用“fontKey”作为键值。以下是此字体定义的源代码：</p>
  <pre class="lang-java">按钮=新按钮（复合，SWT.NONE）; LayoutRegistry registry = LayoutRegistry.getInstance（）; registry.setActiveLayout（“org.eclipse.layout”）;布局布局= registry.getActiveLayout（）; LayoutSet set = layout.getLayoutSet（“org.eclipse.layoutSet”）; button.setFont（set.getFont（“fontKey”）;</pre>
  <p>完成此操作的另一种方法是主题，但声明性布局为您提供了更多选项，例如定义图像或位置数据。使用声明性布局的另一大优势是您可以在运行时更改布局。而且，要做到这一点只需两个步骤。
  </p>
  <ol>
    <li>使用layoutSets定义两个布局。layoutSets必须具有与其等效项相同的ID，并且信息的键值必须相同。
    </li>
    <li>在LayoutRegistry中调用<em>setActiveLayout（String id）</em>方法。这会将活动布局设置为具有给定id的布局。将自动调用PresentationFactory并提示重建样式化组件。
    </li>
  </ol>

  <h2>与入口点相关联</h2>
  <p>要将PresentationFactory和Layout与现有入口点相关联，可以使用<a href="branding.html"><em>org.eclipse.rap.ui.branding</em>扩展点</a> 。
  </p>
  <p>
    <img src="../images/interactiondesign/brandingExt.png" alt="品牌延伸">
  </p>
  <p>这与plugin.xml中显示的相同。
  </p>
  <pre class="lang-xml">&lt;extension point =“org.eclipse.rap.ui.branding”&gt; &lt;branding favicon =“icons / perspective.gif”id =“org.eclipse.rap.presentation.macBarBranding”themeId =“org.eclipse.rap.presentation .macBarTheme“title =”Interactiondesign API“&gt; &lt;presentationFactory defaultLayoutId =”org.eclipse.rap.presentation.defaultlayout“id =”org.eclipse.rap.presentation“name =”ConfigurablePF“viewActionsVisible =”true“&gt; &lt;defaultStackPresentation id =“org.eclipse.rap.presentation.navigationPaneStackPresentation”name =“Default”&gt; &lt;/ defaultStackPresentation&gt; &lt;stackPresentation id =“org.eclipse.rap.presentation.macBarStackPresentation”name =“topLeftMapping”partId =“topLeft”&gt; &lt;/ stackPresentation&gt; &lt;/ presentationFactory&gt; &lt;/ branding&gt; &lt;/ extension&gt;</pre>
  <p>如您所见，presentationFactory是品牌扩展的一个元素，具有以下属性：</p>
  <ul>
    <li>
      <b>ID</b><br>这是关联入口点使用的PresentationFactory的id。
    </li>
    <li>
      <b>defaultLayoutId</b><br>此可选参数表示布局的ID。如果未定义id，则应加载标准工作台布局。
    </li>
    <li>
      <b>viewActionsVisible</b><br>此布尔值负责使所有视图贡献项目默认可见（true）或让用户决定哪些项目可见（false）。
    </li>
  </ul>
  <p>presentationFactory元素可以有两个不同的子元素。
  </p>
  <ol>
    <li>
      <b>defaultStackPresentation</b><br>这表示如果没有定义任何其他内容，则为所有部分加载StackPresentation。如果要加载不同的表示，则需要指定StackPresentation的id。
    </li>
    <li>
      <b>stackPresentation</b><br>该元素将stackPresentation与特定部分耦合。id属性应该是要加载的stackPresentation的id。partId表示已在透视图中定义的零件的id。
    </li>
  </ol>

  <h2>可重复使用的Web组件</h2>
  <p>为了设置RAP应用程序的外观样式，还需要许多Web组件。例如，您可能希望将菜单栏放在带圆角的标题上，或将状态行放在样式很好的页脚中。您可以使用SWT Widgets完成此操作，但如果您想重用这些组件，则还需要使用<em>org.eclipse.rap.ui.interactiondesign.layout。ElementBuilder</em> 。ElementBuilder是一个抽象类，它与声明性布局协同工作。您可以扩展它以构建自己的Web组件。<br>这是一个两步过程。
  </p>
  <ol>
    <li>扩展<em>org.eclipse.rap.ui.interactiondesign。ElementBuilder</em>并实现其抽象方法。最重要的方法是<em>build（）</em> 。在调用<em>build（）</em>时，您应该使用SWT小部件构建组件。每个ElementBuilder都与LayoutSet id相关联，该ID将在ElementBuilder实例化期间从LayoutRegsitry获取。在实例化期间，构建器在LayoutRegistry中注册自身。如果激活了新布局，则将调用所有已注册的ElementBuilders中的<em>dispose（）</em>方法。这意味着您需要确保在此方法中正确处置组件。如果没有，则即时切换布局可能无法正常工作。
    </li>
    <li>第二步是实例化ElementBuilder。例如，YourBuilder由以下代码段实例化：<pre class="lang-java">复合父=新复合（aShell，SWT.NONE）; ElementBuilder builder = new YourBuilder（parent，“org.eclipse.layoutSet”）;</pre>确保使用与之关联的layoutSet初始化ElementBuilder实现。
    </li>
  </ol>
  <p>您可能会认识到ElementBuilder背后的想法 - 它基于构建器设计模式。这将组件与应用程序代码分开，允许您在不同位置重用组件。
  </p>
  <p>这完成了我们的交互设计API之旅。如有疑问，请随时在<a href="http://www.eclipse.org/forums/eclipse.technology.rap">RAP论坛中</a>提问。我们也很高兴听到您使用此API的体验，并了解您正在为您的应用构建的新外观。
  </p>

</body>
</html><html id="1466.ch03s26s03.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>3.26.3。�dbtool的参数</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></meta>
<link rel="home" href="../index.html" title="Jubula User Manual"></link>
<link rel="up" href="ch03s26.html" title="3.26.�Using the dbtool client to import, delete and export from the command line"></link>
<link rel="prev" href="ch03s26s02.html" title="3.26.2.�Starting the dbtool"></link>
<link rel="next" href="ch03s27.html" title="3.27.�Dealing with errors in tests: Event Handlers"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">3.26.3。�dbtool的参数</th></tr>
<tr>
<td width="20%" align="left">
<a href="ch03s26s02.html" accesskey="p">上一页</a> �</td>
<th width="60%" align="center">3.26。�使用dbtool客户端从命令行导入，删除和导出</th>
<td width="20%" align="right">� <a href="ch03s27.html" accesskey="n">下一步</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs" xmlns:d="http://docbook.org/ns/docbook">
<span class="breadcrumb-link"><a href="../index.html">Jubula用户手册</a></span> &gt; <span class="breadcrumb-link"><a href="ch03.html">任务</a></span> &gt; <span class="breadcrumb-link"><a href="ch03s26.html">使用dbtool客户端从命令行导入，删除和导出</a></span> &gt; <span class="breadcrumb-node">dbtool的参数</span>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="parameters-for-the-dbtool"></a> 3.26.3。�dbtool的参数</h3></div></div></div>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>浏览到安装目录并输入<span class="input">dbtool后</span> ，可以输入数据库操作的参数。
      </p></li>
<li class="listitem"><p>dbtool使用表中描述的参数（ <a class="xref" href="ch03s26s03.html#dbtoolparams" title="表�.4.4.�dbtool参数">Table�3.4，“dbtool参数”</a> ）：</p></li>
</ol></div>
<p>
    </p>
<div class="table">
<a name="dbtoolparams"></a><div class="table-contents"><table border="1" summary="dbtool parameters">
<colgroup>
<col width="40%" align="left">
<col align="left">
</colgroup>
<thead><tr>
<th align="left">详情</th>
<th align="left">参数</th>
</tr></thead>
<tbody>
<tr>
<td align="left">救命</td>
<td align="left">
              <span class="input">-H</span><br xmlns:d="http://docbook.org/ns/docbook">提供参数帮助</td>
</tr>
<tr>
<td align="left">删除项目</td>
<td align="left">
              <span class="input">-delete &lt;project-name project-version&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-delete“ExampleProject”1.0</em></span><br xmlns:d="http://docbook.org/ns/docbook">有关保留测试结果摘要的信息，请参阅后面的章节（ <a class="xref" href="ch03s26s03.html#keeping-test-result-summaries" title="3.26.3.1。�删除项目但保留测试结果摘要">Section�3.26.3.1，“删除项目但保留测试结果摘要”</a> ）。<br xmlns:d="http://docbook.org/ns/docbook">有关如何输入版本号的信息，请参阅以下部分（ <a class="xref" href="ch03s26s03.html#dbtool-working-with-versions" title="3.26.3.5。�在数据库工具中输入版本号">章节§3.26.3.5，“在数据库工具中输入版本号”</a> ）</td>
</tr>
<tr>
<td align="left">删除所有</td>
<td align="left">
              <span class="input">-删除所有</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-deleteall</em></span><br xmlns:d="http://docbook.org/ns/docbook">有关保留测试结果摘要的信息，请参阅后面的章节（ <a class="xref" href="ch03s26s03.html#keeping-test-result-summaries" title="3.26.3.1。�删除项目但保留测试结果摘要">Section�3.26.3.1，“删除项目但保留测试结果摘要”</a> ）。
            </td>
</tr>
<tr>
<td align="left">保留测试结果摘要</td>
<td align="left">
              <span class="input">-keepsummary</span> （可选）<br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-keepsummary</em></span><br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#keeping-test-result-summaries" title="3.26.3.1。�删除项目但保留测试结果摘要">Section�3.26.3.1，“删除项目但保留测试结果摘要”</a> ）</td>
</tr>
<tr>
<td align="left">删除测试结果摘要</td>
<td align="left">
              <span class="input">-deletesummaries</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-deletesummaries</em></span><br xmlns:d="http://docbook.org/ns/docbook">删除所有测试结果摘要及其详细信息。要指定应删除的特定摘要组及其详细信息，请使用其他参数：-days，-project和-version。<br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-summaries" title="3.26.3.2。�删除测试结果摘要">Section�3.26.3.2，“删除测试结果摘要”</a> ）</td>
</tr>
<tr>
<td align="left">删除测试结果详细信息</td>
<td align="left">
              <span class="input">-deleteresultdetails</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-deleteresultdetails</em></span><br xmlns:d="http://docbook.org/ns/docbook">删除所有测试结果详细信息。测试结果摘要不会被删除。要指定应删除的特定细节组，请使用其他参数：-days，-project和-version。<br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-details" title="3.26.3.3。�删除测试结果详细信息">Section�3.26.3.3，“删除测试结果详细信息”</a> ）</td>
</tr>
<tr>
<td align="left">天</td>
<td align="left">
              <span class="input">-days &lt;days&gt;</span> （可选）<br xmlns:d="http://docbook.org/ns/docbook">例如 - <span class="emphasis"><em>天5</em></span><br xmlns:d="http://docbook.org/ns/docbook">您可以删除比给定天数更早的测试结果摘要或测试结果详细信息。（ <a class="xref" href="ch03s26s03.html#delete-test-result-details" title="3.26.3.3。�删除测试结果详细信息">Section�3.26.3.3，“删除测试结果详细信息”</a> ）<br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-summaries" title="3.26.3.2。�删除测试结果摘要">Section�3.26.3.2，“删除测试结果摘要”</a> ）</td>
</tr>
<tr>
<td align="left">项目</td>
<td align="left">
              <span class="input">-project &lt;project-name&gt;</span> （可选）<br xmlns:d="http://docbook.org/ns/docbook">删除测试结果摘要或项目的详细信息。<br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-project“ExampleProject”</em></span><br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-details" title="3.26.3.3。�删除测试结果详细信息">Section�3.26.3.3，“删除测试结果详细信息”</a> ）<br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-summaries" title="3.26.3.2。�删除测试结果摘要">Section�3.26.3.2，“删除测试结果摘要”</a> ）</td>
</tr>
<tr>
<td align="left">版</td>
<td align="left">
              <span class="input">-version &lt;project-version&gt;</span> （可选）<br xmlns:d="http://docbook.org/ns/docbook">删除测试结果摘要或项目版本的结果。<br xmlns:d="http://docbook.org/ns/docbook">如果定义了项目版本，则必须设置项目名称。<br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-version 1.0</em></span><br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-details" title="3.26.3.3。�删除测试结果详细信息">Section�3.26.3.3，“删除测试结果详细信息”</a> ）<br xmlns:d="http://docbook.org/ns/docbook">（ <a class="xref" href="ch03s26s03.html#delete-test-result-summaries" title="3.26.3.2。�删除测试结果摘要">Section�3.26.3.2，“删除测试结果摘要”</a> ）</td>
</tr>
<tr>
<td align="left">目录</td>
<td align="left">
              <span class="input">-directory &lt;目录路径&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-directory“&lt;pathToQADocs&gt; / projects”</em></span><br xmlns:d="http://docbook.org/ns/docbook">导入和/或导出的目录<br xmlns:d="http://docbook.org/ns/docbook">该目录必须已存在</td>
</tr>
<tr>
<td align="left">出口项目</td>
<td align="left">
              <span class="input">-export &lt;project-name project-version&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-export“ExampleProject”“1.0”</em></span><br xmlns:d="http://docbook.org/ns/docbook">将覆盖具有相同名称的现有文件。<br xmlns:d="http://docbook.org/ns/docbook">有关如何输入版本号的信息，请参阅下面的章节（ <a class="xref" href="ch03s26s03.html#dbtool-working-with-versions" title="3.26.3.5。�在数据库工具中输入版本号">章节§3.26.3.5，“在数据库工具中输入版本号”</a> ）。
            </td>
</tr>
<tr>
<td align="left">全部导出</td>
<td align="left">
              <span class="input">-exportAll</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-exportall</em></span><br xmlns:d="http://docbook.org/ns/docbook">export all的目录必须为空<br xmlns:d="http://docbook.org/ns/docbook">该目录必须已存在</td>
</tr>
<tr>
<td align="left">导入项目</td>
<td align="left">
              <span class="input">-import &lt;import-file&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-import &lt;ExampleProject.jub&gt;</em></span>
            </td>
</tr>
<tr>
<td align="left">创建版本</td>
<td align="left">
              <span class="input">-createVersion &lt;project-name&gt; &lt;old-version&gt; &lt;new-version&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-createVersion“MyProject”“1.0”“1.1”</em></span><br xmlns:d="http://docbook.org/ns/docbook">有关版本控制项目的信息，请参阅： <a class="xref" href="ch03s26s03.html#creating-new-versions" title="3.26.3.4。�创建新版本的项目">Section�3.26.3.4，“创建项目的新版本”</a><br xmlns:d="http://docbook.org/ns/docbook">有关如何输入版本号的信息，请参阅下面的章节（ <a class="xref" href="ch03s26s03.html#dbtool-working-with-versions" title="3.26.3.5。�在数据库工具中输入版本号">章节§3.26.3.5，“在数据库工具中输入版本号”</a> ）。
            </td>
</tr>
<tr>
<td align="left">工作区</td>
<td align="left">
              <span class="input">-data &lt;工作空间的路径&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-data“&lt;pathToQADocs&gt; / workspace”</em></span><br xmlns:d="http://docbook.org/ns/docbook">ITE工作区，具有数据库连接的首选项设置<br xmlns:d="http://docbook.org/ns/docbook">如果输入-dburl参数，则这是可选的</td>
</tr>
<tr>
<td align="left">数据库方案</td>
<td align="left">
              <span class="input">-dbscheme &lt;scheme&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-dbscheme“Oracle”</em></span><br xmlns:d="http://docbook.org/ns/docbook">如果输入-dburl参数，则这是可选的</td>
</tr>
<tr>
<td align="left">数据库用户名</td>
<td align="left">
              <span class="input">-dbuser &lt;username&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-dbuser“username”</em></span><br xmlns:d="http://docbook.org/ns/docbook">对嵌入式数据库使用<span class="input">sa</span> （不带引号）</td>
</tr>
<tr>
<td align="left">数据库密码</td>
<td align="left">
              <span class="input">-dbpw &lt;密码&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-dbpw“密码”</em></span><br xmlns:d="http://docbook.org/ns/docbook">对嵌入式数据库使用&lt;empty&gt;（“”）</td>
</tr>
<tr>
<td align="left">数据库URL（可选）</td>
<td align="left">
              <span class="input">-dburl &lt;URL&gt;</span><br xmlns:d="http://docbook.org/ns/docbook">例如<span class="emphasis"><em>-dburl“db.example.de”</em></span><br xmlns:d="http://docbook.org/ns/docbook">如果没有给出URL，则使用默认值。<br xmlns:d="http://docbook.org/ns/docbook">如果输入此参数，则无需输入<span class="emphasis"><em>-data</em></span>或<span class="emphasis"><em>-dbscheme</em></span>参数<br xmlns:d="http://docbook.org/ns/docbook">您可以在数据库首选项中找到dburl</td>
</tr>
</tbody>
</table></div>
<div class="table-title">表�.4.4.�dbtool参数</div>
</div>
<p><br class="table-break">
   </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="keeping-test-result-summaries"></a> 3.26.3.1。�删除项目但保留测试结果摘要</h4></div></div></div>
<p>您可以使用参数<span class="input">-keepsummary</span>指定在删除项目或项目时不应删除测试结果摘要。这对于持续集成过程非常有用，其中应保留一段时间内的测试结果，但每晚都会将项目重新导入数据库（例如从版本控制系统）。如果未输入此参数，则将使用“项目”删除摘要。
     </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="delete-test-result-summaries"></a> 3.26.3.2。�删除测试结果摘要</h4></div></div></div>
<p>您可以使用参数<span class="input">-deletesummaries</span>指定应删除测试结果摘要。您还可以指定将删除测试结果摘要的项目和版本。使用days参数删除比给定天数更早的测试结果摘要。
     </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="delete-test-result-details"></a> 3.26.3.3。�删除测试结果详细信息</h4></div></div></div>
<p>您可以使用参数<span class="input">-deleteresultdetails</span>指定应删除测试结果详细信息。相关的测试结果摘要不会被删除。您可以指定将删除测试结果详细信息的项目和版本。使用days参数仅删除比给定天数更早的测试结果详细信息。
     </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="creating-new-versions"></a> 3.26.3.4。�创建新版本的项目</h4></div></div></div>
<p>您可以使用dbtool创建数据库中已存在的Project的新版本。您输入项目名称，要创建其副本的版本以及应在其下创建项目的新版本号。create new version命令的功能与ITE中创建新版本选项的功能相同（ <a class="xref" href="ch03s06s11.html" title="3.6.11。�版权项目">Section�3.6.11，“版本控制项目”</a> ）。如果项目不在指定版本的数据库中，或者新版本已存在，则操作将失败。当您确定没有人在使用项目时，我们建议您使用此功能。
     </p>
<p xmlns:d="http://docbook.org/ns/docbook"></p><table>
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><img align="bottom" width="100" height="91" src="../images/img2.jpg"></td>
<td class="topbotline"><span class="strong"><strong>如果您使用的是嵌入式数据库，请参阅有关使用嵌入式数据库和Test Executor的部分，以获取有关使用哪个用户名和密码的信息（ <a class="xref" href="ch03s25s04.html" title="3.25.4。�将测试执行程序与嵌入式数据库一起使用">Section�3.25.4，“将测试执行程序与嵌入式数据库一起使用”</a> ）。
     </strong></span></td>
</tr></tbody>
</table>
<p>输入所有必要参数后，按<span class="input">�ENTER�</span> 。
     </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="dbtool-working-with-versions"></a> 3.26.3.5。�在数据库工具中输入版本号</h4></div></div></div>
<p>您可以输入版本号，例如<span class="emphasis"><em>“1.0.0_release”</em></span>或<span class="emphasis"><em>“1.0”</em></span> 。
     </p>
<p>如果您的版本仅使用限定符，则可以将其输入为<span class="emphasis"><em>“release”</em></span> 。如果您使用的是仅以数字开头的限定符版本，则必须使用前面的下划线（例如<span class="emphasis"><em>“_3”</em></span> ）。
     </p>
</div>
</div>
<br xmlns:d="http://docbook.org/ns/docbook"><hr xmlns:d="http://docbook.org/ns/docbook">
<address xmlns:d="http://docbook.org/ns/docbook">版权所有BREDEX GmbH 2015。根据Eclipse Public License v1.0提供。</address>
<br xmlns:d="http://docbook.org/ns/docbook">
</body>
</html><html id="3176.Combo.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 组合</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">键入组合</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">
        
        <br>扩展<a href="../symbols/Control.html">控制</a> 。<br>RWT脚本编写org.eclipse.swt.widgets。二合一</p>

<!-- ============================== constructor summary ==================== -->
      
      <table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class Combo.">
        <caption>输入摘要</caption>
        <thead>
          <tr>
            <th scope="col">构造函数属性</th>
            <th scope="col">构造函数名称和描述</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="attributes"> </td>
            <td class="nameDescription">
              <div class="fixedFont">
                <b><a href="../symbols/Combo.html#constructor">组合</a></b> （）</div>
              <div class="description">构造函数不公开。</div>
            </td>
          </tr>
        </tbody>
      </table>
      

<!-- ============================== properties summary ===================== -->
      
        
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Widget.html">Widget</a>借来的字段：</dt><dd><a href="../symbols/Widget.html#$el">$埃尔</a></dd>
        </dl>
        
      

<!-- ============================== methods summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class Combo.">
          <caption>方法摘要</caption>
          <thead>
            <tr>
              <th scope="col">方法属性</th>
              <th scope="col">方法名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Combo.html#getSelection">getSelection</a></b> （）</div>
                <div class="description">返回一个数组，其第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Combo.html#getText">getText</a></b> （）</div>
                <div class="description">返回小部件文本。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Combo.html#setSelection">setSelection</a></b> （选择）</div>
                <div class="description">将文本选择设置为数组指定的范围，该数组的第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont"><b><a href="../symbols/Combo.html#setText">setText</a></b> （文本）</div>
                <div class="description">将接收者的文本字段的内容设置为给定的字符串。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>借用<a href="../symbols/Control.html">Control</a>类的方法：</dt><dd><a href="../symbols/Control.html#addListener">addListener</a> ， <a href="../symbols/Control.html#forceFocus">forceFocus</a> ， <a href="../symbols/Control.html#getBackground">getBackground</a> ， <a href="../symbols/Control.html#getCursor">getCursor</a> ， <a href="../symbols/Control.html#getEnabled">getEnabled</a> ， <a href="../symbols/Control.html#getForeground">getForeground</a> ， <a href="../symbols/Control.html#getToolTipText">getToolTipText</a> ， <a href="../symbols/Control.html#getVisible">getVisible</a> ， <a href="../symbols/Control.html#removeListener">removeListener</a> ， <a href="../symbols/Control.html#setBackground">setBackground</a> ， <a href="../symbols/Control.html#setEnabled">setEnabled</a> ， <a href="../symbols/Control.html#setForeground">setForeground</a> ， <a href="../symbols/Control.html#setToolTipText">setToolTipText</a> ， <a href="../symbols/Control.html#setVisible">setVisible</a></dd><dt>从类<a href="../symbols/Widget.html">Widget</a>借来的方法：</dt><dd><a href="../symbols/Widget.html#getData">getData</a> ， <a href="../symbols/Widget.html#setData">setData</a></dd>
        </dl>
        
      
<!-- ============================== events summary ======================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the events documented in the class Combo.">
          <caption>活动摘要</caption>
          <thead>
            <tr>
              <th scope="col">事件属性</th>
              <th scope="col">事件名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Combo.html#event:Modify">修改</a></b>
                </div>
                <div class="description">更改窗口小部件文本时发送</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                  
                  <b><a href="../symbols/Combo.html#event:Verify">校验</a></b>
                </div>
                <div class="description">在更改窗口小部件文本之前发送</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
        <dl class="inheritsList">
        <dt>从类<a href="../symbols/Control.html">Control中</a>借来的事件：</dt><dd><a href="../symbols/Control.html#event:Dispose">Dispose</a> ， <a href="../symbols/Control.html#event:FocusIn">FocusIn</a> ， <a href="../symbols/Control.html#event:FocusOut">FocusOut</a> ， <a href="../symbols/Control.html#event:Hide">Hide</a> ， <a href="../symbols/Control.html#event:KeyDown">KeyDown</a> ， <a href="../symbols/Control.html#event:KeyUp">KeyUp</a> ， <a href="../symbols/Control.html#event:MouseDoubleClick">MouseDoubleClick</a> ， <a href="../symbols/Control.html#event:MouseDown">MouseDown</a> ， <a href="../symbols/Control.html#event:MouseEnter">MouseEnter</a> ， <a href="../symbols/Control.html#event:MouseExit">MouseExit</a> ， <a href="../symbols/Control.html#event:MouseMove">MouseMove</a> ， <a href="../symbols/Control.html#event:MouseUp">MouseUp</a> ， <a href="../symbols/Control.html#event:MouseWheel">MouseWheel</a> ， <a href="../symbols/Control.html#event:Paint">Paint</a> ， <a href="../symbols/Control.html#event:Show">Show</a></dd>
        </dl>
        
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">
            <b>组合</b> （）</div>

        <div class="description">构造函数不公开。
          
        </div>

        


          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          

      </div>
      

<!-- ============================== field details ========================== -->
      

<!-- ============================== method details ========================= -->
      
        <div class="sectionTitle">方法细节</div>
        
          <a name="getSelection"> </a>
          <div class="fixedFont">

          <span class="light">{int []}</span> <b>getSelection</b> （）</div>
          <div class="description">返回一个数组，其第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。“空”选择由相同的值表示。
<p>索引是基于零的。选择的范围是0 ..N其中N是小部件中的字符数。
</p>
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{int []}</span>数组表示选择的开始和结束</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="getText"> </a>
          <div class="fixedFont">

          <span class="light">{string}</span> <b>getText</b> （）</div>
          <div class="description">返回小部件文本。
            
          </div>

          

            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">返回：</dt>
              
                <dd><span class="light fixedFont">{string}</span>小部件文本</dd>
              
              </dl>
            
            
            

          <hr>
        
          <a name="setSelection"> </a>
          <div class="fixedFont">

          
          <b>setSelection</b> （选择）</div>
          <div class="description">将文本选择设置为数组指定的范围，该数组的第一个值是表示所选文本开头的字符位置，第二个值是表示选择结束的字符位置。“空”选择由相同的值表示。
<p>索引是基于零的。选择的范围是0 ..N其中N是小部件中的字符数。
</p><p>文本选择根据插入符号位置指定。在包含N个字符的文本小部件中，有N + 1个插入符号位置，范围从0开始。N.这与解决字符位置的其他函数（例如使用常用数组索引规则的getText（））不同。
</p>
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{int []}</span> <b>选择</b>
                  
                </dt>
                <dd>表示选择开始和结束的数组</dd>
              
              </dl>
            
            
            
            
            
            
            

          <hr>
        
          <a name="setText"> </a>
          <div class="fixedFont">

          
          <b>setText</b> （文本）</div>
          <div class="description">将接收者的文本字段的内容设置为给定的字符串。
<p>注意： <code>Combo</code>的文本字段通常只能显示单行文本。因此，将文本设置为包含换行符或其他特殊字符的字符串可能会导致它显示不正确。
</p>
            
          </div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{string}</span> <b>文字</b>
                  
                </dt>
                <dd>新文本</dd>
              
              </dl>
            
            
            
            
            
            
            

          
        
      

<!-- ============================== event details ========================= -->
      
        <div class="sectionTitle">活动详情</div>
        
          <a name="event:Modify"> </a>
          <div class="fixedFont">

          
          <b>修改</b>

          </div>
          <div class="description">更改窗口小部件文本时发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Modify">SWT.Modify</a></dd>
              
              </dl>
            

          <hr>
        
          <a name="event:Verify"> </a>
          <div class="fixedFont">

          
          <b>校验</b>

          </div>
          <div class="description">在更改窗口小部件文本之前发送</div>

          

            
              <dl class="detailList">
              <dt class="heading">参数：</dt>
              
                <dt>
                  <span class="light fixedFont">{ <a href="../symbols/Event.html">Event</a> }</span> <b>事件</b>
                  
                </dt>
                <dd></dd>
              
              </dl>
            
            
            
            
            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
                <dd><a href="../symbols/SWT.html#.Verify">SWT.Verify</a></dd>
              
              </dl>
            

          
        
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="3352.Implementing-a-New-Trace-Type.html" dir="ltr"></html><html dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
		<title>Trace Compass开发人员指南 - 实现新的跟踪类型</title>
		<link type="text/css" rel="stylesheet" href="book.css"></link>
	</head>
	<body dir="ltr">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<th align="center" colspan="3" style="width:100%">实现新的跟踪类型</th>
			</tr>
			<tr>
				<td align="left" style="width:20%">
					<a href="Introduction.html" title="介绍">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%"></td>
				<td align="right" style="width:20%">
					<a href="View-Tutorial.html" title="查看教程">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">介绍</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">查看教程</td>
			</tr>
		</table><hr class="navigation-separator">
		<h1 id="Implementing_a_New_Trace_Type">实现新的跟踪类型</h1>
		<p>可以轻松扩展该框架以支持更多跟踪类型。要创建新的跟踪类型，必须定义以下项：</p>
		<ul>
			<li>事件类型</li>
			<li>跟踪类型</li>
			<li>跟踪上下文</li>
			<li>跟踪位置</li>
			<li><i>org.eclipse.linuxtools.tmf.core.tracetype</i>插件扩展点</li>
			<li>（可选） <i>org.eclipse.linuxtools.tmf.ui.tracetypeui</i>插件扩展点</li>
		</ul>
		<p><b>事件类型</b>必须实现<i>ITmfEvent</i>或扩展实现的<i>ITmfEvent</i>类。通常它会扩展<i>TmfEvent</i> 。事件类型必须包含事件的所有数据。
		</p>
		<p><b>跟踪类型</b>必须是<i>ITmfTrace</i>类型。<i>TmfTrace</i>类将提供许多后台操作，以便读者只需要实现某些功能。这包括此跟踪类型事件的<i>事件方面</i> 。请参阅以下部分。
		</p>
		<p><b>跟踪上下文</b>可以看作迭代器的内部。跟踪读取器需要在迭代跟踪时解析事件并跟踪其等级和位置。它可以有时间戳，等级，文件位置或任何其他元素，它应该被认为是短暂的。
		</p>
		<p><b>跟踪位置</b>是经常克隆以存储检查点的元素，通常是持久性的。它用于重建上下文，因此，它需要包含足够的信息以明确指向一个且仅一个事件。最后， <i>tracetype</i>插件扩展将给定跟踪以非编程方式与跟踪类型相关联，以便在UI中使用。</p>
		<h2 id="Event_Aspects">事件方面</h2>
		<p>在Trace Compass中， <i>事件方面</i>表示可以从跟踪事件中提取的任何类型的信息。简单的情况是直接出现在事件中的信息。例如，事件的时间戳，LTTng事件的字段或文本跟踪条目的同一行上的“有效负载”。但它也可能是间接操作的结果，例如在给定事件的时间戳处的状态系统查询（请参阅<a href="Generic-State-System.html#Generic_State_System">通用状态系统</a>部分）。
		</p>
		<p>所有方面都应该实现<b>ITmfEventAspect</b>接口。其中重要的方法是<i>resolve（ITmfEvent）</i> ，它告诉这个方面给定事件的输出内容。一般而言，单例模式非常适合预定义的方面类。
		</p>
		<p>为跟踪类型定义的方面确定事件表中的初始列，以及可以过滤跟踪的元素等。</p>
		<h3 id="Base_and_custom_aspects">基础和自定义方面</h3>
		<p>一些基本方面在<b>TmfTrace＃BASE_ASPECTS</b>中定义。它们使用<b>ITmfEvent中的</b>通用方法，因此它们应适用于框架中定义的任何事件类型。如果没有覆盖<b>TmfTrace＃getEventAspects</b> ，那么只有基本方面将与此跟踪一起使用。
		</p>
		<p>覆盖该方法不会附加到此列表，它将替换它。因此，如果您希望为新的跟踪类型定义其他方面，请不要忘记在列表中包含要使用的BASE_ASPECTS（如果有）。</p>
		<p>返回的<i>Iterable中</i>元素的顺序可能与其他组件有关。例如，事件表中列的初始排序将与之匹配。
		</p>
		<p>定义其他方面允许从跟踪事件中公开更多数据，而无需使用方面API更新所有视图。</p>
		<h3 id="Creating_event_aspects_programmatically">以编程方式创建事件方面</h3>
		<p>事件方面的另一个优点是它们可以通过编程方式创建，而无需修改基本跟踪或事件类。应用于预先存在的跟踪类型的新分析可能希望定义其他方面以使其工作更容易。</p>
		<p>虽然事件方面的概念不应直接暴露给用户，但可以根据用户输入创建新方面。例如，“事件字段”对话框可以要求用户输入字段名称，然后创建一个方面，该方面将在每个事件中查找具有此名称的字段的值。然后，用户可以在这方面显示或过滤。</p>
		<h2 id="Optional_Trace_Type_Attributes">可选的跟踪类型属性</h2>
		<p>在按照前面章节中的描述定义跟踪类型后，可以为跟踪类型定义可选属性。</p>
		<h3 id="Default_Editor">默认编辑器</h3>
		<p><b>org.eclipse.linuxtools.tmf.ui.tracetypeui</b>扩展点的<b>defaultEditor</b>属性允许配置编辑器以用于显示事件。如果省略，则默认使用<i>TmfEventsEditor</i> 。
		</p>
		<p>要配置编辑器，首先将<b>defaultEditor</b>属性添加到扩展定义中的跟踪类型。这可以通过在插件清单编辑器中选择跟踪类型来完成。然后单击鼠标右键并在上下文相关菜单中选择<b>New  - &gt; defaultEditor</b> 。然后选择新添加的属性。现在，您可以在清单编辑器的右侧指定要使用的编辑器ID。例如，此属性可用于实现类<i>org.eclipse.ui.part的扩展<i>。MultiPageEditor</i> 。第一页可以使用<i>TmfEventsEditor</i> '像往常一样显示表中的事件，其他页面可以显示跟踪的其他方面。
		</p>
		<h3 id="Events_Table_Type">事件表类型</h3>
		<p><b>org.eclipse.linuxtools.tmf.ui.tracetypeui</b>扩展点的<b>eventsTableType</b>属性允许配置要在默认事件编辑器中使用的事件表类。如果省略，将使用默认事件表。
		</p>
		<p>要配置跟踪类型特定事件表，请首先将<b>eventsTableType</b>属性添加到扩展定义中的跟踪类型。这可以通过在插件清单编辑器中选择跟踪类型来完成。然后单击鼠标右键并在上下文相关菜单中选择<b>New  - &gt; eventsTableType</b> 。然后选择新添加的属性，并单击清单编辑器右侧的<i>类</i> 。新的类向导将打开。<i>超类</i>字段已经填充了类<i>org.eclipse.tracecompass.tmf.ui.viewers.events。TmfEventsTable</i> 。
		</p>
		<p>通过使用此属性，可以定义具有与默认列不同的列的表。请参阅类<i>org.eclipse.tracecompass.internal.gdbtrace.ui.views.events。GdbEventsTable</i>用于示例实现。
		</p>
		<h3 id="Perspective">透视</h3>
		<p><b>org.eclipse.linuxtools.tmf.ui.tracetypeui</b>扩展点的<b>透视</b>元素允许配置与跟踪类型关联的默认透视图。如果省略，将使用当前透视图。
		</p>
		<p>要配置关联的透视图，首先将<b>perspective</b>元素添加到扩展定义中的跟踪类型。这可以通过在插件清单编辑器中选择跟踪类型来完成。然后单击鼠标右键并在上下文相关菜单中选择“ <b>新建” - &gt;“透视</b> ”。然后选择新添加的元素并选择清单编辑器右侧的<i>id</i>文本字段。输入关联的透视ID，可以在定义透视的<b>org.eclipse.ui.perspectives</b>扩展中找到。
		</p>
		<p>通过使用此元素，当打开此跟踪类型的跟踪时，工作台将切换到关联的透视图。可以通过用户对话框或首选项控制此行为。</p>
		<h2 id="Other_Considerations">其他考虑因素</h2>
		<p>其他视图和组件可以提供仅在事件或跟踪类型类实现某些附加接口时才处于活动状态的其他功能。</p>
		<h3 id="Collapsing_of_repetitive_events">折叠重复事件</h3>
		<p>通过实现接口<i>org.eclipse.tracecompass.tmf.core.event.collapse。ITmfCollapsibleEvent</i>事件表将允许通过在表格中按下鼠标右键后选择菜单项“ <b>折叠事件”</b>来折叠重复事件。
		</p>
		<h2 id="Best_Practices">最佳实践</h2>
		<ul>
			<li>不要将整个跟踪加载到RAM中，它将限制可以读取的跟踪的大小。</li>
			<li>重用尽可能多的代码，使跟踪格式更容易维护。</li>
			<li>使用Eclipse的编辑器而不是直接编辑XML。</li>
			<li>不要忘记Java只支持签名数据类型，处理无符号数据可能需要特别小心。</li>
			<li>如果对跟踪的支持具有自定义UI元素（如图标，视图等），请将核心和UI部分拆分为单独的插件，名称相同，但<i>.core</i>或<i>.ui</i>后缀除外。
				<ul>
					<li>在核心插件中实现<i>tmf.core.tracetype</i>扩展，并在UI插件中实现<i>tmf.ui.tracetypeui</i>扩展（如果适用）。
					</li>
				</ul>
			</li>
		</ul>
		<h2 id="An_Example:_Nexus-lite_parser">示例：Nexus-lite解析器</h2>
		<h3 id="Description_of_the_file">文件描述</h3>
		<p>这是nexus跟踪格式的一个非常小的子集，有一些更改使其更易于阅读。有一个文件。此文件以包含事件名称的64个字符串开头，然后是任意大量的事件。事件每个都是64位长。前32个是以微秒为单位的时间戳，第二个32分为事件类型的6比特，数据有效载荷分为26比特。</p>
		<p>跟踪类型将由两部分组成，第1部分是事件描述，它只是64个字符串，逗号分隔，然后是换行符。</p>
		<pre>启动，停止，加载，添加，...，保留\ n</pre>
		<p>然后会有这种格式的事件</p>
		<table>
			<tr>
				<td style="width:50%;background-color:#ffffcc">时间戳（32位）</td>
				<td style="width:10%;background-color:#ffccff">类型（6位）</td>
				<td style="width:40%;background-color:#ccffcc">有效载荷（26位）</td>
			</tr>
			<tr>
				<td colspan="3" style="background-color:#ffcccc">总共64位</td>
			</tr>
		</table>
		<p>所有事件的大小都相同（64位）。</p>
		<h3 id="NexusLite_Plug-in">NexusLite插件</h3>
		<p>创建一个<b>New</b> ， <b>Project ...</b> ， <b>Plug-in Project</b> ，将标题设置为<b>com.example.nexuslite</b> ，单击<b>Next&gt;</b>然后单击<b>Finish</b> 。
		</p>
		<p>现在设置了Nexus跟踪插件的结构。</p>
		<p>通过在<b>META-INF中</b>打开<b>MANIFEST.MF</b> ，选择<b>Dependencies</b>选项卡并<b>添加...</b> ，为TMF核心和UI <b>添加</b> <b>依赖关系</b>

			<b>org.eclipse.tracecompass.tmf.core</b>和<b>org.eclipse.tracecompass.tmf.ui</b> 。
		</p>
		<p>
			<img border="0" src="images/NTTAddDepend.png">
			<br>

			<img border="0" src="images/NTTSelectProjects.png">
			<br>
		</p>
		<p>现在该项目可以访问TMF类。</p>
		<h3 id="Trace_Event">跟踪事件</h3>
		<p><b>TmfEvent</b>类适用于此示例。无需代码。
		</p>
		<h3 id="Trace_Reader">跟踪阅读器</h3>
		<p>跟踪阅读器将扩展<b>TmfTrace</b>类。
		</p>
		<p>它需要实现：</p>
		<ul>
			<li>验证（跟踪格式是否有效？）</li>
		</ul>
		<ul>
			<li>initTrace（称为跟踪打开）</li>
		</ul>
		<ul>
			<li>seekEvent（转到跟踪中的位置并创建上下文）</li>
		</ul>
		<ul>
			<li>getNext（在基类中实现）</li>
		</ul>
		<ul>
			<li>parseEvent（读取跟踪中的下一个元素）</li>
		</ul>
		<p>作为参考，org.eclipse.tracecompass.tracing.examples.core.trace.nexus中有一个Nexus Trace文件的示例实现。NexusTrace.java。</p>
		<p>在此示例中， <b>validate</b>函数首先检查文件是否存在，然后确保它确实是文件，而不是目录。然后我们尝试读取文件头，以确保它真的是一个Nexus Trace。如果该检查通过，我们返回一个置信度为20的TraceValidationStatus。
		</p>
		<p>通常，TraceValidationStatus置信度应该在1到100之间.1表示“此跟踪具有此类型的可能性非常小”，100表示“它确实是这种类型，并且不能是其他任何东西”。在运行时，自动检测将选择返回最高置信度的类型。因此检查类型“文件是否存在？“不应该回报过高的信心。如果返回置信度0，则自动检测不会选择此类型。</p>
		<p>在这里，我们使用20的置信度，为Nexus格式中可以在TMF中定义的更具体的跟踪类型留出“空间”。</p>
		<p><b>initTrace</b>函数将读取事件名称，并查找数据的开始位置。在此之后，事件的数量是已知的，并且由于每个事件根据规范是8字节长，因此搜索是微不足道的。
		</p>
		<p>此处的<b>搜索</b>只会将阅读器重置到正确的位置。
		</p>
		<p><b>parseEvent</b>方法需要解析并返回当前事件并存储当前位置。
		</p>
		<p><b>getNext</b>方法（在基类中）将读取下一个事件并更新上下文。它调用<b>parseEvent</b>方法来读取事件并更新位置。它不需要被覆盖，在这个例子中它不是。必要的操作序列是从跟踪解析下一个事件，使用该数据创建<b>ITmfEvent</b> ，更新当前位置，调用<b>updateAttributes</b> ，更新上下文然后返回事件。
		</p>
		<p>跟踪通常会实现索引，以便更快地进行搜索。每次打开跟踪时都可以重建索引。或者，它可以保存到磁盘，以便将来更快地打开相同的跟踪。为此，trace对象可以实现<b>ITmfPersistentIndexable</b>接口。
		</p>
		<h3 id="Trace_Context">跟踪上下文</h3>
		<p>跟踪上下文将是<b>TmfContext</b> 。
		</p>
		<h3 id="Trace_Location">跟踪位置</h3>
		<p>跟踪位置将是一个长，表示文件中的排名。<b>TmfLongLocation</b>将被使用，再一次，不需要代码。
		</p>
		<h3 id="The_.27.27org.eclipse.linuxtools.tmf.core.tracetype.27.27_and_.27.27org.eclipse.linuxtools.tmf.ui.tracetypeui.27.27_plug-in_extension_points"><i>org.eclipse.linuxtools.tmf.core.tracetype</i>和<i>org.eclipse.linuxtools.tmf.ui.tracetypeui</i>插件扩展点</h3>
		<p>应该在自己的插件中使用<i>tmf.core.tracetype</i>扩展点。在此示例中，将修改Nexus跟踪插件。
		</p>
		<p>如果希望用户访问给定的事件类型，则需要更新ui插件中的<b>plugin.xml</b>文件。它可以在Eclipse插件编辑器中更新。
		</p>
		<ol>
			<li>在Extensions选项卡中，添加<b>org.eclipse.linuxtools.tmf.core.tracetype</b>扩展点。
			</li>
		</ol>
		<p>
			<img border="0" src="images/NTTExtension.png">
			<br>

			<img border="0" src="images/NTTTraceType.png">
			<br>

			<img border="0" src="images/NTTExtensionPoint.png">
			<br>
		</p>
		<ol>
			<li>在<b>org.eclipse.linuxtools.tmf.ui.tracetype</b>扩展中添加一个新类型。为此， <b>右键单击</b>扩展，然后在上下文菜单中，转到<b>新建&gt;</b> ， <b>键入</b> 。
			</li>
		</ol>
		<p>
			<img border="0" src="images/NTTAddType.png">
			<br>
		</p>
		<p><b>id</b>是用于引用跟踪的唯一标识符。
		</p>
		<p><b>名称</b>是选择跟踪类型时应显示的字段。
		</p>
		<p><b>跟踪类型</b>是引用<b>跟踪类</b>的规范路径。
		</p>
		<p><b>事件类型</b>是指向给定跟踪的<b>事件类</b>的规范路径。
		</p>
		<p><b>类别</b> （可选）是将存储此跟踪类型的容器。
		</p>
		<ol>
			<li>（可选）要将特定于UI的属性添加到跟踪类型，请使用<b>org.eclipse.linuxtools.tmf.ui.tracetypeui</b>扩展名。为此， <b>右键单击</b>扩展，然后在上下文菜单中，转到<b>新建&gt;</b> ， <b>键入</b> 。
			</li>
		</ol>
		<p>这里的<b>tracetype</b>是上面提到的<i>org.eclipse.linuxtools.tmf.core.tracetype</i>的<b>id</b> 。
		</p>
		<p><b>图标</b>是与该跟踪类型关联的图像。
		</p>
		<p>最后，扩展菜单应如下所示。</p>
		<p>
			<img border="0" src="images/NTTPluginxmlComplete.png">
			<br>
		</p><hr class="navigation-separator">
		<table class="navigation" border="0" style="width:100%" summary="navigation">
			<tr>
				<td align="left" style="width:20%">
					<a href="Introduction.html" title="介绍">
						<img alt="以前" border="0" src="images/prev.gif">
					</a>
				</td>
				<td align="center" style="width:60%">
					<a href="Developer-Guide.html" title="Trace Compass开发人员指南">
						<img alt="Trace Compass开发人员指南" border="0" src="images/home.gif">
					</a>
				</td>
				<td align="right" style="width:20%">
					<a href="View-Tutorial.html" title="查看教程">
						<img alt="下一个" border="0" src="images/next.gif">
					</a>
				</td>
			</tr>
			<tr>
				<td align="left" valign="top" style="width:20%">介绍</td>
				<td align="center" style="width:60%"></td>
				<td align="right" valign="top" style="width:20%">查看教程</td>
			</tr>
		</table>
	</body>
</html><html id="2746.org_eclipse_core_resources_variableResolvers.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<title>路径变量解析器</title>
<style type="text/css"></style>
<style type="text/css"></style>
</head>
<body dir="ltr">
<h1 style="text-align:center">路径变量解析器</h1>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">标识符：</h6>org.eclipse.core.resources.variableResolvers<p></p>
<h6 class="CaptionFigColumn SchemaHeader">以来：</h6>3.6<p></p>

<h6 class="CaptionFigColumn SchemaHeader">描述：</h6>变量解析器扩展了项目路径变量的默认列表，可用于指定链接资源的相对位置。<p>
</p>
<p></p>
<h6 class="CaptionFigColumn SchemaHeader">配置标记：</h6>
<p></p>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.variableResolver">variableResolver</a> +）&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST扩展</p>
<p class="code SchemaDtdAttlist">点CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">id CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.variableResolver">variableResolver</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST variableResolver</p>
<p class="code SchemaDtdAttlist">class CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<ul class="ConfigMarkupAttlistDesc">
<li><b>class</b> - 动态提供变量值的类。</li>
<li><b>value</b> - 变量的值，可以是引用另一个变量，也可以是绝对路径。</li>
<li><b>variable</b> - 支持的变量的前缀。我们将来可以使用通配符。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.enablement">启用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">调整</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通用根元素。可以在扩展点内使用该元素来定义其启用表达式。使用“和”运算符组合启用表达式的子项。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.not">not</a> （ <a href="#e.not">not</a> | <a href="#e.and">and</a> | <a href="#e.or">or</a> | <a href="#e.instanceof">instanceof</a> | <a href="#e.test">test</a> | <a href="#e.systemTest">systemTest</a> | <a href="#e.equals">equals</a> | <a href="#e.count">count</a> | <a href="#e.with">with</a> | <a href="#e.resolve">resolve</a> | <a href="#e.adapt">adapt</a> | <a href="#e.iterate">iterate</a> | <a href="#e.reference">reference</a> ）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其子元素表达式求值结果的NOT运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！元<a name="e.and">和</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的AND运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT <a name="e.or">或</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素表示对其所有子元素表达式求值结果的OR运算。</p>
<br><br>
<p class="code SchemaDtd">&lt;！ELEMENT的EMPTY <a name="e.instanceof">实例</a> &gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST的实例</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的检查实例。表达式返回EvaluationResult。如果对象的类型是属性值指定的类型的子类型，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 类或接口的完全限定名称。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.test">测试</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST测试</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">值CDATA #IMPLIED</p>
<p class="code SchemaDtdAttlist">forcePluginActivation（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于评估焦点对象的属性状态。可以使用<b>org.eclipse.core.expressions.propertyTesters</b>扩展点扩展可测试属性集。测试表达式返回EvaluationResult。NOT_LOADED如果尚未加载执行实际测试的属性测试器且属性forcePluginActivation设置为false。如果forcePluginActivation设置为true并且用于评估此表达式的评估上下文支持插件激活，则评估该属性将导致激活定义测试器的插件。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的对象<b>属性</b>的名称。</li>
<li><b>args</b> - 传递给属性测试器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
<li><b>value</b> - 属性的预期值。如果属性是布尔属性，则可以省略（值将为布尔值。真正）。测试表达式应该返回EvaluationResult。如果属性与值和EvaluationResult匹配，则为TRUE。否则为FALSE。使用以下规则将value属性转换为Java基类型：<ul>
 <li>字符串“true”转换为布尔值。真正</li>
 <li>字符串“false”被转换为布尔值。假</li>
 <li>如果字符串包含点，则解释器会尝试将值转换为Float对象。如果失败，则将字符串视为java.lang。串</li>
 <li>如果字符串只包含数字，则解释器将值转换为Integer对象。</li>
 <li>在所有其他情况下，该字符串被视为java.lang。串</li>
 <li>可以通过用单引号包围字符串来抑制将字符串转换为布尔值，浮点数或整数。例如，属性值=“'true'”被转换为字符串“true”</li>
</ul></li>
<li><b>forcePluginActivation</b> - 一个标志，指示是否应在必要时加载提供属性测试器的插件。因此，应谨慎使用此标志，以避免不必要的插件激活。大多数客户应避免将此标志设置为true。仅当用于评估此表达式的评估上下文允许插件激活时，才会使用此标志。否则，将忽略该标志，并且不会发生插件加载。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.systemTest">systemTest</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST systemTest</p>
<p class="code SchemaDtdAttlist">属性CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">通过调用System.getProperty方法测试系统属性，并将结果与value属性指定的值进行比较。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>property</b> - 要测试的系统属性的名称。</li>
<li><b>value</b> - 属性的预期值。该值被解释为字符串值。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.equals">等于</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST等于</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于执行焦点对象的等号检查。表达式返回EvaluationResult。如果对象等于属性值提供的值，则为TRUE。否则EvaluationResult。返回FALSE。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 预期值。作为字符串提供的值将使用与测试表达式的value属性相同的规则转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.count">count</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST计数</p>
<p class="code SchemaDtdAttlist">值CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于测试集合中的元素数。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>value</b> - 一个表达式，用于指定列表中的元素数。可以使用以下通配符：<dl>
                    <dt>*</dt> <dd>任意数量的元素</dd>
                    <dt>？</dt> <dd>没有元素或一个元素</dd>
                    <dt>+</dt> <dd>一个或多个元素</dd>
                    <dt>！</dt> <dd>没有元素</dd>
                    <dt>- <i>N</i> ）</dt>
                    <dd>少于<i>N个</i>元素</dd>
                    <dt>（ <i>N</i> -</dt>
                    <dd>大于<i>N个</i>元素</dd>
                    <dt>整数值</dt> <dd>列表必须包含确切的元素数</dd>
                  </dl></li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.with">用</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST用</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。with表达式的子项使用“and”运算符组合。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>变量</b> - 用于进一步检查的变量的名称。由扩展点的求值程序决定是否在变量池中提供变量。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.resolve">决心</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">的instanceof</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">用</a> ， <a href="#e.resolve">解决</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">重复</a> ， <a href="#e.reference">参考</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST决心</p>
<p class="code SchemaDtdAttlist">变量CDATA #REQUIRED</p>
<p class="code SchemaDtdAttlist">args CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素将要检查的对象的所有子元素更改为给定变量引用的对象。如果无法解析变量，则表达式将在计算时抛出ExpressionException。使用“和”运算符组合解析表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>variable</b> - 要解析的变量的名称。然后将此变量用作子元素评估的焦点对象。在评估表达式时，由扩展点的求值程序通过传递给根表达式元素的求值上下文提供相应的变量解析器（请参阅IVariableResolver）。</li>
<li><b>args</b> - 传递给变量解析器的其他参数。多个参数用逗号分隔。使用与为测试表达式的value属性定义的相同规则将每个单独的参数转换为Java基类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.adapt">适应</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或者</a> ， <a href="#e.instanceof">实例</a> ， <a href="#e.test">测试</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">等于</a> ， <a href="#e.count">计数</a> ， <a href="#e.with">使用</a> ， <a href="#e.resolve">解析</a> ， <a href="#e.adapt">适应</a> ， <a href="#e.iterate">迭代</a> ， <a href="#e.reference">引用</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST适应</p>
<p class="code SchemaDtdAttlist">键入CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于使焦点对象适应属性类型指定的类型。表达式返回EvaluationResult。如果尚未加载适配器或引用的类型，则为NOT_LOADED。如果类型名称根本不存在，它会在评估期间抛出ExpressionException。使用“和”运算符组合适应表达式的子项。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>type</b> - 要调整焦点对象的类型。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.iterate">迭代</a> （ <a href="#e.not">不</a> ， <a href="#e.and">和</a> ， <a href="#e.or">或</a> ， <a href="#e.instanceof">instanceof</a> ， <a href="#e.test">test</a> ， <a href="#e.systemTest">systemTest</a> ， <a href="#e.equals">equals</a> ， <a href="#e.count">count</a> ， <a href="#e.with">with</a> ， <a href="#e.resolve">resolve</a> ， <a href="#e.adapt">adapt</a> ， <a href="#e.iterate">iterate</a> ， <a href="#e.reference">reference</a> ）*&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST迭代</p>
<p class="code SchemaDtdAttlist">运算符（或|和）</p>
<p class="code SchemaDtdAttlist">ifEmpty（true | false）&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于迭代java.util类型的变量。集合，或适应org.eclipse.core.expressions的变量。IIterable。如果焦点对象不是上述对象之一，则在计算表达式时将抛出带有ExpressionStatus的CoreException。使用“and”运算符组合迭代表达式的子表达式。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>运算符</b> - “和”或“或”。运算符定义如何组合应用于Collection或IIterable的每个子节点的所有子表达式的结果以及将使用什么（如果有）短路评估。如果未指定，将使用“和”。</li>
<li><b>ifEmpty</b> - 如果集合为空，则从“iterate”表达式返回的值。如果未指定则为EvaluResult。当运算符等于“和”和EvaluationResult时，返回TRUE。如果运算符等于“或”，则返回FALSE。</li>
</ul>
<br><p class="code SchemaDtd">&lt;！ELEMENT <a name="e.reference">参考</a> EMPTY&gt;</p>
<p class="code SchemaDtd">&lt;！ATTLIST参考</p>
<p class="code SchemaDtdAttlist">definitionId IDREF #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkupElementDesc">此元素用于引用<b>org.eclipse.core.expressions.definitions</b>扩展点中的表达式。将使用当前评估上下文在当前表达式元素中计算表达式定义。</p>
<br>
<ul class="ConfigMarkupAttlistDesc">
<li><b>definitionId</b> - <b>org.eclipse.core.expressions.definitions中</b>表达式的唯一ID。</li>
</ul>
<br><h6 class="CaptionFigColumn SchemaHeader">例子：</h6><p>
</p><pre class="Example"><span class="code SchemaTag">&lt;extension point =</span> <span class="code SchemaCstring">“org.eclipse.core.resources.variableResolvers”</span> <span class="code SchemaTag">&gt; &lt;variableResolver class =</span> <span class="code SchemaCstring">“org.eclipse.core.internal.resources.projectVariables。EclipseHomeProjectVariable“</span> <span class="code SchemaTag">name =</span> <span class="code SchemaCstring">”ECLIPSE_HOME“</span> <span class="code SchemaTag">&gt; &lt;/ variableResolver&gt; &lt;/ extension&gt;</span></pre>

<p></p>

<h6 class="CaptionFigColumn SchemaHeader">API信息：</h6>class属性的值必须表示<tt>org.eclipse.core.resources的子类<tt>。PathVariableResolver</tt> 。
<p></p>

<h6 class="CaptionFigColumn SchemaHeader">提供的实施：</h6><tt>org.eclipse.core.resources</tt>包为以下变量提供解析器： <tt>ECLIPSE_HOME</tt> ， <tt>PROJECT_LOC</tt> ， <tt>WORKSPACE_LOC</tt>和<tt>PARENT</tt>
<p></p>

<br>
<p class="note SchemaCopyright">版权所有（c）2008,2010 IBM Corporation等。<br>本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0">https://www.eclipse.org/legal/epl-v20.html</a> / SPDX-License-Identifier获取。 ：EPL-2.0</p>
</body>
</html><html id="3179.Event.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"></meta>
    <meta name="generator" content="JsDoc Toolkit"></meta>
    
    <title>JsDoc参考 - 事件</title>

    <style type="text/css">/* default.css */
body {
  font: 12px "Lucida Grande",Tahoma,Arial,Helvetica,sans-serif;
  width: 800px;
}
.header {
  clear: both;
  background-color: #ccc;
  padding: 8px;
}
h1 {
  font-size: 150%;
  font-weight: bold;
  padding: 0;
  margin: 1em 0 0 .3em;
}
hr {
  border: none 0;
  border-top: 1px solid #7f8fb1;
  height: 1px;
}
pre.code {
  display: block;
  padding: 8px;
  border: 1px dashed #ccc;
}
#index {
  margin-top: 24px;
  float: left;
  width: 160px;
  position: absolute;
  left: 8px;
  background-color: #f3f3f3;
  padding: 8px;
}
#content {
  margin-left: 190px;
  width: 600px;
}
.classList {
  list-style-type: none;
  padding: 0;
  margin: 0 0 0 8px;
  font-family: arial,sans-serif;
  font-size: 1em;
  overflow: auto;
}
.classList li {
  padding: 0;
  margin: 0 0 8px 0;
}
.summaryTable {
  width: 100%;
}
h1.classTitle {
  font-size: 170%;
  line-height: 130%;
}
h2 {
  font-size: 110%;
}
caption, div.sectionTitle {
  background-color: #7f8fb1;
  color: #fff;
  font-size: 130%;
  text-align: left;
  padding: 2px 6px 2px 6px;
  border: 1px #7f8fb1 solid;
}
div.sectionTitle {
  margin-bottom: 8px;
}
.summaryTable thead {
  display: none;
}
.summaryTable td {
  vertical-align: top;
  padding: 4px;
  border-bottom: 1px #7f8fb1 solid;
  border-right: 1px #7f8fb1 solid;
}
/* col#summaryAttributes {} */
.summaryTable td.attributes {
  border-left: 1px #7f8fb1 solid;
  width: 140px;
  text-align: right;
}
td.attributes, .fixedFont {
  line-height: 15px;
  color: #002ebe;
  font-family: "Courier New",Courier,monospace;
  font-size: 13px;
}
.summaryTable td.nameDescription {
  text-align: left;
  font-size: 13px;
  line-height: 15px;
}
.summaryTable td.nameDescription, .description {
  line-height: 15px;
  padding: 4px;
  padding-left: 4px;
}
.summaryTable {
  margin-bottom: 8px;
}
ul.inheritsList {
  list-style: square;
  margin-left: 20px;
  padding-left: 0;
}
.detailList {
  margin-left: 20px;
  line-height: 15px;
}
.detailList dt {
  margin-left: 20px;
}
.detailList .heading {
  font-weight: bold;
  padding-bottom: 6px;
  margin-left: 0;
}
.light, td.attributes, .light a:link, .light a:visited {
  color: #777;
  font-style: italic;
}
.fineprint {
  text-align: right;
  font-size: 10px;
}
</style>
  </head>

  <body dir="ltr">
<!-- ============================== header ================================= -->
    <!-- begin static/header.html -->
    <div id="header">
</div>
    <!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
    <div id="index">
      <!-- begin publish.classesIndex -->
      <div align="center"><a href="../index.html">指数</a></div>
<hr>
<h2>全球对象</h2>
<ul class="classList">
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li></li>
  
  <li><a href="../symbols/rap.html">敲击</a></li>
  
  <li><a href="../symbols/SWT.html">SWT</a></li>
  
</ul>
<h2>类型</h2>
<ul class="classList">
  
  <li><a href="../symbols/%24.html">$</a></li>
  
  <li><a href="../symbols/Button.html">按键</a></li>
  
  <li><a href="../symbols/Canvas.html">帆布</a></li>
  
  <li><a href="../symbols/Client.html">客户</a></li>
  
  <li><a href="../symbols/Combo.html">二合一</a></li>
  
  <li><a href="../symbols/Composite.html">综合</a></li>
  
  <li><a href="../symbols/Control.html">控制</a></li>
  
  <li><a href="../symbols/Event.html">事件</a></li>
  
  <li><a href="../symbols/Label.html">标签</a></li>
  
  <li><a href="../symbols/ProgressBar.html">进度条</a></li>
  
  <li><a href="../symbols/RemoteObject.html">RemoteObject的</a></li>
  
  <li><a href="../symbols/Scale.html">规模</a></li>
  
  <li><a href="../symbols/ScrolledComposite.html">ScrolledComposite</a></li>
  
  <li><a href="../symbols/Slider.html">滑块</a></li>
  
  <li><a href="../symbols/Spinner.html">微调</a></li>
  
  <li><a href="../symbols/Text.html">文本</a></li>
  
  <li><a href="../symbols/Widget.html">窗口小部件</a></li>
  
  <li></li>
  
  <li></li>
  
</ul>
<hr>
      <!-- end publish.classesIndex -->
    </div>

    <div id="content">
<!-- ============================== class title ============================ -->
      <h1 class="classTitle">输入活动</h1>

<!-- ============================== class summary ========================== -->
      <p class="description">RWT脚本编写org.eclipse.swt.widgets。事件</p>

<!-- ============================== constructor summary ==================== -->
      

<!-- ============================== properties summary ===================== -->
      
        
        
        <table class="summaryTable" cellspacing="0" summary="A summary of the fields documented in the class Event.">
          <caption>现场总结</caption>
          <thead>
            <tr>
              <th scope="col">字段属性</th>
              <th scope="col">字段名称和描述</th>
            </tr>
          </thead>
          <tbody>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#button">按键</a></b>
                </div>
                <div class="description">按下或释放的按钮;第一个按钮为1，第二个按钮为2，第三个按钮为3，等等。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#character">字符</a></b>
                </div>
                <div class="description">取决于事件，键入的键所代表的字符。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#doit">DOIT</a></b>
                </div>
                <div class="description">取决于事件，指示是否应该允许操作的标志。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#gc">GC</a></b>
                </div>
                <div class="description">绘画时使用的图形上下文。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#keyCode">关键代码</a></b>
                </div>
                <div class="description">取决于事件，键入的键的键代码，由类<code>SWT</code>的键代码常量定义。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#start">开始</a></b>
                </div>
                <div class="description">根据事件，修改的文本范围。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#stateMask">stateMask</a></b>
                </div>
                <div class="description">取决于事件，生成事件时键盘修改键和鼠标掩码的状态。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#text">文本</a></b>
                </div>
                <div class="description">根据事件，将插入新文本。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#type">类型</a></b>
                </div>
                <div class="description">事件的类型，由<a href="../symbols/SWT.html">SWT</a>对象中的事件类型常量定义。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#widget">小部件</a></b>
                </div>
                <div class="description">表示发出事件的窗口小部件的对象。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#x">X</a></b>
                </div>
                <div class="description">事件时指针的x坐标设置为MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。</div>
              </td>
            </tr>
          
            <tr>
              <td class="attributes"> </td>
              <td class="nameDescription">
                <div class="fixedFont">
                <b><a href="../symbols/Event.html#y">ÿ</a></b>
                </div>
                <div class="description">事件时指针的y坐标设置为MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。</div>
              </td>
            </tr>
          
          </tbody>
        </table>
        

        
      

<!-- ============================== methods summary ======================== -->
      
<!-- ============================== events summary ======================== -->
      

<!-- ============================== constructor details ==================== -->
      
      <div class="details"><a name="constructor"> </a>
        <div class="sectionTitle">类型细节</div>

        <div class="fixedFont">&lt;private&gt; <b>事件</b> （eventType，originalTarget，originalEvent）</div>

        <div class="description">这种类型的对象被赋予org.eclipse.rap.rwt.scripting的handleEvent函数（JavaScript）。ClientListener（Java）实例。
          
        </div>

        


          
            <dl class="detailList">
            <dt class="heading">参数：</dt>
            
              <dt>
                 <b>事件类型</b>
                
              </dt>
                <dd></dd>
            
              <dt>
                 <b>originalTarget</b>
                
              </dt>
                <dd></dd>
            
              <dt>
                 <b>originalEvent</b>
                
              </dt>
                <dd></dd>
            
            </dl>
          
          
          
            <dl class="detailList">
            <dt class="heading">以来：</dt>
              <dd>2.2</dd>
            </dl>
          
          
          
          
          
            <dl class="detailList">
            <dt class="heading">看到：</dt>
            
              <dd><a href="../symbols/SWT.html">SWT</a></dd>
            
            </dl>
          

      </div>
      

<!-- ============================== field details ========================== -->
      
        <div class="sectionTitle">现场细节</div>
        
          <a name="button"> </a>
          <div class="fixedFont">

          
          <b>按键</b>

          </div>
          <div class="description">按下或释放的按钮;第一个按钮为1，第二个按钮为2，第三个按钮为3，等等。设置为MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="character"> </a>
          <div class="fixedFont">

          
          <b>字符</b>

          </div>
          <div class="description">取决于事件，键入的键所代表的字符。这是应用所有修改器后生成的最终字符。对于不可打印的键（如箭头键），此字段未设置。改变它的价值没有效果。为KeyDown，KeyUp和Verify设置。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="doit"> </a>
          <div class="fixedFont">

          
          <b>DOIT</b>

          </div>
          <div class="description">取决于事件，指示是否应该允许操作的标志。将此字段设置为false将取消操作。在KeyDown，KeyUp和Verify上生效。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="gc"> </a>
          <div class="fixedFont">

          
          <b>GC</b>

          </div>
          <div class="description">绘画时使用的图形上下文。
<p>它支持<a href="http://www.w3.org/TR/2dcontext/">HTML5 Canvas API</a>的子集。</p>领域：<ul>
 <li>的StrokeStyle</li>
 <li>填充样式</li>
 <li>行宽</li>
 <li>lineJoin</li>
 <li>的linecap</li>
 <li>miterLimit分别</li>
 <li>globalAlpha的</li>
</ul>方法：<ul>
 <li>保存</li>
 <li>恢复</li>
 <li>beginPath方法</li>
 <li>closePath</li>
 <li>clearRect（限制：在IE 7/8参数中被忽略，整个画布被清除）</li>
 <li>行程</li>
 <li>填</li>
 <li>搬去</li>
 <li>了lineTo</li>
 <li>到quadraticCurveTo</li>
 <li>bezierCurveTo</li>
 <li>矩形</li>
 <li>弧</li>
 <li>的drawImage</li>
 <li>createLinearGradient（限制：在IE 7/8中，渐变只能垂直或水平绘制。对“addColorStop”的调用必须按偏移量的顺序排列，并且不能覆盖以前的colorsStops）</li>
</ul>现代浏览器支持更多方法，但对于IE 7/8，这些都是。在油漆上设置。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="keyCode"> </a>
          <div class="fixedFont">

          
          <b>关键代码</b>

          </div>
          <div class="description">取决于事件，键入的键的键代码，由类<code>SWT</code>的键代码常量定义。当事件的字符字段不明确时，此字段包含原始字符的未受影响的值。例如，键入Shift + M或M会导致不同的字符（'M'和'm'），但是相同的keyCode（109，'m'的字符代码）。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="start"> </a>
          <div class="fixedFont">

          
          <b>开始</b>

          </div>
          <div class="description">根据事件，修改的文本范围。设置这些字段无效。设置为验证。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="stateMask"> </a>
          <div class="fixedFont">

          
          <b>stateMask</b>

          </div>
          <div class="description">取决于事件，生成事件时键盘修改键和鼠标掩码的状态。设置为KeyDown，KeyUp，MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="text"> </a>
          <div class="fixedFont">

          
          <b>文本</b>

          </div>
          <div class="description">根据事件，将插入新文本。设置此字段将更改即将插入或删除的文本。设置为验证。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="type"> </a>
          <div class="fixedFont">

          
          <b>类型</b>

          </div>
          <div class="description">事件的类型，由<a href="../symbols/SWT.html">SWT</a>对象中的事件类型常量定义。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="widget"> </a>
          <div class="fixedFont">

          
          <b>小部件</b>

          </div>
          <div class="description">表示发出事件的窗口小部件的对象。
            
          </div>

          

            
            
            
              <dl class="detailList">
              <dt class="heading">看到：</dt>
              
              <dd><a href="../symbols/rap.html#.getObject">rap.getObject</a></dd>
              
              </dl>
            
            

          <hr>
        
          <a name="x"> </a>
          <div class="fixedFont">

          
          <b>X</b>

          </div>
          <div class="description">事件时指针的x坐标设置为MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。
            
          </div>

          

            
            
            
            

          <hr>
        
          <a name="y"> </a>
          <div class="fixedFont">

          
          <b>ÿ</b>

          </div>
          <div class="description">事件时指针的y坐标设置为MouseDown，MouseUp，MouseMove，MouseEvnet，MouseExit和MouseDoubleClick。
            
          </div>

          

            
            
            
            

          
        
      

<!-- ============================== method details ========================= -->
      

<!-- ============================== event details ========================= -->
      

      <hr>
    </div>


<!-- ============================== footer ================================= -->
    <div class="fineprint" style="clear:both">版权所有（c）EclipseSource等2013,2019。版权所有。
    </div>
  </body>
</html><html id="2276.Delegates.html" dir="ltr"></html><html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta>
<title>代表</title>
<link href="book.css" rel="stylesheet" type="text/css"></link>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></meta>
<link rel="home" href="index.html" title="OCL Documentation"></link>
<link rel="up" href="ProgrammersGuide.html" title="Classic Ecore/UML Programmers Guide"></link>
<link rel="prev" href="ImpactAnalyzer.html" title="Incrementally Re-Evaluating OCL Expressions Using the Impact Analyzer"></link>
<link rel="next" href="Standalone.html" title="Ecore/UML Standalone Configuration"></link>
</head>
<body bgcolor="white" dir="ltr" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">代表</h1>
<div class="section" title="代表">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear:both">
<a name="Delegates"></a>代表</h2>
</div>
</div>
</div>
<p>EMF提供三种委派机制，使EMF不直接支持的功能可以委派给可以支持它的技术。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><a class="link" href="Delegates.html#ValidationDelegate" title="验证代表">验证代理</a>支持检查EClassifier上的其他不变量</p>
</li>
<li class="listitem">
<p><a class="link" href="Delegates.html#SettingDelegate" title="设置代表">设置委托</a>支持获取EStructuralFeature的初始或派生计算值</p>
</li>
<li class="listitem">
<p><a class="link" href="Delegates.html#InvocationDelegate" title="调用代表">Invocation Delegate</a>支持执行EOperation定义的函数</p>
</li>
</ul>
</div>
<p>并且</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><a class="link" href="Delegates.html#QueryDelegate" title="查询代表">查询委托</a>支持执行未由EOperation定义的函数</p>
</li>
</ul>
</div>
<p>使用<a class="link" href="OCLinEcore.html" title="OCLinEcore语言">OCLinEcore</a>编辑器时，将自动提供支持委派所需的EAnnotations。本节提供了足够的细节，以允许使用Sample Ecore Editor或Java代码手动维护它们。
			</p>
<p>这些EAnnotations确保代表可以用于genmodeled和反射模型。使用genmodel为元模型生成Java类对于建模具有显着的性能优势，但目前对OCL执行没什么影响。使用genmodel的缺点是必须安装Java类，因此Java类的用户必须在与开发人员不同的Eclipse或独立会话中运行。相反，使用反射模型允许开发人员和用户共享相同的Eclipse会话。</p>
<div class="section" title="GenModel设置">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="GenModelSettings"></a> GenModel设置</h3>
</div>
</div>
</div>
<p>需要正确设置一个GenModel设置，以确保生成的Java类中的OCL可以自己成功调用。通过将<code class="code">Operation Reflection</code>选项设置为<code class="code">true</code>确保生成对反射操作调用的支持。
				</p>
</div>
<div class="section" title="OCL委托URI">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="OCLDelegateURI"></a> OCL委托URI</h3>
</div>
</div>
</div>
<p>实现委托的每个应用程序都有一个关联的委托URI，即</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL</code>为经典评估员</p>
</li>
<li class="listitem">
<p>
							
Pivot评估员的<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot</code></p>
</li>
</ul>
</div>
<p>Helios版本中只提供<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL</code> ，因此OCLinEcore编辑器的Helios版本使用了该URI。</p>
<p>OCLinEcore编辑器使用更准确且符合OMG的Pivot元模型，因此在Indigo版本中，OCLinEcore编辑器使用<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot</code> URI并转换所有传入使用<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL</code> URI到<code class="code">http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot</code> 。</p>
<p>如<a class="link" href="UsersGuide.html#EclipseOCLs" title="两个Eclipse OCL">两个Eclipse OCL中</a>所述，Pivot评估器使用中间Pivot模型隐藏Ecore和UML2，因此允许完全符合OMG。只有在按照安装中的说明<a class="link" href="Installation.html" title="安装Eclipse OCL示例和编辑器">安装</a>了OCL示例和编辑器功能时，才能使用Pivot评估程序。
				</p>
<p>OCL代理URI使用</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>org.eclipse.emf.ecore.invocation_delegate</p>
</li>
<li class="listitem">
<p>org.eclipse.emf.ecore.setting_delegate</p>
</li>
<li class="listitem">
<p>org.eclipse.emf.ecore.query_delegate</p>
</li>
<li class="listitem">
<p>org.eclipse.emf.ecore.validation_delegate</p>
</li>
</ul>
</div>
<p>延伸点。</p>
</div>
<div class="section" title="独立初始化">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="StandaloneInitialization"></a>独立初始化</h3>
</div>
</div>
</div>
<p><a class="link" href="Standalone.html" title="Ecore / UML独立配置">独立</a>部分中给出了独立使用EMF委托的初始化代码。
				</p>
</div>
<div class="section" title="调用代表">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="InvocationDelegate"></a>调用代表</h3>
</div>
</div>
</div>
<p>调用调用委托来执行EOperation的主体。必须为EOperation的EClassifier的EPackage注册调用委托。</p>
<p>EPackage注册由EPackage上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <code class="code">http://www.eclipse.org/emf/2002/Ecore</code>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">invocationDelegates</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>调用委托由EOperation上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">body</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>评估<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>以提供EOperation值，其中包含EClassifier作为<code class="code">self</code>上下文对象，EParameters可作为OCL中的参数访问。 <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>的返回类型必须符合EOperation的返回类型。
				</p>
</div>
<div class="section" title="设置代表">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="SettingDelegate"></a>设置代表</h3>
</div>
</div>
</div>
<p>调用设置委托以提供EStructuralFeature的初始值或派生值。必须为EStructuralFeature的EClassifier的EPackage注册设置委托。</p>
<p>EPackage注册由EPackage上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <code class="code">http://www.eclipse.org/emf/2002/Ecore</code>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">settingDelegates</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>设置委托由EStructuralFeature上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">derivation</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>评估<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>以提供EStructuralFeature值，并将包含EClassifier作为<code class="code">self</code>上下文对象。<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>的结果类型必须符合EStructuralFeature的类型。
				</p>
<p>可以指定<code class="code">initial</code>值而不是<code class="code">derivation</code>值。如果还指定了<code class="code">derivation</code>则忽略<code class="code">initial</code>值。
				</p>
</div>
<div class="section" title="验证代表">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ValidationDelegate"></a>验证代表</h3>
</div>
</div>
</div>
<p>调用验证委托以提供EClassifier的附加验证。必须为EClassifier的EPackage注册验证委托，EClassifier为其提供任何Ecore不变量或Ecore约束。Ecore约束和不变量都约束EClassifier，不同之处在于Ecore不变量是通过EOperation实现的，因此Ecore不变量可以被建模环境重用，可能希望有选择地检查或重新检查约束。</p>
<p>EPackage注册由EPackage上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <code class="code">http://www.eclipse.org/emf/2002/Ecore</code>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">validationDelegates</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>所有Ecore约束必须列在EClassifier的EAnnotation中</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <code class="code">http://www.eclipse.org/emf/2002/Ecore</code>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">constraints</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">constraintName1 constraintName2 constraintName3</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>每个Ecore约束的验证委托由EClassifier上的另一个EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <span class="emphasis"><em><code class="code">constraintName</code></em></span>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>每个Ecore不变量的验证委托由EOperation上的EAnnotation提供</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <code class="code">body</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>评估<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>以使用EClassifier作为<code class="code">self</code>上下文对象来验证EClassifier。<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>的结果类型必须是布尔值。
				</p>
</div>
<div class="section" title="验证消息">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ValidationMessages"></a>验证消息</h3>
</div>
</div>
</div>
<p>验证失败时，EMF会生成表单<code class="code">The</code>默认诊断。 <span class="emphasis"><em><code class="code">'constraintName'</code></em></span> <code class="code">is violated on</code> <span class="emphasis"><em><code class="code">'constrainedObject'</code></em></span> 。
				</p>
<p>如果使用<a class="link" href="PivotProgrammersGuide.html#OCLinEcoreEObjectValidator" title="OCLinEcoreEObjectValidator">OCLinEcoreEObjectValidator</a>或<a class="link" href="PivotProgrammersGuide.html#CompleteOCLEObjectValidator" title="CompleteOCLEObjectValidator">CompleteOCLEObjectValidator，</a>则可以使用EClassifier上的其他EAnnotation提供自定义消息。
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">source</code> = <span class="emphasis"><em><code class="code">OCL-Delegate-URI</code></em></span>
						
</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>
									
<code class="code">key</code> = <span class="emphasis"><em><code class="code">constraintName</code></em></span> <code class="code">$message</code>
								
</p>
</li>
<li class="listitem">
<p>
									
<code class="code">value</code> = <span class="emphasis"><em><code class="code">OCL-expression</code></em></span>
								
</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>评估<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>以生成自定义消息，并将EClassifier作为<code class="code">self</code>上下文对象。<span class="emphasis"><em><code class="code">OCL-expression</code></em></span>的结果类型必须是String。
				</p>
<p>还可以通过利用约束评估的布尔值的四个值来自定义诊断的严重性。</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">true</code>表示验证成功</p>
</li>
<li class="listitem">
<p>
							
<code class="code">false</code>表示警告严重性不成功的验证</p>
</li>
<li class="listitem">
<p>
							
<code class="code">null</code>表示错误严重性的验证失败</p>
</li>
<li class="listitem">
<p>
							
<code class="code">invalid</code>表示无法执行验证（错误严重性）</p>
</li>
</ul>
</div>
</div>
<div class="section" title="查询代表">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="QueryDelegate"></a>查询代表</h3>
</div>
</div>
</div>
<p>调用查询委托来评估没有相应EOperation的EObject上的参数化查询。注册查询委托以安装此查询并允许缓存其编译的表单。然后可以根据兼容的上下文对象和参数的需要多次调用委托。</p>
<p>此工具使EMF应用程序能够执行OCL，而无需声明或实例化任何OCL类。</p>
<p>查询委托注册类似于直接使用<code class="code">OCL.newInstance().createHelper().createQuery()</code>
				
</p>
<p>查询委托执行类似于<code class="code">OCL.evaluate()</code> 
				
</p>
</div>
</div>
</body>
</html><html id="0379.org_eclipse_datatools_connectivity_connectionProfile.html" dir="ltr"></html><html dir="ltr">
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>连接配置文件</title>
<style></style>
<style></style>
</head>
<body dir="ltr">
<h1><center>连接配置文件</center></h1>
<p></p>
<h6 class="CaptionFigColumn" id="header">标识符：</h6>org.eclipse.datatools.connectivity.connectionProfile<p></p>
<h6 class="CaptionFigColumn" id="header">以来：</h6>DTP v.0.x<p></p>

<p>
</p><h6 class="CaptionFigColumn" id="header">描述：</h6>此扩展点为插件提供了添加对不同类型的连接配置文件的支持的位置。它还允许扩展来扩展定义的扩展点的功能。

<p>使用<samp>connectionProfile</samp>元素定义连接配置文件。连接配置文件将属于单个类别和单个配置类型。类别用于分组类似的连接配置文件（例如队列，数据库等）。配置类型用于指定配置文件提供的配置信息的类型（例如，New Era Open Transport，JDBC等）。</p>

<p>提供者必须定义用于创建资源的相应<samp>newWizard</samp>元素。</p>

<p>提供者必须定义相应的<samp>org.eclipse.ui.propertyPages</samp>以编辑连接配置文件的属性。提供程序应确保定义了一个<samp>过滤器</samp>元素，以验证所选连接配置文件的提供者ID是否与为<samp>connectionProfile</samp>指定的<samp>id</samp>匹配（这是使用<samp>org.eclipse.datatools.profile.property.id</samp>属性完成的）。 <samp>org.eclipse.datatools.connectivity.ui.wizards。ProfileDetailsPropertyPage</samp>是一个基本属性页实现，旨在由连接配置文件提供程序为此目的进行扩展。</p>

<p>可以使用<samp>connectionFactory</samp>元素注册支持给定配置文件的连接工厂。连接工厂允许插件从连接配置文件创建与服务器的连接。连接配置文件提供程序应提供连接工厂扩展。理想情况下，连接工厂的ID应与连接时创建的对象类型相对应（例如<samp>java.sql。连接</samp> ）。连接配置文件提供程序应实现一个ID为<samp>org.eclipse.datatools.connectivity.connectionFactory.pingFactory</samp>的<samp>connectionFactory</samp> ，以启用基本实现和框架中提供的ping功能。</p><p></p>

<p>通过定义以下扩展元素，可以通过其他插件扩展连接配置文件：</p><ul>
<li><samp>connectionFactory  -</samp></li>此元素使插件能够为指定的连接配置文件提供连接创建支持。
<li><samp>profileExtension  -</samp></li>此元素使插件能够为指定的连接配置文件提供其他配置属性。如果以这种方式扩展连接配置文件，并且在连接到连接配置文件定义的服务器时需要指定这些属性，则需要提供使用其他属性的连接工厂扩展。
</ul>


<p>工具提供商可以选择使用各种机制与连接配置文件集成。工具可以键入特定的配置文件类型（通过检查配置文件的ID属性;例如，如上所述用于提供属性页面的机制）。工具也可以键控以使用具有指定连接工厂的配置文件（例如，特定于DB的工具可以键入以使用具有<samp>java.sql的任何配置文件<samp>。连接</samp>工厂）。此方法允许工具使用可通过特定连接API表示的任何类型的连接配置文件。</p>

<p>提供了以下过滤器属性，用于过滤连接配置文件实例:(这些在<samp>org.eclipse.datatools.connectivity.ui中定义<samp>。IConnectionProfileActionFilter</samp> 。）
</p><ul>
<li><samp>org.eclipse.datatools.profile.property.id</samp> -</li>用于过滤特定类型的配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.categoryID</samp> -</li>用于过滤属于特定类别的配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.factoryID</samp> -</li>用于过滤实现特定类型的连接工厂的配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.hasExtendedProperties</samp> -</li>用于过滤配置了一个或多个<samp>profileExtension</samp>的配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.extensionID</samp> -</li>用于过滤实现特定类型的<samp>profileExtension的</samp>配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.containingViewID</samp> -</li>用于过滤特定视图中包含的配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.isConnected</samp> -</li>用于根据连接状态过滤配置文件实例。
<li><samp>org.eclipse.datatools.connectivity.profile.property.supportsPing</samp> -</li>用于过滤实现ping连接工厂的配置文件实例（name = org.eclipse.datatools.connectivity.profile.property.factoryID，value = org.eclipse.datatools.connectivity.connectionFactory.pingFactory的快捷方式）。
</ul>

<p></p><h6 class="CaptionFigColumn" id="header">配置标记：</h6>
<p class="code" id="dtd">&lt;！ELEMENT <a name="e.extension">扩展</a> （ <a href="#e.category">类别</a> *， <a href="#e.configurationType">configurationType</a> *， <a href="#e.connectionProfile">connectionProfile</a> *， <a href="#e.connectionFactory">connectionFactory</a> *， <a href="#e.profileExtension">profileExtension</a> *， <a href="#e.newWizard">newWizard</a> *， <a href="#e.wizardCategory">wizardCategory</a> *）*&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST扩展</p>
<p class="code" id="dtdAttlist">点CDATA #REQUIRED</p><p class="code" id="dtdAttlist">id CDATA #IMPLIED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>point</b> - 目标扩展点的完全限定标识符<samp>org.eclipse.datatools.connectivity.connectionProfile</samp></li>
<li><b>id</b> - 扩展实例的可选标识符</li>
<li><b>name</b> - 扩展实例的可选名称</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.category">类别</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST类别</p>
<p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">parentCategory CDATA #IMPLIED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素用于标识类别。类别用于对相关的连接配置文件类型（例如数据库）进行分组。</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>id</b> - 此类别的ID。该值由<samp>connectionProfile</samp>元素引用。</li>
<li><b>parentCategory</b> - 如果此类别具有父类别，则为父类别的ID。</li>
<li><b>name</b> - 此类别的显示名称。</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.connectionProfile">connectionProfile</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST connectionProfile</p>
<p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED</p><p class="code" id="dtdAttlist">类别CDATA #REQUIRED</p><p class="code" id="dtdAttlist">configurationType CDATA #REQUIRED</p><p class="code" id="dtdAttlist">icon CDATA #IMPLIED</p><p class="code" id="dtdAttlist">maintainConnection CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素用于定义连接配置文件类型。</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>id</b> - 此连接配置文件的ID。这必须唯一标识此连接配置文件。</li>
<li><b>name</b> - 此连接配置文件类型的显示名称。</li>
<li><b>category</b> - 此连接配置文件所属的类别。这必须映射回<samp>类别/ ID</samp> 。</li>
<li><b>configurationType</b> - 此连接配置文件的配置类型。这必须映射回<samp>configurationType / id</samp> 。</li>
<li><b>icon</b> - 图像文件的插件相对路径。此映像将用于在服务器视图中标识此类型的资源。</li>
<li><b>maintainConnection</b> -</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.configurationType">configurationType</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST配置类型</p>
<p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素用于标识配置类型。配置类型用于确定连接配置文件使用的配置数据的格式。例如，“New Era Open Transport”或“JDBC Connection URL”</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>id</b> - 此配置类型的唯一标识符。</li>
<li><b>name</b> - 此配置类型的名称。</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.connectionFactory">connectionFactory</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST connectionFactory</p>
<p class="code" id="dtdAttlist">个人资料CDATA #REQUIRED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED</p><p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">class CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素定义连接工厂，该工厂可用于使用存储在连接配置文件资源中的属性创建与服务器的连接。</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>profile</b> - 此工厂支持的连接配置文件。这应该引用<samp>connectionProfile / id</samp> 。</li>
<li><b>name</b> - 此连接工厂的名称。</li>
<li><b>id</b> - 此连接工厂的唯一标识符。插件可以使用此ID来检索此连接工厂的实例。</li>
<li><b>class</b> - 实现此连接工厂的类。指定的类必须是IConnectionFactory的实例。</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.profileExtension">profileExtension</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST profileExtension</p>
<p class="code" id="dtdAttlist">个人资料CDATA #REQUIRED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED</p><p class="code" id="dtdAttlist">id CDATA #REQUIRED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素用于定义扩展，该扩展为在连接配置文件上设置其他属性提供支持。实现此扩展点时，还应根据需要实现连接工厂。</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>profile</b> - 此扩展程序支持的连接配置文件。这应该映射到<samp>connectionProfile / id</samp> 。</li>
<li><b>name</b> - 此扩展名。</li>
<li><b>id</b> - 此扩展的唯一标识符。</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.newWizard">newWizard</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST newWizard</p>
<p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">名称CDATA #REQUIRED</p><p class="code" id="dtdAttlist">class CDATA #REQUIRED</p><p class="code" id="dtdAttlist">icon CDATA #IMPLIED</p><p class="code" id="dtdAttlist">描述CDATA #IMPLIED</p><p class="code" id="dtdAttlist">个人资料CDATA #REQUIRED</p><p class="code" id="dtdAttlist">类别CDATA #IMPLIED&gt;</p>
<p></p>
<p class="ConfigMarkup" id="elementDesc">此元素用于标识连接配置文件向导。向导用于创建连接配置文件</p>
<br>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>id</b> - 新向导的唯一标识符。</li>
<li><b>名字</b> -</li>
<li><b>class</b> - 实现此新向导的类。指定的类必须是IWizard的实例。 <samp>org.eclipse.datatools.connectivity.ui.wizards。NewConnectionProfileWizard</samp>是一个基本实现，旨在由连接配置文件提供程序进行扩展。 <samp>org.eclipse.datatools.connectivity.ui.wizards。ConnectionProfileDetailsPage</samp>是一个基本向导页面实现，旨在与上面的向导实现一起使用。</li>
<li><b>icon</b> - 图像文件的插件相对路径。此图像将用于标识新向导。</li>
<li><b>description</b> - 新向导的说明。</li>
<li><b>profile</b> - 此新向导支持的连接配置文件。这应该引用<samp>connectionProfile / id</samp> 。</li>
<li><b>类别</b> -</li>
</ul>
<br><p class="code" id="dtd">&lt;！ELEMENT <a name="e.wizardCategory">wizardCategory</a> EMPTY&gt;</p>
<p class="code" id="dtd">&lt;！ATTLIST wizardCategory</p>
<p class="code" id="dtdAttlist">id CDATA #REQUIRED</p><p class="code" id="dtdAttlist">parentCategory CDATA #IMPLIED</p><p class="code" id="dtdAttlist">名称CDATA #IMPLIED</p><p class="code" id="dtdAttlist">icon CDATA #IMPLIED</p><p class="code" id="dtdAttlist">描述CDATA #IMPLIED</p><p class="code" id="dtdAttlist">wizardTitle CDATA #IMPLIED</p><p class="code" id="dtdAttlist">wizardDescription CDATA #IMPLIED&gt;</p>
<p></p>
<ul class="ConfigMarkup" id="attlistDesc">
<li><b>id</b> - 此元素用于标识向导类别。类别用于对相关连接配置文件向导（例如数据库）进行分组。</li>
<li><b>parentCategory</b> - 如果此类别具有父类别，则为父类别的ID。</li>
<li><b>name</b> - 此类别的显示名称。</li>
<li><b>icon</b> - 图像文件的插件相对路径。此图像将用于在新连接配置文件向导中标识向导类别。</li>
<li><b>description</b> - 新向导类别的说明。</li>
<li><b>wizardTitle</b> - 向导标题</li>
<li><b>wizardDescription</b> - 向导说明</li>
</ul>
<br><h6 class="CaptionFigColumn" id="header">例子：</h6><pre>
 <p class="code" id="tag">&lt;extension id =</p><p class="code" id="cstring">“样品”</p><p class="code" id="tag">名称=</p><p class="code" id="cstring">“示例服务器扩展”</p><p class="code" id="tag">点=</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.connectionProfile”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;category name =</p><p class="code" id="cstring">“样本服务器类别”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleCategory”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/类别&gt;</p>
  <p class="code" id="tag">&lt;configurationType name =</p><p class="code" id="cstring">“示例配置类型”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConfigurationType”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/ configurationType&gt;</p>
  <p class="code" id="tag">&lt;connectionFactory profile =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConnectionProfile”</p><p class="code" id="tag">名称=</p><p class="code" id="cstring">“共享连接工厂”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sharedConnectionFactory”</p><p class="code" id="tag">CLASS =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example。SharedConnectionFactory”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/ connectionFactory的&gt;</p>
  <p class="code" id="tag">&lt;connectionFactory profile =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConnectionProfile”</p><p class="code" id="tag">名称=</p><p class="code" id="cstring">“Ping连接工厂”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.connectionFactory.pingFactory”</p><p class="code" id="tag">CLASS =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example。SharedConnectionFactory”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/ connectionFactory的&gt;</p>
  <p class="code" id="tag">&lt;profileExtension profile =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConnectionProfile”</p><p class="code" id="tag">名称=</p><p class="code" id="cstring">“样本外来属性”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConnectionProfileExtension”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/ profileExtension&gt;</p>
  <p class="code" id="tag">&lt;connectionProfile configurationType =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConfigurationType”</p><p class="code" id="tag">名称=</p><p class="code" id="cstring">“样品连接配置文件”</p><p class="code" id="tag">图标=</p><p class="code" id="cstring">“图标/ sample.gif”</p><p class="code" id="tag">类别=</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleCategory”</p><p class="code" id="tag">ID =</p><p class="code" id="cstring">“org.eclipse.datatools.connectivity.example.sampleConnectionProfile”</p><p class="code" id="tag">&gt;</p>
  <p class="code" id="tag">&lt;/ connectionProfile&gt;</p>
 <p class="code" id="tag">&lt;/分机&gt;</p>
</pre>
<p></p>

<h6 class="CaptionFigColumn" id="header">API信息：</h6>[在此处输入API信息。]
<p></p>

<br>
<p class="note" id="copyright">
</p><p>版权所有（c）2004-2005 Sybase，Inc。</p>
<p>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License 2.0条款提供，可从<a href="https://www.eclipse.org/legal/epl-2.0/">https://www.eclipse.org/legal/epl-2.0/</a>获取。</p>

<p>贡献者：rcernich  - 初始API和实现</p>
<p></p>


</body>
</html><html id="0564.Doc02_ManagingRepositories.html" dir="ltr"></html><html dir="ltr">

<head>
<title>管理存储库（CDO模型存储库文档）</title>

<link rel="stylesheet" href="../book.css" type="text/css" charset="UTF-8"></link>

<noscript></noscript>
<script type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Managing Repositories (CDO Model Repository Documentation)";
    }
}
</script>
</head>

<body bgcolor="white" dir="ltr" onload="windowTitle();">
<!-- <div class="help_breadcrumbs breadcrumbs_top"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<table border="0">
	<tr>
		<td width="100%"><h1>管理存储库</h1></td>
		<td align="right" valign="middle" nowrap=""><a href="Doc01_UserInterface.html" title="向后到用户界面的元素"><img src="../../images/backward.png" border="0"></a> <a href="Doc03_UsingBranches.html" title="转发到分支机构"><img src="../../images/forward.png" border="0"></a></td>
	</tr>
</table>
<p class="author">作者：Eike Stepper</p>
<p>CDO在存储库中存储模型和元模型。需要创建这些存储库，或者如果它们已经存在于远程服务器上，则必须先将它们连接起来，然后才能在Eclipse中使用它们。这些存储库连接的管理发生在<a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图中</a> 。
 </p><p>目前，CDO支持两种不同类型的存储库连接：</p><ul>
 <li>与现有远程存储库的连接，如<a href="Doc02_ManagingRepositories.html#Doc_RemoteRepositories" title="CDO模型存储库文档中的章节">连接到远程存储库中所述</a> 。
 </li><li>与新创建的本地存储库的连接，如<a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">创建本地存储库中所述</a> 。
 </li></ul>请注意，CDO Explorer用户界面上下文中的术语<a href="../../javadoc/org/eclipse/emf/cdo/explorer/repositories/CDORepository.html" title="org.eclipse.emf.cdo.explorer.repositories中的接口"><code>repository</code></a>指的是与核心级<a href="../../javadoc/org/eclipse/emf/cdo/server/IRepository.html" title="org.eclipse.emf.cdo.server中的接口"><code>IRepository</code></a>的<i>连接</i> ，而不是引用<a href="../../javadoc/org/eclipse/emf/cdo/server/IRepository.html" title="org.eclipse.emf.cdo.server中的接口"><code>IRepository</code></a>本身。有关操作CDO服务器以及创建和管理<a href="../../javadoc/org/eclipse/emf/cdo/server/IRepository.html" title="org.eclipse.emf.cdo.server中的接口"><code>IRepository</code></a> ，请参阅“ <a href="../operators/index.html" title="CDO模型存储库文档中的类别">操作员指南”</a> 。
 <p>以下各节说明如何创建，重命名，连接，断开连接或删除存储库以及如何使用分支。
 </p><p>
 <b>目录</b> </p><p>
</p><table border="0">
<tr><td>1</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_CreatingRepositories" title="CDO模型存储库文档中的章节">创建存储库和连接</a></td></tr>
<tr><td></td><td>1.1</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RemoteRepositories" title="CDO模型存储库文档中的章节">连接到远程存储库</a></td></tr>
<tr><td></td><td>1.2</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_CloneRepositories" title="CDO模型存储库文档中的章节">克隆主存储库</a></td></tr>
<tr><td></td><td>1.3</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_LocalRepositories" title="CDO模型存储库文档中的章节">创建本地存储库</a></td></tr>
<tr><td>2</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_RenamingConnections" title="CDO模型存储库文档中的章节">重命名存储库连接</a></td></tr>
<tr><td>3</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_DeletingConnections" title="CDO模型存储库文档中的章节">删除存储库连接</a></td></tr>
<tr><td>4</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_ConnectingDisconnecting" title="CDO模型存储库文档中的章节">连接和断开存储库</a></td></tr>
<tr><td>五</td><td class="te" colspan="4"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowIn" title="CDO模型存储库文档中的章节">在其他视图中显示存储库</a></td></tr>
<tr><td></td><td>5.1</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInSessions" title="CDO模型存储库文档中的章节">在CDO会话视图中显示存储库</a></td></tr>
<tr><td></td><td>5.2</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInServerBrowser" title="CDO模型存储库文档中的章节">在CDO服务器浏览器中显示存储库</a></td></tr>
<tr><td></td><td>5.3</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInProperties" title="CDO模型存储库文档中的章节">在属性视图中显示存储库</a></td></tr>
<tr><td></td><td>5.4</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInHistory" title="CDO模型存储库文档中的章节">在历史记录视图中显示存储库</a></td></tr>
<tr><td></td><td>5.5</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInProjectExplorer" title="CDO模型存储库文档中的章节">在Project Explorer中显示存储库</a></td></tr>
<tr><td></td><td>5.6</td><td class="te" colspan="3"><a href="Doc02_ManagingRepositories.html#Doc_RepositoryShowInSystemExplorer" title="CDO模型存储库文档中的章节">在系统资源管理器中显示存储库</a></td></tr>
</table>



<h2><a name="Doc_CreatingRepositories"></a> 1创建存储库和连接</h2>
<p><a href="Doc01_UserInterface.html#Doc_RepositoriesView" title="CDO模型存储库文档中的章节">CDO存储库视图</a>提供了使用不同类型的CDO存储库的统一方法。只有在创建或连接时，存储库类型之间的差异才会变得明显。
 </p><p>以下部分说明如何使用不同的存储库创建或连接向导。可以通过单击CDO存储库视图工具栏上的绿色加号按钮来启动它们中的每一个：</p><p align="center"><img src="repositories-view.png">


</p><h3><a name="Doc_RemoteRepositories"></a> 1.1连接远程存储库</h3>
<p>要创建与现有远程存储库的在线连接，必须在第一个向导页面上选择第一个类型选项：</p><p align="center"><img src="repo-wizard-type-remote.png">

 </p><p>双击类型选项或单击“下一步”按钮前进到下一个向导页面，在该页面上，新连接的标签和有关远程服务器的信息，该服务器上的存储库以及可选的登录凭据需要输入：</p><p align="center"><img src="repo-wizard-remote.png">

 </p><p><b>标签</b>标识与远程存储库的连接。它在当前工作空间中的所有已配置连接中必须是唯一的。它也可以稍后更改，请参阅<a href="Doc02_ManagingRepositories.html#Doc_RenamingConnections" title="CDO模型存储库文档中的章节">重命名存储库连接</a> 。
 </p><p><b>主机</b>和<b>端口</b>字段指定要连接的存储库的服务器，更确切地说是该服务器上接受目标存储库的连接请求的<a href="../../../org.eclipse.net4j.doc/javadoc/org/eclipse/net4j/acceptor/IAcceptor.html" title="org.eclipse.net4j.acceptor中的接口"><code>IAcceptor</code></a> 。请参阅<a href="../operators/Doc02_ConfiguringAcceptors.html" title="CDO模型存储库文档中的文章">配置接受者</a>以获取操作员详
 </p><p><b>存储库</b>列表显示在目标服务器上发现的存储库。在此列表中选择已发现的存储库会将所选存储库的名称复制到存储库名称字段中。
 </p><p><b>存储库名称</b>字段标识指定CDO服务器上的目标存储库。有关如何在CDO服务器上配置存储库名称，请参阅<a href="../operators/Doc01_ConfiguringRepositories.html#Element_repository" title="CDO模型存储库文档中的章节">元素存储</a>库。
 </p><p>仅当目标存储库支持身份验证时，才会启用<b>用户名</b>和<b>密码</b>字段。有关如何在CDO存储库中配置身份验证和授权的信息，请参阅<a href="http://wiki.eclipse.org/CDO/Security_Manager" title="CDO模型存储库文档中的文章">管理安全性</a> 。

</p><h3><a name="Doc_CloneRepositories"></a> 1.2克隆主存储库</h3>
<p>用户界面尚不支持克隆主存储库。

</p><h3><a name="Doc_LocalRepositories"></a> 1.3创建本地存储库</h3>
<p>要创建新的本地存储库并向其添加在线连接，必须在第一个向导页面上选择第三个类型选项：</p><p align="center"><img src="repo-wizard-type-local.png">

 </p><p>双击类型选项或单击“下一步”按钮前进到下一个向导页面，在该页面上需要输入新连接的标签和有关新本地存储库的信息：</p><p align="center"><img src="repo-wizard-local.png">

 </p><p><b>标签</b>标识与新本地存储库的连接。它在当前工作空间中的所有已配置连接中必须是唯一的。它也可以稍后更改，请参阅<a href="Doc02_ManagingRepositories.html#Doc_RenamingConnections" title="CDO模型存储库文档中的章节">重命名存储库连接</a> 。
 </p><p><b>存储库名称</b>字段指定新本地存储库的名称。它必须在当前工作空间中的所有本地存储库中是唯一的。创建存储库后，与连接标签不同，存储库的名称可以不再更改。
 </p><p><b>版本控制模式</b>确定是保留已更改模型的历史记录（例如，在<a href="Doc04_CheckingOut.html#Doc_HistoricalCheckouts" title="CDO模型存储库文档中的章节">联机历史签出</a>和<a href="Doc01_UserInterface.html#Doc_TimeMachineView" title="CDO模型存储库文档中的章节">CDO时间机器视图中使用</a> ）以及是否支持分支。创建存储库后，无法再更改存储库的版本控制模式。
 </p><p><b>ID生成</b>确定生成新模型元素的位置（服务器或客户端）和方式（计数器或UUID）ID。服务器端计数器ID是更有效的选项，但它们阻止在复制方案中使用存储库，例如<a href="Doc02_ManagingRepositories.html#Doc_CloneRepositories" title="CDO模型存储库文档中的章节">脱机克隆存储库</a>或<a href="Doc04_CheckingOut.html#Doc_OfflineCheckouts" title="CDO模型存储库文档中的章节">脱机签出</a> 。对于这些方案，应选择客户端UUID。创建存储库后，无法再更改存储库的ID生成。
 </p><p>可选的<b>TCP端口</b>字段指定<a href="../../../org.eclipse.net4j.doc/javadoc/org/eclipse/net4j/tcp/ITCPAcceptor.html" title="org.eclipse.net4j.tcp中的接口"><code>ITCPAcceptor</code></a>将接受传入连接请求的端口。默认情况下，此选项被禁用，因为本地存储库在与托管Eclipse IDE相同的Java VM中运行，并且始终通过隐式<a href="../../../org.eclipse.net4j.doc/javadoc/org/eclipse/net4j/jvm/IJVMAcceptor.html" title="org.eclipse.net4j.jvm中的接口"><code>IJVMAcceptor</code></a>接受来自那里的连接请求。

</p><h2><a name="Doc_RenamingConnections"></a> 2重命名存储库连接</h2>
<p>CDO支持在任何时候重命名现有存储库连接，即更改其标签，即使已经存在来自该存储库的检出。可以通过选择存储库连接并按F2键或在上下文菜单中选择“重命名”操作来重命名存储库连接。将弹出以下对话框：</p><p align="center"><img src="repo-rename.png">

 </p><p>如果存储库标签未更改或更改为不存在的标签，则只能使用“确定”按钮完成对话框。

</p><h2><a name="Doc_DeletingConnections"></a> 3删除存储库连接</h2>
<p>通过选择存储库连接并按Del键或在上下文菜单中选择“删除”操作，可以删除现有存储库连接。将弹出以下对话框：</p><p align="center"><img src="repo-delete.png">

 </p><p>如果存在要删除的存储库连接的检出，则将<b>首先</b>弹出以下警告对话框：</p><p align="center"><img src="repo-delete-checkouts.png">

 </p><p>如果确认删除现有结帐，则会按照<a href="Doc05_UsingCheckouts.html#Doc_DeletingCheckouts" title="CDO模型存储库文档中的章节">删除结帐中的</a>说明弹出结帐删除对话框。

</p><h2><a name="Doc_ConnectingDisconnecting"></a> 4连接和断开存储库</h2>
<p>要使用已配置的存储库，例如创建分支（请参阅<a href="Doc03_UsingBranches.html#Doc_CreatingBranches" title="CDO模型存储库文档中的章节">创建分支</a> ）或签出（请参阅<a href="Doc04_CheckingOut.html" title="Article in CDO Model Repository Documentation">从存储库</a>签<a href="Doc04_CheckingOut.html" title="CDO模型存储库文档中的文章">出，存储</a>库必须处于<i>连接</i>状态。创建后直接连接存储库。在Eclipse启动后，所有存储库都处于<i>断开连接</i>状态。
 </p><p>如果存储库已断开连接，则可以通过双击它或在其上下文菜单中选择“连接”来连接它。当打开来自此存储库的现有签出时，它会自动连接。
 </p><p>如果存储库已连接，则可以通过在其上下文菜单中选择“断开连接”来断开连接。当<a href="Doc01_UserInterface.html#Doc_PreferencePages" title="CDO模型存储库文档中的章节">配置的超时时间</a>已过，并且在此期间未使用存储库时，它会自动断开连接。

</p><h2><a name="Doc_RepositoryShowIn"></a> 5在其他视图中显示存储库</h2>
<p>通过选择存储库，打开其上下文菜单，打开Show In子菜单以及选择Show In操作之一，可以在许多其他视图中显示存储库，具体取决于存储库的类型。
 </p><p>本地存储库可以在以下视图中显示：</p><p align="center"><img src="repository-local-showin.png">

 </p><p>远程存储库可以在以下视图中显示：</p><p align="center"><img src="repository-remote-showin.png">


</p><h3><a name="Doc_RepositoryShowInSessions"></a> 5.1在CDO会话视图中显示存储库</h3>
<p>所有存储库都可以在<a href="Doc01_UserInterface.html#Doc_SessionsView" title="CDO模型存储库文档中的章节">CDO Sessions视图中显示</a> ：</p><p align="center"><img src="sessions-view.png">

 </p><p>在CDO会话视图中打开与所选存储库具有相同目标存储库的新<a href="../../javadoc/org/eclipse/emf/cdo/session/CDOSession.html" title="org.eclipse.emf.cdo.session中的接口"><code>session</code></a> 。

</p><h3><a name="Doc_RepositoryShowInServerBrowser"></a> 5.2在CDO服务器浏览器中显示存储库</h3>
<p>本地存储库可以在CDO服务器浏览器中显示：</p><p align="center"><img src="server-browser.png">

 </p><p>CDO Server Browser允许在Web浏览器中内省本地存储库的内部数据。它仅用于测试和调试目的。它<b>并不</b>意味着可以扩展到任意存储库大小的生产工具！

</p><h3><a name="Doc_RepositoryShowInProperties"></a> 5.3在属性视图中显示存储库</h3>
<p>所有存储库都可以在<a href="Doc01_UserInterface.html#Doc_PropertySheetIntegration" title="CDO模型存储库文档中的章节">Properties视图中显示</a> ：</p><p align="center"><img src="property-sheet.png">


</p><h3><a name="Doc_RepositoryShowInHistory"></a> 5.4在历史记录视图中显示存储库</h3>
<p>所有存储库都可以显示在“ <a href="Doc01_UserInterface.html#Doc_HistoryIntegration" title="CDO模型存储库文档中的章节">历史记录”视图中</a> ：</p><p align="center"><img src="history.png">

 </p><p>如果未启用“历史记录”视图工具栏中的“使用编辑器和选择链接”按钮，并且历史记录页面不会自动调整为工作台选择，则此功能特别有用。

</p><h3><a name="Doc_RepositoryShowInProjectExplorer"></a> 5.5在Project Explorer中显示存储库</h3>
<p>所有存储库都可以在<a href="Doc01_UserInterface.html#Doc_ProjectExplorerIntegration" title="CDO模型存储库文档中的章节">Project Explorer中显示</a> ，这意味着将选择所选存储库中的所有已配置检出。

</p><h3><a name="Doc_RepositoryShowInSystemExplorer"></a> 5.6在系统资源管理器中显示存储库</h3>
<p>所有存储库都可以在系统资源管理器中显示：</p><p align="center"><img src="system-explorer-repository.png">

 </p><p>每个存储库都拥有当前工作空间的.metadata下的专用目录。此目录包含repository.properties文件，该文件包含存储库的配置。本地存储库还将本地存储库的数据库存储在此目录中。

</p><p align="right">
<a href="Doc01_UserInterface.html" title="向后到用户界面的元素"><img src="../../images/backward.png" border="0"></a> <a href="Doc03_UsingBranches.html" title="转发到分支机构"><img src="../../images/forward.png" border="0"></a></p>
<!-- <div class="help_breadcrumbs breadcrumbs_bottom"><a href="../Overview.html" title="CDO Model Repository Documentation">CDO Model Repository Documentation</a> > <a href="index.html" title="Category in CDO Model Repository Documentation">User's Guide</a></div> -->

<div class="copyright">版权所有（c）2014 Eike Stepper（德国柏林）等。<br>版权所有。本程序及随附材料根据本发行版附带的Eclipse Public License v1.0条款提供，可从http://www.eclipse.org/legal/epl-v10.html获取。</div>
</body>
</html><html id="0063.ch-TutT6RefineChartAppearance.html" dir="ltr"></html><html lang="zh-Hans" dir="ltr" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"></meta>
    <meta http-equiv="Content-Style-Type" content="text/css"></meta>
    <!-- MOTW-DISABLED saved from url=(0014)about:internet -->
    <title>优化图表外观</title>
    <link rel="StyleSheet" href="css/ChartBasics.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"></link>
    <link rel="StyleSheet" href="webworks.css" type="text/css" media="all"></link>
    <script type="text/javascript" language="JavaScript1.2">
      <!--
        var  WebWorksRootPath = "";
      // -->
    </script>
  </head>
  <body dir="ltr">
    <div style="text-align:left">
      <table cellspacing="0" summary="">
        <tr>
          <td>
            <a href="ch-TutT5ChangeChartAndValueSeriesTitles.html"><img src="images/prev.gif" alt="以前" border="0"></a>
          </td>
          <td>
            <a href="cd-DisplayingDataInChartsIntro.html"><img src="images/next.gif" alt="下一个" border="0"></a>
          </td>
        </tr>
      </table>
    </div>
    <hr align="left">
    <blockquote>
      <h3 class="N_TutorialTask">任务6： <a name="409907">优化图表外观</a></h3>
      <p class="b_Body"><a name="409913">该图表包含标识每个扇区所呈现的数据值的标签。图例标识每个扇区代表的产品系列。虽然图例包含有用的信息，但它也会占用空间并减小饼图的大小，因此您可能需要进行权衡。一种可能性是删除图例并使用扇区标签来显示产品系列信息。当报表用户无法轻易区分颜色时，使用扇区标签而不是图例是更好的选择。每个数据标签显示类别信息和值信息。在这种情况下，类别信息是扇区名称，值信息是扇区的订单总数。</a></p>
      <p class="b_Body"><a name="369198">在以下示例中，标签标识了摩托车部门：</a></p>
      <div class="cf_CodeFirst"><a name="226792">摩托车：12,778</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="226041">要修改图例，请从左侧的导航列表中选择图例。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="247757">取消选择Visible，</a> <a href="#224381" title="优化图表外观">如图13-15</a> <a name="247757">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="167269"><img class="Default" src="images/ChartBasics.13.8.01.png" alt="图13-15格式图表的图例部分" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-15</b> <a name="224381">格式图表的图例部分</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">3</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="382062">现在，您可以将图例信息添加到扇区标签。导航到“值系列”格式设置部分，然后选择“标签”。系列标签出现，</a> <a href="#224523" title="优化图表外观">如图13-16</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="382109"><img class="Default" src="images/ChartBasics.13.8.02.png" alt="图13-16系列标签格式选项" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-16</b> <a name="224523">系列标签格式选项</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">4</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="469082">要将节名称添加到标签，请确保“值”区域的下拉列表中显示“类别数据”，然后选择“添加”。类别数据显示在列表中的值数据下方，</a> <a href="#224531" title="优化图表外观">如图13-17</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="182323"><img class="Default" src="images/ChartBasics.13.8.03.png" alt="图13-17向标签添加类别数据" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-17</b> <a name="224531">向标签添加类别数据</a></div>
      <div class="N_i_Indent1"><a name="182218">您需要重新排列标签数据，因此类别数据（产品系列名称）显示在图表标签中的值之前。例如，您希望标签读取Classic Cars，35,582而不是35,582，Classic Cars。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">五</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="271373">选择Value Data，然后选择Remove。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">6</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="369334">在下拉列表中，选择Value Data，然后选择Add，</a> <a href="#224539" title="优化图表外观">如图13-18</a> <a name="369334">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="182331"><img class="Default" src="images/ChartBasics.13.8.04.png" alt="图13-18从下拉列表中选择值数据" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-18</b> <a name="224539">从下拉列表中选择值数据</a></div>
      <div class="N_i_Indent1"><a name="182372">现在标签以正确的顺序显示信息，但您仍需要更改标签外观。在标签中使用多种信息时，可以在不同部分之间使用分隔符。默认分隔符是逗号。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">7</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="226148">要更改分隔符，请在Separator中键入冒号（:)，然后键入空格，</a> <a href="#241019" title="优化图表外观">如图13-19</a> <a name="226148">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="209622"><img class="Default" src="images/ChartBasics.13.8.05.png" alt="图13-19添加标签分隔符" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-19</b> <a name="241019">添加标签分隔符</a></div>
      <div class="N_i_Indent1"><a name="241024">要更改标签值部分的数字格式，请选择“值中的值数据”，然后选择“格式编辑器”。在“编辑格式”中，您可以更改日期和时间或数字数据的格式。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">8</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="182598">选择Standard，然后将Fraction Digits中的值更改为0，</a> <a href="#224575" title="优化图表外观">如图13-20</a> <a name="182598">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="167315"><img class="Default" src="images/ChartBasics.13.8.06.png" alt="图13-20修改标准数字格式" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-20</b> <a name="224575">修改标准数字格式</a></div>
      <div class="N_i_Indent1"><a name="167321">选择确定以关闭编辑格式。</a></div>
      <p class="N_si_ScanIcon"><a name="167322"><img class="Default" src="images/CH_FontEditorBtn.png" alt="字体编辑器按钮" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">9</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="389226">要更改标签文本的格式属性，请选择“字体编辑器”，</a> <a href="#224583" title="优化图表外观">如图13-21</a> <a name="389226">所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="182621"><img class="Default" src="images/ChartBasics.13.8.08.png" alt="图13-21从标签打开字体编辑器" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-21</b> <a name="224583">从标签打开字体编辑器</a></div>
      <div class="N_i_Indent1"><a name="170049">出现编辑字体。</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="226201">在Font中，选择Tahoma。然后，在Size中，键入11，</a> <a href="#224591" title="优化图表外观">如图13-22</a> 所示</a> 。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i3_Image3"><a name="170050"><img class="Default" src="images/CHT_EditFont.png" alt="图13-22编辑字体" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc3_FigCall3Title">
        <b class="Bold">图13-22</b> <a name="224591">编辑字体</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="241047">选择确定，然后关闭系列标签。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">10</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="291526">现在为将标签连接到扇区的引导线设置一致的长度。</a><a href="#386532" title="优化图表外观">图13-23</a>显示了在哪里可以找到引线设置。</div>
            </td>
          </tr>
        </table>
      </div>
      <p class="i2_Image2"><a name="311107"><img class="Default" src="images/ChartBasics.13.8.10.png" alt="图13-23编辑引导线和爆炸扇区" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-23</b> <a name="386532">编辑引导线和爆炸扇区</a></div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">1</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="386533">在Leader Line Style中，接受默认的Fixed Length。将领导者行长度更改为20。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_n2_NumList2_outer" style="margin-left:14.1732283464567pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n2_NumList2_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023FormatGray">2</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n2_NumList2_inner"><a name="386535">要分隔饼图扇区以便在它们之间显示设定量，请在“切片”中将“按距离”设置为3。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="386537">要使图表对报表用户更有用，</a>您可以添加交互式功能，例如超链接和突出显示。您可以将交互式要素添加到图表区域，图例，标记线以及图表的其他部分。</div>
      <div class="N_i_Indent1"><a name="386518">您已完成图表的创建和格式化。</a></div>
      <div class="N_n1_NumList1_outer" style="margin-left:0pt">
        <table border="0" cellspacing="0" cellpadding="0" summary="" role="presentation">
          <tr style="vertical-align:baseline">
            <td>
              <div class="N_n1_NumList1_inner" style="width:14.1732283464567pt;white-space:nowrap">
                <span class="zAuto_0023Format">11</span>
              </div>
            </td>
            <td width="100%">
              <div class="N_n1_NumList1_inner"><a name="386615">要关闭图表构建器并在布局编辑器中查看图表元素，请选择“完成”。然后，选择“预览”以预览图表。</a></div>
            </td>
          </tr>
        </table>
      </div>
      <div class="N_i_Indent1"><a name="390794">该图表</a> <a href="#293523" title="优化图表外观">如图13-24</a> <a name="390794">所示</a> 。完成的图表显示了每个扇区的类别名称以及扇区值。图表的大小和组织使得快速分析成为可能，同时仍提供详细数据。例如，用户可以立即看到最大的馅饼行业是Classic Cars，其中有35,582个订单，其次是Vintage Cars，其中有22,933个。两个汽车行业的总和都超过其他所有行业。其他产品系列组（如火车）不会提供大量订单。</div>
      <p class="i2_Image2"><a name="293521"><img class="Default" src="images/CHT_P4.png" alt="图13-24完成的教程图表" style="display:inline;float:none;left:0.0;top:0.0"></a></p>
      <div class="fc2_FigCall2Title">
        <b class="Bold">图13-24</b> <a name="293523">完成的教程图表</a></div>
      <p class="b_Body"><a name="296965"> </a></p>
    </blockquote>
    <hr align="left">
    <table align="right" summary="">
      <tr>
        <td class="WebWorks_Company_Name_Bottom">
          <a href="notices.html">（c）版权Actuate Corporation 2013</a>
        </td>
      </tr>
    </table>
  </body>
</html>