<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>代理验证</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="client-side-security.html" title="Previous" type="text/html"></link>
      <link rel="next" href="data-access-and-manipulation.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="client-side-security.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="data-access-and-manipulation.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="connection-and-security.html" property="item" typeof="WebPage"><span property="name">连接和安全</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">代理验证</li>
            </ol>
            <a id="GUID-07E0AF7F-2C9A-42E9-8B99-F2716DC3B746" name="GUID-07E0AF7F-2C9A-42E9-8B99-F2716DC3B746"></a><a id="JJDBC28352"></a>
            
            <h2 id="JJDBC-GUID-07E0AF7F-2C9A-42E9-8B99-F2716DC3B746" class="sect2"><span class="enumeration_chapter">10</span>代理验证</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Java数据库连接（JDBC）提供代理身份验证，也称为N层身份验证。JDBC Oracle调用接口（OCI）驱动程序和JDBC Thin驱动程序都支持此功能。本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="proxy-authentication.html#GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7">关于代理验证</a></p>
                  </li>
                  <li>
                     <p><a href="proxy-authentication.html#GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76">代理连接的类型</a></p>
                  </li>
                  <li>
                     <p><a href="proxy-authentication.html#GUID-BC74B296-1A83-4873-9293-2E9DC2A6C7DC">创建代理连接</a></p>
                  </li>
                  <li>
                     <p><a href="proxy-authentication.html#GUID-D8075A54-00DA-4879-B5D4-2362308EB861">关闭代理会话</a></p>
                  </li>
                  <li>
                     <p><a href="proxy-authentication.html#GUID-E2501FD0-AB8F-47B6-9CEC-B9503852C83B">高速缓存代理连接</a></p>
                  </li>
                  <li>
                     <p><a href="proxy-authentication.html#GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3">代理连接的限制</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-07E0AF7F-2C9A-42E9-8B99-F2716DC3B746__GUID-BDCDF9D2-7424-4C12-BD7F-F6470EF639E9">
                  <p class="notep1">注意：</p>
                  <p>Oracle数据库支持<span class="italic">只有</span>三层代理身份验证功能。它不支持多个中间层。
                  </p>
               </div>
            </div><a id="JJDBC28353"></a><div class="props_rev_3"><a id="GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7" name="GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7"></a><h3 id="JJDBC-GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7" class="sect3"><span class="enumeration_section">10.1</span>关于代理验证</h3>
               <div>
                  <p>代理身份验证是使用中间层进行用户身份验证的过程。您可以使用以下三种形式的代理身份验证，以安全的方式设计中间层服务器以代理客户端：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>中间层服务器使用数据库服务器和客户端对自身进行身份验证。在这种情况下，应用程序用户或其他应用程序使用中间层服务器对自身进行身份验证。客户端身份可以一直维护到数据库。</p>
                     </li>
                     <li>
                        <p>客户端（即数据库用户）未经中间层服务器验证。客户端的标识和数据库密码通过中间层服务器传递到数据库服务器以进行身份验证。</p>
                     </li>
                     <li>
                        <p>客户端（即全局用户）由中间层服务器进行身份验证，并通过中间层传递可分辨名称（DN）或证书以检索客户端的用户名。</p>
                        <div class="infoboxnote" id="GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7__GUID-C76A420C-7AD8-4BF4-B6EC-858638CD056B">
                           <p class="notep1">注意：</p>
                           <p>可以审核中间层服务器代表客户端执行的操作。</p>
                        </div>
                     </li>
                  </ul>
                  <p>在所有情况下，管理员必须授权中间层服务器代理客户端，即代表客户端行事。假设，中间层服务器最初以用户<code class="codeph">HR</code>身份连接到数据库并以用户<code class="codeph">jeff</code>激活代理连接，然后发出以下语句以授权中间层服务器代理客户端：</p><pre class="oac_no_warn" dir="ltr">ALTER USER jeff GRANT通过HR连接;</pre><p>你也可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>指定在作为客户端连接时允许中间层激活的角色。例如，</p><pre class="oac_no_warn" dir="ltr">CREATE ROLE role1; GRANT SELECT ON员工TO role1; ALTER USER jeff GRANT通过HR ROLE角色1连接;</pre><p>role子句仅限制对角色列表中提到的那些数据库对象的访问。角色列表可以为空。</p>
                     </li>
                     <li>
                        <p>通过查询<code class="codeph">PROXY_USERS</code>数据字典视图，查找当前有权通过中间层连接的用户。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">ALTER USER</code>语句的<code class="codeph">REVOKE CONNECT THROUGH</code>子句禁止代理连接。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-9DEFC135-8D15-4A24-8ECF-1E6FDE9AAAC7__GUID-10AE64C5-A346-48D4-B1B6-F3EB57327FD1">
                     <p class="notep1">注意：</p>
                     <p>在代理身份验证的情况下，与数据库的JDBC连接在身份验证期间创建数据库会话，然后可以在连接的生命周期内创建其他会话。</p>
                  </div>
                  <p>您需要使用<code class="codeph">oracle.jdbc.存在的不同字段和方法<code class="codeph">oracle.jdbc.OracleConnection</code>接口设置不同类型的代理连接。
                  </p>
               </div>
            </div><a id="JJDBC28354"></a><div class="props_rev_3"><a id="GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76" name="GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76"></a><h3 id="JJDBC-GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76" class="sect3"><span class="enumeration_section">10.2</span>代理连接的类型</h3>
               <div>
                  <div class="section">
                     <p>您可以使用以下任一选项创建代理连接：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">用户名</code></p>
                           <p>这是通过提供用户名或密码或两者来完成的。使用密码指定身份验证的SQL语句是：</p><pre class="oac_no_warn" dir="ltr">ALTER USER jeff GRANT通过人工授权<span class="italic">密码连接</span> ;</pre><p>在这种情况下， <code class="codeph">jeff</code>是用户名， <code class="codeph">HR</code>是<code class="codeph">jeff</code>的代理。
                           </p>
                           <p>密码选项存在以提高安全性。没有<code class="codeph">authenticated</code>子句意味着默认身份验证，它只使用没有密码的用户名。用于指定默认身份验证的SQL语句是：</p><pre class="oac_no_warn" dir="ltr">ALTER USER jeff GRANT通过HR连接</pre></li>
                        <li>
                           <p><code class="codeph">专有名称</code></p>
                           <p>这是一个全局名称，代替被代理用户的密码。使用专有名称的相应SQL语句的示例是：</p><pre class="oac_no_warn" dir="ltr">创建用户jeff全球识别为'CN = jeff，OU =美洲，O = oracle，L = redwoodshores，ST = ca，C = us';</pre><p><code class="codeph">identified globally as</code>子句<code class="codeph">identified globally as</code>的字符串是可分辨名称。然后，必须使用此专有名称进行身份验证。使用专有名称指定身份验证的相应SQL语句是：</p><pre class="oac_no_warn" dir="ltr">更改用户jeff GRANT通过HR认证连接使用明确的名称;</pre></li>
                        <li>
                           <p><code class="codeph">证书</code></p>
                           <p>这是将要代理的用户的凭据传递给数据库的更加加密的方式。证书包含编码在其中的可分辨名称。生成证书的一种方法是创建钱包，然后解码钱包以获取证书。可以使用<code class="codeph">runutl mkwallet</code>创建钱包。然后，必须使用生成的证书进行身份验证。使用证书指定身份验证的SQL语句是：</p><pre class="oac_no_warn" dir="ltr">ALTER USER jeff GRANT通过HR认证连接使用证书;</pre><div class="infoboxnote" id="GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76__GUID-F3D43EBE-25FD-43EB-8C18-1AC999EA79C1">
                              <p class="notep1">注意：</p>
                              <p>在将来的Oracle数据库版本中将不支持使用证书进行代理身份验证。</p>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-D36EFAC7-3A70-4650-9B8B-046E738EFD76__GUID-9B8270E6-0D4F-4E22-9DF6-41A2B240E304">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>所有选项都可以与角色相关联。</p>
                           </li>
                           <li>
                              <p>打开新的代理连接时，将在数据库服务器上启动新会话。如果你启动一个全局事务，然后调用<code class="codeph">openProxySession</code>方法，那么，此时，你不再是全局事务的一部分，而是就像你在一个新创建的JDBC连接中。通常，这不会发生，因为在创建或恢复全局事务之前调用<code class="codeph">openProxySession</code>方法。在这种情况下，您仍然是全局事务的一部分。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28355"></a><div class="props_rev_3"><a id="GUID-BC74B296-1A83-4873-9293-2E9DC2A6C7DC" name="GUID-BC74B296-1A83-4873-9293-2E9DC2A6C7DC"></a><h3 id="JJDBC-GUID-BC74B296-1A83-4873-9293-2E9DC2A6C7DC" class="sect3"><span class="enumeration_section">10.3</span>创建代理连接</h3>
               <div>
                  <div class="section">
                     <p>用户，比如<code class="codeph">jeff</code> ，必须通过另一个用户连接到数据库，比如<code class="codeph">HR</code> 。代理用户<code class="codeph">HR</code>应具有活动的经过身份验证的连接。然后在此活动连接上创建代理会话，驱动程序向服务器发出命令以为用户<code class="codeph">jeff</code>创建会话。服务器返回新的会话ID，驱动程序发送会话切换命令以切换到此新会话。
                     </p>
                     <p>JDBC OCI和Thin驱动程序以相同的方式切换会话。司机永久切换到新会议， <code class="codeph">jeff</code> 。因此，在新会话<code class="codeph">jeff</code>关闭之前，代理会话<code class="codeph">HR</code>不可用。
                     </p>
                     <div class="infoboxnote" id="GUID-BC74B296-1A83-4873-9293-2E9DC2A6C7DC__GUID-D1301ADB-63B2-4448-9274-61A946C5B763">
                        <p class="notep1">注意：</p>
                        <p>您可以使用<code class="codeph">oracle.jdbc.的<code class="codeph">isProxySession</code>方法<code class="codeph">oracle.jdbc.OracleConnection</code>接口，用于检查与您的连接关联的当前会话是否为代理会话。如果与连接关联的当前会话是代理会话，则此方法返回<code class="codeph">true</code> 。
                        </p>
                     </div>
                     <p>使用<code class="codeph">oracle.jdbc.的以下方法打开新的代理会话<code class="codeph">oracle.jdbc.OracleConnection</code>接口：</p><pre class="oac_no_warn" dir="ltr">void openProxySession（int type，java.util。属性prop）抛出SQLExceptionOpens</pre><p>哪里，</p>
                     <p><code class="codeph">type</code>是代理会话的类型，可以具有以下值：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">的OracleConnection。PROXYTYPE_USER_NAME</code></p>
                           <p>此类型用于指定用户名。</p>
                        </li>
                        <li>
                           <p><code class="codeph">的OracleConnection。PROXYTYPE_DISTINGUISHED_NAME</code></p>
                           <p>此类型用于指定用户的可分辨名称。</p>
                        </li>
                        <li>
                           <p><code class="codeph">的OracleConnection。PROXYTYPE_CERTIFICATE</code></p>
                           <p>此类型用于指定代理证书。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">prop</code>是代理会话的属性值，可以具有以下值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">PROXY_USER_NAME</code></p>
                           <p>此属性值应与<code class="codeph">OracleConnection.类型一起使用<code class="codeph">OracleConnection.PROXYTYPE_USER_NAME</code> 。该值应该是<code class="codeph">java.lang.String</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PROXY_DISTINGUISHED_NAME</code></p>
                           <p>此属性值应与<code class="codeph">OracleConnection.类型一起使用<code class="codeph">OracleConnection.PROXYTYPE_DISTINGUISHED_NAME</code> 。该值应该是<code class="codeph">java.lang.String</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PROXY_CERTIFICATE</code></p>
                           <p>此属性值应与<code class="codeph">OracleConnection.类型一起使用<code class="codeph">OracleConnection.PROXYTYPE_CERTIFICATE</code> 。该值是包含证书的<code class="codeph">bytep[]</code>数组。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PROXY_ROLES</code></p>
                           <p>此属性值可与以下类型一起使用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">的OracleConnection。PROXYTYPE_USER_NAME</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">的OracleConnection。PROXYTYPE_DISTINGUISHED_NAME</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">的OracleConnection。PROXYTYPE_CERTIFICATE</code></p>
                              </li>
                           </ul>
                           <p>该值应该是<code class="codeph">java.lang.String</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PROXY_SESSION</code></p>
                           <p>此属性值与<code class="codeph">close</code>方法一起使用以关闭代理会话。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PROXY_USER_PASSWORD</code></p>
                           <p>此属性值应与<code class="codeph">OracleConnection.类型一起使用<code class="codeph">OracleConnection.PROXYTYPE_USER_NAME</code> 。该值应该是<code class="codeph">java.lang.String</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>以下代码段显示了<code class="codeph">openProxySession</code>方法的<code class="codeph">openProxySession</code> ：</p><pre class="oac_no_warn" dir="ltr">java.util中。属性prop = new java.util。属性（）; prop.put（的OracleConnection。PROXY_USER_NAME，“jeff”）; String [] roles = {“role1”，“role2”}; prop.put（的OracleConnection。PROXY_ROLES，角色）; conn.openProxySession（的OracleConnection。PROXYTYPE_USER_NAME，prop）;</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28356"></a><div class="props_rev_3"><a id="GUID-D8075A54-00DA-4879-B5D4-2362308EB861" name="GUID-D8075A54-00DA-4879-B5D4-2362308EB861"></a><h3 id="JJDBC-GUID-D8075A54-00DA-4879-B5D4-2362308EB861" class="sect3"><span class="enumeration_section">10.4</span>关闭代理会话</h3>
               <div>
                  <div class="section">
                     <p>您可以通过传递<code class="codeph">OracleConnection.来关闭使用<code class="codeph">OracleConnection.openProxySession</code>方法打开的代理会话<code class="codeph">OracleConnection.通过以下方式将<code class="codeph">OracleConnection.close</code>方法的PROXY_SESSION</code>参数：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">OracleConnection.close</code> （OracleConnection。PROXY_SESSION）;</pre><p>这类似于在非缓存连接上关闭代理会话。必须显式调用标准<code class="codeph">close</code>方法才能关闭连接本身。如果直接调用<code class="codeph">close</code>方法，而不关闭代理会话，则会关闭代理会话和连接。这可以通过以下方式实现：</p><pre class="oac_no_warn" dir="ltr">OracleConnection.close（的OracleConnection。INVALID_CONNECTION）;</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28357"></a><div class="props_rev_3"><a id="GUID-E2501FD0-AB8F-47B6-9CEC-B9503852C83B" name="GUID-E2501FD0-AB8F-47B6-9CEC-B9503852C83B"></a><h3 id="JJDBC-GUID-E2501FD0-AB8F-47B6-9CEC-B9503852C83B" class="sect3"><span class="enumeration_section">10.5</span>高速缓存代理连接</h3>
               <div>
                  <div class="section">
                     <p>可以缓存代理连接（如标准连接）。缓存代理连接可提高性能。要缓存代理连接，您需要在启用缓存的<code class="codeph">OracleDataSource</code>对象上使用其中一个<code class="codeph">getConnection</code>方法创建连接。
                     </p>
                     <p>可以使用连接高速缓存的连接属性功能将代理连接高速缓存在连接高速缓存中。连接属性是用户定义的名称/值对，并在将连接返回到连接缓存以供重用之前帮助标记连接。检索标记连接时，可以直接使用它，而无需进行往返创建或关闭代理会话。Universal Connection Pool支持缓存任何用户/密码验证的连接。因此，可以缓存和检索任何用户身份验证的代理连接。</p>
                     <p>建议不应用连接属性来关闭代理连接。如果在未应用连接属性的情况下关闭代理连接，则会将连接返回到连接缓存以供重用，但无法检索。连接缓存机制不记得或重置会话状态。</p>
                     <p>通过直接关闭连接，可以从连接缓存中删除代理连接。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28359"></a><a id="JJDBC28360"></a><a id="JJDBC28358"></a><div class="props_rev_3"><a id="GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3" name="GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3"></a><h3 id="JJDBC-GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3" class="sect3"><span class="enumeration_section">10.6</span>代理连接的限制</h3>
               <div>
                  <div class="section">
                     <p>关闭代理连接会自动关闭代理连接在代理会话期间或代理会话之前创建的每个SQL语句。这可能会对应用程序池或语句缓存造成意外后果。以下代码示例解释了代理连接的此限制：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3__GUID-81E0E070-4A7F-46B3-ABEB-8224F19699C0">例1</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">....public void displayName（String N）//使用代理功能的任何函数{Properties props = new Properties（）; props.put（“PROXY_USER_NAME”，proxyUser）; c.openProxySession（的OracleConnection。PROXYTYPE_USER_NAME，道具）; .......c.close（的OracleConnection。PROXY_SESSION）; public static void main（String args []）抛出SQLException {............PreparedStatement pstmt = conn.prepareStatement（“SELECT first_name FROM EMPLOYEES WHERE employee_id =？“）; pstmt.setInt（1,205）; ResultSet rs = pstmt.executeQuery（）; while（rs.next（））{displayName（rs.getString（1））; if（rs.isClosed（）// The关闭连接时ResultSet已经关闭！{throw new Exception（“你的ResultSet已经过早关闭了！你的Statement对象现在也已经死了。“）;}}}</pre><p>在前面的示例中，当您关闭<code class="codeph">displayName</code>方法中的代理连接时， <code class="codeph">PreparedStatement</code>对象和<code class="codeph">ResultSet</code>对象也将关闭。因此，如果不在循环内检查<code class="codeph">ResultSet</code>对象的状态，则在第二次调用<code class="codeph">next</code>方法时循环将失败。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-036AD953-9692-4DB0-89E2-CED6A49FCDB3__GUID-76175ADC-3FE5-4E72-A6C9-D2DCDAC67691">例2</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">....PreparedStatement pstmt = conn.prepareStatement（“SELECT first_name FROM EMPLOYEES WHERE employee_id =？“）; pstmt.setString（1，”205“）; ResultSet rs = pstmt.executeQuery（）; while（rs.next（））{....}属性props = new Properties（）; props.put（“PROXY_USER_NAME”，proxyUser）; conn.openProxySession（的OracleConnection。PROXYTYPE_USER_NAME，道具）; .......conn.close（的OracleConnection。PROXY_SESSION）; //再次尝试使用PreparedStatement pstmt.setString（1，“28960”）; //这行代码将失败，因为在关闭连接时Statement已经关闭！rs = pstmt.executeQuery（）;</pre><p>在前面的示例中， <code class="codeph">PreparedStatement</code>对象和<code class="codeph">ResultSet</code>对象在打开代理连接之前正常工作。但是，如果在关闭代理连接后尝试执行相同的<code class="codeph">PreparedStatement</code>对象，则语句将失败。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>