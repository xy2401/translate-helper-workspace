<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">
      <meta name="description" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">
      <title>Using LogMiner to Analyze Redo Log Files</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Utilities ">
      <meta property="og:description" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Utilities">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96081-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="oracle-dbnewid-utility.html" title="Previous" type="text/html">
      <link rel="next" href="using-oracle-dbms_metadata-api.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities">
    <meta name="dcterms.isVersionOf" content="SUTIL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-dbnewid-utility.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-oracle-dbms_metadata-api.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Utilities </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="other-oracle-utilities.html" property="item" typeof="WebPage"><span property="name"> Other Utilities</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Using LogMiner to Analyze Redo Log Files</li>
            </ol>
            <a id="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" name="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5"></a><a id="SUTIL019"></a>
            
            <h2 id="SUTIL-GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" class="sect2"><span class="enumeration_chapter">22 </span> Using LogMiner to Analyze Redo Log Files
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface. </p>
               <p>Redo log files contain information about the history of activity on a database.</p>
               <p>See the following topics:</p>
               <p>You can use LogMiner from a command line or you can access it through the Oracle LogMiner Viewer graphical user interface. Oracle LogMiner Viewer is a part of Oracle Enterprise Manager. See the Oracle Enterprise Manager online Help for more information about Oracle LogMiner Viewer.</p>
               <div class="infoboxnote" id="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5__GUID-2E04A2C1-7634-4586-8467-6D0D5DCCD034">
                  <p class="notep1">Note:</p>The <code class="codeph">continuous_mine</code> option for the <code class="codeph">dbms_logmnr.start_logmnr</code> package is desupported in Oracle Database 19c (19.1), and is no longer available.
               </div>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D">LogMiner Benefits</a><br>All changes made to user data or to the database dictionary are recorded in the Oracle redo log files so that database recovery operations can be performed.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D">Introduction to LogMiner</a><br>These topics provide a brief introduction to LogMiner, including the following topics.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093">Using LogMiner in a CDB</a><br>You can use LogMiner in a multitenant container database (CDB).
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5">LogMiner Dictionary Files and Redo Log Files</a><br>Before you begin using LogMiner, it is important to understand how LogMiner works with the LogMiner dictionary file (or files) and redo log files. This will help you to get accurate results and to plan the use of your system resources.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5">Starting LogMiner</a><br>Call the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure to start LogMiner. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D">Querying V$LOGMNR_CONTENTS for Redo Data of Interest</a><br>You access the redo data of interest by querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a><br>LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the <code class="codeph">V$LOGMNR_CONTENTS</code> view, and the speed at which it is returned.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39">Reapplying DDL Statements Returned to V$LOGMNR_CONTENTS</a><br>Some DDL statements that you issue cause Oracle to internally execute one or more other DDL statements.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-4959F073-BE00-4170-BFDC-4722D5770639">Calling DBMS_LOGMNR.START_LOGMNR Multiple Times</a><br>Even after you have successfully called <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> and selected from the <code class="codeph">V$LOGMNR_CONTENTS</code> view, you can call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again without ending the current LogMiner session and specify different options and time or SCN ranges. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E">Supplemental Logging</a><br>Describes supplemental logging.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39">Accessing LogMiner Operational Information in Views</a><br>LogMiner operational information (as opposed to redo data) is contained in views. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760">Steps in a Typical LogMiner Session</a><br>Describes the steps in a typical LogMiner session. 
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98">Examples Using LogMiner</a><br>Examples using LogMiner.
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A">Supported Data Types, Storage Attributes, and Database and Redo Log File Versions</a><br>Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="other-oracle-utilities.html#GUID-FCEA49BD-D3AF-4337-88F1-3A23545F35A6">Other Utilities</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1552"></a><div class="props_rev_3"><a id="GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D" name="GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D"></a><h3 id="SUTIL-GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D" class="sect3"><span class="enumeration_section">22.1 </span>LogMiner Benefits
               </h3>
               <div>
                  <p>All changes made to user data or to the database dictionary are recorded in the Oracle redo log files so that database recovery operations can be performed.</p>
                  <p>Because LogMiner provides a well-defined, easy-to-use, and comprehensive relational interface to redo log files, it can be used as a powerful data auditing tool, and also as a sophisticated data analysis tool. The following list describes some key capabilities of LogMiner:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Pinpointing when a logical corruption to a database, such as errors made at the application level, may have begun. These might include errors such as those where the wrong rows were deleted because of incorrect values in a <code class="codeph">WHERE</code> clause, rows were updated with incorrect values, the wrong index was dropped, and so forth. For example, a user application could mistakenly update a database to give all employees 100 percent salary increases rather than 10 percent increases, or a database administrator (DBA) could accidently delete a critical system table. It is important to know exactly when an error was made so that you know when to initiate time-based or change-based recovery. This enables you to restore the database to the state it was in just before corruption. See <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner lets you make queries based on column values.">Querying V$LOGMNR_CONTENTS Based on Column Values</a> for details about how you can use LogMiner to accomplish this.
                        </p>
                     </li>
                     <li>
                        <p>Determining what actions you would have to take to perform fine-grained recovery at the transaction level. If you fully understand and take into account existing dependencies, then it may be possible to perform a table-specific undo operation to return the table to its original state. This is achieved by applying table-specific reconstructed SQL statements that LogMiner provides in the reverse order from which they were originally issued. See <a href="oracle-logminer-utility.html#GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4">Scenario 1: Using LogMiner to Track Changes Made by a Specific User</a> for an example.
                        </p>
                        <p>Normally you would have to restore the table to its previous state, and then apply an archived redo log file to roll it forward. </p>
                     </li>
                     <li>
                        <p>Performance tuning and capacity planning through trend analysis. You can determine which tables get the most updates and inserts. That information provides a historical perspective on disk access statistics, which can be used for tuning purposes. See <a href="oracle-logminer-utility.html#GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" title="This scenario describes how to use LogMiner to calculate table access statistics.">Scenario 2: Using LogMiner to Calculate Table Access Statistics</a> for an example.
                        </p>
                     </li>
                     <li>
                        <p>Performing postauditing. LogMiner can be used to track any data manipulation language (DML) and data definition language (DDL) statements executed on the database, the order in which they were executed, and who executed them. (However, to use LogMiner for such a purpose, you need to have an idea when the event occurred so that you can specify the appropriate logs for analysis; otherwise you might have to mine a large number of redo log files, which can take a long time. Consider using LogMiner as a complementary activity to auditing database use. See the <a href="../admin/managing-users-and-securing-the-database.html#ADMIN11241" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about database auditing.)
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1553"></a><div class="props_rev_3"><a id="GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" name="GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D"></a><h3 id="SUTIL-GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" class="sect3"><span class="enumeration_section">22.2 </span>Introduction to LogMiner
               </h3>
               <div>
                  <p>These topics provide a brief introduction to LogMiner, including the following topics.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF">LogMiner Configuration</a><br>Describes four basic objects in a LogMiner configurations.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-ED46E42D-B412-4820-9753-EBE15F49BA21">Directing LogMiner Operations and Retrieving Data of Interest</a><br>You direct LogMiner operations using the <code class="codeph">DBMS_LOGMNR</code> and <code class="codeph">DBMS_LOGMNR_D</code> PL/SQL packages, and retrieve data of interest using the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1554"></a><div class="props_rev_3"><a id="GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" name="GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF"></a><h4 id="SUTIL-GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" class="sect4"><span class="enumeration_section">22.2.1 </span>LogMiner Configuration
                  </h4>
                  <div>
                     <p>Describes four basic objects in a LogMiner configurations.</p>
                     <p>Specifically, you should be familiar with: the source database, the mining database, the LogMiner dictionary, and the redo log files containing the data of interest:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <span class="bold">source database</span> is the database that produces all the redo log files that you want LogMiner to analyze. 
                           </p>
                        </li>
                        <li>
                           <p>The <span class="bold">mining database</span> is the database that LogMiner uses when it performs the analysis. 
                           </p>
                        </li>
                        <li>
                           <p>The <span class="bold">LogMiner dictionary </span>allows LogMiner to provide table and column names, instead of internal object IDs, when it presents the redo log data that you request.
                           </p>
                           <p>LogMiner uses the dictionary to translate internal object identifiers and data types to object names and external data formats. Without a dictionary, LogMiner returns internal object IDs and presents data as binary data.</p>
                           <p>For example, consider the following SQL statement:</p><pre class="oac_no_warn" dir="ltr"> INSERT INTO HR.JOBS(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)  VALUES('IT_WT','Technical Writer', 4000, 11000);
</pre><p>Without the dictionary, LogMiner will display:</p><pre class="oac_no_warn" dir="ltr">insert into "UNKNOWN"."OBJ# 45522"("COL 1","COL 2","COL 3","COL 4") values
(HEXTORAW('45465f4748'),HEXTORAW('546563686e6963616c20577269746572'),
HEXTORAW('c229'),HEXTORAW('c3020b'));
</pre></li>
                        <li>
                           <p>The <span class="bold">redo log files</span> contain the changes made to the database or database dictionary.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5">Sample LogMiner Configuration</a><br>Describes a LogMiner configuration.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4">Requirements</a><br>Describes the requirements for the source and mining database, the data dictionary, and the redo log files that LogMiner will mine.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" title="These topics provide a brief introduction to LogMiner, including the following topics.">Introduction to LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3613"></a><a id="SUTIL1555"></a><div class="props_rev_3"><a id="GUID-03892F75-767E-4462-9865-9843F1502AD5" name="GUID-03892F75-767E-4462-9865-9843F1502AD5"></a><h5 id="SUTIL-GUID-03892F75-767E-4462-9865-9843F1502AD5" class="sect5"><span class="enumeration_section">22.2.1.1 </span>Sample LogMiner Configuration
                     </h5>
                     <div>
                        <p>Describes a LogMiner configuration.</p>
                        <p><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">Figure 22-1</a> shows a sample LogMiner configuration. In this figure, the source database in Boston generates redo log files that are archived and shipped to a database in San Francisco. A LogMiner dictionary has been extracted to these redo log files. The mining database, where LogMiner will actually analyze the redo log files, is in San Francisco. The Boston database is running Oracle Database 11<span class="italic">g</span> and the San Francisco database is running Oracle Database 12<span class="italic">c.</span></p>
                        <div class="figure" id="GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">
                           <p class="titleinfigure">Figure 22-1 Sample LogMiner Database Configuration</p><img src="img/remote_config.gif" width="455" alt="Description of Figure 22-1 follows" title="Description of Figure 22-1 follows" longdesc="img_text/remote_config.html"><br><a href="img_text/remote_config.html">Description of "Figure 22-1 Sample LogMiner Database Configuration"</a></div>
                        <!-- class="figure" -->
                        <p><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">Figure 22-1</a> shows just one valid LogMiner configuration. Other valid configurations are those that use the same database for both the source and mining database, or use another method for providing the data dictionary. These other data dictionary options are described in <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you.">LogMiner Dictionary Options</a>.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" title="Describes four basic objects in a LogMiner configurations.">LogMiner Configuration</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1556"></a><div class="props_rev_3"><a id="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4" name="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4"></a><h5 id="SUTIL-GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4" class="sect5"><span class="enumeration_section">22.2.1.2 </span>Requirements
                     </h5>
                     <div>
                        <p>Describes the requirements for the source and mining database, the data dictionary, and the redo log files that LogMiner will mine.</p>
                        <p>Specifically:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Source and mining database </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Both the source database and the mining database must be running on the same hardware platform.</p>
                                 </li>
                                 <li>
                                    <p>The mining database can be the same as, or completely separate from, the source database.</p>
                                 </li>
                                 <li>
                                    <p>The mining database must run the same release or a later release of the Oracle Database software as the source database.</p>
                                 </li>
                                 <li>
                                    <p>The mining database must use the same character set (or a superset of the character set) used by the source database.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>LogMiner dictionary </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The dictionary must be produced by the same source database that generates the redo log files that LogMiner will analyze.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>All redo log files:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Must be produced by the same source database.</p>
                                 </li>
                                 <li>
                                    <p>Must be associated with the same database <code class="codeph">RESETLOGS SCN</code>. 
                                    </p>
                                 </li>
                                 <li>
                                    <p>Must be from a release 8.0 or later Oracle Database. However, several of the LogMiner features introduced as of release 9.0.1 work only with redo log files produced on an Oracle9<span class="italic">i</span> or later database. See <a href="oracle-logminer-utility.html#GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" title="Describes supported database releases and redo log file versions.">Supported Databases and Redo Log File Versions</a>.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>LogMiner does not allow you to mix redo log files from different databases or to use a dictionary from a different database than the one that generated the redo log files to be analyzed.</p>
                        <div class="infoboxnote" id="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4__GUID-B5C5A29D-B28B-40AB-BF80-B9F977CEEDB4">
                           <p class="notep1">Note:</p>
                           <p>You must enable supplemental logging before generating log files that will be analyzed by LogMiner.</p>
                           <p>When you enable supplemental logging, additional information is recorded in the redo stream that is needed to make the information in the redo log files useful to you. Therefore, at the very least, you must enable minimal supplemental logging, as the following SQL statement shows:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
</pre><p>To determine whether supplemental logging is enabled, query the <code class="codeph">V$DATABASE</code> view, as the following SQL statement shows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT SUPPLEMENTAL_LOG_DATA_MIN FROM V$DATABASE;
</pre><p>If the query returns a value of <code class="codeph">YES</code> or <code class="codeph">IMPLICIT</code>, then minimal supplemental logging is enabled. See <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a> for complete information about supplemental logging.
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" title="Describes four basic objects in a LogMiner configurations.">LogMiner Configuration</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1557"></a><div class="props_rev_3"><a id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21" name="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21"></a><h4 id="SUTIL-GUID-ED46E42D-B412-4820-9753-EBE15F49BA21" class="sect4"><span class="enumeration_section">22.2.2 </span>Directing LogMiner Operations and Retrieving Data of Interest
                  </h4>
                  <div>
                     <p>You direct LogMiner operations using the <code class="codeph">DBMS_LOGMNR</code> and <code class="codeph">DBMS_LOGMNR_D</code> PL/SQL packages, and retrieve data of interest using the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </p>
                     <div class="section">
                        <p>For example:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Specify a LogMiner dictionary.</span><div>
                              <p>Use the <code class="codeph">DBMS_LOGMNR_D.BUILD</code> procedure or specify the dictionary when you start LogMiner (in Step 3), or both, depending on the type of dictionary you plan to use. 
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Specify a list of redo log files for analysis.</span><div>
                              <p>Use the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> procedure, or direct LogMiner to create a list of log files for analysis automatically when you start LogMiner (in Step 3).
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Start LogMiner.</span><div>
                              <p>Use the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Request the redo data of interest.</span><div>
                              <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>End the LogMiner session.</span><div>
                              <p>Use the <code class="codeph">DBMS_LOGMNR.END_LOGMNR</code> procedure.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>You must have the <code class="codeph">EXECUTE_CATALOG_ROLE</code> role and the <code class="codeph">LOGMINING</code> privilege to query the <code class="codeph">V$LOGMNR_CONTENTS</code> view and to use the LogMiner PL/SQL packages.
                        </p>
                        <div class="infoboxnote" id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21__GUID-33A8BFB1-3442-45CB-B6DE-5AC4C11FFC9B">
                           <p class="notep1">Note:</p>
                           <p>When mining a specified time or SCN range of interest within archived logs generated by an Oracle RAC database, you must ensure that you have specified all archived logs from all redo threads that were active during that time or SCN range. If you fail to do this, then any queries of <code class="codeph">V$LOGMNR_CONTENTS</code> return only partial results (based on the archived logs specified to LogMiner through the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> procedure). 
                           </p>
                           <p>The <code class="codeph">CONTINUOUS_MINE</code> option for the <code class="codeph">dbms_logmnr.start_logmnr</code> package is desupported in Oracle Database 19c (19.1), and is no longer available.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21__GUID-B0702866-FC79-4EA9-9E05-D6554DD08611">
                        <p class="notep1">See Also:</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a> for an example of using LogMiner
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" title="These topics provide a brief introduction to LogMiner, including the following topics.">Introduction to LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3926"></a><div class="props_rev_3"><a id="GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" name="GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093"></a><h3 id="SUTIL-GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" class="sect3"><span class="enumeration_section">22.3 </span>Using LogMiner in a CDB
               </h3>
               <div>
                  <p>You can use LogMiner in a multitenant container database (CDB).</p>
                  <p>The following sections discuss some differences to be aware of when using LogMiner in a CDB versus a non-CDB:</p>
                  <p>LogMiner supports CDBs that have PDBs of different character sets provided the root container has a character set that is a superset of all the PDBs.</p>
                  <p>To administer a multitenant environment you must have the <code class="codeph">CDB_DBA</code> role.
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0">LogMiner V$ Views and DBA Views in a CDB</a><br>In a CDB, views used by LogMiner to show information about LogMiner sessions running in the system contain an additional column named <code class="codeph">CON_ID</code>.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51">The V$LOGMNR_CONTENTS View in a CDB</a><br>In a CDB, the <code class="codeph">V$LOGMNR_CONTENTS</code> view and its associated functions are restricted to the root database. Several new columns exist in <code class="codeph">V$LOGMNR_CONTENTS</code> in support of CDBs.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0">Enabling Supplemental Logging in a CDB</a><br>In a CDB, the syntax for enabling and disabling database-wide supplemental logging is the same as in a non-CDB database
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-EF8A932F-7E71-4995-893E-E583B90007C2">Using a Flat File Dictionary in a CDB</a><br>You cannot take a dictionary snapshot for an entire CDB in a single flat file. You must be connected to a distinct PDB, and can take a snapshot of only that PDB in a flat file. 
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="oracle-logminer-utility.html#GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" title="In a CDB, views used by LogMiner to show information about LogMiner sessions running in the system contain an additional column named CON_ID.">LogMiner V$ Views and DBA Views in a CDB</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" title="In a CDB, the V$LOGMNR_CONTENTS view and its associated functions are restricted to the root database. Several new columns exist in V$LOGMNR_CONTENTS in support of CDBs.">The V$LOGMNR_CONTENTS View in a CDB</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" title="In a CDB, the syntax for enabling and disabling database-wide supplemental logging is the same as in a non-CDB database">Enabling Supplemental Logging in a CDB</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-EF8A932F-7E71-4995-893E-E583B90007C2" title="You cannot take a dictionary snapshot for an entire CDB in a single flat file. You must be connected to a distinct PDB, and can take a snapshot of only that PDB in a flat file.">Using a Flat File Dictionary in a CDB</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" name="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0"></a><h4 id="SUTIL-GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" class="sect4"><span class="enumeration_section">22.3.1 </span>LogMiner V$ Views and DBA Views in a CDB
                  </h4>
                  <div>
                     <p>In a CDB, views used by LogMiner to show information about LogMiner sessions running in the system contain an additional column named <code class="codeph">CON_ID</code>.
                     </p>
                     <p>The <code class="codeph">CON_ID</code> column identifies the container ID associated with the session for which information is being displayed. When you query the view from a pluggable database (PDB), only information associated with the database is displayed. The following views are affected by this new behavior:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">V$LOGMNR_DICTIONARY_LOAD</code>	
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">V$LOGMNR_LATCH</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V$LOGMNR_PROCESS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V$LOGMNR_SESSION</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V$LOGMNR_STATS</code></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0__GUID-98114A40-FAB4-40B7-AE82-FE364F882588">
                        <p class="notep1">Note:</p>
                        <p>To support CDBs, the <code class="codeph">V$LOGMNR_CONTENTS</code> view has several other new columns in addition to <code class="codeph">CON_ID</code>.
                        </p>
                     </div>
                     <p>The following DBA views have analogous CDB views whose names begin with CDB.</p>
                     <div class="tblformal" id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0__LOGMINERDBAANDCDBVIEWSDBAVIEWCDB_VI-FEBFF9B4">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="LogMiner DBA views and CDB Views " width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d135940e1135">Type of Log View</th>
                                 <th align="left" valign="bottom" width="33%" id="d135940e1137">DBA View</th>
                                 <th align="left" valign="bottom" width="33%" id="d135940e1140">CDB View</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1145" headers="d135940e1135 ">LogMiner Log Views</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1145 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_LOG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1145 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_LOG</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1156" headers="d135940e1135 ">LogMiner Purged Log Views</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1156 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_PURGED_LOG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1156 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_PURGED_LOG</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1167" headers="d135940e1135 ">LogMiner Session Log Views</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1167 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_SESSION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1167 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_SESSION</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>The DBA views show only information related to sessions defined in the container in which they are queried.</p>
                     <p>The CDB views contain an additional <code class="codeph">CON_ID</code> column, which identifies the container whose data a given row represents. When CDB views are queried from the root, they can be used to see information about all containers.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="You can use LogMiner in a multitenant container database (CDB).">Using LogMiner in a CDB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" name="GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51"></a><h4 id="SUTIL-GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" class="sect4"><span class="enumeration_section">22.3.2 </span>The V$LOGMNR_CONTENTS View in a CDB
                  </h4>
                  <div>
                     <p>In a CDB, the <code class="codeph">V$LOGMNR_CONTENTS</code> view and its associated functions are restricted to the root database. Several new columns exist in <code class="codeph">V$LOGMNR_CONTENTS</code> in support of CDBs.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">CON_ID</code> — contains the ID associated with the container from which the query is executed. Because <code class="codeph">V$LOGMNR_CONTENTS</code> is restricted to the root database, this column returns a value of 1 when a query is done on a CDB.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_NAME</code> — the PDB name. This information is available only when mining is performed with a LogMiner dictionary.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_ID</code> — the container ID of the PDB that generated the redo record. This information is available only when mining is performed with a LogMiner dictionary.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_DBID</code> — the PDB identifier. This information is available only when mining is performed with a current LogMiner dictionary.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_GUID</code> — contains the GUID associated with the PDB. This information is available only when mining is performed with a current LogMiner dictionary.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="You can use LogMiner in a multitenant container database (CDB).">Using LogMiner in a CDB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3929"></a><div class="props_rev_3"><a id="GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" name="GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0"></a><h4 id="SUTIL-GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" class="sect4"><span class="enumeration_section">22.3.3 </span>Enabling Supplemental Logging in a CDB
                  </h4>
                  <div>
                     <p>In a CDB, the syntax for enabling and disabling database-wide supplemental logging is the same as in a non-CDB database</p>
                     <div class="section">
                        <p>For example, use the following syntax when adding or dropping supplemental log data:</p><pre class="pre codeblock"><code>ALTER DATABASE [ADD|DROP] SUPPLEMENTAL LOG DATA ...
</code></pre><p>However, note the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>In a CDB, supplemental logging levels that are enabled from <code class="codeph">CDB$ROOT</code> are enabled across the CDB.
                              </p>
                           </li>
                           <li>
                              <p>If at least minimal supplemental logging is enabled in <code class="codeph">CDB$ROOT</code>, then additional supplemental logging levels can be enabled at the PDB level.
                              </p>
                           </li>
                           <li>
                              <p>Supplemental logging levels enabled at the CDB level from <code class="codeph">CDB$ROOT</code> cannot be disabled at the PDB level.
                              </p>
                           </li>
                           <li>
                              <p>Dropping all supplemental logging from <code class="codeph">CDB$ROOT</code> disables all supplemental logging across the CDB regardless of previous PDB level settings.
                              </p>
                           </li>
                        </ul>
                        <p>Supplemental logging operations started with <code class="codeph">CREATE TABLE</code> and <code class="codeph">ALTER TABLE</code> statements can be executed from either the CDB root or a PDB. They affect only the table to which they are applied.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="You can use LogMiner in a multitenant container database (CDB).">Using LogMiner in a CDB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL4227"></a><div class="props_rev_3"><a id="GUID-EF8A932F-7E71-4995-893E-E583B90007C2" name="GUID-EF8A932F-7E71-4995-893E-E583B90007C2"></a><h4 id="SUTIL-GUID-EF8A932F-7E71-4995-893E-E583B90007C2" class="sect4"><span class="enumeration_section">22.3.4 </span>Using a Flat File Dictionary in a CDB
                  </h4>
                  <div>
                     <p>You cannot take a dictionary snapshot for an entire CDB in a single flat file. You must be connected to a distinct PDB, and can take a snapshot of only that PDB in a flat file. </p>
                     <p>Thus, when using a flat file dictionary, you can only mine the redo logs for the changes associated with the PDB whose data dictionary is contained within the flat file.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="You can use LogMiner in a multitenant container database (CDB).">Using LogMiner in a CDB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1558"></a><div class="props_rev_3"><a id="GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" name="GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5"></a><h3 id="SUTIL-GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" class="sect3"><span class="enumeration_section">22.4 </span>LogMiner Dictionary Files and Redo Log Files
               </h3>
               <div>
                  <p>Before you begin using LogMiner, it is important to understand how LogMiner works with the LogMiner dictionary file (or files) and redo log files. This will help you to get accurate results and to plan the use of your system resources.</p>
                  <p>The following concepts are discussed in this section:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C">LogMiner Dictionary Options</a><br>LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0">Redo Log File Options</a><br>To mine data in the redo log files, LogMiner needs information about which redo log files to mine. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3614"></a><a id="SUTIL1559"></a><div class="props_rev_3"><a id="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" name="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C"></a><h4 id="SUTIL-GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" class="sect4"><span class="enumeration_section">22.4.1 </span>LogMiner Dictionary Options
                  </h4>
                  <div>
                     <p>LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you. </p>
                     <p>LogMiner gives you three options for supplying the dictionary:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="To direct LogMiner to use the dictionary currently in use for the database, specify the online catalog as your dictionary source when you start LogMiner.">Using the Online Catalog</a></p>
                           <p>Oracle recommends that you use this option when you will have access to the source database from which the redo log files were created and when no changes to the column definitions in the tables of interest are anticipated. This is the most efficient and easy-to-use option. </p>
                        </li>
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="To extract a LogMiner dictionary to the redo log files, the database must be open and in ARCHIVELOG mode and archiving must be enabled.">Extracting a LogMiner Dictionary to the Redo Log Files</a></p>
                           <p>Oracle recommends that you use this option when you do not expect to have access to the source database from which the redo log files were created, or if you anticipate that changes will be made to the column definitions in the tables of interest.</p>
                        </li>
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" title="When the LogMiner dictionary is in a flat file, fewer system resources are used than when it is contained in the redo log files. Oracle recommends that you regularly back up the dictionary extract to ensure correct analysis of older redo log files.">Extracting the LogMiner Dictionary to a Flat File </a></p>
                           <p>This option is maintained for backward compatibility with previous releases. This option does not guarantee transactional consistency. Oracle recommends that you use either the online catalog or extract the dictionary to redo log files instead.</p>
                        </li>
                     </ul>
                     <p></p>
                     <p><a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C__I1014713">Figure 22-2</a> shows a decision tree to help you select a LogMiner dictionary, depending on your situation.
                     </p>
                     <div class="figure" id="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C__I1014713">
                        <p class="titleinfigure">Figure 22-2 Decision Tree for Choosing a LogMiner Dictionary</p><img src="img/decision_tree.gif" width="564" alt="Description of Figure 22-2 follows" title="Description of Figure 22-2 follows" longdesc="img_text/decision_tree.html"><br><a href="img_text/decision_tree.html">Description of "Figure 22-2 Decision Tree for Choosing a LogMiner Dictionary"</a></div>
                     <!-- class="figure" -->
                     <p>The following sections provide instructions on how to specify each of the available dictionary options.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C">Using the Online Catalog</a><br>To direct LogMiner to use the dictionary currently in use for the database, specify the online catalog as your dictionary source when you start LogMiner.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC">Extracting a LogMiner Dictionary to the Redo Log Files</a><br>To extract a LogMiner dictionary to the redo log files, the database must be open and in <code class="codeph">ARCHIVELOG</code> mode and archiving must be enabled. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018">Extracting the LogMiner Dictionary to a Flat File</a><br>When the LogMiner dictionary is in a flat file, fewer system resources are used than when it is contained in the redo log files. Oracle recommends that you regularly back up the dictionary extract to ensure correct analysis of older redo log files.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" title="Before you begin using LogMiner, it is important to understand how LogMiner works with the LogMiner dictionary file (or files) and redo log files. This will help you to get accurate results and to plan the use of your system resources.">LogMiner Dictionary Files and Redo Log Files</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1560"></a><div class="props_rev_3"><a id="GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" name="GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C"></a><h5 id="SUTIL-GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" class="sect5"><span class="enumeration_section">22.4.1.1 </span>Using the Online Catalog
                     </h5>
                     <div>
                        <p>To direct LogMiner to use the dictionary currently in use for the database, specify the online catalog as your dictionary source when you start LogMiner.</p>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG);
</pre><p>In addition to using the online catalog to analyze online redo log files, you can use it to analyze archived redo log files, if you are on the same system that generated the archived redo log files. </p>
                        <p>The online catalog contains the latest information about the database and may be the fastest way to start your analysis. Because DDL operations that change important tables are somewhat rare, the online catalog generally contains the information you need for your analysis. </p>
                        <p>Remember, however, that the online catalog can only reconstruct SQL statements that are executed on the latest version of a table. As soon as a table is altered, the online catalog no longer reflects the previous version of the table. This means that LogMiner will not be able to reconstruct any SQL statements that were executed on the previous version of the table. Instead, LogMiner generates nonexecutable SQL (including hexadecimal-to-raw formatting of binary values) in the <code class="codeph">SQL_REDO</code> column of the <code class="codeph">V$LOGMNR_CONTENTS</code> view similar to the following example:
                        </p><pre class="oac_no_warn" dir="ltr">insert into HR.EMPLOYEES(col#1, col#2) values (hextoraw('4a6f686e20446f65'),
hextoraw('c306'));"
</pre><p>The online catalog option requires that the database be open.</p>
                        <p>The online catalog option is not valid with the <code class="codeph">DDL_DICT_TRACKING</code> option of <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you.">LogMiner Dictionary Options</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1561"></a><div class="props_rev_3"><a id="GUID-A0D89906-C787-4EB4-BA47-171A457445EC" name="GUID-A0D89906-C787-4EB4-BA47-171A457445EC"></a><h5 id="SUTIL-GUID-A0D89906-C787-4EB4-BA47-171A457445EC" class="sect5"><span class="enumeration_section">22.4.1.2 </span>Extracting a LogMiner Dictionary to the Redo Log Files
                     </h5>
                     <div>
                        <p>To extract a LogMiner dictionary to the redo log files, the database must be open and in <code class="codeph">ARCHIVELOG</code> mode and archiving must be enabled. 
                        </p>
                        <div class="section">
                           <p>While the dictionary is being extracted to the redo log stream, no DDL statements can be executed. Therefore, the dictionary extracted to the redo log files is guaranteed to be consistent (whereas the dictionary extracted to a flat file is not).</p>
                           <p>To extract dictionary information to the redo log files, execute the PL/SQL <code class="codeph">DBMS_LOGMNR_D.BUILD</code> procedure with the <code class="codeph">STORE_IN_REDO_LOGS</code> option. Do not specify a file name or location.
                           </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR_D.BUILD( -
   OPTIONS=&gt; DBMS_LOGMNR_D.STORE_IN_REDO_LOGS);</pre><div class="infoboxnotealso" id="GUID-A0D89906-C787-4EB4-BA47-171A457445EC__GUID-D9B78510-9691-4CD9-B3CB-6945BF1A9293">
                              <p class="notep1">See Also:</p>
                              <p></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../admin/managing-archived-redo-log-files.html#ADMIN11332" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about <code class="codeph">ARCHIVELOG</code> mode
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../arpls/DBMS_LOGMNR_D.html#ARPLS66816" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for a complete description of <code class="codeph">DBMS_LOGMNR_D.BUILD</code></p>
                                 </li>
                              </ul>
                           </div>
                           <p>The process of extracting the dictionary to the redo log files does consume database resources, but if you limit the extraction to off-peak hours, then this should not be a problem, and it is faster than extracting to a flat file. Depending on the size of the dictionary, it may be contained in multiple redo log files. If the relevant redo log files have been archived, then you can find out which redo log files contain the start and end of an extracted dictionary. To do so, query the <code class="codeph">V$ARCHIVED_LOG</code> view, as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG WHERE DICTIONARY_BEGIN='YES';
SELECT NAME FROM V$ARCHIVED_LOG WHERE DICTIONARY_END='YES';
</pre><p>Specify the names of the start and end redo log files, and other redo logs in between them, with the <code class="codeph">ADD_LOGFILE</code> procedure when you are preparing to begin a LogMiner session.
                           </p>
                           <p>Oracle recommends that you periodically back up the redo log files so that the information is saved and available at a later date. Ideally, this will not involve any extra steps because if your database is being properly managed, then there should already be a process in place for backing up and restoring archived redo log files. Again, because of the time required, it is good practice to do this during off-peak hours.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you.">LogMiner Dictionary Options</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1562"></a><div class="props_rev_3"><a id="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" name="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018"></a><h5 id="SUTIL-GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" class="sect5"><span class="enumeration_section">22.4.1.3 </span>Extracting the LogMiner Dictionary to a Flat File 
                     </h5>
                     <div>
                        <p>When the LogMiner dictionary is in a flat file, fewer system resources are used than when it is contained in the redo log files. Oracle recommends that you regularly back up the dictionary extract to ensure correct analysis of older redo log files.</p>
                        <div class="section">
                           <p>To extract database dictionary information to a flat file, use the <code class="codeph">DBMS_LOGMNR_D.BUILD</code> procedure with the <code class="codeph">STORE_IN_FLAT_FILE</code> option. 
                           </p>
                           <p>The following steps describe how to extract a dictionary to a flat file. Steps 1 and 2 are preparation steps. You only need to do them once, and then you can extract a dictionary to a flat file as many times as you want to.</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>The <code class="codeph">DBMS_LOGMNR_D.BUILD</code> procedure requires access to a directory where it can place the dictionary file. Because PL/SQL procedures do not normally access user directories, you must specify a directory location or the procedure will fail. The directory location must be a directory object. The following is an example of using the SQL <code class="codeph">CREATE DIRECTORY</code> statement to create a directory object named <code class="codeph">my_dictionary_dir</code> for the path <code class="codeph">/oracle/database</code>.</span><div><pre class="pre codeblock"><code>SQL&gt; CREATE DIRECTORY "my_dictionary_dir" AS '/oracle/database';
</code></pre></div>
                              <div>
                                 <div class="infoboxnote" id="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018__GUID-6516B852-F836-4968-80BD-7C41EB368818">
                                    <p class="notep1">Note:</p>Prior to Oracle Database 12<span class="italic">c</span> release 2 (12.2), you used the <code class="codeph">UTL_FILE_DIR</code> initialization parameter to specify a directory location. However, as of Oracle Database 18c , the <code class="codeph">UTL_FILE_DIR</code> initialization parameter is desupported. It is still supported for backward compatibility, but Oracle strongly recommends that you instead use directory objects.
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>If the database is closed, then use SQL*Plus to mount and open the database whose redo log files you want to analyze. For example, entering the SQL <code class="codeph">STARTUP</code> command mounts and opens the database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Execute the PL/SQL procedure <code class="codeph">DBMS_LOGMNR_D.BUILD</code>. The following example extracts the LogMiner dictionary file to a flat file named <code class="codeph">dictionary.ora</code> in the directory object <code class="codeph">my_dictionary_dir</code> that was created in step 1.</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE dbms_logmnr_d.build(dictionary_location=&gt;'my_dictionary_dir', - 
                                 dictionary_filename=&gt;'dictionary.ora', -
                                 options =&gt; dbms_logmnr_d.store_in_flat_file);</pre><p>You could also specify a file name and location without specifying the <code class="codeph">STORE_IN_FLAT_FILE</code> option. The result would be the same.
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you.">LogMiner Dictionary Options</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1563"></a><div class="props_rev_3"><a id="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0" name="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0"></a><h4 id="SUTIL-GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0" class="sect4"><span class="enumeration_section">22.4.2 </span>Redo Log File Options
                  </h4>
                  <div>
                     <p>To mine data in the redo log files, LogMiner needs information about which redo log files to mine. </p>
                     <p>Changes made to the database that are found in these redo log files are delivered to you through the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </p>
                     <p>You can direct LogMiner to automatically and dynamically create a list of redo log files to analyze, or you can explicitly specify a list of redo log files for LogMiner to analyze, as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Automatically</p>
                           <p>If LogMiner is being used on the source database, then you can direct LogMiner to find and create a list of redo log files for analysis automatically. Although this example specifies the dictionary from the online catalog, any LogMiner dictionary can be used.</p>
                           <div class="infoboxnote" id="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0__GUID-46B7D4FA-E19F-41BD-B0EF-B1BA5F2086CB">
                              <p class="notep1">Note:</p>The <code class="codeph">continuous_mine</code> option for the <code class="codeph">dbms_logmnr.start_logmnr</code> package is desupported in Oracle Database 19c (19.1), and is no longer available.
                           </div>
                           <p>LogMiner uses the database control file to find and adds redo log files that satisfy your specified time or SCN range to the LogMiner redo log file list. For example:</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';
EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   STARTTIME =&gt; '01-Jan-2012 08:30:00', -
   ENDTIME =&gt; '01-Jan-2012 08:45:00', -
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
   );
</pre><p> (To avoid the need to specify the date format in the PL/SQL call to the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure, this example uses the SQL <code class="codeph">ALTER</code> <code class="codeph">SESSION SET</code> <code class="codeph">NLS_DATE_FORMAT</code> statement first.)
                           </p>
                           <p>You can also direct LogMiner to automatically build a list of redo log files to analyze by specifying just one redo log file using <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>.The previously described method is more typical, however.
                           </p>
                        </li>
                        <li>
                           <p>Manually</p>
                           <p>Use the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> procedure to manually create a list of redo log files before you start LogMiner. After the first redo log file has been added to the list, each subsequently added redo log file must be from the same database and associated with the same database RESETLOGS SCN. When using this method, LogMiner need not be connected to the source database. 
                           </p>
                           <p>For example, to start a new list of redo log files, specify the <code class="codeph">NEW</code> option of the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL/SQL procedure to signal that this is the beginning of a new list. For example, enter the following to specify <code class="codeph">/oracle/logs/log1.f</code>:
                           </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/oracle/logs/log1.f', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);
</pre><p>If desired, add more redo log files by specifying the <code class="codeph">ADDFILE</code> option of the <code class="codeph">PL/SQL DBMS_LOGMNR.ADD_LOGFILE</code> procedure. For example, enter the following to add <code class="codeph">/oracle/logs/log2.f</code>:
                           </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/oracle/logs/log2.f', -
   OPTIONS =&gt; DBMS_LOGMNR.ADDFILE);
</pre><p>To determine which redo log files are being analyzed in the current LogMiner session, you can query the <code class="codeph">V$LOGMNR_LOGS</code> view, which contains one row for each redo log file.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" title="Before you begin using LogMiner, it is important to understand how LogMiner works with the LogMiner dictionary file (or files) and redo log files. This will help you to get accurate results and to plan the use of your system resources.">LogMiner Dictionary Files and Redo Log Files</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1564"></a><div class="props_rev_3"><a id="GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5" name="GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5"></a><h3 id="SUTIL-GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5" class="sect3"><span class="enumeration_section">22.5 </span>Starting LogMiner
               </h3>
               <div>
                  <p>Call the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure to start LogMiner. 
                  </p>
                  <p>Because the options available with the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure allow you to control output to the <code class="codeph">V$LOGMNR_CONTENTS</code> view, you must call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> before querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                  </p>
                  <p>When you start LogMiner, you can:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Specify how LogMiner should filter data it returns (for example, by starting and ending time or SCN value)</p>
                     </li>
                     <li>
                        <p>Specify options for formatting the data returned by LogMiner</p>
                     </li>
                     <li>
                        <p>Specify the LogMiner dictionary to use</p>
                     </li>
                  </ul>
                  <p>The following list is a summary of LogMiner settings that you can specify with the <code class="codeph">OPTIONS</code> parameter to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> and where to find more information about them.
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DICT_FROM_ONLINE_CATALOG</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DICT_FROM_REDO_LOGS</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">COMMITTED_DATA_ONLY</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">SKIP_CORRUPTION</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">NO_SQL_DELIMITER</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">PRINT_PRETTY_SQL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">NO_ROWID_IN_STMT</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DDL_DICT_TRACKING</code></p>
                     </li>
                  </ul>
                  <p>When you execute the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure, LogMiner checks to ensure that the combination of options and parameters that you have specified is valid and that the dictionary and redo log files that you have specified are available. However, the <code class="codeph">V$LOGMNR_CONTENTS</code> view is not populated until you query the view. 
                  </p>
                  <p>Note that parameters and options are not persistent across calls to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>. You must specify all desired parameters and options (including SCN and time ranges) each time you call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>.
                  </p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" name="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D"></a><h3 id="SUTIL-GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" class="sect3"><span class="enumeration_section">22.6 </span>Querying V$LOGMNR_CONTENTS for Redo Data of Interest
               </h3>
               <div>
                  <p>You access the redo data of interest by querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                  </p>
                  <p> (Note that you must have either the <code class="codeph">SYSDBA</code> or <code class="codeph">LOGMINING</code> privilege to query <code class="codeph">V$LOGMNR_CONTENTS</code>.) This view provides historical information about changes made to the database, including (but not limited to) the following:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The type of change made to the database: <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, or <code class="codeph">DDL</code> (<code class="codeph">OPERATION</code> column).
                        </p>
                     </li>
                     <li>
                        <p>The SCN at which a change was made (<code class="codeph">SCN</code> column).
                        </p>
                     </li>
                     <li>
                        <p>The SCN at which a change was committed (<code class="codeph">COMMIT_SCN</code> column).
                        </p>
                     </li>
                     <li>
                        <p>The transaction to which a change belongs (<code class="codeph">XIDUSN</code>, <code class="codeph">XIDSLT</code>, and <code class="codeph">XIDSQN</code> columns).
                        </p>
                     </li>
                     <li>
                        <p>The table and schema name of the modified object (<code class="codeph">SEG_NAME</code> and <code class="codeph">SEG_OWNER</code> columns).
                        </p>
                     </li>
                     <li>
                        <p>The name of the user who issued the DDL or DML statement to make the change (<code class="codeph">USERNAME</code> column).
                        </p>
                     </li>
                     <li>
                        <p>If the change was due to a SQL DML statement, the reconstructed SQL statements showing SQL DML that is equivalent (but not necessarily identical) to the SQL DML used to generate the redo records (<code class="codeph">SQL_REDO</code> column). 
                        </p>
                     </li>
                     <li>
                        <p>If a password is part of the statement in a <code class="codeph">SQL_REDO</code> column, then the password is encrypted. <code class="codeph">SQL_REDO</code> column values that correspond to DDL statements are always identical to the SQL DDL used to generate the redo records.
                        </p>
                     </li>
                     <li>
                        <p>If the change was due to a SQL DML change, the reconstructed SQL statements showing the SQL DML statements needed to undo the change (<code class="codeph">SQL_UNDO</code> column). 
                        </p>
                        <p><code class="codeph">SQL_UNDO</code> columns that correspond to DDL statements are always <code class="codeph">NULL</code>. The <code class="codeph">SQL_UNDO</code> column may be <code class="codeph">NULL</code> also for some data types and for rolled back operations.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__LOGMINERSUPPORTSLOGMINERUTILITYSUPP-FEC1511D">
                     <p class="notep1">Note:</p>
                     <p>LogMiner supports Transparent Data Encryption (TDE), in that <code class="codeph">V$LOGMNR_CONTENTS</code> shows DML operations performed on tables with encrypted columns (including the encrypted columns being updated), provided the LogMiner data dictionary contains the metadata for the object in question and provided the appropriate master key is in the Oracle wallet. The wallet must be open or <code class="codeph">V$LOGMNR_CONTENTS</code> cannot interpret the associated redo records. TDE support is not available if the database is not open (either read-only or read-write). 
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__GUID-0BA85BA5-06F6-477E-9FFC-89CD224BC943">
                     <p class="notep1">See Also:</p>
                     <p><a href="../asoag/asopart1.html#ASOAG600" target="_blank"><span><cite>Oracle Database Advanced Security Guide</cite></span></a> for more information about TDE
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__GUID-177CB69E-F6B9-452A-B951-7AB398092FF1">Example of Querying V$LOGMNR_CONTENTS</p>
                     <p>To find any delete operations that a user named Ron performed on the <code class="codeph">oe.orders</code> table, issue a SQL query similar to the following:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, SQL_REDO, SQL_UNDO
   FROM V$LOGMNR_CONTENTS
   WHERE SEG_OWNER = 'OE' AND SEG_NAME = 'ORDERS' AND
   OPERATION = 'DELETE' AND USERNAME = 'RON';
</pre><p>The following output is produced by the query. The formatting may be different on your display than that shown here.</p><pre class="oac_no_warn" dir="ltr">OPERATION   SQL_REDO                        SQL_UNDO

DELETE      delete from "OE"."ORDERS"       insert into "OE"."ORDERS"        
            where "ORDER_ID" = '2413'       ("ORDER_ID","ORDER_MODE",
            and "ORDER_MODE" = 'direct'      "CUSTOMER_ID","ORDER_STATUS",
            and "CUSTOMER_ID" = '101'        "ORDER_TOTAL","SALES_REP_ID",
            and "ORDER_STATUS" = '5'         "PROMOTION_ID")
            and "ORDER_TOTAL" = '48552'      values ('2413','direct','101',
            and "SALES_REP_ID" = '161'       '5','48552','161',NULL);     
            and "PROMOTION_ID" IS NULL  
            and ROWID = 'AAAHTCAABAAAZAPAAN';

DELETE      delete from "OE"."ORDERS"        insert into "OE"."ORDERS"
            where "ORDER_ID" = '2430'        ("ORDER_ID","ORDER_MODE",
            and "ORDER_MODE" = 'direct'       "CUSTOMER_ID","ORDER_STATUS",
            and "CUSTOMER_ID" = '101'         "ORDER_TOTAL","SALES_REP_ID",
            and "ORDER_STATUS" = '8'          "PROMOTION_ID")
            and "ORDER_TOTAL" = '29669.9'     values('2430','direct','101',
            and "SALES_REP_ID" = '159'        '8','29669.9','159',NULL);
            and "PROMOTION_ID" IS NULL 
            and ROWID = 'AAAHTCAABAAAZAPAAe';
</pre><p>This output shows that user Ron deleted two rows from the <code class="codeph">oe.orders</code> table. The reconstructed SQL statements are equivalent, but not necessarily identical, to the actual statement that Ron issued. The reason for this difference is that the original <code class="codeph">WHERE</code> clause is not logged in the redo log files, so LogMiner can only show deleted (or updated or inserted) rows individually.
                     </p>
                     <p>Therefore, even though a single <code class="codeph">DELETE</code> statement may be responsible for the deletion of both rows, the output in <code class="codeph">V$LOGMNR_CONTENTS</code> does not reflect that fact. The actual <code class="codeph">DELETE</code> statement may have been <code class="codeph">DELETE FROM OE.ORDERS WHERE CUSTOMER_ID ='101</code>' or it may have been <code class="codeph">DELETE FROM OE.ORDERS WHERE PROMOTION_ID = NULL.</code></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91">How the V$LOGMNR_CONTENTS View Is Populated</a><br>The <code class="codeph">V$LOGMNR_CONTENTS</code> fixed view is unlike other views in that it is not a selective presentation of data stored in a table. Instead, it is a relational presentation of the data that you request from the redo log files. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A">Querying V$LOGMNR_CONTENTS Based on Column Values</a><br>LogMiner lets you make queries based on column values.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839">Querying V$LOGMNR_CONTENTS Based on XMLType Columns and Tables</a><br>LogMiner supports redo generated for <code class="codeph">XMLType</code> columns. <code class="codeph">XMLType</code> data stored as <code class="codeph">CLOB</code> is supported when redo is generated at a compatibility setting of 11.0.0.0 or higher.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91" name="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91"></a><h4 id="SUTIL-GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91" class="sect4"><span class="enumeration_section">22.6.1 </span>How the V$LOGMNR_CONTENTS View Is Populated
                  </h4>
                  <div>
                     <p>The <code class="codeph">V$LOGMNR_CONTENTS</code> fixed view is unlike other views in that it is not a selective presentation of data stored in a table. Instead, it is a relational presentation of the data that you request from the redo log files. 
                     </p>
                     <p>LogMiner populates the view only in response to a query against it. You must successfully start LogMiner before you can query <code class="codeph">V$LOGMNR_CONTENTS.</code></p>
                     <p>When a SQL select operation is executed against the <code class="codeph">V$LOGMNR_CONTENTS</code> view, the redo log files are read sequentially. Translated information from the redo log files is returned as rows in the <code class="codeph">V$LOGMNR_CONTENTS</code> view. This continues until either the filter criteria specified at startup are met or the end of the redo log file is reached. 
                     </p>
                     <p>In some cases, certain columns in <code class="codeph">V$LOGMNR_CONTENTS</code> may not be populated. For example:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">TABLE_SPACE</code> column is not populated for rows where the value of the <code class="codeph">OPERATION</code> column is <code class="codeph">DDL</code>. This is because a DDL may operate on more than one tablespace. For example, a table can be created with multiple partitions spanning multiple table spaces; hence it would not be accurate to populate the column.
                           </p>
                        </li>
                        <li>
                           <p>LogMiner does not generate SQL redo or SQL undo for temporary tables. The <code class="codeph">SQL_REDO</code> column will contain the string <code class="codeph">"/* No SQL_REDO for temporary tables */"</code> and the <code class="codeph">SQL_UNDO</code> column will contain the string <code class="codeph">"/* No SQL_UNDO for temporary tables */"</code>.
                           </p>
                        </li>
                     </ul>
                     <p>LogMiner returns all the rows in SCN order unless you have used the <code class="codeph">COMMITTED_DATA_ONLY</code> option to specify that only committed transactions should be retrieved. SCN order is the order normally applied in media recovery. 
                     </p>
                     <div class="infoboxnotealso" id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91__SHOWINGONLYCOMMITTEDTRANSACTIONSFOR-FEC34E1B">
                        <p class="notep1">See Also:</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" title="When using the COMMITTED_DATA_ONLY option to DBMS_LOGMNR.START_LOGMNR, only rows belonging to committed transactions are shown in the V$LOGMNR_CONTENTS view.">Showing Only Committed Transactions</a> for more information about the <code class="codeph">COMMITTED_DATA_ONLY</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code></p>
                     </div>
                     <div class="infoboxnote" id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91__BECVLOGMNR_CONTENTSVIEWIMPACTOFQUER-FEC349FD">
                        <p class="notep1">Note:</p>
                        <p>Because LogMiner populates the <code class="codeph">V$LOGMNR_CONTENTS</code> view only in response to a query and does not store the requested data in the database, the following is true:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Every time you query <code class="codeph">V$LOGMNR_CONTENTS</code>, LogMiner analyzes the redo log files for the data you request. 
                              </p>
                           </li>
                           <li>
                              <p>The amount of memory consumed by the query is not dependent on the number of rows that must be returned to satisfy a query.</p>
                           </li>
                           <li>
                              <p>The time it takes to return the requested data is dependent on the amount and type of redo log data that must be mined to find that data.</p>
                           </li>
                        </ul>
                     </div>
                     <p>For the reasons stated in the previous note, Oracle recommends that you create a table to temporarily hold the results from a query of <code class="codeph">V$LOGMNR_CONTENTS</code> if you need to maintain the data for further analysis, particularly if the amount of data returned by a query is small in comparison to the amount of redo data that LogMiner must analyze to provide that data.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="You access the redo data of interest by querying the V$LOGMNR_CONTENTS view.">Querying V$LOGMNR_CONTENTS for Redo Data of Interest</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-CF064432-57A0-4891-ABE5-800DF327615A" name="GUID-CF064432-57A0-4891-ABE5-800DF327615A"></a><h4 id="SUTIL-GUID-CF064432-57A0-4891-ABE5-800DF327615A" class="sect4"><span class="enumeration_section">22.6.2 </span>Querying V$LOGMNR_CONTENTS Based on Column Values
                  </h4>
                  <div>
                     <p>LogMiner lets you make queries based on column values.</p>
                     <p>For instance, you can perform a query to show all updates to the <code class="codeph">hr.employees</code> table that increase <code class="codeph">salary</code> more than a certain amount. Data such as this can be used to analyze system behavior and to perform auditing tasks.
                     </p>
                     <p>LogMiner data extraction from redo log files is performed using two mine functions: <code class="codeph">DBMS_LOGMNR.MINE_VALUE</code> and <code class="codeph">DBMS_LOGMNR.COLUMN_PRESENT</code>. Support for these mine functions is provided by the <code class="codeph">REDO_VALUE</code> and <code class="codeph">UNDO_VALUE</code> columns in the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </p>
                     <p>The following is an example of how you could use the <code class="codeph">MINE_VALUE</code> function to select all updates to <code class="codeph">hr.employees</code> that increased the <code class="codeph">salary</code> column to more than twice its original value:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO FROM V$LOGMNR_CONTENTS
   WHERE
   SEG_NAME = 'EMPLOYEES' AND
   SEG_OWNER = 'HR' AND
   OPERATION = 'UPDATE' AND
   DBMS_LOGMNR.MINE_VALUE(REDO_VALUE, 'HR.EMPLOYEES.SALARY') &gt;
   2*DBMS_LOGMNR.MINE_VALUE(UNDO_VALUE, 'HR.EMPLOYEES.SALARY');
</pre><p>As shown in this example, the <code class="codeph">MINE_VALUE</code> function takes two arguments:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The first one specifies whether to mine the redo (<code class="codeph">REDO_VALUE</code>) or undo (<code class="codeph">UNDO_VALUE</code>) portion of the data. The redo portion of the data is the data that is in the column after an insert, update, or delete operation; the undo portion of the data is the data that was in the column before an insert, update, or delete operation. It may help to think of the <code class="codeph">REDO_VALUE</code> as the new value and the <code class="codeph">UNDO_VALUE</code> as the old value. 
                           </p>
                        </li>
                        <li>
                           <p>The second argument is a string that specifies the fully qualified name of the column to be mined (in this case, <code class="codeph">hr.employees.salary</code>). The <code class="codeph">MINE_VALUE</code> function always returns a string that can be converted back to the original data type. 
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A89673AD-EC53-4BA0-B298-D62291C5728B">The Meaning of NULL Values Returned by the MINE_VALUE Function</a><br>Describes the meaning of <code class="codeph">NULL</code> values returned by the <code class="codeph">MINE_VALUE</code> function.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290">Usage Rules for the MINE_VALUE and COLUMN_PRESENT Functions</a><br>Describes the usage rules that apply to the <code class="codeph">MINE_VALUE</code> and <code class="codeph">COLUMN_PRESENT</code> functions.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C">Restrictions When Using the MINE_VALUE Function To Get an NCHAR Value</a><br>Describes restrictions when using the <code class="codeph">MINE_VALUE</code> function.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="You access the redo data of interest by querying the V$LOGMNR_CONTENTS view.">Querying V$LOGMNR_CONTENTS for Redo Data of Interest</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1568"></a><div class="props_rev_3"><a id="GUID-A89673AD-EC53-4BA0-B298-D62291C5728B" name="GUID-A89673AD-EC53-4BA0-B298-D62291C5728B"></a><h5 id="SUTIL-GUID-A89673AD-EC53-4BA0-B298-D62291C5728B" class="sect5"><span class="enumeration_section">22.6.2.1 </span>The Meaning of NULL Values Returned by the MINE_VALUE Function
                     </h5>
                     <div>
                        <p>Describes the meaning of <code class="codeph">NULL</code> values returned by the <code class="codeph">MINE_VALUE</code> function.
                        </p>
                        <p>If the <code class="codeph">MINE_VALUE</code> function returns a <code class="codeph">NULL</code> value, then it can mean either:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The specified column is not present in the redo or undo portion of the data.</p>
                           </li>
                           <li>
                              <p>The specified column is present and has a null value.</p>
                           </li>
                        </ul>
                        <p>To distinguish between these two cases, use the <code class="codeph">DBMS_LOGMNR</code>.<code class="codeph">COLUMN_PRESENT</code> function which returns a <code class="codeph">1</code> if the column is present in the redo or undo portion of the data. Otherwise, it returns a <code class="codeph">0</code>. For example, suppose you wanted to find out the increment by which the values in the <code class="codeph">salary</code> column were modified and the corresponding transaction identifier. You could issue the following SQL query:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT 
  (XIDUSN || '.' || XIDSLT || '.' || XIDSQN) AS XID,
  (DBMS_LOGMNR.MINE_VALUE(REDO_VALUE, 'HR.EMPLOYEES.SALARY') -
   DBMS_LOGMNR.MINE_VALUE(UNDO_VALUE, 'HR.EMPLOYEES.SALARY')) AS INCR_SAL
   FROM V$LOGMNR_CONTENTS
   WHERE
   OPERATION = 'UPDATE' AND
   DBMS_LOGMNR.COLUMN_PRESENT(REDO_VALUE, 'HR.EMPLOYEES.SALARY') = 1 AND
   DBMS_LOGMNR.COLUMN_PRESENT(UNDO_VALUE, 'HR.EMPLOYEES.SALARY') = 1;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner lets you make queries based on column values.">Querying V$LOGMNR_CONTENTS Based on Column Values</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1569"></a><div class="props_rev_3"><a id="GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290" name="GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290"></a><h5 id="SUTIL-GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290" class="sect5"><span class="enumeration_section">22.6.2.2 </span>Usage Rules for the MINE_VALUE and COLUMN_PRESENT Functions
                     </h5>
                     <div>
                        <p>Describes the usage rules that apply to the <code class="codeph">MINE_VALUE</code> and <code class="codeph">COLUMN_PRESENT</code> functions.
                        </p>
                        <p>Specifically:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>They can only be used within a LogMiner session.</p>
                           </li>
                           <li>
                              <p>They must be started in the context of a select operation from the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                              </p>
                           </li>
                           <li>
                              <p>They do not support <code class="codeph">LONG</code>, <code class="codeph">LONG RAW,</code> <code class="codeph">CLOB,</code> <code class="codeph">BLOB,</code> <code class="codeph">NCLOB</code>, <code class="codeph">ADT</code>, or <code class="codeph">COLLECTION</code> data types.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner lets you make queries based on column values.">Querying V$LOGMNR_CONTENTS Based on Column Values</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4342"></a><div class="props_rev_3"><a id="GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C" name="GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C"></a><h5 id="SUTIL-GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C" class="sect5"><span class="enumeration_section">22.6.2.3 </span>Restrictions When Using the MINE_VALUE Function To Get an NCHAR Value
                     </h5>
                     <div>
                        <p>Describes restrictions when using the <code class="codeph">MINE_VALUE</code> function.
                        </p>
                        <div class="section">
                           <p>If the <code class="codeph">DBMS_LOGMNR.MINE_VALUE</code> function is used to get an <code class="codeph">NCHAR</code> value that includes characters not found in the database character set, then those characters are returned as the replacement character (for example, an inverted question mark) of the database character set.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner lets you make queries based on column values.">Querying V$LOGMNR_CONTENTS Based on Column Values</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DFDDD830-650B-4E46-A114-105F2995F839" name="GUID-DFDDD830-650B-4E46-A114-105F2995F839"></a><h4 id="SUTIL-GUID-DFDDD830-650B-4E46-A114-105F2995F839" class="sect4"><span class="enumeration_section">22.6.3 </span>Querying V$LOGMNR_CONTENTS Based on XMLType Columns and Tables
                  </h4>
                  <div>
                     <p>LogMiner supports redo generated for <code class="codeph">XMLType</code> columns. <code class="codeph">XMLType</code> data stored as <code class="codeph">CLOB</code> is supported when redo is generated at a compatibility setting of 11.0.0.0 or higher.
                     </p>
                     <p><code class="codeph">XMLType</code> data stored as object-relational and binary XML is supported for redo generated at a compatibility setting of 11.2.0.3 and higher. 
                     </p>
                     <p>LogMiner presents the <code class="codeph">SQL_REDO</code> in <code class="codeph">V$LOGMNR_CONTENTS</code> in different ways depending on the <code class="codeph">XMLType</code> storage. In all cases, the contents of the <code class="codeph">SQL_REDO</code> column, in combination with the <code class="codeph">STATUS</code> column, require careful scrutiny, and usually require reassembly before a SQL or PL/SQL statement can be generated to redo the change. There may be cases when it is not possible to use the <code class="codeph">SQL_REDO</code> data to construct such a change. The examples in the following subsections are based on <code class="codeph">XMLType</code> stored as <code class="codeph">CLOB</code> which is generally the simplest to use for reconstruction of the complete row change.
                     </p>
                     <div class="infoboxnote" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__XMLTYPEDATASTOREDASCLOBISDEPRECATED-FEC446CD">
                        <p class="notep1">Note:</p>
                        <p><code class="codeph">XMLType</code> data stored as <code class="codeph">CLOB</code> is deprecated as of Oracle Database 12<span class="italic">c</span> Release 1 (12.1).
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__QUERYINGVLOGMNR_CONTENTSFORCHANGEST-FEC44E6C">Querying V$LOGMNR_CONTENTS For Changes to Tables With XMLType Columns</p>
                        <p>The example in this section is for a table named <code class="codeph">XML_CLOB_COL_TAB</code> that has the following columns:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>f1 <code class="codeph">NUMBER</code></p>
                           </li>
                           <li>
                              <p>f2 <code class="codeph">VARCHAR2(100)</code></p>
                           </li>
                           <li>
                              <p>f3 <code class="codeph">XMLTYPE</code></p>
                           </li>
                           <li>
                              <p>f4 <code class="codeph">XMLTYPE</code></p>
                           </li>
                           <li>
                              <p>f5 <code class="codeph">VARCHAR2(10)</code></p>
                           </li>
                        </ul>
                        <p>Assume that a LogMiner session has been started with the logs and with the <code class="codeph">COMMITED_DATA_ONLY</code> option. The following query is executed against <code class="codeph">V$LOGMNR_CONTENTS</code> for changes to the <code class="codeph">XML_CLOB_COL_TAB</code> table.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, STATUS, SQL_REDO FROM V$LOGMNR_CONTENTS 
  WHERE SEG_OWNER = 'SCOTT' AND TABLE_NAME = 'XML_CLOB_COL_TAB';
</pre><p>The query output looks similar to the following:</p><pre class="oac_no_warn" dir="ltr">OPERATION         STATUS  SQL_REDO

INSERT            0       insert into "SCOTT"."XML_CLOB_COL_TAB"("F1","F2","F5") values
                             ('5010','Aho40431','PETER')
         
XML DOC BEGIN     5       update "SCOTT"."XML_CLOB_COL_TAB" a set a."F3" = XMLType(:1)
                             where a."F1" = '5010' and a."F2" = 'Aho40431' and a."F5" = 'PETER'

XML DOC WRITE     5       XML Data

XML DOC WRITE     5       XML Data

XML DOC WRITE     5       XML Data

XML DOC END       5
                                                                  </pre><p>In the <code class="codeph">SQL_REDO</code> columns for the <code class="codeph">XML DOC WRITE</code> operations there will be actual data for the XML document. It will not be the string 'XML Data'.
                        </p>
                        <p>This output shows that the general model for an insert into a table with an <code class="codeph">XMLType</code> column is the following:
                        </p>
                        <ol>
                           <li>
                              <p>An initial insert with all of the scalar columns.</p>
                           </li>
                           <li>
                              <p>An <code class="codeph">XML DOC BEGIN </code>operation with an update statement that sets the value for one <code class="codeph">XMLType</code> column using a bind variable.
                              </p>
                           </li>
                           <li>
                              <p>One or more <code class="codeph">XML DOC WRITE</code> operations with the data for the XML document.
                              </p>
                           </li>
                           <li>
                              <p>An <code class="codeph">XML DOC END</code> operation to indicate that all of the data for that XML document has been seen.
                              </p>
                           </li>
                           <li>
                              <p>If there is more than one <code class="codeph">XMLType</code> column in the table, then steps 2 through 4 will be repeated for each <code class="codeph">XMLType</code> column that is modified by the original DML.
                              </p>
                           </li>
                        </ol>
                        <p>If the XML document is not stored as an out-of-line column, then there will be no <code class="codeph">XML DOC BEGIN</code>, <code class="codeph">XML DOC WRITE</code>, or <code class="codeph">XML DOC END</code> operations for that column. The document will be included in an update statement similar to the following:
                        </p><pre class="oac_no_warn" dir="ltr">OPERATION   STATUS         SQL_REDO

UPDATE      0              update "SCOTT"."XML_CLOB_COL_TAB" a
                           set a."F3" = XMLType('&lt;?xml version="1.0"?&gt;
                           &lt;PO pono="1"&gt;
                           &lt;PNAME&gt;Po_99&lt;/PNAME&gt; 
                           &lt;CUSTNAME&gt;Dave Davids&lt;/CUSTNAME&gt; 
                           &lt;/PO&gt;') 
                           where a."F1" = '5006' and a."F2" = 'Janosik' and a."F5" = 'MMM' </pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__QUERYINGVLOGMNR_CONTENTSFORCHANGEST-FEC4598D">Querying V$LOGMNR_CONTENTS For Changes to XMLType Tables</p>
                        <p>DMLs to <code class="codeph">XMLType</code> tables are slightly different from DMLs to <code class="codeph">XMLType</code> columns. The XML document represents the value for the row in the <code class="codeph">XMLType</code> table. Unlike the <code class="codeph">XMLType</code> column case, an initial insert cannot be done which is then followed by an update containing the XML document. Rather, the whole document must be assembled before anything can be inserted into the table.
                        </p>
                        <p>Another difference for <code class="codeph">XMLType</code> tables is the presence of the <code class="codeph">OBJECT_ID</code> column. An object identifier is used to uniquely identify every object in an object table. For <code class="codeph">XMLType</code> tables, this value is generated by Oracle Database when the row is inserted into the table. The <code class="codeph">OBJECT_ID</code> value cannot be directly inserted into the table using SQL. Therefore, LogMiner cannot generate <code class="codeph">SQL_REDO</code> which is executable that includes this value.
                        </p>
                        <p>The <code class="codeph">V$LOGMNR_CONTENTS</code> view has a new <code class="codeph">OBJECT_ID</code> column which is populated for changes to <code class="codeph">XMLType</code> tables. This value is the object identifier from the original table. However, even if this same XML document is inserted into the same <code class="codeph">XMLType</code> table, a new object identifier will be generated. The <code class="codeph">SQL_REDO</code> for subsequent DMLs, such as updates and deletes, on the <code class="codeph">XMLType</code> table will include the object identifier in the <code class="codeph">WHERE</code> clause to uniquely identify the row from the original table.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B">Restrictions When Using LogMiner With XMLType Data</a><br>Describes restrictions when using LogMiner with XMLType data.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89">Example of a PL/SQL Procedure for Assembling XMLType Data</a><br>Example showing a procedure that can be used to mine and assemble XML redo for tables that contain out of line XML data. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="You access the redo data of interest by querying the V$LOGMNR_CONTENTS view.">Querying V$LOGMNR_CONTENTS for Redo Data of Interest</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1571"></a><div class="props_rev_3"><a id="GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B" name="GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B"></a><h5 id="SUTIL-GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B" class="sect5"><span class="enumeration_section">22.6.3.1 </span>Restrictions When Using LogMiner With XMLType Data
                     </h5>
                     <div>
                        <p>Describes restrictions when using LogMiner with XMLType data.</p>
                        <p>Mining <code class="codeph">XMLType</code> data should only be done when using the <code class="codeph">DBMS_LOGMNR.COMMITTED_DATA_ONLY</code> option. Otherwise, incomplete changes could be displayed or changes which should be displayed as XML might be displayed as <code class="codeph">CLOB</code> changes due to missing parts of the row change. This can lead to incomplete and invalid <code class="codeph">SQL_REDO</code> for these SQL DML statements.
                        </p>
                        <p>The <code class="codeph">SQL_UNDO</code> column is not populated for changes to <code class="codeph">XMLType</code> data.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839" title="LogMiner supports redo generated for XMLType columns. XMLType data stored as CLOB is supported when redo is generated at a compatibility setting of 11.0.0.0 or higher.">Querying V$LOGMNR_CONTENTS Based on XMLType Columns and Tables</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1572"></a><div class="props_rev_3"><a id="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89" name="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89"></a><h5 id="SUTIL-GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89" class="sect5"><span class="enumeration_section">22.6.3.2 </span>Example of a PL/SQL Procedure for Assembling XMLType Data
                     </h5>
                     <div>
                        <p>Example showing a procedure that can be used to mine and assemble XML redo for tables that contain out of line XML data. </p>
                        <p>This shows how to assemble the XML data using a temporary LOB. Once the XML document is assembled, it can be used in a meaningful way. This example queries the assembled document for the <code class="codeph">EmployeeName</code> element and then stores the returned name, the XML document and the <code class="codeph">SQL_REDO</code> for the original DML in the <code class="codeph">EMPLOYEE_XML_DOCS</code> table. 
                        </p>
                        <div class="infoboxnote" id="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89__GUID-405ABA2D-15F8-4DCA-BA25-9CD8AF7B30B3">
                           <p class="notep1">Note:</p>
                           <p>This procedure is an example only and is simplified. It is only intended to illustrate that DMLs to tables with <code class="codeph">XMLType</code> data can be mined and assembled using LogMiner.
                           </p>
                        </div>
                        <p>Before calling this procedure, all of the relevant logs must be added to a LogMiner session and <code class="codeph">DBMS_LOGMNR.START_LOGMNR()</code> must be called with the <code class="codeph">COMMITTED_DATA_ONLY</code> option. The <code class="codeph">MINE_AND_ASSEMBLE()</code> procedure can then be called with the schema and table name of the table that has XML data to be mined.
                        </p><pre class="oac_no_warn" dir="ltr">-- table to store assembled XML documents
create table employee_xml_docs  (
  employee_name         varchar2(100),
  sql_stmt                     varchar2(4000),
  xml_doc                     SYS.XMLType);
	
-- procedure to assemble the XML documents
create or replace procedure mine_and_assemble(
  schemaname        in varchar2,
  tablename         in varchar2)
AS
  loc_c      CLOB; 
  row_op     VARCHAR2(100); 
  row_status NUMBER; 
  stmt       VARCHAR2(4000);
  row_redo   VARCHAR2(4000);
  xml_data   VARCHAR2(32767 CHAR); 
  data_len   NUMBER; 
  xml_lob    clob;
  xml_doc    XMLType;
BEGIN 
 
-- Look for the rows in V$LOGMNR_CONTENTS that are for the appropriate schema 
-- and table name but limit it to those that are valid sql or that need assembly
-- because they are XML documents.
 
 For item in ( SELECT operation, status, sql_redo  FROM v$logmnr_contents
 where seg_owner = schemaname and table_name = tablename
 and status IN (DBMS_LOGMNR.VALID_SQL, DBMS_LOGMNR.ASSEMBLY_REQUIRED_SQL))
 LOOP
    row_op := item.operation;
    row_status := item.status;
    row_redo := item.sql_redo;
 
     CASE row_op 
 
          WHEN 'XML DOC BEGIN' THEN 
             BEGIN 
               -- save statement and begin assembling XML data 
               stmt := row_redo; 
               xml_data := ''; 
               data_len := 0; 
               DBMS_LOB.CreateTemporary(xml_lob, TRUE);
             END; 
 
          WHEN 'XML DOC WRITE' THEN 
             BEGIN 
               -- Continue to assemble XML data
               xml_data := xml_data || row_redo; 
               data_len := data_len + length(row_redo); 
               DBMS_LOB.WriteAppend(xml_lob, length(row_redo), row_redo);
             END; 
 
          WHEN 'XML DOC END' THEN 
             BEGIN 
               -- Now that assembly is complete, we can use the XML document 
              xml_doc := XMLType.createXML(xml_lob);
              insert into employee_xml_docs values
                        (extractvalue(xml_doc, '/EMPLOYEE/NAME'), stmt, xml_doc);
              commit;
 
              -- reset
              xml_data := ''; 
              data_len := 0; 
              xml_lob := NULL;
             END; 
 
          WHEN 'INSERT' THEN 
             BEGIN 
                stmt := row_redo;
             END; 
 
          WHEN 'UPDATE' THEN 
             BEGIN 
                stmt := row_redo;
             END; 
 
          WHEN 'INTERNAL' THEN 
             DBMS_OUTPUT.PUT_LINE('Skip rows marked INTERNAL'); 
 
          ELSE 
             BEGIN 
                stmt := row_redo;
                DBMS_OUTPUT.PUT_LINE('Other - ' || stmt); 
                IF row_status != DBMS_LOGMNR.VALID_SQL then 
                   DBMS_OUTPUT.PUT_LINE('Skip rows marked non-executable'); 
                ELSE 
                   dbms_output.put_line('Status : ' || row_status);
                END IF; 
             END; 
 
     END CASE;
 
 End LOOP; 
 
End;
/
 
show errors;
</pre><p>This procedure can then be called to mine the changes to the <code class="codeph">SCOTT.XML_DATA_TAB</code> and apply the DMLs.
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE MINE_AND_ASSEMBLE ('SCOTT', 'XML_DATA_TAB');
</pre><p>As a result of this procedure, the <code class="codeph">EMPLOYEE_XML_DOCS</code> table will have a row for each out-of-line XML column that was changed. The <code class="codeph">EMPLOYEE_NAME</code> column will have the value extracted from the XML document and the <code class="codeph">SQL_STMT</code> column and the <code class="codeph">XML_DOC</code> column reflect the original row change.
                        </p>
                        <p>The following is an example query to the resulting table that displays only the employee name and SQL statement:</p><pre class="oac_no_warn" dir="ltr">SELECT EMPLOYEE_NAME, SQL_STMT FROM EMPLOYEE_XML_DOCS;
		
EMPLOYEE_NAME          SQL_STMT                                                                                           
 
Scott Davis          update "SCOTT"."XML_DATA_TAB" a set a."F3" = XMLType(:1) 
                         where a."F1" = '5000' and a."F2" = 'Chen' and a."F5" = 'JJJ'
	
Richard Harry        update "SCOTT"."XML_DATA_TAB" a set a."F4" = XMLType(:1)  
                         where a."F1" = '5000' and a."F2" = 'Chen' and a."F5" = 'JJJ'
	
Margaret Sally       update "SCOTT"."XML_DATA_TAB" a set a."F4" = XMLType(:1)  
                         where a."F1" = '5006' and a."F2" = 'Janosik' and a."F5" = 'MMM'</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839" title="LogMiner supports redo generated for XMLType columns. XMLType data stored as CLOB is supported when redo is generated at a compatibility setting of 11.0.0.0 or higher.">Querying V$LOGMNR_CONTENTS Based on XMLType Columns and Tables</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" name="GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24"></a><h3 id="SUTIL-GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" class="sect3"><span class="enumeration_section">22.7 </span>Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS
               </h3>
               <div>
                  <p>LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the <code class="codeph">V$LOGMNR_CONTENTS</code> view, and the speed at which it is returned.
                  </p>
                  <p> The following sections demonstrate how to specify these limits and their impact on the data returned when you query <code class="codeph">V$LOGMNR_CONTENTS</code>.
                  </p>
                  <p>In addition, LogMiner offers features for formatting the data that is returned to <code class="codeph">V$LOGMNR_CONTENTS</code>, as described in the following sections:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599" title="By default, a ROWID clause is included in the reconstructed SQL_REDO and SQL_UNDO statements and the statements are ended with a semicolon.">Formatting Reconstructed SQL Statements for Re-execution</a></p>
                     </li>
                     <li>
                        <p><a href="oracle-logminer-utility.html#GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" title="LogMiner provides the PRINT_PRETTY_SQL option that formats the appearance of returned data for readability.">Formatting the Appearance of Returned Data for Readability</a></p>
                     </li>
                  </ul>
                  <p>You request each of these filtering and formatting features using parameters or options to the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure. 
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536">Showing Only Committed Transactions</a><br>When using the <code class="codeph">COMMITTED_DATA_ONLY</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, only rows belonging to committed transactions are shown in the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9">Skipping Redo Corruptions</a><br>When you use the <code class="codeph">SKIP_CORRUPTION</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, any corruptions in the redo log files are skipped during select operations from the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5">Filtering Data by Time</a><br>To filter data by time, set the <code class="codeph">STARTTIME</code> and <code class="codeph">ENDTIME</code> parameters in the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3">Filtering Data by SCN</a><br>To filter data by SCN (system change number), use the <code class="codeph">STARTSCN</code> and <code class="codeph">ENDSCN</code> parameters to the PL/SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599">Formatting Reconstructed SQL Statements for Re-execution</a><br>By default, a <code class="codeph">ROWID</code> clause is included in the reconstructed <code class="codeph">SQL_REDO</code> and <code class="codeph">SQL_UNDO</code> statements and the statements are ended with a semicolon. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623">Formatting the Appearance of Returned Data for Readability</a><br>LogMiner provides the <code class="codeph">PRINT_PRETTY_SQL</code> option that formats the appearance of returned data for readability.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1574"></a><div class="props_rev_3"><a id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" name="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536"></a><h4 id="SUTIL-GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" class="sect4"><span class="enumeration_section">22.7.1 </span>Showing Only Committed Transactions
                  </h4>
                  <div>
                     <p>When using the <code class="codeph">COMMITTED_DATA_ONLY</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, only rows belonging to committed transactions are shown in the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </p>
                     <p>This enables you to filter out rolled back transactions, transactions that are in progress, and internal operations.</p>
                     <p>To enable this option, specify it when you start LogMiner, as follows:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(OPTIONS =&gt; -
  DBMS_LOGMNR.COMMITTED_DATA_ONLY);
</pre><p>When you specify the <code class="codeph">COMMITTED_DATA_ONLY</code> option, LogMiner groups together all DML operations that belong to the same transaction. Transactions are returned in the order in which they were committed.
                     </p>
                     <div class="infoboxnote" id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536__GUID-CE11261A-B2D4-4D23-8B7D-798BFFEBF9DE">
                        <p class="notep1">Note:</p>
                        <p>If the <code class="codeph">COMMITTED_DATA_ONLY</code> option is specified and you issue a query, then LogMiner stages all redo records within a single transaction in memory until LogMiner finds the commit record for that transaction. Therefore, it is possible to exhaust memory, in which case an "Out of Memory" error will be returned. If this occurs, then you must restart LogMiner without the <code class="codeph">COMMITTED_DATA_ONLY</code> option specified and reissue the query.
                        </p>
                     </div>
                     <p>The default is for LogMiner to show rows corresponding to all transactions and to return them in the order in which they are encountered in the redo log files.</p>
                     <p>For example, suppose you start LogMiner without specifying the <code class="codeph">COMMITTED_DATA_ONLY</code> option and you execute the following query:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT (XIDUSN || '.' || XIDSLT || '.' || XIDSQN) AS XID, 
   USERNAME, SQL_REDO FROM V$LOGMNR_CONTENTS WHERE USERNAME != 'SYS' 
   AND SEG_OWNER IS NULL OR SEG_OWNER NOT IN ('SYS', 'SYSTEM');
</pre><p>The output is as follows. Both committed and uncommitted transactions are returned and rows from different transactions are interwoven.</p><pre class="oac_no_warn" dir="ltr">XID         USERNAME  SQL_REDO

1.15.3045   RON       set transaction read write;
1.15.3045   RON       insert into "HR"."JOBS"("JOB_ID","JOB_TITLE",
                      "MIN_SALARY","MAX_SALARY") values ('9782',
                      'HR_ENTRY',NULL,NULL);
1.18.3046   JANE      set transaction read write;
1.18.3046   JANE      insert into "OE"."CUSTOMERS"("CUSTOMER_ID",
                      "CUST_FIRST_NAME","CUST_LAST_NAME",
                      "CUST_ADDRESS","PHONE_NUMBERS","NLS_LANGUAGE",
                      "NLS_TERRITORY","CREDIT_LIMIT","CUST_EMAIL",
                      "ACCOUNT_MGR_ID") values ('9839','Edgar',
                      'Cummings',NULL,NULL,NULL,NULL,
                       NULL,NULL,NULL);
1.9.3041    RAJIV      set transaction read write;
1.9.3041    RAJIV      insert into "OE"."CUSTOMERS"("CUSTOMER_ID",
                       "CUST_FIRST_NAME","CUST_LAST_NAME","CUST_ADDRESS",
                       "PHONE_NUMBERS","NLS_LANGUAGE","NLS_TERRITORY",
                       "CREDIT_LIMIT","CUST_EMAIL","ACCOUNT_MGR_ID") 
                       values ('9499','Rodney','Emerson',NULL,NULL,NULL,NULL,
                       NULL,NULL,NULL);
1.15.3045    RON       commit;
1.8.3054     RON       set transaction read write;
1.8.3054     RON       insert into "HR"."JOBS"("JOB_ID","JOB_TITLE",
                       "MIN_SALARY","MAX_SALARY") values ('9566',
                       'FI_ENTRY',NULL,NULL);
1.18.3046    JANE      commit;
1.11.3047    JANE      set transaction read write;
1.11.3047    JANE      insert into "OE"."CUSTOMERS"("CUSTOMER_ID",
                       "CUST_FIRST_NAME","CUST_LAST_NAME",
                       "CUST_ADDRESS","PHONE_NUMBERS","NLS_LANGUAGE",
                       "NLS_TERRITORY","CREDIT_LIMIT","CUST_EMAIL",
                       "ACCOUNT_MGR_ID") values ('8933','Ronald',
                       'Frost',NULL,NULL,NULL,NULL,NULL,NULL,NULL);
1.11.3047    JANE      commit;
1.8.3054     RON       commit;
</pre><p>Now suppose you start LogMiner, but this time you specify the <code class="codeph">COMMITTED_DATA_ONLY</code> option. If you execute the previous query again, then the output is as follows:
                     </p><pre class="oac_no_warn" dir="ltr">1.15.3045   RON       set transaction read write;
1.15.3045   RON       insert into "HR"."JOBS"("JOB_ID","JOB_TITLE",
                      "MIN_SALARY","MAX_SALARY") values ('9782',
                      'HR_ENTRY',NULL,NULL);
1.15.3045    RON       commit;
1.18.3046   JANE      set transaction read write;
1.18.3046   JANE      insert into "OE"."CUSTOMERS"("CUSTOMER_ID",
                      "CUST_FIRST_NAME","CUST_LAST_NAME",
                      "CUST_ADDRESS","PHONE_NUMBERS","NLS_LANGUAGE",
                      "NLS_TERRITORY","CREDIT_LIMIT","CUST_EMAIL",
                      "ACCOUNT_MGR_ID") values ('9839','Edgar',
                      'Cummings',NULL,NULL,NULL,NULL,
                       NULL,NULL,NULL);
1.18.3046    JANE      commit;
1.11.3047    JANE      set transaction read write;
1.11.3047    JANE      insert into "OE"."CUSTOMERS"("CUSTOMER_ID",
                       "CUST_FIRST_NAME","CUST_LAST_NAME",
                       "CUST_ADDRESS","PHONE_NUMBERS","NLS_LANGUAGE",
                       "NLS_TERRITORY","CREDIT_LIMIT","CUST_EMAIL",
                       "ACCOUNT_MGR_ID") values ('8933','Ronald',
                       'Frost',NULL,NULL,NULL,NULL,NULL,NULL,NULL);
1.11.3047    JANE      commit;
1.8.3054     RON       set transaction read write;
1.8.3054     RON       insert into "HR"."JOBS"("JOB_ID","JOB_TITLE",
                       "MIN_SALARY","MAX_SALARY") values ('9566',
                       'FI_ENTRY',NULL,NULL);
1.8.3054     RON       commit;
</pre><p>Because the <code class="codeph">COMMIT</code> statement for the 1.15.3045 transaction was issued before the <code class="codeph">COMMIT</code> statement for the 1.18.3046 transaction, the entire 1.15.3045 transaction is returned first. This is true even though the 1.18.3046 transaction started before the 1.15.3045 transaction. None of the 1.9.3041 transaction is returned because a <code class="codeph">COMMIT</code> statement was never issued for it.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536__GUID-4B3D4439-E8C6-4D0E-8BED-311A4CAC7272">
                        <p class="notep1">See Also:</p>
                        <p> See <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">Examples Using LogMiner</a> for a complete example that uses the <code class="codeph">COMMITTED_DATA_ONLY</code> option
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1575"></a><div class="props_rev_3"><a id="GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9" name="GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9"></a><h4 id="SUTIL-GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9" class="sect4"><span class="enumeration_section">22.7.2 </span>Skipping Redo Corruptions
                  </h4>
                  <div>
                     <p>When you use the <code class="codeph">SKIP_CORRUPTION</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, any corruptions in the redo log files are skipped during select operations from the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </p>
                     <p>For every corrupt redo record encountered, a row is returned that contains the value <code class="codeph">CORRUPTED_BLOCKS</code> in the <code class="codeph">OPERATION</code> column, <code class="codeph">1343</code> in the <code class="codeph">STATUS</code> column, and the number of blocks skipped in the <code class="codeph">INFO</code> column.
                     </p>
                     <p>Be aware that the skipped records may include changes to ongoing transactions in the corrupted blocks; such changes will not be reflected in the data returned from the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </p>
                     <p>The default is for the select operation to terminate at the first corruption it encounters in the redo log file.</p>
                     <p>The following SQL example shows how this option works:</p><pre class="oac_no_warn" dir="ltr">-- Add redo log files of interest.
--
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   logfilename =&gt; '/usr/oracle/data/db1arch_1_16_482701534.log' -
   options =&gt; DBMS_LOGMNR.NEW);

-- Start LogMiner
--
EXECUTE DBMS_LOGMNR.START_LOGMNR();

-- Select from the V$LOGMNR_CONTENTS view. This example shows corruptions are -- in the redo log files.
-- 
SELECT rbasqn, rbablk, rbabyte, operation, status, info 
   FROM V$LOGMNR_CONTENTS;

ERROR at line 3:
ORA-00368: checksum error in redo log block 
ORA-00353: log corruption near block 6 change 73528 time 11/06/2011 11:30:23 
ORA-00334: archived log: /usr/oracle/data/dbarch1_16_482701534.log

-- Restart LogMiner. This time, specify the SKIP_CORRUPTION option.
-- 
EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   options =&gt; DBMS_LOGMNR.SKIP_CORRUPTION);

-- Select from the V$LOGMNR_CONTENTS view again. The output indicates that 
-- corrupted blocks were skipped: CORRUPTED_BLOCKS is in the OPERATION 
-- column, 1343 is in the STATUS column, and the number of corrupt blocks 
-- skipped is in the INFO column.
--
SELECT rbasqn, rbablk, rbabyte, operation, status, info 
   FROM V$LOGMNR_CONTENTS;

RBASQN  RBABLK RBABYTE  OPERATION        STATUS  INFO
13      2        76     START              0
13      2        76     DELETE             0
13      3       100     INTERNAL           0
13      3       380     DELETE             0
13      0         0     CORRUPTED_BLOCKS   1343  corrupt blocks 4 to 19 skipped
13      20      116     UPDATE             0</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1576"></a><div class="props_rev_3"><a id="GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" name="GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5"></a><h4 id="SUTIL-GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" class="sect4"><span class="enumeration_section">22.7.3 </span>Filtering Data by Time
                  </h4>
                  <div>
                     <p>To filter data by time, set the <code class="codeph">STARTTIME</code> and <code class="codeph">ENDTIME</code> parameters in the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure. 
                     </p>
                     <p>To avoid the need to specify the date format in the call to the PL/SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure, you can use the SQL <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET NLS_DATE_FORMAT</code> statement first, as shown in the following example.
                     </p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';
EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   DICTFILENAME =&gt; '/oracle/database/dictionary.ora', -
   STARTTIME =&gt; '01-Jan-2012 08:30:00', -
   ENDTIME =&gt; '01-Jan-2012 08:45:00'-
   ); 
</pre><p>The timestamps should not be used to infer ordering of redo records. You can infer the order of redo records by using the SCN.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1577"></a><div class="props_rev_3"><a id="GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" name="GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3"></a><h4 id="SUTIL-GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" class="sect4"><span class="enumeration_section">22.7.4 </span>Filtering Data by SCN
                  </h4>
                  <div>
                     <p>To filter data by SCN (system change number), use the <code class="codeph">STARTSCN</code> and <code class="codeph">ENDSCN</code> parameters to the PL/SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure.
                     </p>
                     <p>For example:</p><pre class="oac_no_warn" dir="ltr"> EXECUTE DBMS_LOGMNR.START_LOGMNR(-
    STARTSCN =&gt; 621047, -
    ENDSCN   =&gt; 625695, -
    OPTIONS  =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
                );
</pre><p>The <code class="codeph">STARTSCN</code> and <code class="codeph">ENDSCN</code> parameters override the <code class="codeph">STARTTIME</code> and <code class="codeph">ENDTIME</code> parameters in situations where all are specified.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1578"></a><div class="props_rev_3"><a id="GUID-C2B8C741-9544-4A46-818E-16B233570599" name="GUID-C2B8C741-9544-4A46-818E-16B233570599"></a><h4 id="SUTIL-GUID-C2B8C741-9544-4A46-818E-16B233570599" class="sect4"><span class="enumeration_section">22.7.5 </span>Formatting Reconstructed SQL Statements for Re-execution
                  </h4>
                  <div>
                     <p>By default, a <code class="codeph">ROWID</code> clause is included in the reconstructed <code class="codeph">SQL_REDO</code> and <code class="codeph">SQL_UNDO</code> statements and the statements are ended with a semicolon. 
                     </p>
                     <p>However, you can override the default settings, as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Specify the <code class="codeph">NO_ROWID_IN_STMT</code> option when you start LogMiner.
                           </p>
                           <p>This excludes the <code class="codeph">ROWID</code> clause from the reconstructed statements. Because row IDs are not consistent between databases, if you intend to re-execute the <code class="codeph">SQL_REDO</code> or <code class="codeph">SQL_UNDO</code> statements against a different database than the one against which they were originally executed, then specify the <code class="codeph">NO_ROWID_IN_STMT</code> option when you start LogMiner.
                           </p>
                        </li>
                        <li>
                           <p>Specify the <code class="codeph">NO_SQL_DELIMITER</code> option when you start LogMiner.
                           </p>
                           <p>This suppresses the semicolon from the reconstructed statements. This is helpful for applications that open a cursor and then execute the reconstructed statements.</p>
                        </li>
                     </ul>
                     <p>Note that if the <code class="codeph">STATUS</code> field of the <code class="codeph">V$LOGMNR_CONTENTS</code> view contains the value <code class="codeph">2</code> (<code class="codeph">invalid sql)</code>, then the associated SQL statement cannot be executed.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1579"></a><div class="props_rev_3"><a id="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" name="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623"></a><h4 id="SUTIL-GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" class="sect4"><span class="enumeration_section">22.7.6 </span>Formatting the Appearance of Returned Data for Readability
                  </h4>
                  <div>
                     <p>LogMiner provides the <code class="codeph">PRINT_PRETTY_SQL</code> option that formats the appearance of returned data for readability.
                     </p>
                     <p>Sometimes a query can result in a large number of columns containing reconstructed SQL statements, which can be visually busy and hard to read. LogMiner provides the <code class="codeph">PRINT_PRETTY_SQL</code> option to address this problem. The <code class="codeph">PRINT_PRETTY_SQL</code> option to the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure formats the reconstructed SQL statements as follows, which makes them easier to read:
                     </p><pre class="oac_no_warn" dir="ltr">insert into "HR"."JOBS"
 values
    "JOB_ID" = '9782',
    "JOB_TITLE" = 'HR_ENTRY',
    "MIN_SALARY" IS NULL,
    "MAX_SALARY" IS NULL;
  update "HR"."JOBS"
  set
    "JOB_TITLE" = 'FI_ENTRY'
  where
    "JOB_TITLE" = 'HR_ENTRY' and
    ROWID = 'AAAHSeAABAAAY+CAAX';

update "HR"."JOBS"
  set
    "JOB_TITLE" = 'FI_ENTRY'
  where
    "JOB_TITLE" = 'HR_ENTRY' and
    ROWID = 'AAAHSeAABAAAY+CAAX';

delete from "HR"."JOBS"
 where
    "JOB_ID" = '9782' and
    "JOB_TITLE" = 'FI_ENTRY' and
    "MIN_SALARY" IS NULL and
    "MAX_SALARY" IS NULL and
    ROWID = 'AAAHSeAABAAAY+CAAX';
</pre><p>SQL statements that are reconstructed when the <code class="codeph">PRINT_PRETTY_SQL</code> option is enabled are not executable, because they do not use standard SQL syntax.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623__GUID-DFB9B6E6-40BD-4386-B13F-30342DE13F6B">
                        <p class="notep1">See Also:</p>
                        <p> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">Examples Using LogMiner</a> for a complete example of using the <code class="codeph">PRINT_PRETTY_SQL</code> option
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39" name="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39"></a><h3 id="SUTIL-GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39" class="sect3"><span class="enumeration_section">22.8 </span>Reapplying DDL Statements Returned to V$LOGMNR_CONTENTS
               </h3>
               <div>
                  <p>Some DDL statements that you issue cause Oracle to internally execute one or more other DDL statements.</p>
                  <p>To reapply SQL DDL from the <code class="codeph">SQL_REDO</code> or <code class="codeph">SQL_UNDO</code> columns of the <code class="codeph">V$LOGMNR_CONTENTS</code> view as it was originally applied to the database, do not execute statements that were executed internally by Oracle.
                  </p>
                  <div class="infoboxnote" id="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39__IFYOUEXECUTEDMLSTATEMENTSTHATWEREEX-FEC8AB26">
                     <p class="notep1">Note:</p>
                     <p>If you execute DML statements that were executed internally by Oracle, then you may corrupt your database. See Step 5 of <a href="oracle-logminer-utility.html#GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0">Example 4: Using the LogMiner Dictionary in the Redo Log Files</a> for an example.
                     </p>
                  </div>
                  <p>To differentiate between DDL statements that were issued by a user from those that were issued internally by Oracle, query the <code class="codeph">INFO</code> column of <code class="codeph">V$LOGMNR_CONTENTS</code>. The value of the <code class="codeph">INFO</code> column indicates whether the DDL was executed by a user or by Oracle.
                  </p>
                  <p>To reapply SQL DDL as it was originally applied, re-execute the DDL SQL contained in the <code class="codeph">SQL_REDO</code> or <code class="codeph">SQL_UNDO</code> column of <code class="codeph">V$LOGMNR_CONTENTS</code> only if the <code class="codeph">INFO</code> column contains the value <code class="codeph">USER_DDL.</code></p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL4228"></a><a id="SUTIL4229"></a><a id="SUTIL4230"></a><a id="SUTIL1581"></a><div class="props_rev_3"><a id="GUID-4959F073-BE00-4170-BFDC-4722D5770639" name="GUID-4959F073-BE00-4170-BFDC-4722D5770639"></a><h3 id="SUTIL-GUID-4959F073-BE00-4170-BFDC-4722D5770639" class="sect3"><span class="enumeration_section">22.9 </span>Calling DBMS_LOGMNR.START_LOGMNR Multiple Times
               </h3>
               <div>
                  <p>Even after you have successfully called <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> and selected from the <code class="codeph">V$LOGMNR_CONTENTS</code> view, you can call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again without ending the current LogMiner session and specify different options and time or SCN ranges. 
                  </p>
                  <p>The following list presents reasons why you might want to do this:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>You want to limit the amount of redo data that LogMiner has to analyze.</p>
                     </li>
                     <li>
                        <p>You want to specify different options. For example, you might decide to specify the <code class="codeph">PRINT_PRETTY_SQL </code>option or that you only want to see committed transactions (so you specify the <code class="codeph">COMMITTED_DATA_ONLY</code> option).
                        </p>
                     </li>
                     <li>
                        <p>You want to change the time or SCN range to be analyzed.</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-4959F073-BE00-4170-BFDC-4722D5770639__GUID-28BE8979-5A14-4125-B72B-D9913F275AFA">Examples: Calling DBMS_LOGMNR.START_LOGMNR Multiple Times</p>
                     <p>The following are some examples of when it could be useful to call<code class="codeph"> DBMS_LOGMNR.START_LOGMNR</code> multiple times.
                     </p>
                     <p><span class="bold">Example 1:  Mining Only a Subset of the Data in the Redo Log Files</span></p>
                     <p>Suppose the list of redo log files that LogMiner has to mine include those generated for an entire week. However, you want to analyze only what happened from 12:00 to 1:00 each day. You could do this most efficiently by:</p>
                     <ol>
                        <li>
                           <p>Calling <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> with this time range for Monday. 
                           </p>
                        </li>
                        <li>
                           <p>Selecting changes from the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                           </p>
                        </li>
                        <li>
                           <p>Repeating Steps 1 and 2 for each day of the week.</p>
                        </li>
                     </ol>
                     <p>If the total amount of redo data is large for the week, then this method would make the whole analysis much faster, because only a small subset of each redo log file in the list would be read by LogMiner.</p>
                     <p><span class="bold">Example 2: Adjusting the Time Range or SCN Range</span></p>
                     <p>Suppose you specify a redo log file list and specify a time (or SCN) range when you start LogMiner. When you query the <code class="codeph">V$LOGMNR_CONTENTS</code> view, you find that only part of the data of interest is included in the time range you specified. You can call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again to expand the time range by an hour (or adjust the SCN range). 
                     </p>
                     <p><span class="bold">Example 3: Analyzing Redo Log Files As They Arrive at a Remote Database</span></p>
                     <p>Suppose you have written an application to analyze changes or to replicate changes from one database to another database. The source database sends its redo log files to the mining database and drops them into an operating system directory. Your application: </p>
                     <ol>
                        <li>
                           <p>Adds all redo log files currently in the directory to the redo log file list</p>
                        </li>
                        <li>
                           <p>Calls <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> with appropriate settings and selects from the <code class="codeph">V$LOGMNR_CONTENTS</code> view
                           </p>
                        </li>
                        <li>
                           <p>Adds additional redo log files that have newly arrived in the directory</p>
                        </li>
                        <li>
                           <p>Repeats Steps 2 and 3, indefinitely</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1582"></a><div class="props_rev_3"><a id="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" name="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E"></a><h3 id="SUTIL-GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" class="sect3"><span class="enumeration_section">22.10 </span>Supplemental Logging
               </h3>
               <div>
                  <p>Describes supplemental logging.</p>
                  <p>Redo log files are generally used for instance recovery and media recovery. The data needed for such operations is automatically recorded in the redo log files. However, a redo-based application may require that additional columns be logged in the redo log files. The process of logging these additional columns is called <span class="bold">supplemental logging.</span></p>
                  <p>By default, Oracle Database does not provide any supplemental logging, which means that by default LogMiner is not usable. Therefore, you must enable at least minimal supplemental logging before generating log files which will be analyzed by LogMiner.</p>
                  <p>The following are examples of situations in which additional columns may be needed:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>An application that applies reconstructed SQL statements to a different database must identify the update statement by a set of columns that uniquely identify the row (for example, a primary key), not by the <code class="codeph">ROWID</code> shown in the reconstructed SQL returned by the <code class="codeph">V$LOGMNR_CONTENTS</code> view, because the <code class="codeph">ROWID</code> of one database will be different and therefore meaningless in another database.
                        </p>
                     </li>
                     <li>
                        <p>An application may require that the before-image of the whole row be logged, not just the modified columns, so that tracking of row changes is more efficient.</p>
                     </li>
                  </ul>
                  <p>A <span class="bold">supplemental log group</span> is the set of additional columns to be logged when supplemental logging is enabled. There are two types of supplemental log groups that determine when columns in the log group are logged:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="bold">Unconditional supplemental log groups:</span> The before-images of specified columns are logged any time a row is updated, regardless of whether the update affected any of the specified columns. This is sometimes referred to as an ALWAYS log group.
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">Conditional supplemental log groups:</span> The before-images of all specified columns are logged only if at least one of the columns in the log group is updated.
                        </p>
                     </li>
                  </ul>
                  <p>Supplemental log groups can be system-generated or user-defined. </p>
                  <p>In addition to the two types of supplemental logging, there are two levels of supplemental logging, as described in the following sections:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3">Database-Level Supplemental Logging</a><br>LogMiner provides different types of database-level supplemental logging: minimal supplemental logging, identification key logging, and procedural supplemental logging, as described in these sections. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473">Disabling Database-Level Supplemental Logging</a><br>Disable database-level supplemental logging using the SQL <code class="codeph">ALTER DATABASE </code>statement with the <code class="codeph">DROP SUPPLEMENTAL LOGGING</code> clause. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F">Table-Level Supplemental Logging</a><br>Table-level supplemental logging specifies, at the table level, which columns are to be supplementally logged. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B">Tracking DDL Statements in the LogMiner Dictionary</a><br>LogMiner automatically builds its own internal dictionary from the LogMiner dictionary that you specify when you start LogMiner (either an online catalog, a dictionary in the redo log files, or a flat file). 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2">DDL_DICT_TRACKING and Supplemental Logging Settings</a><br>Describes  interactions that occur when various settings of dictionary tracking and supplemental logging are combined.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023">DDL_DICT_TRACKING and Specified Time or SCN Ranges</a><br>Because LogMiner must not miss a DDL statement if it is to ensure the consistency of its dictionary, LogMiner may start reading redo log files before your requested starting time or SCN (as specified with <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>) when the <code class="codeph">DDL_DICT_TRACKING</code> option is enabled. 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E__GUID-8129DEE8-ADCB-4B26-9FC4-33C07F8ACDEB">
                     <p class="notep1">See Also:</p>
                     <p><a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" title="Describes how to query several views to determine the current settings for supplemental logging.">Querying Views for Supplemental Logging Settings</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1583"></a><div class="props_rev_3"><a id="GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" name="GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3"></a><h4 id="SUTIL-GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" class="sect4"><span class="enumeration_section">22.10.1 </span>Database-Level Supplemental Logging
                  </h4>
                  <div>
                     <p>LogMiner provides different types of database-level supplemental logging: minimal supplemental logging, identification key logging, and procedural supplemental logging, as described in these sections. </p>
                     <p>Minimal supplemental logging does not impose significant overhead on the database generating the redo log files. However, enabling database-wide identification key logging can impose overhead on the database generating the redo log files. Oracle recommends that you at least enable minimal supplemental logging for LogMiner.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D">Minimal Supplemental Logging</a><br>Minimal supplemental logging logs the minimal amount of information needed for LogMiner to identify, group, and merge the redo operations associated with DML changes. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242">Database-Level Identification Key Logging</a><br>Identification key logging is necessary when redo log files will not be mined at the source database instance, for example, when the redo log files will be mined at a logical standby database.
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E6C98352-7048-45BF-9487-F33BC665F7D3">Procedural Supplemental Logging</a><br>Procedural supplemental logging causes LogMiner to log certain procedural invocations to redo, so that they can be replicated by rolling upgrades or Oracle GoldenGate.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1584"></a><div class="props_rev_3"><a id="GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D" name="GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D"></a><h5 id="SUTIL-GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D" class="sect5"><span class="enumeration_section">22.10.1.1 </span>Minimal Supplemental Logging
                     </h5>
                     <div>
                        <p>Minimal supplemental logging logs the minimal amount of information needed for LogMiner to identify, group, and merge the redo operations associated with DML changes. </p>
                        <p>It ensures that LogMiner (and any product building on LogMiner technology) has sufficient information to support chained rows and various storage arrangements, such as cluster tables and index-organized tables. To enable minimal supplemental logging, execute the following SQL statement:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner provides different types of database-level supplemental logging: minimal supplemental logging, identification key logging, and procedural supplemental logging, as described in these sections.">Database-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1585"></a><div class="props_rev_3"><a id="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" name="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242"></a><h5 id="SUTIL-GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" class="sect5"><span class="enumeration_section">22.10.1.2 </span>Database-Level Identification Key Logging
                     </h5>
                     <div>
                        <p>Identification key logging is necessary when redo log files will not be mined at the source database instance, for example, when the redo log files will be mined at a logical standby database.</p>
                        <p>Using database identification key logging, you can enable database-wide before-image logging for all updates by specifying one or more of the following options to the SQL <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">ADD</code> <code class="codeph">SUPPLEMENTAL</code> <code class="codeph">LOG</code> statement: 
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ALL</code> system-generated unconditional supplemental log group
                              </p>
                              <p>This option specifies that when a row is updated, all columns of that row (except for LOBs, <code class="codeph">LONGS</code>, and <code class="codeph">ADT</code>s) are placed in the redo log file.
                              </p>
                              <p>To enable all column logging at the database level, execute the following statement:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
</pre></li>
                           <li>
                              <p><code class="codeph">PRIMARY KEY</code> system-generated unconditional supplemental log group
                              </p>
                              <p>This option causes the database to place all columns of a row's primary key in the redo log file whenever a row containing a primary key is updated (even if no value in the primary key has changed).</p>
                              <p>If a table does not have a primary key, but has one or more non-null unique index key constraints or index keys, then one of the unique index keys is chosen for logging as a means of uniquely identifying the row being updated.</p>
                              <p>If the table has neither a primary key nor a non-null unique index key, then all columns except <code class="codeph">LONG</code> and LOB are supplementally logged; this is equivalent to specifying <code class="codeph">ALL</code> supplemental logging for that row. Therefore, Oracle recommends that when you use database-level primary key supplemental logging, all or most tables be defined to have primary or unique index keys.
                              </p>
                              <p>To enable primary key logging at the database level, execute the following statement:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
</pre></li>
                           <li>
                              <p>UNIQUE system-generated conditional supplemental log group</p>
                              <p>This option causes the database to place all columns of a row's composite unique key or bitmap index in the redo log file if any column belonging to the composite unique key or bitmap index is modified. The unique key can be due to either a unique constraint or a unique index.</p>
                              <p>To enable unique index key and bitmap index logging at the database level, execute the following statement:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;
</pre></li>
                           <li>
                              <p><code class="codeph">FOREIGN KEY</code> system-generated conditional supplemental log group
                              </p>
                              <p>This option causes the database to place all columns of a row's foreign key in the redo log file if any column belonging to the foreign key is modified. </p>
                              <p>To enable foreign key logging at the database level, execute the following SQL statement:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (FOREIGN KEY) COLUMNS;</pre><div class="infoboxnote" id="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242__GUID-BEA69A5E-779D-4BDE-8B3C-9F4D3995765D">
                                 <p class="notep1">Note:</p>
                                 <p>Regardless of whether identification key logging is enabled, the SQL statements returned by LogMiner always contain the <code class="codeph">ROWID</code> clause. You can filter out the <code class="codeph">ROWID</code> clause by using the <code class="codeph">NO_ROWID_IN_STMT</code> option to the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure call. See <a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599" title="By default, a ROWID clause is included in the reconstructed SQL_REDO and SQL_UNDO statements and the statements are ended with a semicolon.">Formatting Reconstructed SQL Statements for Re-execution</a> for details.
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>Keep the following in mind when you use identification key logging:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the database is open when you enable identification key logging, then all DML cursors in the cursor cache are invalidated. This can affect performance until the cursor cache is repopulated.</p>
                           </li>
                           <li>
                              <p>When you enable identification key logging at the database level, minimal supplemental logging is enabled implicitly.</p>
                           </li>
                           <li>
                              <p>Supplemental logging statements are cumulative. If you issue the following SQL statements, then both primary key and unique key supplemental logging is enabled:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;</pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner provides different types of database-level supplemental logging: minimal supplemental logging, identification key logging, and procedural supplemental logging, as described in these sections.">Database-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-E6C98352-7048-45BF-9487-F33BC665F7D3" name="GUID-E6C98352-7048-45BF-9487-F33BC665F7D3"></a><h5 id="SUTIL-GUID-E6C98352-7048-45BF-9487-F33BC665F7D3" class="sect5"><span class="enumeration_section">22.10.1.3 </span>Procedural Supplemental Logging
                     </h5>
                     <div>
                        <p>Procedural supplemental logging causes LogMiner to log certain procedural invocations to redo, so that they can be replicated by rolling upgrades or Oracle GoldenGate.</p>
                        <p>Procedural supplemental logging must be enabled for rolling upgrades and Oracle GoldenGate to support replication of AQ queue tables, hierarchy-enabled tables, and tables with <code class="codeph">SDO_TOPO_GEOMETRY</code> or <code class="codeph">SDO_GEORASTER</code> columns. Use the following SQL statement to enable procedural supplemental logging:
                        </p><pre class="pre codeblock"><code>ALTER DATABASE ADD SUPPLEMENTAL LOG DATA FOR PROCEDURAL REPLICATION END SUBHEADING</code></pre><p>If procedural supplemental logging is enabled, then minimal supplemental logging cannot be dropped unless procedural supplemental logging is dropped first.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner provides different types of database-level supplemental logging: minimal supplemental logging, identification key logging, and procedural supplemental logging, as described in these sections.">Database-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1586"></a><div class="props_rev_3"><a id="GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473" name="GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473"></a><h4 id="SUTIL-GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473" class="sect4"><span class="enumeration_section">22.10.2 </span>Disabling Database-Level Supplemental Logging
                  </h4>
                  <div>
                     <p>Disable database-level supplemental logging using the SQL <code class="codeph">ALTER DATABASE </code>statement with the <code class="codeph">DROP SUPPLEMENTAL LOGGING</code> clause. 
                     </p>
                     <p>You can drop supplemental logging attributes incrementally. For example, suppose you issued the following SQL statements, in the following order:</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;</code>
<code class="codeph">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS</code>;
<code class="codeph">ALTER DATABASE DROP SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;</code>
<code class="codeph">ALTER DATABASE DROP SUPPLEMENTAL LOG DATA;</code>
</pre><p>The statements would have the following effects:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>After the first statement, primary key supplemental logging is enabled.</p>
                        </li>
                        <li>
                           <p>After the second statement, primary key and unique key supplemental logging are enabled.</p>
                        </li>
                        <li>
                           <p>After the third statement, only unique key supplemental logging is enabled.</p>
                        </li>
                        <li>
                           <p>After the fourth statement, all supplemental logging is not disabled. The following error is returned: <code class="codeph">ORA-32589: unable to drop minimal supplemental logging</code>.
                           </p>
                        </li>
                     </ul>
                     <p>To disable all database supplemental logging, you must first disable any identification key logging that has been enabled, then disable minimal supplemental logging. The following example shows the correct order:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;
ALTER DATABASE DROP SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
ALTER DATABASE DROP SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;
ALTER DATABASE DROP SUPPLEMENTAL LOG DATA;
</pre><p>Dropping minimal supplemental log data is allowed only if no other variant of database-level supplemental logging is enabled.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1587"></a><div class="props_rev_3"><a id="GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" name="GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F"></a><h4 id="SUTIL-GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" class="sect4"><span class="enumeration_section">22.10.3 </span>Table-Level Supplemental Logging
                  </h4>
                  <div>
                     <p>Table-level supplemental logging specifies, at the table level, which columns are to be supplementally logged. </p>
                     <p>You can use identification key logging or user-defined conditional and unconditional supplemental log groups to log supplemental information, as described in the following sections.</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-080102D4-B514-40FA-80F7-8461E819F5FE">Table-Level Identification Key Logging</a><br>Identification key logging at the table level offers the same options as those provided at the database level: all, primary key, foreign key, and unique key. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-34912450-76D3-4A9C-9EBF-098F220192FD">Table-Level User-Defined Supplemental Log Groups</a><br>In addition to table-level identification key logging, Oracle supports user-defined supplemental log groups. 
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197">Usage Notes for User-Defined Supplemental Log Groups</a><br>Hints for using user-defined supplemental log groups.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1588"></a><div class="props_rev_3"><a id="GUID-080102D4-B514-40FA-80F7-8461E819F5FE" name="GUID-080102D4-B514-40FA-80F7-8461E819F5FE"></a><h5 id="SUTIL-GUID-080102D4-B514-40FA-80F7-8461E819F5FE" class="sect5"><span class="enumeration_section">22.10.3.1 </span>Table-Level Identification Key Logging
                     </h5>
                     <div>
                        <p>Identification key logging at the table level offers the same options as those provided at the database level: all, primary key, foreign key, and unique key. </p>
                        <p>However, when you specify identification key logging at the table level, only the specified table is affected. For example, if you enter the following SQL statement (specifying database-level supplemental logging), then whenever a column in any database table is changed, the entire row containing that column (except columns for LOBs, <code class="codeph">LONG</code>s, and <code class="codeph">ADT</code>s) will be placed in the redo log file:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
</pre><p>However, if you enter the following SQL statement (specifying table-level supplemental logging) instead, then only when a column in the <code class="codeph">employees</code> table is changed will the entire row (except for LOB, <code class="codeph">LONG</code>s, and <code class="codeph">ADT</code>s) of the table be placed in the redo log file. If a column changes in the <code class="codeph">departments</code> table, then only the changed column will be placed in the redo log file.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
</pre><p>Keep the following in mind when you use table-level identification key logging:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the database is open when you enable identification key logging on a table, then all DML cursors for that table in the cursor cache are invalidated. This can affect performance until the cursor cache is repopulated.</p>
                           </li>
                           <li>
                              <p>Supplemental logging statements are cumulative. If you issue the following SQL statements, then both primary key and unique index key table-level supplemental logging is enabled:</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES 
  ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
ALTER TABLE HR.EMPLOYEES 
  ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;
</pre></li>
                        </ul>
                        <p>See <a href="oracle-logminer-utility.html#GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" title="Identification key logging is necessary when redo log files will not be mined at the source database instance, for example, when the redo log files will be mined at a logical standby database.">Database-Level Identification Key Logging</a> for a description of each of the identification key logging options.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="Table-level supplemental logging specifies, at the table level, which columns are to be supplementally logged.">Table-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1589"></a><div class="props_rev_3"><a id="GUID-34912450-76D3-4A9C-9EBF-098F220192FD" name="GUID-34912450-76D3-4A9C-9EBF-098F220192FD"></a><h5 id="SUTIL-GUID-34912450-76D3-4A9C-9EBF-098F220192FD" class="sect5"><span class="enumeration_section">22.10.3.2 </span>Table-Level User-Defined Supplemental Log Groups
                     </h5>
                     <div>
                        <p>In addition to table-level identification key logging, Oracle supports user-defined supplemental log groups. </p>
                        <p>With user-defined supplemental log groups, you can specify which columns are supplementally logged. You can specify conditional or unconditional log groups, as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>User-defined unconditional log groups</p>
                              <p>To enable supplemental logging that uses user-defined unconditional log groups, use the <code class="codeph">ALWAYS</code> clause as shown in the following example:
                              </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES
   ADD SUPPLEMENTAL LOG GROUP emp_parttime (EMPLOYEE_ID, LAST_NAME, 
   DEPARTMENT_ID) ALWAYS;
</pre><p>This creates a log group named <code class="codeph">emp_parttime</code> on the <code class="codeph">hr.employees</code> table that consists of the columns <code class="codeph">employee_id</code>, <code class="codeph">last_name</code>, and <code class="codeph">department_id</code>. These columns are logged every time an <code class="codeph">UPDATE</code> statement is executed on the <code class="codeph">hr.employees</code> table, regardless of whether the update affected these columns. (To have the entire row image logged any time an update is made, use table-level <code class="codeph">ALL</code> identification key logging, as described previously). 
                              </p>
                              <div class="infoboxnote" id="GUID-34912450-76D3-4A9C-9EBF-098F220192FD__GUID-656E0B11-3DC0-4FAE-B7B0-EA1146ABCE1E">
                                 <p class="notep1">Note:</p>
                                 <p>LOB, <code class="codeph">LONG</code>, and <code class="codeph">ADT</code> columns cannot be supplementally logged.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>User-defined conditional supplemental log groups</p>
                              <p>To enable supplemental logging that uses user-defined conditional log groups, omit the <code class="codeph">ALWAYS</code> clause from the SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> statement, as shown in the following example: 
                              </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES
   ADD SUPPLEMENTAL LOG GROUP emp_fulltime (EMPLOYEE_ID, LAST_NAME, 
   DEPARTMENT_ID);
</pre><p>This creates a log group named <code class="codeph">emp_fulltime</code> on table <code class="codeph">hr.employees</code>. As in the previous example, it consists of the columns <code class="codeph">employee_id</code>, <code class="codeph">last_name</code>, and <code class="codeph">department_id</code>. But because the <code class="codeph">ALWAYS</code> clause was omitted, before-images of the columns are logged only if at least one of the columns is updated.
                              </p>
                           </li>
                        </ul>
                        <p>For both unconditional and conditional user-defined supplemental log groups, you can explicitly specify that a column in the log group be excluded from supplemental logging by specifying the <code class="codeph">NO LOG</code> option. When you specify a log group and use the <code class="codeph">NO LOG</code> option, you must specify at least one column in the log group without the <code class="codeph">NO LOG</code> option, as shown in the following example:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES
   ADD SUPPLEMENTAL LOG GROUP emp_parttime(
   DEPARTMENT_ID NO LOG, EMPLOYEE_ID);
</pre><p>This enables you to associate this column with other columns in the named supplemental log group such that any modification to the <code class="codeph">NO LOG</code> column causes the other columns in the supplemental log group to be placed in the redo log file. This might be useful, for example, for logging certain columns in a group if a <code class="codeph">LONG</code> column changes. You cannot supplementally log the <code class="codeph">LONG</code> column itself; however, you can use changes to that column to trigger supplemental logging of other columns in the same row.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="Table-level supplemental logging specifies, at the table level, which columns are to be supplementally logged.">Table-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1590"></a><div class="props_rev_3"><a id="GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197" name="GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197"></a><h5 id="SUTIL-GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197" class="sect5"><span class="enumeration_section">22.10.3.3 </span>Usage Notes for User-Defined Supplemental Log Groups
                     </h5>
                     <div>
                        <p>Hints for using user-defined supplemental log groups.</p>
                        <p>Keep the following in mind when you specify user-defined supplemental log groups:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A column can belong to more than one supplemental log group. However, the before-image of the columns gets logged only once.</p>
                           </li>
                           <li>
                              <p>If you specify the same columns to be logged both conditionally and unconditionally, then the columns are logged unconditionally.</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="Table-level supplemental logging specifies, at the table level, which columns are to be supplementally logged.">Table-Level Supplemental Logging</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1591"></a><div class="props_rev_3"><a id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B" name="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B"></a><h4 id="SUTIL-GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B" class="sect4"><span class="enumeration_section">22.10.4 </span>Tracking DDL Statements in the LogMiner Dictionary
                  </h4>
                  <div>
                     <p>LogMiner automatically builds its own internal dictionary from the LogMiner dictionary that you specify when you start LogMiner (either an online catalog, a dictionary in the redo log files, or a flat file). </p>
                     <p>This dictionary provides a snapshot of the database objects and their definitions.</p>
                     <p>If your LogMiner dictionary is in the redo log files or is a flat file, then you can use the <code class="codeph">DDL_DICT_TRACKING</code> option to the PL/SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure to direct LogMiner to track data definition language (DDL) statements. DDL tracking enables LogMiner to successfully track structural changes made to a database object, such as adding or dropping columns from a table. For example:
                     </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(OPTIONS =&gt; -
   DBMS_LOGMNR.DDL_DICT_TRACKING + DBMS_LOGMNR.DICT_FROM_REDO_LOGS);
</pre><p>See <a href="oracle-logminer-utility.html#GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F">Example 5: Tracking DDL Statements in the Internal Dictionary</a> for a complete example.
                     </p>
                     <p>With this option set, LogMiner applies any DDL statements seen in the redo log files to its internal dictionary. </p>
                     <div class="infoboxnote" id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B__GUID-B8808527-48A6-40E8-A7DD-9454BEEB48D6">
                        <p class="notep1">Note:</p>
                        <p>In general, it is a good idea to keep supplemental logging and the DDL tracking feature enabled, because if they are not enabled and a DDL event occurs, then LogMiner returns some of the redo data as binary data. Also, a metadata version mismatch could occur.</p>
                     </div>
                     <p>When you enable <code class="codeph">DDL_DICT_TRACKING,</code> data manipulation language (DML) operations performed on tables created after the LogMiner dictionary was extracted can be shown correctly.
                     </p>
                     <p>For example, if a table <code class="codeph">employees</code> is updated through two successive DDL operations such that column <code class="codeph">gender</code> is added in one operation, and column <code class="codeph">commission_pct</code> is dropped in the next, then LogMiner will keep versioned information for <code class="codeph">employees</code> for each of these changes. This means that LogMiner can successfully mine redo log files that are from before and after these DDL changes, and no binary data will be presented for the <code class="codeph">SQL_REDO</code> or <code class="codeph">SQL_UNDO</code> columns. 
                     </p>
                     <p>Because LogMiner automatically assigns versions to the database metadata, it will detect and notify you of any mismatch between its internal dictionary and the dictionary in the redo log files. If LogMiner detects a mismatch, then it generates binary data in the <code class="codeph">SQL_REDO</code> column of the <code class="codeph">V$LOGMNR_CONTENTS</code> view, the <code class="codeph">INFO</code> column contains the string "Dictionary Version Mismatch", and the <code class="codeph">STATUS</code> column will contain the value <code class="codeph">2</code>.
                     </p>
                     <div class="infoboxnote" id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B__GUID-4B6BAD13-5CD0-4B64-BD15-207943B8B5A8">
                        <p class="notep1">Note:</p>
                        <p>It is important to understand that the LogMiner internal dictionary is not the same as the LogMiner dictionary contained in a flat file, in redo log files, or in the online catalog. LogMiner does update its internal dictionary, but it does not update the dictionary that is contained in a flat file, in redo log files, or in the online catalog.</p>
                     </div>
                     <p>The following list describes the requirements for specifying the <code class="codeph">DDL_DICT_TRACKING</code> option with the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">DDL_DICT_TRACKING</code> option is not valid with the <code class="codeph">DICT_FROM_ONLINE_CATALOG</code> option.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">DDL_DICT_TRACKING</code> option requires that the database be open.
                           </p>
                        </li>
                        <li>
                           <p>Supplemental logging must be enabled database-wide, or log groups must have been created for the tables of interest.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1592"></a><div class="props_rev_3"><a id="GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2" name="GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2"></a><h4 id="SUTIL-GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2" class="sect4"><span class="enumeration_section">22.10.5 </span>DDL_DICT_TRACKING and Supplemental Logging Settings
                  </h4>
                  <div>
                     <p>Describes  interactions that occur when various settings of dictionary tracking and supplemental logging are combined.</p>
                     <p>Note the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If <code class="codeph">DDL_DICT_TRACKING</code> is enabled, but supplemental logging is not enabled and:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>A DDL transaction is encountered in the redo log file, then a query of <code class="codeph">V$LOGMNR_CONTENTS</code> will terminate with the ORA-01347 error.
                                 </p>
                              </li>
                              <li>
                                 <p>A DML transaction is encountered in the redo log file, then LogMiner will not assume that the current version of the table (underlying the DML) in its dictionary is correct, and columns in <code class="codeph">V$LOGMNR_CONTENTS</code> will be set as follows:
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The <code class="codeph">SQL_REDO</code> column will contain binary data.
                                       </p>
                                    </li>
                                    <li>
                                       <p>The <code class="codeph">STATUS</code> column will contain a value of <code class="codeph">2</code> (which indicates that the SQL is not valid).
                                       </p>
                                    </li>
                                    <li>
                                       <p>The <code class="codeph">INFO</code> column will contain the string 'Dictionary Mismatch'.
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If <code class="codeph">DDL_DICT_TRACKING</code> is not enabled and supplemental logging is not enabled, and the columns referenced in a DML operation match the columns in the LogMiner dictionary, then LogMiner assumes that the latest version in its dictionary is correct, and columns in <code class="codeph">V$LOGMNR_CONTENTS</code> will be set as follows:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>LogMiner will use the definition of the object in its dictionary to generate values for the <code class="codeph">SQL_REDO</code> and <code class="codeph">SQL_UNDO</code> columns. 
                                 </p>
                              </li>
                              <li>
                                 <p>The status column will contain a value of <code class="codeph">3</code> (which indicates that the SQL is not guaranteed to be accurate). 
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">INFO</code> column will contain the string 'no supplemental log data found'. 
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>If <code class="codeph">DDL_DICT_TRACKING</code> is not enabled and supplemental logging is not enabled and there are more modified columns in the redo log file for a table than the LogMiner dictionary definition for the table defines, then:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">SQL_REDO</code> and <code class="codeph">SQL_UNDO</code> columns will contain the string 'Dictionary Version Mismatch'. 
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">STATUS</code> column will contain a value of <code class="codeph">2</code> (which indicates that the SQL is not valid). 
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">INFO</code> column will contain the string 'Dictionary Mismatch'.
                                 </p>
                              </li>
                           </ul>
                           <p>Also be aware that it is possible to get unpredictable behavior if the dictionary definition of a column indicates one type but the column is really another type.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1593"></a><div class="props_rev_3"><a id="GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023" name="GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023"></a><h4 id="SUTIL-GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023" class="sect4"><span class="enumeration_section">22.10.6 </span>DDL_DICT_TRACKING and Specified Time or SCN Ranges 
                  </h4>
                  <div>
                     <p>Because LogMiner must not miss a DDL statement if it is to ensure the consistency of its dictionary, LogMiner may start reading redo log files before your requested starting time or SCN (as specified with <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>) when the <code class="codeph">DDL_DICT_TRACKING</code> option is enabled. 
                     </p>
                     <p>The actual time or SCN at which LogMiner starts reading redo log files is referred to as the <span class="bold">required starting time</span> or the <span class="bold">required starting SCN</span>. 
                     </p>
                     <p>No missing redo log files (based on sequence numbers) are allowed from the required starting time or the required starting SCN.</p>
                     <p>LogMiner determines where it will start reading redo log data as follows:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>After the dictionary is loaded, the first time that you call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, LogMiner begins reading as determined by one of the following, whichever causes it to begin earlier:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Your requested starting time or SCN value </p>
                              </li>
                              <li>
                                 <p>The commit SCN of the dictionary dump</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>On subsequent calls to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, LogMiner begins reading as determined for one of the following, whichever causes it to begin earliest:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Your requested starting time or SCN value</p>
                              </li>
                              <li>
                                 <p>The start of the earliest DDL transaction where the <code class="codeph">COMMIT</code> statement has not yet been read by LogMiner
                                 </p>
                              </li>
                              <li>
                                 <p>The highest SCN read by LogMiner</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>The following scenario helps illustrate this: </p>
                     <p>Suppose you create a redo log file list containing five redo log files. Assume that a dictionary is contained in the first redo file, and the changes that you have indicated you want to see (using <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>) are recorded in the third redo log file. You then do the following:
                     </p>
                     <ol>
                        <li>
                           <p>Call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>. LogMiner will read:
                           </p>
                           <ol type="a">
                              <li>
                                 <p>The first log file to load the dictionary</p>
                              </li>
                              <li>
                                 <p>The second redo log file to pick up any possible DDLs contained within it</p>
                              </li>
                              <li>
                                 <p> The third log file to retrieve the data of interest</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>Call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again with the same requested range. 
                           </p>
                           <p>LogMiner will begin with redo log file 3; it no longer needs to read redo log file 2, because it has already processed any DDL statements contained within it.</p>
                        </li>
                        <li>
                           <p>Call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again, this time specifying parameters that require data to be read from redo log file 5. 
                           </p>
                           <p>LogMiner will start reading from redo log file 4 to pick up any DDL statements that may be contained within it. </p>
                        </li>
                     </ol>
                     <p>Query the <code class="codeph">REQUIRED_START_DATE</code> or the <code class="codeph">REQUIRED_START_SCN</code> columns of the <code class="codeph">V$LOGMNR_PARAMETERS</code> view to see where LogMiner will actually start reading. Regardless of where LogMiner starts reading, only rows in your requested range will be returned from the <code class="codeph">V$LOGMNR_CONTENTS</code> view. 
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1594"></a><div class="props_rev_3"><a id="GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" name="GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39"></a><h3 id="SUTIL-GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" class="sect3"><span class="enumeration_section">22.11 </span>Accessing LogMiner Operational Information in Views
               </h3>
               <div>
                  <p>LogMiner operational information (as opposed to redo data) is contained in views. </p>
                  <p>You can use SQL to query them as you would any other view.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">V$LOGMNR_DICTIONARY</code></p>
                        <p>Shows information about a LogMiner dictionary file that was created using the <code class="codeph">STORE_IN_FLAT_FILE</code> option to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>. The information shown includes information about the database from which the LogMiner dictionary was created.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$LOGMNR_LOGS</code></p>
                        <p>Shows information about specified redo log files, as described in <a href="oracle-logminer-utility.html#GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" title="You can query the V$LOGMNR_LOGS view to determine which redo log files have been manually or automatically added to the list of redo log files for LogMiner to analyze.">Querying V$LOGMNR_LOGS</a>.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$LOGMNR_PARAMETERS</code></p>
                        <p>Shows information about optional LogMiner parameters, including starting and ending system change numbers (SCNs) and starting and ending times.</p>
                     </li>
                     <li>
                        <p><code class="codeph">V$DATABASE</code>, <code class="codeph">DBA_LOG_GROUPS</code>, <code class="codeph">ALL_LOG_GROUPS</code>, <code class="codeph">USER_LOG_GROUPS</code>, <code class="codeph">DBA_LOG_GROUP_COLUMNS</code>, <code class="codeph">ALL_LOG_GROUP_COLUMNS</code>, <code class="codeph">USER_LOG_GROUP_COLUMN</code>S
                        </p>
                        <p>Shows information about the current settings for supplemental logging, as described in <a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" title="Describes how to query several views to determine the current settings for supplemental logging.">Querying Views for Supplemental Logging Settings</a>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F">Querying V$LOGMNR_LOGS</a><br>You can query the <code class="codeph">V$LOGMNR_LOGS</code> view to determine which redo log files have been manually or automatically added to the list of redo log files for LogMiner to analyze.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1">Querying Views for Supplemental Logging Settings</a><br>Describes how to query several views to determine the current settings for supplemental logging.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" name="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F"></a><h4 id="SUTIL-GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" class="sect4"><span class="enumeration_section">22.11.1 </span>Querying V$LOGMNR_LOGS
                  </h4>
                  <div>
                     <p>You can query the <code class="codeph">V$LOGMNR_LOGS</code> view to determine which redo log files have been manually or automatically added to the list of redo log files for LogMiner to analyze.
                     </p>
                     <p>This view contains one row for each redo log file. It provides valuable information about each of the redo log files, including file name, SCN and time ranges, and whether it contains all or part of the LogMiner dictionary. </p>
                     <p>After a successful call to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>, the <code class="codeph">STATUS</code> column of the <code class="codeph">V$LOGMNR_LOGS</code> view contains one of the following values:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">0</code>  
                           </p>
                           <p>Indicates that the redo log file will be processed during a query of the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">1</code>  
                           </p>
                           <p>Indicates that this will be the first redo log file to be processed by LogMiner during a select operation against the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">2</code>  
                           </p>
                           <p>Indicates that the redo log file has been pruned and therefore will not be processed by LogMiner during a query of the <code class="codeph">V$LOGMNR_CONTENTS</code> view. It has been pruned because it is not needed to satisfy your requested time or SCN range.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">4</code>  
                           </p>
                           <p>Indicates that a redo log file (based on sequence number) is missing from the LogMiner redo log file list.</p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">V$LOGMNR_LOGS</code> view contains a row for each redo log file that is missing from the list, as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">FILENAME</code> column will contain the consecutive range of sequence numbers and total SCN range gap. 
                           </p>
                           <p>For example: 'Missing log file(s) for thread number 1, sequence number(s) 100 to 102'. </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">INFO</code> column will contain the string 'MISSING_LOGFILE'. 
                           </p>
                        </li>
                     </ul>
                     <p>Information about files missing from the redo log file list can be useful for the following reasons:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">DDL_DICT_TRACKING</code> option that can be specified when you call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> will not allow redo log files to be missing from the LogMiner redo log file list for the requested time or SCN range. If a call to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> fails, then you can query the <code class="codeph">STATUS</code> column in the <code class="codeph">V$LOGMNR_LOGS</code> view to determine which redo log files are missing from the list. You can then find and manually add these redo log files and attempt to call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> again.
                           </p>
                           <div class="infoboxnote" id="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F__GUID-5606C88D-743A-4945-9CF5-85C664D49800">
                              <p class="notep1">Note:</p>The <code class="codeph">continuous_mine</code> option for the <code class="codeph">dbms_logmnr.start_logmnr</code> package is desupported in Oracle Database 19c (19.1), and is no longer available.
                           </div>
                        </li>
                        <li>
                           <p>Although all other options that can be specified when you call <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> allow files to be missing from the LogMiner redo log file list, you may not want to have missing files. You can query the <code class="codeph">V$LOGMNR_LOGS</code> view before querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view to ensure that all required files are in the list. If the list is left with missing files and you query the <code class="codeph">V$LOGMNR_CONTENTS</code> view, then a row is returned in <code class="codeph">V$LOGMNR_CONTENTS</code> with the following column values:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>In the <code class="codeph">OPERATION</code> column, a value of 'MISSING_SCN'
                                 </p>
                              </li>
                              <li>
                                 <p> In the <code class="codeph">STATUS</code> column, a value of <code class="codeph">1291</code></p>
                              </li>
                              <li>
                                 <p>In the <code class="codeph">INFO</code> column, a string indicating the missing SCN range (for example, 'Missing SCN 100 - 200')
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" title="LogMiner operational information (as opposed to redo data) is contained in views.">Accessing LogMiner Operational Information in Views</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1596"></a><div class="props_rev_3"><a id="GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" name="GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1"></a><h4 id="SUTIL-GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" class="sect4"><span class="enumeration_section">22.11.2 </span>Querying Views for Supplemental Logging Settings
                  </h4>
                  <div>
                     <p>Describes how to query several views to determine the current settings for supplemental logging.</p>
                     <p>Specificallyt:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">V$DATABASE</code> view
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_FK</code> column
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">NO</code> - if database-level identification key logging with the <code class="codeph">FOREIGN KEY</code> option is not enabled
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - if database-level identification key logging with the <code class="codeph">FOREIGN KEY</code> option is enabled
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_ALL</code> column
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">NO</code> - if database-level identification key logging with the <code class="codeph">ALL</code> option is not enabled
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - if database-level identification key logging with the <code class="codeph">ALL</code> option is enabled
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_UI</code> column
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">NO</code> - if database-level identification key logging with the <code class="codeph">UNIQUE</code> option is not enabled
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - if database-level identification key logging with the <code class="codeph">UNIQUE</code> option is enabled
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_MIN</code> column
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p> <code class="codeph">NO</code> - if no database-level supplemental logging is enabled
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">IMPLICIT</code> - if minimal supplemental logging is enabled because database-level identification key logging options is enabled
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - if minimal supplemental logging is enabled because the SQL <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">ADD</code> <code class="codeph">SUPPLEMENTAL</code> <code class="codeph">LOG</code> <code class="codeph">DATA</code> statement was issued
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">DBA_LOG_GROUPS</code>, <code class="codeph">ALL_LOG_GROUPS</code>, and <code class="codeph">USER_LOG_GROUPS</code> views
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">ALWAYS</code> column
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">ALWAYS</code> - indicates that the columns in this log group will be supplementally logged if any column in the associated row is updated
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CONDITIONAL</code> - indicates that the columns in this group will be supplementally logged only if a column in the log group is updated
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">GENERATED</code> column
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">GENERATED NAME</code> - if the <code class="codeph">LOG_GROUP</code> name was system-generated
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">USER NAME</code> - if the <code class="codeph">LOG_GROUP</code> name was user-defined
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">LOG_GROUP_TYPE</code> column
                                 </p>
                                 <p>This column contains one of the following values to indicate the type of logging defined for this log group. <code class="codeph">USER LOG GROUP</code> indicates that the log group was user-defined (as opposed to system-generated).
                                 </p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">ALL COLUMN LOGGING</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">FOREIGN KEY LOGGING</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">PRIMARY KEY LOGGING</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">UNIQUE KEY LOGGING</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">USER LOG GROUP</code></p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">DBA_LOG_GROUP_COLUMNS</code>, <code class="codeph">ALL_LOG_GROUP_COLUMNS</code>, and <code class="codeph">USER_LOG_GROUP_COLUMNS</code> views
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">LOGGING_PROPERTY</code> column 
                                 </p>
                                 <p>This column contains one of the following values:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><code class="codeph">LOG</code> - indicates that this column in the log group will be supplementally logged
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">NO</code> <code class="codeph">LOG</code> - indicates that this column in the log group will not be supplementally logged
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" title="LogMiner operational information (as opposed to redo data) is contained in views.">Accessing LogMiner Operational Information in Views</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1597"></a><div class="props_rev_3"><a id="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" name="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760"></a><h3 id="SUTIL-GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" class="sect3"><span class="enumeration_section">22.12 </span>Steps in a Typical LogMiner Session
               </h3>
               <div>
                  <p>Describes the steps in a typical LogMiner session. </p>
                  <div class="section">
                     <p>Each step is described in its own subsection.</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span><a href="oracle-logminer-utility.html#GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" title="Enabling supplemental logging.">Enable Supplemental Logging</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" title="Extracting a LogMiner dictionary.">Extract a LogMiner Dictionary</a> (unless you plan to use the online catalog)</span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" title="Specifying redo log files for analysis.">Specify Redo Log Files for Analysis</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" title="Starting LogMiner.">Start LogMiner</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" title="Querying the V$LOGMNR_CONTENTS view.">Typical LogMiner Session Task 5: Query V$LOGMNR_CONTENTS</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" title="Ending the LogMiner session.">End the LogMiner Session</a></span></li>
                  </ol>
                  <div class="section">
                     <p>To run LogMiner, you use the <code class="codeph">DBMS_LOGMNR</code> PL/SQL package. Additionally, you might also use the <code class="codeph">DBMS_LOGMNR_D</code> package if you choose to extract a LogMiner dictionary rather than use the online catalog.
                     </p>
                     <p>The <code class="codeph">DBMS_LOGMNR</code> package contains the procedures used to initialize and run LogMiner, including interfaces to specify names of redo log files, filter criteria, and session characteristics. The <code class="codeph">DBMS_LOGMNR_D</code> package queries the database dictionary tables of the current database to create a LogMiner dictionary file. 
                     </p>
                     <p>The LogMiner PL/SQL packages are owned by the <code class="codeph">SYS</code> schema. Therefore, if you are not connected as user <code class="codeph">SYS</code>, then:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You must include <code class="codeph">SYS</code> in your call. For example:
                           </p><pre class="oac_no_warn" dir="ltr"><code class="codeph">EXECUTE SYS.DBMS_LOGMNR.END_LOGMNR</code>;
</pre></li>
                        <li>
                           <p>You must have been granted the <code class="codeph">EXECUTE_CATALOG_ROLE</code> role.
                           </p>
                           <div class="infoboxnotealso" id="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760__GUID-5755A8B1-82B9-4083-9F04-D5732801B73E">
                              <p class="notep1">See Also:</p>
                              <p></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../arpls/DBMS_LOGMNR.html#ARPLS022" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details about syntax and parameters for these LogMiner packages
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS1398" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for more information about PL/SQL packages
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F621A15A-0A29-4261-9C23-F95139E5D79E">Typical LogMiner Session Task 1: Enable Supplemental Logging</a><br>Enabling supplemental logging. 
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757">Typical LogMiner Session Task 2: Extract a LogMiner Dictionary</a><br>Extracting a LogMiner dictionary.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CEB3F34A-633A-47D5-B568-F65746D02D02">Typical LogMiner Session Task 3: Specify Redo Log Files for Analysis</a><br>Specifying redo log files for analysis.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF">Typical LogMiner Session Task 4: Start LogMiner</a><br>Starting LogMiner.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6">Typical LogMiner Session Task 5: Query V$LOGMNR_CONTENTS</a><br>Querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3">Typical LogMiner Session Task 6: End the LogMiner Session</a><br>Ending the LogMiner session.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1598"></a><div class="props_rev_3"><a id="GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" name="GUID-F621A15A-0A29-4261-9C23-F95139E5D79E"></a><h4 id="SUTIL-GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" class="sect4"><span class="enumeration_section">22.12.1 </span>Typical LogMiner Session Task 1: Enable Supplemental Logging
                  </h4>
                  <div>
                     <p>Enabling supplemental logging. </p>
                     <div class="section">
                        <p>Enable the type of supplemental logging you want to use. At the very least, you must enable minimal supplemental logging, as follows:</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
</pre><p>See <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a> for more information.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1599"></a><div class="props_rev_3"><a id="GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" name="GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757"></a><h4 id="SUTIL-GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" class="sect4"><span class="enumeration_section">22.12.2 </span>Typical LogMiner Session Task 2: Extract a LogMiner Dictionary
                  </h4>
                  <div>
                     <p>Extracting a LogMiner dictionary.</p>
                     <p>To use LogMiner, you must supply it with a dictionary by doing one of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Specify use of the online catalog by using the <code class="codeph">DICT_FROM_ONLINE_CATALOG</code> option when you start LogMiner. See <a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="To direct LogMiner to use the dictionary currently in use for the database, specify the online catalog as your dictionary source when you start LogMiner.">Using the Online Catalog</a>.
                           </p>
                        </li>
                        <li>
                           <p>Extract database dictionary information to the redo log files. See <a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="To extract a LogMiner dictionary to the redo log files, the database must be open and in ARCHIVELOG mode and archiving must be enabled.">Extracting a LogMiner Dictionary to the Redo Log Files</a>. 
                           </p>
                        </li>
                        <li>
                           <p>Extract database dictionary information to a flat file. See <a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" title="When the LogMiner dictionary is in a flat file, fewer system resources are used than when it is contained in the redo log files. Oracle recommends that you regularly back up the dictionary extract to ensure correct analysis of older redo log files.">Extracting the LogMiner Dictionary to a Flat File </a>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1600"></a><div class="props_rev_3"><a id="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" name="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02"></a><h4 id="SUTIL-GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" class="sect4"><span class="enumeration_section">22.12.3 </span>Typical LogMiner Session Task 3: Specify Redo Log Files for Analysis
                  </h4>
                  <div>
                     <p>Specifying redo log files for analysis.</p>
                     <div class="section">
                        <p>Before you can start LogMiner, you must specify the redo log files that you want to analyze. To do so, execute the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> procedure, as demonstrated in the following steps. You can add and remove redo log files in any order.
                        </p>
                        <div class="infoboxnote" id="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02__GUID-BF44A8BE-2FCE-4AF6-B3F0-68DE0E03952B">
                           <p class="notep1">Note:</p>
                           <p>If you are mining in the database instance that is generating the redo log files, then you only need to specify one of the following when you start LogMiner:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">STARTSCN</code> parameter
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">STARTTIME</code> parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Use SQL*Plus to start an Oracle instance, with the database either mounted or unmounted. For example, enter the <code class="codeph">STARTUP</code> statement at the SQL prompt:</span><div><pre class="oac_no_warn" dir="ltr">STARTUP
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Create a list of redo log files. Specify the <code class="codeph">NEW</code> option of the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL/SQL procedure to signal that this is the beginning of a new list. For example, enter the following to specify the <code class="codeph">/oracle/logs/log1.f</code> redo log file: </span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/oracle/logs/log1.f', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If desired, add more redo log files by specifying the <code class="codeph">ADDFILE</code> option of the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL/SQL procedure. For example, enter the following to add the <code class="codeph">/oracle/logs/log2.f</code> redo log file:</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/oracle/logs/log2.f', -
   OPTIONS =&gt; DBMS_LOGMNR.ADDFILE);
</pre><p>The <code class="codeph">OPTIONS</code> parameter is optional when you are adding additional redo log files. For example, you could simply enter the following:
                              </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME=&gt;'/oracle/logs/log2.f');
</pre></div>
                        </li>
                        <li class="stepexpand"><span>If desired, remove redo log files by using the <code class="codeph">DBMS_LOGMNR.REMOVE_LOGFILE </code>PL/SQL procedure. For example, enter the following to remove the <code class="codeph">/oracle/logs/log2.f</code> redo log file:</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.REMOVE_LOGFILE( -
   LOGFILENAME =&gt; '/oracle/logs/log2.f');</pre></div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1601"></a><div class="props_rev_3"><a id="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" name="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF"></a><h4 id="SUTIL-GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" class="sect4"><span class="enumeration_section">22.12.4 </span>Typical LogMiner Session Task 4: Start LogMiner
                  </h4>
                  <div>
                     <p>Starting LogMiner.</p>
                     <div class="section">
                        <p>After you have created a LogMiner dictionary file and specified which redo log files to analyze, you must start LogMiner. Take the following steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Execute the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure to start LogMiner.</span><div>
                              <p>Oracle recommends that you specify a LogMiner dictionary option. If you do not, then LogMiner cannot translate internal object identifiers and data types to object names and external data formats. Therefore, it would return internal object IDs and present data as binary data. Additionally, the <code class="codeph">MINE_VALUE</code> and <code class="codeph">COLUMN_PRESENT</code> functions cannot be used without a dictionary.
                              </p>
                              <p>If you are specifying the name of a flat file LogMiner dictionary, then you must supply a fully qualified file name for the dictionary file. For example, to start LogMiner using <code class="codeph">/oracle/database/dictionary.ora</code>, issue the following statement:
                              </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   DICTFILENAME =&gt;'/oracle/database/dictionary.ora');
</pre><p>If you are not specifying a flat file dictionary name, then use the <code class="codeph">OPTIONS</code> parameter to specify either the <code class="codeph">DICT_FROM_REDO_LOGS</code> or <code class="codeph">DICT_FROM_ONLINE_CATALOG</code> option. 
                              </p>
                              <p>If you specify <code class="codeph">DICT_FROM_REDO_LOGS</code>, then LogMiner expects to find a dictionary in the redo log files that you specified with the <code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> procedure. To determine which redo log files contain a dictionary, look at the <code class="codeph">V$ARCHIVED_LOG</code> view. See <a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="To extract a LogMiner dictionary to the redo log files, the database must be open and in ARCHIVELOG mode and archiving must be enabled.">Extracting a LogMiner Dictionary to the Redo Log Files</a> for an example.
                              </p>
                              <div class="infoboxnote" id="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF__GUID-7E8B82D6-442D-4911-A7DA-019E1EC04B16">
                                 <p class="notep1">Note:</p>
                                 <p>If you add additional redo log files after LogMiner has been started, you must restart LogMiner. LogMiner will not retain options that were included in the previous call to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>; you must respecify the options you want to use. However, LogMiner will retain the dictionary specification from the previous call if you do not specify a dictionary in the current call to <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>.
                                 </p>
                              </div>
                              <p>For more information about the <code class="codeph">DICT_FROM_ONLINE_CATALOG</code> option, see <a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="To direct LogMiner to use the dictionary currently in use for the database, specify the online catalog as your dictionary source when you start LogMiner.">Using the Online Catalog</a>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Optionally, you can filter your query by time or by SCN. See <a href="oracle-logminer-utility.html#GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" title="To filter data by time, set the STARTTIME and ENDTIME parameters in the DBMS_LOGMNR.START_LOGMNR procedure.">Filtering Data by Time</a> or <a href="oracle-logminer-utility.html#GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" title="To filter data by SCN (system change number), use the STARTSCN and ENDSCN parameters to the PL/SQL DBMS_LOGMNR.START_LOGMNR procedure.">Filtering Data by SCN</a>.</span></li>
                        <li class="stepexpand"><span>You can also use the <code class="codeph">OPTIONS</code> parameter to specify additional characteristics of your LogMiner session. For example, you might decide to use the online catalog as your LogMiner dictionary and to have only committed transactions shown in the <code class="codeph">V$LOGMNR_CONTENTS</code> view, as follows:</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(OPTIONS =&gt; -
   DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
   DBMS_LOGMNR.COMMITTED_DATA_ONLY);
</pre><p>For more information about <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> options, see <a href="../arpls/DBMS_LOGMNR.html#ARPLS022" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.
                              </p>
                              <p>You can execute the <code class="codeph">DBMS_LOGMNR</code>.<code class="codeph">START_LOGMNR</code> procedure multiple times, specifying different options each time. This can be useful, for example, if you did not get the desired results from a query of <code class="codeph">V$LOGMNR_CONTENTS</code>, and want to restart LogMiner with different options. Unless you need to respecify the LogMiner dictionary, you do not need to add redo log files if they were already added with a previous call to <code class="codeph">DBMS_LOGMNR</code>.<code class="codeph">START_LOGMNR</code>.
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" name="GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6"></a><h4 id="SUTIL-GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" class="sect4"><span class="enumeration_section">22.12.5 </span>Typical LogMiner Session Task 5: Query V$LOGMNR_CONTENTS
                  </h4>
                  <div>
                     <p>Querying the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                     </p>
                     <p>At this point, LogMiner is started. You can perform queries against the <code class="codeph">V$LOGMNR_CONTENTS</code> view. See<a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner can potentially deal with large amounts of information. You can limit the information that is returned to the V$LOGMNR_CONTENTS view, and the speed at which it is returned.">Filtering and Formatting Data Returned to V$LOGMNR_CONTENTS</a> for examples of this.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1603"></a><div class="props_rev_3"><a id="GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" name="GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3"></a><h4 id="SUTIL-GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" class="sect4"><span class="enumeration_section">22.12.6 </span>Typical LogMiner Session Task 6: End the LogMiner Session
                  </h4>
                  <div>
                     <p>Ending the LogMiner session.</p>
                     <div class="section">
                        <p>To properly end a LogMiner session, use the <code class="codeph">DBMS_LOGMNR.END_LOGMNR</code> PL/SQL procedure, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR;
</pre><p>This procedure closes all the redo log files and allows all the database and system resources allocated by LogMiner to be released. </p>
                        <p>If this procedure is not executed, then LogMiner retains all its allocated resources until the end of the Oracle session in which it was called. It is particularly important to use this procedure to end the LogMiner session if either the <code class="codeph">DDL_DICT_TRACKING</code> option or the <code class="codeph">DICT_FROM_REDO_LOGS</code> option was used.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1604"></a><div class="props_rev_3"><a id="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" name="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98"></a><h3 id="SUTIL-GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" class="sect3"><span class="enumeration_section">22.13 </span>Examples Using LogMiner
               </h3>
               <div>
                  <p>Examples using LogMiner.</p>
                  <p>This section provides several examples of using LogMiner.</p>
                  <div class="infoboxnote" id="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98__GUID-5453CA86-2715-4149-B09F-A15B35750FA2">
                     <p class="notep1">Note:</p>
                     <p>All examples in this section assume that minimal supplemental logging has been enabled:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
</pre><p>See <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a> for more information.
                     </p>
                     <p>All examples, except <a href="oracle-logminer-utility.html#GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A">Example 2: Mining the Redo Log Files in a Given SCN Range</a> and the <a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="Examples of how to use LogMiner for typical scenarios.">Example Scenarios</a>, assume that the <code class="codeph">NLS_DATE_FORMAT</code> parameter has been set as follows:
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt;  ALTER SESSION SET NLS_DATE_FORMAT = 'dd-mon-yyyy hh24:mi:ss';</pre><pre class="oac_no_warn" dir="ltr"></pre><p>Because LogMiner displays date data using the setting for the <code class="codeph">NLS_DATE_FORMAT</code>   parameter that is active for the user session, this step is optional. However, setting the parameter explicitly lets you predict the date format.
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a><br>Examples specifying redo log files.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4">Examples of Mining Without Specifying the List of Redo Log Files Explicitly</a><br>Examples that do not specify redo log files.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027">Example Scenarios</a><br>Examples of how to use LogMiner for typical scenarios.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1605"></a><div class="props_rev_3"><a id="GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" name="GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C"></a><h4 id="SUTIL-GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" class="sect4"><span class="enumeration_section">22.13.1 </span>Examples of Mining by Explicitly Specifying the Redo Log Files of Interest
                  </h4>
                  <div>
                     <p>Examples specifying redo log files.</p>
                     <p>These examples demonstrate how to use LogMiner when you know which redo log files contain the data of interest. These examples are best read sequentially, because each example builds on the example or examples that precede it.</p>
                     <p>The SQL output formatting may be different on your display than that shown in these examples. </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">Example 1: Finding All Modifications in the Last Archived Redo Log File</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0">Example 2: Grouping DML Statements into Committed Transactions</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E42A8D99-F93F-40F4-9E86-787CA179692A">Example 3: Formatting the Reconstructed SQL</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0">Example 4: Using the LogMiner Dictionary in the Redo Log Files</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F">Example 5: Tracking DDL Statements in the Internal Dictionary</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09">Example 6: Filtering Output by Time Range</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">Examples Using LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4231"></a><a id="SUTIL4232"></a><a id="SUTIL4233"></a><a id="SUTIL4234"></a><a id="SUTIL4235"></a><a id="SUTIL1606"></a><div class="props_rev_3"><a id="GUID-E3820793-B482-48C4-9F44-C0D7A062E318" name="GUID-E3820793-B482-48C4-9F44-C0D7A062E318"></a><h5 id="SUTIL-GUID-E3820793-B482-48C4-9F44-C0D7A062E318" class="sect5"><span class="enumeration_section">22.13.1.1 </span>Example 1: Finding All Modifications in the Last Archived Redo Log File
                     </h5>
                     <div>
                        <div class="section">
                           <p>The easiest way to examine the modification history of a database is to mine at the source database and use the online catalog to translate the redo log files. This example shows how to do the simplest analysis using LogMiner. </p>
                           <p>This example assumes that you know you want to mine the redo log file that was most recently archived. It finds all modifications that are contained in the last archived redo log generated by the database (assuming that the database is not an Oracle Real Application Clusters (Oracle RAC) database). </p>
                           <ol>
                              <li>
                                 <p>Determine which redo log file was most recently archived.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG
   WHERE FIRST_TIME = (SELECT MAX(FIRST_TIME) FROM V$ARCHIVED_LOG);

NAME                            
-------------------------------------------
/usr/oracle/data/db1arch_1_16_482701534.dbf</pre></li>
                              <li>
                                 <p>Specify the list of redo log files to be analyzed. In this case, it is the redo log file that was returned by the query in Step 1.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
  LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_16_482701534.dbf', -
  OPTIONS =&gt; DBMS_LOGMNR.NEW);
</pre></li>
                              <li>
                                 <p>Start LogMiner and specify the dictionary to use.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>Note that there are four transactions (two of them were committed within the redo log file being analyzed, and two were not). The output shows the DML statements in the order in which they were executed; thus transactions interleave among themselves.</p><pre class="oac_no_warn" dir="ltr">SELECT username AS USR, (XIDUSN || '.' || XIDSLT || '.' ||  XIDSQN) AS XID, 
   SQL_REDO, SQL_UNDO FROM V$LOGMNR_CONTENTS WHERE username IN ('HR', 'OE');

USR    XID          SQL_REDO                        SQL_UNDO
----   ---------  ----------------------------------------------------
HR     1.11.1476  set transaction read write;

HR     1.11.1476  insert into "HR"."EMPLOYEES"(     delete from "HR"."EMPLOYEES" 
                  "EMPLOYEE_ID","FIRST_NAME",       where "EMPLOYEE_ID" = '306'
                  "LAST_NAME","EMAIL",              and "FIRST_NAME" = 'Nandini'
                  "PHONE_NUMBER","HIRE_DATE",       and "LAST_NAME" = 'Shastry'
                  "JOB_ID","SALARY",                and "EMAIL" = 'NSHASTRY'
                  "COMMISSION_PCT","MANAGER_ID",    and "PHONE_NUMBER" = '1234567890'
                  "DEPARTMENT_ID") values           and "HIRE_DATE" = TO_DATE('10-JAN-2012
                  ('306','Nandini','Shastry',       13:34:43', 'dd-mon-yyyy hh24:mi:ss') 
                  'NSHASTRY', '1234567890',         and "JOB_ID" = 'HR_REP' and 
                  TO_DATE('10-jan-2012 13:34:43',   "SALARY" = '120000' and 
                  'dd-mon-yyyy hh24:mi:ss'),         "COMMISSION_PCT" = '.05' and
                  'HR_REP','120000', '.05',         "DEPARTMENT_ID" = '10' and
                  '105','10');                      ROWID = 'AAAHSkAABAAAY6rAAO';
     
OE     1.1.1484   set transaction read write;

OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  update "OE"."PRODUCT_INFORMATION" 
                  set "WARRANTY_PERIOD" =            set "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+05-00') where      TO_YMINTERVAL('+01-00') where
                  "PRODUCT_ID" = '1799' and          "PRODUCT_ID" = '1799' and
                  "WARRANTY_PERIOD" =                "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+01-00') and        TO_YMINTERVAL('+05-00') and
                  ROWID = 'AAAHTKAABAAAY9mAAB';      ROWID = 'AAAHTKAABAAAY9mAAB'; 
                                                                                
OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  update "OE"."PRODUCT_INFORMATION"
                  set "WARRANTY_PERIOD" =            set "WARRANTY_PERIOD" =
                  TO_YMINTERVAL('+05-00') where      TO_YMINTERVAL('+01-00') where
                  "PRODUCT_ID" = '1801' and          "PRODUCT_ID" = '1801' and
                  "WARRANTY_PERIOD" =                "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+01-00') and        TO_YMINTERVAL('+05-00') and
                  ROWID = 'AAAHTKAABAAAY9mAAC';      ROWID ='AAAHTKAABAAAY9mAAC';

HR     1.11.1476  insert into "HR"."EMPLOYEES"(     delete from "HR"."EMPLOYEES"
                  "EMPLOYEE_ID","FIRST_NAME",       "EMPLOYEE_ID" = '307' and 
                  "LAST_NAME","EMAIL",              "FIRST_NAME" = 'John' and
                  "PHONE_NUMBER","HIRE_DATE",       "LAST_NAME" = 'Silver' and
                  "JOB_ID","SALARY",                "EMAIL" = 'JSILVER' and 
                  "COMMISSION_PCT","MANAGER_ID",    "PHONE_NUMBER" = '5551112222'
                  "DEPARTMENT_ID") values           and "HIRE_DATE" = TO_DATE('10-jan-2012
                  ('307','John','Silver',           13:41:03', 'dd-mon-yyyy hh24:mi:ss') 
                   'JSILVER', '5551112222',         and "JOB_ID" ='105' and "DEPARTMENT_ID" 
                  TO_DATE('10-jan-2012 13:41:03',   = '50' and ROWID = 'AAAHSkAABAAAY6rAAP'; 
                  'dd-mon-yyyy hh24:mi:ss'),
                  'SH_CLERK','110000', '.05',
                  '105','50');                

OE     1.1.1484   commit;

HR     1.15.1481   set transaction read write;

HR     1.15.1481  delete from "HR"."EMPLOYEES"      insert into "HR"."EMPLOYEES"(
                  where "EMPLOYEE_ID" = '205' and   "EMPLOYEE_ID","FIRST_NAME",
                  "FIRST_NAME" = 'Shelley' and      "LAST_NAME","EMAIL","PHONE_NUMBER",
                  "LAST_NAME" = 'Higgins' and       "HIRE_DATE", "JOB_ID","SALARY",
                  "EMAIL" = 'SHIGGINS' and          "COMMISSION_PCT","MANAGER_ID",
                  "PHONE_NUMBER" = '515.123.8080'   "DEPARTMENT_ID") values
                  and "HIRE_DATE" = TO_DATE(        ('205','Shelley','Higgins',
                  '07-jun-1994 10:05:01',           and     'SHIGGINS','515.123.8080',
                  'dd-mon-yyyy hh24:mi:ss')         TO_DATE('07-jun-1994 10:05:01',
                  and "JOB_ID" = 'AC_MGR'           'dd-mon-yyyy hh24:mi:ss'),
                  and "SALARY"= '12000'            'AC_MGR','12000',NULL,'101','110'); 
                  and "COMMISSION_PCT" IS NULL 
                  and "MANAGER_ID" 
                  = '101' and "DEPARTMENT_ID" = 
                  '110' and ROWID = 
                  'AAAHSkAABAAAY6rAAM';


OE     1.8.1484   set transaction read write;

OE     1.8.1484   update "OE"."PRODUCT_INFORMATION"  update "OE"."PRODUCT_INFORMATION"
                  set "WARRANTY_PERIOD" =            set "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+12-06') where      TO_YMINTERVAL('+20-00') where
                  "PRODUCT_ID" = '2350' and          "PRODUCT_ID" = '2350' and
                  "WARRANTY_PERIOD" =                "WARRANTY_PERIOD" =
                  TO_YMINTERVAL('+20-00') and        TO_YMINTERVAL('+20-00') and
                  ROWID = 'AAAHTKAABAAAY9tAAD';       ROWID ='AAAHTKAABAAAY9tAAD'; 

HR     1.11.1476  commit;
</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4236"></a><a id="SUTIL4237"></a><a id="SUTIL4238"></a><a id="SUTIL4239"></a><a id="SUTIL4240"></a><a id="SUTIL1607"></a><div class="props_rev_3"><a id="GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0" name="GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0"></a><h5 id="SUTIL-GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0" class="sect5"><span class="enumeration_section">22.13.1.2 </span>Example 2: Grouping DML Statements into Committed Transactions 
                     </h5>
                     <div>
                        <div class="section">
                           <p>As shown in the first example, <a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">Example 1: Finding All Modifications in the Last Archived Redo Log File</a>, LogMiner displays all modifications it finds in the redo log files that it analyzes by default, regardless of whether the transaction has been committed or not. In addition, LogMiner shows modifications in the same order in which they were executed. Because DML statements that belong to the same transaction are not grouped together, visual inspection of the output can be difficult. Although you can use SQL to group transactions, LogMiner provides an easier way. In this example, the latest archived redo log file will again be analyzed, but it will return only committed transactions.
                           </p>
                           <ol>
                              <li>
                                 <p>Determine which redo log file was most recently archived by the database.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG
   WHERE FIRST_TIME = (SELECT MAX(FIRST_TIME) FROM V$ARCHIVED_LOG);

NAME                            
-------------------------------------------
/usr/oracle/data/db1arch_1_16_482701534.dbf
</pre></li>
                              <li>
                                 <p>Specify the redo log file that was returned by the query in Step 1. The list will consist of one redo log file.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_16_482701534.dbf', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);</pre></li>
                              <li>
                                 <p>Start LogMiner by specifying the dictionary to use and the <code class="codeph">COMMITTED_DATA_ONLY</code> option.
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_16_482701534.dbf', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>Although transaction 1.11.1476 was started before transaction 1.1.1484 (as revealed in <a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">Example 1: Finding All Modifications in the Last Archived Redo Log File</a>), it committed after transaction 1.1.1484 committed. In this example, therefore, transaction 1.1.1484 is shown in its entirety before transaction 1.11.1476. The two transactions that did not commit within the redo log file being analyzed are not returned.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT username AS USR, (XIDUSN || '.' || XIDSLT || '.' ||  XIDSQN) AS XID, SQL_REDO, 
   SQL_UNDO FROM V$LOGMNR_CONTENTS WHERE username IN ('HR', 'OE');
;
USR    XID          SQL_REDO                        SQL_UNDO
----   ---------    ------------------------------- ---------------------------------
     
OE     1.1.1484   set transaction read write;

OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  update "OE"."PRODUCT_INFORMATION" 
                  set "WARRANTY_PERIOD" =            set "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+05-00') where      TO_YMINTERVAL('+01-00') where
                  "PRODUCT_ID" = '1799' and          "PRODUCT_ID" = '1799' and
                  "WARRANTY_PERIOD" =                "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+01-00') and        TO_YMINTERVAL('+05-00') and
                  ROWID = 'AAAHTKAABAAAY9mAAB';      ROWID = 'AAAHTKAABAAAY9mAAB'; 
                                                                                
OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  update "OE"."PRODUCT_INFORMATION"
                  set "WARRANTY_PERIOD" =            set "WARRANTY_PERIOD" =
                  TO_YMINTERVAL('+05-00') where      TO_YMINTERVAL('+01-00') where
                  "PRODUCT_ID" = '1801' and          "PRODUCT_ID" = '1801' and
                  "WARRANTY_PERIOD" =                "WARRANTY_PERIOD" = 
                  TO_YMINTERVAL('+01-00') and        TO_YMINTERVAL('+05-00') and
                  ROWID = 'AAAHTKAABAAAY9mAAC';      ROWID ='AAAHTKAABAAAY9mAAC';

OE     1.1.1484   commit;
                            
HR     1.11.1476  set transaction read write;

HR     1.11.1476  insert into "HR"."EMPLOYEES"(     delete from "HR"."EMPLOYEES" 
                  "EMPLOYEE_ID","FIRST_NAME",       where "EMPLOYEE_ID" = '306'
                  "LAST_NAME","EMAIL",              and "FIRST_NAME" = 'Nandini'
                  "PHONE_NUMBER","HIRE_DATE",       and "LAST_NAME" = 'Shastry'
                  "JOB_ID","SALARY",                and "EMAIL" = 'NSHASTRY'
                  "COMMISSION_PCT","MANAGER_ID",    and "PHONE_NUMBER" = '1234567890'
                  "DEPARTMENT_ID") values           and "HIRE_DATE" = TO_DATE('10-JAN-2012
                  ('306','Nandini','Shastry',       13:34:43', 'dd-mon-yyyy hh24:mi:ss') 
                  'NSHASTRY', '1234567890',         and "JOB_ID" = 'HR_REP' and 
                  TO_DATE('10-jan-2012 13:34:43',   "SALARY" = '120000' and 
                  'dd-mon-yyy hh24:mi:ss'),         "COMMISSION_PCT" = '.05' and
                  'HR_REP','120000', '.05',         "DEPARTMENT_ID" = '10' and
                  '105','10');                      ROWID = 'AAAHSkAABAAAY6rAAO';

HR     1.11.1476  insert into "HR"."EMPLOYEES"(     delete from "HR"."EMPLOYEES"
                  "EMPLOYEE_ID","FIRST_NAME",       "EMPLOYEE_ID" = '307' and 
                  "LAST_NAME","EMAIL",              "FIRST_NAME" = 'John' and
                  "PHONE_NUMBER","HIRE_DATE",       "LAST_NAME" = 'Silver' and
                  "JOB_ID","SALARY",                "EMAIL" = 'JSILVER' and 
                  "COMMISSION_PCT","MANAGER_ID",    "PHONE_NUMBER" = '5551112222'
                  "DEPARTMENT_ID") values           and "HIRE_DATE" = TO_DATE('10-jan-2012
                  ('307','John','Silver',           13:41:03', 'dd-mon-yyyy hh24:mi:ss') 
                   'JSILVER', '5551112222',         and "JOB_ID" ='105' and "DEPARTMENT_ID" 
                  TO_DATE('10-jan-2012 13:41:03',   = '50' and ROWID = 'AAAHSkAABAAAY6rAAP'; 
                  'dd-mon-yyyy hh24:mi:ss'),
                  'SH_CLERK','110000', '.05',
                  '105','50');                

HR     1.11.1476  commit;
</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4241"></a><a id="SUTIL4242"></a><a id="SUTIL4243"></a><a id="SUTIL4244"></a><a id="SUTIL4245"></a><a id="SUTIL4246"></a><a id="SUTIL1608"></a><div class="props_rev_3"><a id="GUID-E42A8D99-F93F-40F4-9E86-787CA179692A" name="GUID-E42A8D99-F93F-40F4-9E86-787CA179692A"></a><h5 id="SUTIL-GUID-E42A8D99-F93F-40F4-9E86-787CA179692A" class="sect5"><span class="enumeration_section">22.13.1.3 </span>Example 3: Formatting the Reconstructed SQL
                     </h5>
                     <div>
                        <div class="section">
                           <p>As shown in <a href="oracle-logminer-utility.html#GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0">Example 2: Grouping DML Statements into Committed Transactions </a>, using the <code class="codeph">COMMITTED_DATA_ONLY</code> option with the dictionary in the online redo log file is an easy way to focus on committed transactions. However, one aspect remains that makes visual inspection difficult: the association between the column names and their respective values in an <code class="codeph">INSERT</code> statement are not apparent. This can be addressed by specifying the <code class="codeph">PRINT_PRETTY_SQL</code> option. Note that specifying this option will make some of the reconstructed SQL statements nonexecutable.
                           </p>
                           <ol>
                              <li>
                                 <p>Determine which redo log file was most recently archived.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG
   WHERE FIRST_TIME = (SELECT MAX(FIRST_TIME) FROM V$ARCHIVED_LOG);

NAME                            
-------------------------------------------
/usr/oracle/data/db1arch_1_16_482701534.dbf</pre></li>
                              <li>
                                 <p>Specify the redo log file that was returned by the query in Step 1.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_16_482701534.dbf', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);</pre></li>
                              <li>
                                 <p>Start LogMiner by specifying the dictionary to use and the <code class="codeph">COMMITTED_DATA_ONLY</code> and <code class="codeph">PRINT_PRETTY_SQL</code> options.
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
              DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
              DBMS_LOGMNR.PRINT_PRETTY_SQL);
</pre><p>The <code class="codeph">DBMS_LOGMNR.PRINT_PRETTY_SQL</code> option changes only the format of the reconstructed SQL, and therefore is useful for generating reports for visual inspection.
                                 </p>
                              </li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view for <code class="codeph">SQL_REDO</code> statements.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT username AS USR, (XIDUSN || '.' || XIDSLT || '.' ||  XIDSQN) AS XID, SQL_REDO 
   FROM V$LOGMNR_CONTENTS;

USR    XID          SQL_REDO                     
----   ---------  -----------------------------------------------------

OE     1.1.1484   set transaction read write;

OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  
                    set 
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') 
                    where
                      "PRODUCT_ID" = '1799' and          
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+01-00') and        
                      ROWID = 'AAAHTKAABAAAY9mAAB';  
                                                                                
OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"
                    set 
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') 
                    where
                      "PRODUCT_ID" = '1801' and
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+01-00') and   
                      ROWID = 'AAAHTKAABAAAY9mAAC'; 

OE     1.1.1484   commit;
                            
HR     1.11.1476  set transaction read write;

HR     1.11.1476  insert into "HR"."EMPLOYEES"
                   values
                     "EMPLOYEE_ID" = 306,
                     "FIRST_NAME" = 'Nandini',
                     "LAST_NAME" = 'Shastry',
                     "EMAIL" = 'NSHASTRY',
                     "PHONE_NUMBER" = '1234567890',
                     "HIRE_DATE" = TO_DATE('10-jan-2012 13:34:43', 
                     'dd-mon-yyyy hh24:mi:ss',
                     "JOB_ID" = 'HR_REP',
                     "SALARY" = 120000,
                     "COMMISSION_PCT" = .05,
                     "MANAGER_ID" = 105,
                     "DEPARTMENT_ID" = 10;

HR     1.11.1476   insert into "HR"."EMPLOYEES"
                    values
                       "EMPLOYEE_ID" = 307,
                       "FIRST_NAME" = 'John',
                       "LAST_NAME" = 'Silver',
                       "EMAIL" = 'JSILVER',
                       "PHONE_NUMBER" = '5551112222',
                       "HIRE_DATE" = TO_DATE('10-jan-2012 13:41:03',
                       'dd-mon-yyyy hh24:mi:ss'),
                       "JOB_ID" = 'SH_CLERK',
                       "SALARY" = 110000,
                       "COMMISSION_PCT" = .05,
                       "MANAGER_ID" = 105,
                       "DEPARTMENT_ID" = 50;
HR     1.11.1476    commit;
</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view for reconstructed <code class="codeph">SQL_UNDO</code> statements.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT username AS USR, (XIDUSN || '.' || XIDSLT || '.' ||  XIDSQN) AS XID, SQL_UNDO 
   FROM V$LOGMNR_CONTENTS;

USR   XID        SQL_UNDO                     
----   ---------  -----------------------------------------------------

     
OE     1.1.1484   set transaction read write;

OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"  
                    set 
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+01-00') 
                    where
                      "PRODUCT_ID" = '1799' and          
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and        
                      ROWID = 'AAAHTKAABAAAY9mAAB';  
                                                                                
OE     1.1.1484   update "OE"."PRODUCT_INFORMATION"
                    set 
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+01-00') 
                    where
                      "PRODUCT_ID" = '1801' and
                      "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and   
                      ROWID = 'AAAHTKAABAAAY9mAAC'; 

OE     1.1.1484   commit;
                            
HR     1.11.1476  set transaction read write;

HR     1.11.1476  delete from "HR"."EMPLOYEES"
                  where
                     "EMPLOYEE_ID" = 306 and
                     "FIRST_NAME" = 'Nandini' and
                     "LAST_NAME" = 'Shastry' and
                     "EMAIL" = 'NSHASTRY' and
                     "PHONE_NUMBER" = '1234567890' and
                     "HIRE_DATE" = TO_DATE('10-jan-2012 13:34:43',
                     'dd-mon-yyyy hh24:mi:ss') and
                     "JOB_ID" = 'HR_REP' and 
                     "SALARY" = 120000 and
                     "COMMISSION_PCT" = .05 and
                     "MANAGER_ID" = 105 and
                     "DEPARTMENT_ID" = 10 and
                     ROWID = 'AAAHSkAABAAAY6rAAO';

HR     1.11.1476   delete from "HR"."EMPLOYEES"
                   where
                       "EMPLOYEE_ID" = 307 and
                       "FIRST_NAME" = 'John' and
                       "LAST_NAME" = 'Silver' and
                       "EMAIL" = 'JSILVER' and
                       "PHONE_NUMBER" = '555122122' and
                       "HIRE_DATE" = TO_DATE('10-jan-2012 13:41:03',
                       'dd-mon-yyyy hh24:mi:ss') and
                       "JOB_ID" = 'SH_CLERK' and
                       "SALARY" = 110000 and
                       "COMMISSION_PCT" = .05 and
                       "MANAGER_ID" = 105 and
                       "DEPARTMENT_ID" = 50 and
                       ROWID = 'AAAHSkAABAAAY6rAAP'; 
HR     1.11.1476    commit;</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4247"></a><a id="SUTIL4248"></a><a id="SUTIL4249"></a><a id="SUTIL4250"></a><a id="SUTIL4251"></a><a id="SUTIL4252"></a><a id="SUTIL1609"></a><div class="props_rev_3"><a id="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0" name="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0"></a><h5 id="SUTIL-GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0" class="sect5"><span class="enumeration_section">22.13.1.4 </span>Example 4: Using the LogMiner Dictionary in the Redo Log Files
                     </h5>
                     <div>
                        <div class="section">
                           <p>This example shows how to use the dictionary that has been extracted to the redo log files. When you use the dictionary in the online catalog, you must mine the redo log files in the same database that generated them. Using the dictionary contained in the redo log files enables you to mine redo log files in a different database. </p>
                           <ol>
                              <li>
                                 <p>Determine which redo log file was most recently archived by the database.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE# FROM V$ARCHIVED_LOG
   WHERE FIRST_TIME = (SELECT MAX(FIRST_TIME) FROM V$ARCHIVED_LOG);

NAME                                           SEQUENCE#
--------------------------------------------   --------------
/usr/oracle/data/db1arch_1_210_482701534.dbf   210</pre></li>
                              <li>
                                 <p>The dictionary may be contained in more than one redo log file. Therefore, you need to determine which redo log files contain the start and end of the dictionary. Query the <code class="codeph">V$ARCHIVED_LOG</code> view, as follows:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>Find a redo log file that contains the end of the dictionary extract. This redo log file must have been created before the redo log file that you want to analyze, but should be as recent as possible. </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE#, DICTIONARY_BEGIN d_beg, DICTIONARY_END d_end
   FROM V$ARCHIVED_LOG
   WHERE SEQUENCE# = (SELECT MAX (SEQUENCE#) FROM V$ARCHIVED_LOG
   WHERE DICTIONARY_END = 'YES' and SEQUENCE# &lt;= 210);

NAME                                           SEQUENCE#    D_BEG  D_END
--------------------------------------------   ----------   -----  ------
/usr/oracle/data/db1arch_1_208_482701534.dbf   208          NO     YES
</pre></li>
                                    <li>
                                       <p>Find the redo log file that contains the start of the data dictionary extract that matches the end of the dictionary found in the previous step: </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE#, DICTIONARY_BEGIN d_beg, DICTIONARY_END d_end
   FROM V$ARCHIVED_LOG
   WHERE SEQUENCE# = (SELECT MAX (SEQUENCE#) FROM V$ARCHIVED_LOG
   WHERE DICTIONARY_BEGIN = 'YES' and SEQUENCE# &lt;= 208);

NAME                                           SEQUENCE#    D_BEG  D_END
--------------------------------------------   ----------   -----  ------
/usr/oracle/data/db1arch_1_207_482701534.dbf   207          YES     NO
</pre></li>
                                    <li>
                                       <p>Specify the list of the redo log files of interest. Add the redo log files that contain the start and end of the dictionary and the redo log file that you want to analyze. You can add the redo log files in any order.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_210_482701534.dbf', -
       OPTIONS =&gt; DBMS_LOGMNR.NEW);
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_208_482701534.dbf');
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_207_482701534.dbf');
</pre></li>
                                    <li>
                                       <p>Query the <code class="codeph">V$LOGMNR_LOGS</code> view to display the list of redo log files to be analyzed, including their timestamps. 
                                       </p>
                                       <p>In the output, LogMiner flags a missing redo log file. LogMiner lets you proceed with mining, provided that you do not specify an option that requires the missing redo log file for proper functioning.</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>Start LogMiner by specifying the dictionary to use and the <code class="codeph">COMMITTED_DATA_ONLY</code> and <code class="codeph">PRINT_PRETTY_SQL</code> options.
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS + -
              DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
              DBMS_LOGMNR.PRINT_PRETTY_SQL);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>To reduce the number of rows returned by the query, exclude from the query all DML statements done in the <code class="codeph">SYS</code> or <code class="codeph">SYSTEM</code> schemas. (This query specifies a timestamp to exclude transactions that were involved in the dictionary extraction.)
                                 </p>
                                 <p>The output shows three transactions: two DDL transactions and one DML transaction. The DDL transactions, 1.2.1594 and 1.18.1602, create the table <code class="codeph">oe.product_tracking</code> and create a trigger on table <code class="codeph">oe.product_information</code>, respectively. In both transactions, the DML statements done to the system tables (tables owned by <code class="codeph">SYS</code>) are filtered out because of the query predicate. 
                                 </p>
                                 <p>The DML transaction, 1.9.1598, updates the <code class="codeph">oe.product_information</code> table. The update operation in this transaction is fully translated. However, the query output also contains some untranslated reconstructed SQL statements. Most likely, these statements were done on the <code class="codeph">oe.product_tracking</code> table that was created after the data dictionary was extracted to the redo log files. 
                                 </p>
                                 <p>(The next example shows how to run LogMiner with the <code class="codeph">DDL_DICT_TRACKING</code> option so that all SQL statements are fully translated; no binary data is returned.)
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr, SQL_REDO FROM V$LOGMNR_CONTENTS 
   WHERE SEG_OWNER IS NULL OR SEG_OWNER NOT IN ('SYS', 'SYSTEM') AND
   TIMESTAMP &gt; '10-jan-2012 15:59:53';

USR             XID         SQL_REDO
---             --------    -----------------------------------
SYS             1.2.1594    set transaction read write;
SYS             1.2.1594    create table oe.product_tracking (product_id number not null,
                            modified_time date,
                            old_list_price number(8,2),
                            old_warranty_period interval year(2) to month);
SYS             1.2.1594    commit;

SYS             1.18.1602   set transaction read write;
SYS             1.18.1602   create or replace trigger oe.product_tracking_trigger
                            before update on oe.product_information
                            for each row
                            when (new.list_price &lt;&gt; old.list_price or
                                  new.warranty_period &lt;&gt; old.warranty_period)
                            declare
                            begin
                            insert into oe.product_tracking values 
                               (:old.product_id, sysdate,
                                :old.list_price, :old.warranty_period);
                            end;
SYS             1.18.1602   commit;

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 100
                              where
                                "PRODUCT_ID" = 1729 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 80 and
                                ROWID = 'AAAHTKAABAAAY9yAAA';

OE              1.9.1598    insert into "UNKNOWN"."OBJ# 33415"
                              values
                                "COL 1" = HEXTORAW('c2121e'),
                                "COL 2" = HEXTORAW('7867010d110804'),
                                "COL 3" = HEXTORAW('c151'),
                                "COL 4" = HEXTORAW('800000053c');

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 92
                              where
                                "PRODUCT_ID" = 2340 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 72 and
                                ROWID = 'AAAHTKAABAAAY9zAAA';

OE              1.9.1598    insert into "UNKNOWN"."OBJ# 33415"
                              values
                                "COL 1" = HEXTORAW('c21829'),
                                "COL 2" = HEXTORAW('7867010d110808'),
                                "COL 3" = HEXTORAW('c149'),
                                "COL 4" = HEXTORAW('800000053c');

OE              1.9.1598     commit;</pre></li>
                              <li>
                                 <p>Issue additional queries, if desired.</p>
                                 <p>Display all the DML statements that were executed as part of the <code class="codeph">CREATE TABLE</code> DDL statement. This includes statements executed by users and internally by Oracle. 
                                 </p>
                                 <div class="infoboxnote" id="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0__IFYOUCHOOSETOREAPPLYSTATEMENTSDISPL-50816118">
                                    <p class="notep1">Note:</p>
                                    <p>If you choose to reapply statements displayed by a query such as the one shown here, then reapply DDL statements only. Do not reapply DML statements that were executed internally by Oracle, or you risk corrupting your database. In the following output, the only statement that you should use in a reapply operation is the <code class="codeph">CREATE TABLE OE.PRODUCT_TRACKING</code> statement.
                                    </p>
                                 </div><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO FROM V$LOGMNR_CONTENTS
   WHERE XIDUSN  = 1 and XIDSLT = 2 and XIDSQN = 1594;

SQL_REDO
--------------------------------------------------------------------------------
set transaction read write;

insert into "SYS"."OBJ$"
 values
    "OBJ#" = 33415,
    "DATAOBJ#" = 33415,
    "OWNER#" = 37,
    "NAME" = 'PRODUCT_TRACKING',
    "NAMESPACE" = 1,
    "SUBNAME" IS NULL,
    "TYPE#" = 2,
    "CTIME" = TO_DATE('13-jan-2012 14:01:03', 'dd-mon-yyyy hh24:mi:ss'),
    "MTIME" = TO_DATE('13-jan-2012 14:01:03', 'dd-mon-yyyy hh24:mi:ss'),
    "STIME" = TO_DATE('13-jan-2012 14:01:03', 'dd-mon-yyyy hh24:mi:ss'),
    "STATUS" = 1,
    "REMOTEOWNER" IS NULL,
    "LINKNAME" IS NULL,
    "FLAGS" = 0,
    "OID$" IS NULL,
    "SPARE1" = 6,
    "SPARE2" = 1,
    "SPARE3" IS NULL,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "SPARE6" IS NULL;

insert into "SYS"."TAB$"
 values
    "OBJ#" = 33415,
    "DATAOBJ#" = 33415,
    "TS#" = 0,
    "FILE#" = 1,
    "BLOCK#" = 121034,
    "BOBJ#" IS NULL,
    "TAB#" IS NULL,
    "COLS" = 5,
    "CLUCOLS" IS NULL,
    "PCTFREE$" = 10,
    "PCTUSED$" = 40,
    "INITRANS" = 1,
    "MAXTRANS" = 255,
    "FLAGS" = 1,
    "AUDIT$" = '--------------------------------------',
    "ROWCNT" IS NULL,
    "BLKCNT" IS NULL,
    "EMPCNT" IS NULL,
    "AVGSPC" IS NULL,
    "CHNCNT" IS NULL,
    "AVGRLN" IS NULL,
    "AVGSPC_FLB" IS NULL,
    "FLBCNT" IS NULL,
    "ANALYZETIME" IS NULL,
    "SAMPLESIZE" IS NULL,
    "DEGREE" IS NULL,
    "INSTANCES" IS NULL,
    "INTCOLS" = 5,
    "KERNELCOLS" = 5,
    "PROPERTY" = 536870912,
    "TRIGFLAG" = 0,
    "SPARE1" = 178,
    "SPARE2" IS NULL,
    "SPARE3" IS NULL,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "SPARE6" = TO_DATE('13-jan-2012 14:01:05', 'dd-mon-yyyy hh24:mi:ss'),

insert into "SYS"."COL$"
 values
    "OBJ#" = 33415,
    "COL#" = 1,
    "SEGCOL#" = 1,
    "SEGCOLLENGTH" = 22,
    "OFFSET" = 0,
    "NAME" = 'PRODUCT_ID',
    "TYPE#" = 2,
    "LENGTH" = 22,
    "FIXEDSTORAGE" = 0,
    "PRECISION#" IS NULL,
    "SCALE" IS NULL,
    "NULL$" = 1,
    "DEFLENGTH" IS NULL,
    "SPARE6" IS NULL,
    "INTCOL#" = 1,
    "PROPERTY" = 0,
    "CHARSETID" = 0,
    "CHARSETFORM" = 0,
    "SPARE1" = 0,
    "SPARE2" = 0,
    "SPARE3" = 0,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "DEFAULT$" IS NULL;

insert into "SYS"."COL$"
 values
    "OBJ#" = 33415,
    "COL#" = 2,
    "SEGCOL#" = 2,
    "SEGCOLLENGTH" = 7,
    "OFFSET" = 0,
    "NAME" = 'MODIFIED_TIME',
    "TYPE#" = 12,
    "LENGTH" = 7,
    "FIXEDSTORAGE" = 0,
    "PRECISION#" IS NULL,
    "SCALE" IS NULL,
    "NULL$" = 0,
    "DEFLENGTH" IS NULL,
    "SPARE6" IS NULL,
    "INTCOL#" = 2,
    "PROPERTY" = 0,
    "CHARSETID" = 0,
    "CHARSETFORM" = 0,
    "SPARE1" = 0,
    "SPARE2" = 0,
    "SPARE3" = 0,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "DEFAULT$" IS NULL;

insert into "SYS"."COL$"
 values
    "OBJ#" = 33415,
    "COL#" = 3,
    "SEGCOL#" = 3,
    "SEGCOLLENGTH" = 22,
    "OFFSET" = 0,
    "NAME" = 'OLD_LIST_PRICE',
    "TYPE#" = 2,
    "LENGTH" = 22,
    "FIXEDSTORAGE" = 0,
    "PRECISION#" = 8,
    "SCALE" = 2,
    "NULL$" = 0,
    "DEFLENGTH" IS NULL,
    "SPARE6" IS NULL,
    "INTCOL#" = 3,
    "PROPERTY" = 0,
    "CHARSETID" = 0,
    "CHARSETFORM" = 0,
    "SPARE1" = 0,
    "SPARE2" = 0,
    "SPARE3" = 0,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "DEFAULT$" IS NULL;

insert into "SYS"."COL$"
 values
    "OBJ#" = 33415,
    "COL#" = 4,
    "SEGCOL#" = 4,
    "SEGCOLLENGTH" = 5,
    "OFFSET" = 0,
    "NAME" = 'OLD_WARRANTY_PERIOD',
    "TYPE#" = 182,
    "LENGTH" = 5,
    "FIXEDSTORAGE" = 0,
    "PRECISION#" = 2,
    "SCALE" = 0,
    "NULL$" = 0,
    "DEFLENGTH" IS NULL,
    "SPARE6" IS NULL,
    "INTCOL#" = 4,
    "PROPERTY" = 0,
    "CHARSETID" = 0,
    "CHARSETFORM" = 0,
    "SPARE1" = 0,
    "SPARE2" = 2,
    "SPARE3" = 0,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "DEFAULT$" IS NULL;

insert into "SYS"."CCOL$"
 values
    "OBJ#" = 33415,
    "CON#" = 2090,
    "COL#" = 1,
    "POS#" IS NULL,
    "INTCOL#" = 1,
    "SPARE1" = 0,
    "SPARE2" IS NULL,
    "SPARE3" IS NULL,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "SPARE6" IS NULL;

insert into "SYS"."CDEF$"
 values
    "OBJ#" = 33415,
    "CON#" = 2090,
    "COLS" = 1,
    "TYPE#" = 7,
    "ROBJ#" IS NULL,
    "RCON#" IS NULL,
    "RRULES" IS NULL,
    "MATCH#" IS NULL,
    "REFACT" IS NULL,
    "ENABLED" = 1,
    "CONDLENGTH" = 24,
    "SPARE6" IS NULL,
    "INTCOLS" = 1,
    "MTIME" = TO_DATE('13-jan-2012 14:01:08', 'dd-mon-yyyy hh24:mi:ss'),
    "DEFER" = 12,
    "SPARE1" = 6,
    "SPARE2" IS NULL,
    "SPARE3" IS NULL,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "CONDITION" = '"PRODUCT_ID" IS NOT NULL';

create table oe.product_tracking (product_id number not null,
  modified_time date,
  old_product_description varchar2(2000),
  old_list_price number(8,2),
  old_warranty_period interval year(2) to month);

update "SYS"."SEG$"
  set
    "TYPE#" = 5,
    "BLOCKS" = 5,
    "EXTENTS" = 1,
    "INIEXTS" = 5,
    "MINEXTS" = 1,
    "MAXEXTS" = 121,
    "EXTSIZE" = 5,
    "EXTPCT" = 50,
    "USER#" = 37,
    "LISTS" = 0,
    "GROUPS" = 0,
    "CACHEHINT" = 0,
    "HWMINCR" = 33415,
    "SPARE1" = 1024
  where
    "TS#" = 0 and
    "FILE#" = 1 and
    "BLOCK#" = 121034 and
    "TYPE#" = 3 and
    "BLOCKS" = 5 and
    "EXTENTS" = 1 and
    "INIEXTS" = 5 and
    "MINEXTS" = 1 and
    "MAXEXTS" = 121 and
    "EXTSIZE" = 5 and
    "EXTPCT" = 50 and
    "USER#" = 37 and
    "LISTS" = 0 and
    "GROUPS" = 0 and
    "BITMAPRANGES" = 0 and
    "CACHEHINT" = 0 and
    "SCANHINT" = 0 and
    "HWMINCR" = 33415 and
    "SPARE1" = 1024 and
    "SPARE2" IS NULL and
    ROWID = 'AAAAAIAABAAAdMOAAB';

insert into "SYS"."CON$"
 values
    "OWNER#" = 37,
    "NAME" = 'SYS_C002090',
    "CON#" = 2090,
    "SPARE1" IS NULL,
    "SPARE2" IS NULL,
    "SPARE3" IS NULL,
    "SPARE4" IS NULL,
    "SPARE5" IS NULL,
    "SPARE6" IS NULL;

commit;</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4253"></a><a id="SUTIL4254"></a><a id="SUTIL4255"></a><a id="SUTIL4256"></a><a id="SUTIL4257"></a><a id="SUTIL4258"></a><a id="SUTIL4259"></a><a id="SUTIL1610"></a><div class="props_rev_3"><a id="GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F" name="GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F"></a><h5 id="SUTIL-GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F" class="sect5"><span class="enumeration_section">22.13.1.5 </span>Example 5: Tracking DDL Statements in the Internal Dictionary
                     </h5>
                     <div>
                        <div class="section">
                           <p>By using the <code class="codeph">DBMS_LOGMNR.DDL_DICT_TRACKING</code> option, this example ensures that the LogMiner internal dictionary is updated with the DDL statements encountered in the redo log files.
                           </p>
                           <ol>
                              <li>
                                 <p>Determine which redo log file was most recently archived by the database.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE# FROM V$ARCHIVED_LOG 
   WHERE FIRST_TIME = (SELECT MAX(FIRST_TIME) FROM V$ARCHIVED_LOG);

NAME                                           SEQUENCE#
--------------------------------------------   --------------
/usr/oracle/data/db1arch_1_210_482701534.dbf   210</pre></li>
                              <li>
                                 <p>Because the dictionary may be contained in more than one redo log file, you need to determine which redo log files contain the start and end of the data dictionary. Query the <code class="codeph">V$ARCHIVED_LOG</code> view, as follows:
                                 </p>
                                 <ol type="a">
                                    <li>
                                       <p>Find a redo log that contains the end of the data dictionary extract. This redo log file must have been created before the redo log files that you want to analyze, but should be as recent as possible. </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE#, DICTIONARY_BEGIN d_beg, DICTIONARY_END d_end
   FROM V$ARCHIVED_LOG
   WHERE SEQUENCE# = (SELECT MAX (SEQUENCE#) FROM V$ARCHIVED_LOG
   WHERE DICTIONARY_END = 'YES' and SEQUENCE# &lt; 210);


NAME                                           SEQUENCE#    D_BEG  D_END
--------------------------------------------   ----------   -----  ------
/usr/oracle/data/db1arch_1_208_482701534.dbf   208          NO     YES
</pre></li>
                                    <li>
                                       <p>Find the redo log file that contains the start of the data dictionary extract that matches the end of the dictionary found by the previous SQL statement: </p><pre class="oac_no_warn" dir="ltr">SELECT NAME, SEQUENCE#, DICTIONARY_BEGIN d_beg, DICTIONARY_END d_end
   FROM V$ARCHIVED_LOG
   WHERE SEQUENCE# = (SELECT MAX (SEQUENCE#) FROM V$ARCHIVED_LOG
   WHERE DICTIONARY_BEGIN = 'YES' and SEQUENCE# &lt;= 208);

NAME                                           SEQUENCE#    D_BEG  D_END
--------------------------------------------   ----------   -----  ------
/usr/oracle/data/db1arch_1_208_482701534.dbf   207          YES     NO
</pre></li>
                                 </ol>
                              </li>
                              <li>
                                 <p> Ensure that you have a complete list of redo log files.</p>
                                 <p>To successfully apply DDL statements encountered in the redo log files, ensure that all files are included in the list of redo log files to mine. The missing log file corresponding to sequence# 209 must be included in the list. Determine the names of the redo log files that you need to add to the list by issuing the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG
   WHERE SEQUENCE# &gt;= 207 AND SEQUENCE# &lt;= 210 
   ORDER BY SEQUENCE# ASC;

NAME                                           
--------------------------------------------   
/usr/oracle/data/db1arch_1_207_482701534.dbf  
/usr/oracle/data/db1arch_1_208_482701534.dbf  
/usr/oracle/data/db1arch_1_209_482701534.dbf  
/usr/oracle/data/db1arch_1_210_482701534.dbf  </pre></li>
                              <li>
                                 <p>Specify the list of the redo log files of interest.</p>
                                 <p>Include the redo log files that contain the beginning and end of the dictionary, the redo log file that you want to mine, and any redo log files required to create a list without gaps. You can add the redo log files in any order.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_210_482701534.dbf', -</pre><pre class="oac_no_warn" dir="ltr">       OPTIONS =&gt; DBMS_LOGMNR.NEW);</pre><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_209_482701534.dbf');
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_208_482701534.dbf');
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(-
   LOGFILENAME =&gt; '/usr/oracle/data/db1arch_1_207_482701534.dbf');</pre></li>
                              <li>
                                 <p>Start LogMiner by specifying the dictionary to use and the <code class="codeph">DDL_DICT_TRACKING</code>, <code class="codeph">COMMITTED_DATA_ONLY</code>, and <code class="codeph">PRINT_PRETTY_SQL</code> options.
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS + -
              DBMS_LOGMNR.DDL_DICT_TRACKING + -
              DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
              DBMS_LOGMNR.PRINT_PRETTY_SQL);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>To reduce the number of rows returned, exclude from the query all DML statements done in the <code class="codeph">SYS</code> or <code class="codeph">SYSTEM</code> schemas. (This query specifies a timestamp to exclude transactions that were involved in the dictionary extraction.)
                                 </p>
                                 <p>The query returns all the reconstructed SQL statements correctly translated and the insert operations on the <code class="codeph">oe.product_tracking</code> table that occurred because of the trigger execution.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr,(XIDUSN || '.' || XIDSLT || '.' || XIDSQN) as XID, SQL_REDO FROM  
   V$LOGMNR_CONTENTS 
   WHERE SEG_OWNER IS NULL OR SEG_OWNER NOT IN ('SYS', 'SYSTEM') AND
   TIMESTAMP &gt; '10-jan-2012 15:59:53';

USR             XID         SQL_REDO
-----------     --------    -----------------------------------
SYS             1.2.1594    set transaction read write;
SYS             1.2.1594    create table oe.product_tracking (product_id number not null,
                            modified_time date,
                            old_list_price number(8,2),
                            old_warranty_period interval year(2) to month);
SYS             1.2.1594    commit;

SYS             1.18.1602   set transaction read write;
SYS             1.18.1602   create or replace trigger oe.product_tracking_trigger
                            before update on oe.product_information
                            for each row
                            when (new.list_price &lt;&gt; old.list_price or
                                  new.warranty_period &lt;&gt; old.warranty_period)
                            declare
                            begin
                            insert into oe.product_tracking values 
                               (:old.product_id, sysdate,
                                :old.list_price, :old.warranty_period);
                            end;
SYS             1.18.1602   commit;

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 100
                              where
                                "PRODUCT_ID" = 1729 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 80 and
                                ROWID = 'AAAHTKAABAAAY9yAAA';
OE              1.9.1598    insert into "OE"."PRODUCT_TRACKING"
                              values
                                "PRODUCT_ID" = 1729,
                                "MODIFIED_TIME" = TO_DATE('13-jan-2012 16:07:03', 
                                'dd-mon-yyyy hh24:mi:ss'),
                                "OLD_LIST_PRICE" = 80,
                                "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00');

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 92
                              where
                                "PRODUCT_ID" = 2340 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 72 and
                                ROWID = 'AAAHTKAABAAAY9zAAA';

OE              1.9.1598    insert into "OE"."PRODUCT_TRACKING"
                              values
                                "PRODUCT_ID" = 2340,
                                "MODIFIED_TIME" = TO_DATE('13-jan-2012 16:07:07', 
                                'dd-mon-yyyy hh24:mi:ss'),
                                "OLD_LIST_PRICE" = 72,
                                "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00');

OE              1.9.1598     commit;</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4260"></a><a id="SUTIL4261"></a><a id="SUTIL4262"></a><a id="SUTIL4263"></a><a id="SUTIL4264"></a><a id="SUTIL1611"></a><div class="props_rev_3"><a id="GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09" name="GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09"></a><h5 id="SUTIL-GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09" class="sect5"><span class="enumeration_section">22.13.1.6 </span>Example 6: Filtering Output by Time Range
                     </h5>
                     <div>
                        <div class="section">
                           <p>In the previous two examples, rows were filtered by specifying a timestamp-based predicate (timestamp &gt; '10-jan-2012 15:59:53') in the query. However, a more efficient way to filter out redo records based on timestamp values is by specifying the time range in the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure call, as shown in this example. 
                           </p>
                           <ol>
                              <li>
                                 <p>Create a list of redo log files to mine.</p>
                                 <p>Suppose you want to mine redo log files generated since a given time. The following procedure creates a list of redo log files based on a specified time. The subsequent SQL <code class="codeph">EXECUTE</code> statement calls the procedure and specifies the starting time as 2 p.m. on Jan-13-2012.
                                 </p><pre class="oac_no_warn" dir="ltr">--
-- my_add_logfiles
-- Add all archived logs generated after a specified start_time.
--
CREATE OR REPLACE PROCEDURE my_add_logfiles (in_start_time  IN DATE) AS
  CURSOR  c_log IS 
    SELECT NAME FROM V$ARCHIVED_LOG 
      WHERE FIRST_TIME &gt;= in_start_time;

count      pls_integer := 0;
my_option  pls_integer := DBMS_LOGMNR.NEW;

BEGIN
  FOR c_log_rec IN c_log
  LOOP
    DBMS_LOGMNR.ADD_LOGFILE(LOGFILENAME =&gt; c_log_rec.name, 
                            OPTIONS =&gt; my_option);
    my_option := DBMS_LOGMNR.ADDFILE;
    DBMS_OUTPUT.PUT_LINE('Added logfile ' || c_log_rec.name);
  END LOOP;
END;
/

EXECUTE my_add_logfiles(in_start_time =&gt; '13-jan-2012 14:00:00');</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_LOGS</code> to see the list of redo log files.
                                 </p>
                                 <p>This example includes the size of the redo log files in the output.</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name, LOW_TIME start_time, FILESIZE bytes 
    FROM V$LOGMNR_LOGS;

NAME                                START_TIME            BYTES
----------------------------------- --------------------  ----------------
/usr/orcl/arch1_310_482932022.dbf    13-jan-2012 14:02:35  23683584
/usr/orcl/arch1_311_482932022.dbf    13-jan-2012 14:56:35  2564096
/usr/orcl/arch1_312_482932022.dbf    13-jan-2012 15:10:43  23683584
/usr/orcl/arch1_313_482932022.dbf    13-jan-2012 15:17:52  23683584
/usr/orcl/arch1_314_482932022.dbf    13-jan-2012 15:23:10  23683584
/usr/orcl/arch1_315_482932022.dbf    13-jan-2012 15:43:22  23683584
/usr/orcl/arch1_316_482932022.dbf    13-jan-2012 16:03:10  23683584
/usr/orcl/arch1_317_482932022.dbf    13-jan-2012 16:33:43  23683584
/usr/orcl/arch1_318_482932022.dbf    13-jan-2012 17:23:10  23683584</pre></li>
                              <li>
                                 <p>Adjust the list of redo log files.</p>
                                 <p>Suppose you realize that you want to mine just the redo log files generated between 3 p.m. and 4 p.m. </p>
                                 <p>You could use the query predicate (<code class="codeph">timestamp &gt; '13-jan-2012 15:00:00' and timestamp &lt; '13-jan-2012 16:00:00'</code>) to accomplish this. However, the query predicate is evaluated on each row returned by LogMiner, and the internal mining engine does not filter rows based on the query predicate. Thus, although you only wanted to get rows out of redo log files <code class="codeph">arch1_311_482932022.dbf</code> to <code class="codeph">arch1_315_482932022.dbf,</code> your query would result in mining all redo log files registered to the LogMiner session. 
                                 </p>
                                 <p>Furthermore, although you could use the query predicate and manually remove the redo log files that do not fall inside the time range of interest, the simplest solution is to specify the time range of interest in the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure call. 
                                 </p>
                                 <p>Although this does not change the list of redo log files, LogMiner will mine only those redo log files that fall in the time range specified. </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   STARTTIME =&gt; '13-jan-2012 15:00:00', -
   ENDTIME   =&gt; '13-jan-2012 16:00:00', -
   OPTIONS   =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
                DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
                DBMS_LOGMNR.PRINT_PRETTY_SQL);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT TIMESTAMP, (XIDUSN || '.' || XIDSLT || '.' || XIDSQN) AS XID,</pre><pre class="oac_no_warn" dir="ltr"> SQL_REDO FROM V$LOGMNR_CONTENTS WHERE SEG_OWNER = 'OE';

TIMESTAMP              XID          SQL_REDO
---------------------  -----------  --------------------------------
13-jan-2012 15:29:31   1.17.2376    update "OE"."PRODUCT_INFORMATION"
                                      set
                                        "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00')
                                      where
                                        "PRODUCT_ID" = 3399 and
                                        "WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00') and
                                        ROWID = 'AAAHTKAABAAAY9TAAE';
13-jan-2012 15:29:34   1.17.2376      insert into "OE"."PRODUCT_TRACKING"
                                        values
                                        "PRODUCT_ID" = 3399,
                                        "MODIFIED_TIME" = TO_DATE('13-jan-2012 15:29:34', 
                                        'dd-mon-yyyy hh24:mi:ss'),
                                        "OLD_LIST_PRICE" = 815,
                                        "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00');

13-jan-2012 15:52:43   1.15.1756      update "OE"."PRODUCT_INFORMATION"
                                        set
                                          "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00')
                                        where
                                          "PRODUCT_ID" = 1768 and
                                          "WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00') and
                                          ROWID = 'AAAHTKAABAAAY9UAAB';

13-jan-2012 15:52:43   1.15.1756      insert into "OE"."PRODUCT_TRACKING"
                                        values
                                        "PRODUCT_ID" = 1768,
                                        "MODIFIED_TIME" = TO_DATE('13-jan-2012 16:52:43', 
                                        'dd-mon-yyyy hh24:mi:ss'),
                                        "OLD_LIST_PRICE" = 715,
                                        "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00');
</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="Examples specifying redo log files.">Examples of Mining by Explicitly Specifying the Redo Log Files of Interest</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1612"></a><div class="props_rev_3"><a id="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" name="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4"></a><h4 id="SUTIL-GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" class="sect4"><span class="enumeration_section">22.13.2 </span>Examples of Mining Without Specifying the List of Redo Log Files Explicitly
                  </h4>
                  <div>
                     <p>Examples that do not specify redo log files.</p>
                     <p>The previous set of examples explicitly specified the redo log file or files to be mined. However, if you are mining in the same database that generated the redo log files, then you can mine the appropriate list of redo log files by just specifying the time (or SCN) range of interest. To mine a set of redo log files without explicitly specifying them, specify either a time range or an SCN range of interest.</p>
                     <div class="infoboxnote" id="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4__GUID-B96FA62F-213C-4239-9BA8-1D1A627CB71A">
                        <p class="notep1">Note:</p>The <code class="codeph">continuous_mine</code> option for the <code class="codeph">dbms_logmnr.start_logmnr</code> package is desupported in Oracle Database 19c (19.1), and is no longer available.
                     </div>
                     <p>This section contains the following list of examples; these examples are best read in sequential order, because each example builds on the example or examples that precede it:</p>
                     <p>The SQL output formatting may be different on your display than that shown in these examples. </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F35C6876-5AE0-4229-891D-47B1C3759A11">Example 1: Mining Redo Log Files in a Given Time Range</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A">Example 2: Mining the Redo Log Files in a Given SCN Range</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B">Example 3: Using Continuous Mining to Include Future Values in a Query</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">Examples Using LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4265"></a><a id="SUTIL4266"></a><a id="SUTIL4267"></a><a id="SUTIL4268"></a><a id="SUTIL4269"></a><a id="SUTIL4270"></a><a id="SUTIL1613"></a><div class="props_rev_3"><a id="GUID-F35C6876-5AE0-4229-891D-47B1C3759A11" name="GUID-F35C6876-5AE0-4229-891D-47B1C3759A11"></a><h5 id="SUTIL-GUID-F35C6876-5AE0-4229-891D-47B1C3759A11" class="sect5"><span class="enumeration_section">22.13.2.1 </span>Example 1: Mining Redo Log Files in a Given Time Range
                     </h5>
                     <div>
                        <div class="section">
                           <p>This example is similar to Example 4: Using the LogMiner Dictionary in the Redo Log Files, except the list of redo log files are not specified explicitly. This example assumes that you want to use the data dictionary extracted to the redo log files.</p>
                           <ol>
                              <li>
                                 <p>Determine the timestamp of the redo log file that contains the start of the data dictionary.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME, FIRST_TIME FROM V$ARCHIVED_LOG</pre><pre class="oac_no_warn" dir="ltr">    WHERE SEQUENCE# = (SELECT MAX(SEQUENCE#) FROM V$ARCHIVED_LOG 
    WHERE DICTIONARY_BEGIN = 'YES');

NAME                                          FIRST_TIME
--------------------------------------------  --------------------
/usr/oracle/data/db1arch_1_207_482701534.dbf  10-jan-2012 12:01:34
</pre></li>
                              <li>
                                 <p>Display all the redo log files that have been generated so far.</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name FROM V$LOGMNR_LOGS
   WHERE LOW_TIME &gt; '10-jan-2012 12:01:34';

NAME
----------------------------------------------
/usr/oracle/data/db1arch_1_207_482701534.dbf
/usr/oracle/data/db1arch_1_208_482701534.dbf
/usr/oracle/data/db1arch_1_209_482701534.dbf
/usr/oracle/data/db1arch_1_210_482701534.dbf</pre></li>
                              <li>
                                 <p>Start LogMiner by specifying the dictionary to use and the <code class="codeph">COMMITTED_DATA_ONLY</code> and <code class="codeph">PRINT_PRETTY_SQL</code> options.
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-
   STARTTIME =&gt; '10-jan-2012 12:01:34', -
     ENDTIME =&gt; SYSDATE, -
     OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS + -
                DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
                DBMS_LOGMNR.PRINT_PRETTY_SQL + -
                    );</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_LOGS</code> view.
                                 </p>
                                 <p>This step shows that the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure includes all of the redo log files that have been generated so far, as expected. (Compare the output in this step to the output in Step 2.)
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name FROM V$LOGMNR_LOGS;

NAME
------------------------------------------------------
/usr/oracle/data/db1arch_1_207_482701534.dbf
/usr/oracle/data/db1arch_1_208_482701534.dbf
/usr/oracle/data/db1arch_1_209_482701534.dbf
/usr/oracle/data/db1arch_1_210_482701534.dbf</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>To reduce the number of rows returned by the query, exclude all DML statements done in the <code class="codeph">SYS</code> or <code class="codeph">SYSTEM</code> schema. (This query specifies a timestamp to exclude transactions that were involved in the dictionary extraction.)
                                 </p>
                                 <p>Note that all reconstructed SQL statements returned by the query are correctly translated.</p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr,(XIDUSN || '.' || XIDSLT || '.' || XIDSQN) as XID, 
   SQL_REDO FROM V$LOGMNR_CONTENTS 
   WHERE SEG_OWNER IS NULL OR SEG_OWNER NOT IN ('SYS', 'SYSTEM') AND
   TIMESTAMP &gt; '10-jan-2012 15:59:53';

USR             XID         SQL_REDO
-----------     --------    -----------------------------------
SYS             1.2.1594    set transaction read write;
SYS             1.2.1594    create table oe.product_tracking (product_id number not null,
                            modified_time date,
                            old_list_price number(8,2),
                            old_warranty_period interval year(2) to month);
SYS             1.2.1594    commit;

SYS             1.18.1602   set transaction read write;
SYS             1.18.1602   create or replace trigger oe.product_tracking_trigger
                            before update on oe.product_information
                            for each row
                            when (new.list_price &lt;&gt; old.list_price or
                                  new.warranty_period &lt;&gt; old.warranty_period)
                            declare
                            begin
                            insert into oe.product_tracking values 
                               (:old.product_id, sysdate,
                                :old.list_price, :old.warranty_period);
                            end;
SYS             1.18.1602   commit;

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 100
                              where
                                "PRODUCT_ID" = 1729 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 80 and
                                ROWID = 'AAAHTKAABAAAY9yAAA';
OE              1.9.1598    insert into "OE"."PRODUCT_TRACKING"
                              values
                                "PRODUCT_ID" = 1729,
                                "MODIFIED_TIME" = TO_DATE('13-jan-2012 16:07:03', 
                                'dd-mon-yyyy hh24:mi:ss'),
                                "OLD_LIST_PRICE" = 80,
                                "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00');

OE              1.9.1598    update "OE"."PRODUCT_INFORMATION"
                              set
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+08-00'),
                                "LIST_PRICE" = 92
                              where
                                "PRODUCT_ID" = 2340 and
                                "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00') and
                                "LIST_PRICE" = 72 and
                                ROWID = 'AAAHTKAABAAAY9zAAA';

OE              1.9.1598    insert into "OE"."PRODUCT_TRACKING"
                              values
                                "PRODUCT_ID" = 2340,
                                "MODIFIED_TIME" = TO_DATE('13-jan-2012 16:07:07', 
                                'dd-mon-yyyy hh24:mi:ss'),
                                "OLD_LIST_PRICE" = 72,
                                "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00');

OE              1.9.1598     commit;</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="Examples that do not specify redo log files.">Examples of Mining Without Specifying the List of Redo Log Files Explicitly</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4271"></a><a id="SUTIL4272"></a><a id="SUTIL4273"></a><a id="SUTIL4274"></a><a id="SUTIL4275"></a><a id="SUTIL1614"></a><div class="props_rev_3"><a id="GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A" name="GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A"></a><h5 id="SUTIL-GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A" class="sect5"><span class="enumeration_section">22.13.2.2 </span>Example 2: Mining the Redo Log Files in a Given SCN Range
                     </h5>
                     <div>
                        <div class="section">
                           <p>This example shows how to specify an SCN range of interest and mine the redo log files that satisfy that range. You can use LogMiner to see all committed DML statements whose effects have not yet been made permanent in the data files.</p>
                           <p>Note that in this example (unlike the other examples) it is not assumed that you have set the <code class="codeph">NLS_DATE_FORMAT</code> parameter.
                           </p>
                           <ol>
                              <li>
                                 <p>Determine the SCN of the last checkpoint taken.</p><pre class="oac_no_warn" dir="ltr">SELECT CHECKPOINT_CHANGE#, CURRENT_SCN FROM V$DATABASE;</pre><pre class="oac_no_warn" dir="ltr">
CHECKPOINT_CHANGE#  CURRENT_SCN
------------------  ---------------
          56453576         56454208</pre></li>
                              <li>
                                 <p>Start LogMiner.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-</pre><pre class="oac_no_warn" dir="ltr">   STARTSCN =&gt; 56453576, -
   ENDSCN   =&gt; 56454208, -
   OPTIONS  =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + -
               DBMS_LOGMNR.COMMITTED_DATA_ONLY + -
               DBMS_LOGMNR.PRINT_PRETTY_SQL + -
               );
</pre></li>
                              <li>
                                 <p>Display the list of archived redo log files added by LogMiner.</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name, LOW_SCN, NEXT_SCN FROM V$LOGMNR_LOGS;</pre><pre class="oac_no_warn" dir="ltr">
NAME                                           LOW_SCN   NEXT_SCN
--------------------------------------------   --------  --------
/usr/oracle/data/db1arch_1_215_482701534.dbf   56316771  56453579
</pre><p>Note that the redo log file that LogMiner added does not contain the whole SCN range. LogMiner adds the rest of the SCN range contained in the online redo log files automatically, as needed during the query execution. Use the following query to determine whether the redo log file added is the latest archived redo log file produced.</p><pre class="oac_no_warn" dir="ltr">SELECT NAME FROM V$ARCHIVED_LOG 
   WHERE SEQUENCE# = (SELECT MAX(SEQUENCE#) FROM V$ARCHIVED_LOG);

NAME
-------------------------------------------- 
/usr/oracle/data/db1arch_1_215_482701534.dbf </pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view for changes made to the user tables.
                                 </p>
                                 <p>The following query does not return the <code class="codeph">SET TRANSACTION READ WRITE</code> and <code class="codeph">COMMIT</code> statements associated with transaction 1.6.1911 because these statements do not have a segment owner (<code class="codeph">SEG_OWNER</code>) associated with them.
                                 </p>
                                 <p>Note that the default <code class="codeph">NLS_DATE_FORMAT</code>, 'DD-MON-RR', is used to display the column <code class="codeph">MODIFIED_TIME</code> of type <code class="codeph">DATE</code>.
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT SCN, (XIDUSN || '.' || XIDSLT || '.' ||  XIDSQN) as XID, SQL_REDO 
    FROM V$LOGMNR_CONTENTS
    WHERE SEG_OWNER NOT IN ('SYS', 'SYSTEM');


SCN        XID        SQL_REDO
---------- ---------- -------------
56454198   1.6.1911   update "OE"."PRODUCT_INFORMATION"
                        set
                          "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00')
                        where
                          "PRODUCT_ID" = 2430 and
                          "WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00') and
                          ROWID = 'AAAHTKAABAAAY9AAAC';

56454199   1.6.1911   insert into "OE"."PRODUCT_TRACKING"
                        values
                          "PRODUCT_ID" = 2430,
                          "MODIFIED_TIME" = TO_DATE('17-JAN-03', 'DD-MON-RR'),
                          "OLD_LIST_PRICE" = 175,
                          "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00');

56454204   1.6.1911    update "OE"."PRODUCT_INFORMATION"
                         set
                           "WARRANTY_PERIOD" = TO_YMINTERVAL('+05-00')
                         where
                           "PRODUCT_ID" = 2302 and
                           "WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00') and
                           ROWID = 'AAAHTKAABAAAY9QAAA';
56454206   1.6.1911    insert into "OE"."PRODUCT_TRACKING"
                         values
                           "PRODUCT_ID" = 2302,
                           "MODIFIED_TIME" = TO_DATE('17-JAN-03', 'DD-MON-RR'),
                           "OLD_LIST_PRICE" = 150,
                           "OLD_WARRANTY_PERIOD" = TO_YMINTERVAL('+02-00');</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="Examples that do not specify redo log files.">Examples of Mining Without Specifying the List of Redo Log Files Explicitly</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4276"></a><a id="SUTIL4277"></a><a id="SUTIL4278"></a><a id="SUTIL1615"></a><div class="props_rev_3"><a id="GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B" name="GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B"></a><h5 id="SUTIL-GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B" class="sect5"><span class="enumeration_section">22.13.2.3 </span>Example 3: Using Continuous Mining to Include Future Values in a Query 
                     </h5>
                     <div>
                        <div class="section">
                           <p>To specify that a query not finishes until some future time occurs or SCN is reached, set either the <code class="codeph">ENDTIME</code> or <code class="codeph">ENDSCN</code> option in your call to the <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> procedure to a time in the future or to an SCN value that has not yet been reached. 
                           </p>
                           <p>This examples assumes that you want to monitor all changes made to the table <code class="codeph">hr.employees</code> from now until 5 hours from now, and that you are using the dictionary in the online catalog.
                           </p>
                           <ol>
                              <li>
                                 <p>Start LogMiner.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR(-</pre><pre class="oac_no_warn" dir="ltr">   STARTTIME =&gt; SYSDATE, -
   ENDTIME   =&gt; SYSDATE + 5/24, -
   OPTIONS   =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG);</pre></li>
                              <li>
                                 <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                                 </p>
                                 <p>This select operation will not complete until it encounters the first redo log file record that is generated after the time range of interest (5 hours from now). You can end the select operation prematurely by pressing Ctrl+C.</p>
                                 <p>This example specifies the <code class="codeph">SET</code> <code class="codeph">ARRAYSIZE</code> statement so that rows are displayed as they are entered in the redo log file. If you do not specify the <code class="codeph">SET ARRAYSIZE</code> statement, then rows are not returned until the SQL internal buffer is full. 
                                 </p><pre class="oac_no_warn" dir="ltr">SET ARRAYSIZE 1;
SELECT USERNAME AS usr, SQL_REDO FROM V$LOGMNR_CONTENTS
   WHERE  SEG_OWNER = 'HR' AND TABLE_NAME = 'EMPLOYEES';</pre></li>
                              <li>
                                 <p>End the LogMiner session.</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR();</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="Examples that do not specify redo log files.">Examples of Mining Without Specifying the List of Redo Log Files Explicitly</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1616"></a><div class="props_rev_3"><a id="GUID-143798E2-B0E0-4E9D-A70C-08593A117027" name="GUID-143798E2-B0E0-4E9D-A70C-08593A117027"></a><h4 id="SUTIL-GUID-143798E2-B0E0-4E9D-A70C-08593A117027" class="sect4"><span class="enumeration_section">22.13.3 </span>Example Scenarios
                  </h4>
                  <div>
                     <p>Examples of how to use LogMiner for typical scenarios.</p>
                     <p>These examples include:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4">Scenario 1: Using LogMiner to Track Changes Made by a Specific User</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3">Scenario 2: Using LogMiner to Calculate Table Access Statistics</a><br>This scenario describes how to use LogMiner to calculate table access statistics.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">Examples Using LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1617"></a><div class="props_rev_3"><a id="GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4" name="GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4"></a><h5 id="SUTIL-GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4" class="sect5"><span class="enumeration_section">22.13.3.1 </span>Scenario 1: Using LogMiner to Track Changes Made by a Specific User
                     </h5>
                     <div>
                        <p>This example shows how to see all changes made to the database in a specific time range by a single user: <code class="codeph">joedevo</code>. Connect to the database and then take the following steps:
                        </p>
                        <ol>
                           <li>
                              <p>Create the LogMiner dictionary file.</p>
                              <p>To use LogMiner to analyze <code class="codeph">joedevo</code>'s data, you must either create a LogMiner dictionary file before any table definition changes are made to tables that <code class="codeph">joedevo</code> uses or use the online catalog at LogMiner startup. See <a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" title="Extracting a LogMiner dictionary.">Extract a LogMiner Dictionary</a> for examples of creating LogMiner dictionaries. This example uses a LogMiner dictionary that has been extracted to the redo log files.
                              </p>
                           </li>
                           <li>
                              <p>Add redo log files.</p>
                              <p>Assume that <code class="codeph">joedevo</code> has made some changes to the database. You can now specify the names of the redo log files that you want to analyze, as follows:
                              </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; 'log1orc1.ora', -
   OPTIONS =&gt; DBMS_LOGMNR.NEW);
</pre><p>If desired, add additional redo log files, as follows:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE( -
   LOGFILENAME =&gt; 'log2orc1.ora', -
   OPTIONS =&gt; DBMS_LOGMNR.ADDFILE);
</pre></li>
                           <li>
                              <p>Start LogMiner and limit the search to the specified time range:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   DICTFILENAME =&gt; 'orcldict.ora', -
   STARTTIME =&gt; TO_DATE('01-Jan-1998 08:30:00','DD-MON-YYYY HH:MI:SS'), -
   ENDTIME =&gt; TO_DATE('01-Jan-1998 08:45:00', 'DD-MON-YYYY HH:MI:SS'));
</pre></li>
                           <li>
                              <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view.
                              </p>
                              <p>At this point, the <code class="codeph">V$LOGMNR_CONTENTS</code> view is available for queries. You decide to find all of the changes made by user <code class="codeph">joedevo</code> to the <code class="codeph">salary</code> table. Execute the following <code class="codeph">SELECT</code> statement:
                              </p><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO, SQL_UNDO FROM V$LOGMNR_CONTENTS 
   WHERE USERNAME = 'joedevo' AND SEG_NAME = 'salary';
</pre><p>For both the <code class="codeph">SQL_REDO</code> and <code class="codeph">SQL_UNDO</code> columns, two rows are returned (the format of the data display will be different on your screen). You discover that <code class="codeph">joedevo</code> requested two operations: he deleted his old salary and then inserted a new, higher salary. You now have the data necessary to undo this operation. 
                              </p><pre class="oac_no_warn" dir="ltr">SQL_REDO                              SQL_UNDO
--------                              --------
delete from SALARY                    insert into SALARY(NAME, EMPNO, SAL)
where EMPNO = 12345                    values ('JOEDEVO', 12345, 500)
and NAME='JOEDEVO'
and SAL=500;

insert into SALARY(NAME, EMPNO, SAL)  delete from SALARY
values('JOEDEVO',12345, 2500)         where EMPNO = 12345
                                      and NAME = 'JOEDEVO'
2 rows selected                       and SAL = 2500;
</pre></li>
                           <li>
                              <p>End the LogMiner session.</p>
                              <p>Use the <code class="codeph">DBMS_LOGMNR.END_LOGMNR</code> procedure to finish the LogMiner session properly:
                              </p><pre class="oac_no_warn" dir="ltr">DBMS_LOGMNR.END_LOGMNR( );</pre></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="Examples of how to use LogMiner for typical scenarios.">Example Scenarios</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1618"></a><div class="props_rev_3"><a id="GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" name="GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3"></a><h5 id="SUTIL-GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" class="sect5"><span class="enumeration_section">22.13.3.2 </span>Scenario 2: Using LogMiner to Calculate Table Access Statistics
                     </h5>
                     <div>
                        <p>This scenario describes how to use LogMiner to calculate table access statistics.</p>
                        <p>In this example, assume you manage a direct marketing database and want to determine how productive the customer contacts have been in generating revenue for a 2-week period in January. Assume that you have already created the LogMiner dictionary and added the redo log files that you want to search (as demonstrated in the previous example). Take the following steps:</p>
                        <ol>
                           <li>
                              <p>Start LogMiner and specify a range of times:</p><pre class="pre codeblock"><code>EXECUTE DBMS_LOGMNR.START_LOGMNR( -
   STARTTIME =&gt; TO_DATE('07-Jan-2012 08:30:00','DD-MON-YYYY HH:MI:SS'), -
   ENDTIME =&gt; TO_DATE('21-Jan-2012 08:45:00','DD-MON-YYYY HH:MI:SS'), -
   DICTFILENAME =&gt; '/usr/local/dict.ora');
</code></pre></li>
                           <li>
                              <p>Query the <code class="codeph">V$LOGMNR_CONTENTS</code> view to determine which tables were modified in the time range you specified, as shown in the following example. (This query filters out system tables that traditionally have a <code class="codeph">$</code> in their name.)
                              </p><pre class="pre codeblock"><code>SELECT SEG_OWNER, SEG_NAME, COUNT(*) AS Hits FROM
   V$LOGMNR_CONTENTS WHERE SEG_NAME NOT LIKE '%$' GROUP BY
   SEG_OWNER, SEG_NAME ORDER BY Hits DESC;
</code></pre></li>
                           <li>
                              <p>The following data is displayed. (The format of your display may be different.)</p><pre class="pre codeblock"><code>SEG_OWNER          SEG_NAME          Hits
---------          --------          ----
CUST               ACCOUNT            384
UNIV               EXECDONOR          325
UNIV               DONOR              234
UNIV               MEGADONOR           32
HR                 EMPLOYEES           12
SYS                DONOR               12
</code></pre><p>The values in the <code class="codeph">Hits</code> column show the number of times that the named table had an insert, delete, or update operation performed on it during the 2-week period specified in the query. In this example, the <code class="codeph">cust.account</code> table was modified the most during the specified 2-week period, and the <code class="codeph">hr.employees</code> and <code class="codeph">sys.donor</code> tables were modified the least during the same time period.
                              </p>
                           </li>
                           <li>
                              <p>End the LogMiner session.</p>
                              <p>Use the <code class="codeph">DBMS_LOGMNR.END_LOGMNR</code> procedure to finish the LogMiner session properly:
                              </p><code class="codeph">DBMS_LOGMNR.END_LOGMNR( );</code></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="Examples of how to use LogMiner for typical scenarios.">Example Scenarios</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="SUTIL1619"></a><div class="props_rev_3"><a id="GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" name="GUID-D11CC6EF-D94C-426F-B244-96CE2403924A"></a><h3 id="SUTIL-GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" class="sect3"><span class="enumeration_section">22.14 </span>Supported Data Types, Storage Attributes, and Database and Redo Log File Versions
               </h3>
               <div>
                  <p>Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3">Supported Data Types and Table Storage Attributes</a><br>Describes supported data types and table storage attributes.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D">Unsupported Data Types and Table Storage Attributes</a><br>Describes unsupported data types and table storage attributes.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-0BC1D343-0577-4DC4-9DBA-083194560D13">Supported Databases and Redo Log File Versions</a><br>Describes supported database releases and redo log file versions.
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5">SecureFiles LOB Considerations</a><br>SecureFiles LOBs are supported when database compatibility is set to 11.2 or later. 
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface.">Using LogMiner to Analyze Redo Log Files</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL4317"></a><a id="SUTIL4318"></a><a id="SUTIL102"></a><div class="props_rev_3"><a id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" name="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3"></a><h4 id="SUTIL-GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" class="sect4"><span class="enumeration_section">22.14.1 </span>Supported Data Types and Table Storage Attributes
                  </h4>
                  <div>
                     <p>Describes supported data types and table storage attributes.</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-16CCD6C9-725D-40AA-959A-7E87785C70DD">
                           <p class="notep1">Note:</p>
                           <p>As of Oracle Database 12<span class="italic">c</span> Release 1 (12.1), the maximum size of the <code class="codeph">VARCHAR2</code>, <code class="codeph">NVARCHAR2</code>, and <code class="codeph">RAW</code> data types has been increased to 32 KB when the <code class="codeph">COMPATIBLE</code> initialization parameter is set to 12.0 or higher and the <code class="codeph">MAX_STRING_SIZE</code> initialization parameter is set to <code class="codeph">EXTENDED</code>. 
                           </p>
                           <p>LogMiner treats 32 KB columns as LOBs for the purposes of supplemental logging. </p>
                           <p>A 32 KB column cannot be part of an ALWAYS supplemental logging group. </p>
                        </div>
                        <p>LogMiner supports the following data types and table storage attributes. As described in <a href="oracle-logminer-utility.html#GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" title="LogMiner support for certain data types and table storage attributes has database compatibility requirements.">Compatibility Requirements</a>, some data types are supported only in certain releases.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-272EC7F9-C6E3-4193-8F47-1F1E0DA7A88A">Data Types</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">BINARY_DOUBLE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BINARY_FLOAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code> and <code class="codeph">NCLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DATE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INTERVAL YEAR TO MONTH</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INTERVAL DAY TO SECOND</code></p>
                           </li>
                           <li>
                              <p>LOBs stored as SecureFiles (requires that the database be run at a compatibility of 11.2 or higher.</p>
                           </li>
                           <li>
                              <p><code class="codeph">LONG</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">LONG RAW</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NCHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NUMBER</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NVARCHAR2</code></p>
                           </li>
                           <li>
                              <p>Objects stored as <code class="codeph">VARRAY</code>s
                              </p>
                           </li>
                           <li>
                              <p>Objects (Simple and Nested ADTs without Collections)</p>
                              <p>Object support (including Oracle-supplied types such as <code class="codeph">SDO_GEOMETRY</code>, <code class="codeph">ORDIMAGE</code>, and so on) requires that the database be running Oracle Database 12<span class="italic">c</span> Release 1 (12.1) or higher with a redo compatibility setting of 12.0.0.0 or higher. The contents of the <code class="codeph">SQL_REDO</code> column for the XML data-related operations is never valid SQL or PL/SQL.
                              </p>
                           </li>
                           <li>
                              <p>Oracle Text</p>
                           </li>
                           <li>
                              <p><code class="codeph">RAW</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH  TIMEZONE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH LOCAL TIMEZONE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">VARCHAR</code> and <code class="codeph">VARCHAR2</code></p>
                           </li>
                           <li>
                              <p>XDB</p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLType</code> data for all storage models, assuming the following primary database compatibility requirements:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">XMLType</code> stored in <code class="codeph">CLOB</code> format requires that the database be run at a compatibility setting of 11.0 or higher (<code class="codeph">XMLType</code> stored as <code class="codeph">CLOB</code> is deprecated as of Oracle Database 12<span class="italic">c</span> Release 1 (12.1).)
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">XMLType</code> stored in object-relational format or as binary XML requires that the database be running Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.3) or higher with a redo compatibility setting of 11.2.0.3 or higher. The contents of the <code class="codeph">SQL_REDO</code> column for the XML data-related operations is never valid SQL or PL/SQL.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-1D21E466-34A2-4081-A48E-0597813FE47F">Table Storage Types</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Cluster tables (including index clusters and heap clusters).</p>
                           </li>
                           <li>
                              <p>Index-organized tables (IOTs) (partitioned and nonpartitioned, including overflow segments).</p>
                           </li>
                           <li>
                              <p>Heap-organized tables (partitioned and nonpartitioned).</p>
                           </li>
                           <li>
                              <p>Advanced row compression and basic table compression. Both of these options require a database compatibility setting of 11.1.0 or higher.</p>
                           </li>
                           <li>
                              <p>Tables containing LOB columns stored as SecureFiles, when database compatibility is set to 11.2 or higher.</p>
                           </li>
                           <li>
                              <p>Tables using Hybrid Columnar Compression, when database compatibility is set to 11.2.0.2 or higher.</p>
                              <div class="infoboxnotealso" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-19469851-AA17-4845-881A-5C5926328D34">
                                 <p class="notep1">See Also:</p>
                                 <p></p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle Database Concepts</span></a> for more information about Hybrid Columnar Compression
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F">Compatibility Requirements</a><br>LogMiner support for certain data types and table storage attributes has database compatibility requirements.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.">Supported Data Types, Storage Attributes, and Database and Redo Log File Versions</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4319"></a><div class="props_rev_3"><a id="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" name="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F"></a><h5 id="SUTIL-GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" class="sect5"><span class="enumeration_section">22.14.1.1 </span>Compatibility Requirements
                     </h5>
                     <div>
                        <p>LogMiner support for certain data types and table storage attributes has database compatibility requirements.</p>
                        <div class="section">
                           <p>Specifically:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Multibyte <code class="codeph">CLOB</code> support requires the database to run at a compatibility of 10.1 or higher. 
                                 </p>
                              </li>
                              <li>
                                 <p>IOT support without <code class="codeph">LOB</code>s and Overflows requires the database to run at a compatibility of 10.1 or higher.
                                 </p>
                              </li>
                              <li>
                                 <p>IOT support with <code class="codeph">LOB</code> and Overflow requires the database to run at a compatibility of 10.2 or higher.
                                 </p>
                              </li>
                              <li>
                                 <p>TDE and TSE support require the database to run at a compatibility of 11.1 or higher.</p>
                              </li>
                              <li>
                                 <p>Basic compression and advanced row compression require the database to run at a compatibility of 11.1 or higher.</p>
                              </li>
                              <li>
                                 <p>Hybrid Columnar Compression support is dependent on the underlying storage system and requires the database to run at a compatibility of 11.2 or higher.</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F__GUID-D0D87557-1C68-4A33-9865-3D4899F25390">
                           <p class="notep1">See Also:</p>
                           <p></p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle Database Concepts</span></a> for more information about Hybrid Columnar Compression
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" title="Describes supported data types and table storage attributes.">Supported Data Types and Table Storage Attributes</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1620"></a><div class="props_rev_3"><a id="GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D" name="GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D"></a><h4 id="SUTIL-GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D" class="sect4"><span class="enumeration_section">22.14.2 </span>Unsupported Data Types and Table Storage Attributes
                  </h4>
                  <div>
                     <p>Describes unsupported data types and table storage attributes.</p>
                     <div class="section">
                        <p>LogMiner does not support the following data types and table storage attributes. If a table contains columns having any of these unsupported data types, then the entire table is ignored by LogMiner.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">BFILE</code></p>
                           </li>
                           <li>
                              <p>Nested tables</p>
                           </li>
                           <li>
                              <p>Objects with nested tables</p>
                           </li>
                           <li>
                              <p>Tables with identity columns</p>
                           </li>
                           <li>
                              <p>Temporal validity columns</p>
                           </li>
                           <li>
                              <p>PKREF columns</p>
                           </li>
                           <li>
                              <p>PKOID columns</p>
                           </li>
                           <li>
                              <p>Nested table attributes and stand-alone nested table columns</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.">Supported Data Types, Storage Attributes, and Database and Redo Log File Versions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1621"></a><div class="props_rev_3"><a id="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" name="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13"></a><h4 id="SUTIL-GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" class="sect4"><span class="enumeration_section">22.14.3 </span>Supported Databases and Redo Log File Versions
                  </h4>
                  <div>
                     <p>Describes supported database releases and redo log file versions.</p>
                     <p>LogMiner runs only on databases of release 8.1 or later, but you can use it to analyze redo log files from release 8.0 databases. However, the information that LogMiner is able to retrieve from a redo log file depends on the version of the log, not the release of the database in use. For example, redo log files for Oracle9<span class="italic">i</span> can be augmented to capture additional information when supplemental logging is enabled. This allows LogMiner functionality to be used to its fullest advantage. Redo log files created with older releases of Oracle will not have that additional data and may therefore have limitations on the operations and data types supported by LogMiner.
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13__GUID-0085D85C-B355-409F-88A8-EFC74079C6EB">
                        <p class="notep1">See Also:</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">Steps in a Typical LogMiner Session</a> and <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">Supplemental Logging</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.">Supported Data Types, Storage Attributes, and Database and Redo Log File Versions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3764"></a><div class="props_rev_3"><a id="GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5" name="GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5"></a><h4 id="SUTIL-GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5" class="sect4"><span class="enumeration_section">22.14.4 </span>SecureFiles LOB Considerations
                  </h4>
                  <div>
                     <p>SecureFiles LOBs are supported when database compatibility is set to 11.2 or later. </p>
                     <p>Only <code class="codeph">SQL_REDO</code> columns can be filled in for SecureFiles LOB columns; <code class="codeph">SQL_UNDO</code> columns are not filled in.
                     </p>
                     <p>Transparent Data Encryption (TDE) and data compression can be enabled on SecureFiles LOB columns at the primary database.</p>
                     <p>Deduplication of SecureFiles LOB columns is fully supported. Fragment operations are not supported.</p>
                     <p>If LogMiner encounters redo generated by unsupported operations, then it generates rows with the <code class="codeph">OPERATION</code> column set to <code class="codeph">UNSUPPORTED</code>. No SQL_REDO or SQL_UNDO will be generated for these redo records.
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="Describes information about data type and storage attribute support and the releases of the database and redo log files that are supported.">Supported Data Types, Storage Attributes, and Database and Redo Log File Versions</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>