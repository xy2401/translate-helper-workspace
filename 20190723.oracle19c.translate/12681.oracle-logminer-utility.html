<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface."></meta>
      <meta name="description" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface."></meta>
      <title>使用LogMiner分析重做日志文件</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Utilities "></meta>
      <meta property="og:description" content="Oracle LogMiner, which is part of Oracle Database, enables you to query online and archived redo log files through a SQL interface."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Utilities"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96081-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-dbnewid-utility.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-oracle-dbms_metadata-api.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities"></meta>
    <meta name="dcterms.isVersionOf" content="SUTIL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-dbnewid-utility.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-oracle-dbms_metadata-api.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="other-oracle-utilities.html" property="item" typeof="WebPage"><span property="name">其他公用事业</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用LogMiner分析重做日志文件</li>
            </ol>
            <a id="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" name="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5"></a><a id="SUTIL019"></a>
            
            <h2 id="SUTIL-GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" class="sect2"><span class="enumeration_chapter">22</span>使用LogMiner分析重做日志文件</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。</p>
               <p>重做日志文件包含有关数据库活动历史记录的信息。</p>
               <p>请参阅以下主题：</p>
               <p>您可以从命令行使用LogMiner，也可以通过Oracle LogMiner Viewer图形用户界面访问它。Oracle LogMiner Viewer是Oracle Enterprise Manager的一部分。有关Oracle LogMiner Viewer的更多信息，请参见Oracle Enterprise Manager联机帮助。</p>
               <div class="infoboxnote" id="GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5__GUID-2E04A2C1-7634-4586-8467-6D0D5DCCD034">
                  <p class="notep1">注意：</p>Oracle Database 19c（19.1）中不支持<code class="codeph">dbms_logmnr.start_logmnr</code>软件包的<code class="codeph">continuous_mine</code>选项，该选项不再可用。
               </div>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D">LogMiner的好处</a><br>对用户数据或数据库字典所做的所有更改都记录在Oracle重做日志文件中，以便可以执行数据库恢复操作。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D">LogMiner简介</a><br>这些主题简要介绍了LogMiner，包括以下主题。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093">在CDB中使用LogMiner</a><br>您可以在多租户容器数据库（CDB）中使用LogMiner。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5">LogMiner字典文件和重做日志文件</a><br>在开始使用LogMiner之前，了解LogMiner如何使用LogMiner字典文件（或多个文件）和重做日志文件非常重要。这将帮助您获得准确的结果并规划系统资源的使用。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5">启动LogMiner</a><br>调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程以启动LogMiner。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D">查询重做感兴趣数据的V $ LOGMNR_CONTENTS</a><br>您可以通过查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图来访问感兴趣的重做数据。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24">过滤和格式化数据返回到V $ LOGMNR_CONTENTS</a><br>LogMiner可能会处理大量信息。您可以限制返回到<code class="codeph">V$LOGMNR_CONTENTS</code>视图的信息以及返回的速度。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39">重新应用返回到V $ LOGMNR_CONTENTS的DDL语句</a><br>您发出的某些DDL语句会导致Oracle在内部执行一个或多个其他DDL语句。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-4959F073-BE00-4170-BFDC-4722D5770639">多次调用DBMS_LOGMNR.START_LOGMNR</a><br>您已成功调用即使在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>从所选<code class="codeph">V$LOGMNR_CONTENTS</code>视图，您可以拨打<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>再次没有结束当前的LogMiner会话，并且指定不同的选择和时间或SCN范围。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E">补充记录</a><br>描述补充日志记录。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39">在视图中访问LogMiner操作信息</a><br>LogMiner操作信息（与重做数据相对）包含在视图中。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760">典型LogMiner会话中的步骤</a><br>描述典型LogMiner会话中的步骤。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98">示例使用LogMiner</a><br>使用LogMiner的示例。
                  </li>
                  <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A">支持的数据类型，存储属性以及数据库和重做日志文件版本</a><br>描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="other-oracle-utilities.html#GUID-FCEA49BD-D3AF-4337-88F1-3A23545F35A6">其他实用程序</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1552"></a><div class="props_rev_3"><a id="GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D" name="GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D"></a><h3 id="SUTIL-GUID-7B22CA96-37E8-464A-A103-E8F8DA7BB75D" class="sect3"><span class="enumeration_section">22.1</span> LogMiner的好处</h3>
               <div>
                  <p>对用户数据或数据库字典所做的所有更改都记录在Oracle重做日志文件中，以便可以执行数据库恢复操作。</p>
                  <p>由于LogMiner为重做日志文件提供了定义明确，易于使用且全面的关系界面，因此它可以用作强大的数据审计工具，也可以用作复杂的数据分析工具。以下列表描述了LogMiner的一些关键功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>精确定位数据库的逻辑损坏（例如在应用程序级别发生的错误）可能已经开始。这些可能包括错误，例如由于<code class="codeph">WHERE</code>子句中的值不正确而删除了错误的行，使用不正确的值更新了行，删除了错误的索引等错误。例如，用户应用程序可能会错误地更新数据库，以便为所有员工提供100％的工资增长而不是10％的增加，或者数据库管理员（DBA）可能会意外删除关键系统表。确切地知道何时发生错误以便您知道何时启动基于时间或基于更改的恢复非常重要。这使您可以将数据库还原到损坏之前的状态。有关如何使用LogMiner完成此操作的详细信息，请参阅<a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner允许您根据列值进行查询。">基于列值查询V $ LOGMNR_CONTENTS</a> 。
                        </p>
                     </li>
                     <li>
                        <p>确定在事务级别执行细粒度恢复时必须采取的操作。如果您完全理解并考虑了现有依赖项，则可以执行特定于表的撤消操作以将表返回到其原始状态。这是通过应用LogMiner按照与它们最初发布的相反顺序提供的特定于表的重构SQL语句来实现的。有关示例，请参阅<a href="oracle-logminer-utility.html#GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4">方案1：使用LogMiner跟踪特定用户所做的更改</a> 。
                        </p>
                        <p>通常，您必须将表还原到其先前的状态，然后应用存档的重做日志文件以将其向前滚动。</p>
                     </li>
                     <li>
                        <p>通过趋势分析进行性能调整和容量规划。您可以确定哪些表获得最多更新和插入。该信息提供了磁盘访问统计信息的历史视角，可用于调整目的。有关示例，请参阅<a href="oracle-logminer-utility.html#GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" title="此方案描述了如何使用LogMiner计算表访问统计信息。">方案2：使用LogMiner计算表访问统计信息</a> 。
                        </p>
                     </li>
                     <li>
                        <p>执行postauditing。LogMiner可用于跟踪在数据库上执行的任何数据操作语言（DML）和数据定义语言（DDL）语句，它们的执行顺序以及执行它们的人员。（但是，要将LogMiner用于此目的，您需要知道事件发生的时间，以便您可以指定适当的日志进行分析;否则您可能需要挖掘大量的重做日志文件，这可能需要很久。考虑使用LogMiner作为审核数据库使用的补充活动。有关数据库审计的信息，请参见“ <a href="../admin/managing-users-and-securing-the-database.html#ADMIN11241" target="_blank"><span class="italic">Oracle数据库管理员指南”</span></a> 。）
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1553"></a><div class="props_rev_3"><a id="GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" name="GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D"></a><h3 id="SUTIL-GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" class="sect3"><span class="enumeration_section">22.2</span> LogMiner简介</h3>
               <div>
                  <p>这些主题简要介绍了LogMiner，包括以下主题。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF">LogMiner配置</a><br>描述LogMiner配置中的四个基本对象。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-ED46E42D-B412-4820-9753-EBE15F49BA21">指导LogMiner操作和检索感兴趣的数据</a><br>你直接使用LogMiner的操作<code class="codeph">DBMS_LOGMNR</code>和<code class="codeph">DBMS_LOGMNR_D</code> PL / SQL程序包，并使用检索感兴趣的数据<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1554"></a><div class="props_rev_3"><a id="GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" name="GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF"></a><h4 id="SUTIL-GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" class="sect4"><span class="enumeration_section">22.2.1</span> LogMiner配置</h4>
                  <div>
                     <p>描述LogMiner配置中的四个基本对象。</p>
                     <p>具体来说，您应该熟悉：源数据库，挖掘数据库，LogMiner字典以及包含感兴趣数据的重做日志文件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">源数据库</span>是生成您希望LogMiner分析的所有重做日志文件的数据库。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">挖掘数据库</span>是LogMiner在执行分析时使用的数据库。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">LogMiner字典</span>允许LogMiner在显示您请求的重做日志数据时提供表名和列名，而不是内部对象ID。</p>
                           <p>LogMiner使用字典将内部对象标识符和数据类型转换为对象名称和外部数据格式。如果没有字典，LogMiner将返回内部对象ID并将数据显示为二进制数据。</p>
                           <p>例如，请考虑以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO HR.JOBS（JOB_ID，JOB_TITLE，MIN_SALARY，MAX_SALARY）VALUES（'IT_WT'，'Technical Writer'，4000,11000）;</pre><p>没有字典，LogMiner将显示：</p><pre class="oac_no_warn" dir="ltr">插入“UNKNOWN”。“OBJ＃45522”（“COL 1”，“COL 2”，“COL 3”，“COL 4”）值（HEXTORAW（'45465f4748'），HEXTORAW（'546563686e6963616c20577269746572'），HEXTORAW（ 'C229'），HEXTORAW（ 'c3020b'））;</pre></li>
                        <li>
                           <p><span class="bold">重做日志文件</span>包含对数据库或数据库字典所做的更改。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5">示例LogMiner配置</a><br>描述LogMiner配置。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4">要求</a><br>描述了源和挖掘数据库，数据字典以及LogMiner将挖掘的重做日志文件的要求。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" title="这些主题简要介绍了LogMiner，包括以下主题。">LogMiner简介</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3613"></a><a id="SUTIL1555"></a><div class="props_rev_3"><a id="GUID-03892F75-767E-4462-9865-9843F1502AD5" name="GUID-03892F75-767E-4462-9865-9843F1502AD5"></a><h5 id="SUTIL-GUID-03892F75-767E-4462-9865-9843F1502AD5" class="sect5"><span class="enumeration_section">22.2.1.1</span> LogMiner配置示例</h5>
                     <div>
                        <p>描述LogMiner配置。</p>
                        <p><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">图22-1</a>显示了LogMiner配置示例。在此图中，Boston中的源数据库生成重做日志文件，这些文件存档并运送到旧金山的数据库。已将LogMiner字典解压缩到这些重做日志文件。LogMiner将实际分析重做日志文件的挖掘数据库位于旧金山。Boston数据库运行Oracle Database 11 <span class="italic">g</span> ，旧金山数据库运行Oracle Database 12 <span class="italic">c。</span></p>
                        <div class="figure" id="GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">
                           <p class="titleinfigure">图22-1 LogMiner数据库配置示例</p><img src="img/remote_config.gif" width="455" alt="下面是图22-1的描述" title="下面是图22-1的描述" longdesc="img_text/remote_config.html"><br><a href="img_text/remote_config.html">“图22-1 LogMiner数据库配置示例”的说明</a></div>
                        <!-- class="figure" -->
                        <p><a href="oracle-logminer-utility.html#GUID-03892F75-767E-4462-9865-9843F1502AD5__I1018483">图22-1</a>只显示了一个有效的LogMiner配置。其他有效配置是对源数据库和挖掘数据库使用相同数据库的配置，或使用其他方法提供数据字典的配置。<a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="LogMiner requires a dictionary to translate object IDs into object names when it returns redo data to you.">LogMiner Dictionary Options</a>中描述了这些其他数据字典<a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。">选项</a> 。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" title="描述LogMiner配置中的四个基本对象。">LogMiner配置</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1556"></a><div class="props_rev_3"><a id="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4" name="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4"></a><h5 id="SUTIL-GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4" class="sect5"><span class="enumeration_section">22.2.1.2</span>要求</h5>
                     <div>
                        <p>描述了源和挖掘数据库，数据字典以及LogMiner将挖掘的重做日志文件的要求。</p>
                        <p>特别：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>来源和采矿数据库</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>源数据库和挖掘数据库都必须在同一硬件平台上运行。</p>
                                 </li>
                                 <li>
                                    <p>挖掘数据库可以与源数据库相同或完全独立。</p>
                                 </li>
                                 <li>
                                    <p>挖掘数据库必须作为源数据库运行相同版本或更高版本的Oracle数据库软件。</p>
                                 </li>
                                 <li>
                                    <p>挖掘数据库必须使用源数据库使用的相同字符集（或字符集的超集）。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>LogMiner字典</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>字典必须由生成LogMiner将分析的重做日志文件的相同源数据库生成。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>所有重做日志文件：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>必须由相同的源数据库生成。</p>
                                 </li>
                                 <li>
                                    <p>必须与相同的数据库<code class="codeph">RESETLOGS SCN</code>关联。</p>
                                 </li>
                                 <li>
                                    <p>必须来自8.0或更高版本的Oracle数据库。但是，从9.0.1版开始引入的一些LogMiner功能仅适用于在Oracle9 <span class="italic">i</span>或更高版本数据库上生成的重做日志文件。请参阅<a href="oracle-logminer-utility.html#GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" title="描述支持的数据库版本和重做日志文件版本。">支持的数据库和重做日志文件版本</a> 。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>LogMiner不允许您混合来自不同数据库的重做日志文件，也不允许使用与生成要分析的重做日志文件的数据库不同的数据库中的字典。</p>
                        <div class="infoboxnote" id="GUID-7594F0D7-0ACD-46E6-BD61-2751136ECDB4__GUID-B5C5A29D-B28B-40AB-BF80-B9F977CEEDB4">
                           <p class="notep1">注意：</p>
                           <p>在生成将由LogMiner分析的日志文件之前，必须启用补充日志记录。</p>
                           <p>启用补充日志记录时，会在重做流中记录其他信息，以使重做日志文件中的信息对您有用。因此，至少，您必须启用最小的补充日志记录，如以下SQL语句所示：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据;</pre><p>要确定是否启用了补充日志记录，请查询<code class="codeph">V$DATABASE</code>视图，如以下SQL语句所示：</p><pre class="oac_no_warn" dir="ltr">从V $ DATABASE中选择SUPPLEMENTAL_LOG_DATA_MIN;</pre><p>如果查询返回值<code class="codeph">YES</code>或<code class="codeph">IMPLICIT</code> ，则启用最小补充日志记录。有关<a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="Describes supplemental logging.">补充日志记录</a>的完整信息，请参阅<a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志</a>记录。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2A5828FB-C4BA-45E8-AEB2-4FA54EC5AFEF" title="描述LogMiner配置中的四个基本对象。">LogMiner配置</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1557"></a><div class="props_rev_3"><a id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21" name="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21"></a><h4 id="SUTIL-GUID-ED46E42D-B412-4820-9753-EBE15F49BA21" class="sect4"><span class="enumeration_section">22.2.2</span>指导LogMiner操作和检索感兴趣的数据</h4>
                  <div>
                     <p>你直接使用LogMiner的操作<code class="codeph">DBMS_LOGMNR</code>和<code class="codeph">DBMS_LOGMNR_D</code> PL / SQL程序包，并使用检索感兴趣的数据<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </p>
                     <div class="section">
                        <p>例如：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>指定LogMiner字典。</span><div>
                              <p>根据您计划使用的字典类型，使用<code class="codeph">DBMS_LOGMNR_D.BUILD</code>过程或在启动LogMiner时（在步骤3中）或两者都指定字典。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>指定重做日志文件列表以进行分析。</span><div>
                              <p>使用<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>过程，或指示LogMiner创建日志文件列表，以便在启动LogMiner时自动进行分析（在步骤3中）。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>启动LogMiner。</span><div>
                              <p>使用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>请求感兴趣的重做数据。</span><div>
                              <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>结束LogMiner会话。</span><div>
                              <p>使用<code class="codeph">DBMS_LOGMNR.END_LOGMNR</code>过程。
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>您必须具有<code class="codeph">EXECUTE_CATALOG_ROLE</code>角色和<code class="codeph">LOGMINING</code>权限才能查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图并使用LogMiner PL / SQL包。
                        </p>
                        <div class="infoboxnote" id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21__GUID-33A8BFB1-3442-45CB-B6DE-5AC4C11FFC9B">
                           <p class="notep1">注意：</p>
                           <p>在Oracle RAC数据库生成的归档日志中挖掘指定时间或SCN感兴趣范围时，必须确保已指定在该时间或SCN范围内处于活动状态的所有重做线程中的所有归档日志。如果你不能做到这一点，那么任何疑问<code class="codeph">V$LOGMNR_CONTENTS</code>只返回部分结果（基于通过指定LogMiner的归档日志<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>程序）。
                           </p>
                           <p>Oracle Database 19c（19.1）中不支持<code class="codeph">dbms_logmnr.start_logmnr</code>软件包的<code class="codeph">CONTINUOUS_MINE</code>选项，该选项不再可用。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-ED46E42D-B412-4820-9753-EBE15F49BA21__GUID-B0702866-FC79-4EA9-9E05-D6554DD08611">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="Describes the steps in a typical LogMiner session.">典型LogMiner会话</a>中的<a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">步骤，以</a>获取使用LogMiner的示例</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2EAA593B-DC09-4D30-87EB-34819FC68B3D" title="这些主题简要介绍了LogMiner，包括以下主题。">LogMiner简介</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3926"></a><div class="props_rev_3"><a id="GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" name="GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093"></a><h3 id="SUTIL-GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" class="sect3"><span class="enumeration_section">22.3</span>在CDB中使用LogMiner</h3>
               <div>
                  <p>您可以在多租户容器数据库（CDB）中使用LogMiner。</p>
                  <p>以下部分讨论了在CDB中使用LogMiner与非CDB时要注意的一些差异：</p>
                  <p>LogMiner支持具有不同字符集的PDB的CDB，前提是根容器具有作为所有PDB的超集的字符集。</p>
                  <p>要管理多租户环境，您必须具有<code class="codeph">CDB_DBA</code>角色。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0">CDB中的LogMiner V $视图和DBA视图</a><br>在CDB中，LogMiner用于显示有关在系统中运行的LogMiner会话的信息的视图包含一个名为<code class="codeph">CON_ID</code>的附加列。</li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51">CDB中的V $ LOGMNR_CONTENTS视图</a><br>在CDB中， <code class="codeph">V$LOGMNR_CONTENTS</code>视图及其相关功能仅限于根数据库。<code class="codeph">V$LOGMNR_CONTENTS</code>中存在几个支持CDB的新列。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0">在CDB中启用补充日志记录</a><br>在CDB中，启用和禁用数据库范围的补充日志记录的语法与非CDB数据库中的语法相同</li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-EF8A932F-7E71-4995-893E-E583B90007C2">在CDB中使用平面文件字典</a><br>您无法在单个平面文件中为整个CDB获取字典快照。您必须连接到不同的PDB，并且只能在平面文件中拍摄该PDB的快照。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="oracle-logminer-utility.html#GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" title="在CDB中，LogMiner用于显示有关在系统中运行的LogMiner会话的信息的视图包含一个名为CON_ID的附加列。">CDB中的LogMiner V $视图和DBA视图</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" title="在CDB中，V $ LOGMNR_CONTENTS视图及其相关功能仅限于根数据库。V $ LOGMNR_CONTENTS中存在几个支持CDB的新列。">CDB中的V $ LOGMNR_CONTENTS视图</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" title="在CDB中，启用和禁用数据库范围的补充日志记录的语法与非CDB数据库中的语法相同">在CDB中启用补充日志记录</a></li>
                        <li><a href="oracle-logminer-utility.html#GUID-EF8A932F-7E71-4995-893E-E583B90007C2" title="您无法在单个平面文件中为整个CDB获取字典快照。您必须连接到不同的PDB，并且只能在平面文件中拍摄该PDB的快照。">在CDB中使用平面文件字典</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" name="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0"></a><h4 id="SUTIL-GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0" class="sect4"><span class="enumeration_section">22.3.1</span> CDB中的LogMiner V $视图和DBA视图</h4>
                  <div>
                     <p>在CDB中，LogMiner用于显示有关在系统中运行的LogMiner会话的信息的视图包含一个名为<code class="codeph">CON_ID</code>的附加列。</p>
                     <p><code class="codeph">CON_ID</code>列标识与正在显示信息的会话关联的容器ID。从可插拔数据库（PDB）查询视图时，仅显示与数据库关联的信息。以下视图受此新行为的影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">V $ LOGMNR_DICTIONARY_LOAD</code>	
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ LOGMNR_LATCH</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ LOGMNR_PROCESS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ LOGMNR_SESSION</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ LOGMNR_STATS</code></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0__GUID-98114A40-FAB4-40B7-AE82-FE364F882588">
                        <p class="notep1">注意：</p>
                        <p>为了支持CDB，除了<code class="codeph">CON_ID</code>之外， <code class="codeph">V$LOGMNR_CONTENTS</code>视图还有几个其他新列。</p>
                     </div>
                     <p>以下DBA视图具有类似的CDB视图，其名称以CDB开头。</p>
                     <div class="tblformal" id="GUID-945F35C4-1D2D-4F0E-954B-408BBB09EDF0__LOGMINERDBAANDCDBVIEWSDBAVIEWCDB_VI-FEBFF9B4">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="LogMiner DBA views and CDB Views " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d135940e1135">日志视图的类型</th>
                                 <th align="left" valign="bottom" width="33%" id="d135940e1137">DBA视图</th>
                                 <th align="left" valign="bottom" width="33%" id="d135940e1140">CDB视图</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1145" headers="d135940e1135 ">LogMiner日志视图</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1145 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_LOG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1145 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_LOG</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1156" headers="d135940e1135 ">LogMiner清除日志视图</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1156 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_PURGED_LOG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1156 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_PURGED_LOG</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d135940e1167" headers="d135940e1135 ">LogMiner会话日志视图</td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1167 d135940e1137 ">
                                    <p><code class="codeph">DBA_LOGMNR_SESSION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d135940e1167 d135940e1140 ">
                                    <p><code class="codeph">CDB_LOGMNR_SESSION</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>DBA视图仅显示与查询它们的容器中定义的会话相关的信息。</p>
                     <p>CDB视图包含一个额外的<code class="codeph">CON_ID</code>列，用于标识给定行所代表的数据的容器。从根查询CDB视图时，可以使用它们查看有关所有容器的信息。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="您可以在多租户容器数据库（CDB）中使用LogMiner。">在CDB中使用LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" name="GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51"></a><h4 id="SUTIL-GUID-98AED018-EAF5-4B56-BE6C-F1DEEF8D6B51" class="sect4"><span class="enumeration_section">22.3.2</span> CDB中的V $ LOGMNR_CONTENTS视图</h4>
                  <div>
                     <p>在CDB中， <code class="codeph">V$LOGMNR_CONTENTS</code>视图及其相关功能仅限于根数据库。<code class="codeph">V$LOGMNR_CONTENTS</code>中存在几个支持CDB的新列。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CON_ID</code> - 包含与执行查询的容器关联的ID。由于<code class="codeph">V$LOGMNR_CONTENTS</code>仅限于根数据库，因此在CDB上执行查询时，此列将返回值1。</p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_NAME</code> -  PDB名称。仅当使用LogMiner字典执行挖掘时，此信息才可用。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_ID</code> - 生成重做记录的PDB的容器ID。仅当使用LogMiner字典执行挖掘时，此信息才可用。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_DBID</code> -  PDB标识符。仅当使用当前LogMiner字典执行挖掘时，此信息才可用。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SRC_CON_GUID</code> - 包含与PDB关联的GUID。仅当使用当前LogMiner字典执行挖掘时，此信息才可用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="您可以在多租户容器数据库（CDB）中使用LogMiner。">在CDB中使用LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3929"></a><div class="props_rev_3"><a id="GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" name="GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0"></a><h4 id="SUTIL-GUID-6564DEB6-DE46-4269-BFA0-4797612DE7C0" class="sect4"><span class="enumeration_section">22.3.3</span>在CDB中启用补充日志记录</h4>
                  <div>
                     <p>在CDB中，启用和禁用数据库范围的补充日志记录的语法与非CDB数据库中的语法相同</p>
                     <div class="section">
                        <p>例如，在添加或删除补充日志数据时使用以下语法：</p><pre class="pre codeblock"><code>ALTER DATABASE [ADD | DROP]补充日志数据......
</code></pre><p>但请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在CDB中，CDB上启用了从<code class="codeph">CDB$ROOT</code>启用的补充日志记录级别。</p>
                           </li>
                           <li>
                              <p>如果在<code class="codeph">CDB$ROOT</code>启用了至少最小的补充日志记录，则可以在PDB级别启用其他补充日志记录级别。
                              </p>
                           </li>
                           <li>
                              <p>在CDB级别从<code class="codeph">CDB$ROOT</code>级别启用的补充日志记录级别无法在PDB级别禁用。
                              </p>
                           </li>
                           <li>
                              <p>从<code class="codeph">CDB$ROOT</code>删除所有补充日志记录会禁用<code class="codeph">CDB$ROOT</code>所有补充日志记录，无论以前的PDB级别设置如何。
                              </p>
                           </li>
                        </ul>
                        <p>使用<code class="codeph">CREATE TABLE</code>和<code class="codeph">ALTER TABLE</code>语句启动的补充日志记录操作可以从CDB根目录或PDB执行。它们仅影响应用它们的表。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="您可以在多租户容器数据库（CDB）中使用LogMiner。">在CDB中使用LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL4227"></a><div class="props_rev_3"><a id="GUID-EF8A932F-7E71-4995-893E-E583B90007C2" name="GUID-EF8A932F-7E71-4995-893E-E583B90007C2"></a><h4 id="SUTIL-GUID-EF8A932F-7E71-4995-893E-E583B90007C2" class="sect4"><span class="enumeration_section">22.3.4</span>在CDB中使用平面文件字典</h4>
                  <div>
                     <p>您无法在单个平面文件中为整个CDB获取字典快照。您必须连接到不同的PDB，并且只能在平面文件中拍摄该PDB的快照。</p>
                     <p>因此，在使用平面文件字典时，您只能挖掘重做日志以查找与数据字典包含在平面文件中的PDB相关的更改。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-2555A155-01E3-483E-9FC6-2BDC2D8A4093" title="您可以在多租户容器数据库（CDB）中使用LogMiner。">在CDB中使用LogMiner</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1558"></a><div class="props_rev_3"><a id="GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" name="GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5"></a><h3 id="SUTIL-GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" class="sect3"><span class="enumeration_section">22.4</span> LogMiner字典文件和重做日志文件</h3>
               <div>
                  <p>在开始使用LogMiner之前，了解LogMiner如何使用LogMiner字典文件（或多个文件）和重做日志文件非常重要。这将帮助您获得准确的结果并规划系统资源的使用。</p>
                  <p>本节讨论以下概念：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C">LogMiner字典选项</a><br>当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0">重做日志文件选项</a><br>要挖掘重做日志文件中的数据，LogMiner需要有关要挖掘哪些重做日志文件的信息。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3614"></a><a id="SUTIL1559"></a><div class="props_rev_3"><a id="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" name="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C"></a><h4 id="SUTIL-GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" class="sect4"><span class="enumeration_section">22.4.1</span> LogMiner字典选项</h4>
                  <div>
                     <p>当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。</p>
                     <p>LogMiner为您提供了三个提供字典的选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="要指示LogMiner使用当前用于数据库的字典，请在启动LogMiner时将在线目录指定为字典源。">使用在线目录</a></p>
                           <p>Oracle建议您在有权访问创建重做日志文件的源数据库时以及未预期更改目标表中的列定义时使用此选项。这是最有效且易于使用的选项。</p>
                        </li>
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="要将LogMiner字典提取到重做日志文件，必须打开数据库并处于ARCHIVELOG模式，并且必须启用存档。">将LogMiner字典提取到重做日志文件</a></p>
                           <p>如果您不希望访问从中创建重做日志文件的源数据库，或者您预计将对感兴趣的表中的列定义进行更改，Oracle建议您使用此选项。</p>
                        </li>
                        <li>
                           <p><a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" title="当LogMiner字典位于平面文件中时，使用的系统资源少于重做日志文件中包含的系统资源。Oracle建议您定期备份字典提取以确保正确分析旧的重做日志文件。">将LogMiner字典提取到平面文件</a></p>
                           <p>维护此选项是为了与以前的版本向后兼容。此选项不保证事务一致性。Oracle建议您使用联机目录或提取字典来重做日志文件。</p>
                        </li>
                     </ul>
                     <p></p>
                     <p><a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C__I1014713">图22-2</a>显示了一个决策树，可帮助您根据您的具体情况选择LogMiner字典。
                     </p>
                     <div class="figure" id="GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C__I1014713">
                        <p class="titleinfigure">图22-2选择LogMiner字典的决策树</p><img src="img/decision_tree.gif" width="564" alt="下面是图22-2的描述" title="下面是图22-2的描述" longdesc="img_text/decision_tree.html"><br><a href="img_text/decision_tree.html">“图22-2用于选择LogMiner字典的决策树”的描述</a></div>
                     <!-- class="figure" -->
                     <p>以下部分提供有关如何指定每个可用字典选项的说明。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C">使用在线目录</a><br>要指示LogMiner使用当前用于数据库的字典，请在启动LogMiner时将在线目录指定为字典源。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC">将LogMiner字典提取到重做日志文件</a><br>要将LogMiner字典提取到重做日志文件，必须打开数据库并处于<code class="codeph">ARCHIVELOG</code>模式，并且必须启用存档。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018">将LogMiner字典提取到平面文件</a><br>当LogMiner字典位于平面文件中时，使用的系统资源少于重做日志文件中包含的系统资源。Oracle建议您定期备份字典提取以确保正确分析旧的重做日志文件。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" title="在开始使用LogMiner之前，了解LogMiner如何使用LogMiner字典文件（或多个文件）和重做日志文件非常重要。这将帮助您获得准确的结果并规划系统资源的使用。">LogMiner Dictionary文件和重做日志文件</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1560"></a><div class="props_rev_3"><a id="GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" name="GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C"></a><h5 id="SUTIL-GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" class="sect5"><span class="enumeration_section">22.4.1.1</span>使用在线目录</h5>
                     <div>
                        <p>要指示LogMiner使用当前用于数据库的字典，请在启动LogMiner时将在线目录指定为字典源。</p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG）;</pre><p>除了使用联机目录分析联机重做日志文件之外，如果您位于生成归档重做日志文件的同一系统上，则可以使用它来分析归档重做日志文件。</p>
                        <p>在线目录包含有关数据库的最新信息，可能是开始分析的最快方法。由于更改重要表的DDL操作有点罕见，因此在线目录通常包含分析所需的信息。</p>
                        <p>但请记住，在线目录只能重建在最新版本的表上执行的SQL语句。一旦表格被更改，在线目录就不再反映该表格的先前版本。这意味着LogMiner将无法重建在该表的先前版本上执行的任何SQL语句。相反，LogMiner在<code class="codeph">V$LOGMNR_CONTENTS</code>视图的<code class="codeph">SQL_REDO</code>列中生成不可执行的SQL（包括二进制值的十六进制到原始格式），类似于以下示例：</p><pre class="oac_no_warn" dir="ltr">插入HR.EMPLOYEES（col＃1，col＃2）值（hextoraw（'4a6f686e20446f65'），hextoraw（'c306'））;“</pre><p>在线目录选项要求打开数据库。</p>
                        <p>在线目录选项是不符合有效<code class="codeph">DDL_DICT_TRACKING</code>的选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。">LogMiner字典选项</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1561"></a><div class="props_rev_3"><a id="GUID-A0D89906-C787-4EB4-BA47-171A457445EC" name="GUID-A0D89906-C787-4EB4-BA47-171A457445EC"></a><h5 id="SUTIL-GUID-A0D89906-C787-4EB4-BA47-171A457445EC" class="sect5"><span class="enumeration_section">22.4.1.2</span>将LogMiner字典提取到重做日志文件</h5>
                     <div>
                        <p>要将LogMiner字典提取到重做日志文件，必须打开数据库并处于<code class="codeph">ARCHIVELOG</code>模式，并且必须启用存档。
                        </p>
                        <div class="section">
                           <p>在将字典提取到重做日志流时，不能执行任何DDL语句。因此，保证提取到重做日志文件的字典是一致的（而不是提取到平面文件的字典）。</p>
                           <p>要提取字典信息到重做日志文件，执行的PL / SQL <code class="codeph">DBMS_LOGMNR_D.BUILD</code>与程序<code class="codeph">STORE_IN_REDO_LOGS</code>选项。不要指定文件名或位置。
                           </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR_D.BUILD（ -  OPTIONS =&gt; DBMS_LOGMNR_D.STORE_IN_REDO_LOGS）;</pre><div class="infoboxnotealso" id="GUID-A0D89906-C787-4EB4-BA47-171A457445EC__GUID-D9B78510-9691-4CD9-B3CB-6945BF1A9293">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<code class="codeph">ARCHIVELOG</code>模式的详细信息，请<code class="codeph">ARCHIVELOG</code> <a href="../admin/managing-archived-redo-log-files.html#ADMIN11332" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">DBMS_LOGMNR_D.BUILD</code>的完整说明，请<a href="../arpls/DBMS_LOGMNR_D.html#ARPLS66816" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                           <p>将字典提取到重做日志文件的过程确实消耗了数据库资源，但是如果将提取限制在非高峰时间，那么这应该不是问题，并且它比提取到平面文件更快。根据字典的大小，它可能包含在多个重做日志文件中。如果相关的重做日志文件已存档，则可以找出哪些重做日志文件包含提取的字典的开头和结尾。为此，请查询<code class="codeph">V$ARCHIVED_LOG</code>视图，如下所示：</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称，其中DICTIONARY_BEGIN ='YES';从V $ ARCHIVED_LOG中选择名称，其中DICTIONARY_END ='是';</pre><p>在准备开始LogMiner会话时，使用<code class="codeph">ADD_LOGFILE</code>过程指定开始和结束重做日志文件的名称以及它们之间的其他重做日志。
                           </p>
                           <p>Oracle建议您定期备份重做日志文件，以便保存信息并在以后使用。理想情况下，这不会涉及任何额外的步骤，因为如果您的数据库得到妥善管理，那么应该已经有一个流程来备份和恢复存档的重做日志文件。同样，由于需要时间，在非高峰时段进行此操作是一种好习惯。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。">LogMiner字典选项</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1562"></a><div class="props_rev_3"><a id="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" name="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018"></a><h5 id="SUTIL-GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" class="sect5"><span class="enumeration_section">22.4.1.3</span>将LogMiner字典提取到平面文件</h5>
                     <div>
                        <p>当LogMiner字典位于平面文件中时，使用的系统资源少于重做日志文件中包含的系统资源。Oracle建议您定期备份字典提取以确保正确分析旧的重做日志文件。</p>
                        <div class="section">
                           <p>要提取数据库字典信息到一个平面文件，使用<code class="codeph">DBMS_LOGMNR_D.BUILD</code>程序与<code class="codeph">STORE_IN_FLAT_FILE</code>选项。
                           </p>
                           <p>以下步骤描述了如何将字典提取到平面文件。步骤1和2是准备步骤。您只需要执行一次，然后您可以根据需要多次将字典提取到平面文件中。</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span><code class="codeph">DBMS_LOGMNR_D.BUILD</code>过程需要访问可放置字典文件的目录。由于PL / SQL过程通常不访问用户目录，因此必须指定目录位置，否则过程将失败。目录位置必须是目录对象。以下是使用SQL <code class="codeph">CREATE DIRECTORY</code>语句为路径<code class="codeph">/oracle/database</code>创建名为<code class="codeph">my_dictionary_dir</code>的目录对象的<code class="codeph">my_dictionary_dir</code> 。</span><div><pre class="pre codeblock"><code>SQL&gt; CREATE DIRECTORY“my_dictionary_dir”AS'/ oracle / database';</code></pre></div>
                              <div>
                                 <div class="infoboxnote" id="GUID-DA37874F-6637-4205-AB5C-A8AC1914D018__GUID-6516B852-F836-4968-80BD-7C41EB368818">
                                    <p class="notep1">注意：</p>在Oracle Database 12 <span class="italic">c第</span> 2版（12.2）之前，您使用<code class="codeph">UTL_FILE_DIR</code>初始化参数来指定目录位置。但是，从Oracle Database 18c开始，不支持<code class="codeph">UTL_FILE_DIR</code>初始化参数。它仍然支持向后兼容性，但Oracle强烈建议您改为使用目录对象。
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>如果数据库已关闭，则使用SQL * Plus装入并打开要分析其重做日志文件的数据库。例如，输入SQL <code class="codeph">STARTUP</code>命令将安装并打开数据库：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; STARTUP</pre></div>
                           </li>
                           <li class="stepexpand"><span>执行PL / SQL过程<code class="codeph">DBMS_LOGMNR_D.BUILD</code> 。以下示例将LogMiner字典文件提取到在步骤1中创建的目录对象<code class="codeph">my_dictionary_dir</code>中名为<code class="codeph">dictionary.ora</code>的平面文件。</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE dbms_logmnr_d.build（dictionary_location =&gt;'my_dictionary_dir'， -  dictionary_filename =&gt;'dictionary.ora'， -  options =&gt; dbms_logmnr_d.store_in_flat_file）;</pre><p>您还可以指定文件名和位置，而无需指定<code class="codeph">STORE_IN_FLAT_FILE</code>选项。结果将是相同的。
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-A69748AD-B53D-42D9-9B54-C8132D8E4C1C" title="当LogMiner向您返回重做数据时，它需要一个字典将对象ID转换为对象名称。">LogMiner字典选项</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1563"></a><div class="props_rev_3"><a id="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0" name="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0"></a><h4 id="SUTIL-GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0" class="sect4"><span class="enumeration_section">22.4.2</span>重做日志文件选项</h4>
                  <div>
                     <p>要挖掘重做日志文件中的数据，LogMiner需要有关要挖掘哪些重做日志文件的信息。</p>
                     <p>在这些重做日志文件中找到的对数据库所做的更改将通过<code class="codeph">V$LOGMNR_CONTENTS</code>视图传递给您。
                     </p>
                     <p>您可以指示LogMiner自动动态创建要分析的重做日志文件列表，也可以显式指定LogMiner要重新分析的重做日志文件列表，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>自动</p>
                           <p>如果在源数据库上使用LogMiner，则可以指示LogMiner自动查找并创建重做日志文件列表以进行分析。虽然此示例从在线目录中指定字典，但可以使用任何LogMiner字典。</p>
                           <div class="infoboxnote" id="GUID-C50E9C76-ABA1-4A27-AAB4-C65479EDFDE0__GUID-46B7D4FA-E19F-41BD-B0EF-B1BA5F2086CB">
                              <p class="notep1">注意：</p>Oracle Database 19c（19.1）中不支持<code class="codeph">dbms_logmnr.start_logmnr</code>软件包的<code class="codeph">continuous_mine</code>选项，该选项不再可用。
                           </div>
                           <p>LogMiner使用数据库控制文件查找并将满足指定时间或SCN范围的重做日志文件添加到LogMiner重做日志文件列表中。例如：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY HH24：MI：SS'; EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  STARTTIME =&gt; '01 -Jan-2012 08:30:00'， -  ENDTIME =&gt; '01 -Jan-2012 08:45:00'， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  - ）;</pre><p>（为了避免在对<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程的PL / SQL调用中指定日期格式，此示例首先使用SQL <code class="codeph">ALTER</code> <code class="codeph">SESSION SET</code> <code class="codeph">NLS_DATE_FORMAT</code>语句。）
                           </p>
                           <p>您还可以通过使用<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>指定一个重做日志文件来指示LogMiner自动构建要分析的重做日志文件列表。但是，前面描述的方法更为典型。
                           </p>
                        </li>
                        <li>
                           <p>手动</p>
                           <p>在启动LogMiner之前，使用<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>过程手动创建重做日志文件列表。将第一个重做日志文件添加到列表后，每个随后添加的重做日志文件必须来自同一个数据库并与相同的数据库RESETLOGS SCN关联。使用此方法时，无需将LogMiner连接到源数据库。
                           </p>
                           <p>例如，要启动重做日志文件的新列表，请指定<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL / SQL过程的<code class="codeph">NEW</code>选项，以指示这是新列表的开头。例如，输入以下内容以指定<code class="codeph">/oracle/logs/log1.f</code> ：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log1.f'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre><p>如果需要，可以通过指定<code class="codeph">PL/SQL DBMS_LOGMNR.ADD_LOGFILE</code> <code class="codeph">ADDFILE</code>过程的<code class="codeph">ADDFILE</code>选项来添加更多重做日志文件。例如，输入以下内容以添加<code class="codeph">/oracle/logs/log2.f</code> ：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log2.f'， -  OPTIONS =&gt; DBMS_LOGMNR.ADDFILE）;</pre><p>要确定当前LogMiner会话中正在分析哪些重做日志文件，您可以查询<code class="codeph">V$LOGMNR_LOGS</code>视图，该视图包含每个重做日志文件的一行。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-1582C62D-5AD8-4807-9ABF-B0F1861C81B5" title="在开始使用LogMiner之前，了解LogMiner如何使用LogMiner字典文件（或多个文件）和重做日志文件非常重要。这将帮助您获得准确的结果并规划系统资源的使用。">LogMiner Dictionary文件和重做日志文件</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1564"></a><div class="props_rev_3"><a id="GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5" name="GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5"></a><h3 id="SUTIL-GUID-A5A1E94C-45AA-4B6A-B7B3-E1AD2F8675B5" class="sect3"><span class="enumeration_section">22.5</span>启动LogMiner</h3>
               <div>
                  <p>调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程以启动LogMiner。
                  </p>
                  <p>由于可用的选项与<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>程序允许您控制输出到<code class="codeph">V$LOGMNR_CONTENTS</code>视图，你必须调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>查询之前<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                  </p>
                  <p>启动LogMiner时，您可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>指定LogMiner如何过滤它返回的数据（例如，通过开始和结束时间或SCN值）</p>
                     </li>
                     <li>
                        <p>指定用于格式化LogMiner返回的数据的选项</p>
                     </li>
                     <li>
                        <p>指定要使用的LogMiner字典</p>
                     </li>
                  </ul>
                  <p>以下列表是LogMiner设置的摘要，您可以使用<code class="codeph">OPTIONS</code>参数指定<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>以及在何处查找有关它们的更多信息。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">DICT_FROM_ONLINE_CATALOG</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">DICT_FROM_REDO_LOGS</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">COMMITTED_DATA_ONLY</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">SKIP_CORRUPTION</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">NO_SQL_DELIMITER</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">PRINT_PRETTY_SQL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">NO_ROWID_IN_STMT</code> 
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DDL_DICT_TRACKING</code></p>
                     </li>
                  </ul>
                  <p>执行<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程时，LogMiner会检查以确保您指定的选项和参数组合有效，并且您指定的字典和重做日志文件可用。但是，在查询视图之前，不会填充<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                  </p>
                  <p>请注意，对<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，参数和选项不是持久的。每次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>时，必须指定所有需要的参数和选项（包括SCN和时间范围）。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" name="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D"></a><h3 id="SUTIL-GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" class="sect3"><span class="enumeration_section">22.6</span>查询重做感兴趣数据的V $ LOGMNR_CONTENTS</h3>
               <div>
                  <p>您可以通过查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图来访问感兴趣的重做数据。
                  </p>
                  <p>（请注意，您必须具有<code class="codeph">SYSDBA</code>或<code class="codeph">LOGMINING</code>权限才能查询<code class="codeph">V$LOGMNR_CONTENTS</code> 。）此视图提供有关对数据库所做更改的历史信息，包括（但不限于）以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对数据库所做的更改类型： <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">DDL</code> （ <code class="codeph">OPERATION</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>进行更改的SCN（ <code class="codeph">SCN</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>提交更改的SCN（ <code class="codeph">COMMIT_SCN</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>更改所属的事务（ <code class="codeph">XIDUSN</code> ， <code class="codeph">XIDSLT</code>和<code class="codeph">XIDSQN</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>已修改对象的表和架构名称（ <code class="codeph">SEG_NAME</code>和<code class="codeph">SEG_OWNER</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>发出DDL或DML语句以进行更改的用户的名称（ <code class="codeph">USERNAME</code>列）。
                        </p>
                     </li>
                     <li>
                        <p>如果更改是由SQL DML语句引起的，则显示SQL DML的重构SQL语句与用于生成重做记录的SQL DML（ <code class="codeph">SQL_REDO</code>列）等效（但不一定相同）。
                        </p>
                     </li>
                     <li>
                        <p>如果密码是<code class="codeph">SQL_REDO</code>列中语句的<code class="codeph">SQL_REDO</code> ，则密码将被加密。与DDL语句对应的<code class="codeph">SQL_REDO</code>列值始终与用于生成重做记录的SQL DDL相同。
                        </p>
                     </li>
                     <li>
                        <p>如果更改是由SQL DML更改引起的，则重构的SQL语句显示撤消更改所需的SQL DML语句（ <code class="codeph">SQL_UNDO</code>列）。
                        </p>
                        <p>与DDL语句对应的<code class="codeph">SQL_UNDO</code>列始终为<code class="codeph">NULL</code> 。对于某些数据类型和回滚操作， <code class="codeph">SQL_UNDO</code>列也可能为<code class="codeph">NULL</code> 。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__LOGMINERSUPPORTSLOGMINERUTILITYSUPP-FEC1511D">
                     <p class="notep1">注意：</p>
                     <p>LogMiner支持透明数据加密（TDE），因为<code class="codeph">V$LOGMNR_CONTENTS</code>显示对具有加密列的表（包括正在更新的加密列）执行的DML操作，前提是LogMiner数据字典包含相关对象的元数据并提供适当的主数据密钥在Oracle钱包中。钱包必须打开或<code class="codeph">V$LOGMNR_CONTENTS</code>无法解释相关的重做记录。如果数据库未打开（只读或读写），则无法使用TDE支持。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__GUID-0BA85BA5-06F6-477E-9FFC-89CD224BC943">
                     <p class="notep1">也可以看看：</p>
                     <p>有关TDE的更多信息，请参见<a href="../asoag/asopart1.html#ASOAG600" target="_blank"><span><cite>“Oracle数据库高级安全指南</cite></span></a></p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D__GUID-177CB69E-F6B9-452A-B951-7AB398092FF1">查询V $ LOGMNR_CONTENTS的示例</p>
                     <p>要查找名为Ron的用户在<code class="codeph">oe.orders</code>表上执行的任何删除操作，请发出类似于以下内容的SQL查询：</p><pre class="oac_no_warn" dir="ltr">SELECT操作，SQL_REDO，SQL_UNDO来自V $ LOGMNR_CONTENTS WHERE SEG_OWNER ='OE'和SEG_NAME ='ORDERS'和OPERATION ='DELETE'和USERNAME ='RON';</pre><p>查询生成以下输出。显示格式可能与此处显示的格式不同。</p><pre class="oac_no_warn" dir="ltr">操作SQL_REDO SQL_UNDO删除从“OE”删除。“ORDERS”插入“OE”。“ORDERS”，其中“ORDER_ID”='2413'（“ORDER_ID”，“ORDER_MODE”和“ORDER_MODE”='直接'“CUSTOMER_ID” ，“ORDER_STATUS”和“CUSTOMER_ID”='101'“ORDER_TOTAL”，“SALES_REP_ID”和“ORDER_STATUS”='5'“PROMOTION_ID”）和“ORDER_TOTAL”='48552'值（'2413'，'直接' ，'101'和“SALES_REP_ID”='161''5'，'48552'，'161'，NULL）;并且“PROMOTION_ID”为NULL并且ROWID ='AAAHTCAABAAAZAPAAN'; DELETE删除“OE”。“ORDERS”插入“OE”。“ORDERS”，其中“ORDER_ID”='2430'（“ORDER_ID”，“ORDER_MODE”和“ORDER_MODE”='直接'“CUSTOMER_ID”，“ORDER_STATUS “和”CUSTOMER_ID“='101'”ORDER_TOTAL“，”SALES_REP_ID“和”ORDER_STATUS“='8'”PROMOTION_ID“）和”ORDER_TOTAL“=''29669.9'值（'2430'，'直接'，'101 '，和“SALES_REP_ID”='159''8'，'29669.9'，'159'，NULL）;和“PROMOTION_ID”为空，ROWID ='AAAHTCAABAAAZAPAAe';</pre><p>此输出显示用户Ron从<code class="codeph">oe.orders</code>表中删除了两行。重构的SQL语句与Ron发出的实际语句相同，但不一定相同。造成这种差异的原因是原始<code class="codeph">WHERE</code>子句未记录在重做日志文件中，因此LogMiner只能单独显示已删除（或更新或插入）的行。
                     </p>
                     <p>因此，即使单个<code class="codeph">DELETE</code>语句可能负责删除这两行， <code class="codeph">V$LOGMNR_CONTENTS</code>中的输出也不会反映该事实。实际的<code class="codeph">DELETE</code>语句可能是<code class="codeph">DELETE FROM OE.ORDERS WHERE CUSTOMER_ID ='101</code> '，或者它可能是<code class="codeph">DELETE FROM OE.ORDERS WHERE PROMOTION_ID = NULL.</code></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91">如何填充V $ LOGMNR_CONTENTS视图</a><br><code class="codeph">V$LOGMNR_CONTENTS</code>固定视图与其他视图不同，因为它不是存储在表中的数据的选择性表示。相反，它是您从重做日志文件请求的数据的关系表示。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A">根据列值查询V $ LOGMNR_CONTENTS</a><br>LogMiner允许您根据列值进行查询。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839">基于XMLType列和表查询V $ LOGMNR_CONTENTS</a><br>LogMiner支持为<code class="codeph">XMLType</code>列生成的重做。在兼容性设置为11.0.0.0或更高版本时生成重做时，支持存储为<code class="codeph">CLOB</code> <code class="codeph">XMLType</code>数据。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91" name="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91"></a><h4 id="SUTIL-GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91" class="sect4"><span class="enumeration_section">22.6.1</span>如何填充V $ LOGMNR_CONTENTS视图</h4>
                  <div>
                     <p><code class="codeph">V$LOGMNR_CONTENTS</code>固定视图与其他视图不同，因为它不是存储在表中的数据的选择性表示。相反，它是您从重做日志文件请求的数据的关系表示。
                     </p>
                     <p>LogMiner仅在响应对其的查询时填充视图。您必须先成功启动LogMiner，然后才能查询<code class="codeph">V$LOGMNR_CONTENTS.</code></p>
                     <p>对<code class="codeph">V$LOGMNR_CONTENTS</code>视图执行SQL select操作时，将按顺序读取重做日志文件。来自重做日志文件的翻译信息将作为<code class="codeph">V$LOGMNR_CONTENTS</code>视图中的行返回。这将继续，直到满足启动时指定的筛选条件或达到重做日志文件的末尾。
                     </p>
                     <p>在某些情况下，可能无法填充<code class="codeph">V$LOGMNR_CONTENTS</code>某些列。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于<code class="codeph">OPERATION</code>列的值为<code class="codeph">DDL</code>行，不会填充<code class="codeph">TABLE_SPACE</code>列。这是因为DDL可能在多个表空间上运行。例如，可以使用跨越多个表空间的多个分区创建表;因此填充列是不准确的。
                           </p>
                        </li>
                        <li>
                           <p>LogMiner不为临时表生成SQL重做或SQL撤消。<code class="codeph">SQL_REDO</code>列将包含字符串<code class="codeph">"/* No SQL_REDO for temporary tables */"</code> ， <code class="codeph">SQL_UNDO</code>列将包含字符串<code class="codeph">"/* No SQL_UNDO for temporary tables */"</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>除非您使用<code class="codeph">COMMITTED_DATA_ONLY</code>选项指定仅应检索已提交的事务，否则LogMiner将以SCN顺序返回所有行。SCN订单是通常在介质恢复中应用的订单。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91__SHOWINGONLYCOMMITTEDTRANSACTIONSFOR-FEC34E1B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" title="对DBMS_LOGMNR.START_LOGMNR使用COMMITTED_DATA_ONLY选项时，只有属于已提交事务的行才会显示在V $ LOGMNR_CONTENTS视图中。">显示仅提交事务</a>以获取有关<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>的<code class="codeph">COMMITTED_DATA_ONLY</code>选项的更多信息</p>
                     </div>
                     <div class="infoboxnote" id="GUID-7F1199AB-84E5-49C7-80C1-30D74800BA91__BECVLOGMNR_CONTENTSVIEWIMPACTOFQUER-FEC349FD">
                        <p class="notep1">注意：</p>
                        <p>由于LogMiner仅在响应查询时填充<code class="codeph">V$LOGMNR_CONTENTS</code>视图，并且未将请求的数据存储在数据库中，因此以下情况属实：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每次查询<code class="codeph">V$LOGMNR_CONTENTS</code> ，LogMiner都会分析您请求的数据的重做日志文件。</p>
                           </li>
                           <li>
                              <p>查询占用的内存量不依赖于必须返回以满足查询的行数。</p>
                           </li>
                           <li>
                              <p>返回所请求数据所花费的时间取决于必须挖掘以查找该数据的重做日志数据的数量和类型。</p>
                           </li>
                        </ul>
                     </div>
                     <p>由于上一个注释中所述的原因，如果您需要维护数据以供进一步分析，Oracle建议您创建一个表来临时保存<code class="codeph">V$LOGMNR_CONTENTS</code>查询的结果，特别是如果查询返回的数据量是与LogMiner必须分析以提供该数据的重做数据量相比较小。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="您可以通过查询V $ LOGMNR_CONTENTS视图来访问感兴趣的重做数据。">查询重做感兴趣数据的V $ LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-CF064432-57A0-4891-ABE5-800DF327615A" name="GUID-CF064432-57A0-4891-ABE5-800DF327615A"></a><h4 id="SUTIL-GUID-CF064432-57A0-4891-ABE5-800DF327615A" class="sect4"><span class="enumeration_section">22.6.2</span>根据列值查询V $ LOGMNR_CONTENTS</h4>
                  <div>
                     <p>LogMiner允许您根据列值进行查询。</p>
                     <p>例如，您可以执行查询以显示<code class="codeph">hr.employees</code>表的所有更新，这些更新会增加超过特定金额的<code class="codeph">salary</code> 。诸如此类的数据可用于分析系统行为和执行审计任务。
                     </p>
                     <p>使用两个挖掘函数执行从重做日志文件中提取LogMiner数据： <code class="codeph">DBMS_LOGMNR.MINE_VALUE</code>和<code class="codeph">DBMS_LOGMNR.COLUMN_PRESENT</code> 。这些矿山支持功能是由提供<code class="codeph">REDO_VALUE</code>和<code class="codeph">UNDO_VALUE</code>在列<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </p>
                     <p>以下是如何使用<code class="codeph">MINE_VALUE</code>函数选择<code class="codeph">hr.employees</code>所有更新的<code class="codeph">hr.employees</code> ，该更新将<code class="codeph">salary</code>列增加到其原始值的两倍以上：</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO FROM V $ LOGMNR_CONTENTS WHERE SEG_NAME ='EMPLOYEES'和SEG_OWNER ='HR'和OPERATION ='UPDATE'和DBMS_LOGMNR.MINE_VALUE（REDO_VALUE，'HR.EMPLOYEES.SALARY'）&gt; 2 * DBMS_LOGMNR.MINE_VALUE（UNDO_VALUE，'HR .EMPLOYEES.SALARY'）;</pre><p>如此示例所示， <code class="codeph">MINE_VALUE</code>函数有两个参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>第一个指定是否挖掘数据的重做（ <code class="codeph">REDO_VALUE</code> ）或撤消（ <code class="codeph">UNDO_VALUE</code> ）部分。数据的重做部分是插入，更新或删除操作后列中的数据;数据的撤消部分是插入，更新或删除操作之前的列中的数据。将<code class="codeph">REDO_VALUE</code>视为新值并将<code class="codeph">UNDO_VALUE</code>视为旧值可能会有所帮助。
                           </p>
                        </li>
                        <li>
                           <p>第二个参数是一个字符串，它指定要挖掘的列的完全限定名称（在本例中为<code class="codeph">hr.employees.salary</code> ）。<code class="codeph">MINE_VALUE</code>函数始终返回可以转换回原始数据类型的字符串。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A89673AD-EC53-4BA0-B298-D62291C5728B">MINE_VALUE函数返回的NULL值的含义</a><br>描述<code class="codeph">MINE_VALUE</code>函数返回的<code class="codeph">NULL</code>值的含义。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290">MINE_VALUE和COLUMN_PRESENT函数的使用规则</a><br>描述适用于<code class="codeph">MINE_VALUE</code>和<code class="codeph">COLUMN_PRESENT</code>函数的使用规则。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C">使用MINE_VALUE函数获取NCHAR值时的限制</a><br>描述使用<code class="codeph">MINE_VALUE</code>函数时的限制。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="您可以通过查询V $ LOGMNR_CONTENTS视图来访问感兴趣的重做数据。">查询重做感兴趣数据的V $ LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1568"></a><div class="props_rev_3"><a id="GUID-A89673AD-EC53-4BA0-B298-D62291C5728B" name="GUID-A89673AD-EC53-4BA0-B298-D62291C5728B"></a><h5 id="SUTIL-GUID-A89673AD-EC53-4BA0-B298-D62291C5728B" class="sect5"><span class="enumeration_section">22.6.2.1</span> MINE_VALUE函数返回的NULL值的含义</h5>
                     <div>
                        <p>描述<code class="codeph">MINE_VALUE</code>函数返回的<code class="codeph">NULL</code>值的含义。
                        </p>
                        <p>如果<code class="codeph">MINE_VALUE</code>函数返回<code class="codeph">NULL</code>值，那么它可能意味着：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>指定的列不存在于数据的重做或撤消部分中。</p>
                           </li>
                           <li>
                              <p>指定的列存在且具有空值。</p>
                           </li>
                        </ul>
                        <p>要区分这两种情况，请使用<code class="codeph">DBMS_LOGMNR</code> 。 <code class="codeph">COLUMN_PRESENT</code>函数，如果该列存在于数据的重做或撤消部分，则返回<code class="codeph">1</code> 。否则，它返回<code class="codeph">0</code> 。例如，假设您想要找出修改<code class="codeph">salary</code>列中的值的增量以及相应的事务标识符。您可以发出以下SQL查询：</p><pre class="oac_no_warn" dir="ltr">SELECT（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，（DBMS_LOGMNR.MINE_VALUE（REDO_VALUE，'HR.EMPLOYEES.SALARY'） -  DBMS_LOGMNR.MINE_VALUE（UNDO_VALUE，'HR.EMPLOYEES.SALARY'））AS INCR_SAL来自V $ LOGMNR_CONTENTS WHERE OPERATION ='UPDATE'和DBMS_LOGMNR .COLUMN_PRESENT（REDO_VALUE，'HR.EMPLOYEES.SALARY'）= 1 AND DBMS_LOGMNR.COLUMN_PRESENT（UNDO_VALUE，'HR.EMPLOYEES.SALARY'）= 1;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner允许您根据列值进行查询。">基于列值查询V $ LOGMNR_CONTENTS</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1569"></a><div class="props_rev_3"><a id="GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290" name="GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290"></a><h5 id="SUTIL-GUID-66897AA4-7B9D-4C2C-9FC3-64DF9A292290" class="sect5"><span class="enumeration_section">22.6.2.2</span> MINE_VALUE和COLUMN_PRESENT函数的使用规则</h5>
                     <div>
                        <p>描述适用于<code class="codeph">MINE_VALUE</code>和<code class="codeph">COLUMN_PRESENT</code>函数的使用规则。
                        </p>
                        <p>特别：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它们只能在LogMiner会话中使用。</p>
                           </li>
                           <li>
                              <p>它们必须在<code class="codeph">V$LOGMNR_CONTENTS</code>视图中的select操作的上下文中启动。
                              </p>
                           </li>
                           <li>
                              <p>它们不支持<code class="codeph">LONG</code> ， <code class="codeph">LONG RAW,</code> <code class="codeph">CLOB,</code> <code class="codeph">BLOB,</code> <code class="codeph">NCLOB</code> ， <code class="codeph">ADT</code>或<code class="codeph">COLLECTION</code>数据类型。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner允许您根据列值进行查询。">基于列值查询V $ LOGMNR_CONTENTS</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4342"></a><div class="props_rev_3"><a id="GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C" name="GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C"></a><h5 id="SUTIL-GUID-7C1FB699-52D6-4B93-A676-C9426D32FE3C" class="sect5"><span class="enumeration_section">22.6.2.3</span>使用MINE_VALUE函数获取NCHAR值时的限制</h5>
                     <div>
                        <p>描述使用<code class="codeph">MINE_VALUE</code>函数时的限制。
                        </p>
                        <div class="section">
                           <p>如果使用<code class="codeph">DBMS_LOGMNR.MINE_VALUE</code>函数来获取包含在数据库字符集中找不到的字符的<code class="codeph">NCHAR</code>值，则返回这些字符作为数据库字符集的替换字符（例如，反转的问号）。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-CF064432-57A0-4891-ABE5-800DF327615A" title="LogMiner允许您根据列值进行查询。">基于列值查询V $ LOGMNR_CONTENTS</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DFDDD830-650B-4E46-A114-105F2995F839" name="GUID-DFDDD830-650B-4E46-A114-105F2995F839"></a><h4 id="SUTIL-GUID-DFDDD830-650B-4E46-A114-105F2995F839" class="sect4"><span class="enumeration_section">22.6.3</span>基于XMLType列和表查询V $ LOGMNR_CONTENTS</h4>
                  <div>
                     <p>LogMiner支持为<code class="codeph">XMLType</code>列生成的重做。在兼容性设置为11.0.0.0或更高版本时生成重做时，支持存储为<code class="codeph">CLOB</code> <code class="codeph">XMLType</code>数据。
                     </p>
                     <p>在兼容性设置为11.2.0.3及更高版本时生成的重做支持存储为对象关系和二进制XML的<code class="codeph">XMLType</code>数据。
                     </p>
                     <p>LogMiner以不同的方式在<code class="codeph">V$LOGMNR_CONTENTS</code>中呈现<code class="codeph">SQL_REDO</code> ，具体取决于<code class="codeph">XMLType</code>存储。在所有情况下， <code class="codeph">SQL_REDO</code>列的内容与<code class="codeph">STATUS</code>列一起需要仔细审查，并且通常需要重新组装才能生成SQL或PL / SQL语句以重做更改。可能存在无法使用<code class="codeph">SQL_REDO</code>数据构造此类更改的情况。以下小节中的示例基于存储为<code class="codeph">CLOB</code> <code class="codeph">XMLType</code> ，它通常最简单地用于重建完整的行更改。
                     </p>
                     <div class="infoboxnote" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__XMLTYPEDATASTOREDASCLOBISDEPRECATED-FEC446CD">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用存储为<code class="codeph">CLOB</code> <code class="codeph">XMLType</code>数据。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__QUERYINGVLOGMNR_CONTENTSFORCHANGEST-FEC44E6C">查询V $ LOGMNR_CONTENTS以更改具有XMLType列的表</p>
                        <p>本节中的示例适用于名为<code class="codeph">XML_CLOB_COL_TAB</code>的表，其中包含以下列：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>f1 <code class="codeph">NUMBER</code></p>
                           </li>
                           <li>
                              <p>f2 <code class="codeph">VARCHAR2(100)</code></p>
                           </li>
                           <li>
                              <p>f3 <code class="codeph">XMLTYPE</code></p>
                           </li>
                           <li>
                              <p>f4 <code class="codeph">XMLTYPE</code></p>
                           </li>
                           <li>
                              <p>f5 <code class="codeph">VARCHAR2(10)</code></p>
                           </li>
                        </ul>
                        <p>假设已使用日志和<code class="codeph">COMMITED_DATA_ONLY</code>选项启动LogMiner会话。对<code class="codeph">V$LOGMNR_CONTENTS</code>执行以下查询以更改<code class="codeph">XML_CLOB_COL_TAB</code>表。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT操作，状态，SQL_REDO来自V $ LOGMNR_CONTENTS WHERE SEG_OWNER ='SCOTT'和TABLE_NAME ='XML_CLOB_COL_TAB';</pre><p>查询输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">操作状态SQL_REDO INSERT 0插入“SCOTT”。“XML_CLOB_COL_TAB”（“F1”，“F2”，“F5”）值（'5010'，'Aho40431'，'PETER'）XML DOC BEGIN 5更新“SCOTT”。 “XML_CLOB_COL_TAB”设置a。“F3”= XMLType（：1）其中a。“F1”='5010'和a。“F2”='Aho40431'和a。“F5”='PETER'XML DOC WRITE 5 XML数据XML DOC WRITE 5 XML数据XML DOC WRITE 5 XML数据XML DOC END 5</pre><p>在<code class="codeph">XML DOC WRITE</code>操作的<code class="codeph">SQL_REDO</code>列中，将存在XML文档的实际数据。它不是字符串'XML Data'。
                        </p>
                        <p>此输出显示插入到具有<code class="codeph">XMLType</code>列的表中的一般模型如下：</p>
                        <ol>
                           <li>
                              <p>带有所有标量列的初始插入。</p>
                           </li>
                           <li>
                              <p>带有update语句的<code class="codeph">XML DOC BEGIN</code>操作，该语句使用绑定变量设置一个<code class="codeph">XMLType</code>列的值。
                              </p>
                           </li>
                           <li>
                              <p>一个或多个<code class="codeph">XML DOC WRITE</code>操作，包含XML文档的数据。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">XML DOC END</code>操作，用于指示已查看该XML文档的所有数据。
                              </p>
                           </li>
                           <li>
                              <p>如果表中有多个<code class="codeph">XMLType</code>列，则将对原始DML修改的每个<code class="codeph">XMLType</code>列重复步骤2到4。</p>
                           </li>
                        </ol>
                        <p>如果XML文档未存储为外联列，则该列将不存在<code class="codeph">XML DOC BEGIN</code> ， <code class="codeph">XML DOC WRITE</code>或<code class="codeph">XML DOC END</code>操作。该文档将包含在类似于以下内容的更新声明中：</p><pre class="oac_no_warn" dir="ltr">操作状态SQL_REDO UPDATE 0更新“SCOTT”。“XML_CLOB_COL_TAB”设置a。“F3”= XMLType（'&lt;？xml版本=“1.0”？&gt; &lt;PO pono =“1”&gt; &lt;PNAME&gt; Po_99 &lt;/ PNAME&gt; &lt;CUSTNAME&gt; Dave Davids &lt;/ CUSTNAME&gt; &lt;/ PO&gt;'）其中a。“F1”='5006'和a。“F2”=' Janosik'和a。“F5”='MMM'</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFDDD830-650B-4E46-A114-105F2995F839__QUERYINGVLOGMNR_CONTENTSFORCHANGEST-FEC4598D">查询V $ LOGMNR_CONTENTS以更改XMLType表</p>
                        <p>DML到<code class="codeph">XMLType</code>表与DML到<code class="codeph">XMLType</code>列略有不同。XML文档表示<code class="codeph">XMLType</code>表中行的值。与<code class="codeph">XMLType</code>列情况不同，无法执行初始插入，然后是包含XML文档的更新。相反，必须先组装整个文档，然后才能将任何内容插入到表中。
                        </p>
                        <p><code class="codeph">XMLType</code>表的另一个区别是存在<code class="codeph">OBJECT_ID</code>列。对象标识符用于唯一标识对象表中的每个对象。对于<code class="codeph">XMLType</code>表，当将行插入表中时，Oracle数据库将生成此值。无法使用SQL将<code class="codeph">OBJECT_ID</code>值直接插入表中。因此，LogMiner无法生成包含此值的可执行<code class="codeph">SQL_REDO</code> 。
                        </p>
                        <p><code class="codeph">V$LOGMNR_CONTENTS</code>视图有一个新的<code class="codeph">OBJECT_ID</code>列，该列填充了<code class="codeph">XMLType</code>表的更改。此值是原始表中的对象标识符。但是，即使将相同的XML文档插入到同一<code class="codeph">XMLType</code>表中，也会生成新的对象标识符。<code class="codeph">XMLType</code>表上的后续DML（例如更新和删除）的<code class="codeph">SQL_REDO</code>将在<code class="codeph">WHERE</code>子句中包含对象标识符，以唯一标识原始表中的行。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B">使用带有XMLType数据的LogMiner时的限制</a><br>描述将LogMiner与XMLType数据一起使用时的限制。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89">用于组装XMLType数据的PL / SQL过程的示例</a><br>示例显示了一个过程，该过程可用于为包含异常XML数据的表挖掘和汇编XML重做。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-14D0D046-79B1-4A3F-8F6A-DC98598D2B7D" title="您可以通过查询V $ LOGMNR_CONTENTS视图来访问感兴趣的重做数据。">查询重做感兴趣数据的V $ LOGMNR_CONTENTS</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1571"></a><div class="props_rev_3"><a id="GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B" name="GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B"></a><h5 id="SUTIL-GUID-9797CFFF-033D-44F7-A3CD-0ADA0BA46C6B" class="sect5"><span class="enumeration_section">22.6.3.1</span>使用带有XMLType数据的LogMiner时的限制</h5>
                     <div>
                        <p>描述将LogMiner与XMLType数据一起使用时的限制。</p>
                        <p>只有在使用<code class="codeph">DBMS_LOGMNR.COMMITTED_DATA_ONLY</code>选项时才能挖掘<code class="codeph">XMLType</code>数据。否则，可能会显示不完整的更改，或者显示为XML的更改可能会显示为<code class="codeph">CLOB</code>更改，因为行更改的部分缺失。这可能导致这些SQL DML语句的<code class="codeph">SQL_REDO</code>不完整且无效。
                        </p>
                        <p>不会为更改<code class="codeph">XMLType</code>数据填充<code class="codeph">SQL_UNDO</code>列。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839" title="LogMiner支持为XMLType列生成的重做。在兼容性设置为11.0.0.0或更高版本时生成重做时，支持存储为CLOB的XMLType数据。">基于XMLType列和表查询V $ LOGMNR_CONTENTS</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1572"></a><div class="props_rev_3"><a id="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89" name="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89"></a><h5 id="SUTIL-GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89" class="sect5"><span class="enumeration_section">22.6.3.2用于汇编</span> XMLType数据的PL / SQL过程示例</h5>
                     <div>
                        <p>示例显示了一个过程，该过程可用于为包含异常XML数据的表挖掘和汇编XML重做。</p>
                        <p>这显示了如何使用临时LOB组装XML数据。组装XML文档后，可以以有意义的方式使用它。此示例在已汇编的文档中查询<code class="codeph">EmployeeName</code>元素，然后将返回的名称，XML文档和原始DML的<code class="codeph">SQL_REDO</code>在<code class="codeph">EMPLOYEE_XML_DOCS</code>表中。
                        </p>
                        <div class="infoboxnote" id="GUID-C4FEF4D3-2848-4030-951A-C4ADF1D9FD89__GUID-405ABA2D-15F8-4DCA-BA25-9CD8AF7B30B3">
                           <p class="notep1">注意：</p>
                           <p>此过程仅是示例，并且已简化。它仅用于说明可以使用LogMiner挖掘和组装具有<code class="codeph">XMLType</code>数据的表的DML。
                           </p>
                        </div>
                        <p>在调用此过程之前，必须将所有相关日志添加到LogMiner会话，并且必须使用<code class="codeph">COMMITTED_DATA_ONLY</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR()</code> 。然后可以使用包含要挖掘的XML数据的表的模式和表名来调用<code class="codeph">MINE_AND_ASSEMBLE()</code>过程。
                        </p><pre class="oac_no_warn" dir="ltr">- 用于存储汇编的XML文档的表创建表employee_xml_docs（employee_name varchar2（100），sql_stmt varchar2（4000），xml_doc SYS.XMLType）; - 汇编XML文档的过程创建或替换过程mine_and_assemble（varchar2中的schemaname，varchar2中的tablename）AS loc_c CLOB; row_op VARCHAR2（100）; row_status NUMBER; stmt VARCHAR2（4000）; row_redo VARCHAR2（4000）; xml_data VARCHAR2（32767 CHAR）; data_len NUMBER; xml_lob clob; xml_doc XMLType; BEGIN  - 查找V $ LOGMNR_CONTENTS中适用于相应模式的行 - 和表名，但将其限制为有效sql或需要汇编的行 - 因为它们是XML文档。对于项目（SELECT操作，状态，sql_redo FROM v $ logmnr_contents，其中seg_owner = schemaname和table_name = tablename和status IN（DBMS_LOGMNR.VALID_SQL，DBMS_LOGMNR.ASSEMBLY_REQUIRED_SQL））LOOP row_op：= item.operation; row_status：= item.status; row_redo：= item.sql_redo; CASE row_op WHEN'XML DOC BEGIN'那么开始 - 保存语句并开始汇编XML数据stmt：= row_redo; xml_data：=''; data_len：= 0; DBMS_LOB.CreateTemporary（xml_lob，TRUE）;结束;当'XML DOC写'然后开始 - 继续汇编XML数据xml_data：= xml_data || row_redo; data_len：= data_len + length（row_redo）; DBMS_LOB.WriteAppend（xml_lob，length（row_redo），row_redo）;结束;当'XML DOC结束'然后开始 - 现在组装完成了，我们可以使用XML文档xml_doc：= XMLType.createXML（xml_lob）;插入employee_xml_docs值（extractvalue（xml_doc，'/ EMPLOYEE / NAME'），stmt，xml_doc）;承诺; -  reset xml_data：=''; data_len：= 0; xml_lob：= NULL;结束;什么时候'插入'然后开始stmt：= row_redo;结束;当'更新'然后开始stmt：= row_redo;结束;当'内部'那么DBMS_OUTPUT.PUT_LINE（'跳过标记为INTERNAL'的行）; ELSE BEGIN stmt：= row_redo; DBMS_OUTPUT.PUT_LINE（'Other  - '|| stmt）;如果是row_status！= DBMS_LOGMNR.VALID_SQL然后是DBMS_OUTPUT.PUT_LINE（'跳过标记为不可执行的行'）; ELSE dbms_output.put_line（'Status：'|| row_status）;万一;结束;结束案例;结束LOOP;结束; /显示错误;</pre><p>然后可以调用此过程来挖掘对<code class="codeph">SCOTT.XML_DATA_TAB</code>的更改并应用DML。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE MINE_AND_ASSEMBLE（'SCOTT'，'XML_DATA_TAB'）;</pre><p>作为此过程的结果， <code class="codeph">EMPLOYEE_XML_DOCS</code>表将为每个已更改的外联XML列提供一行。<code class="codeph">EMPLOYEE_NAME</code>列将具有从XML文档和<code class="codeph">SQL_STMT</code>列中提取的值，而<code class="codeph">XML_DOC</code>列将反映原始行更改。
                        </p>
                        <p>以下是对结果表的示例查询，该查询仅显示员工姓名和SQL语句：</p><pre class="oac_no_warn" dir="ltr">从EMPLOYEE_XML_DOCS中选择EMPLOYEE_NAME，SQL_STMT; EMPLOYEE_NAME SQL_STMT Scott Davis更新“SCOTT”。“XML_DATA_TAB”a a set。“F3”= XMLType（：1）其中a。“F1”='5000'和a。“F2”='陈'和a。“F5 “='JJJ'理查德哈里更新”SCOTT“。”XML_DATA_TAB“a set a。”F4“= XMLType（：1）其中a。”F1“='5000'和a。”F2“='陈'和a 。“F5”='JJJ'Margaret Sally更新“SCOTT”。“XML_DATA_TAB”a set a。“F4”= XMLType（：1）其中a。“F1”='5006'和a。“F2”='Janosik '和a。“F5”='MMM'</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-DFDDD830-650B-4E46-A114-105F2995F839" title="LogMiner支持为XMLType列生成的重做。在兼容性设置为11.0.0.0或更高版本时生成重做时，支持存储为CLOB的XMLType数据。">基于XMLType列和表查询V $ LOGMNR_CONTENTS</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" name="GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24"></a><h3 id="SUTIL-GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" class="sect3"><span class="enumeration_section">22.7</span>过滤和格式化返回V $ LOGMNR_CONTENTS的数据</h3>
               <div>
                  <p>LogMiner可能会处理大量信息。您可以限制返回到<code class="codeph">V$LOGMNR_CONTENTS</code>视图的信息以及返回的速度。
                  </p>
                  <p>以下部分演示了如何指定这些限制及其对查询<code class="codeph">V$LOGMNR_CONTENTS</code>时返回的数据的影响。</p>
                  <p>此外，LogMiner还提供了格式化返回到<code class="codeph">V$LOGMNR_CONTENTS</code>的数据的功能，如以下部分所述：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599" title="默认情况下，ROWID子句包含在重构的SQL_REDO和SQL_UNDO语句中，语句以分号结束。">格式化重建的SQL语句以便重新执行</a></p>
                     </li>
                     <li>
                        <p><a href="oracle-logminer-utility.html#GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" title="LogMiner提供PRINT_PRETTY_SQL选项，该选项用于格式化返回数据的外观以提高可读性。">格式化返回数据的外观以提高可读性</a></p>
                     </li>
                  </ul>
                  <p>您可以使用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程的参数或选项请求每个过滤和格式化功能。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536">仅显示已提交的事务</a><br>当使用<code class="codeph">COMMITTED_DATA_ONLY</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，只属于提交的事务的行会显示在<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9">跳过重做损坏</a><br>当您使用<code class="codeph">SKIP_CORRUPTION</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，在重做日志文件中的任何损坏的过程中从选择操作跳过<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5">按时间过滤数据</a><br>要按时间过滤数据，请在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程中设置<code class="codeph">STARTTIME</code>和<code class="codeph">ENDTIME</code>参数。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3">通过SCN过滤数据</a><br>为了通过SCN（系统改变号）过滤数据，使用<code class="codeph">STARTSCN</code>和<code class="codeph">ENDSCN</code>参数给PL / SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599">格式化重建的SQL语句以便重新执行</a><br>默认情况下， <code class="codeph">ROWID</code>子句包含在重构的<code class="codeph">SQL_REDO</code>和<code class="codeph">SQL_UNDO</code>语句中，语句以分号结束。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623">格式化返回数据的外观以提高可读性</a><br>LogMiner提供<code class="codeph">PRINT_PRETTY_SQL</code>选项，该选项用于格式化返回数据的外观以提高可读性。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1574"></a><div class="props_rev_3"><a id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" name="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536"></a><h4 id="SUTIL-GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536" class="sect4"><span class="enumeration_section">22.7.1</span>仅显示已提交的事务</h4>
                  <div>
                     <p>当使用<code class="codeph">COMMITTED_DATA_ONLY</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，只属于提交的事务的行会显示在<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </p>
                     <p>这使您可以筛选回滚事务，正在进行的事务和内部操作。</p>
                     <p>要启用此选项，请在启动LogMiner时指定它，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（OPTIONS =&gt;  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY）;</pre><p>指定<code class="codeph">COMMITTED_DATA_ONLY</code>选项时，LogMiner将属于同一事务的所有DML操作组合在一起。事务按照提交的顺序返回。
                     </p>
                     <div class="infoboxnote" id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536__GUID-CE11261A-B2D4-4D23-8B7D-798BFFEBF9DE">
                        <p class="notep1">注意：</p>
                        <p>如果指定了<code class="codeph">COMMITTED_DATA_ONLY</code>选项并且您发出了查询，则LogMiner会将内存中单个事务中的所有重做记录分段，直到LogMiner找到该事务的提交记录。因此，可以耗尽内存，在这种情况下将返回“Out of Memory”错误。如果发生这种情况，则必须在未指定<code class="codeph">COMMITTED_DATA_ONLY</code>选项的情况下重新启动LogMiner，然后重新发出查询。
                        </p>
                     </div>
                     <p>默认情况下，LogMiner显示与所有事务对应的行，并按重做日志文件中遇到的顺序返回它们。</p>
                     <p>例如，假设您在未指定<code class="codeph">COMMITTED_DATA_ONLY</code>选项的情况下启动LogMiner并执行以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，USERNAME，SQL_REDO来自V $ LOGMNR_CONTENTS WHERE USERNAME！='SYS'和SEG_OWNER为空或SEG_OWNER不在（'SYS'，'SYSTEM'）;</pre><p>输出如下。返回已提交和未提交的事务，并且来自不同事务的行交织在一起。</p><pre class="oac_no_warn" dir="ltr">XID USERNAME SQL_REDO 1.15.3045 RON set transaction read write; 1.15.3045 RON插入“HR”。“JOBS”（“JOB_ID”，“JOB_TITLE”，“MIN_SALARY”，“MAX_SALARY”）值（'9782'，'HR_ENTRY'，NULL，NULL）; 1.18.3046 JANE设置事务读写; 1.18.3046 JANE插入“OE”。“CUSTOMERS”（“CUSTOMER_ID”，“CUST_FIRST_NAME”，“CUST_LAST_NAME”，“CUST_ADDRESS”，“PHONE_NUMBERS”，“NLS_LANGUAGE”，“NLS_TERRITORY”，“CREDIT_LIMIT”，“CUST_EMAIL”， “ACCOUNT_MGR_ID”）值（'9839'，'Edgar'，'Cummings'，NULL，NULL，NULL，NULL，NULL，NULL，NULL）; 1.9.3041 RAJIV设置事务读写; 1.9.3041 RAJIV插入“OE”。“CUSTOMERS”（“CUSTOMER_ID”，“CUST_FIRST_NAME”，“CUST_LAST_NAME”，“CUST_ADDRESS”，“PHONE_NUMBERS”，“NLS_LANGUAGE”，“NLS_TERRITORY”，“CREDIT_LIMIT”，“CUST_EMAIL”， “ACCOUNT_MGR_ID”）值（'9499'，'Rodney'，'Emerson'，NULL，NULL，NULL，NULL，NULL，NULL，NULL）; 1.15.3045 RON提交; 1.8.3054 RON设置事务读写; 1.8.3054 RON插入“HR”。“JOBS”（“JOB_ID”，“JOB_TITLE”，“MIN_SALARY”，“MAX_SALARY”）值（'9566'，'FI_ENTRY'，NULL，NULL）; 1.18.3046 JANE承诺; 1.11.3047 JANE设置事务读写; 1.11.3047 JANE插入“OE”。“CUSTOMERS”（“CUSTOMER_ID”，“CUST_FIRST_NAME”，“CUST_LAST_NAME”，“CUST_ADDRESS”，“PHONE_NUMBERS”，“NLS_LANGUAGE”，“NLS_TERRITORY”，“CREDIT_LIMIT”，“CUST_EMAIL”， “ACCOUNT_MGR_ID”）值（'8933'，'Ronald'，'Frost'，NULL，NULL，NULL，NULL，NULL，NULL，NULL）; 1.11.3047 JANE承诺; 1.8.3054 RON提交;</pre><p>现在假设您启动了LogMiner，但这次您指定了<code class="codeph">COMMITTED_DATA_ONLY</code>选项。如果再次执行上一个查询，则输出如下：</p><pre class="oac_no_warn" dir="ltr">1.15.3045 RON设置事务读写; 1.15.3045 RON插入“HR”。“JOBS”（“JOB_ID”，“JOB_TITLE”，“MIN_SALARY”，“MAX_SALARY”）值（'9782'，'HR_ENTRY'，NULL，NULL）; 1.15.3045 RON提交; 1.18.3046 JANE设置事务读写; 1.18.3046 JANE插入“OE”。“CUSTOMERS”（“CUSTOMER_ID”，“CUST_FIRST_NAME”，“CUST_LAST_NAME”，“CUST_ADDRESS”，“PHONE_NUMBERS”，“NLS_LANGUAGE”，“NLS_TERRITORY”，“CREDIT_LIMIT”，“CUST_EMAIL”， “ACCOUNT_MGR_ID”）值（'9839'，'Edgar'，'Cummings'，NULL，NULL，NULL，NULL，NULL，NULL，NULL）; 1.18.3046 JANE承诺; 1.11.3047 JANE设置事务读写; 1.11.3047 JANE插入“OE”。“CUSTOMERS”（“CUSTOMER_ID”，“CUST_FIRST_NAME”，“CUST_LAST_NAME”，“CUST_ADDRESS”，“PHONE_NUMBERS”，“NLS_LANGUAGE”，“NLS_TERRITORY”，“CREDIT_LIMIT”，“CUST_EMAIL”， “ACCOUNT_MGR_ID”）值（'8933'，'Ronald'，'Frost'，NULL，NULL，NULL，NULL，NULL，NULL，NULL）; 1.11.3047 JANE承诺; 1.8.3054 RON设置事务读写; 1.8.3054 RON插入“HR”。“JOBS”（“JOB_ID”，“JOB_TITLE”，“MIN_SALARY”，“MAX_SALARY”）值（'9566'，'FI_ENTRY'，NULL，NULL）; 1.8.3054 RON提交;</pre><p>由于1.15.3045事务的<code class="codeph">COMMIT</code>语句是在1.18.3046事务的<code class="codeph">COMMIT</code>语句之前发出的，因此首先返回整个1.15.3045事务。即使1.18.3046交易在1.15.3045交易之前开始，也是如此。没有返回1.9.3041事务，因为从未为它发出<code class="codeph">COMMIT</code>语句。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-6A2398F7-D484-495A-8AD2-0A6B34C03536__GUID-4B3D4439-E8C6-4D0E-8BED-311A4CAC7272">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="Examples using LogMiner.">使用</a> <code class="codeph">COMMITTED_DATA_ONLY</code>选项的完整示例，请参阅<a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="使用LogMiner的示例。">使用LogMiner</a>的示例</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1575"></a><div class="props_rev_3"><a id="GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9" name="GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9"></a><h4 id="SUTIL-GUID-FAA95EFA-4AC0-4F5B-BE30-D79A9AC4C6B9" class="sect4"><span class="enumeration_section">22.7.2</span>跳过重做损坏</h4>
                  <div>
                     <p>当您使用<code class="codeph">SKIP_CORRUPTION</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，在重做日志文件中的任何损坏的过程中从选择操作跳过<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </p>
                     <p>对于遇到的每个损坏的重做记录，返回一行，其中包含<code class="codeph">OPERATION</code>列中的值<code class="codeph">CORRUPTED_BLOCKS</code> ， <code class="codeph">STATUS</code>列中的值<code class="codeph">1343</code>以及<code class="codeph">INFO</code>列中跳过的块数。
                     </p>
                     <p>请注意，跳过的记录可能包括对损坏块中正在进行的事务的更改;此类更改不会反映在从<code class="codeph">V$LOGMNR_CONTENTS</code>视图返回的数据中。
                     </p>
                     <p>默认情况下，select操作在重做日志文件中遇到的第一次损坏时终止。</p>
                     <p>以下SQL示例显示了此选项的工作方式：</p><pre class="oac_no_warn" dir="ltr">- 添加感兴趣的重做日志文件。 -  EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  logfilename =&gt;'/ usr / oracle / data / db1arch_1_16_482701534.log' -  options =&gt; DBMS_LOGMNR.NEW）; - 启动LogMiner  -  EXECUTE DBMS_LOGMNR.START_LOGMNR（）; - 从V $ LOGMNR_CONTENTS视图中选择。此示例显示了损坏 - 在重做日志文件中。-  SELECT rbasqn，rbablk，rbabyte，operation，status，info FROM V $ LOGMNR_CONTENTS;第3行的错误：ORA-00368：重做日志块中的校验和错误ORA-00353：块6附近的日志损坏更改73528时间11/06/2011 11:30:23 ORA-00334：存档日志：/ usr / oracle / data /dbarch1_16_482701534.log  - 重新启动LogMiner。这次，指定SKIP_CORRUPTION选项。-  EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  options =&gt; DBMS_LOGMNR.SKIP_CORRUPTION）; - 再次从V $ LOGMNR_CONTENTS视图中选择。输出表明 - 跳过了损坏的块：CORRUPTED_BLOCKS在OPERATION  - 列中，1343在STATUS列中，并且跳过的损坏块数在INFO列中。-  SELECT rbasqn，rbablk，rbabyte，operation，status，info FROM V $ LOGMNR_CONTENTS; RBASQN RBABLK RBABYTE操作状态信息13 2 76 START 0 13 2 76 DELETE 0 13 3 100 INTERNAL 0 13 3 380 DELETE 0 13 0 0 CORRUPTED_BLOCKS 1343损坏的块4到19跳过13 20 116 UPDATE 0</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1576"></a><div class="props_rev_3"><a id="GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" name="GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5"></a><h4 id="SUTIL-GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" class="sect4"><span class="enumeration_section">22.7.3</span>按时间过滤数据</h4>
                  <div>
                     <p>要按时间过滤数据，请在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程中设置<code class="codeph">STARTTIME</code>和<code class="codeph">ENDTIME</code>参数。
                     </p>
                     <p>为了避免在调用PL / SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程中指定日期格式，可以首先使用SQL <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET NLS_DATE_FORMAT</code>语句，如以下示例所示。
                     </p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY HH24：MI：SS'; EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  DICTFILENAME =&gt;'/ oracle / database / _dictionary.ora'， -  STARTTIME =&gt; '01 -Jan-2012 08:30:00'， -  ENDTIME =&gt; '01 -Jan-2012 08:45 ：00' - ）;</pre><p>时间戳不应用于推断重做记录的排序。您可以使用SCN推断重做记录的顺序。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1577"></a><div class="props_rev_3"><a id="GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" name="GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3"></a><h4 id="SUTIL-GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" class="sect4"><span class="enumeration_section">22.7.4</span>通过SCN过滤数据</h4>
                  <div>
                     <p>为了通过SCN（系统改变号）过滤数据，使用<code class="codeph">STARTSCN</code>和<code class="codeph">ENDSCN</code>参数给PL / SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程。
                     </p>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  STARTSCN =&gt; 621047， -  ENDSCN =&gt; 625695， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  - ）;</pre><p>在指定了所有参数的情况下， <code class="codeph">STARTSCN</code>和<code class="codeph">ENDSCN</code>参数会覆盖<code class="codeph">STARTTIME</code>和<code class="codeph">ENDTIME</code>参数。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1578"></a><div class="props_rev_3"><a id="GUID-C2B8C741-9544-4A46-818E-16B233570599" name="GUID-C2B8C741-9544-4A46-818E-16B233570599"></a><h4 id="SUTIL-GUID-C2B8C741-9544-4A46-818E-16B233570599" class="sect4"><span class="enumeration_section">22.7.5</span>格式化重建的SQL语句以便重新执行</h4>
                  <div>
                     <p>默认情况下， <code class="codeph">ROWID</code>子句包含在重构的<code class="codeph">SQL_REDO</code>和<code class="codeph">SQL_UNDO</code>语句中，语句以分号结束。
                     </p>
                     <p>但是，您可以覆盖默认设置，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>启动LogMiner时指定<code class="codeph">NO_ROWID_IN_STMT</code>选项。
                           </p>
                           <p>这会从重构语句中排除<code class="codeph">ROWID</code>子句。由于数据库之间的行ID不一致，如果您打算针对与最初执行它们的数据库不同的数据库重新执行<code class="codeph">SQL_REDO</code>或<code class="codeph">SQL_UNDO</code>语句，请在启动LogMiner时指定<code class="codeph">NO_ROWID_IN_STMT</code>选项。
                           </p>
                        </li>
                        <li>
                           <p>启动LogMiner时指定<code class="codeph">NO_SQL_DELIMITER</code>选项。
                           </p>
                           <p>这会从重构语句中抑制分号。这对于打开游标然后执行重构语句的应用程序很有用。</p>
                        </li>
                     </ul>
                     <p>请注意，如果<code class="codeph">V$LOGMNR_CONTENTS</code>视图的<code class="codeph">STATUS</code>字段包含值<code class="codeph">2</code> （ <code class="codeph">invalid sql)</code> ，则无法执行关联的SQL语句。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1579"></a><div class="props_rev_3"><a id="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" name="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623"></a><h4 id="SUTIL-GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623" class="sect4"><span class="enumeration_section">22.7.6</span>为可读性格式化返回数据的外观</h4>
                  <div>
                     <p>LogMiner提供<code class="codeph">PRINT_PRETTY_SQL</code>选项，该选项用于格式化返回数据的外观以提高可读性。
                     </p>
                     <p>有时，查询可能会导致包含重构SQL语句的大量列，这些列可能在视觉上繁忙且难以阅读。LogMiner提供<code class="codeph">PRINT_PRETTY_SQL</code>选项来解决此问题。该<code class="codeph">PRINT_PRETTY_SQL</code>选项将<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>程序格式化重构的SQL语句如下，这使得它们更容易阅读：</p><pre class="oac_no_warn" dir="ltr">插入“HR”。“JOBS”值“JOB_ID”='9782'，“JOB_TITLE”='HR_ENTRY'，“MIN_SALARY”为空，“MAX_SALARY”为空;更新“HR”。“JOBS”设置“JOB_TITLE”='FI_ENTRY'，其中“JOB_TITLE”='HR_ENTRY'，ROWID ='AAAHSeAABAAAY + CAAX';更新“HR”。“JOBS”设置“JOB_TITLE”='FI_ENTRY'，其中“JOB_TITLE”='HR_ENTRY'，ROWID ='AAAHSeAABAAAY + CAAX';从“HR”中删除。“JOBS”，其中“JOB_ID”='9782'，“JOB_TITLE”='FI_ENTRY'和“MIN_SALARY”为空，“MAX_SALARY”为空，ROWID ='AAAHSeAABAAAY + CAAX';</pre><p>启用<code class="codeph">PRINT_PRETTY_SQL</code>选项时重建的SQL语句不可执行，因为它们不使用标准SQL语法。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-95841FA7-BE3F-4B78-B52B-47D5F6ED5623__GUID-DFB9B6E6-40BD-4386-B13F-30342DE13F6B">
                        <p class="notep1">也可以看看：</p>
                        <p> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="使用LogMiner的示例。">示例使用LogMiner</a>获取使用<code class="codeph">PRINT_PRETTY_SQL</code>选项的完整示例</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39" name="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39"></a><h3 id="SUTIL-GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39" class="sect3"><span class="enumeration_section">22.8</span>重新应用返回V $ LOGMNR_CONTENTS的DDL语句</h3>
               <div>
                  <p>您发出的某些DDL语句会导致Oracle在内部执行一个或多个其他DDL语句。</p>
                  <p>要从<code class="codeph">V$LOGMNR_CONTENTS</code>视图的<code class="codeph">SQL_REDO</code>或<code class="codeph">SQL_UNDO</code>列重新应用SQL DDL，因为它最初应用于数据库，请不要执行Oracle内部执行的语句。
                  </p>
                  <div class="infoboxnote" id="GUID-BA4A515F-D694-4A88-AA34-97DDD421EA39__IFYOUEXECUTEDMLSTATEMENTSTHATWEREEX-FEC8AB26">
                     <p class="notep1">注意：</p>
                     <p>如果您执行由Oracle内部执行的DML语句，那么您可能会损坏您的数据库。请参阅<a href="oracle-logminer-utility.html#GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0">示例4的</a>步骤5 <a href="oracle-logminer-utility.html#GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0">：使用重做日志文件中的LogMiner字典</a>作为示例。
                     </p>
                  </div>
                  <p>要区分用户发出的DDL语句和Oracle内部发布的语句，请查询<code class="codeph">V$LOGMNR_CONTENTS</code>的<code class="codeph">INFO</code>列。 <code class="codeph">INFO</code>列的值指示DDL是由用户还是由Oracle执行。
                  </p>
                  <p>要重新应用最初应用的SQL DDL，仅当<code class="codeph">INFO</code>列包含值<code class="codeph">USER_DDL.</code>时，才重新执行<code class="codeph">V$LOGMNR_CONTENTS</code>的<code class="codeph">SQL_REDO</code>或<code class="codeph">SQL_UNDO</code>列中包含的DDL SQL <code class="codeph">USER_DDL.</code></p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL4228"></a><a id="SUTIL4229"></a><a id="SUTIL4230"></a><a id="SUTIL1581"></a><div class="props_rev_3"><a id="GUID-4959F073-BE00-4170-BFDC-4722D5770639" name="GUID-4959F073-BE00-4170-BFDC-4722D5770639"></a><h3 id="SUTIL-GUID-4959F073-BE00-4170-BFDC-4722D5770639" class="sect3"><span class="enumeration_section">22.9</span>多次调用DBMS_LOGMNR.START_LOGMNR</h3>
               <div>
                  <p>您已成功调用即使在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>从所选<code class="codeph">V$LOGMNR_CONTENTS</code>视图，您可以拨打<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>再次没有结束当前的LogMiner会话，并且指定不同的选择和时间或SCN范围。
                  </p>
                  <p>以下列表说明了您可能希望执行此操作的原因：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您希望限制LogMiner必须分析的重做数据量。</p>
                     </li>
                     <li>
                        <p>您想指定不同的选项。例如，您可能决定指定<code class="codeph">PRINT_PRETTY_SQL</code>选项，或者您只想查看已提交的事务（因此您指定了<code class="codeph">COMMITTED_DATA_ONLY</code>选项）。
                        </p>
                     </li>
                     <li>
                        <p>您想要更改要分析的时间或SCN范围。</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-4959F073-BE00-4170-BFDC-4722D5770639__GUID-28BE8979-5A14-4125-B72B-D9913F275AFA">示例：多次调用DBMS_LOGMNR.START_LOGMNR</p>
                     <p>以下是多次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>可能有用的一些示例。
                     </p>
                     <p><span class="bold">示例1：仅挖掘重做日志文件中的数据子集</span></p>
                     <p>假设LogMiner必须挖掘的重做日志文件列表包括整周生成的重做日志文件。但是，您只想分析每天从12:00到1:00发生的事情。你可以通过以下方式最有效地做到：</p>
                     <ol>
                        <li>
                           <p>使用此星期一的时间范围调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。
                           </p>
                        </li>
                        <li>
                           <p>从<code class="codeph">V$LOGMNR_CONTENTS</code>视图中选择更改。
                           </p>
                        </li>
                        <li>
                           <p>一周中的每一天重复步骤1和2。</p>
                        </li>
                     </ol>
                     <p>如果本周重做数据的总量很大，则此方法将使整个分析更快，因为LogMiner只会读取列表中每个重做日志文件的一小部分。</p>
                     <p><span class="bold">示例2：调整时间范围或SCN范围</span></p>
                     <p>假设您指定重做日志文件列表并在启动LogMiner时指定时间（或SCN）范围。查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图时，您发现只有部分感兴趣的数据包含在您指定的时间范围内。您可以再次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>以将时间范围扩展一小时（或调整SCN范围）。
                     </p>
                     <p><span class="bold">示例3：分析重做日志文件到达远程数据库时</span></p>
                     <p>假设您编写了一个应用程序来分析更改或将更改从一个数据库复制到另一个数据库。源数据库将其重做日志文件发送到挖掘数据库并将其放入操作系统目录中。你的申请：</p>
                     <ol>
                        <li>
                           <p>将当前目录中的所有重做日志文件添加到重做日志文件列表中</p>
                        </li>
                        <li>
                           <p>使用适当的设置<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> <code class="codeph">V$LOGMNR_CONTENTS</code>并从<code class="codeph">V$LOGMNR_CONTENTS</code>视图中进行选择</p>
                        </li>
                        <li>
                           <p>添加新到达目录的其他重做日志文件</p>
                        </li>
                        <li>
                           <p>无限期地重复步骤2和3</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1582"></a><div class="props_rev_3"><a id="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" name="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E"></a><h3 id="SUTIL-GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" class="sect3"><span class="enumeration_section">22.10</span>补充记录</h3>
               <div>
                  <p>描述补充日志记录。</p>
                  <p>重做日志文件通常用于实例恢复和媒体恢复。此类操作所需的数据会自动记录在重做日志文件中。但是，基于重做的应用程序可能需要在重做日志文件中记录其他列。记录这些附加列的过程称为<span class="bold">补充日志记录。</span></p>
                  <p>默认情况下，Oracle数据库不提供任何补充日志记录，这意味着默认情况下LogMiner不可用。因此，在生成将由LogMiner分析的日志文件之前，必须至少启用最少的补充日志记录。</p>
                  <p>以下是可能需要其他列的情况示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将重构的SQL语句应用于其他数据库的应用程序必须通过一组唯一标识该行的列（例如，主键）来标识update语句，而不是通过<code class="codeph">V$LOGMNR_CONTENTS</code>返回的重构SQL中显示的<code class="codeph">ROWID</code>来标识更新语句。 view，因为一个数据库的<code class="codeph">ROWID</code>将不同，因此在另一个数据库中没有意义。
                        </p>
                     </li>
                     <li>
                        <p>应用程序可能要求记录整行的前映像，而不仅仅是已修改的列，以便跟踪行更改更有效。</p>
                     </li>
                  </ul>
                  <p><span class="bold">补充日志组</span>是启用补充日志记录时要记录的其他列的集合。有两种类型的补充日志组可确定记录日志组中的列的时间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">无条件补充日志组：</span>无论更新是否影响任何指定列，都会在更新行时记录指定列的前映像。这有时称为ALWAYS日志组。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">条件补充日志组：</span>仅当更新日志组中的至少一个列时，才会记录所有指定列的前映像。
                        </p>
                     </li>
                  </ul>
                  <p>补充日志组可以是系统生成的，也可以是用户定义的。</p>
                  <p>除了两种类型的补充日志记录之外，还有两个级别的补充日志记录，如以下部分所述：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3">数据库级补充日志记录</a><br>LogMiner提供不同类型的数据库级补充日志记录：最小补充日志记录，标识密钥日志记录和过程补充日志记录，如这些部分所述。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473">禁用数据库级补充日志记录</a><br>使用带有<code class="codeph">DROP SUPPLEMENTAL LOGGING</code>子句的SQL <code class="codeph">ALTER DATABASE</code>语句禁用数据库级补充日志记录。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F">表级补充记录</a><br>表级补充日志记录在表级别指定要补充记录的列。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B">跟踪LogMiner词典中的DDL语句</a><br>LogMiner从您在启动LogMiner时指定的LogMiner字典（在线目录，重做日志文件中的字典或平面文件）中自动构建自己的内部字典。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2">DDL_DICT_TRACKING和补充日志记录设置</a><br>描述组合字典跟踪和补充日志记录的各种设置时发生的交互。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023">DDL_DICT_TRACKING和指定时间或SCN范围</a><br>由于LogMiner的一定不要错过一个DDL语句，如果它要保证它的字典的一致性，可以LogMiner的开始读取重做日志文件的请求开始时间或SCN之前（如指定<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ）的时候<code class="codeph">DDL_DICT_TRACKING</code>启用选项。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E__GUID-8129DEE8-ADCB-4B26-9FC4-33C07F8ACDEB">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" title="描述如何查询多个视图以确定补充日志记录的当前设置。">查询补充日志记录设置的视图</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1583"></a><div class="props_rev_3"><a id="GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" name="GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3"></a><h4 id="SUTIL-GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" class="sect4"><span class="enumeration_section">22.10.1</span>数据库级补充日志记录</h4>
                  <div>
                     <p>LogMiner提供不同类型的数据库级补充日志记录：最小补充日志记录，标识密钥日志记录和过程补充日志记录，如这些部分所述。</p>
                     <p>最小的补充日志记录不会对生成重做日志文件的数据库施加显着的开销。但是，启用数据库范围的标识密钥日志记录会对生成重做日志文件的数据库施加开销。Oracle建议您至少为LogMiner启用最少的补充日志记录。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D">最小的补充记录</a><br>最小补充日志记录记录LogMiner识别，分组和合并与DML更改相关联的重做操作所需的最少量信息。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242">数据库级标识密钥记录</a><br>如果不在源数据库实例中挖掘重做日志文件，则必须使用标识密钥日志记录，例如，当重做日志文件将在逻辑备用数据库中挖掘时。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E6C98352-7048-45BF-9487-F33BC665F7D3">程序补充记录</a><br>过程补充日志记录使LogMiner将某些过程调用记录到重做，以便可以通过滚动升级或Oracle GoldenGate来复制它们。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1584"></a><div class="props_rev_3"><a id="GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D" name="GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D"></a><h5 id="SUTIL-GUID-82A335B2-9F8F-4A95-A314-2EECDB0B3D2D" class="sect5"><span class="enumeration_section">22.10.1.1</span>最小补充记录</h5>
                     <div>
                        <p>最小补充日志记录记录LogMiner识别，分组和合并与DML更改相关联的重做操作所需的最少量信息。</p>
                        <p>它确保LogMiner（以及构建在LogMiner技术上的任何产品）具有足够的信息来支持链式行和各种存储安排，例如集群表和索引组织表。要启用最少的补充日志记录，请执行以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner提供不同类型的数据库级补充日志记录：最小补充日志记录，标识密钥日志记录和过程补充日志记录，如这些部分所述。">数据库级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1585"></a><div class="props_rev_3"><a id="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" name="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242"></a><h5 id="SUTIL-GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" class="sect5"><span class="enumeration_section">22.10.1.2</span>数据库级标识密钥记录</h5>
                     <div>
                        <p>如果不在源数据库实例中挖掘重做日志文件，则必须使用标识密钥日志记录，例如，当重做日志文件将在逻辑备用数据库中挖掘时。</p>
                        <p>使用数据库标识密钥日志记录，您可以通过为SQL <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">ADD</code> <code class="codeph">SUPPLEMENTAL</code> <code class="codeph">LOG</code>语句指定以下一个或多个选项，为所有更新启用数据库范围的映像前日志记录：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ALL</code>系统生成的无条件补充日志组</p>
                              <p>此选项指定在更新行时，该行的所有列（LOB， <code class="codeph">LONGS</code>和<code class="codeph">ADT</code>除外）都放在重做日志文件中。
                              </p>
                              <p>要在数据库级别启用所有列日志记录，请执行以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE添加补充日志数据（全部）列;</pre></li>
                           <li>
                              <p><code class="codeph">PRIMARY KEY</code>系统生成的无条件补充日志组</p>
                              <p>每当更新包含主键的行时（即使主键中的值没有更改），此选项也会使数据库将行主键的所有列放在重做日志文件中。</p>
                              <p>如果表没有主键，但具有一个或多个非空唯一索引键约束或索引键，则选择其中一个唯一索引键作为唯一标识正在更新的行的记录。</p>
                              <p>如果表既没有主键也没有非空唯一索引键，则除了<code class="codeph">LONG</code>和LOB之外的所有列都被补充记录;这相当于为该行指定<code class="codeph">ALL</code>补充日志记录。因此，Oracle建议在使用数据库级主键补充日志记录时，将所有或大多数表定义为具有主键或唯一索引键。
                              </p>
                              <p>要在数据库级别启用主键日志记录，请执行以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE添加补充日志数据（主键）列;</pre></li>
                           <li>
                              <p>UNIQUE系统生成的条件补充日志组</p>
                              <p>如果修改了属于复合唯一键或位图索引的任何列，则此选项会使数据库将行的复合唯一键或位图索引的所有列放在重做日志文件中。唯一键可以是唯一约束或唯一索引。</p>
                              <p>要在数据库级别启用唯一索引键和位图索引日志记录，请执行以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE添加补充日志数据（独特）列;</pre></li>
                           <li>
                              <p><code class="codeph">FOREIGN KEY</code>系统生成的条件补充日志组</p>
                              <p>如果修改了属于外键的任何列，则此选项会使数据库将行的外键的所有列放在重做日志文件中。</p>
                              <p>要在数据库级别启用外键日志记录，请执行以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据（外键）列;</pre><div class="infoboxnote" id="GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242__GUID-BEA69A5E-779D-4BDE-8B3C-9F4D3995765D">
                                 <p class="notep1">注意：</p>
                                 <p>无论是否启用了标识密钥日志记录，LogMiner返回的SQL语句始终包含<code class="codeph">ROWID</code>子句。你可以滤除<code class="codeph">ROWID</code>使用条款<code class="codeph">NO_ROWID_IN_STMT</code>选项将<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程调用。有关详细信息，请参阅<a href="oracle-logminer-utility.html#GUID-C2B8C741-9544-4A46-818E-16B233570599" title="默认情况下，ROWID子句包含在重构的SQL_REDO和SQL_UNDO语句中，语句以分号结束。">格式化重新构建的SQL语句以进行重新执行</a> 。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>使用标识密钥记录时，请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果在启用标识密钥日志记录时数据库处于打开状态，则游标缓存中的所有DML游标都将失效。这可能会影响性能，直到重新填充游标缓存。</p>
                           </li>
                           <li>
                              <p>在数据库级别启用标识密钥日志记录时，将隐式启用最少的补充日志记录。</p>
                           </li>
                           <li>
                              <p>补充日志记录语句是累积的。如果发出以下SQL语句，则启用主键和唯一键补充日志记录：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据（PRIMARY KEY）列; ALTER DATABASE添加补充日志数据（独特）列;</pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner提供不同类型的数据库级补充日志记录：最小补充日志记录，标识密钥日志记录和过程补充日志记录，如这些部分所述。">数据库级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-E6C98352-7048-45BF-9487-F33BC665F7D3" name="GUID-E6C98352-7048-45BF-9487-F33BC665F7D3"></a><h5 id="SUTIL-GUID-E6C98352-7048-45BF-9487-F33BC665F7D3" class="sect5"><span class="enumeration_section">22.10.1.3</span>程序补充记录</h5>
                     <div>
                        <p>过程补充日志记录使LogMiner将某些过程调用记录到重做，以便可以通过滚动升级或Oracle GoldenGate来复制它们。</p>
                        <p>必须为滚动升级启用过程补充日志记录，并且Oracle GoldenGate支持使用<code class="codeph">SDO_TOPO_GEOMETRY</code>或<code class="codeph">SDO_GEORASTER</code>列复制AQ队列表，启用层次结构的表和表。使用以下SQL语句启用过程补充日志记录：</p><pre class="pre codeblock"><code>ALTER DATABASE添加补充日志数据，用于程序复制结束</code></pre><p>如果启用了过程补充日志记录，则除非首先删除过程补充日志记录，否则不能删除最少的补充日志记录。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D2DDD67C-E1CC-45A6-A2A7-198E4C142FA3" title="LogMiner提供不同类型的数据库级补充日志记录：最小补充日志记录，标识密钥日志记录和过程补充日志记录，如这些部分所述。">数据库级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1586"></a><div class="props_rev_3"><a id="GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473" name="GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473"></a><h4 id="SUTIL-GUID-64EB9DC1-CC04-40E4-B5ED-4568D4D7C473" class="sect4"><span class="enumeration_section">22.10.2</span>禁用数据库级补充日志记录</h4>
                  <div>
                     <p>使用带有<code class="codeph">DROP SUPPLEMENTAL LOGGING</code>子句的SQL <code class="codeph">ALTER DATABASE</code>语句禁用数据库级补充日志记录。
                     </p>
                     <p>您可以逐步删除补充日志记录属性。例如，假设您按以下顺序发出以下SQL语句：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;</code> <code class="codeph">ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS</code> ; <code class="codeph">ALTER DATABASE DROP SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;</code> <code class="codeph">ALTER DATABASE DROP SUPPLEMENTAL LOG DATA;</code>
</pre><p>这些陈述会产生以下影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个语句之后，启用主键补充日志记录。</p>
                        </li>
                        <li>
                           <p>在第二个语句之后，启用主键和唯一键补充日志记录。</p>
                        </li>
                        <li>
                           <p>在第三个语句之后，仅启用唯一密钥补充日志记录。</p>
                        </li>
                        <li>
                           <p>在第四个语句之后，不会禁用所有补充日志记录。返回以下错误： <code class="codeph">ORA-32589: unable to drop minimal supplemental logging</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>要禁用所有数据库补充日志记录，必须先禁用已启用的任何标识密钥日志记录，然后禁用最少的补充日志记录。以下示例显示了正确的顺序：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据（PRIMARY KEY）列; ALTER DATABASE添加补充日志数据（独特）列; ALTER DATABASE DROP SUPPLEMENTAL LOG DATA（PRIMARY KEY）COLUMNS; ALTER DATABASE DROP SUPPLEMENTAL LOG DATA（UNIQUE）COLUMNS; ALTER DATABASE DROP SUPPLEMENTAL LOG DATA;</pre><p>仅当未启用其他数据库级补充日志记录变量时，才允许删除最小补充日志数据。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1587"></a><div class="props_rev_3"><a id="GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" name="GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F"></a><h4 id="SUTIL-GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" class="sect4"><span class="enumeration_section">22.10.3</span>表级补充日志记录</h4>
                  <div>
                     <p>表级补充日志记录在表级别指定要补充记录的列。</p>
                     <p>您可以使用标识密钥日志记录或用户定义的条件和无条件补充日志组来记录补充信息，如以下各节所述。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-080102D4-B514-40FA-80F7-8461E819F5FE">表级标识密钥记录</a><br>表级别的标识密钥日志记录提供与数据库级别提供的选项相同的选项：all，primary key，foreign key和unique key。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-34912450-76D3-4A9C-9EBF-098F220192FD">表级用户定义的补充日志组</a><br>除了表级标识密钥日志记录之外，Oracle还支持用户定义的补充日志组。
                        </li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197">用户定义的补充日志组的使用说明</a><br>使用用户定义的补充日志组的提示。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1588"></a><div class="props_rev_3"><a id="GUID-080102D4-B514-40FA-80F7-8461E819F5FE" name="GUID-080102D4-B514-40FA-80F7-8461E819F5FE"></a><h5 id="SUTIL-GUID-080102D4-B514-40FA-80F7-8461E819F5FE" class="sect5"><span class="enumeration_section">22.10.3.1</span>表级标识密钥记录</h5>
                     <div>
                        <p>表级别的标识密钥日志记录提供与数据库级别提供的选项相同的选项：all，primary key，foreign key和unique key。</p>
                        <p>但是，在表级别指定标识密钥日志记录时，只会影响指定的表。例如，如果输入以下SQL语句（指定数据库级补充日志记录），则每当更改任何数据库表中的列时，包含该列的整行（LOB， <code class="codeph">LONG</code>和<code class="codeph">ADT</code>的列除外）将放在重做日志文件中：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据（全部）列;</pre><p>但是，如果您输入以下SQL语句（指定表级补充日志记录），那么只有当<code class="codeph">employees</code>表中的列更改时，表的整行（LOB， <code class="codeph">LONG</code>和<code class="codeph">ADT</code>除外）才是放在重做日志文件中。如果某个列在<code class="codeph">departments</code>表中更改，则只有更改的列将放在重做日志文件中。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES添加补充日志数据（全部）列;</pre><p>使用表级标识密钥日志记录时，请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果在表上启用标识密钥日志记录时数据库已打开，则游标高速缓存中该表的所有DML游标都将失效。这可能会影响性能，直到重新填充游标缓存。</p>
                           </li>
                           <li>
                              <p>补充日志记录语句是累积的。如果发出以下SQL语句，则启用主键和唯一索引键表级补充日志记录：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES添加补充日志数据（主键）列; ALTER TABLE HR.EMPLOYEES添加补充日志数据（独特）列;</pre></li>
                        </ul>
                        <p>有关每个标识密钥日志记录选项的说明，请参阅<a href="oracle-logminer-utility.html#GUID-E3E015C4-B0EB-4072-92A6-FD3079C68242" title="如果不在源数据库实例中挖掘重做日志文件，则必须使用标识密钥日志记录，例如，当重做日志文件将在逻辑备用数据库中挖掘时。">数据库级标识密钥日志</a>记录。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="表级补充日志记录在表级别指定要补充记录的列。">表级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1589"></a><div class="props_rev_3"><a id="GUID-34912450-76D3-4A9C-9EBF-098F220192FD" name="GUID-34912450-76D3-4A9C-9EBF-098F220192FD"></a><h5 id="SUTIL-GUID-34912450-76D3-4A9C-9EBF-098F220192FD" class="sect5"><span class="enumeration_section">22.10.3.2</span>表级用户定义的补充日志组</h5>
                     <div>
                        <p>除了表级标识密钥日志记录之外，Oracle还支持用户定义的补充日志组。</p>
                        <p>使用用户定义的补充日志组，您可以指定补充记录哪些列。您可以指定条件或无条件日志组，如下所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用户定义的无条件日志组</p>
                              <p>要启用使用用户定义的无条件日志组的补充日志记录，请使用<code class="codeph">ALWAYS</code>子句，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES添加补充日志组emp_parttime（EMPLOYEE_ID，LAST_NAME，DEPARTMENT_ID）总是;</pre><p>这将在<code class="codeph">hr.employees</code>表上创建一个名为<code class="codeph">emp_parttime</code>的日志组，该日志组包含<code class="codeph">employee_id</code> ， <code class="codeph">last_name</code>和<code class="codeph">department_id</code>列。每次在<code class="codeph">hr.employees</code>表上执行<code class="codeph">UPDATE</code>语句时都会记录这些列，无论更新是否影响这些列。（要在更新时记录整个行图像，请使用表级<code class="codeph">ALL</code>标识密钥记录，如前所述）。
                              </p>
                              <div class="infoboxnote" id="GUID-34912450-76D3-4A9C-9EBF-098F220192FD__GUID-656E0B11-3DC0-4FAE-B7B0-EA1146ABCE1E">
                                 <p class="notep1">注意：</p>
                                 <p>LOB， <code class="codeph">LONG</code>和<code class="codeph">ADT</code>列无法进行补充记录。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>用户定义的条件补充日志组</p>
                              <p>要启用使用用户定义的条件日志组的补充日志记录，请从SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中省略<code class="codeph">ALWAYS</code>子句，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES添加补充日志组emp_fulltime（EMPLOYEE_ID，LAST_NAME，DEPARTMENT_ID）;</pre><p>这将在表<code class="codeph">hr.employees</code>上创建名为<code class="codeph">emp_fulltime</code>的日志组。与前面的示例一样，它由<code class="codeph">employee_id</code> ， <code class="codeph">last_name</code>和<code class="codeph">department_id</code>列组成。但是因为省略了<code class="codeph">ALWAYS</code>子句，所以只有在至少更新其中一列时才会记录列的前映像。
                              </p>
                           </li>
                        </ul>
                        <p>对于无条件和条件用户定义的补充日志组，您可以通过指定<code class="codeph">NO LOG</code>选项显式指定日志组中的列从补充日志记录中排除。指定日志组并使用<code class="codeph">NO LOG</code>选项时，必须在日志组中至少指定一个没有<code class="codeph">NO LOG</code>选项的列，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE HR.EMPLOYEES添加补充日志组emp_parttime（DEPARTMENT_ID NO LOG，EMPLOYEE_ID）;</pre><p>这使您可以将此列与指定的补充日志组中的其他列相关联，以便对<code class="codeph">NO LOG</code>列的任何修改都会使补充日志组中的其他列放在重做日志文件中。例如，如果<code class="codeph">LONG</code>列发生更改，则记录组中的某些列可能很有用。您无法补充记录<code class="codeph">LONG</code>列本身;但是，您可以对该列使用更改来触发同一行中其他列的补充日志记录。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="表级补充日志记录在表级别指定要补充记录的列。">表级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1590"></a><div class="props_rev_3"><a id="GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197" name="GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197"></a><h5 id="SUTIL-GUID-C7FA40DF-EA93-40AA-BDE9-614CD96FE197" class="sect5"><span class="enumeration_section">22.10.3.3</span>用户定义的补充日志组的使用说明</h5>
                     <div>
                        <p>使用用户定义的补充日志组的提示。</p>
                        <p>指定用户定义的补充日志组时，请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>列可以属于多个补充日志组。但是，列的前映像仅记录一次。</p>
                           </li>
                           <li>
                              <p>如果您有条件地和无条件地指定要记录的相同列，则无条件地记录列。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-BCECDF33-10A7-4939-905E-A7C3A3FFA23F" title="表级补充日志记录在表级别指定要补充记录的列。">表级补充日志记录</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1591"></a><div class="props_rev_3"><a id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B" name="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B"></a><h4 id="SUTIL-GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B" class="sect4"><span class="enumeration_section">22.10.4</span>跟踪LogMiner字典中的DDL语句</h4>
                  <div>
                     <p>LogMiner从您在启动LogMiner时指定的LogMiner字典（在线目录，重做日志文件中的字典或平面文件）中自动构建自己的内部字典。</p>
                     <p>此字典提供数据库对象及其定义的快照。</p>
                     <p>如果您的LogMiner字典是在重做日志文件或者是一个平面文件，那么你可以使用<code class="codeph">DDL_DICT_TRACKING</code>选项的PL / SQL <code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>程序直接LogMiner的跟踪数据定义语言（DDL）语句。DDL跟踪使LogMiner能够成功跟踪对数据库对象所做的结构更改，例如从表中添加或删除列。例如：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（OPTIONS =&gt;  -  DBMS_LOGMNR.DDL_DICT_TRACKING + DBMS_LOGMNR.DICT_FROM_REDO_LOGS）;</pre><p>有关完整示例，请参阅<a href="oracle-logminer-utility.html#GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F">示例5：在内部字典中跟踪DDL语句</a> 。
                     </p>
                     <p>设置此选项后，LogMiner会将重做日志文件中的任何DDL语句应用于其内部字典。</p>
                     <div class="infoboxnote" id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B__GUID-B8808527-48A6-40E8-A7DD-9454BEEB48D6">
                        <p class="notep1">注意：</p>
                        <p>通常，最好保持启用补充日志记录和DDL跟踪功能，因为如果它们未启用且发生DDL事件，则LogMiner会将一些重做数据作为二进制数据返回。此外，可能会发生元数据版本不匹配。</p>
                     </div>
                     <p>启用<code class="codeph">DDL_DICT_TRACKING,</code>可以正确显示在提取LogMiner字典后创建的表上执行的数据操作语言（DML）操作。
                     </p>
                     <p>例如，如果通过两个连续的DDL操作更新表<code class="codeph">employees</code> ，以便在一个操作中添加列<code class="codeph">gender</code> ，并且在下一个操作中删除列<code class="codeph">commission_pct</code> ，则LogMiner将为每个这些更改保留<code class="codeph">employees</code>版本化信息。这意味着LogMiner可以成功挖掘来自这些DDL更改之前和之后的重做日志文件，并且不会为<code class="codeph">SQL_REDO</code>或<code class="codeph">SQL_UNDO</code>列提供二进制数据。
                     </p>
                     <p>由于LogMiner会自动为数据库元数据分配版本，因此它会检测并通知您内部字典与重做日志文件中的字典之间的任何不匹配。如果LogMiner检测到不匹配，则它会在<code class="codeph">V$LOGMNR_CONTENTS</code>视图的<code class="codeph">SQL_REDO</code>列中生成二进制数据， <code class="codeph">INFO</code>列包含字符串“Dictionary Version Mismatch”， <code class="codeph">STATUS</code>列将包含值<code class="codeph">2</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-56743517-A0C0-4CCD-9D20-2883AFB5683B__GUID-4B6BAD13-5CD0-4B64-BD15-207943B8B5A8">
                        <p class="notep1">注意：</p>
                        <p>重要的是要了解LogMiner内部字典与平面文件，重做日志文件或在线目录中包含的LogMiner字典不同。LogMiner会更新其内部字典，但不会更新平面文件，重做日志文件或在线目录中包含的字典。</p>
                     </div>
                     <p>下面的列表描述了指定的要求<code class="codeph">DDL_DICT_TRACKING</code>与选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>程序。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DDL_DICT_TRACKING</code>选项对<code class="codeph">DICT_FROM_ONLINE_CATALOG</code>选项无效。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DDL_DICT_TRACKING</code>选项要求打开数据库。
                           </p>
                        </li>
                        <li>
                           <p>必须在数据库范围内启用补充日志记录，或者必须为感兴趣的表创建日志组。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1592"></a><div class="props_rev_3"><a id="GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2" name="GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2"></a><h4 id="SUTIL-GUID-815049EB-F41B-4EB9-97DC-913F40D43EC2" class="sect4"><span class="enumeration_section">22.10.5</span> DDL_DICT_TRACKING和补充日志记录设置</h4>
                  <div>
                     <p>描述组合字典跟踪和补充日志记录的各种设置时发生的交互。</p>
                     <p>请注意以下事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果启用了<code class="codeph">DDL_DICT_TRACKING</code> ，但未启用补充日志记录，并且：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在重做日志文件中遇到DDL事务，然后<code class="codeph">V$LOGMNR_CONTENTS</code>的查询将以ORA-01347错误终止。
                                 </p>
                              </li>
                              <li>
                                 <p>在重做日志文件中遇到DML事务，然后LogMiner不会假定其字典中当前版本的表（在DML下面）是正确的，并且<code class="codeph">V$LOGMNR_CONTENTS</code>将设置如下：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">SQL_REDO</code>列将包含二进制数据。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">STATUS</code>列将包含值<code class="codeph">2</code> （表示SQL无效）。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">INFO</code>列将包含字符串'Dictionary Mismatch'。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>如果未启用<code class="codeph">DDL_DICT_TRACKING</code>且未启用补充日志记录，并且DML操作中引用的列与LogMiner字典中的列匹配，则LogMiner假定其字典中的最新版本正确，并且将设置<code class="codeph">V$LOGMNR_CONTENTS</code>列如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>LogMiner将使用其字典中对象的定义为<code class="codeph">SQL_REDO</code>和<code class="codeph">SQL_UNDO</code>列生成值。
                                 </p>
                              </li>
                              <li>
                                 <p>status列将包含值<code class="codeph">3</code> （表示不保证SQL准确）。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">INFO</code>列将包含字符串'找不到补充日志数据'。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>如果未启用<code class="codeph">DDL_DICT_TRACKING</code>且未启用补充日志记录，并且表的重做日志文件中的修改列数多于表定义的LogMiner字典定义，则：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">SQL_REDO</code>和<code class="codeph">SQL_UNDO</code>列将包含字符串'Dictionary Version Mismatch'。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">STATUS</code>列将包含值<code class="codeph">2</code> （表示SQL无效）。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">INFO</code>列将包含字符串'Dictionary Mismatch'。
                                 </p>
                              </li>
                           </ul>
                           <p>另请注意，如果列的字典定义指示一种类型但列实际上是另一种类型，则可能会出现不可预测的行为。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1593"></a><div class="props_rev_3"><a id="GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023" name="GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023"></a><h4 id="SUTIL-GUID-AADE2750-DBE9-4E2F-81F1-BE32EFF2A023" class="sect4"><span class="enumeration_section">22.10.6</span> DDL_DICT_TRACKING和指定时间或SCN范围</h4>
                  <div>
                     <p>由于LogMiner的一定不要错过一个DDL语句，如果它要保证它的字典的一致性，可以LogMiner的开始读取重做日志文件的请求开始时间或SCN之前（如指定<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ）的时候<code class="codeph">DDL_DICT_TRACKING</code>启用选项。
                     </p>
                     <p>LogMiner开始读取重做日志文件的实际时间或SCN称为<span class="bold">所需的开始时间</span>或<span class="bold">所需的起始SCN</span> 。</p>
                     <p>从所需的开始时间或所需的起始SCN中不允许丢失重做日志文件（基于序列号）。</p>
                     <p>LogMiner确定它将开始读取重做日志数据的位置，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>加载字典后，第一次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，LogMiner将按以下某个选项开始读取，以较早的方式开始：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您要求的开始时间或SCN值</p>
                              </li>
                              <li>
                                 <p>字典转储的提交SCN</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>在对<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>后续调用中，LogMiner开始按照以下之一确定读取，无论哪个导致它最早开始：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您要求的开始时间或SCN值</p>
                              </li>
                              <li>
                                 <p>最早的DDL事务的开始，其中LogMiner尚未读取<code class="codeph">COMMIT</code>语句</p>
                              </li>
                              <li>
                                 <p>LogMiner读取的最高SCN</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>以下方案有助于说明这一点：</p>
                     <p>假设您创建一个包含五个重做日志文件的重做日志文件列表。假设第一个重做文件中包含字典，并且您指示要查看的更改（使用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ）将记录在第三个重做日志文件中。然后，您执行以下操作：</p>
                     <ol>
                        <li>
                           <p>调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。 LogMiner将读取：</p>
                           <ol type="a">
                              <li>
                                 <p>第一个加载字典的日志文件</p>
                              </li>
                              <li>
                                 <p>第二个重做日志文件，用于获取其中包含的任何可能的DDL</p>
                              </li>
                              <li>
                                 <p>第三个日志文件，用于检索感兴趣的数据</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>使用相同的请求范围再次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。
                           </p>
                           <p>LogMiner将以重做日志文件3开头;它不再需要读取重做日志文件2，因为它已经处理了其中包含的任何DDL语句。</p>
                        </li>
                        <li>
                           <p>再次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> ，这次指定需要从重做日志文件5读取数据的参数。
                           </p>
                           <p>LogMiner将从重做日志文件4开始读取以获取可能包含在其中的任何DDL语句。</p>
                        </li>
                     </ol>
                     <p>查询<code class="codeph">V$LOGMNR_PARAMETERS</code>视图的<code class="codeph">REQUIRED_START_DATE</code>或<code class="codeph">REQUIRED_START_SCN</code>列，以查看LogMiner实际开始读取的位置。无论LogMiner何处开始读取，都只会从<code class="codeph">V$LOGMNR_CONTENTS</code>视图返回所请求范围内的行。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1594"></a><div class="props_rev_3"><a id="GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" name="GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39"></a><h3 id="SUTIL-GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" class="sect3"><span class="enumeration_section">22.11</span>在视图中访问LogMiner操作信息</h3>
               <div>
                  <p>LogMiner操作信息（与重做数据相对）包含在视图中。</p>
                  <p>您可以像使用任何其他视图一样使用SQL查询它们。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">V $ LOGMNR_DICTIONARY</code></p>
                        <p>显示有关所有正在使用创建的LogMiner字典文件信息<code class="codeph">STORE_IN_FLAT_FILE</code>选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。显示的信息包括有关创建LogMiner字典的数据库的信息。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V $ LOGMNR_LOGS</code></p>
                        <p>显示有关指定的重做日志文件的信息，如<a href="oracle-logminer-utility.html#GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" title="您可以查询V $ LOGMNR_LOGS视图以确定哪些重做日志文件已手动或自动添加到重做日志文件列表中以供LogMiner分析。">查询V $ LOGMNR_LOGS中所述</a> 。</p>
                     </li>
                     <li>
                        <p><code class="codeph">V $ LOGMNR_PARAMETERS</code></p>
                        <p>显示有关可选LogMiner参数的信息，包括开始和结束系统更改编号（SCN）以及开始和结束时间。</p>
                     </li>
                     <li>
                        <p><code class="codeph">V$DATABASE</code> ， <code class="codeph">DBA_LOG_GROUPS</code> ， <code class="codeph">ALL_LOG_GROUPS</code> ， <code class="codeph">USER_LOG_GROUPS</code> ， <code class="codeph">DBA_LOG_GROUP_COLUMNS</code> ， <code class="codeph">ALL_LOG_GROUP_COLUMNS</code> ， <code class="codeph">USER_LOG_GROUP_COLUMN</code> S</p>
                        <p>显示有关补充日志记录的当前设置的信息，如<a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" title="描述如何查询多个视图以确定补充日志记录的当前设置。">查询补充日志记录设置的视图中</a>所述。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F">查询V $ LOGMNR_LOGS</a><br>您可以查询<code class="codeph">V$LOGMNR_LOGS</code>视图以确定哪些重做日志文件已手动或自动添加到重做日志文件列表中以供LogMiner分析。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1">查询补充日志记录设置的视图</a><br>描述如何查询多个视图以确定补充日志记录的当前设置。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" name="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F"></a><h4 id="SUTIL-GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F" class="sect4"><span class="enumeration_section">22.11.1</span>查询V $ LOGMNR_LOGS</h4>
                  <div>
                     <p>您可以查询<code class="codeph">V$LOGMNR_LOGS</code>视图以确定哪些重做日志文件已手动或自动添加到重做日志文件列表中以供LogMiner分析。
                     </p>
                     <p>此视图包含每个重做日志文件的一行。它提供有关每个重做日志文件的有价值信息，包括文件名，SCN和时间范围，以及它是否包含全部或部分LogMiner字典。</p>
                     <p>成功调用后<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>的<code class="codeph">STATUS</code>中的列<code class="codeph">V$LOGMNR_LOGS</code>视图包含下列值之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">0</code>  
                           </p>
                           <p>指示在查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图期间将处理重做日志文件。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">1</code>  
                           </p>
                           <p>表示这将是LogMiner在针对<code class="codeph">V$LOGMNR_CONTENTS</code>视图的选择操作期间处理的第一个重做日志文件。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">2</code>  
                           </p>
                           <p>表示重做日志文件已被修剪，因此在查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图期间LogMiner将不会处理该文件。它已被修剪，因为它不需要满足您要求的时间或SCN范围。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">4</code>  
                           </p>
                           <p>表示LogMiner重做日志文件列表中缺少重做日志文件（基于序列号）。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">V$LOGMNR_LOGS</code>视图包含列表中缺少的每个重做日志文件的行，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">FILENAME</code>列将包含连续的序列号范围和总SCN范围间隙。
                           </p>
                           <p>例如：'缺少线程号1的日志文件，序列号100到102'。</p>
                        </li>
                        <li>
                           <p><code class="codeph">INFO</code>列将包含字符串'MISSING_LOGFILE'。
                           </p>
                        </li>
                     </ul>
                     <p>由于以下原因，有关重做日志文件列表中缺少的文件的信息可能很有用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该<code class="codeph">DDL_DICT_TRACKING</code>可当你调用指定选项<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>将不允许重做日志文件从LogMiner的丢失重做日志文件列表的请求的时间或SCN范围。如果对<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>失败，则可以查询<code class="codeph">V$LOGMNR_LOGS</code>视图中的<code class="codeph">STATUS</code>列以确定列表中缺少哪些重做日志文件。然后，您可以查找并手动添加这些重做日志文件，并尝试再次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code> 。
                           </p>
                           <div class="infoboxnote" id="GUID-A4779AA3-EE5B-43CA-A64A-0A6B8CFC5D4F__GUID-5606C88D-743A-4945-9CF5-85C664D49800">
                              <p class="notep1">注意：</p>Oracle Database 19c（19.1）中不支持<code class="codeph">dbms_logmnr.start_logmnr</code>软件包的<code class="codeph">continuous_mine</code>选项，该选项不再可用。
                           </div>
                        </li>
                        <li>
                           <p>虽然在调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>时可以指定的所有其他选项都允许从LogMiner重做日志文件列表中删除文件，但您可能不希望丢失文件。在查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图之前，可以查询<code class="codeph">V$LOGMNR_LOGS</code>视图，以确保列表中包含所有必需的文件。如果列表中缺少文件并且您查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图，则在<code class="codeph">V$LOGMNR_CONTENTS</code>返回一行，其中包含以下列值：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在“ <code class="codeph">OPERATION</code>列中，值为“MISSING_SCN”</p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">STATUS</code>列中，值为<code class="codeph">1291</code></p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">INFO</code>列中，指示缺少SCN范围的字符串（例如，“缺少SCN 100  -  200”）</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" title="LogMiner操作信息（与重做数据相对）包含在视图中。">在视图中访问LogMiner操作信息</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1596"></a><div class="props_rev_3"><a id="GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" name="GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1"></a><h4 id="SUTIL-GUID-48D9DB83-BBC0-45EE-A81E-7CD047C908C1" class="sect4"><span class="enumeration_section">22.11.2</span>查询补充日志设置视图</h4>
                  <div>
                     <p>描述如何查询多个视图以确定补充日志记录的当前设置。</p>
                     <p>Specificallyt：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">V$DATABASE</code>视图</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_FK</code>列</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">NO</code> - 如果未启用使用<code class="codeph">FOREIGN KEY</code>选项的数据库级标识密钥日志记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - 如果启用了使用<code class="codeph">FOREIGN KEY</code>选项的数据库级标识密钥日志记录</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_ALL</code>列</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">NO</code> - 如果未启用带有<code class="codeph">ALL</code>选项的数据库级标识密钥日志记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - 如果启用了带有<code class="codeph">ALL</code>选项的数据库级标识密钥日志记录</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_UI</code>列</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">NO</code> - 如果未启用使用<code class="codeph">UNIQUE</code>选项的数据库级标识密钥记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - 如果启用了使用<code class="codeph">UNIQUE</code>选项的数据库级标识密钥记录</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">SUPPLEMENTAL_LOG_DATA_MIN</code>列</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p> <code class="codeph">NO</code> - 如果未启用数据库级补充日志记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">IMPLICIT</code> - 如果启用了最小补充日志记录，则启用了数据库级标识密钥日志记录选项</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">YES</code> - 如果由于发出SQL <code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">ADD</code> <code class="codeph">SUPPLEMENTAL</code> <code class="codeph">LOG</code> <code class="codeph">DATA</code>语句而启用了最小补充日志记录</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">DBA_LOG_GROUPS</code> ， <code class="codeph">ALL_LOG_GROUPS</code>和<code class="codeph">USER_LOG_GROUPS</code>视图</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ALWAYS</code>专栏</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">ALWAYS</code> - 表示如果更新关联行中的任何列，将对该日志组中的列进行补充记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CONDITIONAL</code> - 表示仅当日志组中的列更新时，才会补充记录此组中的列</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">GENERATED</code>列</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">GENERATED NAME</code> - 如果<code class="codeph">LOG_GROUP</code>名称是系统生成的</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">USER NAME</code> - 如果<code class="codeph">LOG_GROUP</code>名称是用户定义的</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">LOG_GROUP_TYPE</code>列</p>
                                 <p>此列包含以下值之一，以指示为此日志组定义的日志记录类型。<code class="codeph">USER LOG GROUP</code>表示日志组是用户定义的（与系统生成的相反）。
                                 </p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">所有栏目记录</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">外国钥匙记录</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">主要关键记录</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">独特的钥匙记录</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">用户登录组</code></p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">DBA_LOG_GROUP_COLUMNS</code> ， <code class="codeph">ALL_LOG_GROUP_COLUMNS</code>和<code class="codeph">USER_LOG_GROUP_COLUMNS</code>视图</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">LOGGING_PROPERTY</code>列</p>
                                 <p>此列包含以下值之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">LOG</code> - 表示将对日志组中的此列进行补充记录</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">NO</code> <code class="codeph">LOG</code> - 表示日志组中的此列不会被补充记录</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-B3C964E4-F33E-48C0-951F-86AF3778DE39" title="LogMiner操作信息（与重做数据相对）包含在视图中。">在视图中访问LogMiner操作信息</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1597"></a><div class="props_rev_3"><a id="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" name="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760"></a><h3 id="SUTIL-GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" class="sect3"><span class="enumeration_section">22.12</span>典型LogMiner会话中的步骤</h3>
               <div>
                  <p>描述典型LogMiner会话中的步骤。</p>
                  <div class="section">
                     <p>每个步骤都在其自己的小节中描述。</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span><a href="oracle-logminer-utility.html#GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" title="启用补充日志记录。">启用补充日志记录</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" title="提取LogMiner字典。">提取LogMiner词典</a> （除非您打算使用在线目录）</span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" title="指定重做日志文件以进行分析。">指定要分析的重做日志文件</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" title="启动LogMiner。">启动LogMiner</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" title="查询V $ LOGMNR_CONTENTS视图。">典型的LogMiner会话任务5：查询V $ LOGMNR_CONTENTS</a></span></li>
                     <li><span><a href="oracle-logminer-utility.html#GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" title="结束LogMiner会话。">结束LogMiner会话</a></span></li>
                  </ol>
                  <div class="section">
                     <p>要运行LogMiner，请使用<code class="codeph">DBMS_LOGMNR</code> PL / SQL包。此外，如果您选择提取LogMiner字典而不是使用在线目录，则也可以使用<code class="codeph">DBMS_LOGMNR_D</code>包。
                     </p>
                     <p><code class="codeph">DBMS_LOGMNR</code>包中包含用于初始化和运行LogMiner的过程，包括用于指定重做日志文件名称，过滤条件和会话特征的接口。<code class="codeph">DBMS_LOGMNR_D</code>包查询当前数据库的数据库字典表以创建LogMiner字典文件。
                     </p>
                     <p>LogMiner PL / SQL包由<code class="codeph">SYS</code>模式拥有。因此，如果未以<code class="codeph">SYS</code>用户身份连接，则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您必须在通话中包含<code class="codeph">SYS</code> 。例如：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">EXECUTE SYS.DBMS_LOGMNR.END_LOGMNR</code> ;</pre></li>
                        <li>
                           <p>您必须已被授予<code class="codeph">EXECUTE_CATALOG_ROLE</code>角色。
                           </p>
                           <div class="infoboxnotealso" id="GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760__GUID-5755A8B1-82B9-4083-9F04-D5732801B73E">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关这些LogMiner软件包的语法和参数的详细信息，请参阅<a href="../arpls/DBMS_LOGMNR.html#ARPLS022" target="_blank"><span class="italic">Oracle Database PL / SQL软件包和类型参考</span></a></p>
                                 </li>
                                 <li>
                                    <p>有关PL / SQL包的更多信息，请参见<a href="../adfns/coding-subprograms-and-packages.html#ADFNS1398" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F621A15A-0A29-4261-9C23-F95139E5D79E">典型的LogMiner会话任务1：启用补充日志记录</a><br>启用补充日志记录。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757">典型的LogMiner会话任务2：提取LogMiner词典</a><br>提取LogMiner字典。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CEB3F34A-633A-47D5-B568-F65746D02D02">典型的LogMiner会话任务3：指定要进行分析的重做日志文件</a><br>指定重做日志文件以进行分析。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF">典型的LogMiner会话任务4：启动LogMiner</a><br>启动LogMiner。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6">典型的LogMiner会话任务5：查询V $ LOGMNR_CONTENTS</a><br>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3">典型的LogMiner会话任务6：结束LogMiner会话</a><br>结束LogMiner会话。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1598"></a><div class="props_rev_3"><a id="GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" name="GUID-F621A15A-0A29-4261-9C23-F95139E5D79E"></a><h4 id="SUTIL-GUID-F621A15A-0A29-4261-9C23-F95139E5D79E" class="sect4"><span class="enumeration_section">22.12.1</span>典型的LogMiner会话任务1：启用补充日志记录</h4>
                  <div>
                     <p>启用补充日志记录。</p>
                     <div class="section">
                        <p>启用要使用的补充日志记录的类型。至少，您必须启用最少的补充日志记录，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER DATABASE添加补充日志数据;</pre><p>有关更多信息，请参阅<a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1599"></a><div class="props_rev_3"><a id="GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" name="GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757"></a><h4 id="SUTIL-GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" class="sect4"><span class="enumeration_section">22.12.2</span>典型的LogMiner会话任务2：提取LogMiner字典</h4>
                  <div>
                     <p>提取LogMiner字典。</p>
                     <p>要使用LogMiner，您必须通过执行以下操作之一为其提供字典：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>启动LogMiner时，使用<code class="codeph">DICT_FROM_ONLINE_CATALOG</code>选项指定在线目录的使用。请参阅<a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="要指示LogMiner使用当前用于数据库的字典，请在启动LogMiner时将在线目录指定为字典源。">使用在线目录</a> 。
                           </p>
                        </li>
                        <li>
                           <p>将数据库字典信息提取到重做日志文件。请参阅<a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="要将LogMiner字典提取到重做日志文件，必须打开数据库并处于ARCHIVELOG模式，并且必须启用存档。">将LogMiner词典提取到重做日志文件</a> 。
                           </p>
                        </li>
                        <li>
                           <p>将数据库字典信息提取到平面文件。请参阅<a href="oracle-logminer-utility.html#GUID-DA37874F-6637-4205-AB5C-A8AC1914D018" title="当LogMiner字典位于平面文件中时，使用的系统资源少于重做日志文件中包含的系统资源。Oracle建议您定期备份字典提取以确保正确分析旧的重做日志文件。">将LogMiner字典提取到平面文件</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1600"></a><div class="props_rev_3"><a id="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" name="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02"></a><h4 id="SUTIL-GUID-CEB3F34A-633A-47D5-B568-F65746D02D02" class="sect4"><span class="enumeration_section">22.12.3</span>典型的LogMiner会话任务3：指定要进行分析的重做日志文件</h4>
                  <div>
                     <p>指定重做日志文件以进行分析。</p>
                     <div class="section">
                        <p>在启动LogMiner之前，必须指定要分析的重做日志文件。为此，请执行<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>过程，如以下步骤所示。您可以按任何顺序添加和删除重做日志文件。
                        </p>
                        <div class="infoboxnote" id="GUID-CEB3F34A-633A-47D5-B568-F65746D02D02__GUID-BF44A8BE-2FCE-4AF6-B3F0-68DE0E03952B">
                           <p class="notep1">注意：</p>
                           <p>如果要在生成重做日志文件的数据库实例中进行挖掘，则只需在启动LogMiner时指定以下内容之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">STARTSCN</code>参数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">STARTTIME</code>参数</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用SQL * Plus启动Oracle实例，同时安装或卸载数据库。例如，在SQL提示符处输入<code class="codeph">STARTUP</code>语句：</span><div><pre class="oac_no_warn" dir="ltr">启动</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建重做日志文件列表。指定<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL / SQL过程的<code class="codeph">NEW</code>选项，以指示这是新列表的开头。例如，输入以下内容以指定<code class="codeph">/oracle/logs/log1.f</code>重做日志文件：</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log1.f'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>如果需要，通过指定添加更多的重做日志文件<code class="codeph">ADDFILE</code>的备选方案<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code> PL / SQL程序。例如，输入以下内容以添加<code class="codeph">/oracle/logs/log2.f</code>重做日志文件：</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log2.f'， -  OPTIONS =&gt; DBMS_LOGMNR.ADDFILE）;</pre><p>添加其他重做日志文件时， <code class="codeph">OPTIONS</code>参数是可选的。例如，您只需输入以下内容：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log2.f'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>如果需要，请使用<code class="codeph">DBMS_LOGMNR.REMOVE_LOGFILE</code> PL / SQL过程删除重做日志文件。例如，输入以下内容以删除<code class="codeph">/oracle/logs/log2.f</code>重做日志文件：</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.REMOVE_LOGFILE（ -  LOGFILENAME =&gt;'/ oracle / logs / log2.f'）;</pre></div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1601"></a><div class="props_rev_3"><a id="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" name="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF"></a><h4 id="SUTIL-GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF" class="sect4"><span class="enumeration_section">22.12.4</span>典型的LogMiner会话任务4：启动LogMiner</h4>
                  <div>
                     <p>启动LogMiner。</p>
                     <div class="section">
                        <p>创建LogMiner字典文件并指定要分析的重做日志文件后，必须启动LogMiner。采取以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>执行<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程以启动LogMiner。</span><div>
                              <p>Oracle建议您指定LogMiner字典选项。如果不这样做，则LogMiner无法将内部对象标识符和数据类型转换为对象名称和外部数据格式。因此，它将返回内部对象ID并将数据呈现为二进制数据。此外，没有字典，不能使用<code class="codeph">MINE_VALUE</code>和<code class="codeph">COLUMN_PRESENT</code>函数。
                              </p>
                              <p>如果要指定平面文件LogMiner字典的名称，则必须为字典文件提供完全限定的文件名。例如，要使用<code class="codeph">/oracle/database/dictionary.ora</code>启动LogMiner，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  DICTFILENAME =&gt;'/ oracle / database / dictionary.ora'）;</pre><p>如果未指定平面文件字典名称，请使用<code class="codeph">OPTIONS</code>参数指定<code class="codeph">DICT_FROM_REDO_LOGS</code>或<code class="codeph">DICT_FROM_ONLINE_CATALOG</code>选项。
                              </p>
                              <p>如果指定<code class="codeph">DICT_FROM_REDO_LOGS</code> ，然后LogMiner的希望能够找到在您指定的重做日志文件的字典<code class="codeph">DBMS_LOGMNR.ADD_LOGFILE</code>程序。要确定哪些重做日志文件包含字典，请查看<code class="codeph">V$ARCHIVED_LOG</code>视图。有关示例，请参阅<a href="oracle-logminer-utility.html#GUID-A0D89906-C787-4EB4-BA47-171A457445EC" title="要将LogMiner字典提取到重做日志文件，必须打开数据库并处于ARCHIVELOG模式，并且必须启用存档。">将LogMiner Dictionary提取到重做日志文件</a> 。
                              </p>
                              <div class="infoboxnote" id="GUID-319446A8-6FEC-42CE-A6A4-582CA65377CF__GUID-7E8B82D6-442D-4911-A7DA-019E1EC04B16">
                                 <p class="notep1">注意：</p>
                                 <p>如果在启动LogMiner后添加其他重做日志文件，则必须重新启动LogMiner。LogMiner不会保留上一次调用<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>包含的选项;您必须重新指定要使用的选项。但是，如果您未在当前对<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>指定字典，则LogMiner将保留上一次调用的字典规范。</p>
                              </div>
                              <p>有关<code class="codeph">DICT_FROM_ONLINE_CATALOG</code>选项的更多信息，请参阅<a href="oracle-logminer-utility.html#GUID-1D510A2F-4CE8-4D69-AB18-CDD58FB3458C" title="要指示LogMiner使用当前用于数据库的字典，请在启动LogMiner时将在线目录指定为字典源。">使用联机目录</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>（可选）您可以按时间或按SCN过滤查询。请参阅<a href="oracle-logminer-utility.html#GUID-0AA13EFD-8118-4061-A215-9D3AF9EEB1D5" title="要按时间过滤数据，请在DBMS_LOGMNR.START_LOGMNR过程中设置STARTTIME和ENDTIME参数。">按时间</a> <a href="oracle-logminer-utility.html#GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" title="To filter data by SCN (system change number), use the STARTSCN and ENDSCN parameters to the PL/SQL DBMS_LOGMNR.START_LOGMNR procedure.">过滤数据</a>或<a href="oracle-logminer-utility.html#GUID-011AA230-32A7-4DE7-9DC0-CE1FF55CFAF3" title="要通过SCN（系统更改编号）过滤数据，请将STARTSCN和ENDSCN参数用于PL / SQL DBMS_LOGMNR.START_LOGMNR过程。">按SCN过滤数据</a> 。</span></li>
                        <li class="stepexpand"><span>您还可以使用<code class="codeph">OPTIONS</code>参数指定LogMiner会话的其他特征。例如，您可能决定使用在线目录作为LogMiner字典，并且只在<code class="codeph">V$LOGMNR_CONTENTS</code>视图中显示已提交的事务，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（OPTIONS =&gt;  -  DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY）;</pre><p>有关<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>选项的更多信息，请参阅<a href="../arpls/DBMS_LOGMNR.html#ARPLS022" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                              </p>
                              <p>您可以执行<code class="codeph">DBMS_LOGMNR</code> 。 <code class="codeph">START_LOGMNR</code>过程，每次指定不同的选项。这可能很有用，例如，如果您没有从<code class="codeph">V$LOGMNR_CONTENTS</code>的查询中获得所需的结果，并且想要使用不同的选项重新启动LogMiner。除非您需要重新指定LogMiner字典，否则如果已经添加了以前调用<code class="codeph">DBMS_LOGMNR</code>重做日志文件，则无需添加它们。 <code class="codeph">START_LOGMNR</code> 。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" name="GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6"></a><h4 id="SUTIL-GUID-CDB10F63-EC7C-4ADB-8022-0A0EA45268E6" class="sect4"><span class="enumeration_section">22.12.5</span>典型的LogMiner会话任务5：查询V $ LOGMNR_CONTENTS</h4>
                  <div>
                     <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                     </p>
                     <p>此时，LogMiner已启动。您可以对<code class="codeph">V$LOGMNR_CONTENTS</code>视图执行查询。有关此示例，请参阅<a href="oracle-logminer-utility.html#GUID-C659DAB0-03D0-4958-BB2F-E81C2928BE24" title="LogMiner可能会处理大量信息。您可以限制返回到V $ LOGMNR_CONTENTS视图的信息以及返回的速度。">过滤和格式化返回到V $ LOGMNR_CONTENTS的数据</a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1603"></a><div class="props_rev_3"><a id="GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" name="GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3"></a><h4 id="SUTIL-GUID-F6E100FC-817C-486C-A60E-B6D372E46CD3" class="sect4"><span class="enumeration_section">22.12.6</span>典型的LogMiner会话任务6：结束LogMiner会话</h4>
                  <div>
                     <p>结束LogMiner会话。</p>
                     <div class="section">
                        <p>要正确结束LogMiner会话，请使用<code class="codeph">DBMS_LOGMNR.END_LOGMNR</code> PL / SQL过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR;</pre><p>此过程将关闭所有重做日志文件，并允许释放LogMiner分配的所有数据库和系统资源。</p>
                        <p>如果未执行此过程，则LogMiner会保留其所有已分配的资源，直到调用它的Oracle会话结束。如果使用<code class="codeph">DDL_DICT_TRACKING</code>选项或<code class="codeph">DICT_FROM_REDO_LOGS</code>选项，则使用此过程结束LogMiner会话尤为重要。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话中的步骤</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1604"></a><div class="props_rev_3"><a id="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" name="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98"></a><h3 id="SUTIL-GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" class="sect3"><span class="enumeration_section">22.13</span>示例使用LogMiner</h3>
               <div>
                  <p>使用LogMiner的示例。</p>
                  <p>本节提供了几个使用LogMiner的示例。</p>
                  <div class="infoboxnote" id="GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98__GUID-5453CA86-2715-4149-B09F-A15B35750FA2">
                     <p class="notep1">注意：</p>
                     <p>本节中的所有示例都假定已启用最小补充日志记录：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE添加补充日志数据;</pre><p>有关更多信息，请参阅<a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录</a> 。
                     </p>
                     <p>除<a href="oracle-logminer-utility.html#GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A">示例2：在给定SCN范围内挖掘重做日志文件</a>和<a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="有关如何将LogMiner用于典型方案的示例。">示例方案</a>之外的所有示例都假定<code class="codeph">NLS_DATE_FORMAT</code>参数已设置如下：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='dd-mon-yyyy hh24：mi：ss';</pre><pre class="oac_no_warn" dir="ltr"></pre><p>由于LogMiner使用对用户会话激活的<code class="codeph">NLS_DATE_FORMAT</code>参数的设置来显示日期数据，因此此步骤是可选的。但是，显式设置参数可以预测日期格式。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C">通过明确指定感兴趣的重做日志文件进行挖掘的示例</a><br>指定重做日志文件的示例。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4">未明确指定重做日志文件列表的挖掘示例</a><br>未指定重做日志文件的示例。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027">示例场景</a><br>有关如何将LogMiner用于典型方案的示例。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1605"></a><div class="props_rev_3"><a id="GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" name="GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C"></a><h4 id="SUTIL-GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" class="sect4"><span class="enumeration_section">22.13.1</span>通过显式指定重做日志文件进行挖掘的示例</h4>
                  <div>
                     <p>指定重做日志文件的示例。</p>
                     <p>这些示例演示了当您知道哪些重做日志文件包含感兴趣的数据时如何使用LogMiner。这些示例最好按顺序读取，因为每个示例都建立在它前面的示例或示例之上。</p>
                     <p>显示的SQL输出格式可能与这些示例中显示的不同。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">示例1：查找上次存档重做日志文件中的所有修改</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0">示例2：将DML语句分组为已提交的事务</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E42A8D99-F93F-40F4-9E86-787CA179692A">示例3：格式化重建的SQL</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0">示例4：在重做日志文件中使用LogMiner字典</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F">示例5：跟踪内部字典中的DDL语句</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09">例6：按时间范围过滤输出</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="使用LogMiner的示例。">使用LogMiner的示例</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4231"></a><a id="SUTIL4232"></a><a id="SUTIL4233"></a><a id="SUTIL4234"></a><a id="SUTIL4235"></a><a id="SUTIL1606"></a><div class="props_rev_3"><a id="GUID-E3820793-B482-48C4-9F44-C0D7A062E318" name="GUID-E3820793-B482-48C4-9F44-C0D7A062E318"></a><h5 id="SUTIL-GUID-E3820793-B482-48C4-9F44-C0D7A062E318" class="sect5"><span class="enumeration_section">22.13.1.1</span>示例1：查找上次存档重做日志文件中的所有修改</h5>
                     <div>
                        <div class="section">
                           <p>检查数据库修改历史记录的最简单方法是在源数据库中挖掘并使用在线目录来转换重做日志文件。此示例显示如何使用LogMiner进行最简单的分析。</p>
                           <p>此示例假定您知道要挖掘最近归档的重做日志文件。它查找数据库生成的上一个归档重做日志中包含的所有修改（假设该数据库不是Oracle Real Application Clusters（Oracle RAC）数据库）。</p>
                           <ol>
                              <li>
                                 <p>确定最近归档的重做日志文件。</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称WHERE FIRST_TIME =（SELECT MAX（FIRST_TIME）FROM V $ ARCHIVED_LOG）; NAME ------------------------------------------- / usr / oracle / data /db1arch_1_16_482701534.dbf</pre></li>
                              <li>
                                 <p>指定要分析的重做日志文件列表。在这种情况下，它是步骤1中查询返回的重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_16_482701534.dbf'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre></li>
                              <li>
                                 <p>启动LogMiner并指定要使用的字典。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>请注意，有四个事务（其中两个事务在正在分析的重做日志文件中提交，而另外两个事务没有提交）。输出按执行顺序显示DML语句;因此交易在它们之间交错。</p><pre class="oac_no_warn" dir="ltr">SELECT用户名AS USR，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，SQL_REDO，SQL_UNDO FROM V $ LOGMNR_CONTENTS WHERE用户名IN（'HR'，'OE'）; USR XID SQL_REDO SQL_UNDO ---- --------- --------------------------------- ------------------- HR 1.11.1476设置事务读写; HR 1.11.1476插入“HR”。“EMPLOYEES”（从“HR”删除。“EMPLOYEES”“EMPLOYEE_ID”，“FIRST_NAME”，“EMPLOYEE_ID”='306'“LAST_NAME”，“EMAIL”和“FIRST_NAME” “='Nandini'”PHONE_NUMBER“，”HIRE_DATE“和”LAST_NAME“=”Shastry“”JOB_ID“，”SALARY“和”EMAIL“=”NSHASTRY“”COMMISSION_PCT“，”MANAGER_ID“和”PHONE_NUMBER“= '1234567890'“DEPARTMENT_ID”）值和“HIRE_DATE”= TO_DATE（'10 -JAN-2012（'306'，'Nandini'，'Shastry'，13：34：43'，'dd-mon-yyyy hh24：mi ：ss'）'NSHASTRY'，'1234567890'和“JOB_ID”='HR_REP'和TO_DATE（'10 -jan-2012 13:34:43'，“SALARY”='120000'和'dd-mon-yyyy hh24：mi：ss'），“COMMISSION_PCT”='。05'和'HR_REP'，'120000'，'。05'，“DEPARTMENT_ID”= '10'和'105'，'10'）; ROWID ='AAAHSkAABAAAY6rAAO'; OE 1.1.1484设置事务读写; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”=设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）其中TO_YMINTERVAL（'+ 01-00'）其中“PRODUCT_ID”='1799'和“PRODUCT_ID”='1799'和“WARRANTY_PERIOD”=“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAB'; ROWID ='AAAHTKAABAAAY9mAAB'; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”=设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）其中TO_YMINTERVAL（'+ 01-00'）其中“PRODUCT_ID”='1801'和“PRODUCT_ID”='1801'和“WARRANTY_PERIOD”=“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAC'; ROWID ='AAAHTKAABAAAY9mAAC'; HR 1.11.1476插入“HR”。“EMPLOYEES”（从“HR”删除。“EMPLOYEES”“EMPLOYEE_ID”，“FIRST_NAME”，“EMPLOYEE_ID”=“307”和“LAST_NAME”，“EMAIL”，“FIRST_NAME” ='John'和“PHONE_NUMBER”，“HIRE_DATE”，“LAST_NAME”=“Silver”和“JOB_ID”，“SALARY”，“EMAIL”=“JSILVER”和“COMMISSION_PCT”，“MANAGER_ID”，“PHONE_NUMBER”=' 5551112222'“DEPARTMENT_ID”）值和“HIRE_DATE”= TO_DATE（'10 -jan-2012（'307'，'John'，'Silver'，13：41：03'，'dd-mon-yyyy hh24：mi： ss'）'JSILVER'，'5551112222'和“JOB_ID”='105'和“DEPARTMENT_ID”TO_DATE（'10 -jan-2012 13:41:03'，='50'和ROWID ='AAAHSkAABAAAY6rAAP';' dd-mon-yyyy hh24：mi：ss'），'SH_CLERK'，'110000'，'。05'，'105'，'50'）; OE 1.1.1484承诺; HR 1.15.1481设置事务读写; HR 1.15.1481从“HR”删除。“EMPLOYEES”插入“HR”。“EMPLOYEES”（其中“EMPLOYEE_ID”='205'和“EMPLOYEE_ID”，“FIRST_NAME”，“FIRST_NAME”='Shelley'和“LAST_NAME” “，”EMAIL“，”PHONE_NUMBER“，”LAST_NAME“=”Higgins“和”HIRE_DATE“，”JOB_ID“，”SALARY“，”EMAIL“=”SHIGGINS“和”COMMISSION_PCT“，”MANAGER_ID“，”PHONE_NUMBER“= '515.123.8080'“DEPARTMENT_ID”）值和“HIRE_DATE”= TO_DATE（（'205'，'Shelley'，'Higgins'，'07 -jun-1994 10:05:01'和'SHIGGINS'，'515.123 .8080'，'dd-mon-yyyy hh24：mi：ss'）TO_DATE（'07 -jun-1994 10:05:01'，和'JOB_ID'='AC_MGR''dd-mon-yyyy hh24：mi： ss'）和“SALARY”='12000''AC_MGR'，'12000'，NULL，'101'，'110'）;和“COMMISSION_PCT”为空，“MANAGER_ID”='101'，“DEPARTMENT_ID”='110'，ROWID ='AAAHSkAABAAAY6rAAM'; OE 1.8.1484设置事务读写; OE 1.8.1484更新“OE”。“PRODUCT_INFORMATION”更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”=设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 12-06'）其中TO_YMINTERVAL（'+ 20-00'）其中“PRODUCT_ID”='2350'和“PRODUCT_ID”='2350'和“WARRANTY_PERIOD”=“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 20-00'）和TO_YMINTERVAL（'+ 20-00'）和ROWID ='AAAHTKAABAAAY9tAAD'; ROWID ='AAAHTKAABAAAY9tAAD'; HR 1.11.1476 commit;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4236"></a><a id="SUTIL4237"></a><a id="SUTIL4238"></a><a id="SUTIL4239"></a><a id="SUTIL4240"></a><a id="SUTIL1607"></a><div class="props_rev_3"><a id="GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0" name="GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0"></a><h5 id="SUTIL-GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0" class="sect5"><span class="enumeration_section">22.13.1.2</span>示例2：将DML语句分组为已提交的事务</h5>
                     <div>
                        <div class="section">
                           <p>如第一个示例所示， <a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">示例1：查找上次存档重做日志文件中的</a>所有修改，LogMiner显示它在默认情况下分析的重做日志文件中找到的所有修改，无论事务是否已提交。此外，LogMiner按照执行顺序显示修改。由于属于同一事务的DML语句未组合在一起，因此可能难以对输出进行目视检查。虽然您可以使用SQL对事务进行分组，但LogMiner提供了一种更简单的方法。在此示例中，将再次分析最新的归档重做日志文件，但它将仅返回已提交的事务。
                           </p>
                           <ol>
                              <li>
                                 <p>确定数据库最近归档了哪个重做日志文件。</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称WHERE FIRST_TIME =（SELECT MAX（FIRST_TIME）FROM V $ ARCHIVED_LOG）; NAME ------------------------------------------- / usr / oracle / data /db1arch_1_16_482701534.dbf</pre></li>
                              <li>
                                 <p>指定步骤1中查询返回的重做日志文件。该列表将包含一个重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_16_482701534.dbf'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre></li>
                              <li>
                                 <p>通过指定要使用的字典和<code class="codeph">COMMITTED_DATA_ONLY</code>选项来启动LogMiner。
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_16_482701534.dbf'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>虽然事务1.11.1476是在事务1.1.1484之前启动的（如<a href="oracle-logminer-utility.html#GUID-E3820793-B482-48C4-9F44-C0D7A062E318">示例1：在上次存档的重做日志文件中查找所有修改中所示</a> ），但它在事务1.1.1484提交后提交。因此，在此示例中，事务1.1.1484在事务1.11.1476之前完整显示。未返回在正在分析的重做日志文件中未提交的两个事务。
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT用户名AS USR，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，SQL_REDO，SQL_UNDO FROM V $ LOGMNR_CONTENTS WHERE用户名IN（'HR'，'OE'）; ; USR XID SQL_REDO SQL_UNDO ---- --------- -------------------------------  - ------------------------------- OE 1.1.1484 set transaction read write; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”=设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）其中TO_YMINTERVAL（'+ 01-00'）其中“PRODUCT_ID”='1799'和“PRODUCT_ID”='1799'和“WARRANTY_PERIOD”=“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAB'; ROWID ='AAAHTKAABAAAY9mAAB'; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”=设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）其中TO_YMINTERVAL（'+ 01-00'）其中“PRODUCT_ID”='1801'和“PRODUCT_ID”='1801'和“WARRANTY_PERIOD”=“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAC'; ROWID ='AAAHTKAABAAAY9mAAC'; OE 1.1.1484承诺; HR 1.11.1476设置事务读写; HR 1.11.1476插入“HR”。“EMPLOYEES”（从“HR”删除。“EMPLOYEES”“EMPLOYEE_ID”，“FIRST_NAME”，“EMPLOYEE_ID”='306'“LAST_NAME”，“EMAIL”和“FIRST_NAME” “='Nandini'”PHONE_NUMBER“，”HIRE_DATE“和”LAST_NAME“=”Shastry“”JOB_ID“，”SALARY“和”EMAIL“=”NSHASTRY“”COMMISSION_PCT“，”MANAGER_ID“和”PHONE_NUMBER“= '1234567890'“DEPARTMENT_ID”）值和“HIRE_DATE”= TO_DATE（'10 -JAN-2012（'306'，'Nandini'，'Shastry'，13：34：43'，'dd-mon-yyyy hh24：mi ：ss'）'NSHASTRY'，'1234567890'和“JOB_ID”='HR_REP'和TO_DATE（'10 -jan-2012 13:34:43'，“SALARY”='120000'和'dd-mon-yyy hh24：mi：ss'），“COMMISSION_PCT”='。05'和'HR_REP'，'120000'，'。05'，“DEPARTMENT_ID”= '10'和'105'，'10'）; ROWID ='AAAHSkAABAAAY6rAAO'; HR 1.11.1476插入“HR”。“EMPLOYEES”（从“HR”删除。“EMPLOYEES”“EMPLOYEE_ID”，“FIRST_NAME”，“EMPLOYEE_ID”=“307”和“LAST_NAME”，“EMAIL”，“FIRST_NAME” ='John'和“PHONE_NUMBER”，“HIRE_DATE”，“LAST_NAME”=“Silver”和“JOB_ID”，“SALARY”，“EMAIL”=“JSILVER”和“COMMISSION_PCT”，“MANAGER_ID”，“PHONE_NUMBER”=' 5551112222'“DEPARTMENT_ID”）值和“HIRE_DATE”= TO_DATE（'10 -jan-2012（'307'，'John'，'Silver'，13：41：03'，'dd-mon-yyyy hh24：mi： ss'）'JSILVER'，'5551112222'和“JOB_ID”='105'和“DEPARTMENT_ID”TO_DATE（'10 -jan-2012 13:41:03'，='50'和ROWID ='AAAHSkAABAAAY6rAAP';' dd-mon-yyyy hh24：mi：ss'），'SH_CLERK'，'110000'，'。05'，'105'，'50'）; HR 1.11.1476 commit;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4241"></a><a id="SUTIL4242"></a><a id="SUTIL4243"></a><a id="SUTIL4244"></a><a id="SUTIL4245"></a><a id="SUTIL4246"></a><a id="SUTIL1608"></a><div class="props_rev_3"><a id="GUID-E42A8D99-F93F-40F4-9E86-787CA179692A" name="GUID-E42A8D99-F93F-40F4-9E86-787CA179692A"></a><h5 id="SUTIL-GUID-E42A8D99-F93F-40F4-9E86-787CA179692A" class="sect5"><span class="enumeration_section">22.13.1.3</span>示例3：格式化重建的SQL</h5>
                     <div>
                        <div class="section">
                           <p>如<a href="oracle-logminer-utility.html#GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0">示例2</a>所示<a href="oracle-logminer-utility.html#GUID-9CCAC3BD-EF59-4370-BAA8-5451082577A0">：将DML语句分组为已提交事务</a> ，将<code class="codeph">COMMITTED_DATA_ONLY</code>选项与联机重做日志文件中的字典一起使用是一种关注已提交事务的简便方法。但是，仍有一个方面使视觉检查变得困难： <code class="codeph">INSERT</code>语句中列名与其各自值之间的关联并不明显。这可以通过指定<code class="codeph">PRINT_PRETTY_SQL</code>选项来解决。请注意，指定此选项将使某些重构的SQL语句不可执行。
                           </p>
                           <ol>
                              <li>
                                 <p>确定最近归档的重做日志文件。</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称WHERE FIRST_TIME =（SELECT MAX（FIRST_TIME）FROM V $ ARCHIVED_LOG）; NAME ------------------------------------------- / usr / oracle / data /db1arch_1_16_482701534.dbf</pre></li>
                              <li>
                                 <p>指定步骤1中查询返回的重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_16_482701534.dbf'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre></li>
                              <li>
                                 <p>通过指定要使用的字典以及<code class="codeph">COMMITTED_DATA_ONLY</code>和<code class="codeph">PRINT_PRETTY_SQL</code>选项来启动LogMiner。
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL）;</pre><p><code class="codeph">DBMS_LOGMNR.PRINT_PRETTY_SQL</code>选项仅更改重构SQL的格式，因此可用于生成用于目视检查的报告。
                                 </p>
                              </li>
                              <li>
                                 <p>查询<code class="codeph">SQL_REDO</code>语句的<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT用户名AS USR，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，SQL_REDO来自V $ LOGMNR_CONTENTS; USR XID SQL_REDO ---- --------- ---------------------------------- ------------------- OE 1.1.1484设置事务读写; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'），其中“PRODUCT_ID”='1799'和“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和ROWID ='AAAHTKAABAAAY9mAAB'; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'），其中“PRODUCT_ID”='1801'和“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'）和ROWID ='AAAHTKAABAAAY9mAAC'; OE 1.1.1484承诺; HR 1.11.1476设置事务读写; HR 1.11.1476插入“HR”。“EMPLOYEES”值“EMPLOYEE_ID”= 306，“FIRST_NAME”=“Nandini”，“LAST_NAME”=“Shastry”，“EMAIL”=“NSHASTRY”，“PHONE_NUMBER”='1234567890 '，“HIRE_DATE”= TO_DATE（'10 -jan-2012 13:34:43'，'dd-mon-yyyy hh24：mi：ss'，“JOB_ID”='HR_REP'，“SALARY”= 120000，“COMMISSION_PCT “=。05，”MANAGER_ID“= 105，”DEPARTMENT_ID“= 10; HR 1.11.1476插入”HR“。”EMPLOYEES“值”EMPLOYEE_ID“= 307，”FIRST_NAME“=”John“，”LAST_NAME“=' Silver'，“EMAIL”='JSILVER'，“PHONE_NUMBER”='5551112222'，“HIRE_DATE”= TO_DATE（'10 -jan-2012 13:41:03'，'dd-mon-yyyy hh24：mi：ss' ），“JOB_ID”='SH_CLERK'，“SALARY”= 110000，“COMMISSION_PCT”=。05，“MANAGER_ID”= 105，“DEPARTMENT_ID”= 50; HR 1.11.1476 commit;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图以查找重构的<code class="codeph">SQL_UNDO</code>语句。
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT用户名AS USR，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，SQL_UNDO FROM V $ LOGMNR_CONTENTS; USR XID SQL_UNDO ---- --------- ---------------------------------- ------------------- OE 1.1.1484设置事务读写; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'），其中“PRODUCT_ID”='1799'和“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAB'; OE 1.1.1484更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 01-00'），其中“PRODUCT_ID”='1801'和“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）和ROWID ='AAAHTKAABAAAY9mAAC'; OE 1.1.1484承诺; HR 1.11.1476设置事务读写; HR 1.11.1476从“HR”删除。“EMPLOYEES”，其中“EMPLOYEE_ID”= 306，“FIRST_NAME”='Nandini'和“LAST_NAME”='Shastry'和“EMAIL”='NSHASTRY'和“PHONE_NUMBER”='1234567890 '和'HIRE_DATE“= TO_DATE（'10 -jan-2012 13:34:43'，'dd-mon-yyyy hh24：mi：ss'）和”JOB_ID“='HR_REP'和”SALARY“= 120000和” COMMISSION_PCT“=。05并且”MANAGER_ID“= 105且”DEPARTMENT_ID“= 10且ROWID ='AAAHSkAABAAAY6rAAO'; HR 1.11.1476从“HR”删除。“EMPLOYEES”，其中“EMPLOYEE_ID”= 307，“FIRST_NAME”=“John”和“LAST_NAME”=“Silver”和“EMAIL”=“JSILVER”和“PHONE_NUMBER”='555122122 '和'HIRE_DATE“= TO_DATE（'10 -jan-2012 13:41:03'，'dd-mon-yyyy hh24：mi：ss'）和”JOB_ID“='SH_CLERK'和”SALARY“= 110000和” COMMISSION_PCT“=。05和”MANAGER_ID“= 105且”DEPARTMENT_ID“= 50且ROWID ='AAAHSkAABAAAY6rAAP'; HR 1.11.1476 commit;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4247"></a><a id="SUTIL4248"></a><a id="SUTIL4249"></a><a id="SUTIL4250"></a><a id="SUTIL4251"></a><a id="SUTIL4252"></a><a id="SUTIL1609"></a><div class="props_rev_3"><a id="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0" name="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0"></a><h5 id="SUTIL-GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0" class="sect5"><span class="enumeration_section">22.13.1.4</span>示例4：在重做日志文件中使用LogMiner字典</h5>
                     <div>
                        <div class="section">
                           <p>此示例显示如何使用已提取到重做日志文件的字典。在联机目录中使用词典时，必须在生成它们的同一数据库中挖掘重做日志文件。使用重做日志文件中包含的字典，您可以在不同的数据库中挖掘重做日志文件。</p>
                           <ol>
                              <li>
                                 <p>确定数据库最近归档了哪个重做日志文件。</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃FROM V $ ARCHIVED_LOG WHERE FIRST_TIME =（SELECT MAX（FIRST_TIME）FROM V $ ARCHIVED_LOG）; NAME SEQUENCE＃-------------------------------------------- --- ----------- /usr/oracle/data/db1arch_1_210_482701534.dbf 210</pre></li>
                              <li>
                                 <p>字典可以包含在多个重做日志文件中。因此，您需要确定哪些重做日志文件包含字典的开头和结尾。查询<code class="codeph">V$ARCHIVED_LOG</code>视图，如下所示：</p>
                                 <ol type="a">
                                    <li>
                                       <p>查找包含字典提取结尾的重做日志文件。必须在要分析的重做日志文件之前创建此重做日志文件，但该文件应尽可能新。</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃，DICTIONARY_BEGIN d_beg，DICTIONARY_END d_end FROM V $ ARCHIVED_LOG WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG WHERE DICTIONARY_END ='YES'和SEQUENCE＃&lt;= 210）; NAME SEQUENCE＃D_BEG D_END --------------------------------------------  - --------- ----- ------ /usr/oracle/data/db1arch_1_208_482701534.dbf 208否是</pre></li>
                                    <li>
                                       <p>找到重做日志文件，其中包含与上一步中找到的字典末尾匹配的数据字典提取的开头：</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃，DICTIONARY_BEGIN d_beg，DICTIONARY_END d_end FROM V $ ARCHIVED_LOG WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG WHERE DICTIONARY_BEGIN ='YES'和SEQUENCE＃&lt;= 208）; NAME SEQUENCE＃D_BEG D_END --------------------------------------------  - --------- ----- ------ /usr/oracle/data/db1arch_1_207_482701534.dbf 207是否</pre></li>
                                    <li>
                                       <p>指定感兴趣的重做日志文件列表。添加包含字典的开头和结尾以及要分析的重做日志文件的重做日志文件。您可以按任何顺序添加重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_210_482701534.dbf'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）; EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_208_482701534.dbf'）; EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_207_482701534.dbf'）;</pre></li>
                                    <li>
                                       <p>查询<code class="codeph">V$LOGMNR_LOGS</code>视图以显示要分析的重做日志文件列表，包括其时间戳。
                                       </p>
                                       <p>在输出中，LogMiner标记缺少的重做日志文件。LogMiner允许您继续挖掘，前提是您没有指定需要缺少重做日志文件才能正常运行的选项。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>通过指定要使用的字典以及<code class="codeph">COMMITTED_DATA_ONLY</code>和<code class="codeph">PRINT_PRETTY_SQL</code>选项来启动LogMiner。
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>要减少查询返回的行数，请从查询中排除在<code class="codeph">SYS</code>或<code class="codeph">SYSTEM</code>模式中完成的所有DML语句。（此查询指定时间戳以排除字典提取中涉及的事务。）
                                 </p>
                                 <p>输出显示三个事务：两个DDL事务和一个DML事务。DDL事务1.2.1594和1.18.1602分别创建表<code class="codeph">oe.product_tracking</code>并在表<code class="codeph">oe.product_information</code>上创建触发器。在这两个事务中，由于查询谓词，对系统表（ <code class="codeph">SYS</code>拥有的表）执行的DML语句被过滤掉。
                                 </p>
                                 <p>DML事务1.9.1598更新了<code class="codeph">oe.product_information</code>表。此事务中的更新操作已完全翻译。但是，查询输出还包含一些未翻译的重构SQL语句。最有可能的是，这些语句是在将数据字典解压缩到重做日志文件之后创建的<code class="codeph">oe.product_tracking</code>表上完成的。
                                 </p>
                                 <p>（下一个示例显示如何使用<code class="codeph">DDL_DICT_TRACKING</code>选项运行LogMiner，以便完全翻译所有SQL语句;不返回二进制数据。）
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr，SQL_REDO FROM V $ LOGMNR_CONTENTS WHERE SEG_OWNER为NULL或SEG_OWNER NOT IN（'SYS'，'SYSTEM'）和TIMESTAMP&gt; '10 -jan-2012 15:59:53'; USR XID SQL_REDO --- -------- ----------------------------------- SYS 1.2.1594设置事务读写; SYS 1.2.1594 create table oe.product_tracking（product_id number not null，modified_time date，old_list_price number（8,2），old_warranty_period interval year（2）to month）; SYS 1.2.1594 commit; SYS 1.18.1602设置事务读写; SYS 1.18.1602在更新oe.product_information之前为每一行创建或替换触发器oe.product_tracking_trigger（new.list_price &lt;&gt; old.list_price或new.warranty_period &lt;&gt; old.warranty_period）声明开始插入oe.product_tracking值（： old.product_id，sysdate，：old.list_price，：old.warranty_period）;结束; SYS 1.18.1602提交; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 100，其中“PRODUCT_ID”= 1729，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 80并且ROWID ='AAAHTKAABAAAY9yAAA'; OE 1.9.1598插入“UNKNOWN”。“OBJ＃33415”值“COL 1”= HEXTORAW（'c2121e'），“COL 2”= HEXTORAW（'7867010d110804'），“COL 3”= HEXTORAW（'c151' ），“COL 4”= HEXTORAW（'800000053c'）; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 92其中“PRODUCT_ID”= 2340并且“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 72并且ROWID ='AAAHTKAABAAAY9zAAA'; OE 1.9.1598插入“UNKNOWN”。“OBJ＃33415”值“COL 1”= HEXTORAW（'c21829'），“COL 2”= HEXTORAW（'7867010d110808'），“COL 3”= HEXTORAW（'c149' ），“COL 4”= HEXTORAW（'800000053c'）; OE 1.9.1598提交;</pre></li>
                              <li>
                                 <p>如果需要，发出其他查询。</p>
                                 <p>显示作为<code class="codeph">CREATE TABLE</code> DDL语句的一部分执行的所有DML语句。这包括用户执行的语句和Oracle内部执行的语句。
                                 </p>
                                 <div class="infoboxnote" id="GUID-90944343-46BB-4BD5-A0C6-7A4B79D9BEF0__IFYOUCHOOSETOREAPPLYSTATEMENTSDISPL-50816118">
                                    <p class="notep1">注意：</p>
                                    <p>如果您选择重新应用查询显示的语句（如此处所示的语句），则仅重新应用DDL语句。不要重新应用Oracle内部执行的DML语句，否则可能会损坏数据库。在以下输出中，您应该在重新应用操作中使用的唯一语句是<code class="codeph">CREATE TABLE OE.PRODUCT_TRACKING</code>语句。
                                    </p>
                                 </div><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO FROM V $ LOGMNR_CONTENTS WHERE XIDUSN = 1且XIDSLT = 2且XIDSQN = 1594; SQL_REDO ------------------------------------------------- -------------------------------设置事务读写;插入“SYS”。“OBJ $”值“OBJ＃”= 33415，“DATAOBJ＃”= 33415，“OWNER＃”= 37，“NAME”='PRODUCT_TRACKING'，“NAMESPACE”= 1，“SUBNAME”是NULL，“TYPE＃”= 2，“CTIME”= TO_DATE（'13 -jan-2012 14:01:03'，'dd-mon-yyyy hh24：mi：ss'），“MTIME”= TO_DATE（'13 -jan-2012 14:01:03'，'dd-mon-yyyy hh24：mi：ss'），“STIME”= TO_DATE（'13 -jan-2012 14:01:03'，'dd-mon-yyyy hh24：mi：ss'），“STATUS”= 1，“REMOTEOWNER”为空，“LINKNAME”为空，“FLAGS”= 0，“OID $”为空，“SPARE1”= 6，“SPARE2”= 1 ，“SPARE3”为空，“SPARE4”为空，“SPARE5”为空，“SPARE6”为空;插入“SYS”。“TAB $”值“OBJ＃”= 33415，“DATAOBJ＃”= 33415，“TS＃”= 0，“FILE＃”= 1，“BLOCK＃”= 121034，“BOBJ＃” IS NULL，“TAB＃”IS NULL，“COLS”= 5，“CLUCOLS”为空，“PCTFREE $”= 10，“PCTUSED $”= 40，“INITRANS”= 1，“MAXTRANS”= 255，“FLAGS “= 1，”AUDIT $“='--------------------------------------'， “ROWCNT”为空，“BLKCNT”为空，“EMPCNT”为空，“AVGSPC”为空，“CHNCNT”为空，“AVGRLN”为空，“AVGSPC_FLB”为空，“FLBCNT”为空，“ANALYZETIME “IS NULL，”SAMPLESIZE“IS NULL，”DEGREE“IS NULL，”INSTANCES“IS NULL”，INTCOLS“= 5，”KERNELCOLS“= 5，”PROPERTY“= 536870912，”TRIGFLAG“= 0，”SPARE1“= 178，“SPARE2”为空，“SPARE3”为空，“SPARE4”为空，“SPARE5”为空，“SPARE6”= TO_DATE（'13 -jan-2012 14:01:05'，'dd-mon- yyyy hh24：mi：ss'），插入“SYS”。“COL $”值“OBJ＃”= 33415，“COL＃”= 1，“SEGCOL＃”= 1，“SEGCOLLENGTH”= 22，“OFFSET” = 0，“NAME”='PRODUCT_ID'，“TYPE＃”= 2，“LENGTH”= 22，“FIXEDSTORAGE”= 0，“PRECISION＃”为空，“SCALE”为空，“NULL $” = 1，“DEFLENGTH”为空，“SPARE6”为空，“INTCOL＃”= 1，“PROPERTY”= 0，“CHARSETID”= 0，“CHARSETFORM”= 0，“SPARE1”= 0，“SPARE2”= 0，“SPARE3”= 0，“SPARE4”为空，“SPARE5”为空，“DEFAULT $”为空;插入“SYS”。“COL $”值“OBJ＃”= 33415，“COL＃”= 2，“SEGCOL＃”= 2，“SEGCOLLENGTH”= 7，“OFFSET”= 0，“NAME”='MODIFIED_TIME '，“TYPE＃”= 12，“LENGTH”= 7，“FIXEDSTORAGE”= 0，“PRECISION＃”为空，“SCALE”为空，“NULL $”= 0，“DEFLENGTH”为空，“SPARE6” IS NULL，“INTCOL＃”= 2，“PROPERTY”= 0，“CHARSETID”= 0，“CHARSETFORM”= 0，“SPARE1”= 0，“SPARE2”= 0，“SPARE3”= 0，“SPARE4”IS NULL，“SPARE5”为空，“DEFAULT $”为空;插入“SYS”。“COL $”值“OBJ＃”= 33415，“COL＃”= 3，“SEGCOL＃”= 3，“SEGCOLLENGTH”= 22，“OFFSET”= 0，“NAME”='OLD_LIST_PRICE '，“TYPE＃”= 2，“LENGTH”= 22，“FIXEDSTORAGE”= 0，“PRECISION＃”= 8，“SCALE”= 2，“NULL $”= 0，“DEFLENGTH”为空，“SPARE6” IS NULL，“INTCOL＃”= 3，“PROPERTY”= 0，“CHARSETID”= 0，“CHARSETFORM”= 0，“SPARE1”= 0，“SPARE2”= 0，“SPARE3”= 0，“SPARE4”IS NULL，“SPARE5”为空，“DEFAULT $”为空;插入“SYS”。“COL $”值“OBJ＃”= 33415，“COL＃”= 4，“SEGCOL＃”= 4，“SEGCOLLENGTH”= 5，“OFFSET”= 0，“NAME”='OLD_WARRANTY_PERIOD '，“TYPE＃”= 182，“LENGTH”= 5，“FIXEDSTORAGE”= 0，“PRECISION＃”= 2，“SCALE”= 0，“NULL $”= 0，“DEFLENGTH”为空，“SPARE6” IS NULL，“INTCOL＃”= 4，“PROPERTY”= 0，“CHARSETID”= 0，“CHARSETFORM”= 0，“SPARE1”= 0，“SPARE2”= 2，“SPARE3”= 0，“SPARE4”IS NULL，“SPARE5”为空，“DEFAULT $”为空;插入“SYS”。“CCOL $”值“OBJ＃”= 33415，“CON＃”= 2090，“COL＃”= 1，“POS＃”为空，“INTCOL＃”= 1，“SPARE1”= 0，“SPARE2”为空，“SPARE3”为空，“SPARE4”为空，“SPARE5”为空，“SPARE6”为空;插入“SYS”。“CDEF $”值“OBJ＃”= 33415，“CON＃”= 2090，“COLS”= 1，“TYPE＃”= 7，“ROBJ＃”IS NULL，“RCON＃”IS NULL，“RRULES”为空，“MATCH＃”为空，“REFACT”为空，“ENABLED”= 1，“CONDLENGTH”= 24，“SPARE6”为空，“INTCOLS”= 1，“MTIME”= TO_DATE （'13 -jan-2012 14:01:08'，'dd-mon-yyyy hh24：mi：ss'），“DEFER”= 12，“SPARE1”= 6，“SPARE2”为空，“SPARE3”是NULL，“SPARE4”为空，“SPARE5”为空，“CONDITION”=“”PRODUCT_ID“不为空”; create table oe.product_tracking（product_id number not null，modified_time date，old_product_description varchar2（2000），old_list_price number（8,2），old_warranty_period interval year（2）to month）;更新“SYS”。“SEG $”设置“TYPE＃”= 5，“BLOCKS”= 5，“EXTENTS”= 1，“INIEXTS”= 5，“MINEXTS”= 1，“MAXEXTS”= 121，“EXTSIZE” = 5，“EXTPCT”= 50，“USER＃”= 37，“LISTS”= 0，“GROUPS”= 0，“CACHEHINT”= 0，“HWMINCR”= 33415，“SPARE1”= 1024，其中“TS＃” = 0，“FILE＃”= 1，“BLOCK＃”= 121034，“TYPE＃”= 3，“BLOCKS”= 5，“EXTENTS”= 1，“INIEXTS”= 5，“MINEXTS”= 1，“MAXEXTS” “= 121且”EXTSIZE“= 5且”EXTPCT“= 50且”USER＃“= 37且”LISTS“= 0且”GROUPS“= 0且”BITMAPRANGES“= 0且”CACHEHINT“= 0且”SCANHINT“ = 0且“HWMINCR”= 33415且“SPARE1”= 1024且“SPARE2”为空且ROWID ='AAAAAIAABAAAdMOAAB';插入“SYS”。“CON $”值“OWNER＃”= 37，“NAME”='SYS_C002090'，“CON＃”= 2090，“SPARE1”为空，“SPARE2”为空，“SPARE3”为空，“SPARE4”为空，“SPARE5”为空，“SPARE6”为空;承诺;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4253"></a><a id="SUTIL4254"></a><a id="SUTIL4255"></a><a id="SUTIL4256"></a><a id="SUTIL4257"></a><a id="SUTIL4258"></a><a id="SUTIL4259"></a><a id="SUTIL1610"></a><div class="props_rev_3"><a id="GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F" name="GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F"></a><h5 id="SUTIL-GUID-E0DDC97C-7364-4BED-AF2A-E0B486F0E22F" class="sect5"><span class="enumeration_section">22.13.1.5</span>示例5：跟踪内部字典中的DDL语句</h5>
                     <div>
                        <div class="section">
                           <p>通过使用<code class="codeph">DBMS_LOGMNR.DDL_DICT_TRACKING</code>选项，此示例确保使用重做日志文件中遇到的DDL语句更新LogMiner内部字典。
                           </p>
                           <ol>
                              <li>
                                 <p>确定数据库最近归档了哪个重做日志文件。</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃FROM V $ ARCHIVED_LOG WHERE FIRST_TIME =（SELECT MAX（FIRST_TIME）FROM V $ ARCHIVED_LOG）; NAME SEQUENCE＃-------------------------------------------- --- ----------- /usr/oracle/data/db1arch_1_210_482701534.dbf 210</pre></li>
                              <li>
                                 <p>由于字典可能包含在多个重做日志文件中，因此您需要确定哪些重做日志文件包含数据字典的开头和结尾。查询<code class="codeph">V$ARCHIVED_LOG</code>视图，如下所示：</p>
                                 <ol type="a">
                                    <li>
                                       <p>查找包含数据字典提取结尾的重做日志。必须在要分析的重做日志文件之前创建此重做日志文件，但该文件应尽可能新。</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃，DICTIONARY_BEGIN d_beg，DICTIONARY_END d_end FROM V $ ARCHIVED_LOG WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG WHERE DICTIONARY_END ='YES'和SEQUENCE＃&lt;210）; NAME SEQUENCE＃D_BEG D_END --------------------------------------------  - --------- ----- ------ /usr/oracle/data/db1arch_1_208_482701534.dbf 208否是</pre></li>
                                    <li>
                                       <p>找到包含数据字典提取的开头的重做日志文件，该文件与前一个SQL语句找到的字典的结尾相匹配：</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，SEQUENCE＃，DICTIONARY_BEGIN d_beg，DICTIONARY_END d_end FROM V $ ARCHIVED_LOG WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG WHERE DICTIONARY_BEGIN ='YES'和SEQUENCE＃&lt;= 208）; NAME SEQUENCE＃D_BEG D_END --------------------------------------------  - --------- ----- ------ /usr/oracle/data/db1arch_1_208_482701534.dbf 207是否</pre></li>
                                 </ol>
                              </li>
                              <li>
                                 <p>确保您拥有重做日志文件的完整列表。</p>
                                 <p>要成功应用重做日志文件中遇到的DDL语句，请确保所有文件都包含在要挖掘的重做日志文件列表中。对应于序列＃209的缺失日志文件必须包含在列表中。通过发出以下查询来确定需要添加到列表的重做日志文件的名称：</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称，其中SEQUENCE＃&gt; = 207 AND SEQUENCE＃&lt;= 210 ORDER BY SEQUENCE＃ASC; NAME -------------------------------------------- / usr / oracle / data / db1arch_1_207_482701534.dbf /usr/oracle/data/db1arch_1_208_482701534.dbf /usr/oracle/data/db1arch_1_209_482701534.dbf /usr/oracle/data/db1arch_1_210_482701534.dbf</pre></li>
                              <li>
                                 <p>指定感兴趣的重做日志文件列表。</p>
                                 <p>包括重做日志文件，其中包含字典的开头和结尾，您要挖掘的重做日志文件以及创建无间隙列表所需的任何重做日志文件。您可以按任何顺序添加重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_210_482701534.dbf'， -</pre><pre class="oac_no_warn" dir="ltr">OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_209_482701534.dbf'）; EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_208_482701534.dbf'）; EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'/usr/oracle/data/db1arch_1_207_482701534.dbf'）;</pre></li>
                              <li>
                                 <p>通过指定要使用的字典以及<code class="codeph">DDL_DICT_TRACKING</code> ， <code class="codeph">COMMITTED_DATA_ONLY</code>和<code class="codeph">PRINT_PRETTY_SQL</code>选项来启动LogMiner。
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS +  -  DBMS_LOGMNR.DDL_DICT_TRACKING +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>要减少返回的行数，请从查询中排除在<code class="codeph">SYS</code>或<code class="codeph">SYSTEM</code>模式中完成的所有DML语句。（此查询指定时间戳以排除字典提取中涉及的事务。）
                                 </p>
                                 <p>该查询返回正确翻译的所有重构SQL语句以及由于触发器执行而在<code class="codeph">oe.product_tracking</code>表上执行的插入操作。
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）作为XID，SQL_REDO来自V $ LOGMNR_CONTENTS WHERE SEG_OWNER为NULL或SEG_OWNER NOT IN（'SYS'，'SYSTEM'）和TIMESTAMP&gt; '10 -jan-2012 15:59:53'; USR XID SQL_REDO ----------- -------- ---------------------------- ------- SYS 1.2.1594设置事务读写; SYS 1.2.1594 create table oe.product_tracking（product_id number not null，modified_time date，old_list_price number（8,2），old_warranty_period interval year（2）to month）; SYS 1.2.1594 commit; SYS 1.18.1602设置事务读写; SYS 1.18.1602在更新oe.product_information之前为每一行创建或替换触发器oe.product_tracking_trigger（new.list_price &lt;&gt; old.list_price或new.warranty_period &lt;&gt; old.warranty_period）声明开始插入oe.product_tracking值（： old.product_id，sysdate，：old.list_price，：old.warranty_period）;结束; SYS 1.18.1602提交; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 100，其中“PRODUCT_ID”= 1729，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 80并且ROWID ='AAAHTKAABAAAY9yAAA'; OE 1.9.1598插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 1729，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 16:07:03'，'dd-mon-yyyy hh24：mi：ss '），“OLD_LIST_PRICE”= 80，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 92其中“PRODUCT_ID”= 2340并且“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 72并且ROWID ='AAAHTKAABAAAY9zAAA'; OE 1.9.1598插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 2340，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 16:07:07'，'dd-mon-yyyy hh24：mi：ss '），“OLD_LIST_PRICE”= 72，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）; OE 1.9.1598提交;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4260"></a><a id="SUTIL4261"></a><a id="SUTIL4262"></a><a id="SUTIL4263"></a><a id="SUTIL4264"></a><a id="SUTIL1611"></a><div class="props_rev_3"><a id="GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09" name="GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09"></a><h5 id="SUTIL-GUID-6BE36A8B-0078-4EB1-9D57-80E51A2DFB09" class="sect5"><span class="enumeration_section">22.13.1.6</span>例6：按时间范围过滤输出</h5>
                     <div>
                        <div class="section">
                           <p>在前两个示例中，通过在查询中指定基于时间戳的谓词（timestamp&gt; '10 -jan-2012 15:59:53'）来过滤行。但是，基于时间戳值过滤掉重做记录的更有效方法是在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程调用中指定时间范围，如本例所示。
                           </p>
                           <ol>
                              <li>
                                 <p>创建一个重做日志文件列表。</p>
                                 <p>假设您要挖掘自给定时间以来生成的重做日志文件。以下过程根据指定的时间创建重做日志文件列表。随后的SQL <code class="codeph">EXECUTE</code>语句调用该过程并将开始时间指定为1月13日至2012年1月2日。
                                 </p><pre class="oac_no_warn" dir="ltr">-   -  my_add_logfiles  - 添加在指定的start_time之后生成的所有存档日志。- 创建或替换过程my_add_logfiles（in_start_time IN DATE）as CURSOR c_log IS SELECT NAME FROM V $ ARCHIVED_LOG WHERE FIRST_TIME&gt; = in_start_time; count pls_integer：= 0; my_option pls_integer：= DBMS_LOGMNR.NEW; BEGIN FOR c_log_rec IN c_log LOOP DBMS_LOGMNR.ADD_LOGFILE（LOGFILENAME =&gt; c_log_rec.name，OPTIONS =&gt; my_option）; my_option：= DBMS_LOGMNR.ADDFILE; DBMS_OUTPUT.PUT_LINE（'添加日志文件'|| c_log_rec.name）;结束循环;结束; / EXECUTE my_add_logfiles（in_start_time =&gt; '13 -jan-2012 14:00:00'）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_LOGS</code>以查看重做日志文件列表。
                                 </p>
                                 <p>此示例包括输出中重做日志文件的大小。</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name，LOW_TIME start_time，FILESIZE bytes FROM V $ LOGMNR_LOGS;名称START_TIME BYTES ----------------------------------- ------------ -------- ---------------- /usr/orcl/arch1_310_482932022.dbf 13-jan-2012 14:02:35 23683584 / usr / orcl / arch1_311_482932022。 dbf 13-jan-2012 14:56:35 2564096 /usr/orcl/arch1_312_482932022.dbf 13-jan-2012 15:10:43 23683584 /usr/orcl/arch1_313_482932022.dbf 13-jan-2012 15:17:52 23683584 /usr/orcl/arch1_314_482932022.dbf 13-jan-2012 15:23:10 23683584 /usr/orcl/arch1_315_482932022.dbf 13-jan-2012 15:43:22 23683584 /usr/orcl/arch1_316_482932022.dbf 13-jan- 2012 16:03:10 23683584 /usr/orcl/arch1_317_482932022.dbf 13-jan-2012 16:33:43 23683584 /usr/orcl/arch1_318_482932022.dbf 13-jan-2012 17:23:10 23683584</pre></li>
                              <li>
                                 <p>调整重做日志文件列表。</p>
                                 <p>假设您意识到您只想挖掘下午3点到4点之间生成的重做日志文件</p>
                                 <p>您可以使用查询谓词（ <code class="codeph">timestamp &gt; '13-jan-2012 15:00:00' and timestamp &lt; '13-jan-2012 16:00:00'</code> ）来完成此操作。但是，将在LogMiner返回的每一行上计算查询谓词，并且内部挖掘引擎不会根据查询谓词过滤行。因此，虽然您只想将重做日志文件<code class="codeph">arch1_311_482932022.dbf</code>行从<code class="codeph">arch1_311_482932022.dbf</code>中<code class="codeph">arch1_315_482932022.dbf,</code>您的查询将导致挖掘注册到LogMiner会话的所有重做日志文件。
                                 </p>
                                 <p>此外，尽管您可以使用查询谓词并手动删除不属于感兴趣的时间范围的重做日志文件，但最简单的解决方案是在<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程调用中指定感兴趣的时间范围。
                                 </p>
                                 <p>虽然这不会更改重做日志文件列表，但LogMiner将仅挖掘落在指定时间范围内的重做日志文件。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  STARTTIME =&gt; '13 -jan-2012 15:00:00'， -  ENDTIME =&gt; '13 -jan-2012 16:00:00'， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  -  DBMS_LOGMNR。 COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT TIMESTAMP，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）AS XID，</pre><pre class="oac_no_warn" dir="ltr">SQL_REDO FROM V $ LOGMNR_CONTENTS WHERE SEG_OWNER ='OE'; TIMESTAMP XID SQL_REDO --------------------- ----------- --------------- ----------------- 13-jan-2012 15:29:31 1.17.2376更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）其中“PRODUCT_ID”= 3399，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 02-00'），ROWID ='AAAHTKAABAAAY9TAAE'; 13-jan-2012 15:29:34 1.17.2376插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 3399，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 15:29:34'，'dd -mon-yyyy hh24：mi：ss'），“OLD_LIST_PRICE”= 815，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 02-00'）; 13-jan-2012 15:52:43 1.15.1756更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'），其中“PRODUCT_ID”= 1768，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 02-00'）和ROWID ='AAAHTKAABAAAY9UAAB'; 13-jan-2012 15:52:43 1.15.1756插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 1768，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 16:52:43'，'dd -mon-yyyy hh24：mi：ss'），“OLD_LIST_PRICE”= 715，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 02-00'）;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-659D077D-CEB3-4B5A-AD70-EEA41D6A1C4C" title="指定重做日志文件的示例。">通过显式指定感兴趣的重做日志文件进行挖掘的示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1612"></a><div class="props_rev_3"><a id="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" name="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4"></a><h4 id="SUTIL-GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" class="sect4"><span class="enumeration_section">22.13.2</span>挖掘示例未明确指定重做日志文件列表</h4>
                  <div>
                     <p>未指定重做日志文件的示例。</p>
                     <p>前面的一组示例明确指定了要挖掘的重做日志文件。但是，如果您在生成重做日志文件的同一数据库中进行挖掘，则可以通过仅指定感兴趣的时间（或SCN）范围来挖掘相应的重做日志文件列表。要在不明确指定的情况下挖掘一组重做日志文件，请指定时间范围或感兴趣的SCN范围。</p>
                     <div class="infoboxnote" id="GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4__GUID-B96FA62F-213C-4239-9BA8-1D1A627CB71A">
                        <p class="notep1">注意：</p>Oracle Database 19c（19.1）中不支持<code class="codeph">dbms_logmnr.start_logmnr</code>软件包的<code class="codeph">continuous_mine</code>选项，该选项不再可用。
                     </div>
                     <p>本节包含以下示例列表;这些示例最好按顺序阅读，因为每个示例都建立在它之前的示例或示例之上：</p>
                     <p>显示的SQL输出格式可能与这些示例中显示的不同。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-F35C6876-5AE0-4229-891D-47B1C3759A11">示例1：在给定时间范围内挖掘重做日志文件</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A">示例2：在给定SCN范围内挖掘重做日志文件</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B">示例3：使用连续挖掘在查询中包含未来值</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="使用LogMiner的示例。">使用LogMiner的示例</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4265"></a><a id="SUTIL4266"></a><a id="SUTIL4267"></a><a id="SUTIL4268"></a><a id="SUTIL4269"></a><a id="SUTIL4270"></a><a id="SUTIL1613"></a><div class="props_rev_3"><a id="GUID-F35C6876-5AE0-4229-891D-47B1C3759A11" name="GUID-F35C6876-5AE0-4229-891D-47B1C3759A11"></a><h5 id="SUTIL-GUID-F35C6876-5AE0-4229-891D-47B1C3759A11" class="sect5"><span class="enumeration_section">22.13.2.1</span>示例1：在给定时间范围内挖掘重做日志文件</h5>
                     <div>
                        <div class="section">
                           <p>此示例类似于示例4：在重做日志文件中使用LogMiner Dictionary，但未明确指定重做日志文件列表。此示例假定您要使用提取到重做日志文件的数据字典。</p>
                           <ol>
                              <li>
                                 <p>确定包含数据字典开头的重做日志文件的时间戳。</p><pre class="oac_no_warn" dir="ltr">从V $ ARCHIVED_LOG中选择名称，FIRST_TIME</pre><pre class="oac_no_warn" dir="ltr">WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG WHERE DICTIONARY_BEGIN ='YES'）; NAME FIRST_TIME -------------------------------------------- ---- ---------------- /usr/oracle/data/db1arch_1_207_482701534.dbf 10-jan-2012 12:01:34</pre></li>
                              <li>
                                 <p>显示到目前为止生成的所有重做日志文件。</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name FROM V $ LOGMNR_LOGS WHERE LOW_TIME&gt; '10 -jan-2012 12:01:34'; NAME ---------------------------------------------- / usr / oracle / data / db1arch_1_207_482701534.dbf /usr/oracle/data/db1arch_1_208_482701534.dbf /usr/oracle/data/db1arch_1_209_482701534.dbf /usr/oracle/data/db1arch_1_210_482701534.dbf</pre></li>
                              <li>
                                 <p>通过指定要使用的字典以及<code class="codeph">COMMITTED_DATA_ONLY</code>和<code class="codeph">PRINT_PRETTY_SQL</code>选项来启动LogMiner。
                                 </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  STARTTIME =&gt; '10 -jan-2012 12:01:34'， -  ENDTIME =&gt; SYSDATE， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_REDO_LOGS +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL +  - ）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_LOGS</code>视图。
                                 </p>
                                 <p>此步骤显示<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>过程包括到目前为止生成的所有重做日志文件，如预期的那样。（将此步骤中的输出与步骤2中的输出进行比较。）
                                 </p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name FROM V $ LOGMNR_LOGS;名称  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ----- /usr/oracle/data/db1arch_1_207_482701534.dbf /usr/oracle/data/db1arch_1_208_482701534.dbf /usr/oracle/data/db1arch_1_209_482701534.dbf /usr/oracle/data/db1arch_1_210_482701534.dbf</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>要减少查询返回的行数，请排除在<code class="codeph">SYS</code>或<code class="codeph">SYSTEM</code>模式中完成的所有DML语句。（此查询指定时间戳以排除字典提取中涉及的事务。）
                                 </p>
                                 <p>请注意，查询返回的所有重构SQL语句都已正确转换。</p><pre class="oac_no_warn" dir="ltr">SELECT USERNAME AS usr，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）作为XID，SQL_REDO来自V $ LOGMNR_CONTENTS WHERE SEG_OWNER为NULL或SEG_OWNER NOT IN（'SYS'，'SYSTEM'）和TIMESTAMP&gt; '10 -jan-2012 15:59:53'; USR XID SQL_REDO ----------- -------- ---------------------------- ------- SYS 1.2.1594设置事务读写; SYS 1.2.1594 create table oe.product_tracking（product_id number not null，modified_time date，old_list_price number（8,2），old_warranty_period interval year（2）to month）; SYS 1.2.1594 commit; SYS 1.18.1602设置事务读写; SYS 1.18.1602在更新oe.product_information之前为每一行创建或替换触发器oe.product_tracking_trigger（new.list_price &lt;&gt; old.list_price或new.warranty_period &lt;&gt; old.warranty_period）声明开始插入oe.product_tracking值（： old.product_id，sysdate，：old.list_price，：old.warranty_period）;结束; SYS 1.18.1602提交; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 100，其中“PRODUCT_ID”= 1729，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 80并且ROWID ='AAAHTKAABAAAY9yAAA'; OE 1.9.1598插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 1729，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 16:07:03'，'dd-mon-yyyy hh24：mi：ss '），“OLD_LIST_PRICE”= 80，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）; OE 1.9.1598更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 08-00'），“LIST_PRICE”= 92其中“PRODUCT_ID”= 2340并且“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00 '）和“LIST_PRICE”= 72并且ROWID ='AAAHTKAABAAAY9zAAA'; OE 1.9.1598插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 2340，“MODIFIED_TIME”= TO_DATE（'13 -jan-2012 16:07:07'，'dd-mon-yyyy hh24：mi：ss '），“OLD_LIST_PRICE”= 72，“OLD_WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'）; OE 1.9.1598提交;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：未</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="未指定重做日志文件的示例。">明确指定重做日志文件列表的挖掘示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4271"></a><a id="SUTIL4272"></a><a id="SUTIL4273"></a><a id="SUTIL4274"></a><a id="SUTIL4275"></a><a id="SUTIL1614"></a><div class="props_rev_3"><a id="GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A" name="GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A"></a><h5 id="SUTIL-GUID-97F5B369-A905-4BCF-AA7F-E9F932D3D14A" class="sect5"><span class="enumeration_section">22.13.2.2</span>示例2：在给定的SCN范围内挖掘重做日志文件</h5>
                     <div>
                        <div class="section">
                           <p>此示例显示如何指定感兴趣的SCN范围并挖掘满足该范围的重做日志文件。您可以使用LogMiner查看所有已提交的DML语句，这些语句的效果尚未在数据文件中永久生效。</p>
                           <p>请注意，在此示例中（与其他示例不同），不会假定您已设置<code class="codeph">NLS_DATE_FORMAT</code>参数。
                           </p>
                           <ol>
                              <li>
                                 <p>确定最后一个检查点的SCN。</p><pre class="oac_no_warn" dir="ltr">SELECT CHECKPOINT_CHANGE＃，CURRENT_SCN来自V $ DATABASE;</pre><pre class="oac_no_warn" dir="ltr">CHECKPOINT_CHANGE＃CURRENT_SCN ------------------ --------------- 56453576 56454208</pre></li>
                              <li>
                                 <p>启动LogMiner。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -</pre><pre class="oac_no_warn" dir="ltr">STARTSCN =&gt; 56453576， -  ENDSCN =&gt; 56454208， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG +  -  DBMS_LOGMNR.COMMITTED_DATA_ONLY +  -  DBMS_LOGMNR.PRINT_PRETTY_SQL +  - ）;</pre></li>
                              <li>
                                 <p>显示LogMiner添加的归档重做日志文件列表。</p><pre class="oac_no_warn" dir="ltr">SELECT FILENAME name，LOW_SCN，NEXT_SCN FROM V $ LOGMNR_LOGS;</pre><pre class="oac_no_warn" dir="ltr">NAME LOW_SCN NEXT_SCN -------------------------------------------- --- ----- -------- /usr/oracle/data/db1arch_1_215_482701534.dbf 56316771 56453579</pre><p>请注意，LogMiner添加的重做日志文件不包含整个SCN范围。LogMiner会在查询执行期间根据需要自动添加联机重做日志文件中包含的其余SCN范围。使用以下查询确定添加的重做日志文件是否是生成的最新归档重做日志文件。</p><pre class="oac_no_warn" dir="ltr">选择名称来自V $ ARCHIVED_LOG WHERE SEQUENCE＃=（SELECT MAX（SEQUENCE＃）FROM V $ ARCHIVED_LOG）; NAME -------------------------------------------- / usr / oracle /数据/ db1arch_1_215_482701534.dbf</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图以查看对用户表所做的更改。
                                 </p>
                                 <p>以下查询不返回与事务1.6.1911关联的<code class="codeph">SET TRANSACTION READ WRITE</code>和<code class="codeph">COMMIT</code>语句，因为这些语句没有与它们关联的段所有者（ <code class="codeph">SEG_OWNER</code> ）。
                                 </p>
                                 <p>请注意，默认的<code class="codeph">NLS_DATE_FORMAT</code> ，'DD-MON-RR'用于显示<code class="codeph">DATE</code>类型的<code class="codeph">MODIFIED_TIME</code>列。</p><pre class="oac_no_warn" dir="ltr">SELECT SCN，（XIDUSN ||'。'|| XIDSLT || ”。'|| XIDSQN）作为XID，SQL_REDO来自V $ LOGMNR_CONTENTS WHERE SEG_OWNER NOT IN（'SYS'，'SYSTEM'）; SCN XID SQL_REDO ---------- ---------- ------------- 56454198 1.6.1911更新“OE”。“PRODUCT_INFORMATION”设置“ WARRANTY_PERIOD“= TO_YMINTERVAL（'+ 05-00'），其中”PRODUCT_ID“= 2430，”WARRANTY_PERIOD“= TO_YMINTERVAL（'+ 02-00'），ROWID ='AAAHTKAABAAAY9AAAC'; 56454199 1.6.1911插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 2430，“MODIFIED_TIME”= TO_DATE（'17 -JAN-03'，'DD-MON-RR'），“OLD_LIST_PRICE”= 175，“ OLD_WARRANTY_PERIOD“= TO_YMINTERVAL（'+ 02-00'）; 56454204 1.6.1911更新“OE”。“PRODUCT_INFORMATION”设置“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 05-00'），其中“PRODUCT_ID”= 2302，“WARRANTY_PERIOD”= TO_YMINTERVAL（'+ 02-00'），ROWID =' AAAHTKAABAAAY9QAAA“; 56454206 1.6.1911插入“OE”。“PRODUCT_TRACKING”值“PRODUCT_ID”= 2302，“MODIFIED_TIME”= TO_DATE（'17 -JAN-03'，'DD-MON-RR'），“OLD_LIST_PRICE”= 150，“ OLD_WARRANTY_PERIOD“= TO_YMINTERVAL（'+ 02-00'）;</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：未</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="未指定重做日志文件的示例。">明确指定重做日志文件列表的挖掘示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL4276"></a><a id="SUTIL4277"></a><a id="SUTIL4278"></a><a id="SUTIL1615"></a><div class="props_rev_3"><a id="GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B" name="GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B"></a><h5 id="SUTIL-GUID-7ADC1F9A-953D-4FEC-A7AB-CE3C70B77D7B" class="sect5"><span class="enumeration_section">22.13.2.3</span>示例3：使用连续挖掘在查询中包含未来值</h5>
                     <div>
                        <div class="section">
                           <p>要指定查询未在某个未来时间发生或达到SCN之前完成，请<code class="codeph">ENDSCN</code>过程的<code class="codeph">DBMS_LOGMNR.START_LOGMNR</code>的<code class="codeph">ENDTIME</code>或<code class="codeph">ENDSCN</code>选项设置为将来的时间或尚未达到的SCN值。
                           </p>
                           <p>此示例假定您要监视从现在起到5小时后对表<code class="codeph">hr.employees</code>所做的所有更改，以及您正在使用联机目录中的字典。
                           </p>
                           <ol>
                              <li>
                                 <p>启动LogMiner。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -</pre><pre class="oac_no_warn" dir="ltr">STARTTIME =&gt; SYSDATE， -  ENDTIME =&gt; SYSDATE + 5/24， -  OPTIONS =&gt; DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG）;</pre></li>
                              <li>
                                 <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                                 </p>
                                 <p>在遇到感兴趣的时间范围（从现在起5小时）之后生成的第一个重做日志文件记录之前，此选择操作将不会完成。您可以按Ctrl + C提前结束选择操作。</p>
                                 <p>此示例指定<code class="codeph">SET</code> <code class="codeph">ARRAYSIZE</code>语句，以便在重做日志文件中输入行时显示这些行。如果未指定<code class="codeph">SET ARRAYSIZE</code>语句，则在SQL内部缓冲区已满之前不会返回行。
                                 </p><pre class="oac_no_warn" dir="ltr">SET ARRAYSIZE 1; SELECT USERNAME AS usr，SQL_REDO FROM V $ LOGMNR_CONTENTS WHERE SEG_OWNER ='HR'AND TABLE_NAME ='EMPLOYEES';</pre></li>
                              <li>
                                 <p>结束LogMiner会话。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：未</strong> <a href="oracle-logminer-utility.html#GUID-BAB7801D-BB5E-49D8-BC5A-0C08E5F3C2B4" title="未指定重做日志文件的示例。">明确指定重做日志文件列表的挖掘示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1616"></a><div class="props_rev_3"><a id="GUID-143798E2-B0E0-4E9D-A70C-08593A117027" name="GUID-143798E2-B0E0-4E9D-A70C-08593A117027"></a><h4 id="SUTIL-GUID-143798E2-B0E0-4E9D-A70C-08593A117027" class="sect4"><span class="enumeration_section">22.13.3</span>示例场景</h4>
                  <div>
                     <p>有关如何将LogMiner用于典型方案的示例。</p>
                     <p>这些例子包括：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4">场景1：使用LogMiner跟踪特定用户所做的更改</a><br></li>
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3">场景2：使用LogMiner计算表访问统计信息</a><br>此方案描述了如何使用LogMiner计算表访问统计信息。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-40619B3B-8BDF-4D90-B924-5A0F8A631F98" title="使用LogMiner的示例。">使用LogMiner的示例</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1617"></a><div class="props_rev_3"><a id="GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4" name="GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4"></a><h5 id="SUTIL-GUID-E0333B57-A26D-4E00-9E8E-5D21035C73B4" class="sect5"><span class="enumeration_section">22.13.3.1</span>场景1：使用LogMiner跟踪特定用户所做的更改</h5>
                     <div>
                        <p>此示例显示如何查看单个用户在特定时间范围内对数据库所做的所有更改： <code class="codeph">joedevo</code> 。连接到数据库，然后执行以下步骤：</p>
                        <ol>
                           <li>
                              <p>创建LogMiner字典文件。</p>
                              <p>要使用LogMiner分析<code class="codeph">joedevo</code>的数据，必须先创建一个LogMiner字典文件，然后才能对<code class="codeph">joedevo</code>使用的表进行任何表定义更改，或者在LogMiner启动时使用在线目录。有关创建LogMiner词典的示例，请参阅<a href="oracle-logminer-utility.html#GUID-8D74F78A-E7D1-48E6-8E65-5E8CC55F0757" title="提取LogMiner字典。">提取</a> LogMiner词典。此示例使用已提取到重做日志文件的LogMiner字典。
                              </p>
                           </li>
                           <li>
                              <p>添加重做日志文件。</p>
                              <p>假设<code class="codeph">joedevo</code>已对数据库进行了一些更改。您现在可以指定要分析的重做日志文件的名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'log1orc1.ora'， -  OPTIONS =&gt; DBMS_LOGMNR.NEW）;</pre><p>如果需要，请添加其他重做日志文件，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.ADD_LOGFILE（ -  LOGFILENAME =&gt;'log2orc1.ora'， -  OPTIONS =&gt; DBMS_LOGMNR.ADDFILE）;</pre></li>
                           <li>
                              <p>启动LogMiner并将搜索限制在指定的时间范围内：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  DICTFILENAME =&gt;'orcldict.ora'， -  STARTTIME =&gt; TO_DATE（'01 -Jan-1998 08:30:00'，'DD-MON-YYYY HH：MI：SS'）， -  ENDTIME =&gt; TO_DATE（'01-Jan-1998 08:45:00'，'DD-MON-YYYY HH：MI：SS'））;</pre></li>
                           <li>
                              <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图。
                              </p>
                              <p>此时， <code class="codeph">V$LOGMNR_CONTENTS</code>视图可用于查询。您决定查找用户<code class="codeph">joedevo</code>对<code class="codeph">salary</code>表所做的所有更改。执行以下<code class="codeph">SELECT</code>语句：</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_REDO，SQL_UNDO FROM V $ LOGMNR_CONTENTS WHERE USERNAME ='joedevo'AND SEG_NAME ='salary';</pre><p>对于<code class="codeph">SQL_REDO</code>和<code class="codeph">SQL_UNDO</code>列，将返回两行（数据显示的格式在屏幕上将有所不同）。你发现<code class="codeph">joedevo</code>要求两个操作：他删除了他的旧工资，然后插入一个新的更高的工资。您现在拥有撤消此操作所需的数据。
                              </p><pre class="oac_no_warn" dir="ltr">SQL_REDO SQL_UNDO -------- --------从SALARY中删除插入SALARY（NAME，EMPNO，SAL），其中EMPNO = 12345值（'JOEDEVO'，12345,500）和NAME ='JOEDEVO '和SAL = 500;插入SALARY（NAME，EMPNO，SAL）从SALARY值（'JOEDEVO'，12345,2500）删除，其中EMPNO = 12345，NAME ='JOEDEVO'2行选择，SAL = 2500;</pre></li>
                           <li>
                              <p>结束LogMiner会话。</p>
                              <p>使用<code class="codeph">DBMS_LOGMNR.END_LOGMNR</code>过程正确完成LogMiner会话：</p><pre class="oac_no_warn" dir="ltr">DBMS_LOGMNR.END_LOGMNR（）;</pre></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="有关如何将LogMiner用于典型方案的示例。">示例方案</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1618"></a><div class="props_rev_3"><a id="GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" name="GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3"></a><h5 id="SUTIL-GUID-C17BC82E-A71D-4814-938A-DD35FA9239C3" class="sect5"><span class="enumeration_section">22.13.3.2</span>场景2：使用LogMiner计算表访问统计信息</h5>
                     <div>
                        <p>此方案描述了如何使用LogMiner计算表访问统计信息。</p>
                        <p>在此示例中，假设您管理直接营销数据库，并希望确定客户联系人在1月份的2周时间内产生收入的效率。假设您已经创建了LogMiner字典并添加了要搜索的重做日志文件（如上例所示）。采取以下步骤：</p>
                        <ol>
                           <li>
                              <p>启动LogMiner并指定一系列时间：</p><pre class="pre codeblock"><code>EXECUTE DBMS_LOGMNR.START_LOGMNR（ -  STARTTIME =&gt; TO_DATE（'07 -Jan-2012 08:30:00'，'DD-MON-YYYY HH：MI：SS'）， -  ENDTIME =&gt; TO_DATE（'21 -Jan-2012 08:45:00'，'DD-MON-YYYY HH：MI：SS'）， -  DICTFILENAME =&gt;'/usr/local/dict.ora'）;</code></pre></li>
                           <li>
                              <p>查询<code class="codeph">V$LOGMNR_CONTENTS</code>视图以确定在指定的时间范围内修改了哪些表，如以下示例所示。（此查询过滤掉传统上名称为<code class="codeph">$</code>系统表。）
                              </p><pre class="pre codeblock"><code>SELECT SEG_OWNER，SEG_NAME，COUNT（*）AS点击来自V $ LOGMNR_CONTENTS SEG_NAME不喜欢'％$'GROUP by SEG_OWNER，SEG_NAME ORDER BY点击DESC;</code></pre></li>
                           <li>
                              <p>显示以下数据。（显示格式可能不同。）</p><pre class="pre codeblock"><code>SEG_OWNER SEG_NAME点击--------- -------- ---- CUST ACCOUNT 384 UNIV EXECDONOR 325 UNIV DONOR 234 UNIV MEGADONOR 32 HR EMPLOYEES 12 SYS DONOR 12</code></pre><p>“ <code class="codeph">Hits</code>列中的值显示命名表在查询中指定的2周时间内对其执行插入，删除或更新操作的次数。在此示例中， <code class="codeph">cust.account</code>表在指定的2周期间内被修改最多， <code class="codeph">hr.employees</code>和<code class="codeph">sys.donor</code>表在同一时间段内被修改得最少。
                              </p>
                           </li>
                           <li>
                              <p>结束LogMiner会话。</p>
                              <p>使用<code class="codeph">DBMS_LOGMNR.END_LOGMNR</code>过程正确完成LogMiner会话：</p><code class="codeph">DBMS_LOGMNR.END_LOGMNR（）;</code></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-143798E2-B0E0-4E9D-A70C-08593A117027" title="有关如何将LogMiner用于典型方案的示例。">示例方案</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="SUTIL1619"></a><div class="props_rev_3"><a id="GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" name="GUID-D11CC6EF-D94C-426F-B244-96CE2403924A"></a><h3 id="SUTIL-GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" class="sect3"><span class="enumeration_section">22.14</span>支持的数据类型，存储属性以及数据库和重做日志文件版本</h3>
               <div>
                  <p>描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3">支持的数据类型和表存储属性</a><br>描述支持的数据类型和表存储属性。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D">不支持的数据类型和表存储属性</a><br>描述不支持的数据类型和表存储属性。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-0BC1D343-0577-4DC4-9DBA-083194560D13">支持的数据库和重做日志文件版本</a><br>描述支持的数据库版本和重做日志文件版本。
                     </li>
                     <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5">SecureFiles LOB注意事项</a><br>当数据库兼容性设置为11.2或更高版本时，支持SecureFiles LOB。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-3417B738-374C-4EE3-B15C-3A66E01AE2B5" title="Oracle LogMiner是Oracle数据库的一部分，使您可以通过SQL接口查询联机和归档的重做日志文件。">使用LogMiner分析重做日志文件</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL4317"></a><a id="SUTIL4318"></a><a id="SUTIL102"></a><div class="props_rev_3"><a id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" name="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3"></a><h4 id="SUTIL-GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" class="sect4"><span class="enumeration_section">22.14.1</span>支持的数据类型和表存储属性</h4>
                  <div>
                     <p>描述支持的数据类型和表存储属性。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-16CCD6C9-725D-40AA-959A-7E87785C70DD">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database <span class="italic">12c</span>第1版（12.1）开始，当<code class="codeph">COMPATIBLE</code>初始化参数设置为12.0或更高且<code class="codeph">MAX_STRING_SIZE</code>初始化参数设置<code class="codeph">MAX_STRING_SIZE</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">RAW</code>数据类型的最大大小已增加到32 KB <code class="codeph">EXTENDED</code> 。</p>
                           <p>LogMiner将32 KB列视为LOB，以便进行补充日志记录。</p>
                           <p>32 KB列不能是ALWAYS补充日志记录组的一部分。</p>
                        </div>
                        <p>LogMiner支持以下数据类型和表存储属性。如<a href="oracle-logminer-utility.html#GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" title="LogMiner对某些数据类型和表存储属性的支持具有数据库兼容性要求。">兼容性要求中所述</a> ，某些数据类型仅在某些版本中受支持。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-272EC7F9-C6E3-4193-8F47-1F1E0DA7A88A">数据类型</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">BINARY_DOUBLE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BINARY_FLOAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">日期</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">间隔年至月</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">间隔第二天</code></p>
                           </li>
                           <li>
                              <p>存储为SecureFiles的LOB（要求数据库以11.2或更高的兼容性运行。</p>
                           </li>
                           <li>
                              <p><code class="codeph">长</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">LONG RAW</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NCHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">数</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NVARCHAR2</code></p>
                           </li>
                           <li>
                              <p>存储为<code class="codeph">VARRAY</code>的对象</p>
                           </li>
                           <li>
                              <p>对象（没有集合的简单和嵌套ADT）</p>
                              <p>对象支持（包括Oracle提供的类型，如<code class="codeph">SDO_GEOMETRY</code> ， <code class="codeph">ORDIMAGE</code>等）要求数据库运行Oracle Database 12 <span class="italic">c</span>第1版（12.1）或更高版本，重做兼容性设置为12.0.0.0或更高版本。XML数据相关操作的<code class="codeph">SQL_REDO</code>列的内容永远不是有效的SQL或PL / SQL。</p>
                           </li>
                           <li>
                              <p>Oracle Text</p>
                           </li>
                           <li>
                              <p><code class="codeph">生的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP与TIMEZONE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP与本地时区</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">VARCHAR</code>和<code class="codeph">VARCHAR2</code></p>
                           </li>
                           <li>
                              <p>XDB</p>
                           </li>
                           <li>
                              <p>假定以下主数据库兼容性要求，所有存储模型的<code class="codeph">XMLType</code>数据：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>以<code class="codeph">CLOB</code>格式存储的<code class="codeph">XMLType</code>要求数据库以11.0或更高的兼容性设置运行（从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用存储为<code class="codeph">CLOB</code> <code class="codeph">XMLType</code> 。）
                                    </p>
                                 </li>
                                 <li>
                                    <p>以对象关系格式或二进制XML格式存储的<code class="codeph">XMLType</code>要求数据库运行Oracle Database <span class="italic">11g</span>第2版（11.2.0.3）或更高版本，重做兼容性设置为11.2.0.3或更高版本。XML数据相关操作的<code class="codeph">SQL_REDO</code>列的内容永远不是有效的SQL或PL / SQL。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-1D21E466-34A2-4081-A48E-0597813FE47F">表存储类型</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集群表（包括索引集群和堆集群）。</p>
                           </li>
                           <li>
                              <p>索引组织表（IOT）（分区和非分区，包括溢出段）。</p>
                           </li>
                           <li>
                              <p>堆组织表（分区和非分区）。</p>
                           </li>
                           <li>
                              <p>高级行压缩和基本表压缩。这两个选项都需要11.1.0或更高版本的数据库兼容性设置。</p>
                           </li>
                           <li>
                              <p>当数据库兼容性设置为11.2或更高时，包含存储为SecureFiles的LOB列的表。</p>
                           </li>
                           <li>
                              <p>使用混合列压缩的表，当数据库兼容性设置为11.2.0.2或更高时。</p>
                              <div class="infoboxnotealso" id="GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3__GUID-19469851-AA17-4845-881A-5C5926328D34">
                                 <p class="notep1">也可以看看：</p>
                                 <p></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>有关混合列压缩的更多信息，请参见<a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-logminer-utility.html#GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F">兼容性要求</a><br>LogMiner对某些数据类型和表存储属性的支持具有数据库兼容性要求。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。">支持的数据类型，存储属性以及数据库和重做日志文件版本</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL4319"></a><div class="props_rev_3"><a id="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" name="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F"></a><h5 id="SUTIL-GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F" class="sect5"><span class="enumeration_section">22.14.1.1</span>兼容性要求</h5>
                     <div>
                        <p>LogMiner对某些数据类型和表存储属性的支持具有数据库兼容性要求。</p>
                        <div class="section">
                           <p>特别：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>多字节<code class="codeph">CLOB</code>支持要求数据库以10.1或更高的兼容性运行。
                                 </p>
                              </li>
                              <li>
                                 <p>没有<code class="codeph">LOB</code>和溢出的IOT支持要求数据库以10.1或更高的兼容性运行。
                                 </p>
                              </li>
                              <li>
                                 <p>IOT支持与<code class="codeph">LOB</code>和溢出需要数据库在10.2或更高版本兼容运行。
                                 </p>
                              </li>
                              <li>
                                 <p>TDE和TSE支持要求数据库以11.1或更高的兼容性运行。</p>
                              </li>
                              <li>
                                 <p>基本压缩和高级行压缩要求数据库以11.1或更高的兼容性运行。</p>
                              </li>
                              <li>
                                 <p>混合列压缩支持依赖于底层存储系统，并要求数据库以11.2或更高的兼容性运行。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-8811DF7C-6A84-4DA7-9639-F9509289FA2F__GUID-D0D87557-1C68-4A33-9865-3D4899F25390">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关混合列压缩的更多信息，请参见<a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-BA995486-041E-4C83-83EA-D7BC2A866DE3" title="描述支持的数据类型和表存储属性。">支持的数据类型和表存储属性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1620"></a><div class="props_rev_3"><a id="GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D" name="GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D"></a><h4 id="SUTIL-GUID-8A4F98EC-C233-4471-BFF9-9FB35EF5AD0D" class="sect4"><span class="enumeration_section">22.14.2</span>不支持的数据类型和表存储属性</h4>
                  <div>
                     <p>描述不支持的数据类型和表存储属性。</p>
                     <div class="section">
                        <p>LogMiner不支持以下数据类型和表存储属性。如果表包含具有任何这些不受支持的数据类型的列，则LogMiner将忽略整个表。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">BFILE</code></p>
                           </li>
                           <li>
                              <p>嵌套表</p>
                           </li>
                           <li>
                              <p>具有嵌套表的对象</p>
                           </li>
                           <li>
                              <p>带有标识列的表</p>
                           </li>
                           <li>
                              <p>时间有效性列</p>
                           </li>
                           <li>
                              <p>PKREF专栏</p>
                           </li>
                           <li>
                              <p>PKOID列</p>
                           </li>
                           <li>
                              <p>嵌套表属性和独立嵌套表列</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。">支持的数据类型，存储属性以及数据库和重做日志文件版本</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1621"></a><div class="props_rev_3"><a id="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" name="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13"></a><h4 id="SUTIL-GUID-0BC1D343-0577-4DC4-9DBA-083194560D13" class="sect4"><span class="enumeration_section">22.14.3</span>支持的数据库和重做日志文件版本</h4>
                  <div>
                     <p>描述支持的数据库版本和重做日志文件版本。</p>
                     <p>LogMiner仅在8.1或更高版本的数据库上运行，但您可以使用它来分析8.0版数据库中的重做日志文件。但是，LogMiner能够从重做日志文件中检索的信息取决于日志的版本，而不是正在使用的数据库的版本。例如，可以扩充Oracle9 <span class="italic">i的</span>重做日志文件，以便在启用补充日志记录时捕获其他信息。这样可以充分利用LogMiner功能。使用较早版本的Oracle创建的重做日志文件将不具有该附加数据，因此可能对LogMiner支持的操作和数据类型有限制。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-0BC1D343-0577-4DC4-9DBA-083194560D13__GUID-0085D85C-B355-409F-88A8-EFC74079C6EB">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oracle-logminer-utility.html#GUID-6609EBA2-B2D7-4EAE-8344-A1F6C0A24760" title="描述典型LogMiner会话中的步骤。">典型LogMiner会话</a>和<a href="oracle-logminer-utility.html#GUID-D857AF96-AC24-4CA1-B620-8EA3DF30D72E" title="描述补充日志记录。">补充日志记录中的步骤</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。">支持的数据类型，存储属性以及数据库和重做日志文件版本</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3764"></a><div class="props_rev_3"><a id="GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5" name="GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5"></a><h4 id="SUTIL-GUID-7255A2C3-59E6-41FE-B2E1-D0CD4A3CEAD5" class="sect4"><span class="enumeration_section">22.14.4</span> SecureFiles LOB注意事项</h4>
                  <div>
                     <p>当数据库兼容性设置为11.2或更高版本时，支持SecureFiles LOB。</p>
                     <p>对于SecureFiles LOB列，只能<code class="codeph">SQL_REDO</code>列; <code class="codeph">SQL_UNDO</code>列未填写。
                     </p>
                     <p>可以在主数据库的SecureFiles LOB列上启用透明数据加密（TDE）和数据压缩。</p>
                     <p>完全支持SecureFiles LOB列的重复数据删除。不支持片段操作。</p>
                     <p>如果LogMiner遇到由不支持的操作生成的重做，则会生成<code class="codeph">OPERATION</code>列设置为<code class="codeph">UNSUPPORTED</code> 。不会为这些重做记录生成SQL_REDO或SQL_UNDO。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-logminer-utility.html#GUID-D11CC6EF-D94C-426F-B244-96CE2403924A" title="描述有关数据类型和存储属性支持以及受支持的数据库和重做日志文件的版本的信息。">支持的数据类型，存储属性以及数据库和重做日志文件版本</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>