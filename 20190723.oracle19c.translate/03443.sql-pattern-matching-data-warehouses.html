<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>用于模式匹配的SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sql-aggregation-data-warehouses.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sql-modeling-data-warehouses.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-aggregation-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sql-modeling-data-warehouses.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">关系分析</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于模式匹配的SQL</li>
            </ol>
            <a id="GUID-136DAC89-DA17-45C6-9E37-C9892723AC79" name="GUID-136DAC89-DA17-45C6-9E37-C9892723AC79"></a><a id="DWHSG8956"></a>
            
            <h2 id="DWHSG-GUID-136DAC89-DA17-45C6-9E37-C9892723AC79" class="sect2"><span class="enumeration_chapter">21</span>用于模式匹配的SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>认识<a id="d80268e20" class="indexterm-anchor"></a><a id="d80268e22" class="indexterm-anchor"></a><a id="d80268e26" class="indexterm-anchor"></a>行序列中的模式是一种广泛需要的功能，但直到现在才用SQL。有许多变通方法，但这些难以编写，难以理解，执行效率低下。从Oracle Database 12 <span class="italic">c开始</span> ，您可以使用<code class="codeph">MATCH_RECOGNIZE</code>子句在本机SQL中有效执行此功能。本章讨论如何执行此操作，并包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6">数据仓库中的模式匹配概述</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323">模式匹配的基本主题</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117">模式匹配细节</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-F120C679-9C56-4703-970E-07C276EA50F1">模式匹配的高级主题</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6">模式匹配中的规则和限制</a></p>
                  </li>
                  <li>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75">模式匹配的示例</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8958"></a><a id="DWHSG8957"></a><div class="props_rev_3"><a id="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6" name="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6"></a><h3 id="DWHSG-GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6" class="sect3"><span class="enumeration_section">21.1</span>数据仓库中模式匹配概述</h3>
               <div>
                  <p>SQL中的模式匹配使用<code class="codeph">MATCH_RECOGNIZE</code>子句执行。<code class="codeph">MATCH_RECOGNIZE</code>使您可以执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句对<code class="codeph">MATCH_RECOGNIZE</code>子句中使用的数据进行逻辑分区和排序。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">MATCH_RECOGNIZE</code>子句的<code class="codeph">PATTERN</code>子句定义要搜索的行的<code class="codeph">PATTERN</code> 。这些模式使用正则表达式语法，这是一种功能强大且富有表现力的特性，适用于您定义的模式变量。
                        </p>
                     </li>
                     <li>
                        <p>指定将行映射到<code class="codeph">DEFINE</code>子句中的行模式变量所需的逻辑条件。
                        </p>
                     </li>
                     <li>
                        <p>在<code class="codeph">MEASURES</code>子句中定义度量，这些度量是SQL查询的其他部分中可用的表达式。
                        </p>
                     </li>
                  </ul>
                  <p>作为模式匹配的简单案例，请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">图21-1</a>中<a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">所示</a>的股票价格图表。
                  </p>
                  <div class="figure" id="GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">
                     <p class="titleinfigure">图21-1股票图表</p><img src="img/dwhsg140.png" alt="下面是图21-1的描述" title="下面是图21-1的描述" longdesc="img_text/dwhsg140.html"><br><a href="img_text/dwhsg140.html">“图21-1股票图表”的描述</a></div>
                  <!-- class="figure" -->
                  <p>模式匹配可以让您识别价格模式，例如<a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">图21-1</a>中<a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">所示的</a> V形和W形，以及执行多种类型的计算。例如，您的计算可能包括观测计数或向下或向上斜率的平均值。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69">为什么要使用模式匹配？</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E">如何在模式匹配中处理数据</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D">关于模式匹配特殊功能</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8960"></a><a id="DWHSG8961"></a><a id="DWHSG8962"></a><a id="DWHSG8959"></a><div class="props_rev_3"><a id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69" name="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69"></a><h4 id="DWHSG-GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69" class="sect4"><span class="enumeration_section">21.1.1</span>为什么使用模式匹配？
                  </h4>
                  <div>
                     <p>识别多行中发现的模式的能力对于多种工作很重要。示例包括由事件序列驱动的各种业务流程，例如必须检测到异常行为的安全应用程序，以及寻求定价模式，交易量和其他行为的财务应用程序。其他常见用途是欺诈检测应用程序和传感器数据分析。描述这个一般区域的一个术语是复杂的事件处理，模式匹配是这项活动的有力辅助。</p>
                     <p>现在考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">例21-1中</a>的查询。它使用<a href="sql-pattern-matching-data-warehouses.html#GUID-E64F38D8-8B30-45CA-BB6D-476EFCB564B6__CACJHAJB">图21-1中</a>显示的股票价格，您可以使用后面的<code class="codeph">CREATE</code>和<code class="codeph">INSERT</code>语句将其加载到数据库中。该查询查找股票价格跌至最低价格然后上涨的所有情况。这通常称为V形。在研究查询之前，请查看输出。只有三行，因为代码编写为每次匹配仅报告一行，并找到三个匹配。<code class="codeph">MATCH_RECOGNIZE</code>子句允许您选择每个匹配显示一行和每个匹配显示所有行。在此示例中，使用每个匹配一行的较短输出。
                     </p>
                     <div class="example" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">
                        <p class="titleinexample">例21-1模式匹配：简单的V形，每次匹配1行输出</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Ticker（SYMBOL VARCHAR2（10），tstamp DATE，price NUMBER）;插入代码价值（'ACME'，'01 -Apr-11'，12）;插入代码价值（'ACME'，'02 -Apr-11'，17）;插入代码值（'ACME'，'03 -Apr-11'，19）;插入代码价值（'ACME'，'04 -Apr-11'，21）;插入代码价值（'ACME'，'05 -Apr-11'，25）;插入代码价值（'ACME'，'06 -Apr-11'，12）;插入代码价值（'ACME'，'07 -Apr-11'，15）;插入代码价值（'ACME'，'08 -Apr-11'，20）;插入代码价值（'ACME'，'09 -Apr-11'，24）;插入代码价值（'ACME'，'10 -Apr-11'，25）;插入代码价值（'ACME'，'11 -Apr-11'，19）;插入代码价值（'ACME'，'12 -Apr-11'，15）;插入代码价值（'ACME'，'13 -Apr-11'，25）;插入代码价值（'ACME'，'14 -Apr-11'，25）;插入代码价值（'ACME'，'15 -Apr-11'，14）;插入代码价值（'ACME'，'16 -Apr-11'，12）;插入代码价值（'ACME'，'17 -Apr-11'，14）;插入代码价值（'ACME'，'18 -Apr-11'，24）;插入代码价值（'ACME'，'19 -Apr-11'，23）;插入代码价值（'ACME'，'20 -Apr-11'，22）; SELECT * FROM Ticker MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES STRT.tstamp AS start_tstamp，LAST（DOWN.tstamp）AS bottom_tstamp，LAST（UP.tstamp）AS end_tstamp在匹配跳到最后一个模式后匹配一行（STRT DOWN + UP +）DEFINE DOWN DOWN.price &lt;PREV（DOWN.price），UP AS UP.price&gt; PREV（UP.price））MR ORDER BY MR.symbol，MR.start_tstamp; SYMBOL START_TST BOTTOM_TS END_TSTAM ---------- --------- --------- --------- ACME 05-APR-11 06-APR -11 10-APR-11 ACME 10-APR-11 12-APR-11 13-APR-11 ACME 14-APR-11 16-APR-11 18-APR-11</pre><p>这个查询有什么作用？以下解释了<code class="codeph">MATCH_RECOGNIZE</code>子句中的每一行：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">PARTITION</code> <code class="codeph">BY</code>将<code class="codeph">Ticker</code>表中的数据划分为逻辑组，其中每个组包含一个股票代码。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ORDER</code> <code class="codeph">BY</code>通过<code class="codeph">tstamp</code>每个逻辑组中的数据进行<code class="codeph">tstamp</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">MEASURES</code>定义了三种措施：在一个V形（开始时的时间戳<code class="codeph">start_tstamp</code> ）中，在V形（底部的时间戳<code class="codeph">bottom_tstamp</code> ），并且在V形（结束时的时间戳<code class="codeph">end_tstamp</code> ）。<code class="codeph">bottom_tstamp</code>和<code class="codeph">end_tstamp</code>度量使用<code class="codeph">LAST()</code>函数来确保检索的值是每个模式匹配中的时间戳的最终值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>意味着对于找到的每个模式匹配，将有一行输出。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code>意味着，只要你找到一个匹配您重新启动在那是最后一排的行搜索<code class="codeph">UP</code>模式变量。模式变量是<code class="codeph">MATCH_RECOGNIZE</code>语句中使用的变量，在<code class="codeph">DEFINE</code>子句中<code class="codeph">DEFINE</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PATTERN (STRT DOWN+ UP+)</code>表示您要搜索的模式有三个模式变量： <code class="codeph">STRT</code> ， <code class="codeph">DOWN</code>和<code class="codeph">UP</code> 。 <code class="codeph">DOWN</code>和<code class="codeph">UP</code>之后的加号（ <code class="codeph">+</code> ）表示必须至少将一行映射到每一行。该模式定义了一个正则表达式，这是一种搜索模式的高度表达方式。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">DEFINE</code>为我们提供了行映射到行模式变量<code class="codeph">STRT</code> ， <code class="codeph">DOWN</code>和<code class="codeph">UP</code>所必须满足的条件。因为<code class="codeph">STRT</code>没有条件，所以任何行都可以映射到<code class="codeph">STRT</code> 。为什么没有条件的模式变量？您可以将它作为测试匹配的起点。<code class="codeph">DOWN</code>和<code class="codeph">UP</code>利用了<code class="codeph">PREV()</code>函数，它可以将当前行的价格与前一行的价格进行比较。当一行的价格低于它前面的行时， <code class="codeph">DOWN</code>匹配，因此它定义了V形的向下（左）腿。如果行的价格高于前面的行，则可以将行映射到<code class="codeph">UP</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <p>以下两个图将帮助您更好地理解<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">示例21-1</a>返回的结果。<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">图21-2</a>显示了映射到特定模式变量的日期，如<code class="codeph">PATTERN</code>子句中所指定。在将模式变量映射到日期之后， <code class="codeph">MEASURES</code>子句使用该信息来计算度量值。测量结果<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">如图21-3</a>所示。
                     </p>
                     <div class="figure" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">
                        <p class="titleinfigure">图21-2说明哪些日期映射到哪些模式变量的股票图表</p><img src="img/dwhsg143.png" alt="下面是图21-2的描述" title="下面是图21-2的描述" longdesc="img_text/dwhsg143.html"><br><a href="img_text/dwhsg143.html">“图21-2说明哪些日期映射到哪些模式变量的股票图表”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">图21-2</a>标记了映射到模式变量的每个日期。映射基于<code class="codeph">PATTERN</code>子句中指定的<code class="codeph">PATTERN</code>和<code class="codeph">DEFINE</code>子句中指定的逻辑条件。细垂直线显示为模式找到的三个匹配的边框。在每次匹配中，第一个日期将<code class="codeph">STRT</code>模式变量映射到它（标记为<span class="italic">Start</span> ），然后是映射到<code class="codeph">DOWN</code>模式变量的一个或多个日期，最后是映射到<code class="codeph">UP</code>模式变量的一个或多个日期。
                     </p>
                     <p>因为您在查询中指定了<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code> ，所以两个相邻的匹配可以共享一行。这意味着单个日期可以有两个映射到它的变量。例如，10月4日的模式变量<code class="codeph">UP</code>和<code class="codeph">STRT</code>映射到它：4月10日是比赛1的结束和比赛2的开始。
                     </p>
                     <div class="figure" id="GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">
                        <p class="titleinfigure">图21-3显示度量对应日期的股票图表</p><img src="img/dwhsg144.png" alt="下面是图21-3的描述" title="下面是图21-3的描述" longdesc="img_text/dwhsg144.html"><br><a href="img_text/dwhsg144.html">“图21-3显示措施所针对的日期的股票图表”的描述</a></div>
                     <!-- class="figure" -->
                     <p>在<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">图21-3中</a> ，标签仅用于查询的<code class="codeph">MEASURES</code>子句中定义的度量： <code class="codeph">START</code> （查询中的<code class="codeph">start_tstamp</code> ）， <code class="codeph">BOTTOM</code> （查询中的<code class="codeph">bottom_tstamp</code> ）和<code class="codeph">END</code> （查询中的<code class="codeph">end_tstamp</code> ）。<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">如图21-2所示</a> ，细垂直线显示为模式找到的三个匹配的边框。每场比赛都有一个<code class="codeph">Start</code>日期，一个<code class="codeph">Bottom</code>日期和一个<code class="codeph">End</code>日期。与<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">图21-2一样</a> ，10月4日的日期在两场比赛中找到：它是比赛1的<code class="codeph">END</code>测量和比赛2的<code class="codeph">START</code>测量。<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">图21-3</a>的标记日期显示哪些日期对应于度量定义，这些定义基于<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">图21-2中</a>所示的模式变量映射。
                     </p>
                     <p>请注意， <a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACJCHIC">图21-3中</a>标记的日期对应于示例输出中前面显示的九个日期。输出的第一行具有匹配1中显示的日期，输出的第二行具有匹配2中显示的日期，输出的第三行具有匹配3中显示的日期。
                     </p>
                  </div>
               </div><a id="DWHSG8963"></a><div class="props_rev_3"><a id="GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E" name="GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E"></a><h4 id="DWHSG-GUID-28245FC1-DF36-4A18-A885-009ED6B58A1E" class="sect4"><span class="enumeration_section">21.1.2</span>如何在模式匹配中处理数据</h4>
                  <div>
                     <p><code class="codeph">MATCH_RECOGNIZE</code>子句执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>行模式输入表根据<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句进行<code class="codeph">PARTITION</code> 。每个分区由输入表的一组行组成，这些行在分区列上具有相同的值。
                           </p>
                        </li>
                        <li>
                           <p>每个行模式分区都是根据<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句排序的。
                           </p>
                        </li>
                        <li>
                           <p>搜索每个有序行模式分区以寻找与<code class="codeph">PATTERN</code>匹配。</p>
                        </li>
                        <li>
                           <p>模式匹配通过在<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句指定的顺序中考虑行模式分区中的行来查找最早行的匹配来进行操作。
                           </p>
                           <p>行序列中的模式匹配是一个增量过程，检查一行接一行，看它是否适合模式。使用此增量处理模型，在识别完整模式之前的任何步骤中，您只有部分匹配，并且您不知道将来可能添加哪些行，也不知道未来行可能映射到哪些变量。</p>
                           <p>如果在最早的行中找不到匹配项，则搜索将移动到分区中的下一行，检查是否可以从该行开始找到匹配项。</p>
                        </li>
                        <li>
                           <p>找到匹配项后，行模式匹配计算行模式度量列，这些列是<code class="codeph">MEASURES</code>子句定义的表达式。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，如第一个示例所示，模式匹配为找到的每个匹配生成一行。如果使用<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，则匹配的每一行都包含在模式匹配输出中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code>子句确定在找到非空匹配后行模式匹配在行模式分区内恢复的位置。在前面的例子中，行图案在比赛的最后一排匹配的简历实测值（ <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <code class="codeph">UP</code> ）。
                           </p>
                        </li>
                     </ol>
                  </div>
               </div><a id="DWHSG8964"></a><div class="props_rev_3"><a id="GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D" name="GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D"></a><h4 id="DWHSG-GUID-7CB8D843-220C-4C59-BEDF-65687E2F4F4D" class="sect4"><span class="enumeration_section">21.1.3</span>关于模式匹配特殊功能</h4>
                  <div>
                     <p>功能是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>正则表达式是系统搜索数据模式的一种强大且长期建立的方式。Perl语言的正则表达式功能被用作模式匹配规则的设计目标，Oracle Database 12 <span class="italic">c</span> Release 1实现了这些规则匹配规则的子集。
                           </p>
                        </li>
                        <li>
                           <p>Oracle的正则表达式与典型的正则表达式的不同之处在于行模式变量由布尔条件而不是字符或字符集定义。</p>
                        </li>
                        <li>
                           <p>虽然模式匹配使用正则表达式的表示法来表达模式，但它实际上是更丰富的功能，因为模式变量可以定义为依赖于先前行映射到行模式变量的方式。<code class="codeph">DEFINE</code>子句使模式变量能够基于其他模式变量构建。
                           </p>
                        </li>
                        <li>
                           <p>行模式变量的定义和度量的定义允许子查询。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8965"></a><div class="props_rev_3"><a id="GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323" name="GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323"></a><h3 id="DWHSG-GUID-29BBD1CF-1C1B-4424-AED1-A91D66E52323" class="sect3"><span class="enumeration_section">21.2</span>模式匹配的基本主题</h3>
               <div>
                  <p>本节讨论：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B">模式匹配的基本示例</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48">模式匹配中的任务和关键词</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4">模式匹配语法</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8967"></a><a id="DWHSG8968"></a><a id="DWHSG8969"></a><a id="DWHSG8966"></a><div class="props_rev_3"><a id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B" name="GUID-8EB29CC4-77D4-4375-A323-74910D66564B"></a><h4 id="DWHSG-GUID-8EB29CC4-77D4-4375-A323-74910D66564B" class="sect4"><span class="enumeration_section">21.2.1</span>模式匹配的基本例子</h4>
                  <div>
                     <p>本节包括匹配模式的一些基本示例。</p>
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCCGDH">
                        <p class="titleinexample">例21-2简单V形的模式匹配，每个匹配的所有行输出</p>
                        <p>此示例中的第一行是在使用SQL * Plus时改进格式。</p><pre class="oac_no_warn" dir="ltr">column var_match format a4 SELECT * FROM Ticker MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES STRT.tstamp AS start_tstamp，FINAL LAST（DOWN.tstamp）AS bottom_tstamp，FINAL LAST（UP.tstamp）AS end_tstamp，MATCH_NUMBER（）AS match_num，CLASSIFIER （）AS var_match在匹配跳到最后一个模式（STRT DOWN + UP +）之后每次匹配所有行都定义为DOWN.price &lt;PREV（DOWN.price），UP AS UP.price&gt; PREV（UP.price））MR ORDER BY MR.symbol，MR.match_num，MR.tstamp; SYMBOL TSTAMP START_TST BOTTOM_TS END_TSTAM MATCH_NUM VAR_ PRICE ---------- --------- --------- --------- ----- ---- ---------- ---- ---------- ACME 05-APR-11 05-APR-11 06-APR-11 10-APR-11 1 STRT 25 ACME 06-APR-11 05-APR-11 06-APR-11 10-APR-11 1 DOWN 12 ACME 07-APR-11 05-APR-11 06-APR-11 10-APR-11 1 UP 15 ACME 08-APR-11 05-APR-11 06-APR-11 10-APR-11 1 UP 20 ACME 09-APR-11 05-APR-11 06-APR-11 10-APR-11 1 UP 24 ACME 10 -APR-11 05-APR-11 06-APR-11 10-APR-11 1 UP 25 ACME 10-APR-11 10-APR-11 12-APR-11 13-APR-11 2 STRT 25 ACME 11-APR -11 10-APR-11 12-APR-11 13-APR-11 2下19 ACME 12-APR-11 10-APR-11 12-APR-11 13-APR-11 2下15 ACME 13-APR-11 10-APR-11 12-APR-11 13-APR-11 2 UP 25 ACME 14-APR-11 14-APR-11 16-APR-11 18-APR-11 3 STRT 25 ACME 15-APR-11 14- APR-11 16-APR-11 18-APR-11 3 DOWN 14 ACME 16-APR-11 14-APR-11 16-APR-11 18-APR-11 3 DOWN 12 ACME 17-APR-11 14-APR- 11 16-APR-11 18-APR-11 3 UP 14 ACME 18-APR-11 14-APR-11 16-APR-11 18-APR-11 3 UP 24选择15行。
</pre><p>这个查询有什么作用？它类似于<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">例21-1中</a>的查询，除了<code class="codeph">MEASURES</code>子句中的项目， <code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>的更改以及查询结束时对<code class="codeph">ORDER</code> <code class="codeph">BY</code>的更改。在<code class="codeph">MEASURES</code>子句中，有以下新增内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">MATCH_NUMBER()</code> <code class="codeph">AS</code> <code class="codeph">match_num</code></p>
                              <p>因为此示例为每个匹配提供了多行，所以您需要知道哪些行是哪些行匹配。<code class="codeph">MATCH_NUMBER</code>为特定匹配的每一行分配相同的编号。例如，在行模式分区中找到的第一个匹配项中的所有行都被赋予<code class="codeph">match_num</code>值1。请注意，匹配编号在每个行模式分区中从1开始重新开始。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">CLASSIFIER()</code> <code class="codeph">AS</code> <code class="codeph">var_match</code></p>
                              <p>要知道哪些行映射到哪个变量，请使用<code class="codeph">CLASSIFIER</code>函数。在此示例中，某些行将映射到<code class="codeph">STRT</code>变量，某些行将映射到<code class="codeph">DOWN</code>变量，其他行将映射到<code class="codeph">UP</code>变量。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">FINAL</code> <code class="codeph">LAST()</code> 
                              </p>
                              <p>通过指定<code class="codeph">FINAL</code>并使用<code class="codeph">bottom_tstamp</code>的<code class="codeph">LAST()</code>函数，每个匹配中的每一行显示其V形底部的相同日期。同样，将<code class="codeph">FINAL</code> <code class="codeph">LAST()</code>应用于<code class="codeph">end_tstamp</code>度量会使每个匹配中的每一行显示其V形末尾的相同日期。如果没有此语法，则显示的日期将是每行的运行值。
                              </p>
                           </li>
                        </ul>
                        <p>其他两个方面进行了更改：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> -虽然<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">例21-1</a>给出了简要的有关使用该行每场比赛只有1排<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，这个例子要求，以显示每场比赛的每一行。
                              </p>
                           </li>
                           <li>
                              <p>最后一行的<code class="codeph">ORDER</code> <code class="codeph">BY</code> - 改变了它以利用<code class="codeph">MATCH_NUM</code> ，因此同一匹配中的所有行都按时间顺序排列在一起。
                              </p>
                           </li>
                        </ul>
                        <p>请注意，4月10日的行会出现两次，因为它有两种模式匹配：它是第一次匹配的最后一天和第二次匹配的第一天。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCIFAC">
                        <p class="titleinexample">例21-3与变量上的聚合模式匹配</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCIFAC">例21-3</a>强调了模式匹配查询中聚合函数的使用。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Ticker MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES MATCH_NUMBER（）AS match_num，CLASSIFIER（）AS var_match，FINAL COUNT（UP.tstamp）AS up_days，FINAL COUNT（tstamp）AS total_days，RUNNING COUNT（tstamp）AS cnt_days ，价格 -  STRT.price AS price_dif匹配所有匹配后跳到最后一个模式（STRT DOWN + UP +）定义为DOWN.price &lt;PREV（DOWN.price），UP AS UP.price&gt; PREV（UP.price） MR先生，MR.symbol，MR.match_num，MR.tstamp; SYMBOL TSTAMP MATCH_NUM VAR_ UP_DAYS TOTAL_DAYS CNT_DAYS PRICE_DIF价格------ --------- --------- ---- ------- ------ ---- -------- --------- ----- ACME 05-APR-11 1 STRT 4 6 1 0 25 ACME 06-APR-11 1 DOWN 4 6 2 -13 12 ACME 07-APR-11 1 UP 4 6 3 -10 15 ACME 08-APR-11 1 UP 4 6 4 -5 20 ACME 09-APR-11 1 UP 4 6 5 -1 24 ACME 10-APR- 11 1 UP 4 6 6 0 25 ACME 10-APR-11 2 STRT 1 4 1 0 25 ACME 11-APR-11 2 DOWN 1 4 2 -6 19 ACME 12-APR-11 2 DOWN 1 4 3 -10 15 ACME 13-APR-11 2 UP 1 4 4 0 25 ACME 14-APR-11 3 STRT 2 5 1 0 25 ACME 15-APR-11 3 DOWN 2 5 2 -11 14 ACME 16-APR-11 3 DOWN 2 5 3 -13 12 ACME 17-APR-11 3 UP 2 5 4 -11 14 ACME 18-APR-11 3 UP 2 5 5 -1 24 15行选择。
</pre><p>这个查询有什么作用？它基于<a href="sql-pattern-matching-data-warehouses.html#GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACCCGDH">示例21-2</a> ，添加了三个使用聚合函数<code class="codeph">COUNT()</code>度量。它还添加了一个度量，显示表达式如何使用限定且不合格的列。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">up_days</code>度量（使用<code class="codeph">FINAL</code> <code class="codeph">COUNT</code> ）显示每个匹配中映射到<code class="codeph">UP</code>模式变量的天数。您可以通过计算<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACFEJBE">图21-2中</a>每个匹配的<code class="codeph">UP</code>标签来验证这一点。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">total_days</code>度量（也使用<code class="codeph">FINAL</code> <code class="codeph">COUNT</code> ）引入了非限定列的使用。由于此度量指定了<code class="codeph">FINAL</code> <code class="codeph">count(tstamp)</code>而没有模式变量来限定<code class="codeph">tstamp</code>列，因此它返回匹配中包含的所有行的计数。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">cnt_days</code>度量引入了<code class="codeph">RUNNING</code>关键字。此度量提供了一个运行计数，有助于区分匹配中的行。请注意，它也没有模式变量来限定<code class="codeph">tstamp</code>列，因此它适用于匹配的所有行。在这种情况下，您不需要显式使用<code class="codeph">RUNNING</code>关键字，因为它是默认值。有关详细信息，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B">运行与最终语义和关键字</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">price_dif</code>指标显示我们每天的股票价格与比赛第一天的价格之间的差异。在表达式“ <code class="codeph">price - STRT.price)</code> ”中，您会看到一个不合格的列“ <code class="codeph">price</code> ”与限定列“ <code class="codeph">STRT.price</code> ”一起使用的情况。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8EB29CC4-77D4-4375-A323-74910D66564B__CACDGBEA">
                        <p class="titleinexample">例21-4 W形的模式匹配</p>
                        <p>此示例说明了W形状。</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Ticker MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES MATCH_NUMBER（）AS match_num，CLASSIFIER（）AS var_match，STRT.tstamp AS start_tstamp，FINAL LAST（UP.tstamp）AS end_tstamp匹配后跳过最后一次匹配所有行PATTERN（STRT DOWN + UP + DOWN + UP +）定义为DOWN.price &lt;PREV（DOWN.price），UP AS UP.price&gt; PREV（UP.price））MR ORDER BY MR.symbol，MR.match_num，MR.tstamp; SYMBOL TSTAMP MATCH_NUM VAR_ START_TST END_TSTAM价格---------- --------- ---------- ---- ---------  - -------- ---------- ACME 05-APR-11 1 STRT 05-APR-11 13-APR-11 25 ACME 06-APR-11 1 DOWN 05-APR-11 13-APR-11 12 ACME 07-APR-11 1 UP 05-APR-11 13-APR-11 15 ACME 08-APR-11 1 UP 05-APR-11 13-APR-11 20 ACME 09-APR-11 1 UP 05-APR-11 13-APR-11 24 ACME 10-APR-11 1 UP 05-APR-11 13-APR-11 25 ACME 11-APR-11 1 DOWN 05-APR-11 13-APR-11 19 ACME 12-APR-11 1 DOWN 05-APR-11 13-APR-11 15 ACME 13-APR-11 1 UP 05-APR-11 13-APR-11 25</pre><p>这个查询有什么作用？它建立在<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">例21-1中</a>介绍的概念之上，并在数据而不是V形中寻找W形。查询结果显示一个W形状。为了找到W形状，修改了定义<code class="codeph">PATTERN</code>正则表达式的线以寻找模式<code class="codeph">DOWN</code>然后连续两次<code class="codeph">UP</code> ： <code class="codeph">PATTERN</code> <code class="codeph">(STRT DOWN+ UP+ DOWN+ UP+)</code> 。这种图案规格意味着它只能匹配W形，其中两个V形在它们之间没有分离。例如，如果存在价格不变的平坦间隔，并且该间隔发生在两个V形状之间，则该模式将不匹配该数据。为了说明返回的数据，输出设置为<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> 。请注意， <code class="codeph">MEASURES</code>子句中的<code class="codeph">FINAL</code> <code class="codeph">LAST(UP.tstamp)</code>返回映射到<code class="codeph">UP</code>的最后一行的时间戳值。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8970"></a><div class="props_rev_3"><a id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48" name="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48"></a><h4 id="DWHSG-GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48" class="sect4"><span class="enumeration_section">21.2.2</span>模式匹配中的任务和关键字</h4>
                  <div>
                     <p>本节讨论模式匹配中的以下任务和关键字。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-15B5EF24-F543-4439-A6A6-22246AE834E9">PARTITION BY：逻辑上将行划分为组</p>
                        <p>您通常希望将输入数据划分为逻辑组以进行分析。在具有股票的示例中，您将模式匹配分开，以便一次仅应用于一个股票。您可以使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code>关键字执行此操作。<code class="codeph">PARTITION</code> <code class="codeph">BY</code>用于指定行模式输入表的行将由一列或多列分区。匹配位于分区内，不跨越分区边界。
                        </p>
                        <p>如果没有<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ，则行模式输入表的所有行构成单行模式分区。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-A36AD094-C8BE-4AEC-B662-F50069283674">ORDER BY：逻辑排序分区中的行</p>
                        <p>将输入数据划分为逻辑分区后，您需要在每个分区内对数据进行排序。如果没有行排序，则无法使用可靠的序列来检查模式匹配。<code class="codeph">ORDER</code> <code class="codeph">BY</code>关键字用于指定行模式分区中的行顺序。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-9D80679D-833F-4926-94DF-6C1EEF22A032">[ONE ROW |所有游戏]每场比赛：为每场比赛选择摘要或详细信息</p>
                        <p>您有时需要有关匹配的摘要数据，有时需要详细信息。您可以使用以下SQL关键字执行此操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                              <p>每个匹配产生一个摘要行。这是默认值。</p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                              <p>跨越多行的匹配将为匹配中的每一行生成一个输出行。</p>
                           </li>
                        </ul>
                        <p>输出在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">行模式输出</a> ”中说明</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-4F8661E5-A920-49FC-95FB-57A574AEBC47">措施：从模式匹配中定义导出计算</p>
                        <p>模式匹配子句使您可以创建在各种分析中有用的表达式。它们通过使用<code class="codeph">MEASURES</code>子句在输出中显示为列。<code class="codeph">MEASURES</code>子句定义行模式度量列，其值通过计算与特定匹配相关的表达式来计算。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-377262F0-AB19-4CD8-A186-152CE0922431">PATTERN：定义将匹配的行模式</p>
                        <p><code class="codeph">PATTERN</code>子句允许您定义必须匹配的模式变量，它们必须匹配的顺序以及必须匹配的行数。<code class="codeph">PATTERN</code>子句指定匹配搜索的正则表达式。
                        </p>
                        <p>行模式匹配由行模式分区中的一组连续行组成。匹配的每一行都映射到一个模式变量。将行映射到模式变量必须符合<code class="codeph">PATTERN</code>子句中的正则表达式，并且<code class="codeph">DEFINE</code>子句中的所有条件都必须为true。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-7910E083-0636-418C-93F0-861FB0B478D3">定义：定义主要模式变量</p>
                        <p>因为<code class="codeph">PATTERN</code>子句依赖于模式变量，所以必须有一个子句来定义这些变量。它们在<code class="codeph">DEFINE</code>子句中指定。
                        </p>
                        <p><code class="codeph">DEFINE</code>是一个必需子句，用于指定行必须满足以映射到特定模式变量的条件。
                        </p>
                        <p>模式变量不需要定义。任何行都可以映射到未定义的模式变量。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-9DC05558-50D7-4867-9553-3FCE75235A58">匹配跳过后：找到匹配后重新启动匹配过程</p>
                        <p>查询找到匹配项后，必须在完全正确的点查找下一个匹配项。你想找到早先比赛结束与下一场比赛开始重叠的比赛吗？你想要一些其他的变化吗？模式匹配在指定重启点时提供了极大的灵活性。<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code>子句确定在找到非空匹配后恢复行模式匹配的点。该子句的默认值是<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code> ：在当前匹配的最后一行之后的下一行恢复模式匹配。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-3CC279F9-63F2-4092-94BB-D9E03B097787">MATCH_NUMBER：查找哪些行是哪个匹配的成员</p>
                        <p>在给定的行分区中，您的模式可能有大量匹配项。你如何区分所有这些比赛？这是通过<code class="codeph">MATCH_NUMBER</code>函数完成的。行模式分区内的匹配按顺序从1开始按顺序编号。请注意，匹配编号在每个行模式分区中从1开始重新开始，因为行模式分区之间没有固有的顺序。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B6B60284-5DEB-4C0D-A028-9FFDCAC1BE48__GUID-B5F70FF5-1022-4C07-9349-516CEE462296">CLASSIFIER：查找哪个模式变量适用于哪些行</p>
                        <p>除了知道您正在看哪个<code class="codeph">MATCH_NUMBER</code> ，您可能还想知道模式的哪个组件适用于特定行。这是使用<code class="codeph">CLASSIFIER</code>函数完成的。行的分类器是行通过行模式匹配映射到的模式变量。<code class="codeph">CLASSIFIER</code>函数返回一个字符串，其值是行映射到的变量的名称。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8980"></a><div class="props_rev_3"><a id="GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4" name="GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4"></a><h4 id="DWHSG-GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4" class="sect4"><span class="enumeration_section">21.2.3</span>模式匹配语法</h4>
                  <div>
                     <div class="section">
                        <p>模式匹配语法如下：</p><pre class="oac_no_warn" dir="ltr">table_reference :: = {only（query_table_expression）| query_table_expression} [flashback_query_clause] [pivot_clause | unpivot_clause | row_pattern_recognition_clause] [t_alias] row_pattern_recognition_clause :: = MATCH_RECOGNIZE（[row_pattern_partition_by] [row_pattern_order_by] [row_pattern_measures] [row_pattern_rows_per_match] [row_pattern_skip_to] PATTERN（row_pattern）[row_pattern_subset_clause] DEFINE row_pattern_definition_list）row_pattern_partition_by :: = PARTITION BY列[，列] ......row_pattern_order_by :: = ORDER BY列[，列] ...row_pattern_measures :: = MEASURES row_pattern_measure_column [，row_pattern_measure_column] ...row_pattern_measure_column :: =表达式AS c_alias row_pattern_rows_per_match :: =每行匹配一行|每次匹配所有行row_pattern_skip_to :: =比赛后{跳到下一行|跳过最后一行| SKIP TO FIRST variable_name | SKIP TO LAST variable_name | SKIP TO variable_name} row_pattern :: = row_pattern_term | row_pattern“|” row_pattern_term row_pattern_term :: = row_pattern_factor | row_pattern_term row_pattern_factor row_pattern_factor :: = row_pattern_primary [row_pattern_quantifier] row_pattern_quantifier :: = * [？]| + [？]|？[？]|“{”[unsigned_integer]，[unsigned_integer]“}”[？]|“{”unsigned_integer“}”row_pattern_primary :: = variable_name | $ | ^ |（[row_pattern]）|“{ - ”row_pattern“ - }”| row_pattern_permute row_pattern_permute :: = PERMUTE（row_pattern [，row_pattern] ...）row_pattern_subset_clause :: = SUBSET row_pattern_subset_item [，row_pattern_subset_item] ...row_pattern_subset_item :: = variable_name =（variable_name [，variable_name] ...）row_pattern_definition_list :: = row_pattern_definition [，row_pattern_definition] ...row_pattern_definition :: = variable_name AS条件</pre><p>模式匹配中的行模式操作的语法是：</p><pre class="oac_no_warn" dir="ltr">function :: = single_row_function | aggregate_function | analytic_function | object_reference_function | model_function | user_defined_function | OLAP_function | data_cartridge_function | row_pattern_recognition_function row_pattern_recognition_function :: = row_pattern_classifier_function | row_pattern_match_number_function | row_pattern_navigation_function | row_pattern_aggregate_function row_pattern_classifier_function :: = CLASSIFIER（）row_pattern_match_number_function :: = MATCH_NUMBER（）row_pattern_navigation_function :: = row_pattern_navigation_logical | row_pattern_navigation_physical | row_pattern_navigation_compound row_pattern_navigation_logical :: = [RUNNING | FINAL] {FIRST | LAST}（expression [，offset]）row_pattern_navigation_physical :: = {PREV | NEXT}（expression [，offset]）row_pattern_navigation_compound :: = {PREV | NEXT}（[RUNNING | FINAL] {FIRST | LAST}（表达式[，偏移]）[，偏移]）</pre><p>模式匹配子句中set函数规范的语法是：</p><pre class="oac_no_warn" dir="ltr">row_pattern_aggregate_function :: = [RUNNING |最终] aggregate_function</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8981"></a><div class="props_rev_3"><a id="GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117" name="GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117"></a><h3 id="DWHSG-GUID-3112250E-FD3B-4C6B-B73B-B6233E3E7117" class="sect3"><span class="enumeration_section">21.3</span>模式匹配细节</h3>
               <div>
                  <p>本节详细介绍了<a href="sql-pattern-matching-data-warehouses.html#GUID-BA62D1BA-FDE1-4517-A248-F0EC4D1A52B4">模式匹配语法中</a>讨论的项目以及其他主题。请注意，某些材料不可避免地错综复杂。模式匹配的某些方面需要仔细关注细微的细节。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-E508A372-0287-4515-859A-74B070A356A5">PARTITION BY：逻辑上将行划分为组</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E">ORDER BY：逻辑排序分区中的行</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-FF7F2D64-503F-411C-9E57-15755441D7A2">[ONE ROW |所有游戏]每场比赛：为每场比赛选择摘要或详细信息</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2">措施：定义查询中使用的计算</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1">PATTERN：定义要匹配的行模式</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET：定义联合行模式变量</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8">定义：定义主要模式变量</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8">匹配跳过之后：定义匹配后重新开始匹配过程的位置</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">MEASURES和DEFINE中的表达</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">行模式输出</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8982"></a><div class="props_rev_3"><a id="GUID-E508A372-0287-4515-859A-74B070A356A5" name="GUID-E508A372-0287-4515-859A-74B070A356A5"></a><h4 id="DWHSG-GUID-E508A372-0287-4515-859A-74B070A356A5" class="sect4"><span class="enumeration_section">21.3.1</span> PARTITION BY：逻辑<span class="enumeration_section">上将</span>行划分为组</h4>
                  <div>
                     <div class="section">
                        <p>通常，您希望将输入数据划分为逻辑组以进行分析。在具有股票的示例中，模式匹配被划分，使得它一次仅适用于一个股票。为此，请使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句。<code class="codeph">PARTITION</code> <code class="codeph">BY</code>指定输入表的行将由一列或多列分区。匹配位于分区内，不跨越分区边界。
                        </p>
                        <p>如果没有<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ，则行模式输入表的所有行构成单行模式分区。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8983"></a><div class="props_rev_3"><a id="GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E" name="GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E"></a><h4 id="DWHSG-GUID-755183E1-E75E-4ABC-89DE-DB47C1603B5E" class="sect4"><span class="enumeration_section">21.3.2</span> ORDER BY：逻辑排序分区中的行</h4>
                  <div>
                     <p><code class="codeph">ORDER</code> <code class="codeph">BY</code>子句用于指定行模式分区中的行顺序。如果行模式分区中的两行顺序不是由<code class="codeph">ORDER</code> <code class="codeph">BY</code>确定的，则<code class="codeph">MATCH_RECOGNIZE</code>子句的结果是非确定性的：每次运行查询时，它可能不会给出一致的结果。
                     </p>
                  </div>
               </div><a id="DWHSG8984"></a><div class="props_rev_3"><a id="GUID-FF7F2D64-503F-411C-9E57-15755441D7A2" name="GUID-FF7F2D64-503F-411C-9E57-15755441D7A2"></a><h4 id="DWHSG-GUID-FF7F2D64-503F-411C-9E57-15755441D7A2" class="sect4"><span class="enumeration_section">21.3.3</span> [一行|所有游戏]每场比赛：为每场比赛选择摘要或详细信息</h4>
                  <div>
                     <p>您有时需要有关匹配的摘要数据，有时需要详细信息。您可以使用以下SQL执行此操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                           <p>每个匹配产生一个摘要行。这是默认值。</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code></p>
                           <p>跨越多行的匹配将为匹配中的每一行生成一个输出行。</p>
                        </li>
                     </ul>
                     <p>输出在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5">行模式输出</a> ”中说明</span> 。
                     </p>
                     <p><code class="codeph">MATCH_RECOGNIZE</code>子句可以找到零行匹配。对于空匹配， <code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>返回摘要行： <code class="codeph">PARTITION</code> <code class="codeph">BY</code>列采用空匹配发生的行中的值，并在一组空行上计算度量列。
                     </p>
                     <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>有三个子选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code></p>
                        </li>
                     </ul>
                     <p><span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-F120C679-9C56-4703-970E-07C276EA50F1">模式匹配中的高级主题</a> ”</span>中介绍了这些选项。
                     </p>
                  </div>
               </div><a id="DWHSG8985"></a><div class="props_rev_3"><a id="GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2" name="GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2"></a><h4 id="DWHSG-GUID-A8D4A132-E8A5-4EDD-B3C8-4F5D98AD2EA2" class="sect4"><span class="enumeration_section">21.3.4</span>措施：定义查询中使用的计算</h4>
                  <div>
                     <p><code class="codeph">MEASURES</code>子句定义模式输出表的列列表。每个模式度量列都使用列名定义，其值由相应的模式度量表达式指定。
                     </p>
                     <p>值表达式是针对模式变量定义的。值表达式可以包含集函数，模式导航操作， <code class="codeph">CLASSIFIER()</code> ， <code class="codeph">MATCH_NUMBER()</code>以及对输入表的任何列的列引用。有关详细信息，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">MEASURES和DEFINE中的表达式</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="DWHSG8986"></a><div class="props_rev_3"><a id="GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1" name="GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1"></a><h4 id="DWHSG-GUID-7FD680A5-A529-4A90-8FC4-972F9F0E92E1" class="sect4"><span class="enumeration_section">21.3.5</span>模式：定义要匹配的行模式</h4>
                  <div>
                     <p><code class="codeph">PATTERN</code>关键字指定要在分区中的有序行序列中识别的模式。模式中的每个变量名称对应于布尔条件，稍后将使用语法的<code class="codeph">DEFINE</code>组件指定该条件。
                     </p>
                     <p><code class="codeph">PATTERN</code>子句用于指定正则表达式。解释正则表达式概念和细节超出了本材料的范围。如果您不熟悉正则表达式，建议您使用其他来源熟悉该主题。
                     </p>
                     <p><code class="codeph">PATTERN</code>子句中的正则表达式括在括号中。<code class="codeph">PATTERN</code>可以使用以下运算符：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>级联</p>
                           <p>连接用于列出要按该顺序匹配的模式中的两个或更多项。当两个连续项之间没有操作符号时，项目会连接在一起。例如： <code class="codeph">PATTERN (ABC)</code> 。
                           </p>
                        </li>
                        <li>
                           <p>量词</p>
                           <p>量词是POSIX运算符，用于定义匹配所接受的迭代次数。POSIX扩展正则表达式的语法类似于传统的UNIX正则表达式。以下是量词的选择：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">*</code> -  0次或更多次迭代</p>
                              </li>
                              <li>
                                 <p><code class="codeph">+</code> -  1次或更多次迭代</p>
                              </li>
                              <li>
                                 <p><code class="codeph">?</code> -  0或1次迭代</p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n}</code> - <code class="codeph">n</code>次迭代（n&gt; 0）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n,}</code> - <code class="codeph">n</code>或更多次迭代（n&gt; = 0）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">{n,m}</code> - 在<code class="codeph">n</code>和<code class="codeph">m</code> （包括）迭代之间（ <code class="codeph">0 &lt;= n</code> <code class="codeph">&lt;= m</code> ， <code class="codeph">0 &lt; m</code> ）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">{,m}</code> - 介于0和<code class="codeph">m</code> （含）之间的迭代次数（ <code class="codeph">m &gt; 0</code> ）</p>
                              </li>
                              <li>
                                 <p>不情愿的量词 - 由量词后面的附加问号表示<code class="codeph">(*?, +?, ??, {n,}?, { n, m }?, {,m}?)</code> 。对于不情愿和不情愿量词之间的区别，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-11206451-1F14-41AC-828F-F97C694F325C">不情愿与贪婪量词</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                           <p>以下是使用量词运算符的示例：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">A*</code>匹配0或多次重复<code class="codeph">A</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">A{3,6}</code>的3至6次迭代匹配<code class="codeph">A</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">A{,4}</code>匹配<code class="codeph">A</code> 0到4次迭代</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>轮流</p>
                           <p>Alternation匹配几个可能的正则表达式列表中的单个正则表达式。通过在每个正则表达式之间放置一个垂直条（|）来创建交替列表。替代品按其指定的顺序是优选的。例如， <code class="codeph">PATTERN (A | B | C)</code>尝试首先匹配<code class="codeph">A</code>如果<code class="codeph">A</code>不匹配，则尝试匹配<code class="codeph">B</code>如果<code class="codeph">B</code>不匹配，则尝试匹配<code class="codeph">C</code></p>
                        </li>
                        <li>
                           <p>分组</p>
                           <p>分组将正则表达式的一部分视为单个单元，使您能够将正则表达式运算符（如量词）应用于该组。使用括号创建分组。例如， <code class="codeph">PATTERN ((AB){3} C)</code>尝试将组<code class="codeph">(AB)</code>匹配三次，然后寻找一次出现的<code class="codeph">C</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">置换</code></p>
                           <p>有关详细信息，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7">如何更新所有排列</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>排除</p>
                           <p>要从<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>的输出中排除的模式部分包含在{ - 和 - }之间。请参见<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">如何从输出中排除模式的部分</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>锚</p>
                           <p>锚定位置而不是行。它们匹配分区开头或结尾的位置。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">^</code>匹配分区中第一行之前的位置。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">$</code>匹配分区中最后一行之后的位置。
                                 </p>
                              </li>
                           </ul>
                           <p>例如，只有当分区中的所有行都满足<code class="codeph">A</code>的条件时， <code class="codeph">PATTERN (^A+$)</code>才会匹配。结果匹配跨越整个分区。
                           </p>
                        </li>
                        <li>
                           <p>空模式（）匹配一组空行</p>
                        </li>
                     </ul>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-11206451-1F14-41AC-828F-F97C694F325C">不情愿与贪婪量词</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0">运营商优先权</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8987"></a><div class="props_rev_3"><a id="GUID-11206451-1F14-41AC-828F-F97C694F325C" name="GUID-11206451-1F14-41AC-828F-F97C694F325C"></a><h5 id="DWHSG-GUID-11206451-1F14-41AC-828F-F97C694F325C" class="sect5"><span class="enumeration_section">21.3.5.1</span>不情愿与贪婪量词</h5>
                     <div>
                        <p>模式量词被称为贪婪;他们将尝试尽可能多地匹配应用它们的正则表达式的多个实例。例外情况是带有问号的模式量词<code class="codeph">?</code> 作为后缀，那些被称为不情愿。他们将尝试尽可能少地匹配应用它们的正则表达式的实例。
                        </p>
                        <p>附加到单个模式变量的贪婪和不情愿量词之间的差异如下所示： <code class="codeph">A*</code>尝试将尽可能多的行映射到<code class="codeph">A</code> ，而<code class="codeph">A*?</code> 尝试将尽可能少的行映射到<code class="codeph">A</code>例如：</p><pre class="oac_no_warn" dir="ltr">图案（XY * Z）</pre><p>该模式由三个变量名称<code class="codeph">X</code> ， <code class="codeph">Y</code>和<code class="codeph">Z</code> ， <code class="codeph">Y</code>用<code class="codeph">*</code>定量。这意味着当连续的输入输入行满足以下条件时，将识别并报告模式匹配：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>行满足定义变量<code class="codeph">X</code>后跟零或更多行的条件，这些行满足定义变量<code class="codeph">Y</code>的条件，后跟满足定义变量<code class="codeph">Z</code>的条件的行。</p>
                           </li>
                        </ul>
                        <p>在匹配处理中，行被映射到后的图案<code class="codeph">X</code>和0个或多个行被映射到<code class="codeph">Y</code> ，如果下列行可以被映射到两个变量<code class="codeph">Y</code>和<code class="codeph">Z</code> （满足两者的限定条件<code class="codeph">Y</code>和<code class="codeph">Z</code> ），然后，因为<code class="codeph">Y</code>的量词<code class="codeph">*</code>是贪心的，所以该行优先映射到<code class="codeph">Y</code>而不是<code class="codeph">Z</code>由于这种贪婪的属性， <code class="codeph">Y</code>优先于<code class="codeph">Z</code>并且映射了更多的<code class="codeph">Y</code>行。如果模式表达式是<code class="codeph">PATTERN (XY*?Z)</code> ，它使用了一个不情愿的量词<code class="codeph">*?</code> 超过<code class="codeph">Y</code> ，然后<code class="codeph">Z</code>优先于<code class="codeph">Y</code></p>
                     </div>
                  </div><a id="DWHSG8988"></a><div class="props_rev_3"><a id="GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0" name="GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0"></a><h5 id="DWHSG-GUID-D8424DBD-9DC1-40EA-A998-07880D7A31E0" class="sect5"><span class="enumeration_section">21.3.5.2</span>运算符优先级</h5>
                     <div>
                        <p>正则表达式中元素的优先级按递减顺序排列如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">row_pattern_primary</code></p>
                              <p>这些元素包括主模式变量（模式变量不是使用<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET：定义联合行模式变量</a> ”中</span>描述的<code class="codeph">SUBSET</code>子句创建的），锚点， <code class="codeph">PERMUTE</code> ，括号表达式，排除语法和空模式</p>
                           </li>
                           <li>
                              <p>量词</p>
                              <p><code class="codeph">row_pattern_primary</code>可以具有零个或一个量词。
                              </p>
                           </li>
                           <li>
                              <p>级联</p>
                           </li>
                           <li>
                              <p>轮流</p>
                           </li>
                        </ul>
                        <p><code class="codeph">PATTERN</code> <code class="codeph">(AB | CD)</code>说明了交替的优先顺序，它相当于<code class="codeph">PATTERN</code> （ <code class="codeph">(AB) | (CD))</code> 。但是，它不等同于<code class="codeph">PATTERN</code> <code class="codeph">(A (B | C) D)</code> 。
                        </p>
                        <p>量词的优先级由<code class="codeph">PATTERN</code> （ <code class="codeph">AB *)</code> ，它等同于<code class="codeph">PATTERN</code> <code class="codeph">(A (B*))</code> 。但是，它不是<code class="codeph">PATTERN</code> （ <code class="codeph">(AB)*)</code> 。
                        </p>
                        <p>量词可能不会立即跟随另一个量词。例如，禁止使用<code class="codeph">PATTERN</code> <code class="codeph">(A**)</code> 。
                        </p>
                        <p>允许主模式变量在模式中出现多次，例如<code class="codeph">PATTERN</code> <code class="codeph">(XYX)</code> 。
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8990"></a><a id="DWHSG8989"></a><div class="props_rev_3"><a id="GUID-55087E05-983A-4B47-94FE-556D04FF9842" name="GUID-55087E05-983A-4B47-94FE-556D04FF9842"></a><h4 id="DWHSG-GUID-55087E05-983A-4B47-94FE-556D04FF9842" class="sect4"><span class="enumeration_section">21.3.6子集</span> ：定义联合行模式变量</h4>
                  <div>
                     <p>有时，创建一组多个模式变量是有帮助的，这些变量可以用自己的变量名称来引用。这些分组称为联合行模式变量，您可以使用<code class="codeph">SUBSET</code>子句创建它们。<code class="codeph">SUBSET</code>创建的联合行模式变量可以在<code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>子句中使用。<code class="codeph">SUBSET</code>子句是可选的。它用于声明联合行模式变量。例如，这是一个使用<code class="codeph">SUBSET</code>来计算平均值的查询，该平均值基于映射到<code class="codeph">STRT</code>和<code class="codeph">DOWN</code>变量的并集的所有行，其中<code class="codeph">STRT</code>是模式的起始点，而<code class="codeph">DOWN</code>是a的向下（左）分支。 V形。
                     </p>
                     <p><a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842__CACHECJD">例21-5</a>说明了创建一个联合行模式变量。
                     </p>
                     <div class="example" id="GUID-55087E05-983A-4B47-94FE-556D04FF9842__CACHECJD">
                        <p class="titleinexample">示例21-5定义联合行模式变量</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Ticker MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES FIRST（STRT.tstamp）AS strt_time，LAST（DOWN.tstamp）AS bottom，AVG（STDN.Price）AS stdn_avgprice匹配后跳过最后一个模式的一行比赛（STRT DOWN + UP +）SUBSET STDN =（STRT，DOWN）定义为UP.Price&gt; PREV（UP.Price），DOWN as DOWN.Price &lt;PREV（DOWN.Price））; SYMBOL STRT_TIME BOTTOM STDN_AVGPRICE ------ --------- --------- ------------- ACME 05-APR-11 06-APR -11 18.5 ACME 10-APR-11 12-APR-11 19.6666667 ACME 14-APR-11 16-APR-11 17</pre></div>
                     <!-- class="example" -->
                     <p>此示例声明了一个联合行模式变量<code class="codeph">STDN</code> ，并将其定义为映射到<code class="codeph">STRT</code>的行和映射到<code class="codeph">DOWN</code>的行的并集。查询中可以有多个联合行模式变量。例如：</p><pre class="oac_no_warn" dir="ltr">模式（W + X + Y + Z +）SUBSET XY =（X，Y），WZ =（W，Z）</pre><p><code class="codeph">SUBSET</code>项的右侧是括号内的不同主行模式变量的逗号分隔列表。这将联合行模式变量（在左侧）定义为主行模式变量的联合（在右侧）。
                     </p>
                     <p>请注意，右侧的模式变量列表可能不包含任何联合行模式变量（没有联合的联合）。</p>
                     <p>对于每个匹配，都有一个隐式联合行模式变量，称为通用行模式变量。通用行模式变量是所有主行模式变量的并集。例如，如果模式具有主模式变量<code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code> ，则通用行模式变量等效于带有参数<code class="codeph">(A, B, C)</code>的<code class="codeph">SUBSET</code>子句。因此，匹配的每一行都映射到通用行模式变量。<code class="codeph">MEASURES</code>或<code class="codeph">DEFINE</code>子句中的任何非限定列引用都由通用行模式变量隐式限定。请注意，没有关键字可以显式指定通用行模式变量。
                     </p>
                  </div>
               </div><a id="DWHSG8992"></a><a id="DWHSG8991"></a><div class="props_rev_3"><a id="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8" name="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8"></a><h4 id="DWHSG-GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8" class="sect4"><span class="enumeration_section">21.3.7</span>定义：定义主要模式变量</h4>
                  <div>
                     <p><code class="codeph">DEFINE</code>是一个强制性子句，用于指定定义主要模式变量的条件。在示例中：</p><pre class="oac_no_warn" dir="ltr">定义为UP.Price&gt; PREV（UP.Price），DOWN AS DOWN.Price &lt;PREV（DOWN.Price）</pre><p><code class="codeph">UP</code>由条件<code class="codeph">UP.Price &gt; PREV (UP.Price)</code>定义， <code class="codeph">DOWN</code>由条件<code class="codeph">DOWN.Price &lt; PREV (DOWN.Price)</code> 。（ <code class="codeph">PREV</code>是行模式导航操作，用于计算上一行中的表达式;有关完整的行模式导航操作集，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">行模式导航操作</a> ”</span> 。）
                     </p>
                     <p>模式变量不需要定义;如果没有定义，则可以将任何行映射到模式变量。</p>
                     <p>联合行模式变量（参见<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-55087E05-983A-4B47-94FE-556D04FF9842">SUBSET：定义联合行模式变量</a> ”中</span>的<code class="codeph">SUBSET</code>讨论）不能由<code class="codeph">DEFINE</code> ，但可以在模式变量的定义中引用。
                     </p>
                     <p>模式变量的定义可以引用另一个模式变量，如<a href="sql-pattern-matching-data-warehouses.html#GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8__CACGBDEB">例21-6所示</a> 。
                     </p>
                     <div class="example" id="GUID-CA54B0BA-CD50-4078-B5DE-14700D3E3CA8__CACGBDEB">
                        <p class="titleinexample">例21-6定义模式变量</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Ticker MATCH_RECOGNIZE（符号来自Ticker MATCH_RECOGNIZE的分区（按符号顺序排序按顺序首先测量（A.tstamp）AS A_Firstday，LAST（D.tstamp）AS D_Lastday，AVG（B.Price）AS B_Avgprice，AVG（D .Price）AS D_Avgprice PATTERN（A B + C + D）SUBSET BC =（B，C）DEFINE A价格&gt; 100，B AS B.Price&gt; A.Price，C AS C.Price &lt;AVG（B.Price）， D AS D.Price&gt; MAX（BC.Price））M</pre></div>
                     <!-- class="example" -->
                     <p>在这个例子中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">A</code>的定义隐式引用了通用行模式变量（因为不合格的列引用<code class="codeph">Price</code> ）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">B</code>的定义引用了模式变量<code class="codeph">A</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">C</code>的定义引用了模式变量<code class="codeph">B</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">D</code>的定义引用了联合行模式变量<code class="codeph">BC</code> 。</p>
                        </li>
                     </ul>
                     <p>在试验匹配中对分区的连续行评估条件，当前行暂时映射到模式允许的模式变量。要成功映射，条件必须求值为true。</p>
                     <p>在前面的示例中：</p><pre class="oac_no_warn" dir="ltr">AS价格&gt; 100</pre><p><code class="codeph">Price</code>是指当前行中的<code class="codeph">Price</code> ，因为映射到任何主行模式变量的最后一行是当前行，它暂时映射到<code class="codeph">A</code>或者，在此示例中，使用<code class="codeph">A.Price</code>会产生相同的结果。
                     </p><pre class="oac_no_warn" dir="ltr">B AS B.Price&gt; A.Price</pre><p><code class="codeph">B.Price</code>指当前行中的<code class="codeph">Price</code> （因为<code class="codeph">B</code>被定义），而<code class="codeph">A.Price</code>指的是映射到<code class="codeph">A</code>的最后一行。鉴于模式，映射到<code class="codeph">A</code>的唯一行是要映射的第一行。
                     </p><pre class="oac_no_warn" dir="ltr">C AS C.Price &lt;AVG（B.Price）</pre><p>这里<code class="codeph">C.Price</code>指的是当前行中的<code class="codeph">Price</code> ，因为<code class="codeph">C</code>正在被定义。聚合<code class="codeph">AVG</code> （即插入<code class="codeph">Price</code> ）计算为已映射到<code class="codeph">B</code>的所有行的平均值。</p><pre class="oac_no_warn" dir="ltr">D AS D.Price&gt; MAX（BC.Price）</pre><p>模式变量<code class="codeph">D</code>类似于模式变量<code class="codeph">C</code> ，但它说明了在布尔条件中使用并集行模式变量。在这种情况下， <code class="codeph">MAX(BC.Price)</code>返回与变量<code class="codeph">B</code>或变量<code class="codeph">C</code>匹配的行的最大价格值。布尔条件的语义在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF">MEASURES和DEFINE中的表达式</a> ”</span>中有更详细的讨论。
                     </p>
                  </div>
               </div><a id="DWHSG8993"></a><div class="props_rev_3"><a id="GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8" name="GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8"></a><h4 id="DWHSG-GUID-7EFC0A71-C896-4F0E-9FC4-4FC67EB12EC8" class="sect4"><span class="enumeration_section">21.3.8</span>匹配跳过后：定义匹配后重新开始匹配过程的位置</h4>
                  <div>
                     <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code>子句确定在找到非空匹配后恢复行模式匹配的点。该条款的默认值是<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code> 。选项如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code></p>
                           <p>在当前匹配的第一行之后的行处恢复模式匹配。</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code></p>
                           <p>在当前匹配的最后一行之后的下一行继续模式匹配。</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">FIRST</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>在映射到模式变量的第一行继续模式匹配。</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>在映射到模式变量的最后一行继续模式匹配。</p>
                        </li>
                        <li>
                           <p><code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <span class="italic"><code class="codeph">pattern_variable</code></span></p>
                           <p>与<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">LAST</code> <span class="italic"><code class="codeph">pattern_variable</code></span> 。
                           </p>
                        </li>
                     </ul>
                     <p>当使用<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">FIRST</code>或<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">[LAST]</code> ，可能没有行被映射到pattern_variable。例如：</p><pre class="oac_no_warn" dir="ltr">在比赛后跳到一个模式（XA * X），</pre><p>示例中的模式变量<code class="codeph">A</code>可能没有映射到<code class="codeph">A</code>行。如果没有行映射到<code class="codeph">A</code> ，则没有要跳过的行，因此会生成运行时异常。另一个问题是<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code>可能会尝试在最后一场比赛开始的同一行恢复模式匹配。例如：</p><pre class="oac_no_warn" dir="ltr">在匹配跳到X模式（X Y + Z）之后，</pre><p>在此示例中， <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">X</code>尝试在找到上一个匹配的同一行恢复模式匹配。这将导致无限循环，因此为此方案生成运行时异常。
                     </p>
                     <p>请注意， <code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code>语法仅确定在非空匹配后继续扫描匹配的点。找到空匹配时，将跳过一行（就好像已指定<code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code>一样）。因此，空匹配永远不会导致其中一个异常。应该重写获取其中一个异常的查询，例如，如下所示：</p><pre class="oac_no_warn" dir="ltr">匹配后跳到一个模式（X（A | B）Y）</pre><p>当行映射到<code class="codeph">B</code> ，这将导致运行时错误，因为没有行映射到<code class="codeph">A</code>如果意图跳到<code class="codeph">A</code>或<code class="codeph">B</code> ，则以下内容将起作用：</p><pre class="oac_no_warn" dir="ltr">匹配跳到C模式（X（A | B）Y）子集C =（A，B）</pre><p>在修订的示例中，无论<code class="codeph">A</code>或<code class="codeph">B</code>是否匹配，都不会出现运行时错误。
                     </p>
                     <p>另一个例子：</p><pre class="oac_no_warn" dir="ltr">比赛后跳到第一个模式（A * X）</pre><p>此示例在第一次匹配后获得异常，要么跳过到匹配的第一行（如果<code class="codeph">A*</code>匹配），要么跳过到不存在的行（如果<code class="codeph">A*</code>不匹配）。在这个例子中， <code class="codeph">SKIP</code> <code class="codeph">TO</code> <code class="codeph">NEXT</code> <code class="codeph">ROW</code>是更好的选择。
                     </p>
                     <p>当使用<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>和除了<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code>之外的跳过选项时，连续匹配可能重叠，在这种情况下，行模式输入表的行<code class="codeph">R</code>可能出现在多个匹配中。在这种情况下，行模式输出表对于行参与的每个匹配将具有一行。如果行模式输入表的一行参与多个匹配，则<code class="codeph">MATCH_NUMBER</code>函数可用于区分匹配。当一行参与多个匹配时，其分类符在每个匹配中可以不同。
                     </p>
                  </div>
               </div><a id="DWHSG9192"></a><a id="DWHSG8996"></a><div class="props_rev_3"><a id="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF" name="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF"></a><h4 id="DWHSG-GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF" class="sect4"><span class="enumeration_section">21.3.9</span>措施和定义中的表达</h4>
                  <div>
                     <p>模式匹配提供以下行模式匹配唯一的标量表达式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>行模式导航操作，使用<code class="codeph">PREV</code> ， <code class="codeph">NEXT</code> ， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code>函数。行模式导航操作在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">行模式导航操作</a> ”</span>中讨论。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">MATCH_NUMBER</code>函数，返回其行模式分区中行模式匹配的序号，在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08">MATCH_NUMBER：查找哪些行匹配</a> ”中讨论</span> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">CLASSIFIER</code>函数，它返回行映射到的主行模式变量的名称，在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C">CLASSIFIER：查找哪个模式变量适用于哪些行</a> ”中讨论</span> 。
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>子句中的表达式具有相同的语法和语义，但以下情况除外：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DEFINE</code>子句仅支持运行语义。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">MEASURES</code>子句默认运行语义，但也支持最终语义。这种区别在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0">RUNNING Versus FINAL Semantics</a> ”中</span>讨论。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-AFEA3481-E159-4435-B16A-5B2F9A17DFCF__GUID-7D2633F1-0B96-4572-8128-434747FB16F5">使用表达式</p>
                     </div>
                     <!-- class="section" -->
                     <p>本节讨论在模式匹配中使用表达式时的一些注意事项，包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08">MATCH_NUMBER：查找哪些行匹配</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C">CLASSIFIER：查找哪个模式变量适用于哪些行</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C">行模式列参考</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC">骨料</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86">行模式导航操作</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8994"></a><div class="props_rev_3"><a id="GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08" name="GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08"></a><h5 id="DWHSG-GUID-FDD3FCDF-85F5-494F-8B15-6576CAC31F08" class="sect5"><span class="enumeration_section">21.3.9.1</span> MATCH_NUMBER：查找哪些行匹配</h5>
                     <div>
                        <p>行模式分区内的匹配按顺序从1开始按顺序编号。请注意，匹配编号在每个行模式分区中从1开始重新开始，因为行模式分区之间没有固有的顺序。<code class="codeph">MATCH_NUMBER()</code>是一个返回数字值的函数，其标度为0（零），其值是行模式分区中匹配的顺序编号。
                        </p>
                        <p>前面使用<code class="codeph">MATCH_NUMBER()</code>示例已经显示它在<code class="codeph">MEASURES</code>子句中使用。也可以在<code class="codeph">DEFINE</code>子句中使用<code class="codeph">MATCH_NUMBER()</code> ，它可用于定义依赖于匹配编号的条件。
                        </p>
                     </div>
                  </div><a id="DWHSG8995"></a><div class="props_rev_3"><a id="GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C" name="GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C"></a><h5 id="DWHSG-GUID-BAFE1F4E-4507-4DFF-93B9-E7452FDC7E3C" class="sect5"><span class="enumeration_section">21.3.9.2</span>分类器：查找哪个模式变量适用于哪些行</h5>
                     <div>
                        <p><code class="codeph">CLASSIFIER</code>函数返回一个字符串，其值是行映射到的模式变量的名称。<code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>子句中都允许使用<code class="codeph">CLASSIFIER</code>功能。
                        </p>
                        <p>在<code class="codeph">DEFINE</code>子句中， <code class="codeph">CLASSIFIER</code>函数返回当前行映射到的主模式变量的名称。
                        </p>
                        <p>在<code class="codeph">MEASURES</code>条款中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果指定了<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，则查询在处理<code class="codeph">MEASURES</code>子句时使用匹配的最后一行，因此<code class="codeph">CLASSIFIER</code>函数返回匹配的最后一行映射到的模式变量的名称。
                              </p>
                           </li>
                           <li>
                              <p>如果指定了<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，则对于找到的匹配的每一行， <code class="codeph">CLASSIFIER</code>函数返回行映射到的模式变量的名称。
                              </p>
                           </li>
                        </ul>
                        <p>空匹配的起始行的分类器是空值。</p>
                     </div>
                  </div><a id="DWHSG8997"></a><div class="props_rev_3"><a id="GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C" name="GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C"></a><h5 id="DWHSG-GUID-415869D9-40B1-44A3-B6B5-F197BA11B33C" class="sect5"><span class="enumeration_section">21.3.9.3</span>行模式列引用</h5>
                     <div>
                        <p>行模式列引用是由显式或隐式模式变量限定的列名，如下所示：</p><pre class="oac_no_warn" dir="ltr">A.Price</pre><p><code class="codeph">A</code>是模式变量， <code class="codeph">Price</code>是列名。没有限定符的列名称（如<code class="codeph">Price</code>由通用行模式变量隐式限定，该变量引用匹配中所有行的集合。列引用可以嵌套在其他语法元素中，尤其是聚合和导航操作符。（但是，行模式匹配中的嵌套受到<code class="codeph">FROM</code>子句中<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0">禁止嵌套在MATCH_RECOGNIZE子句中</a> ”中</span>描述的限制。）
                        </p>
                        <p>模式列引用分类如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌套在聚合中，例如<code class="codeph">SUM</code> ：聚合行模式列引用。
                              </p>
                           </li>
                           <li>
                              <p>嵌套在行模式导航操作（ <code class="codeph">PREV</code> ， <code class="codeph">NEXT</code> ， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code> ）中：导航的行模式列引用。
                              </p>
                           </li>
                           <li>
                              <p>否则：普通的行模式列引用。</p>
                           </li>
                        </ul>
                        <p>聚合或行模式导航操作中的所有模式列引用必须由相同的模式变量限定。例如：</p><pre class="oac_no_warn" dir="ltr">PATTERN（A + B +）DEFINE B AS AVG（A.Price + B.Tax）&gt; 100</pre><p>前面的示例是语法错误，因为<code class="codeph">A</code>和<code class="codeph">B</code>是两个不同的模式变量。聚合语义需要一组行;没有办法形成一组行来评估<code class="codeph">A.Price + B.Tax</code> 。但是，以下是可以接受的：</p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG（B.Price + B.Tax）&gt; 100</pre><p>在前面的示例中，聚合中的所有模式列引用都由<code class="codeph">B</code>限定。</p>
                        <p>非限定列引用由通用行模式变量隐式限定，该变量引用匹配中所有行的集合。例如：</p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG（价格+ B.Tax）&gt; 1000</pre><p>前面的示例是语法错误，因为非限定列引用<code class="codeph">Price</code>由通用行模式变量隐式限定，而<code class="codeph">B.Tax</code>由<code class="codeph">B</code>显式限定。但是，以下是可以接受的：</p><pre class="oac_no_warn" dir="ltr">DEFINE B AS AVG（价格+税）&gt; 1000</pre><p>在前面的示例中， <code class="codeph">Price</code>和<code class="codeph">Tax</code>都由通用行模式变量隐式限定。
                        </p>
                     </div>
                  </div><a id="DWHSG8998"></a><div class="props_rev_3"><a id="GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC" name="GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC"></a><h5 id="DWHSG-GUID-87BCA5E7-B796-456C-A65D-FCE810F693FC" class="sect5"><span class="enumeration_section">21.3.9.4</span>聚合</h5>
                     <div>
                        <p>聚合（ <code class="codeph">COUNT</code> ， <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MAX</code>和<code class="codeph">MIN</code> ）可以在<code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>子句中使用。请注意，不支持<code class="codeph">DISTINCT</code>关键字。在行模式匹配中使用时，聚合使用运行或最终语义对映射到特定模式变量的一组行进行操作。例如：</p><pre class="oac_no_warn" dir="ltr">MEASURES SUM（A.Price）AS RunningSumOverA，FINAL SUM（A.Price）AS FinalSumOverA PER ROWS PER MATCH</pre><p>在此示例中， <code class="codeph">A</code>是模式变量。第一个模式度量<code class="codeph">RunningSumOverA</code>未指定<code class="codeph">RUNNING</code>或<code class="codeph">FINAL</code> ，因此它默认为<code class="codeph">RUNNING</code> 。这意味着它被计算为当前匹配映射到<code class="codeph">A</code>的那些行中的<code class="codeph">Price</code>之和，直到并包括当前行。第二个模式度量<code class="codeph">FinalSumOverA</code>计算当前匹配映射到<code class="codeph">A</code>的所有行的<code class="codeph">Price</code>之和，包括可能晚于当前行的行。最终聚合仅在<code class="codeph">MEASURES</code>子句中可用，而不在<code class="codeph">DEFINE</code>子句中。
                        </p>
                        <p>聚合中包含的非限定列引用由通用行模式变量隐式限定，该变量引用当前模式匹配的所有行。例如：</p><pre class="oac_no_warn" dir="ltr">SUM（价格）</pre><p>计算当前行模式匹配的所有行的<code class="codeph">Price</code>的运行总和。
                        </p>
                        <p>聚合中包含的所有列引用必须由相同的模式变量限定。例如：</p><pre class="oac_no_warn" dir="ltr">SUM（价格+ A.Tax）</pre><p>由于<code class="codeph">Price</code>由通用行模式变量隐式限定，而<code class="codeph">A.Tax</code>由<code class="codeph">A</code>显式限定，因此会出现语法错误。
                        </p>
                        <p><code class="codeph">COUNT</code>聚合具有模式匹配的特殊语法，因此可以指定<code class="codeph">COUNT(A.*)</code> 。<code class="codeph">COUNT(A.*)</code>是当前模式匹配映射到模式变量A的行数。对于<code class="codeph">COUNT(*)</code> ， <code class="codeph">*</code>隐式覆盖通用行模式变量的行，因此<code class="codeph">COUNT(*)</code>是当前模式匹配中的行数。
                        </p>
                     </div>
                  </div><a id="DWHSG9000"></a><div class="props_rev_3"><a id="GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86" name="GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86"></a><h5 id="DWHSG-GUID-81B6B874-1D40-43A0-A8CE-06FEF68A1B86" class="sect5"><span class="enumeration_section">21.3.9.5</span>行模式导航操作</h5>
                     <div>
                        <p>有四个函数 - <code class="codeph">PREV</code> ， <code class="codeph">NEXT</code> ， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code> - 通过物理或逻辑偏移实现行模式内的导航。
                        </p>
                     </div><a id="DWHSG8999"></a><div class="props_rev_3"><a id="GUID-D53633CB-550C-4574-BF90-A91797D1E8DB" name="GUID-D53633CB-550C-4574-BF90-A91797D1E8DB"></a><h6 id="DWHSG-GUID-D53633CB-550C-4574-BF90-A91797D1E8DB" class="sect6"><span class="enumeration_section">21.3.9.5.1</span> PREV和NEXT</h6>
                        <div>
                           <p><code class="codeph">PREV</code>函数可用于使用分区中的前一行来计算表达式。它根据物理行进行操作，并不限于映射到特定变量的行。如果没有前一行，则返回null值。例如：</p><pre class="oac_no_warn" dir="ltr">DEFINE A PRE PRE（A.Price）&gt; 100</pre><p>前面的示例说明，如果当前行之前的行的价格大于100，则当前行可以映射到<code class="codeph">A</code>如果前一行不存在（即当前行是行模式分区的第一行），则<code class="codeph">PREV(A.Price)</code>为空，因此条件不为<code class="codeph">True</code> ，因此无法映射第一行到<code class="codeph">A</code></p>
                           <p>请注意，您可以在定义模式变量<code class="codeph">A</code>使用另一个模式变量（例如<code class="codeph">B</code> ），并使条件将<code class="codeph">PREV()</code>函数应用于该其他模式变量。这可能类似于：</p><pre class="oac_no_warn" dir="ltr">定义为上一个（B.PRICE）&gt; 100</pre><p>在这种情况下， <code class="codeph">PREV()</code>函数用于其导航的起始行是映射到模式变量<code class="codeph">B</code>的最后一行。</p>
                           <p><code class="codeph">PREV</code>函数可以接受一个可选的非负整数参数，指示前一行的物理偏移量。从而：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">PREV (A.Price, 0)</code>相当于<code class="codeph">A.Price</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PREV (A.price, 1)</code>相当于<code class="codeph">PREV (A.Price)</code> 。注意：1是默认偏移量。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PREV (A.Price, 2)</code>是在由A表示的具有运行语义的行之前的行中的<code class="codeph">Price</code>的值。（如果没有行映射到A，或者之前没有行两行，则<code class="codeph">PREV (A.Price, 2)</code>为空。）
                                 </p>
                              </li>
                           </ul>
                           <p>偏移量必须是运行时常量（文字，绑定变量和涉及它们的表达式），而不是列或子查询。</p>
                           <p><code class="codeph">NEXT</code>功能是<code class="codeph">PREV</code>功能的前瞻性版本。它可以用于使用物理偏移在行模式分区中引用正向行。语法与<code class="codeph">PREV</code>相同，但函数名称除外。例如：</p><pre class="oac_no_warn" dir="ltr">DEFINE A AS NEXT（A.Price）&gt; 100</pre><p>前面的示例在行模式分区中查找一行。请注意，模式匹配不支持在<code class="codeph">DEFINE</code>子句期间查看当前行的聚合，因为很难预测将来哪个行将映射到哪个模式变量。<code class="codeph">NEXT</code>函数不违反此原则，因为它基于物理偏移导航到“未来”行，这不需要知道行的未来映射。
                           </p>
                           <p>例如，要找到一个隔离的行，它比之前两行的平均值和其后的两行的平均值多两倍：使用<code class="codeph">NEXT</code> ，这可以表示为：</p><pre class="oac_no_warn" dir="ltr">PATTERN（X）DEFINE X AS X.Price&gt; 2 *（PREV（X.Price，2）+ PREV（X.Price，1）+ NEXT（X.Price，1）+ NEXT（X.Price，2）） / 4</pre><p>请注意，评估<code class="codeph">PREV</code>或<code class="codeph">NEXT</code>的行不一定映射到参数中的模式变量。例如，在此示例中， <code class="codeph">PREV (X.Price, 2)</code>在不属于匹配项的行中进行求值。模式变量的目的是标识要偏移的行，而不是最终到达的行。（如果模式变量的定义在<code class="codeph">PREV()</code>或<code class="codeph">NEXT()</code>引用自身，那么它将当前行称为要从中偏移的行。）这一点在<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">在模式匹配中嵌套FIRST和最后一个并且在模式匹配中的下一个</a> ”中</span>进一步讨论。
                           </p>
                           <p><code class="codeph">PREV</code>和<code class="codeph">NEXT</code>可以与多个列引用一起使用;例如：</p><pre class="oac_no_warn" dir="ltr">DEFINE A AS PREV（A.Price + A.Tax）&lt;100</pre><p>当使用复杂表达式作为<code class="codeph">PREV</code>或<code class="codeph">NEXT</code>的第一个参数时，所有限定符必须是相同的模式变量（在此示例中为<code class="codeph">A</code> ）。
                           </p>
                           <p><code class="codeph">PREV</code>和<code class="codeph">NEXT</code>总是有运行语义;关键字<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>不能与<code class="codeph">PREV</code>或<code class="codeph">NEXT</code>一起使用。 （请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B">运行与最终语义和关键字</a> ”相关的部分</span> ）。要获得最终语义，请使用，例如， <code class="codeph">PREV</code> （ <code class="codeph">FINAL</code> <code class="codeph">LAST (A.Price))</code>如<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">在模式匹配中嵌套FIRST和LAST以及模式匹配中的NEXT</a> ”中所述</span> 。
                           </p>
                        </div><a id="DWHSG9002"></a><a id="DWHSG9001"></a><div class="props_rev_3"><a id="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5" name="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5"></a><h6 id="DWHSG-GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5" class="sect6"><span class="enumeration_section">21.3.9.5.1.1第</span>一次和最后一次</h6>
                           <div>
                              <p>与<code class="codeph">PREV</code>和<code class="codeph">NEXT</code>函数相比， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code>函数仅在映射到模式变量的行之间导航：它们使用逻辑而非物理偏移。<code class="codeph">FIRST</code>返回在映射到模式变量的行组的第一行中计算的表达式的值。例如：</p><pre class="oac_no_warn" dir="ltr">第一（A.Price）</pre><p>如果没有行映射到<code class="codeph">A</code> ，则该值为null。
                              </p>
                              <p>类似地， <code class="codeph">LAST</code>返回在映射到模式变量的行组的最后一行中计算的表达式的值。例如：</p><pre class="oac_no_warn" dir="ltr">最后（A.Price）</pre><p>前面的示例计算映射到<code class="codeph">A</code>的最后一行中的<code class="codeph">A.Price</code> （如果没有这样的行，则为null）。
                              </p>
                              <p><code class="codeph">FIRST</code>和<code class="codeph">LAST</code>运算符可以接受可选的非负整数参数，该参数指示映射到模式变量的行集内的逻辑偏移量。例如：</p><pre class="oac_no_warn" dir="ltr">第一（A.Price，1）</pre><p>上一行评估映射到<code class="codeph">A</code>的第二行中的<code class="codeph">Price</code> 。请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5__CACHFFDJ" title="该表包含FIRST和LAST函数示例中使用的数据集和映射。">表21-1中</a>的以下数据集和映射。
                              </p>
                              <div class="tblformal" id="GUID-2AA752D4-AD79-41FB-8F0C-925F012742F5__CACHFFDJ">
                                 <p class="titleintable">表21-1模式和行</p>
                                 <table cellpadding="4" cellspacing="0" class="Formal" title="模式和行" width="100%" border="1" summary="This table contains a data set and mappings that are used in the FIRST and LAST function examples." frame="hsides" rules="rows">
                                    <thead>
                                       <tr align="left" valign="top">
                                          <th align="left" valign="bottom" width="32%" id="d80268e3657">行</th>
                                          <th align="left" valign="bottom" width="25%" id="d80268e3660">价钱</th>
                                          <th align="left" valign="bottom" width="43%" id="d80268e3663">制图</th>
                                       </tr>
                                    </thead>
                                    <tbody>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3668" headers="d80268e3657 ">
                                             <p>R1</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3668 d80268e3660 ">
                                             <p>10</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3668 d80268e3663 ">
                                             <p>一个</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3678" headers="d80268e3657 ">
                                             <p>R2</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3678 d80268e3660 ">
                                             <p>20</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3678 d80268e3663 ">
                                             <p>乙</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3688" headers="d80268e3657 ">
                                             <p>R3</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3688 d80268e3660 ">
                                             <p>三十</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3688 d80268e3663 ">
                                             <p>一个</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3698" headers="d80268e3657 ">
                                             <p>R4</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3698 d80268e3660 ">
                                             <p>40</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3698 d80268e3663 ">
                                             <p>C</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="32%" id="d80268e3708" headers="d80268e3657 ">
                                             <p>R5</p>
                                          </td>
                                          <td align="left" valign="top" width="25%" headers="d80268e3708 d80268e3660 ">
                                             <p>50</p>
                                          </td>
                                          <td align="left" valign="top" width="43%" headers="d80268e3708 d80268e3663 ">
                                             <p>一个</p>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </div>
                              <!-- class="inftblhruleinformal" -->
                              <p>然后是以下内容：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price)</code> = <code class="codeph">FIRST (A.Price, 0)</code> = <code class="codeph">LAST (A.Price, 2) = 10</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 1)</code> = <code class="codeph">LAST (A.Price, 1) = 30</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 2)</code> = <code class="codeph">LAST (A.Price, 0) = LAST (A.Price) = 50</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FIRST (A.Price, 3)</code>为空， <code class="codeph">LAST (A.Price, 3)</code></p>
                                 </li>
                              </ul>
                              <p>注意，偏移是逻辑偏移，在映射到模式变量<code class="codeph">A</code>的行<code class="codeph">{R1, R3, R5}</code>的行集内移动。与<code class="codeph">PREV</code>或<code class="codeph">NEXT</code> ，它不是物理偏移。</p>
                              <p>可选的整数参数必须是运行时常量（文字，绑定变量和涉及它们的表达式），而不是列或子查询。</p>
                              <p><code class="codeph">FIRST</code>或<code class="codeph">LAST</code>的第一个参数必须至少有一个行模式列引用。因此， <code class="codeph">FIRST(1)</code>是语法错误。
                              </p>
                              <p><code class="codeph">FIRST</code>或<code class="codeph">LAST</code>的第一个参数可能有多个行模式列引用，在这种情况下，所有限定符必须是相同的模式变量。例如， <code class="codeph">FIRST (A.Price + B.Tax)</code>是语法错误，但<code class="codeph">FIRST (A.Price + A.Tax)</code>是可接受的。
                              </p>
                              <p><code class="codeph">FIRST</code>和<code class="codeph">LAST</code>支持运行和最终语义。<code class="codeph">RUNNING</code>关键字是缺省值，是<code class="codeph">DEFINE</code>子句中唯一受支持的选项。可以使用关键字<code class="codeph">FINAL</code>在<code class="codeph">MEASURES</code>访问最终语义，如下所示：</p><pre class="oac_no_warn" dir="ltr">最终最终（A.Price）作为最终价格的所有行数</pre></div>
                        </div>
                     </div>
                  </div><a id="DWHSG9193"></a><div class="props_rev_3"><a id="GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B" name="GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B"></a><h5 id="DWHSG-GUID-F7ECC486-0BDA-47AD-90B9-C356F5E18C5B" class="sect5"><span class="enumeration_section">21.3.9.6</span>运行与最终语义和关键字</h5>
                     <div>
                        <p>本节讨论使用<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>时要记住的一些注意事项。</p>
                     </div><a id="DWHSG9007"></a><a id="DWHSG9008"></a><a id="DWHSG9009"></a><a id="DWHSG9010"></a><a id="DWHSG9011"></a><a id="DWHSG9194"></a><div class="props_rev_3"><a id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0" name="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0"></a><h6 id="DWHSG-GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0" class="sect6"><span class="enumeration_section">21.3.9.6.1</span>运行与最终语义</h6>
                        <div>
                           <p>行序列中的模式匹配通常被认为是一个增量过程，检查一行接一行，看它是否适合模式。使用此增量处理模型，在识别完整模式之前的任何步骤中，只有部分匹配，并且不知道将来可能添加哪些行，也不知道未来行可能映射到哪些变量。因此，在模式匹配中， <code class="codeph">DEFINE</code>子句的布尔条件中的行模式列引用具有运行语义。这意味着模式变量表示已映射到模式变量的行集，包括当前行，但不包括任何将来的行。
                           </p>
                           <p>在完成匹配之后，可以具有最终语义。最终语义与在成功匹配的最后一行上运行语义相同。最终语义仅在<code class="codeph">MEASURES</code>可用，因为在<code class="codeph">DEFINE</code> ，是否存在完全匹配的不确定性。
                           </p>
                           <p>关键字<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>分别用于表示运行或最终语义; <span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2">RUNNING与最终关键字</a> ”</span>中讨论了这些关键字的规则。
                           </p>
                           <p><code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>表达式评估的基本规则如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>当在一组行上计算涉及模式变量的表达式时，将使用映射到模式变量的行集。如果该集为空，则<code class="codeph">COUNT</code>为0，并且涉及模式变量的任何其他表达式为null。
                                 </p>
                              </li>
                              <li>
                                 <p>当表达式需要在单行中进行求值时，则使用该集合的最新行。如果该集为空，则表达式为null。</p>
                              </li>
                           </ul>
                           <p>例如，请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJHBAI">示例21-7中</a>的下表和查询。
                           </p>
                           <div class="example" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJHBAI">
                              <p class="titleinexample">例21-7运行与最终语义</p><pre class="oac_no_warn" dir="ltr">选择M.Symbol，M.Tstamp，M.Price，M.RunningAvg，M.FinalAvg来自TICKER MATCH_RECOGNIZE（按符号顺序划分tstamp措施运行AVG（A.Price）AS RunningAvg，FINAL AVG（A.Price）AS FinalAvg所有匹配模式（A +）定义为A. A.Price&gt; = AVG（A.Price））M;</pre></div>
                           <!-- class="example" -->
                           <p>请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACEDGJH" title="此表显示有序模式和分区数据。">表21-2中</a>显示的以下有序行模式分区数据。
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACEDGJH">
                              <p class="titleintable">表21-2模式和分区数据</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="模式和分区数据" width="100%" border="1" summary="This table displays ordered pattern and partitioned data." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="22%" id="d80268e3939">行</th>
                                       <th align="left" valign="bottom" width="20%" id="d80268e3942">符号</th>
                                       <th align="left" valign="bottom" width="27%" id="d80268e3945">时间戳</th>
                                       <th align="left" valign="bottom" width="32%" id="d80268e3948">价钱</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3953" headers="d80268e3939 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3953 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3953 d80268e3945 ">
                                          <p>09军，09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3953 d80268e3948 ">
                                          <p>10</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3966" headers="d80268e3939 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3966 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3966 d80268e3945 ">
                                          <p>10君09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3966 d80268e3948 ">
                                          <p>16</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3979" headers="d80268e3939 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3979 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3979 d80268e3945 ">
                                          <p>11君09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3979 d80268e3948 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="22%" id="d80268e3992" headers="d80268e3939 ">
                                          <p>R4</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e3992 d80268e3942 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d80268e3992 d80268e3945 ">
                                          <p>12君09</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d80268e3992 d80268e3948 ">
                                          <p>9</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>以下逻辑可用于查找匹配：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在行模式分区的第一行上，暂时将行<code class="codeph">R1</code>映射到模式变量<code class="codeph">A</code>此时，映射到变量<code class="codeph">A</code>的行集是<code class="codeph">{R1}</code> 。要确认此映射是否成功，请评估谓词：</p>
                                 <p><code class="codeph">A.Price&gt; = AVG（A.Price）</code></p>
                                 <p>在左侧，必须在单行中评估<code class="codeph">A.Price</code> ，这是使用运行语义的集合的最后一行。该集的最后一行是<code class="codeph">R1</code> ;因此<code class="codeph">A.Price</code>是10。
                                 </p>
                                 <p>在右侧， <code class="codeph">AVG (A.Price)</code>是一个聚合，它是使用集合的行计算的。这个平均值是10/1 = 10。
                                 </p>
                                 <p>因此谓词询问<code class="codeph">10 &gt;= 10.</code> 答案是肯定的，因此映射成功。但是，模式<code class="codeph">A+</code>是贪婪的，因此查询必须尝试匹配更多行（如果可能）。
                                 </p>
                              </li>
                              <li>
                                 <p>在行模式分区的第二行上，暂时将<code class="codeph">R2</code>映射到模式变量<code class="codeph">A</code>此时有两行映射到<code class="codeph">A</code> ，因此该集合为<code class="codeph">{R1, R2}</code> 。通过评估谓词来确认映射是否成功。
                                 </p>
                                 <p><code class="codeph">A.Price&gt; = AVG（A.Price）</code></p>
                                 <p>在左侧，必须在单行中评估<code class="codeph">A.Price</code> ，这是使用运行语义的集合的最后一行。该集的最后一行是<code class="codeph">R2</code> ;因此<code class="codeph">A.Price</code>是16。在右侧， <code class="codeph">AVG (A.Price)</code>是一个聚合，它是使用集合的行计算的。该平均值为（10 + 16）/ 2 = 13。因此谓词询问16&gt; = 13。答案是肯定的，因此映射成功。
                                 </p>
                              </li>
                              <li>
                                 <p>在行模式分区的第三行上，暂时将<code class="codeph">R3</code>映射到模式变量<code class="codeph">A</code>现在有三行映射到<code class="codeph">A</code> ，因此该集合为<code class="codeph">{R1, R2, R3}</code> 。通过评估谓词来确认映射是否成功：</p>
                                 <p><code class="codeph">A.Price&gt; = AVG（A.Price）</code></p>
                                 <p>在左侧， <code class="codeph">A.Price</code>在<code class="codeph">R3</code>进行评估;因此， <code class="codeph">A.Price</code>是13。
                                 </p>
                                 <p>在右侧， <code class="codeph">AVG (A.Price)</code>是一个聚合，它是使用集合的行计算的。该平均值为（10 + 16 + 13）/ 3 = 13。因此谓词询问13&gt; = 13。答案是肯定的，因此映射成功。
                                 </p>
                              </li>
                              <li>
                                 <p>在行模式分区的第四行，暂时将<code class="codeph">R4</code>映射到模式变量<code class="codeph">A</code>此时，该集合为<code class="codeph">{R1, R2, R3, R4}</code> 。通过评估谓词来确认映射是否成功：</p>
                                 <p><code class="codeph">A.Price&gt; = AVG（A.Price）</code></p>
                                 <p>在左侧， <code class="codeph">A.Price</code>在<code class="codeph">R4</code>评估;因此， <code class="codeph">A.Price</code>是9。
                                 </p>
                                 <p>在右侧， <code class="codeph">AVG (A.Price)</code>是一个聚合，它是使用集合的行计算的。该平均值为（10 + 16 + 13 + 9）/ 4 = 12。因此谓词询问9&gt; = 12。答案是否定的，因此映射不成功。
                                 </p>
                              </li>
                           </ul>
                           <p><code class="codeph">R4</code>不满足<code class="codeph">A</code>的定义，因此与<code class="codeph">A+</code>的最长匹配是<code class="codeph">{R1, R2, R3}</code> 。因为<code class="codeph">A+</code>有一个贪心量词，所以这是首选匹配。
                           </p>
                           <p><code class="codeph">DEFINE</code>子句中计算的平均值是运行平均值。在<code class="codeph">MEASURES</code> ，尤其是<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，可以区分最终聚合和运行聚合。请注意在<code class="codeph">MEASURES</code>子句中使用关键字<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code> 。可以在<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJDBGA" title="此表显示运行平均值和最终平均值。">表21-3</a>中的示例的结果中观察到区别。
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACJDBGA">
                              <p class="titleintable">表21-3行模式导航</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="行模式导航" width="100%" border="1" summary="This table displays the running average and final average." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="18%" id="d80268e4211">符号</th>
                                       <th align="left" valign="bottom" width="20%" id="d80268e4214">时间戳</th>
                                       <th align="left" valign="bottom" width="21%" id="d80268e4217">价钱</th>
                                       <th align="left" valign="bottom" width="23%" id="d80268e4220">平均运行</th>
                                       <th align="left" valign="bottom" width="18%" id="d80268e4223">最终平均值</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4228" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4228 d80268e4214 ">
                                          <p>2009-06-09</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4228 d80268e4217 ">
                                          <p>10</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4228 d80268e4220 ">
                                          <p>10</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4228 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4244" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4244 d80268e4214 ">
                                          <p>2009-06-10</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4244 d80268e4217 ">
                                          <p>16</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4244 d80268e4220 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4244 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="18%" id="d80268e4260" headers="d80268e4211 ">
                                          <p>XYZ</p>
                                       </td>
                                       <td align="left" valign="top" width="20%" headers="d80268e4260 d80268e4214 ">
                                          <p>2009-06-11</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d80268e4260 d80268e4217 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d80268e4260 d80268e4220 ">
                                          <p>13</p>
                                       </td>
                                       <td align="left" valign="top" width="18%" headers="d80268e4260 d80268e4223 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>映射到模式变量的行集可能为空。评估空集时：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">COUNT</code>是0。
                                 </p>
                              </li>
                              <li>
                                 <p>任何其他聚合，行模式导航操作或普通模式列引用都为null。</p>
                              </li>
                           </ul>
                           <p>例如：</p><pre class="oac_no_warn" dir="ltr">模式（A？B +）定义A A.Price&gt; 100，B AS B.Price&gt; COUNT（A. *）* 50</pre><p>在前面的示例中，请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACIAFHB" title="此表显示三行的价格值。">表21-4中</a>的数据的以下有序行模式分区。
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACIAFHB">
                              <p class="titleintable">表21-4模式和行</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="模式和行" width="100%" border="1" summary="This table displays the price values for three rows." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="40%" id="d80268e4307">行</th>
                                       <th align="left" valign="bottom" width="60%" id="d80268e4310">价钱</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4315" headers="d80268e4307 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4315 d80268e4310 ">
                                          <p>60</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4322" headers="d80268e4307 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4322 d80268e4310 ">
                                          <p>70</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="40%" id="d80268e4329" headers="d80268e4307 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="60%" headers="d80268e4329 d80268e4310 ">
                                          <p>40</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>可以在此数据中找到匹配，如下所示：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>暂时将行<code class="codeph">R1</code>映射到模式变量<code class="codeph">A</code> （量词<code class="codeph">?</code> 意味着首先尝试与<code class="codeph">A</code>进行单一比赛;如果失败，则将空匹配视为匹配<code class="codeph">A?</code> ）。要查看映射是否成功，将评估谓词<code class="codeph">A.Price &gt; 100</code> 。<code class="codeph">A.Price</code>是60;因此，谓词为false，映射到<code class="codeph">A</code>不成功。
                                 </p>
                              </li>
                              <li>
                                 <p>由于映射到<code class="codeph">A</code>失败，空匹配被视为匹配<code class="codeph">A?</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>暂时将行<code class="codeph">R1</code>映射到<code class="codeph">B</code>检查此映射的谓词是<code class="codeph">B.Price &gt; COUNT (A.*) * 50</code></p>
                                 <p>没有行映射到<code class="codeph">A</code> ，因此<code class="codeph">COUNT (A.*)</code>为0。由于<code class="codeph">B.Price = 60</code>大于0，因此映射成功。
                                 </p>
                              </li>
                              <li>
                                 <p>类似地，行<code class="codeph">R2</code>和<code class="codeph">R3</code>可以成功映射到<code class="codeph">B</code>因为没有更多行，所以这是完全匹配：没有行映射<code class="codeph">A</code> ，行{R1，R2，R3}映射到<code class="codeph">B</code></p>
                              </li>
                           </ul>
                           <p>模式变量可以作为前向引用，即对尚未匹配的模式变量的引用。例如：</p><pre class="oac_no_warn" dir="ltr">PATTERN（X + Y +）DEFINE X AS COUNT（Y。*）&gt; 3，Y AS Y.Price&gt; 10</pre><p>前面的示例是有效的语法。但是，此示例永远不会匹配，因为在将行映射到<code class="codeph">X</code> ，没有行已映射到<code class="codeph">Y</code>因此<code class="codeph">COUNT(Y.*)</code>为0且永远不会大于3。即使有四个可能成功映射到<code class="codeph">Y</code>未来行，也是如此。请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACFHCII" title="此表显示数据模式分区的数据集。">表21-5中的</a>此数据集。
                           </p>
                           <div class="tblformal" id="GUID-896F20BD-FB91-4CE8-9D7D-E7AF8F12B9B0__CACFHCII">
                              <p class="titleintable">表21-5模式和行</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="模式和行" width="100%" border="1" summary="This table displays the data set for pattern partition of data." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="46%" id="d80268e4449">行</th>
                                       <th align="left" valign="bottom" width="54%" id="d80268e4452">价钱</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4457" headers="d80268e4449 ">
                                          <p>R1</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4457 d80268e4452 ">
                                          <p>2</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4464" headers="d80268e4449 ">
                                          <p>R2</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4464 d80268e4452 ">
                                          <p>11</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4471" headers="d80268e4449 ">
                                          <p>R3</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4471 d80268e4452 ">
                                          <p>12</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4478" headers="d80268e4449 ">
                                          <p>R4</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4478 d80268e4452 ">
                                          <p>13</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="46%" id="d80268e4485" headers="d80268e4449 ">
                                          <p>R5</p>
                                       </td>
                                       <td align="left" valign="top" width="54%" headers="d80268e4485 d80268e4452 ">
                                          <p>14</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>将<code class="codeph">{R2, R3, R4, R5}</code>映射到<code class="codeph">Y</code>将是成功的，因为这些行中的所有四行都满足为<code class="codeph">Y</code>定义的布尔条件。在这种情况下，您可能认为可以将<code class="codeph">R1</code>映射到<code class="codeph">X</code>并完成匹配。但是，模式匹配的规则将找不到此匹配，因为根据模式<code class="codeph">X+ Y+</code> ，在将任何行映射到<code class="codeph">Y</code>之前，必须至少将一行映射到<code class="codeph">X</code></p>
                        </div>
                     </div><a id="DWHSG9195"></a><div class="props_rev_3"><a id="GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2" name="GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2"></a><h6 id="DWHSG-GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2" class="sect6"><span class="enumeration_section">21.3.9.6.2</span>运行与最终关键字</h6>
                        <div>
                           <p><code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>是用于指示是否需要运行或最终语义的关键字。<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>可以与聚合和行模式导航操作<code class="codeph">FIRST</code>和<code class="codeph">LAST</code> 。</p>
                           <p>聚合， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code>可以在行模式匹配查询中的以下位置发生：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在<code class="codeph">DEFINE</code>条款中。处理<code class="codeph">DEFINE</code>子句时，查询仍处于识别匹配的过程中，因此唯一支持的语义正在运行。
                                 </p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">MEASURES</code>条款中。处理<code class="codeph">MEASURES</code>子句时，查询已完成识别匹配;因此，可以考虑最终语义。有两个子类：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果指定了<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，那么从概念上讲，查询位于匹配的最后一行，并且运行与最终语义之间没有真正的区别。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果指定了<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，则行模式输出表将为匹配的每一行分配一行。在这种情况下，用户可能希望同时看到运行和最终值，因此模式匹配提供<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>关键字以支持该区别。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <p>根据此分析，模式匹配指定以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在<code class="codeph">MEASURES</code> ，关键字<code class="codeph">RUNNING</code>和<code class="codeph">FINAL</code>可用于指示聚合， <code class="codeph">FIRST</code>或<code class="codeph">LAST</code>的所需语义。关键字在运算符之前写入，例如， <code class="codeph">RUNNING</code> <code class="codeph">COUNT</code> <code class="codeph">(A.*)</code>或<code class="codeph">FINAL</code> <code class="codeph">SUM</code> <code class="codeph">(B.Price)</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code> ，默认值为<code class="codeph">RUNNING</code> 。</p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">DEFINE</code> ，不允许使用<code class="codeph">FINAL</code> ;如果需要，可以使用<code class="codeph">RUNNING</code>来增加清晰度。
                                 </p>
                              </li>
                              <li>
                                 <p>在具有<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">MEASURES</code> ，在识别出匹配的最后一行之后计算所有聚合， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code> ，以便默认的<code class="codeph">RUNNING</code>语义实际上与<code class="codeph">FINAL</code>语义没有区别。在这些情况下，用户可能更愿意将表达式默认为<code class="codeph">FINAL</code> ，或者用户可以选择写入<code class="codeph">FINAL</code>以增加清晰度。
                                 </p>
                              </li>
                              <li>
                                 <p>普通列引用具有运行语义。（对于<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，要在<code class="codeph">MEASURES</code>获取最终语义，请使用<code class="codeph">FINAL</code> <code class="codeph">LAST</code>行模式导航操作，而不是普通的列引用。）
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="DWHSG9196"></a><div class="props_rev_3"><a id="GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8" name="GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8"></a><h6 id="DWHSG-GUID-92114C69-76DC-4393-BF8C-0BD70A3286B8" class="sect6"><span class="enumeration_section">21.3.9.6.3</span>普通行模式列参考</h6>
                        <div>
                           <p>普通行模式列引用既不是聚合也不是导航，例如：</p><pre class="oac_no_warn" dir="ltr">A.Price</pre><p><span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-91574202-3C6D-47E1-A28E-0692BB45CCF2">RUNNING与最终关键字关键字</a> ”</span>表示普通行模式列引用始终具有运行语义。这意味着：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在<code class="codeph">DEFINE</code> ，普通列引用引用映射到模式变量的最后一行，直到并包括当前行。如果没有这样的行，则该值为null。
                                 </p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">MEASURES</code> ，有两个子类：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果指定了<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，那么还有一个当前行的概念，其语义与<code class="codeph">DEFINE</code>中的相同。</p>
                                    </li>
                                    <li>
                                       <p>如果指定了<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，那么从概念上讲，查询位于匹配的最后一行。普通列引用引用映射到模式变量的最后一行。如果变量未映射到任何行，则该值为null。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <p>这些语义与<code class="codeph">LAST</code>运算符相同，默认为隐式<code class="codeph">RUNNING</code> 。因此，普通的列引用（如<code class="codeph">X.Price</code> ）等同于<code class="codeph">RUNNING LAST (X.Price)</code> 。
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9003"></a><div class="props_rev_3"><a id="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5" name="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5"></a><h4 id="DWHSG-GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5" class="sect4"><span class="enumeration_section">21.3.10</span>行模式输出</h4>
                  <div>
                     <p><code class="codeph">MATCH_RECOGNIZE</code>的结果称为行模式输出表。行图案输出表的形状（行类型）取决于的选择<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>或<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> 。</p>
                     <p>如果指定或暗示了<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，则行模式输出表的列是声明顺序中的行模式分区列，后面是声明顺序中的行模式度量列。因为表必须至少有一列，这意味着必须至少有一个行模式分区列或一个行模式度量列。
                     </p>
                     <p>如果指定了<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，那么行模式输出表的列是声明顺序中的行模式分区列，声明顺序中的排序列，声明顺序中的行模式度量列，以及最后行模式输入表的任何剩余列，按行它们在行模式输入表中出现的顺序排列。
                     </p>
                     <p>模式度量列的名称和声明类型由<code class="codeph">MEASURES</code>子句确定。非度量列的名称和声明的类型继承自模式输入表的相应列。
                     </p>
                     <div class="infoboxnotealso" id="GUID-CAE4A0B5-41D3-4F4B-BEE7-5B7953CDFBB5__GUID-DF5E7851-B9D4-4F1A-9BB8-19E1286ACDC6">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF">关联名称和行模式输出</a> ”，</span>用于将相关名称分配给行模式输出的信息</p>
                     </div>
                  </div><a id="DWHSG9004"></a><div class="props_rev_3"><a id="GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF" name="GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF"></a><h5 id="DWHSG-GUID-DC8CA75C-01CC-4DAB-BD4D-ECF00E3347EF" class="sect5"><span class="enumeration_section">21.3.10.1</span>关联名称和行模式输出</h5>
                     <div>
                        <p>可以将相关名称分配给行模式输出表，类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT M.Matchno来自Ticker MATCH_RECOGNIZE（...MEASURE MATCH_NUMBER（）AS Matchno ...）M</pre><p>在前面的示例中， <code class="codeph">M</code>是分配给行模式输出表的相关名。分配相关名称的好处是相关名称可用于限定行模式输出表的列名，如前面示例中的<code class="codeph">M.Matchno</code>所示。如果<code class="codeph">FROM</code>子句中有其他表，这对于解决不明确的列名尤其重要。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9014"></a><div class="props_rev_3"><a id="GUID-F120C679-9C56-4703-970E-07C276EA50F1" name="GUID-F120C679-9C56-4703-970E-07C276EA50F1"></a><h3 id="DWHSG-GUID-F120C679-9C56-4703-970E-07C276EA50F1" class="sect3"><span class="enumeration_section">21.4</span>模式匹配的高级主题</h3>
               <div>
                  <p>本节讨论以下高级主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42">在PREV和NEXT中嵌套FIRST和LAST模式匹配</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D">处理模式匹配中的空匹配或不匹配的行</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">如何从输出中排除模式的部分</a></p>
                     </li>
                     <li>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7">如何表达所有排列</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9016"></a><a id="DWHSG9015"></a><div class="props_rev_3"><a id="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42" name="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42"></a><h4 id="DWHSG-GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42" class="sect4"><span class="enumeration_section">21.4.1</span>在模式匹配中在PREV和NEXT内嵌套FIRST和LAST</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">FIRST</code>和<code class="codeph">LAST</code>在已映射到特定模式变量的行集内提供导航; <code class="codeph">PREV</code>和<code class="codeph">NEXT</code>使用特定行的物理偏移量提供导航。可以通过在<code class="codeph">PREV</code>或<code class="codeph">NEXT</code>嵌套<code class="codeph">FIRST</code>或<code class="codeph">LAST</code>来组合这些类型的导航。这允许表达式如下：</p><pre class="oac_no_warn" dir="ltr">上一篇（最后一篇（A.Price + A.Tax，1），3）</pre><p>在此示例中， <code class="codeph">A</code>必须是模式变量。需要具有行模式列引用，并且复合运算符中的所有模式变量必须是等效的（在此示例中为<code class="codeph">A</code> ）。
                        </p>
                        <p>该复合运算符的评估如下：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>内部运算符<code class="codeph">LAST</code>仅对映射到模式变量<code class="codeph">A</code>的行集进行操作。在此集合中，找到<span class="italic">最后</span>一行<span class="italic">减去1</span>的行。（如果没有这样的行，则结果为null。）</span></li>
                        <li><span>外部运算符<code class="codeph">PREV</code>从步骤1中找到的行开始，并在行模式分区中备份三行。（如果没有这样的行，则结果为null。）</span></li>
                        <li><span>设<code class="codeph">R</code>是一个依赖于实现的范围变量，它引用步骤2找到的行。在表达式<code class="codeph">A.Price + A.Tax</code> ，用<code class="codeph">R</code>替换模式变量<code class="codeph">A</code>每次出现。评估结果表达式<code class="codeph">R.Price + R.Tax</code>并确定复合导航操作的值。</span></li>
                     </ol>
                     <div class="section">
                        <p>例如，请考虑<a href="sql-pattern-matching-data-warehouses.html#GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42__CACIACEJ" title="此表显示数据集和映射，以说明模式匹配中的FIRST和LAST函数。">表21-6中</a>的数据集和映射。
                        </p>
                        <div class="tblformal" id="GUID-AC9AACD8-76AE-4AD8-8103-065BE4B54A42__CACIACEJ">
                           <p class="titleintable">表21-6数据集和映射</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="数据集和映射" width="100%" border="1" summary="This table displays a data set and mappings to illustrate the FIRST and LAST functions in pattern matching." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d80268e5125">行</th>
                                    <th align="left" valign="bottom" width="28%" id="d80268e5128">价钱</th>
                                    <th align="left" valign="bottom" width="24%" id="d80268e5131">税</th>
                                    <th align="left" valign="bottom" width="29%" id="d80268e5134">制图</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5139" headers="d80268e5125 ">
                                       <p>R1</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5139 d80268e5128 ">
                                       <p>10</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5139 d80268e5131 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5139 d80268e5134 ">
                                       <p></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5151" headers="d80268e5125 ">
                                       <p>R2</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5151 d80268e5128 ">
                                       <p>20</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5151 d80268e5131 ">
                                       <p>2</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5151 d80268e5134 ">
                                       <p>一个</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5164" headers="d80268e5125 ">
                                       <p>R3</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5164 d80268e5128 ">
                                       <p>三十</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5164 d80268e5131 ">
                                       <p>3</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5164 d80268e5134 ">
                                       <p>乙</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5177" headers="d80268e5125 ">
                                       <p>R4</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5177 d80268e5128 ">
                                       <p>40</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5177 d80268e5131 ">
                                       <p>4</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5177 d80268e5134 ">
                                       <p>一个</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5190" headers="d80268e5125 ">
                                       <p>R5</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5190 d80268e5128 ">
                                       <p>50</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5190 d80268e5131 ">
                                       <p>五</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5190 d80268e5134 ">
                                       <p>C</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d80268e5203" headers="d80268e5125 ">
                                       <p>R6</p>
                                    </td>
                                    <td align="left" valign="top" width="28%" headers="d80268e5203 d80268e5128 ">
                                       <p>60</p>
                                    </td>
                                    <td align="left" valign="top" width="24%" headers="d80268e5203 d80268e5131 ">
                                       <p>6</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d80268e5203 d80268e5134 ">
                                       <p>一个</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>要评估<code class="codeph">PREV (LAST (A.Price + A.Tax, 1), 3)</code> ，可以使用以下步骤：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>映射到<code class="codeph">A</code>的行集是<code class="codeph">{R2, R4, R6}</code> 。<code class="codeph">LAST</code>在此设备上运行，从末端偏移到达<code class="codeph">R4</code>行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PREV</code>执行物理偏移，在<code class="codeph">R4</code>之前3行，到达<code class="codeph">R1</code> 。
                              </p>
                           </li>
                           <li>
                              <p>设<code class="codeph">R</code>是指向<code class="codeph">R1</code>的范围变量。<code class="codeph">R.Price + R.Tax</code>被评估，给出10 + 1 = 11。
                              </p>
                           </li>
                        </ul>
                        <p>请注意，此嵌套未定义为嵌套函数的典型评估。内部运算符<code class="codeph">LAST</code>实际上并不计算表达式<code class="codeph">A.Price + A.Tax</code> ;它使用此表达式指定模式变量<code class="codeph">(A)</code> ，然后在映射到该变量的行内导航。外部运算符<code class="codeph">PREV</code>对行执行进一步的物理导航。表达式<code class="codeph">A.Price + A.Tax</code>实际上并未如此评估，因为最终到达的行不一定映射到模式变量<code class="codeph">A</code>在此示例中， <code class="codeph">R1</code>未映射到任何模式变量。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9017"></a><div class="props_rev_3"><a id="GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D" name="GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D"></a><h4 id="DWHSG-GUID-D3AD7864-B350-4E58-8794-EB87A1EE3F6D" class="sect4"><span class="enumeration_section">21.4.2</span>在模式匹配中处理空匹配或不匹配的行</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>有三个子选项：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code></p>
                           </li>
                        </ul>
                        <p>以下主题介绍了这些选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88">处理模式匹配中的空匹配</a></p>
                           </li>
                           <li>
                              <p><a href="sql-pattern-matching-data-warehouses.html#GUID-09B27A5F-0354-4D07-AC0E-FF2644732178">在模式匹配中处理不匹配的行</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG9018"></a><div class="props_rev_3"><a id="GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88" name="GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88"></a><h5 id="DWHSG-GUID-B5028DDC-6C2E-4DA8-8CC9-2AE324B17F88" class="sect5"><span class="enumeration_section">21.4.2.1</span>处理模式匹配中的空匹配</h5>
                     <div>
                        <div class="section">
                           <p>一些模式允许空匹配。例如， <code class="codeph">PATTERN (A*)</code>可以与映射到<code class="codeph">A</code>零个或多个行匹配。</p>
                           <p>空匹配不会将任何行映射到模式变量;然而，一场空比赛有一个起跑线。例如，分区的第一行可能存在空匹配，分区的第二行可能存在空匹配，依此类推。根据其起始行的序号位置为空匹配分配顺序匹配编号，与任何其他匹配相同。</p>
                           <p>当使用<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，空匹配会导致输出表的一行。空匹配的行模式度量计算如下：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">MATCH_NUMBER()</code>的值是空匹配的顺序匹配编号。
                                 </p>
                              </li>
                              <li>
                                 <p>任何<code class="codeph">COUNT</code>都是0。
                                 </p>
                              </li>
                              <li>
                                 <p>任何其他聚合，行模式导航操作或普通行模式列引用都为null。</p>
                              </li>
                           </ul>
                           <p>至于<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，问题是，是否为空匹配生成一行输出，因为空匹配中没有行。为了治理这个，有两种选择：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> ：使用这个选项，任何空匹配生成的行图案输出表中的单个行。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> ：使用这个选项，从行图案输出表省略空匹配。（这可能会导致顺序匹配编号出现空白。）
                                 </p>
                              </li>
                           </ul>
                           <p><code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>默认<code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code> 。使用此选项，空匹配在行模式输出表中生成一行。在这一行：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">CLASSIFIER()</code>函数的值为null。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">MATCH_NUMBER</code> <code class="codeph">()</code>函数的值是空匹配的顺序匹配编号。
                                 </p>
                              </li>
                              <li>
                                 <p>任何普通行模式列引用的值都为null。</p>
                              </li>
                              <li>
                                 <p>使用空行集计算任何聚合或行模式导航操作的值（因此任何<code class="codeph">COUNT</code>为0，并且所有其他聚合和行模式导航操作为空）。
                                 </p>
                              </li>
                              <li>
                                 <p>对应于行模式输入表的列的任何列的值与空匹配的起始行中的对应列相同。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9019"></a><div class="props_rev_3"><a id="GUID-09B27A5F-0354-4D07-AC0E-FF2644732178" name="GUID-09B27A5F-0354-4D07-AC0E-FF2644732178"></a><h5 id="DWHSG-GUID-09B27A5F-0354-4D07-AC0E-FF2644732178" class="sect5"><span class="enumeration_section">21.4.2.2</span>在模式匹配中处理不匹配的行</h5>
                     <div>
                        <div class="section">
                           <p>行模式输入表的某些行既不是空匹配的起始行，也不是非空匹配的映射。这些行称为不匹配的行。</p>
                           <p>选项<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>显示空匹配和不匹配的行。空匹配的处理方式与<code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>相同。当显示不匹配的行时，所有行模式度量都为空，有点类似于外连接的空扩展端。因此， <code class="codeph">COUNT</code>和<code class="codeph">MATCH_NUMBER</code>可用于区分不匹配的行与空匹配的起始行。禁止使用排除语法{ -   - }，这<code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>的精神相反。有关详细信息，请参阅<span class="q">“ <a href="sql-pattern-matching-data-warehouses.html#GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522">如何从输出中排除模式的一部分</a> ”</span> 。
                           </p>
                           <p>模式不可能允许空匹配并且还具有不匹配的行。原因是如果行模式输入表的一行无法映射到主行模式变量，那么该行仍然可以是空匹配的起始行，并且不会被视为不匹配，假设模式允许空的比赛。因此，如果模式允许空匹配，那么使用<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>的输出与使用<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>的输出相同。因此， <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>主要用于不允许空匹配的模式。但是，如果用户不确定模式是否具有空匹配或不匹配的行，则用户可能更喜欢指定<code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> 。
                           </p>
                           <p>请注意，如果<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>与默认的跳跃行为（使用<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">PAST</code> <code class="codeph">LAST</code> <code class="codeph">ROW</code> ），然后是完全有输出为输入中的每一行一行。
                           </p>
                           <p>使用<code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code>允许其他跳过行为，在这种情况下，行可以通过多个匹配进行映射，并多次出现在行模式输出表中。不匹配的行只会在输出中出现一次。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG9021"></a><a id="DWHSG9020"></a><div class="props_rev_3"><a id="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522" name="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522"></a><h4 id="DWHSG-GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522" class="sect4"><span class="enumeration_section">21.4.3</span>如何从输出中排除模式的一部分</h4>
                  <div>
                     <div class="section">
                        <p>当使用具有<code class="codeph">OMIT</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>或<code class="codeph">SHOW</code> <code class="codeph">EMPTY</code> <code class="codeph">MATCHES</code>子选项的<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> ，可以从行模式输出表中排除匹配<code class="codeph">PATTERN</code>的一部分的行。排除的部分在<code class="codeph">PATTERN</code>子句中的<code class="codeph">{-</code>和<code class="codeph">-}</code>之间括起来。
                        </p>
                        <p>例如，以下示例查找以不低于10的价格开头的价格上涨的最长期间。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-41BCB768-10FC-4737-B33C-4A8FE99A5522__GUID-3D476B17-DFB1-49AB-A1DD-A31727C6FD7E">
                        <p class="titleinexample">例21-8价格上涨的时期</p><pre class="oac_no_warn" dir="ltr">选择M.Symbol，M.Tstamp，M.Matchno，M.Classfr，M.Price，M.Avgp来自Ticker MATCH_RECOGNIZE（按标志分类ORST BY tstamp MEASURES FINAL AVG（S.Price）AS Avgp，CLASSIFIER（）AS Classfr ，MATCH_NUMBER（）AS Matchno匹配后跳过最后B个模式（{ -  A  - } B + { -  C +  - }）SUBSET S =（A，B）定义A A.Price&gt; = 10，B AS B.Price&gt; PREV（B.Price），C AS C.Price &lt;= PREV（C.Price））M ORDER BY符号，tstamp;符号TSTAMP MATCHNO CLAS价格AVGP ---------- --------- ---------- ---- ----------  - --------- ACME 02-APR-11 1 B 17 18.8 ACME 03-APR-11 1 B 19 18.8 ACME 04-APR-11 1 B 21 18.8 ACME 05-APR-11 1 B 25 18.8 ACME 07-APR-11 2 B 15 19.2 ACME 08-APR-11 2 B 20 19.2 ACME 09-APR-11 2 B 24 19.2 ACME 10-APR-11 2 B 25 19.2 ACME 13-APR-11 3 B 25 20 ACME 17-APR-11 4 B 14 16.6666667 ACME 18-APR-11 4 B 24 16.6666667</pre><p>行模式输出表将只有映射到<code class="codeph">B</code>的行，映射到<code class="codeph">A</code>和<code class="codeph">C</code>的行将从输出中排除。虽然排除的行不会出现在行模式输出表中，但它们不会从联合模式变量的定义中排除，也不会从<code class="codeph">DEFINE</code>或<code class="codeph">MEASURES</code>的标量表达式的计算中排除。例如，请参阅前一个示例中的主要模式变量<code class="codeph">A</code>和<code class="codeph">C</code>的定义，联合模式变量<code class="codeph">S</code>的定义或<code class="codeph">Avgp</code>行模式度量。
                        </p>
                        <p>不允许使用排除语法与<code class="codeph">ALL</code> <code class="codeph">ROWS</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code> <code class="codeph">WITH</code> <code class="codeph">UNMATCHED</code> <code class="codeph">ROWS</code> 。</p>
                        <p>使用<code class="codeph">ONE</code> <code class="codeph">ROW</code> <code class="codeph">PER</code> <code class="codeph">MATCH</code>允许排除语法，但它没有任何效果，因为在这种情况下，每个匹配只有一个摘要行。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9022"></a><div class="props_rev_3"><a id="GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7" name="GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7"></a><h4 id="DWHSG-GUID-CFE61EC5-3287-45C7-9439-25BBC7E9F0B7" class="sect4"><span class="enumeration_section">21.4.4</span>如何表达所有排列</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">PERMUTE</code>语法可用于表示作为更简单模式的排列的模式。例如， <code class="codeph">PATTERN (PERMUTE (A, B, C))</code>相当于三个模式变量<code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code>的所有排列的交替，类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">PATTERN（ABC | ACB | BAC | BCA | CAB | CBA）</pre><p>请注意， <code class="codeph">PERMUTE</code>字典顺序扩展，并且每个要置换的元素必须以逗号分隔其他元素。（在此示例中，因为三个模式变量<code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code>按字母顺序列出，所以从词典扩展开始，扩展的可能性也按字母顺序列出。）这很重要，因为可以按照扩展中的顺序尝试替代方案。因此，在匹配<code class="codeph">(</code> <code class="codeph">ACB)</code>之前尝试匹配<code class="codeph">(ABC)</code> <code class="codeph">ACB)</code> ，依此类推;成功的第一次尝试就是所谓的“胜利者”。
                        </p>
                        <p>另一个例子：</p><pre class="oac_no_warn" dir="ltr">模式（PERMUTE（X {3}，BC？，D））</pre><p>这相当于以下内容：</p><pre class="oac_no_warn" dir="ltr">模式（（公元前3 {3}？D）| （X {3} DBC？）| （公元前？X {3} D）| （公元前？DX {3}）| （DX {3} BC？）| （DBC？X {3}））</pre><p>请注意，模式元素“ <code class="codeph">BC?</code>“不是以逗号分隔的，所以它们被视为一个单元。”
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9023"></a><div class="props_rev_3"><a id="GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6" name="GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6"></a><h3 id="DWHSG-GUID-F50A916B-1BB1-42AA-B9EB-AA80D52464F6" class="sect3"><span class="enumeration_section">21.5</span>模式匹配中的规则和限制</h3>
               <div>
                  <div class="section">
                     <p>本节讨论以下规则和限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484">模式匹配中的输入表要求</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0">禁止嵌套在MATCH_RECOGNIZE条款中</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-B58FE3AD-0285-4516-A464-8110530033B9">连接MATCH_RECOGNIZE子句</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-733B9762-654B-47D7-971F-9F1AF70E06CB">聚合限制</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9024"></a><div class="props_rev_3"><a id="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484" name="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484"></a><h4 id="DWHSG-GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484" class="sect4"><span class="enumeration_section">21.5.1</span>模式匹配中的输入表要求</h4>
                  <div>
                     <div class="section">
                        <p>行模式输入表是<code class="codeph">MATCH_RECOGNIZE</code>的输入参数。您可以使用表或视图，也可以使用命名查询（在<code class="codeph">WITH</code>子句中定义）。行模式输入表也可以是派生表（也称为内联视图）。例如。
                        </p><pre class="oac_no_warn" dir="ltr">FROM（SELECT S.Name，T.Tstamp，T.Price FROM Ticker T，SymbolNames S WHERE T.Symbol = S.Symbol）MATCH_RECOGNIZE（...）中号</pre><p>行模式输入表不能是连接表。解决方法是使用派生表，如下所示：</p><pre class="oac_no_warn" dir="ltr">FROM（SELECT * FROM LEFT OUTER JOIN B ON（AX = BY））MATCH_RECOGNIZE（...）中号</pre><p>模式输入表中的列名必须是明确的。如果行模式输入表是基表或视图，则这不是问题，因为SQL不允许在基表或视图中使用不明确的列名。当行模式输入表是派生表时，这只是一个问题。例如，考虑两个表的连接， <code class="codeph">Emp</code>和<code class="codeph">Dept</code> ，每个表都有一个名为<code class="codeph">Name</code>的列。以下是语法错误：</p><pre class="oac_no_warn" dir="ltr">FROM（SELECT D.Name，E.Name，E.Empno，E.Salary FROM Dept D，Emp E WHERE D.Deptno = E.Deptno）MATCH_RECOGNIZE（PARName by D.Name ...）
</pre><p>前面的示例是一个错误，因为变量<code class="codeph">D</code>在<code class="codeph">MATCH_RECOGNIZE</code>子句中不可见（ <code class="codeph">D</code>的范围只是派生表）。类似以下的重写没有帮助：</p><pre class="oac_no_warn" dir="ltr">FROM（SELECT D.Name，E.Name，E.Empno，E.Salary FROM Dept D，Emp E WHERE D.Deptno = E.Deptno）MATCH_RECOGNIZE（PARTITION BY Name ...）
</pre><p>这种重写消除了在<code class="codeph">MATCH_RECOGNIZE</code>子句中使用变量<code class="codeph">D</code>但是，现在错误是<code class="codeph">Name</code>是不明确的，因为派生表有两列名为<code class="codeph">Name</code> 。处理此问题的方法是消除派生表本身中列名的歧义，类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">FROM（SELECT D.Name AS Dname，E.Name AS Ename，E.Empno，E.Salary FROM Dept D，Emp E WHERE D.Deptno = E.Deptno）MATCH_RECOGNIZE（PARIDTION BY Dname ...）
</pre><div class="infoboxnotealso" id="GUID-3D256B0E-CD13-4DE2-ABE5-B187191D5484__GUID-E828B32B-A8A8-4502-86E8-59003DE9D9F3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../sqlrf/Pattern-matching-Conditions.html#SQLRF52141" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9025"></a><div class="props_rev_3"><a id="GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0" name="GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0"></a><h4 id="DWHSG-GUID-D4EA0438-FCE4-48A5-B95F-56224A49CAE0" class="sect4"><span class="enumeration_section">21.5.2</span>禁止嵌套在MATCH_RECOGNIZE子句中</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">MATCH_RECOGNIZE</code>子句中禁止以下类型的嵌套：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将一个<code class="codeph">MATCH_RECOGNIZE</code>子句嵌套在另一个中。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">MEASURES</code>子句或<code class="codeph">DEFINE</code>子条款中的外部引用。这意味着<code class="codeph">MATCH_RECOGNIZE</code>子句不能引用除行模式输入表之外的外部查询块中的任何表。
                              </p>
                           </li>
                           <li>
                              <p>相关子查询不能用于<code class="codeph">MEASURES</code>或<code class="codeph">DEFINE</code> 。此外， <code class="codeph">MEASURES</code>或<code class="codeph">DEFINE</code>子查询不能引用模式变量。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">MATCH_RECOGNIZE</code>子句不能用于递归查询。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句不能使用<code class="codeph">MATCH_RECOGNIZE</code>子句。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9026"></a><div class="props_rev_3"><a id="GUID-B58FE3AD-0285-4516-A464-8110530033B9" name="GUID-B58FE3AD-0285-4516-A464-8110530033B9"></a><h4 id="DWHSG-GUID-B58FE3AD-0285-4516-A464-8110530033B9" class="sect4"><span class="enumeration_section">21.5.3</span>连接的MATCH_RECOGNIZE子句</h4>
                  <div>
                     <div class="section">
                        <p>请注意，不禁止将一个<code class="codeph">MATCH_RECOGNIZE</code>子句的输出提供给另一个<code class="codeph">MATCH_RECOGNIZE</code>子句的输入，如下例所示：</p><pre class="oac_no_warn" dir="ltr">选择 ...FROM（SELECT * FROM Ticker MATCH_RECOGNIZE（...））MATCH_RECOGNIZE（...）
</pre><p>在此示例中，第一个<code class="codeph">MATCH_RECOGNIZE</code>子句位于派生表中，然后该表将输入提供给第二个<code class="codeph">MATCH_RECOGNIZE</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9027"></a><div class="props_rev_3"><a id="GUID-733B9762-654B-47D7-971F-9F1AF70E06CB" name="GUID-733B9762-654B-47D7-971F-9F1AF70E06CB"></a><h4 id="DWHSG-GUID-733B9762-654B-47D7-971F-9F1AF70E06CB" class="sect4"><span class="enumeration_section">21.5.4</span>聚合限制</h4>
                  <div>
                     <div class="section">
                        <p>聚合函数<code class="codeph">COUNT</code> ， <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MAX</code>和<code class="codeph">MIN</code>可以在<code class="codeph">MEASURES</code>和<code class="codeph">DEFINE</code>子句中使用。不支持<code class="codeph">DISTINCT</code>关键字。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9028"></a><div class="props_rev_3"><a id="GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75" name="GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75"></a><h3 id="DWHSG-GUID-7FE4B935-E0A4-4D16-96B4-5097DCA0FC75" class="sect3"><span class="enumeration_section">21.6</span>模式匹配的例子</h3>
               <div>
                  <div class="section">
                     <p>本节包含以下类型的高级模式匹配示例：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4">模式匹配示例：股票市场</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219">模式匹配示例：安全日志分析</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8">模式匹配示例：会话化</a></p>
                        </li>
                        <li>
                           <p><a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD">模式匹配示例：财务跟踪</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9030"></a><a id="DWHSG9031"></a><a id="DWHSG9032"></a><a id="DWHSG9033"></a><a id="DWHSG9034"></a><a id="DWHSG9035"></a><a id="DWHSG9036"></a><a id="DWHSG9029"></a><div class="props_rev_3"><a id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4" name="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4"></a><h4 id="DWHSG-GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4" class="sect4"><span class="enumeration_section">21.6.1</span>模式匹配示例：股票市场</h4>
                  <div>
                     <div class="section">
                        <p>本节包含基于涉及股价和模式的常见任务的模式匹配示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">
                        <p class="titleinexample">例21-9指定幅度的价格下跌</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">例21-9</a>中的查询显示当前价格低于前一天收盘价的特定百分比（在此示例中为8％）的股票。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Ticker3Wave（SYMBOL VARCHAR2（10），tstamp DATE，PRICE NUMBER）;插入Ticker3Wave VALUES（'ACME'，'01 -Apr-11'，1000）;插入Ticker3Wave VALUES（'ACME'，'02 -Apr-11'，775）;插入Ticker3Wave VALUES（'ACME'，'03 -Apr-11'，900）;插入Ticker3Wave VALUES（'ACME'，'04 -Apr-11'，775）;插入Ticker3Wave VALUES（'ACME'，'05 -Apr-11'，900）;插入Ticker3Wave VALUES（'ACME'，'06 -Apr-11'，775）;插入Ticker3Wave VALUES（'ACME'，'07 -Apr-11'，900）;插入Ticker3Wave VALUES（'ACME'，'08 -Apr-11'，775）;插入Ticker3Wave VALUES（'ACME'，'09 -Apr-11'，800）;插入Ticker3Wave VALUES（'ACME'，'10 -Apr-11'，550）;插入Ticker3Wave VALUES（'ACME'，'11 -Apr-11'，900）;插入Ticker3Wave VALUES（'ACME'，'12 -Apr-11'，800）;插入Ticker3Wave VALUES（'ACME'，'13 -Apr-11'，1100）;插入Ticker3Wave VALUES（'ACME'，'14 -Apr-11'，800）;插入Ticker3Wave VALUES（'ACME'，'15 -Apr-11'，550）;插入Ticker3Wave VALUES（'ACME'，'16 -Apr-11'，800）;插入Ticker3Wave VALUES（'ACME'，'17 -Apr-11'，875）;插入Ticker3Wave VALUES（'ACME'，'18 -Apr-11'，950）;插入Ticker3Wave VALUES（'ACME'，'19 -Apr-11'，600）;插入Ticker3Wave VALUES（'ACME'，'20 -Apr-11'，300）; SELECT * FROM Ticker3Wave MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES B.tstamp AS时间戳，A.price AS Aprice，B.price AS Bprice，（（B.price  -  A.price）* 100）/ A.price AS PctDrop匹配后跳到B模式（AB）DEFINE B AS（B.price  -  A.price）/ A.price &lt;-0.08）; SYMBOL TIMESTAMP APRICE BPRICE PCTDROP ------ --------- ---------- ------- ---------- ACME 02- APR-11 1000 775 -22.5 ACME 04-APR-11 900 775 -13.888889 ACME 06-APR-11 900 775 -13.888889 ACME 08-APR-11 900 775 -13.888889 ACME 10-APR-11 800 550 -31.25 ACME 12- APR-11 900 800 -11.111111 ACME 14-APR-11 1100 800 -27.272727 ACME 15-APR-11 800 550 -31.25 ACME 19-APR-11 950 600 -36.842105 ACME 20-APR-11 600 300 -50.0 10行选择。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACCFCAF">
                        <p class="titleinexample">例21-10当返回原始价格时，指定幅度的价格下跌</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACCFCAF">例21-10中</a>的查询扩展了<a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJADEG">例21-9中</a>定义的模式。它发现价格下跌超过8％的股票。当股票价格仍然低于原始价格时，它还会寻求零或多天。然后，它确定股票价格上涨何时等于或超过其初始值。因为知道模式发生的天数会很有用，所以它包含在这里。<code class="codeph">start_price</code>列是匹配的起始价格， <code class="codeph">end_price</code>列是匹配的结束价格，当价格等于或大于起始价格时。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Ticker3Wave MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES A.tstamp作为start_timestamp，A.price作为start_price，B.price作为drop_price，COUNT（C。*）+ 1作为cnt_days，D.tstamp作为end_timestamp，D。价格作为end_price匹配在匹配后的最后一行比赛最后一行模式（ABC * D）定义B为（B.price  -  A.price）/A.price &lt;-0.08，C为C.price &lt;A.price，D如D.price&gt; = A.price）;符号START_TIM START_PRICE DROP_PRICE CNT_DAYS END_TIMES END_PRICE ---------- --------- ----------- ---------- --- ----- --------- ---------- ACME 01-APR-11 1000 775 11 13-APR-11 1100 ACME 14-APR-11 800 550 1 16- APR-11 800</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGJACI">
                        <p class="titleinexample">例21-11在交易历史中查找V和U形状</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGJACI">例21-11</a>显示了在定义模式时考虑所有可能的数据行为的重要性。表<code class="codeph">TickerVU</code>就像第一个示例的表<code class="codeph">Ticker</code> ，除了它在4月16日和17日的第三个底部的低点连续两个等价天。这种平底价格下降称为U形。<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">示例21-1</a>的原始示例是否可以识别修改后的数据很像V形，并在其输出中包含U形？不，查询需要如图所示进行修改。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE TickerVU（SYMBOL VARCHAR2（10），tstamp DATE，PRICE NUMBER）;插入TickerVU值（'ACME'，'01 -Apr-11'，12）;插入TickerVU值（'ACME'，'02 -Apr-11'，17）;插入TickerVU值（'ACME'，'03 -Apr-11'，19）;插入TickerVU值（'ACME'，'04 -Apr-11'，21）;插入TickerVU值（'ACME'，'05 -Apr-11'，25）;插入TickerVU值（'ACME'，'06 -Apr-11'，12）;插入TickerVU值（'ACME'，'07 -Apr-11'，15）;插入TickerVU值（'ACME'，'08 -Apr-11'，20）;插入TickerVU值（'ACME'，'09 -Apr-11'，24）;插入TickerVU值（'ACME'，'10 -Apr-11'，25）;插入TickerVU值（'ACME'，'11 -Apr-11'，19）;插入TickerVU值（'ACME'，'12 -Apr-11'，15）;插入TickerVU值（'ACME'，'13 -Apr-11'，25）;插入TickerVU值（'ACME'，'14 -Apr-11'，25）;插入TickerVU值（'ACME'，'15 -Apr-11'，14）;插入TickerVU值（'ACME'，'16 -Apr-11'，12）;插入TickerVU值（'ACME'，'17 -Apr-11'，12）;插入TickerVU值（'ACME'，'18 -Apr-11'，24）;插入TickerVU值（'ACME'，'19 -Apr-11'，23）;插入TickerVU值（'ACME'，'20 -Apr-11'，22）;</pre><p>如果您运行<a href="sql-pattern-matching-data-warehouses.html#GUID-E088DB07-41E8-4103-BEAE-7EC1448C5D69__CACHHJJG">示例21-1的</a>原始查询，修改为使用此表名，会发生什么？
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TickerVU MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES STRT.tstamp AS start_tstamp，DOWN.tstamp AS bottom_tstamp，UP.tstamp AS end_tstamp在匹配跳到最后一个模式（STRT DOWN + UP +）之后匹配一行，定义为DOWN DOWN DOWN .price &lt;PREV（DOWN.price），UP AS UP.price&gt; PREV（UP.price））MR ORDER BY MR.symbol，MR.start_tstamp; SYMBOL START_TST BOTTOM_TS END_TSTAM ---------- --------- --------- --------- ACME 05-APR-11 06-APR -11 10-APR-11 ACME 10-APR-11 12-APR-11 13-APR-11</pre><p>查询只显示两行，而不是显示三行输出（每个价格下降一行）。之所以发生这种情况是因为没有定义变量来处理价格下跌底部的平坦数据。现在，使用此查询的修改版本，在<code class="codeph">DEFINE</code>子句中为平面数据添加变量，并在<code class="codeph">PATTERN</code>子句中使用该变量。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TickerVU MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES STRT.tstamp AS start_tstamp，DOWN.tstamp AS bottom_tstamp，UP.tstamp AS end_tstamp在匹配跳到最后一个模式（STRT DOWN + FLAT * UP +）之后匹配一行定义DOWN AS DOWN.price &lt;PREV（DOWN.price），FLAT AS FLAT.price = PREV（FLAT.price），UP AS UP.price&gt; PREV（UP.price））MR ORDER BY MR.symbol，MR.start_tstamp; SYMBOL START_TST BOTTOM_TS END_TSTAM ---------- --------- --------- --------- ACME 05-APR-11 06-APR -11 10-APR-11 ACME 10-APR-11 12-APR-11 13-APR-11 ACME 14-APR-11 16-APR-11 18-APR-11</pre><p>现在，您将获得包含数据中所有三个价格下跌的输出。这里的教训是考虑数据序列中所有可能的变化，并根据需要在<code class="codeph">PATTERN</code> ， <code class="codeph">DEFINE</code>和<code class="codeph">MEASURES</code>子句中包含这些可能性。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">
                        <p class="titleinexample">例21-12查找Elliott Wave模式：Inverted-V的多个实例</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">例21-12</a>显示了一类股票价格模式的简单版本，称为Elliott Wave，它具有多个倒V形的连续模式。在这种特殊情况下，模式表达式搜索1天或更多天，然后向下搜索1天或更多天，并且此序列必须连续出现5次且没有间隙。也就是说，模式看起来类似于：/ \ / \ / \ / \ / \。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_ELLIOTT。* FROM Ticker3Wave MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES COUNT（*）as CNT，COUNT（P. *）AS CNT_P，COUNT（Q. *）AS CNT_Q，COUNT（R. *）AS CNT_R，COUNT （S. *）AS CNT_S，COUNT（T. *）AS CNT_T，COUNT（U. *）AS CNT_U，COUNT（V. *）AS CNT_V，COUNT（W. *）AS CNT_W，COUNT（X. *） AS CNT_X，COUNT（Y。*）AS CNT_Y，COUNT（Z. *）AS CNT_Z，CLASSIFIER（）AS CLS，MATCH_NUMBER（）作为MNO在匹配跳到最后Z模式之后的所有行（P Q + R + S + T + U + V + W + X + Y + Z +）DEFINE Q AS Q.price&gt; PREV（Q.price），R AS R.price &lt;PREV（R.price），S AS S.price&gt; PREV（S.price），T AS T.价格&lt;PREV（T.price），U AS U.price&gt; PREV（U.price），V AS V.price &lt;PREV（V.price），W AS W.price&gt; PREV（W.price），X AS X.price &lt;PREV（X.price），Y AS Y.price&gt; PREV（Y.price），Z AS Z.price &lt;PREV（Z.price））MR_ELLIOTT ORDER BY符号，tstamp;</pre><pre class="oac_no_warn" dir="ltr">SYMB TSTAMP CNT CNT_P CNT_Q CNT_R CNT_S CNT_T CNT_U CNT_V CNT_W CNT_X CNT_Y CNT_Z CLS MNO PRICE ---- --------- ---- ----- ----- -----  - ---- ----- ----- ----- ----- ----- ----- ----- --- --- ----- ACME 02-APR-11 1 1 0 0 0 0 0 0 0 0 0 0 P 1 775 ACME 03-APR-11 2 1 1 0 0 0 0 0 0 0 0 0 Q 1 900 ACME 04-APR-11 3 1 1 1 0 0 0 0 0 0 0 0 R 1 775 ACME 05-APR-11 4 1 1 1 1 0 0 0 0 0 0 0 S 1 900 ACME 06-APR-11 5 1 1 1 1 1 0 0 0 0 0 0 T 1 775 ACME 07-APR-11 6 1 1 1 1 1 0 0 0 0 0 U 1 900 ACME 08-APR-11 7 1 1 1 1 1 1 0 0 0 0 V 1 775 ACME 09- APR-11 8 1 1 1 1 1 1 1 0 0 0 W 1 800 ACME 10-APR-11 9 1 1 1 1 1 1 1 1 0 0 X 1 550 ACME 11-APR-11 10 1 1 1 1 1 1 1 1 1 1 0 Y 1 900 ACME 12-APR-11 11 1 1 1 1 1 1 1 1 1 1 Z 1 800 11行选择。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJEHCH">
                        <p class="titleinexample">例21-13查找Elliott波并指定一系列可接受的行计数</p>
                        <p>与<a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACGCEDD">例21-12</a>类似， <a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACJEHCH">例21-13</a>指定了倒Vs的Elliott Wave。但是，在这种情况下，正则表达式用于为每个模式变量指定要匹配的连续行数，并将其指定为范围。使用语法<code class="codeph">"{3,4}"</code>设置每个模式变量以寻找三个或四个连续匹配。输出显示模式的一个完全匹配的所有行，并让您准确查看每个模式变量的开始和结束时间。注意，变量<code class="codeph">W</code>和<code class="codeph">X</code>每个都有四行匹配，而变量<code class="codeph">Y</code>和<code class="codeph">Z</code>每个只有三行匹配。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE tickerwavemulti（符号VARCHAR2（10），tstamp DATE，价格NUMBER）; INSERT INTO tickerwavemulti VALUES（'ACME'，'01-May-10'，36.25）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'01-May-10'，177.85）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'01-May-10'，27.18）; INSERT INTO tickerwavemulti VALUES（'ACME'，'02-May-10'，36.47）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'02-May-10'，177.25）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'02-May-10'，27.41）; INSERT INTO tickerwavemulti VALUES（'ACME'，'03-May-10'，36.36）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'03-May-10'，176.16）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'03-May-10'，27.43）; INSERT INTO tickerwavemulti VALUES（'ACME'，'04-May-10'，36.25）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'04-May-10'，176.28）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'04-May-10'，27.56）; INSERT INTO tickerwavemulti VALUES（'ACME'，'05-May-10'，36.36）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'05-May-10'，177.72）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'05-May-10'，27.31）; INSERT INTO tickerwavemulti VALUES（'ACME'，'06-May-10'，36.70）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'06-May-10'，178.36）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'06-May-10'，27.23）; INSERT INTO tickerwavemulti VALUES（'ACME'，'07-May-10'，36.50）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'07-May-10'，178.93）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'07-May-10'，27.08）; INSERT INTO tickerwavemulti VALUES（'ACME'，'08-May-10'，36.66）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'08-May-10'，178.18）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'08-May-10'，26.90）; INSERT INTO tickerwavemulti VALUES（'ACME'，'09-May-10'，36.98）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'09-May-10'，179.15）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'09-May-10'，26.73）; INSERT INTO tickerwavemulti VALUES（'ACME'，'10-May-10'，37.08）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'10-May-10'，180.39）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'10-May-10'，26.86）; INSERT INTO tickerwavemulti VALUES（'ACME'，'11-May-10'，37.43）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'11-May-10'，181.44）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'11-May-10'，26.78）; INSERT INTO tickerwavemulti VALUES（'ACME'，'12-May-10'，37.68）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'12-May-10'，183.11）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'12-May-10'，26.59）; INSERT INTO tickerwavemulti VALUES（'ACME'，'13-May-10'，37.66）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'13-May-10'，181.50）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'13-May-10'，26.39）; INSERT INTO tickerwavemulti VALUES（'ACME'，'14-May-10'，37.32）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'14-May-10'，180.65）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'14-May-10'，26.31）; INSERT INTO tickerwavemulti VALUES（'ACME'，'15-May-10'，37.16）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'15-May-10'，179.51）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'15-May-10'，26.53）; INSERT INTO tickerwavemulti VALUES（'ACME'，'16-May-10'，36.98）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'16-May-10'，180.00）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'16-May-10'，26.76）; INSERT INTO tickerwavemulti VALUES（'ACME'，'17-May-10'，37.19）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'17-May-10'，179.24）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'17-May-10'，26.63）; INSERT INTO tickerwavemulti VALUES（'ACME'，'18-May-10'，37.45）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'18-May-10'，180.48）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'18-May-10'，26.84）; INSERT INTO tickerwavemulti VALUES（'ACME'，'19-May-10'，37.79）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'19-May-10'，181.21）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'19-May-10'，26.90）; INSERT INTO tickerwavemulti VALUES（'ACME'，'20-May-10'，37.49）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'20-May-10'，179.79）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'20-May-10'，27.06）; INSERT INTO tickerwavemulti VALUES（'ACME'，'21-May-10'，37.30）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'21-May-10'，181.19）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'21-May-10'，27.17）; INSERT INTO tickerwavemulti VALUES（'ACME'，'22-May-10'，37.08）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'22-May-10'，179.88）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'22-May-10'，26.95）; INSERT INTO tickerwavemulti VALUES（'ACME'，'23-May-10'，37.34）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'23-May-10'，181.21）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'23-May-10'，26.71）; INSERT INTO tickerwavemulti VALUES（'ACME'，'24-May-10'，37.54）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'24-May-10'，181.94）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'24-May-10'，26.96）; INSERT INTO tickerwavemulti VALUES（'ACME'，'25-May-10'，37.69）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'25-May-10'，180.88）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'25-May-10'，26.72）; INSERT INTO tickerwavemulti VALUES（'ACME'，'26-May-10'，37.60）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'26 -May-10'，180.72）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'26-May-10'，26.47）; INSERT INTO tickerwavemulti VALUES（'ACME'，'27-May-10'，37.93）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'27-May-10'，181.54）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'27-May-10'，26.73）; INSERT INTO tickerwavemulti VALUES（'ACME'，'28-May-10'，38.17）; INSERT INTO tickerwavemulti VALUES（'BLUE'，'28-May-10'，182.93）; INSERT INTO tickerwavemulti VALUES（'EDGY'，'28-May-10'，26.89）; SELECT MR_EW。* FROM tickerwavemulti MATCH_RECOGNIZE（按符号分区ORDER由tstamp MEASURES V.tstamp AS START_T，Z.tstamp AS END_T，COUNT（V.price）AS CNT_V，COUNT（W.price）AS UP__W，COUNT（X.price） ）AS DWN_X，COUNT（Y.price）AS UP__Y，COUNT（Z.price）AS DWN_Z，MATCH_NUMBER（）在匹配跳到最后Z模式（VW {3,4} X {3,4}之后，每个匹配都是MNO } Y {3,4} Z {3,4}）DEFINE W AS W.price&gt; PREV（W.price），X AS X.price &lt;PREV（X.price），Y AS Y.price&gt; PREV（Y 。）），Z AS Z.price &lt;PREV（Z.price））MR_EW ORDER BY符号，tstamp; SYMB TSTAMP START_T END_T CNT_V UP__W DWN_X UP__Y DWN_Z MNO价格---- --------- --------- --------- ----- --- -  ----- ----- ----- ----- ------- ACME 08-MAY-10 08-MAY-10 1 0 0 0 0 1 36.66 ACME 09- 5月10日08-MAY-10 1 1 0 0 0 1 36.98 ACME 10-MAY-10 08-MAY-10 1 2 0 0 0 1 37.08 ACME 11-MAY-10 08-MAY-10 1 3 0 0 0 1 37.43 ACME 12-MAY-10 08-MAY-10 1 4 0 0 0 1 37.68 ACME 13-MAY-10 08-MAY-10 1 4 1 0 0 1 37.66 ACME 14-MAY-10 08-MAY-10 1 4 2 0 0 1 37.32 ACME 15-MAY-10 08-MAY-10 1 4 3 0 0 1 37.16 ACME 16-MAY-10 08-MAY-10 1 4 4 0 0 1 36.98 ACME 17-MAY-10 08-MAY -10 1 4 4 1 0 1 37.19 ACME 18-MAY-10 08-MAY-10 1 4 4 2 0 1 37.45 ACME 19-MAY-10 08-MAY-10 1 4 4 3 0 1 37.79 ACME 20-MAY- 10 08-MAY-10 20-MAY-10 1 4 4 3 1 1 37.49 ACME 21-MAY-10 08-MAY-10 21-MAY-10 1 4 4 3 2 1 37.30 ACME 22-MAY-10 08-MAY -10 22-MAY-10 1 4 4 3 3 1 37.08</pre><pre class="oac_no_warn" dir="ltr">选择了15行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACBDBHA">
                        <p class="titleinexample">例21-14跳到匹配中间以检查重叠匹配</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACBDBHA">例21-14</a>强调了<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code>子句找到重叠匹配的强大功能。它有一个简单的模式，寻找由模式变量<code class="codeph">Q</code> ， <code class="codeph">R</code> ， <code class="codeph">S</code>和<code class="codeph">T</code>组成的W形。对于W的每个分支，行数可以是一个或多个。该匹配还利用了<code class="codeph">AFTER</code> <code class="codeph">MATCH</code> <code class="codeph">SKIP</code> <code class="codeph">TO</code>子句：当找到匹配时，它将仅向前跳到最后的<code class="codeph">R</code>值，即W形的中点。这使查询能够找到W形的匹配，其中W形的后半部分是后续重叠W形的前半部分。在以下输出中，您可以看到匹配一个在4月5日结束，但匹配两个重叠并从4月3日开始。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_W。* FROM Ticker3Wave MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES MATCH_NUMBER（）AS MNO，P.tstamp AS START_T，T.tstamp AS END_T，MAX（P.price）AS TOP_L，MIN（Q.price）AS BOTT1 ，MAX（R.price）AS TOP_M，MIN（S.price）AS BOTT2，MAX（T.price）AS TOP_R在匹配跳过最后R模式后匹配所有行（P Q + R + S + T +）DE QINE Q AS Q.价格&lt;PREV（Q.price），R AS R.price&gt; PREV（R.price），S AS S.price &lt;PREV（S.price），T AS T.price&gt; PREV（T.price））MR_W ORDER BY符号，mno，tstamp; SYMB TSTAMP MNO START_T END_T TOP_L BOTT1 TOP_M BOTT2 TOP_R价格---- --------- ----- --------- --------- --- -  ----- ----- ----- ----- ----- ACME 01-APR-11 1 01-APR-11 1000 1000 ACME 02-APR-11 1 01- APR-11 1000 775 775 ACME 03-APR-11 1 01-APR-11 1000 775 900 900 ACME 04-APR-11 1 01-APR-11 1000 775 900 775 775 ACME 05-APR-11 1 01-APR- 11 05-APR-11 1000 775 900 775 900 900 ACME 03-APR-11 2 03-APR-11 900 900 ACME 04-APR-11 2 03-APR-11 900 775 775 ACME 05-APR-11 2 03- APR-11 900 775 900 900 ACME 06-APR-11 2 03-APR-11 900 775 900 775 775 ACME 07-APR-11 2 03-APR-11 07-APR-11 900 775 900 775 900 900 ACME 05- APR-11 3 05-APR-11 900 900 ACME 06-APR-11 3 05-APR-11 900 775 775 ACME 07-APR-11 3 05-APR-11 900 775 900 900 ACME 08-APR-11 3 05 -APR-11 900 775 900 775 775 ACME 09-APR-11 3 05-APR-11 09-APR-11 900 775 900 775 800 800 ACME 07-APR-11 4 07-APR-11 900 900 ACME 08-APR -11 4 07-APR-11 900 775 775 ACME 09-APR-11 4 07-APR-11 900 775 800 800 ACME 10-APR-11 4 07-APR-11 900 775 800 550 550 ACME 11-APR- 11 4 07-APR-11 11-APR-11 900 775 800 550 900 900 ACME 09-APR-11 5 09-APR-11 800 800 ACME 10-APR-11 5 09-APR-11 800 550 550 ACME 11- APR-11 5 09-APR-11 800 550 900 900 ACME 12-APR-11 5 09-APR-11 800 550 900 800 800 ACME 13-APR-11 5 09-APR-11 13-APR-11 800 550 900 800 1100 1100 ACME 11-APR-11 6 11-APR-11 900 900 ACME 12-APR-11 6 11-APR-11 900 800 800 ACME 13-APR-11 6 11-APR-11 900 800 1100 1100 ACME 14 -APR-11 6 11-APR-11 900 800 1100 800 800 ACME 15-APR-11 6 11-APR-11 900 800 1100 550 550 ACME 16-APR-11 6 11-APR-11 16-APR-11 900 800 1100 550 800 800 ACME 17-APR-11 6 11-APR-11 17-APR-11 900 800 1100 550 875 875 ACME 18-APR-11 6 11-APR-11 18-APR-11 900 800 1100 550 950选择950 33行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACEHIDF">
                        <p class="titleinexample">示例21-15查找在指定时间间隔内发生的大型事务</p>
                        <p>在<a href="sql-pattern-matching-data-warehouses.html#GUID-2C252AA0-EE82-4F70-9E59-A51B403E07E4__CACEHIDF">例21-15中</a> ，您可以找到交易量很大的股票，即集中期间的大宗交易。在此示例中，大量交易被定义为在一小时内发生的三笔交易，其中每笔交易的交易量超过30,000股。请注意，必须包含模式变量（如<code class="codeph">B</code> ，因此模式可以接受不符合条件的交易。如果没有<code class="codeph">B</code>变量，模式将仅匹配满足条件的三个连续事务的情况。
                        </p>
                        <p>此示例中的查询使用表<code class="codeph">stockT04</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE STOCKT04（符号varchar2（10），tstamp TIMESTAMP，价格NUMBER，卷NUMBER）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.00.00.000000 PM'，35,35000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.05.00.000000 PM'，35,15000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.10.00.000000 PM'，35,5000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.11.00.000000 PM'，35,42000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.16.00.000000 PM'，35,7000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.19.00.000000 PM'，35,5000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.20.00.000000 PM'，35,5000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.33.00.000000 PM'，35,55000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.36.00.000000 PM'，35,15000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.48.00.000000 PM'，35,15000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 12.59.00.000000 PM'，35,15000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 01.09.00.000000 PM'，35,55000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 01.19.00.000000 PM'，35,55000）;插入STOCKT04 VALUES（'ACME'，'01 -Jan-10 01.29.00.000000 PM'，35,15000）; SELECT * FROM stockT04 MATCH_RECOGNIZE（PARTITION BY符号ORDER BY tstamp MEASURES FIRST（A.tstamp）AS in_hour_of_trade，SUM（A.volume）AS sum_of_large_volumes匹配跳过最后一行后的一行比赛（AB * AB * A）DEFINE A AS（（A.volume&gt; 30000）AND（（A.tstamp  -  FIRST（A.tstamp））&lt;'0 01：00：00.00'）），B AS（（B.volume &lt;= 30000）AND（（B .tstamp  -  FIRST（A.tstamp））&lt;'0 01：00：00.00'）））; SYMBOL IN_HOUR_OF_TRADE SUM_OF_LARGE_VOLUMES ------ ----------------------------- ------------ -------- ACME 01-JAN-10 12.00.00.000000 PM 132000选择1行。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9038"></a><a id="DWHSG9039"></a><a id="DWHSG9040"></a><a id="DWHSG9037"></a><div class="props_rev_3"><a id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219" name="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219"></a><h4 id="DWHSG-GUID-C261911B-CDFC-47C8-8692-BA9301C6E219" class="sect4"><span class="enumeration_section">21.6.2</span>模式匹配示例：安全日志分析</h4>
                  <div>
                     <div class="section">
                        <p>本节中的示例涉及发出错误消息和身份验证检查的计算机系统，并将事件存储在系统文件中。要确定是否存在安全问题和其他问题，您需要分析系统文件。此活动也称为日志梳理，因为软件梳理文件以查找关注的项目。请注意，这些示例的源数据未显示，因为它会占用太多空间。在这些示例中， <code class="codeph">AUTHENLOG</code>表来自日志文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACCHHEA">
                        <p class="titleinexample">例21-16四个或更多连续相同的消息</p>
                        <p>此示例中的查询从一组三个可能的<code class="codeph">'errtype'</code>值中寻找四个或更多连续相同消息的出现： <code class="codeph">error</code> ， <code class="codeph">notice</code>和<code class="codeph">warn</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT MR_SEC.ERRTYPE，MR_SEC.MNO AS模式，MR_SEC.CNT AS计数，SUBSTR（MR_SEC.MSG_W，1,30）AS消息，MR_SEC.START_T AS Starting_on，MR_SEC.END_T AS Ending_on FROM AUTHENLOG MATCH_RECOGNIZE（PARTITION BY errtype ORDER BY tstamp MEASURES S.tstamp AS START_T，W.tstamp AS END_T，W.message AS MSG_W，COUNT（*）AS CNT，MATCH_NUMBER（）在匹配跳过最后一行模式（SW {3，}）之后，每个匹配的MNO行DEFINE W AS W.message = PREV（W.message））MR_SEC ORDER BY ErrType，Pattern;</pre><pre class="oac_no_warn" dir="ltr">ERRTYP PATTERN COUNT MESSAGE STARTING_ON ENDING_ON ------ ------- ----- ------------------- ------- --------------------- ----------------------------错误1 4脚本未找到或09-JAN-10 12.00.06.000006 PM 09-JAN-10 12.00.15.000015 PM错误2 4文件不存在04-FEB-10 12.00.18.000018 PM 04-FEB-10 12.00.23.000023 PM错误3 4文件不存在06-FEB-10 12.00.25.000025 PM 06-FEB-10 12.00.33.000033 PM错误4 4文件不存在13-FEB-10 12.00.19.000019 PM 14-FEB-10 12.00.07.000007 PM错误5 5文件不存在28-FEB-10 12.00.27.000027 PM 28-FEB-10 12.00.34.000034 PM错误6 4未找到脚本或05-APR-10 12.00.19.000019 PM 05-MAR-10 12.00.23.000023 PM错误7 4文件不存在07-MAR-10 12.00.31.000031 PM 08-MAR-10 12.00.02.000002 PM错误8 4文件不存在14-MAR-10 12.00.19.000019 PM 15-MAR-10 12.00.00.000000 PM错误9 4文件不存在20-MAR-10 12.00.02.000002 PM 20-MAR-10 12.00.06.000006 PM错误10 5文件不存在28-APR-10 12.00.24.000024 P M 28-APR-10 12.00.31.000031 PM错误11 5未找到脚本或01-MAY-10 12.00.15.000015 PM 02-MAY-10 12.00.11.000011 PM错误12 5用户jsmith：authen 02-MAY-10 12.00.54.000054 PM 03-MAY-10 12.00.11.000011 PM错误13 4文件不存在09-MAY-10 12.00.46.000046 PM 10-MAY-10 12.00.01.000001 PM错误14 4文件不存在20-MAY-10 12.00.42.000042 PM 20-MAY-10 12.00.47.000047 PM错误15 4用户jsmith：authen 21-MAY-10 12.00.08.000008 PM 21-MAY-10 12.00.18.000018 PM错误16 4文件不存在24-MAY-10 12.00.07.000007 PM 25-MAY-10 12.00.01.000001 PM错误17 4用户jsmith：authen 12-JUN-10 12.00.00.000000 PM 12-JUN-10 12.00.07.000007 PM错误18 4脚本未找到或12-JUN-10 12.00.18.000018 PM 13-JUN-10 12.00.01.000001 PM错误19 4文件不存在17-JUN-10 12.00.23.000023 PM 17-JUN-10 12.00.30.000030 PM错误20 5文件不存在21-JUN-10 12.00.31.000031 PM 22-JUN-10 12.00.01.000001 PM错误21 4用户jsmith：authen 22-JUN-10 12.00.36.000036 PM 22-JUN-10 12.00.56。 000056 PM错误22 4文件不存在08-JUL-10 12.00.29.000029 PM 08-JUL-10 12.00.32.000032 PM错误23 6用户jsmith：authen 10-JUL-10 12.00.43.000043 PM 11-JUL-10 12.00。 06.000006 PM错误24 4文件不存在12-JUL-10 12.00.09.000009 PM 12-JUL-10 12.00.22.000022 PM错误25 4文件不存在26-JUL-10 12.00.18.000018 PM 27-JUL-10 12.00。 04.000004 PM错误26 4文件不存在03-AUG-10 12.00.02.000002 PM 03-AUG-10 12.00.11.000011 PM错误27 4文件不存在23-AUG-10 12.00.04.000004 PM 23-AUG-10 12.00。 18.000018 PM错误28 5文件不存在24-AUG-10 12.00.09.000009 PM 26-AUG-10 12.00.00.000000 PM错误29 4未找到脚本或09-SEP-10 12.00.03.000003 PM 09-SEP-10 12.00。 09.000009 PM错误30 4未找到脚本或11-SEP-10 12.00.22.000022 PM 11-SEP-10 12.00.31.000031 PM错误31 4未找到脚本或23-SEP-10 12.00.09.000009 PM 23-SEP-10 12.00。 16.000016 PM错误32 5未找到脚本或17-OCT-10 12.00.02.000002 PM 18-OCT-10 12.00.09.000009 PM错误33 4文件不存在20-OCT-10 12.00.35.000035 PM 21-OCT-10 12.00.00.000000 PM错误34 5文件不存在21-OCT-10 12.00.16.000016 PM 21-OCT-10 12.00.35.000035 PM错误35 4文件不存在26-OCT-10 12.00.25.000025 PM 26-OCT-10 12.00.35.000035 PM错误36 4用户jsmith：authen 26-OCT-10 12.00.43.000043 PM 26-OCT-10 12.00.49.000049 PM错误37 4用户jsmith：authen 01-NOV-10 12.00.35.000035 PM 01-NOV-10 12.00.39.000039 PM错误38 4文件不存在09-NOV-10 12.00.46.000046 PM 10-NOV-10 12.00.09.000009 PM错误39 4用户jsmith：authen 11-NOV-10 12.00.14.000014 PM 11-NOV-10 12.00.30.000030 PM错误40 4用户jsmith：authen 22-NOV-10 12.00.46.000046 PM 23-NOV-10 12.00.07.000007 PM错误41 4脚本未找到或03-DEC-10 12.00.14.000014 PM 03-DEC-10 12.00.27.000027 PM错误42 5文件不存在07-DEC-10 12.00.02.000002 PM 07-DEC-10 12.00.37.000037 PM错误43 4用户jsmith：authen 11-DEC-10 12.00.06.000006 PM 11-DEC-10 12.00.11.000011 PM错误44 4用户jsmith：authen 1 9-DEC-10 12.00.26.000026 PM 20-DEC-10 12.00.04.000004 PM错误45 4用户jsmith：authen 25-DEC-10 12.00.11.000011 PM 25-DEC-10 12.00.17.000017 PM错误46 4文件不存在04-JAN-11 12.00.09.000009 PM 04-JAN-11 12.00.19.000019 PM错误47 4用户jsmith：authen 10-JAN-11 12.00.23.000023 PM 11-JAN-11 12.00.03.000003 PM错误48 4文件不存在11-JAN-11 12.00.14.000014 PM 11-JAN-11 12.00.24.000024 PM notice 1 4 Child 3228：Release 08-JAN-10 12.00.38.000038 PM 09-JAN-10 12.00.02.000002 PM notice 2 4 Child 3228：Release 16-JAN-10 12.00.10.000010 PM 17-JAN-10 12.00.13.000013 PM notice 3 4 Child 1740：Startin 28-JAN-10 12.00.17.000017 PM 28-JAN-10 12.00.22.000022 PM notice 4 4 Child 1740：Child p 08-MAR-10 12.00.37.000037 PM 08-MAR-10 12.00.40.000040 PM notice 5 4 Child 3228：All wor 19-APR-10 12.00.10.000010 PM 19-APR-10 12.00.15.000015 PM notice 6 4 Child 1740 ：获取02-MAY-10 12.00.38.000038 PM 02-MAY-10 12.00.46.000046 PM notice 7 4 Child 1740：09-MAY-10 12.00.03.00 0003 PM 09-MAY-10 12.00.08.000008 PM notice 8 4 Child 3228：Child pr 18-MAY-10 12.00.38.000038 PM 18-MAY-10 12.00.45.000045 PM notice 9 4 Child 3228：All work 25-JUL-10 12.00.04.000004 PM 25-JUL-10 12.00.09.000009 PM notice 10 4 Child 3228：All work 24-AUG-10 12.00.11.000011 PM 24-AUG-10 12.00.18.000018 PM notice 11 4 Child 1740：Starting 19-SEP- 10 12.00.05.000005 PM 19-SEP-10 12.00.15.000015 PM通知12 4儿童1740：获得06-OCT-10 12.00.07.000007 PM 06-OCT-10 12.00.13.000013 PM通知13 4儿童1740：从09-JAN-开始11 12.00.12.000012 PM 09-JAN-11 12.00.18.000018 PM警告1 3448 ScriptAlias dire 01-JAN-10 12.00.00.000000 PM 17-JAN-11 12.00.18.000018 PM 62行选择。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACBDDGJ">
                        <p class="titleinexample">例21-17四个或更多连续的身份验证失败</p>
                        <p>在此示例中，无论IP发起地址如何，您都在寻找四个或更多连续的身份验证失败。输出显示两个匹配，第一个有五行，最后一个有四行。</p><pre class="oac_no_warn" dir="ltr">选择MR_SEC2。ERRTYPE AS Authen，MR_SEC2。MNO AS模式，MR_SEC2。CNT AS Count，MR_SEC2。IPADDR AS On_IP，MR_SEC2。TSTAMP AS发生_来自AUTHENLOG MATCH_RECOGNIZE（按类型划分排序按tstamp测量COUNT（*）作为CNT，MATCH_NUMBER（）作为MNO所有行数匹配后跳到最后W模式（SW {3，}）定义为S.message LIKE'％authenticat％'，W AS W.message = PREV（W.message））MR_SEC2 ORDER BY Authen，Pattern，Count;</pre><pre class="oac_no_warn" dir="ltr">AUTHEN PATTERN COUNT ON_IP OCCURRING_ON ------ ------- --------- ------------ ----------- -----------------错误1 1 10.111.112.3 02-MAY-10 12.00.54.000054 PM错误1 2 10.111.112.6 03-MAY-10 12.00.07.000007 PM错误1 3 10.111.112.6 03-MAY-10 12.00.08.000008 PM错误1 4 10.111.112.6 03-MAY-10 12.00.09.000009 PM错误1 5 10.111.112.6 03-MAY-10 12.00.11.000011 PM错误2 1 10.111.112.5 21- MAY-10 12.00.08.000008 PM error 2 2 10.111.112.6 21-MAY-10 12.00.16.000016 PM error 2 3 10.111.112.4 21-MAY-10 12.00.17.000017 PM error 2 4 10.111.112.6 21-MAY-10 12.00。 18.000018 PM错误3 1 10.111.112.5 12-JUN-10 12.00.00.000000 PM错误3 2 10.111.112.4 12-JUN-10 12.00.04.000004 PM错误3 3 10.111.112.3 12-JUN-10 12.00.06.000006 PM错误3 4 10.111.112.3 12-JUN-10 12.00.07.000007 PM错误4 1 10.111.112.5 22-JUN-10 12.00.36.000036 PM错误4 2 10.111.112.5 22-JUN-10 12.00.50.000050 PM错误4 3 10.111.112.5 22- JUN-10 12.00.53.000053 PM错误4 4 10.111.112.6 22-JUN-10 12.00.56.000056 PM错误5 1 10.111.112.4 10-JUL-10 12.00.43.000043 PM误差5 2 10.111.112.6 10-JUL-10 12.00.48.000048 PM误差5 3 10.111.112.6 10-JUL-10 12.00.51.000051 PM误差5 4 10.111.112.3 11- JUL-10 12.00.00.000000 PM误差5 5 10.111.112.5 11-JUL-10 12.00.04.000004 PM误差5 6 10.111.112.3 11-JUL-10 12.00.06.000006 PM误差6 1 10.111.112.4 26-OCT-10 12.00。 43.000043 PM错误6 2 10.111.112.4 26-OCT-10 12.00.47.000047 PM错误6 3 10.111.112.4 26-OCT-10 12.00.48.000048 PM错误6 4 10.111.112.5 26-OCT-10 12.00.49.000049 PM错误7 1 10.111.112.3 01-NOV-10 12.00.35.000035 PM误差7 2 10.111.112.5 01-NOV-10 12.00.37.000037 PM误差7 3 10.111.112.5 01-NOV-10 12.00.38.000038 PM误差7 4 10.111.112.3 01- NOV-10 12.00.39.000039 PM误差8 1 10.111.112.6 11-NOV-10 12.00.14.000014 PM误差8 2 10.111.112.5 11-NOV-10 12.00.20.000020 PM误差8 3 10.111.112.6 11-NOV-10 12.00。 24.000024 PM错误8 4 10.111.112.3 11-NOV-10 12.00.30.000030 PM错误9 1 10.111.112.5 22-NOV-10 12.00.46.000046 PM错误9 2 10.111.112。 5 22-NOV-10 12.00.51.000051 PM误差9 3 10.111.112.3 23-NOV-10 12.00.06.000006 PM误差9 4 10.111.112.3 23-NOV-10 12.00.07.000007 PM误差10 1 10.111.112.5 11-DEC- 10 12.00.06.000006 PM错误10 2 10.111.112.4 11-DEC-10 12.00.07.000007 PM错误10 3 10.111.112.5 11-DEC-10 12.00.08.000008 PM错误10 4 10.111.112.6 11-DEC-10 12.00.11.000011 PM错误11 1 10.111.112.5 19-DEC-10 12.00.26.000026 PM错误11 2 10.111.112.5 20-DEC-10 12.00.01.000001 PM错误11 3 10.111.112.4 20-DEC-10 12.00.03.000003 PM错误11 4 10.111。 112.3 20-DEC-10 12.00.04.000004 PM错误12 1 10.111.112.4 25-DEC-10 12.00.11.000011 PM错误12 2 10.111.112.4 25-DEC-10 12.00.12.000012 PM错误12 3 10.111.112.4 25-DEC- 10 12.00.16.000016 PM错误12 4 10.111.112.3 25-DEC-10 12.00.17.000017 PM错误13 1 10.111.112.6 10-JAN-11 12.00.23.000023 PM错误13 2 10.111.112.6 11-JAN-11 12.00.00.000000 PM错误13 3 10.111.112.3 11-JAN-11 12.00.02.000002 PM错误13 4 10.111.112.4 11-JAN-11 12.00.03.000003 PM选择了55行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACDABEB">
                        <p class="titleinexample">示例21-18来自相同IP地址的身份验证失败</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACDABEB">例21-18中</a>的查询类似于<a href="sql-pattern-matching-data-warehouses.html#GUID-C261911B-CDFC-47C8-8692-BA9301C6E219__CACBDDGJ">例21-17</a> ，但是它从连续三次或更多次发生的同一IP发起地址中发现了认证失败。
                        </p><pre class="oac_no_warn" dir="ltr">选择MR_S3。MNO AS模式，MR_S3。CNT AS Count，MR_S3。ERRTYPE AS类型，MR_S3。IPADDR AS On_IP_addr，MR_S3。START_T作为Starting_on，MR_S3。END_T AS Ending_on来自AUTHENLOG MATCH_RECOGNIZE（按类型划分错误按顺序测量S.tstamp AS START_T，W.tstamp AS END_T，W.ipaddr AS IPADDR，COUNT（*）AS CNT，MATCH_NUMBER（）作为比赛后的每个匹配的MNO一行跳到最后的W模式（SW {2，}）定义为S.message LIKE'％authenticat％'，W AS W.message = PREV（W.message）AND W.ipaddr = PREV（W.ipaddr））MR_S3 ORDER BY Type，Pattern;</pre><pre class="oac_no_warn" dir="ltr">模式计数类型ON_IP_ADDR STARTING_ON ENDING_ON ------- ----- ----- ------------ --------------- ------------- ---------------------------- 1 4错误10.111.112.6 03-MAY -10 12.00.07.000007 PM 03-MAY-10 12.00.11.000011 PM 2 3错误10.111.112.5 22-JUN-10 12.00.36.000036 PM 22-JUN-10 12.00.53.000053 PM 3 3错误10.111.112.4 27-JUN-10 12.00.03.000003 PM 27-JUN-10 12.00.08.000008 PM 4 3错误10.111.112.6 19-JUL-10 12.00.15.000015 PM 19-JUL-10 12.00.17.000017 PM 5 3错误10.111.112.4 26-OCT-10 12.00。 43.000043 PM 26-OCT-10 12.00.48.000048 PM 6 3错误10.111.112.4 25-DEC-10 12.00.11.000011 PM 25-DEC-10 12.00.16.000016 PM 7 3错误10.111.112.5 12-JAN-11 12.00.01.000001 PM 12-JAN-11 12.00.08.000008 PM选择了7行。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9198"></a><a id="DWHSG9200"></a><a id="DWHSG9202"></a><a id="DWHSG9197"></a><div class="props_rev_3"><a id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8" name="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8"></a><h4 id="DWHSG-GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8" class="sect4"><span class="enumeration_section">21.6.3</span>模式匹配示例：会话化</h4>
                  <div>
                     <div class="section">
                        <p>会话化是定义用户活动的不同会话的过程，通常涉及单个会话中的多个事件。模式匹配可以轻松表达会话的查询。例如，您可能想知道在典型会话期间您的网站访问者有多少页面。如果您是通信提供商，您可能想知道两个用户之间的电话会话的特征，其中会话涉及断开的连接和用户重拨。企业可以从了解用户会话行为中获得重要价值，因为它可以帮助企业定义服务产品和增强功能，定价，营销等。</p>
                        <p>以下示例包括两个与网站点击流相关的会话化示例，后面是涉及电话呼叫的示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">
                        <p class="titleinexample">例21-19点击流数据的简单会话</p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">例21-19</a>是点击流数据分析的会话化的简单说明。对于一组行，目标是检测会话，为每个会话分配会话ID，并显示每个输入行及其会话ID。以下数据来自跟踪所有页面请求的Web服务器系统日志。您从一组行开始，其中每一行都是用户请求页面的事件。在这个简单的示例中，数据包括分区键，即用户ID，以及指示用户何时请求页面的时间戳。Web系统日志显示用户请求给定页面的时间，但没有指示用户何时停止查看该页面。
                        </p>
                        <p>在<a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">示例21-19中</a> ，会话被定义为具有相同分区键（ <code class="codeph">User_ID</code> ）的一个或多个时间排序行的序列，其中时间戳之间的时间间隔小于指定阈值。在这种情况下，阈值是十个时间单位。如果行的时间戳大于十个单位，则认为它们位于不同的会话中。请注意，此处使用的10单位阈值是任意数字：每个真实案例都需要分析师的判断来确定最合适的阈值时间间隔。从历史上看，30分钟的差距是分离网站访问会话的常用阈值。
                        </p>
                        <p>首先创建一个点击流事件表。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE事件（Time_Stamp NUMBER，User_ID VARCHAR2（10））;</pre><p>接下来插入数据。下面的插入语句已经过排序和间隔，以方便您阅读，以便您可以看到分区及其中的会话。在现实生活中，事件将按时间戳顺序到达，并且不同用户会话的行将混合在一起。</p><pre class="oac_no_warn" dir="ltr">INSERT INTO事件（Time_Stamp，User_ID）VALUES（1，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（11，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（23，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（34，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（44，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（53，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（63，'Mary'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（3，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（13，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（23，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（33，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（43，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（54，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（63，'Richard'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（2，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（12，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（22，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（32，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（43，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（47，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（48，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（59，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（60，'Sam'）; INSERT INTO事件（Time_Stamp，User_ID）VALUES（68，'Sam'）;</pre><p>下面的行模式匹配查询将显示每个输入行及其<code class="codeph">Session_ID</code> 。如上所述，如果事件相隔十个或更少的时间单位，则认为事件是同一会话的一部分。该会话阈值在模式变量的<code class="codeph">DEFINE</code>子句中表示。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT time_stamp，user_id，session_id FROM Events MATCH_RECOGNIZE（PARTITION BY User_ID ORDER BY Time_Stamp MEASURES match_number（）AS session_id ALL ROWS PER MATCH PATTERN（bs *）DEFINE AS（s。Time_Stamp  -  prev（Time_Stamp）&lt;= 10））ORDER BY user_id，time_stamp;</pre><p>输出将是：</p><pre class="oac_no_warn" dir="ltr">TIME_STAMP USER_ID SESSION_ID ---------- ---------- ---------- 1 Mary 1 11 Mary 1 23 Mary 2 34 Mary 3 44 Mary 3 53 Mary 3 63 Mary 3 3 Richard 1 13 Richard 1 23 Richard 1 33 Richard 1 43 Richard 1 54 Richard 2 63 Richard 2 2 Sam 1 12 Sam 1 22 Sam 1 32 Sam 1 43 Sam 2 47 Sam 2 48 Sam 2 59 Sam 3 60 Sam 3 68 Sam 3选择24行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACEGADH">
                        <p class="titleinexample">例21-20带聚合的简单会话</p>
                        <p>将会话编号分配给详细级别的行，如<a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">示例21-19中所示，</a>只是开始分析过程。会话数据的业务价值仅在按会话汇总后才会出现。
                        </p>
                        <p>此示例聚合数据以使每个会话为这一列提供一行： <code class="codeph">Session_ID</code> ， <code class="codeph">User_ID</code> ，每个会话的聚合事件数和总会话持续时间。通过此输出，您可以轻松查看每个用户每次会话的点击次数以及每次会话持续的时间。反过来，来自此查询的数据可用于驱动许多其他分析，例如最大，最小和平均会话持续时间。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT session_id，user_id，start_time，no_of_events，duration FROM事件MATCH_RECOGNIZE（PARTITION BY User_ID ORDER BY Time_Stamp MEASURES MATCH_NUMBER（）session_id，COUNT（*）AS no_of_events，FIRST（time_stamp）start_time，LAST（time_stamp） -  FIRST（time_stamp）duration PATTERN （bs *）DEFINE的AS（s。Time_Stamp  -  PREV（Time_Stamp）&lt;= 10））ORDER BY user_id，session_id;</pre><p>输出将是：</p><pre class="oac_no_warn" dir="ltr">SESSION_ID USER_ID START_TIME NO_OF_EVENTS DURATION ---------- ---------- ---------- ------------ --- ------- 1 Mary 1 2 10 2 Mary 23 1 0 3 Mary 34 4 29 1 Richard 3 5 40 2 Richard 54 2 9 1 Sam 2 4 30 2 Sam 43 3 5 3 Sam 59 3 9 8行入选。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACBHIHI">
                        <p class="titleinexample">示例21-21具有丢弃连接的电话呼叫的会话</p>
                        <p>在具有点击流数据的示例<a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACIGEDH">示例21-19</a>和<a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACEGADH">示例21-20</a>中，源数据中没有明确的终点来指示查看页面的结束时间。即使用户活动有明确的终点，终点也可能不表示用户想要结束会话。考虑使用移动电话服务的人，其电话连接被丢弃：通常，用户将重拨并继续通话。在这种情况下，涉及同一对电话号码的多个电话呼叫应被视为单个电话会话的一部分。
                        </p>
                        <p><a href="sql-pattern-matching-data-warehouses.html#GUID-8E2505C1-0C8F-40D5-8222-37C9E22B85A8__CACBHIHI">例21-21</a>说明了电话呼叫会话。它使用呼叫详细记录数据作为会话的基础，其中呼叫数据记录行包括<code class="codeph">Start_Time</code> ， <code class="codeph">End_Time</code> ， <code class="codeph">Caller_ID</code> ， <code class="codeph">Callee_ID</code> 。以下查询执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过<code class="codeph">caller_id</code>和<code class="codeph">callee_id</code>对数据进行分区。
                              </p>
                           </li>
                           <li>
                              <p>如果后续呼叫之间的间隔在60秒的阈值内，则查找将呼叫者到被呼叫者的呼叫分组到会话中的会话。该阈值在模式变量<code class="codeph">B</code>的<code class="codeph">DEFINE</code>子句中指定。</p>
                           </li>
                           <li>
                              <p>每个会话的返回值（请参阅<code class="codeph">MEASURES</code>子句）：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">session_id</code> ，调用者和被调用者</p>
                                 </li>
                                 <li>
                                    <p>在会话中重新启动了多少次呼叫</p>
                                 </li>
                                 <li>
                                    <p>总有效通话时长（电话连接时的总会话时间）</p>
                                 </li>
                                 <li>
                                    <p>总中断持续时间（电话断开时会话期间的总时间）</p>
                                 </li>
                              </ul>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">SELECT Caller，Callee，Start_Time，Effective_Call_Duration，（End_Time  -  Start_Time） -  Effective_Call_Duration AS Total_Interruption_Duration，No_Of_Restarts，Session_ID FROM my_cdr MATCH_RECOGNIZE（呼叫者分配，被叫者ORDER BY Start_Time MEASURES A.Start_Time AS Start_Time，End_Time AS End_Time，SUM（End_Time  -  Start_Time ）AS Effective_Call_Duration，COUNT（B. *）AS No_Of_Restarts，MATCH_NUMBER（）AS Session_ID PATTERN（AB *）DEFINE B AS B.Start_Time  -  PREV（B.end_Time）&lt;60）;</pre><p>因为先前的查询需要大量数据才有意义，并且这会占用大量空间，所以此处不包含<code class="codeph">INSERT</code>语句。但是，以下是示例输出。
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; desc my_cdr名称是否为空？输入-------------- ---------- ---------- CALLER NOT NULL NUMBER（38）CALLEE NOT NULL NUMBER（38）START_TIME NOT NULL NUMBER（38）END_TIME NOT NULL NUMBER（38）SELECT * FROM my_cdr ORDER BY 1,2,3,4; CALLER CALLEE START_TIME END_TIME ------ ------ ---------- --------- 1 7 1354 1575 1 7 1603 1829 1 7 1857 2301 1 7 2320 2819 1 7 2840 2964 1 7 64342 64457 1 7 85753 85790 1 7 85808 85985 1 7 86011 86412 1 7 86437 86546 1 7 163436 163505 1 7 163534 163967 1 7 163982 164454 1 7 214677 214764 1 7 214782 215248 1 7 216056 216271 1 7 216297 216728 1 7 216747 216853 1 7 261138 261463 1 7 261493 261864 1 7 261890 262098 1 7 262115 262655 1 7 301931 302226 1 7 302248 302779 1 7 302804 302992 1 7 303015 303258 1 7 303283 303337 1 7 383019 383378 1 7 383407 383534 1 7 424800 425096选择了30行。CALLER CALLEE START_TIME EFFECTIVE_CALL TOTAL_INTERUPTION NO_OF_RE SESSION_ID ------ ------- --------- -------------- ------- ---------- -------- ---------- 1 7 1354 1514 96 4 1 1 7 64342 115 0 0 2 1 7 85753 724 69 3 3 1 7 163436 974 44 2 4 1 7 214677 553 18 1 5 1 7 216056 752 45 2 6 1 7 261138 1444 73 3 7 1 7 301931 1311 95 4 8 1 7 383019 486 29 1 9 1 7 424800 296 0 0 10 10行选择。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9304"></a><a id="DWHSG9303"></a><div class="props_rev_3"><a id="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD" name="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD"></a><h4 id="DWHSG-GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD" class="sect4"><span class="enumeration_section">21.6.4</span>模式匹配示例：财务跟踪</h4>
                  <div>
                     <div class="section">
                        <p>常见的财务应用是搜索可疑的财务模式。<a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">例21-22</a>说明了如何检测看似可疑的汇款，因为已经确定了您已定义为异常的某些标准。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">
                        <p class="titleinexample">例21-22可疑汇款</p>
                        <p>在<a href="sql-pattern-matching-data-warehouses.html#GUID-6155172D-4613-4D9D-9669-2CDB3FDEF8BD__CACDHADI">例21-22中</a> ，我们搜索在转移资金时似乎可疑的模式。在这种情况下，这被定义为在30天内三次或更多次（少于2000美元）的汇款，然后在最后一次小额转账的10天内进行大额转账（超过1,000,000美元）。为简化起见，表格和数据非常基础。
                        </p>
                        <p>首先，我们创建一个包含必要数据的表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE event_log（时间DATE，用户ID VARCHAR2（30），数量NUMBER（10），事件VARCHAR2（10），transfer_to VARCHAR2（10））;</pre><p>然后我们将数据插入<code class="codeph">event_log</code> ：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO event_log VALUES（TO_DATE（'01 -JAN-2012'，'DD-MON-YYYY'），'john'，1000000，'deposit'，NULL）; INSERT INTO event_log VALUES（TO_DATE（'05 -JAN-2012'，'DD-MON-YYYY'），'john'，1200000，'deposit'，NULL）; INSERT INTO event_log VALUES（TO_DATE（'06 -JAN-2012'，'DD-MON-YYYY'），'john'，1000，'transfer'，'bob'）; INSERT INTO event_log VALUES（TO_DATE（'15 -JAN-2012'，'DD-MON-YYYY'），'john'，1500，'transfer'，'bob'）; INSERT INTO event_log VALUES（TO_DATE（'20 -JAN-2012'，'DD-MON-YYYY'），'john'，1500，'transfer'，'allen'）; INSERT INTO event_log VALUES（TO_DATE（'23 -JAN-2012'，'DD-MON-YYYY'），'john'，1000，'transfer'，'tim'）; INSERT INTO event_log VALUES（TO_DATE（'26 -JAN-2012'，'DD-MON-YYYY'），'john'，1000000，'transfer'，'tim'）; INSERT INTO event_log VALUES（TO_DATE（'27 -JAN-2012'，'DD-MON-YYYY'），'john'，500000，'deposit'，NULL）;</pre><p>接下来，我们可以查询此表：</p><pre class="oac_no_warn" dir="ltr">SELECT userid，first_t，last_t，amount FROM（SELECT * FROM event_log WHERE event ='transfer'）MATCH_RECOGNIZE（PARTITION BY userid ORDER BY time MEASURES FIRST（x.time）first_t，y.time last_t，y.amount amount PATTERN（x {3，} y）DEFINE x AS（事件='转移'和金额<span class="bold">&lt;2000</span> ），y AS（事件='转移'和金额<span class="bold">&gt; = 1000000</span>和最后（x.time） - 第一（x.time） <span class="bold">&lt;30</span>和y.time  - 最后（x.time） <span class="bold">&lt;10</span> ））; USERID FIRST_TLAST_T AMOUNT ---------- --------- --------- -------约翰06-JAN-12 26-JAN-12百万</pre><p>在此声明中，第一个粗体表示小转移，第二个表示大转移，第三个表示小转移发生在30天内，第四个表示大转移发生在最后一次小转移之后的10天内。</p>
                        <p>可以进一步细化此声明以包括可疑转移的接收者，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT userid，first_t，last_t，amount，transfer_to FROM（SELECT * FROM event_log WHERE event ='transfer'）MATCH_RECOGNIZE（PARTITION BY userid ORDER BY time MEASURES z.time first_t，y.time last_t，y.amount amount，y.transfer_to transfer_to PATTERN（zx {2，} y）DEFINE z AS（event ='transfer'AND amount <span class="bold">&lt;2000</span> ），x AS（event ='transfer'AND amount &lt;= 2000 AND <span class="bold">PREV（x.transfer_to）&lt;&gt; x.transfer_to ）</span> ，y AS（event ='transfer'和amount <span class="bold">&gt; = 1000000</span> AND LAST（x.time） -  z.time <span class="bold">&lt;30</span> AND y.time  -  LAST（x.time） <span class="bold">&lt;10</span> AND SUM（x.amount）+ z .amount <span class="bold">&lt;20000</span> ）; USERID FIRST_TLAST_T AMOUNT TRANSFER_TO ---------- --------- --------- ------- ---- -------约翰15-JAN-12 26-JAN-12 1000000蒂姆</pre><p>在此声明中，第一个粗体文本表示第一个小转移，下一个表示两个或多个小转移到不同帐户，第三个表示所有小转移的总和低于20,000美元。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>