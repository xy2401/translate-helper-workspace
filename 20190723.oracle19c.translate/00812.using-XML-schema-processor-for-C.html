<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use the Extensible Markup Language (XML) schema processor for C."></meta>
      <meta name="description" content="An explanation is given of how to use the Extensible Markup Language (XML) schema processor for C."></meta>
      <title>使用C的XML模式处理器</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use the Extensible Markup Language (XML) schema processor for C."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-binary-XML-with-C.html" title="Previous" type="text/html"></link>
      <link rel="next" href="determining-XML-differences-using-C.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-binary-XML-with-C.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="determining-XML-differences-using-C.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-C.html" property="item" typeof="WebPage"><span property="name">适用于C的Oracle XML Developer's Kit</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用C的XML模式处理器</li>
            </ol>
            <a id="GUID-E200D27B-EC8D-44D9-A54D-6460D52CD70E" name="GUID-E200D27B-EC8D-44D9-A54D-6460D52CD70E"></a><a id="ADXDK1040"></a><a id="ADXDK1600"></a>
            
            <h2 id="ADXDK-GUID-E200D27B-EC8D-44D9-A54D-6460D52CD70E" class="sect2"><span class="enumeration_chapter">7</span>使用C的XML模式处理器</h2>
         </header>
         <div class="ind">
            <div>
               <p>给出了如何使用C的可扩展标记语言（XML）模式处理器的解释。</p>
               <div class="section"></div>
               <!-- class="section" -->
               <div class="infoboxnote" id="GUID-E200D27B-EC8D-44D9-A54D-6460D52CD70E__GUID-CE76921C-B1E1-4506-8325-2BDAB58C145B">
                  <p class="notep1">注意：</p>
                  <p>使用适用于Oracle XML Developer Kit（XDK）和Oracle XML DB应用程序的统一C应用程序编程接口（API）。不推荐使用较旧的非经过授权的C函数，仅支持向后兼容性。它们将在以后的版本中删除。</p>
                  <p>统一C API <a href="getting-started-with-XDK-for-C.html#GUID-181C9561-3CA8-4FBB-A269-AEE8C4AA60D9" title="统一的C API是一个编程接口，它统一了XDK for C和Oracle XML DB所需的功能。此API主要由XSLT和XML Schema使用。">在Unified C API概述中</a>描述。</p>
               </div>
            </div><a id="ADXDK19805"></a><div class="props_rev_3"><a id="GUID-17F16A07-60E7-4598-836C-EBF31D9C69B9" name="GUID-17F16A07-60E7-4598-836C-EBF31D9C69B9"></a><h3 id="ADXDK-GUID-17F16A07-60E7-4598-836C-EBF31D9C69B9" class="sect3">适用于C的Oracle XML Schema Processor</h3>
               <div>
                  <p>C的XML Schema处理器是C的可扩展标记语言（XML）解析器的配套组件，它允许支持XML应用程序中的简单和复杂数据类型。</p>
                  <p>C的XML Schema处理器支持万维网联盟（W3C）XML Schema Recommendation。这使得编写处理XML文档的自定义应用程序变得简单，这意味着符合标准的XML Schema处理器是移植Oracle数据库的每个操作系统上XDK的一部分。</p>
                  <p>XML Schema处理器支持XML验证和元数据检索。它可以单独调用，也可以通过XML Parser for C调用。</p>
                  <div class="infoboxnotealso" id="GUID-17F16A07-60E7-4598-836C-EBF31D9C69B9__GUID-85901773-6389-45C6-9228-733F665766ED">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="XML-parsing-for-Java.html#GUID-33E0EA2B-A08A-462E-86B4-3F944409663D" title="描述了针对Java的可扩展标记语言（XML）解析。">XML Parsing for Java</a> ，有关XML Schema的更多信息以及您希望使用XML Schema的原因。
                     </p>
                  </div>
               </div><a id="ADXDK19806"></a><div class="props_rev_3"><a id="GUID-ED2D65C0-E980-4F0D-B53B-C0C9324E644D" name="GUID-ED2D65C0-E980-4F0D-B53B-C0C9324E644D"></a><h4 id="ADXDK-GUID-ED2D65C0-E980-4F0D-B53B-C0C9324E644D" class="sect4">用于C功能的Oracle XML Schema</h4>
                  <div>
                     <p>描述了用于C的Oracle XML Schema处理器的功能。</p>
                     <p>特征：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>支持简单和复杂的类型</p>
                        </li>
                        <li>
                           <p>基于C的XML解析器构建</p>
                        </li>
                        <li>
                           <p>支持W3C XML Schema Recommendation</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-ED2D65C0-E980-4F0D-B53B-C0C9324E644D__GUID-5B9AE439-947F-4496-899A-DE6572C614D9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../caxml/package-Schema-API.html#CAXML05000" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a> “用于C的模式API”</p>
                           </li>
                           <li>
                              <p><code class="codeph">$ORACLE_HOME/xdk/demo/c/schema/</code> - 示例代码</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADXDK19807"></a><div class="props_rev_3"><a id="GUID-D897A10A-51B1-4053-8502-EE35E456342F" name="GUID-D897A10A-51B1-4053-8502-EE35E456342F"></a><h4 id="ADXDK-GUID-D897A10A-51B1-4053-8502-EE35E456342F" class="sect4">适用于C的Oracle XML Schema Processor的标准一致性</h4>
                  <div>
                     <p>列出了符合C的XML模式处理器的标准。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>W3C推荐的可扩展标记语言（XML）1.0</p>
                        </li>
                        <li>
                           <p>文档对象模型（DOM）级别1.0的W3C建议</p>
                        </li>
                        <li>
                           <p>W3C推荐XML格式的命名空间</p>
                        </li>
                        <li>
                           <p>W3C对XML Schema的建议</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19809"></a><a id="ADXDK19810"></a><a id="ADXDK19808"></a><div class="props_rev_3"><a id="GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81" name="GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81"></a><h4 id="ADXDK-GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81" class="sect4">用于C：提供软件的XML模式处理器</h4>
                  <div>
                     <p>描述了为XML Schema Processor for C提供的软件。</p>
                     <div class="tblformal" id="GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81__G1010085">
                        <p class="titleintable">表7-1 $ ORACLE_HOME中C：XML提供的文件的XML模式处理器</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="用于C的XML模式处理器：$ ORACLE_HOME中的提供文件" width="100%" border="1" summary="This table lists the supplied files and directories for this release. Directory and Files, and Description are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d25262e469">目录和文件</th>
                                 <th align="left" valign="bottom" width="70%" id="d25262e472">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e477" headers="d25262e469 ">
                                    <p><code class="codeph">箱子</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e477 d25262e472 ">
                                    <p>模式处理器可执行文件， <code class="codeph">schema</code> 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e488" headers="d25262e469 ">
                                    <p><code class="codeph">LIB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e488 d25262e472 ">
                                    <p>XML / XSL / Schema和支持库</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e496" headers="d25262e469 ">
                                    <p><code class="codeph">NLS /数据</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e496 d25262e472 ">
                                    <p>全球化支持数据文件</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e504" headers="d25262e469 ">
                                    <p><code class="codeph">XDK /演示/ C /架构</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e504 d25262e472 ">
                                    <p>Schema处理器的示例用法</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e512" headers="d25262e469 ">
                                    <p><code class="codeph">XDK /包括</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e512 d25262e472 ">
                                    <p>头文件</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e520" headers="d25262e469 ">
                                    <p><code class="codeph">XDK / MESG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e520 d25262e472 ">
                                    <p>错误消息文件</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e528" headers="d25262e469 ">
                                    <p><code class="codeph">XDK / readme.html中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e528 d25262e472 ">
                                    <p>介绍性文件</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p> <a href="using-XML-schema-processor-for-C.html#GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81__G1010119" title="列中包含库和描述。">表7-2</a>列出了目录<code class="codeph">lib</code>包含的库。
                     </p>
                     <div class="tblformal" id="GUID-4A027870-C565-4E37-A0D2-42B1C7DDBE81__G1010119">
                        <p class="titleintable">表7-2 C：提供的库的XML模式处理器</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="用于C：提供的库的XML模式处理器" width="100%" border="1" summary="Included Library and Description are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d25262e555">包含的图书馆</th>
                                 <th align="left" valign="bottom" width="70%" id="d25262e558">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e563" headers="d25262e555 ">
                                    <p><code class="codeph">libxml10.a</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e563 d25262e558 ">
                                    <p>XML解析器，可扩展样式表语言转换（XSLT）处理器，XML架构处理器</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e571" headers="d25262e555 ">
                                    <p><code class="codeph">libcore10.a</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e571 d25262e558 ">
                                    <p>常见的Oracle运行时环境（CORE）功能</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d25262e579" headers="d25262e555 ">
                                    <p><code class="codeph">libnls10.a</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d25262e579 d25262e558 ">
                                    <p>全球化支持</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="ADXDK19811"></a><div class="props_rev_3"><a id="GUID-867DB3AD-DD1B-4115-9825-9FBD1D00F2DB" name="GUID-867DB3AD-DD1B-4115-9825-9FBD1D00F2DB"></a><h3 id="ADXDK-GUID-867DB3AD-DD1B-4115-9825-9FBD1D00F2DB" class="sect3">使用C XML Schema Processor命令行实用程序</h3>
               <div>
                  <p>您可以通过在安装区域中调用<code class="codeph">bin/schema</code>将C语言的XML Schema处理器作为可执行文件调用。
                  </p>
                  <div class="section">
                     <p>可执行文件有两个参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML实例文档</p>
                        </li>
                        <li>
                           <p>（可选）默认架构</p>
                        </li>
                     </ul>
                     <p>也可以使用提供的API编写代码来调用C的XML Schema处理器。必须使用<code class="codeph">include</code>子目录中的头文件编译代码，并将其链接到<code class="codeph">lib</code>子目录中的<code class="codeph">lib</code> 。有关如何构建程序的详细信息，请参阅<code class="codeph">xdk/demo/c/schema</code>子目录中的<code class="codeph">Makefile</code> 。
                     </p>
                     <p><code class="codeph">mesg/</code>子目录中提供了不同语言的错误消息文件。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADXDK19813"></a><a id="ADXDK19812"></a><div class="props_rev_3"><a id="GUID-8A27497A-0146-44C5-83A6-33090F4D1FC3" name="GUID-8A27497A-0146-44C5-83A6-33090F4D1FC3"></a><h3 id="ADXDK-GUID-8A27497A-0146-44C5-83A6-33090F4D1FC3" class="sect3">C使用图的XML模式处理器</h3>
               <div>
                  <p>给出了用于C的XML Schema处理器的调用序列。</p>
                  <p><a href="using-XML-schema-processor-for-C.html#GUID-8A27497A-0146-44C5-83A6-33090F4D1FC3__I1008723">图7-1</a>说明了调用顺序，如下所示：</p>
                  <ol>
                     <li>
                        <p>初始化调用在会话开始时调用一次;它返回在整个会话中使用的模式上下文。</p>
                     </li>
                     <li>
                        <p>要在会话中使用的模式文档是预先加载的。</p>
                     </li>
                     <li>
                        <p>首先使用XML解析器解析要验证的实例文档。</p>
                     </li>
                     <li>
                        <p>然后，将实例的XML元素子树的顶部传递给模式验证功能。</p>
                     </li>
                     <li>
                        <p>如果实例文档中未定义显式模式，则使用任何加载的模式。</p>
                     </li>
                     <li>
                        <p>然后可以使用相同的模式上下文验证更多文档。</p>
                     </li>
                     <li>
                        <p>会话结束时，将调用Schema拆除功能，该功能释放为加载的模式分配的所有内存。</p>
                     </li>
                  </ol>
                  <div class="figure" id="GUID-8A27497A-0146-44C5-83A6-33090F4D1FC3__I1008723">
                     <p class="titleinfigure">图7-1 C使用图的XML模式处理器</p><img src="img/adxdk092.gif" width="489" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/adxdk092.html"><br><a href="img_text/adxdk092.html">“图7-1 C使用图的XML模式处理器”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ADXDK19815"></a><a id="ADXDK19814"></a><div class="props_rev_3"><a id="GUID-5681C905-D876-412A-A88A-6CAD3A3FD3C3" name="GUID-5681C905-D876-412A-A88A-6CAD3A3FD3C3"></a><h3 id="ADXDK-GUID-5681C905-D876-412A-A88A-6CAD3A3FD3C3" class="sect3">如何为C示例程序运行XML架构</h3>
               <div>
                  <p>目录<code class="codeph">xdk/demo/c/schema</code>包含示例XML Schema应用程序，这些应用程序显示如何将Oracle XML Schema处理器与其API一起使用。这些示例文件在此处描述。
                  </p>
                  <div class="tblformal" id="GUID-5681C905-D876-412A-A88A-6CAD3A3FD3C3__G1010135">
                     <p class="titleintable">表7-3提供的C示例的XML架构</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="提供的C示例的XML模式" width="100%" border="1" summary="This table lists the provided sample files. Sample File and Description are the columns." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="30%" id="d25262e920">示例文件</th>
                              <th align="left" valign="bottom" width="70%" id="d25262e923">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d25262e928" headers="d25262e920 ">
                                 <p><code class="codeph">Makefile文件</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d25262e928 d25262e923 ">
                                 <p>Makefile用于构建示例程序并运行它们，验证输出是否正确。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d25262e936" headers="d25262e920 ">
                                 <p><code class="codeph">xsdtest.c</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d25262e936 d25262e923 ">
                                 <p>调用C ++的XML Schema的程序</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d25262e944" headers="d25262e920 ">
                                 <p><code class="codeph">车{XSD，XML，标准}</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d25262e944 d25262e923 ">
                                 <p>在对它们运行<code class="codeph">xsdtest</code>之后， <code class="codeph">xsdtest</code>对示例模式，实例文档和预期输出进行操作。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d25262e955" headers="d25262e920 ">
                                 <p><code class="codeph">水溶液{XSD，XML，标准}</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d25262e955 d25262e923 ">
                                 <p>在对它们运行<code class="codeph">xsdtest</code>之后，分别为第二个示例模式，实例文档和预期输出。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d25262e966" headers="d25262e920 ">
                                 <p><code class="codeph">酒馆。{XSD，XML，标准}</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d25262e966 d25262e923 ">
                                 <p>在对它们运行<code class="codeph">xsdtest</code>之后， <code class="codeph">xsdtest</code>对第三个示例模式，实例文档和预期输出。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>要构建示例程序，请运行<code class="codeph">make</code> 。
                  </p>
                  <p>要构建程序并运行它们，将实际输出与预期输出进行比较：</p><pre class="oac_no_warn" dir="ltr">确保</pre></div>
            </div><a id="ADXDK19004"></a><div class="props_rev_3"><a id="GUID-3CB7FD0A-E148-48C9-882F-BF5F3E51D1AB" name="GUID-3CB7FD0A-E148-48C9-882F-BF5F3E51D1AB"></a><h3 id="ADXDK-GUID-3CB7FD0A-E148-48C9-882F-BF5F3E51D1AB" class="sect3">什么是流式验证器？</h3>
               <div>
                  <p>流式验证器使用XML事件，它是XML文档的表示，类似于Simple API for XML（SAX）事件。XML事件具有开始标记，结束标记和注释。生产者驱动SAX事件，消费者驱动XML事件。</p>
                  <p>流式验证器与较旧的模式验证器共享软件，并从中获取大部分功能。内存开销小于旧验证器中使用的DOM表示。只有一次通过该文件。流式验证器是在Oracle Database 11g第1版（11.1）中引入的。</p>
                  <p>流验证有两种模式：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>透明模式事件将返回给应用程序。</p>
                     </li>
                     <li>
                        <p>不透明模式事件不会返回到应用程序，但会返回指示文档验证过程成功或失败的错误。</p>
                     </li>
                  </ul>
                  <p>在文档验证之前，必须创建常规验证上下文，并且必须使用此上下文加载相关模式。然后必须创建pull解析器（或另一个事件生成器）的XML事件上下文。然后将该事件上下文提供给流式验证器，以便它可以从生产者请求事件。</p>
                  <p>还支持将模式DOM传递给<code class="codeph">XmlSchemaLoad</code> API。
                  </p>
               </div><a id="ADXDK19816"></a><div class="props_rev_3"><a id="GUID-9AA4F9D3-1898-4D08-BEF9-9AEA7EED6221" name="GUID-9AA4F9D3-1898-4D08-BEF9-9AEA7EED6221"></a><h4 id="ADXDK-GUID-9AA4F9D3-1898-4D08-BEF9-9AEA7EED6221" class="sect4">使用透明模式</h4>
                  <div>
                     <p>描述了透明模式的基本用法。</p>
                     <div class="section">
                        <p>应用程序首先调用<code class="codeph">XmlEvCreateSVCtx(</code> ）。此调用创建并返回<code class="codeph">xmlctx</code>类型的事件上下文，必须在后续调用流式验证器时传递该事件上下文。必须通过调用<code class="codeph">XmlEvDestroyCtx()</code>来终止创建的事件上下文。
                        </p>
                        <p>在创建事件上下文之后，应用程序通过调用<code class="codeph">XmlEvNext()</code>重复将验证提升到下一个事件，该<code class="codeph">XmlEvNext()</code>返回下一个事件的类型。其他API接口允许应用程序检索与上一个事件相关的信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19817"></a><div class="props_rev_3"><a id="GUID-A6EF9125-DECE-4C6F-8038-C8D4C355D20B" name="GUID-A6EF9125-DECE-4C6F-8038-C8D4C355D20B"></a><h5 id="ADXDK-GUID-A6EF9125-DECE-4C6F-8038-C8D4C355D20B" class="sect5">透明模式下的错误处理</h5>
                     <div>
                        <p>没有有效事件的概念。有效性是文档的属性，而不是文档的单个项目和事件。</p>
                        <p>错误是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">XML_EVENT_FATAL_ERROR</code> - 当XML事件的生产者报告此错误时，流验证器将此事件返回给应用程序并停止验证过程。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">XML_EVENT_ERROR</code> - 当验证错误发生时，流验证程序将此事件返回给应用程序。然后，应用程序可以调用<code class="codeph">XmlEvGetError()</code>以获取有关错误的更多信息。
                              </p>
                           </li>
                        </ul>
                        <p>如果应用程序未收到任何<code class="codeph">XML_EVENT_ERROR</code>或<code class="codeph">XML_EVENT_FATAL_ERROR</code>事件，则该文档有效。因此，应用程序必须处理这些事件而不是忽略它们。
                        </p>
                        <p>不缓存这些错误，并且相关信息不可用于以后检索。</p>
                     </div>
                  </div><a id="ADXDK19819"></a><a id="ADXDK19818"></a><div class="props_rev_3"><a id="GUID-B26DBA74-92F6-4CA0-8160-CAD399B810D5" name="GUID-B26DBA74-92F6-4CA0-8160-CAD399B810D5"></a><h5 id="ADXDK-GUID-B26DBA74-92F6-4CA0-8160-CAD399B810D5" class="sect5">流式验证器示例</h5>
                     <div>
                        <p>提出了透明模式下的流验证器示例。</p>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-B26DBA74-92F6-4CA0-8160-CAD399B810D5__GUID-80A7CED4-CE51-4696-A7E5-E353149F8647">
                           <p class="titleinexample">例7-1透明模式下的流式验证器</p><pre class="oac_no_warn" dir="ltr">#include“xmlev.h”......xmlevctx * ppevtcx，* svevctx; xmlctx * xctx xsdctx * sctx;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“test”）））printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）; ...如果（！（sctx = XmlSchemaCreate（xctx，＆xerr，NULL）））printf（“无法创建模式上下文，错误％u \ n”，（unsigned）xerr）; ...if（xerr = XmlSchemaLoad（sctx，“my_schema.xsd”，NULL））printf（“无法加载模式，错误％u \ n”，（unsigned）xerr）;如果（！（ppevctx = XmlEvCreatePPCtx（xctx，＆xerr，NULL）））printf（“无法创建EVENT上下文，错误％u \ n”，（无符号）xerr）; if（xerr = XmlEvLoadPPDoc（xctx，ppevctx，“file”，“test.xml”，0，NULL））printf（“无法加载文档，错误％u \ n”，（无符号）xerr）; ...如果（！（svevctx = XmlEvCreateSVCtx（xctx，sctx，ppevctx，＆xerr）））printf（“无法创建SVcontext，错误％u \ n”，（unsigned）xerr）; ...for（;;）{xmlevtype cur_event; cur_event = XmlEvNext（svevctx）; switch（cur_event）{case XML_EVENT_FATAL_ERROR：printf（“FATAL ERROR”）; / *错误处理在这里* / return; case XML_EVENT_ERROR：XmlEvGetError（svevctx，oratext * msg）; printf（“验证失败，错误％s \ n”，msg）;打破; case XML_EVENT_START_ELEMENT：printf（“&lt;％s&gt;”，XmlEvGetName（svevctx））;打破; ...case XML_EVENT_END_DOCUMENT：printf（“END DOCUMENT”）;返回; } ...XmlEvDestroySVCtx（svevctx）; XmlSchemaDestroy（sctx）; XmlEvDestroyCtx（ppevctx）; XmlDestroyCtx（xctx）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19820"></a><div class="props_rev_3"><a id="GUID-6FA49C7C-AF47-41E7-A408-671A56B5526F" name="GUID-6FA49C7C-AF47-41E7-A408-671A56B5526F"></a><h4 id="ADXDK-GUID-6FA49C7C-AF47-41E7-A408-671A56B5526F" class="sect4">使用不透明模式</h4>
                  <div>
                     <p>在不透明模式下，流式验证器将实例文档读取为来自生产者的一系列事件，但它不会将事件传递给应用程序（使用者）。它在成功时返回<code class="codeph">XMLERR_OK</code> ，在失败时返回错误号。
                     </p>
                     <div class="section">
                        <p>加载架构并初始化XML事件上下文后，应用程序可以通过调用<code class="codeph">XmlEvSchemaValidate()</code>在此模式下验证文档。此函数的签名采用指向事件上下文的指针。声明是：</p><pre class="pre codeblock"><code>xmlerr XmlEvSchemaValidate（xmlctx * xctx，xsdctx * sctx，xmlevctx * evctx，oratext ** errmsg）; / *返回（xmlerr），错误代码* /</code></pre></div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19821"></a><div class="props_rev_3"><a id="GUID-4DE7B524-672B-4E1A-93DA-0AC889047AE4" name="GUID-4DE7B524-672B-4E1A-93DA-0AC889047AE4"></a><h5 id="ADXDK-GUID-4DE7B524-672B-4E1A-93DA-0AC889047AE4" class="sect5">不透明模式下的错误处理</h5>
                     <div>
                        <p>当流验证程序遇到错误时， <code class="codeph">XmlEvSchemaValidate()</code>返回错误号。这可能是因为解析错误或验证错误。然后，应用程序可以使用现有的<code class="codeph">XmlEvGetError</code> API来获取错误消息。
                        </p>
                        <p>错误消息已参数化，并且通常具有导致流式验证器终止的所有错误。</p>
                     </div>
                  </div><a id="ADXDK19823"></a><a id="ADXDK19822"></a><div class="props_rev_3"><a id="GUID-A45759C8-8044-42C8-B678-7E4CAE92EF9D" name="GUID-A45759C8-8044-42C8-B678-7E4CAE92EF9D"></a><h5 id="ADXDK-GUID-A45759C8-8044-42C8-B678-7E4CAE92EF9D" class="sect5">不透明模式应用示例</h5>
                     <div>
                        <p>提出了一个不透明模式应用程序的示例。</p>
                        <div class="example" id="GUID-A45759C8-8044-42C8-B678-7E4CAE92EF9D__GUID-3A6EE0EF-5868-457F-9146-E98A1BA9D6F2">
                           <p class="titleinexample">例7-2不透明模式下的流验证器示例</p><pre class="oac_no_warn" dir="ltr">#include“xmlev.h”......xmlevctx * ppevtcx; xmlctx * xctx; xsdctx * sctx; oratext ** errmsg; xmlerr xerr;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“test”））printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）; ...如果（！（sctx = XmlSchemaCreate（xctx，＆xerr，NULL）））printf（“无法创建模式上下文，错误％u \ n”，（unsigned）xerr）; ...if（xerr = XmlSchemaLoad（sctx，“my_schema.xsd”，NULL））printf（“无法加载模式，错误％u \ n”，（unsigned）xerr）;如果（！（ppevctx = XmlEvCreatePPCtx（xctx，＆xerr，NULL）））printf（“无法创建EVENT上下文，错误％u \ n”，（无符号）xerr）; if（xerr = XmlEvLoadPPDoc（xctx，ppevctx，“file”，“test.xml”，0，NULL））printf（“无法加载文档，错误％u \ n”，（无符号）xerr）; if（（xerr = XmlEvSchemaValidate（xctx，sctx，ppevctx，errmsg）））{printf（“Validation Failed，Error：％s \ n”，errmsg）; } ...XmlSchemaDestroy（sctx）; XmlEvDestroyCtx（ppevctx）; XmlDestroyCtx（xctx）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19825"></a><a id="ADXDK19824"></a><div class="props_rev_3"><a id="GUID-0FF5701E-1349-4514-B6B2-CAA69956BC80" name="GUID-0FF5701E-1349-4514-B6B2-CAA69956BC80"></a><h4 id="ADXDK-GUID-0FF5701E-1349-4514-B6B2-CAA69956BC80" class="sect4">使用函数XmlSchemaLoad（）与现有DOM</h4>
                  <div>
                     <p>函数<code class="codeph">XmlSchemaLoad()</code>接受两个固定参数和一组变量属性。第一个参数是模式上下文;第二个是架构文档的URL位置。
                     </p>
                     <div class="section">
                        <p>从Oracle Database 11g第1版（11.1）开始，您可以使用属性<code class="codeph">schema_dom_callback</code>在给定URL的情况下提供对架构DOM的访问。该属性是应用程序提供的回调函数。如果提供，架构加载函数使用此回调来访问主架构的DOM并访问任何包含，导入或重新定义的架构。
                        </p>
                        <p>回调签名如下：</p><pre class="oac_no_warn" dir="ltr">typedef xmldocnode *（* xmlsch_dom_callback）（xmlctx * xctx，oratext * uri，xmlerr * xerr）;</pre><p>回调接受URI（模式加载函数传入所需文档的URI）并返回文档节点。<a href="using-XML-schema-processor-for-C.html#GUID-0FF5701E-1349-4514-B6B2-CAA69956BC80__GUID-D3201FCC-6377-446E-A325-18C33B904837">例7-3</a>说明了这一点。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0FF5701E-1349-4514-B6B2-CAA69956BC80__GUID-D3201FCC-6377-446E-A325-18C33B904837">
                        <p class="titleinexample">例7-3 XmlSchemaLoad（）示例</p><pre class="oac_no_warn" dir="ltr">#include“xmlev.h”......xmlctx * xctx; xsdctx * sctx; xmldocnode * doc;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“test”））printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）; ...如果（！（sctx = XmlSchemaCreate（xctx，＆xerr，NULL）））printf（“无法创建模式上下文，错误％u \ n”，（unsigned）xerr）; ...if（xerr = XmlSchemaLoad（sctx，schema_uri，“schema_dom_callback”，func1，NULL））printf（“无法加载模式，错误％u \ n”，（unsigned）xerr）; ...XmlSchemaDestroy（sctx）; XmlDestroyCtx（xctx）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADXDK19827"></a><a id="ADXDK19826"></a><div class="props_rev_3"><a id="GUID-58DE68DC-6EDF-405B-BD60-F751BAAE4C42" name="GUID-58DE68DC-6EDF-405B-BD60-F751BAAE4C42"></a><h4 id="ADXDK-GUID-58DE68DC-6EDF-405B-BD60-F751BAAE4C42" class="sect4">验证选项</h4>
                  <div>
                     <p>您可以使用<code class="codeph">XmlSchemaSetValidateOptions()</code>为验证过程提供选项。
                     </p>
                     <div class="section">
                        <p>例如：</p><pre class="pre codeblock"><code>XmlSchemaSetValidateOptions（scctx，“ignore_id_constraint”，（boolean）TRUE，NULL）;</code></pre><p>选项是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ignore_id_constraint</code> （在Oracle Database 11g第1版（11.1）之前存在）</p>
                           </li>
                           <li>
                              <p><code class="codeph">ignore_sch_location</code> （在Oracle Database 11g第1版（11.1）之前存在）</p>
                           </li>
                           <li>
                              <p><code class="codeph">ignore_par_val_rest</code> （在Oracle Database 11g第1版（11.1）之前存在）</p>
                           </li>
                           <li>
                              <p><code class="codeph">ignore_pattern_check</code> ：当此属性为<code class="codeph">TRUE</code> ，流式验证器将忽略pattern-facet检查。默认值为<code class="codeph">FALSE</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">no_events_for_defaults</code> ：当此属性为<code class="codeph">TRUE</code> ，流式验证程序不会返回添加到实例文档的默认值的事件。<span class="italic">此选项只能在透明的情况下使用。</span></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-58DE68DC-6EDF-405B-BD60-F751BAAE4C42__GUID-D1659A1C-E3CC-4169-A049-8150354FD850">
                        <p class="titleinexample">示例7-4使用新选项的流式验证器示例</p><pre class="pre codeblock"><code>#include“xmlev.h”......xmlevctx * ppevtcx; xmlctx * xctx; xsdctx * sctx; xmlerr xerr; oratext ** errmsg;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“test”））printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）; ...如果（！（sctx = XmlSchemaCreate（xctx，＆xerr，NULL）））printf（“无法创建模式上下文，错误％u \ n”，（unsigned）xerr）; ...if（xerr = XmlSchemaLoad（sctx，“my_schema.xsd”，NULL））printf（“无法加载模式，错误％u \ n”，（unsigned）xerr）;如果（！（ppevctx = XmlEvCreatePPCtx（xctx，＆xerr，“file”，“test.xml”，NULL）））printf（“无法创建EVENT上下文，错误％u \ n”，（无符号）xerr）; if（xerr = XmlEvLoadPPDoc（xctx，ppevctx，“file”，“test.xml”，0，NULL））printf（“无法加载文档，错误％u \ n”，（无符号）xerr）; XmlSchemaSetValidateOptions（sctx，“ignore_id_constraint”，TRUE，“ignore_pattern_facet”，TRUE，NULL）; if（（xerr = XmlEvSchemaValidate（xctx，sctx，ppevctx，errmsg）））{printf（“Validation Failed，Error：％s \ n”，errmsg）; } ...XmlSchemaDestroy（sctx）; XmlEvDestroyCtx（ppevctx）; XmlDestroyCtx（xctx）;</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>