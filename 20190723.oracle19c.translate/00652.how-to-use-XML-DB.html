<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An overview of the various ways of using Oracle XML DB is presented."></meta>
      <meta name="description" content="An overview of the various ways of using Oracle XML DB is presented."></meta>
      <title>如何使用Oracle XML DB概述</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="An overview of the various ways of using Oracle XML DB is presented."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="getting-started-with-XML-DB.html" title="Previous" type="text/html"></link>
      <link rel="next" href="manipulation-of-XML-in-XML-DB.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="getting-started-with-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="manipulation-of-XML-in-XML-DB.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-DB-basics.html" property="item" typeof="WebPage"><span property="name">Oracle XML DB基础知识</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">如何使用Oracle XML DB概述</li>
            </ol>
            <a id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398" name="GUID-757B4470-851B-47B7-AB78-81F47ECE5398"></a><a id="ADXDB0300"></a>
            
            <h2 id="ADXDB-GUID-757B4470-851B-47B7-AB78-81F47ECE5398" class="sect2"><span class="enumeration_chapter">3</span>如何使用Oracle XML DB概述</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='how-to-use-XML-DB'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>介绍了使用Oracle XML DB的各种方法的概述。</p>
               <p>此概述说明了如何执行以下操作：创建和分区<code class="codeph">XMLType</code>表和列;强制数据完整性，加载，查询和更新数据库XML内容;并从关系数据生成XML数据。它还解释了Oracle XML DB如何确定哪些字符集用于XML文档。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398__GUID-3110B980-4BC0-4DA8-B5FE-4CE8010C1B95">采购订单文档说明了关键的XML模式功能</p>
                  <p>本章介绍的许多示例都说明了在采购订单文档中访问和管理XML内容的技术。采购订单是高度结构化的文档，但您也可以使用此处显示的技术来处理结构很少的XML文档。</p>
                  <p>此处用于示例的采购订单文档符合采购订单XML架构，该架构演示了典型XML文档的一些关键功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>全局元素<code class="codeph">PurchaseOrder</code>是<code class="codeph">complexType</code> <code class="codeph">PurchaseOrderType</code>的实例</p>
                     </li>
                     <li>
                        <p><code class="codeph">PurchaseOrderType</code>定义组成<code class="codeph">PurchaseOrder</code>元素的节点集</p>
                     </li>
                     <li>
                        <p><code class="codeph">LineItems</code>元件由集合的<code class="codeph">LineItem</code>元素</p>
                     </li>
                     <li>
                        <p>每个<code class="codeph">LineItem</code>元素由两个元素组成： <code class="codeph">Description</code>和<code class="codeph">Part</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">Part</code>元素具有属性<code class="codeph">Id</code> ， <code class="codeph">Quantity</code>和<code class="codeph">UnitPrice</code></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B">创建XMLType表和列</a><br>创建<code class="codeph">XMLType</code>的表或列非常简单，因为它是一种抽象数据类型。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242">在存储为二进制XML的XMLType数据上创建虚拟列</a><br>您只能为存储为二进制XML的<code class="codeph">XMLType</code>数据创建虚拟列。这些列可用于分区或约束数据。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5">对包含存储为二进制XML的XMLType数据的表进行分区</a><br>您可以对包含存储为二进制XML的<code class="codeph">XMLType</code>数据的表进行分区。</li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596">使用数据库实施XML数据完整性</a><br>您可以将SQL和XML的强大功能与数据库强制执行规则的能力结合起来。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B">将XML内容加载到Oracle XML DB中</a><br>有几种方法可以将XML内容加载到Oracle XML DB中。</li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75">查询Oracle XML DB中存储的XML内容</a><br>有许多方法可以在Oracle XML DB中查询XML内容并检索它。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8">更新存储在Oracle XML DB中的XML内容</a><br>您可以更新XML内容，替换文档的全部内容或仅替换文档的特定部分。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B">从关系数据生成XML数据</a><br>您可以使用Oracle XML DB从关系数据生成XML数据。
                  </li>
                  <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D">XML文档的字符集</a><br>Oracle XML DB有几种方法可以确定哪些字符集用于XML文档</li>
               </ul>
               <div class="infoboxnotealso" id="GUID-757B4470-851B-47B7-AB78-81F47ECE5398__GUID-6E7C00BE-B33D-4314-BB86-CE698C0D0877">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="getting-started-with-XML-DB.html#GUID-39A9B429-EFD9-4FC0-AB93-35324AF6D6AE" title="在规划Oracle XML DB应用程序时，考虑一些初步设计标准是值得的。">Oracle XML DB的应用程序设计注意事项，适用</a>于大多数用途的推荐Oracle XML DB功能</p>
                     </li>
                     <li>
                        <p><a href="XMLType-APIs.html#GUID-6209297F-DBE4-4F31-85F1-4083BF5BDE01" title="您可以使用Oracle XML DB XMLType PL / SQL，Java，C API和Oracle Data Provider for .NET（ODP.NET）来访问和操作XML数据。">XMLType API</a> ， <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="涵盖了XML Schema的使用和XMLType数据的对象关系存储。">XML Schema和Object-Relational XMLType</a>以及<a href="XML-DB-repository.html#GUID-840EBE35-8FC8-4150-9FC8-78442FD1B12B" title="Oracle XML DB Repository允许您对数据进行版本控制，实现和管理安全性，并使用API来访问和操作存储库资源。">Oracle XML DB Repository，</a>以获取有关更高级Oracle XML DB功能的信息</p>
                     </li>
                     <li>
                        <p><a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD" title="提供了各种示例中使用的采购订单XML模式的完整列表。">购买订单XML模式</a> ，用于本章示例中使用的采购订单XML模式</p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XML-DB-basics.html#GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" title="介绍了Oracle XML DB的基础知识。">Oracle XML DB基础知识</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5801"></a><a id="ADXDB5802"></a><a id="ADXDB4044"></a><div class="props_rev_3"><a id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B" name="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B"></a><h3 id="ADXDB-GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B" class="sect3"><span class="enumeration_section">3.1</span>创建XMLType表和列</h3>
               <div>
                  <p>创建<code class="codeph">XMLType</code>的表或列非常简单，因为它是一种抽象数据类型。
                  </p>
                  <div class="section">
                     <p>基本的<code class="codeph">CREATE TABLE</code>语句（不指定存储选项且不指定XML模式）将<code class="codeph">XMLType</code>数据存储为二进制XML。 <a id="fn_1" name="fn_1" href="#fn_1" data="" the="" xmltype="" storage="" model="" for="" xml="" schema-based="" is="" whatever="" was="" specified="" during="" registration="" of="" referenced="" schema.="" if="" no="" registration,="" then="" object-relational="" used=")" ="" onclick="footdisplay(1, "><sup>脚1</sup></a></p>
                     <p><a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFCFCDG">示例3-1</a>创建<code class="codeph">XMLType</code>列， <a href="how-to-use-XML-DB.html#GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFJACCB">示例3-2</a>创建<code class="codeph">XMLType</code>表。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFCFCDG">
                     <p class="titleinexample">示例3-1使用XMLType列创建表</p><pre class="pre codeblock"><code>CREATE TABLE mytable1（key_column VARCHAR2（10）PRIMARY KEY，xml_column <span class="bold">XMLType</span> ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5FDB0DB8-EE99-4DC4-9F73-49143026FD1B__BJFJACCB">
                     <p class="titleinexample">示例3-2创建XMLType表</p><pre class="pre codeblock"><code>CREATE TABLE mytable2 OF <span class="bold">XMLType</span> ;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XML-Schema-and-query-basic.html#GUID-A7862EBA-F10A-43BA-A540-933529E514E5" title="您可以创建受XML架构定义的全局元素约束的XMLType表和列。在XMLType列被约束到特定元素和特定模式之后，它只能包含符合该元素的模式定义的文档。">基于XML模式创建XMLType表和列</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6339"></a><a id="ADXDB6340"></a><a id="ADXDB6338"></a><div class="props_rev_3"><a id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" name="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242"></a><h3 id="ADXDB-GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" class="sect3"><span class="enumeration_section">3.2</span>在XMLType数据上创建虚拟列存储为二进制XML</h3>
               <div>
                  <p>您只能为存储为二进制XML的<code class="codeph">XMLType</code>数据创建虚拟列。这些列可用于分区或约束数据。
                  </p>
                  <div class="section">
                     <p>您为XML数据创建虚拟列的方式与为其他数据类型创建虚拟列的方式相同，但您使用的语法略有不同。（特别是，您不能指定与列定义关联的约束。）</p>
                     <p>您可以根据涉及该元素或属性的SQL表达式定义基于XML元素或属性的虚拟列。因此该列基于功能。</p>
                     <p>您可以使用SQL / XML函数<code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>来执行此操作，如<a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">示例3-3</a>和<a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">示例3-4中所示</a> 。函数<code class="codeph">XMLQuery</code>的XQuery表达式参数必须是仅使用子轴和属性轴的简单XPath表达式。
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">例3-3</a>创建<code class="codeph">XMLType</code>表<code class="codeph">po_binaryxml</code> ，存储为二进制XML。它创建虚拟列<code class="codeph">date_col</code> ，它表示属性<code class="codeph">/PurchaseOrder/@orderDate</code> <code class="codeph">date_col</code>的XML数据。
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">示例3-4</a>创建了关系表<code class="codeph">rel_tab</code> ，它有两列：主键的<code class="codeph">VARCHAR2</code>列<code class="codeph">key_col</code>和XML数据的<code class="codeph">XMLType</code>列<code class="codeph">xml_col</code> 。
                     </p>
                     <p>由于<code class="codeph">XMLType</code>是抽象数据类型，因此如果在<code class="codeph">XMLType</code>表或列上创建虚拟列，则会<span class="italic">隐藏</span>这些列。例如，它们不会出现在<code class="codeph">DESCRIBE</code>语句中。这种隐藏使得使用诸如<code class="codeph">DESCRIBE</code>操作的工具能够正常运行而不会被虚拟列误导。
                     </p>
                     <div class="infoboxnote" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__GUID-A0DFADB0-98D4-4242-BEFA-11783DCB7600">
                        <p class="notep1">注意：</p>
                        <p>如果使用虚拟列进行间隔分区，则它<span class="italic">必须</span>具有数据类型<code class="codeph">NUMBER</code>或<code class="codeph">DATE</code> ，否则会引发错误。使用SQL / XML函数<code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>转换为正确的数据类型。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__GUID-B28290E4-574E-45AB-A7E4-712A0D37729F">
                        <p class="notep1">也可以看看：</p>
                        <p>有关使用虚拟列创建表的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGJAJCH">
                     <p class="titleinexample">示例3-3在XMLType表中为XML属性创建虚拟列</p><pre class="pre codeblock"><code>CREATE TABLE po_binaryxml OF XMLType XMLTYPE STORE作为二进制XML <span class="bold">VIRTUAL COLUMNS</span> （date_col AS（XMLCast（XMLQuery（'/ PurchaseOrder / @orderDate'PASSING OBJECT_VALUE RETURNING CONTENT）AS DATE）））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C516A75D-519D-4599-ACFF-2837EB4F3242__CEGDDHBD">
                     <p class="titleinexample">示例3-4在XMLType列中为XML属性创建虚拟列</p><pre class="pre codeblock"><code>CREATE TABLE reltab（key_col VARCHAR2（10）PRIMARY KEY，xml_col XMLType）XMLTYPE xml_col存储为二进制XML <span class="bold">虚拟列</span> （date_col AS（XMLCast（XMLQuery（'/ PurchaseOrder / @orderDate'PASSING xml_col返回内容），日期）））;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" title="您可以对包含存储为二进制XML的XMLType数据的表进行分区。">对包含存储为二进制XML的XMLType数据的表进行分区</a></li>
                        <li><a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" title="您可以使用SQL约束和数据库触发器来确保数据完整性属性，例如唯一性和外键关系。">使用SQL约束实现参照完整性</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6342"></a><a id="ADXDB6343"></a><a id="ADXDB6341"></a><div class="props_rev_3"><a id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" name="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5"></a><h3 id="ADXDB-GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5" class="sect3"><span class="enumeration_section">3.3</span>对包含存储为二进制XML的XMLType数据的表进行分区</h3>
               <div>
                  <p>您可以对包含存储为二进制XML的<code class="codeph">XMLType</code>数据的表进行分区。</p>
                  <div class="section">
                     <p>有两种可能性：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该表是关系型的，具有<code class="codeph">XMLType</code>列和非<code class="codeph">XMLType</code>列。
                           </p>
                        </li>
                        <li>
                           <p>该表的数据类型为<code class="codeph">XMLType</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>对于<code class="codeph">XMLType</code>列，您使用非<code class="codeph">XMLType</code>列作为分区键。这在<a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCHHDE">例3-5中</a>说明。
                     </p>
                     <p>这个案例没有提供任何关于XML数据的新内容或特定内容。其中一列包含<code class="codeph">XMLType</code>数据这一事实无关紧要。对于另一种情况，情况有所不同：对<code class="codeph">XMLType</code>表进行分区。
                     </p>
                     <p>XML数据有自己的结构，（ <code class="codeph">XMLType</code>对象关系存储除外）不直接反映在数据库数据结构中。对于存储为二进制XML的<code class="codeph">XMLType</code>数据，单个XML元素和属性不会映射到单个数据库列或表。
                     </p>
                     <p>因此，为了根据各个元素或属性的值对二进制XML数据进行分区，关系数据的标准方法不适用。相反，你必须创建一个代表相关的XML数据<span class="italic">虚拟列</span> ，然后使用这些虚拟列来定义你需要的约束或分区。
                     </p>
                     <p>技术如下：</p>
                     <ol>
                        <li>
                           <p>定义与您感兴趣的XML元素或属性相对应的虚拟列。</p>
                        </li>
                        <li>
                           <p>使用这些列将<code class="codeph">XMLType</code>数据作为一个整体进行分区。
                           </p>
                        </li>
                     </ol>
                     <p><a href="how-to-use-XML-DB.html#GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCIJEF">示例3-6中</a>说明了这一点：虚拟列<code class="codeph">date_col</code>以采购订单文档中元素<code class="codeph">PurchaseOrder</code>的<code class="codeph">orderDate</code>属性为目标。此列用作分区键。
                     </p>
                     <p>为了使用包含XML数据的分区表获得最佳性能，Oracle建议您使用<code class="codeph">XMLType</code>列而不是<code class="codeph">XMLType</code>表，因此使用非<code class="codeph">XMLType</code>列进行分区。
                     </p>
                     <div class="infoboxnote" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__GUID-4D49DA2D-CDB6-4130-8B35-13F90D076A20">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>仅当存储模型是二进制XML时，才可以使用虚拟列对<code class="codeph">XMLType</code>表进行分区。支持范围，散列和列表分区。
                              </p>
                           </li>
                           <li>
                              <p>从11g第2版（11.2）开始，支持对存储为XML的<code class="codeph">XMLType</code>表进行分区。它仅支持如果数据库兼容性（参数<code class="codeph">compatible</code>文件<code class="codeph">init.ora</code> ）为11.2或更高。
                              </p>
                           </li>
                           <li>
                              <p>如果关系表具有<code class="codeph">XMLType</code> <span class="italic">列</span> ，则无法使用该列对表进行分区以定义XML数据的虚拟列。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCHHDE">
                     <p class="titleinexample">示例3-5对具有XMLType列的关系表进行分区</p><pre class="pre codeblock"><code>CREATE TABLE reltab（key_col VARCHAR2（10）PRIMARY KEY，xml_col XMLType）XMLTYPE xml_col存储作为BANGARY XML <span class="bold">PARTITION BY RANGE（key_col）</span> <span class="bold">（PARTITION P1值小于（'abc'），</span> <span class="bold">PARTITION P2值小于（MAXVALUE））</span> ;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DC3679D1-9963-4F1A-88B0-79A92032C9D5__CEGCIJEF">
                     <p class="titleinexample">示例3-6对XMLType表进行分区</p><pre class="pre codeblock"><code>CREATE TABLE po_binaryxml OF XMLType XMLTYPE STORE作为二进制XML <span class="bold">VIRTUAL COLUMNS</span> （date_col AS（XMLCast（XMLQuery（'/ PurchaseOrder / @ orderDate'PASSING OBJECT_VALUE RETURNING CONTENT）作为日期）））按<span class="bold">范围划分（date_col）</span> <span class="bold">（PARTITION orders2001 VALUES LESS）（ to_date（'01 -JAN-2002'）），</span> <span class="bold">PARTITION orders2002 VALUES LESS（MAXVALUE））</span> ;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="indexes-for-XMLType-data.html#GUID-7F44BE51-8F1A-487F-84CD-054E08F7A652" title="如果使用范围，列表或散列分区对XMLType表或具有XMLType列的表进行分区，则还可以在表上创建XMLIndex索引。您可以选择确保并行执行索引创建和维护。">XMLIndex分区和并行</a></li>
                        <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" title="使用对象关系存储的XMLType列对对象关系XMLType表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。">分区存储对象 - 关系的XMLType表和列的概述</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4101"></a><a id="ADXDB0345"></a><div class="props_rev_3"><a id="GUID-8320CE79-5536-4252-BAF4-746692EBA596" name="GUID-8320CE79-5536-4252-BAF4-746692EBA596"></a><h3 id="ADXDB-GUID-8320CE79-5536-4252-BAF4-746692EBA596" class="sect3"><span class="enumeration_section">3.4</span>使用数据库实施XML数据完整性</h3>
               <div>
                  <p>您可以将SQL和XML的强大功能与数据库强制执行规则的能力结合起来。</p>
                  <div class="section">
                     <p>您可以使用SQL来补充XML模式提供的功能。只有格式良好的XML文档才能存储在<code class="codeph">XMLType</code>表或列中。<strong class="term">格式良好的</strong> XML文档符合XML声明中声明的XML版本的语法。这包括具有单个根元素，正确嵌套的标记等。此外，如果<code class="codeph">XMLType</code>表或列被约束为XML模式，则只有符合该XML模式的文档才能存储在该表或列中。任何在基于XML模式的<code class="codeph">XMLType</code>存储或插入任何其他类型的XML文档的尝试都会引发错误。<a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596__BABCBCJJ">例3-7</a>说明了这一点。
                     </p>
                     <p>仅当将内容直接插入<code class="codeph">XMLType</code>表时才会发生此类错误。它表示Oracle XML DB无法将该文档识别为XML架构定义的类的成员。要使文档被识别为模式定义的类的成员，必须满足以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML文档根元素的名称必须与用于定义<code class="codeph">XMLType</code>表或列的全局元素的名称匹配。
                           </p>
                        </li>
                        <li>
                           <p>XML文档必须包含<code class="codeph">XMLSchema-instance</code>名称空间中的相应属性，或者XML文档必须使用<code class="codeph">XMLType</code>构造函数或<code class="codeph">XMLType</code>方法<code class="codeph">createSchemaBasedXML()</code>与XML模式显式关联。
                           </p>
                        </li>
                     </ul>
                     <p>如果约束XML模式声明了<code class="codeph">targetNamespace</code> ，则实例文档必须包含相应的名称空间声明，以将文档的根元素放在XML模式定义的<code class="codeph">targetNamespace</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-8320CE79-5536-4252-BAF4-746692EBA596__GUID-9A41BA8D-9224-4712-BB73-3D695C950734">
                        <p class="notep1">注意：</p>
                        <p>XML约束仅在单个XML文档中强制实施。跨多个XML文档强制实施数据库（SQL）约束。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-8320CE79-5536-4252-BAF4-746692EBA596__BABCBCJJ">
                     <p class="titleinexample">示例3-7尝试插入不正确的XML文档时出错</p><pre class="pre codeblock"><code>INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'Invoice.xml'），nls_charset_id（'AL32UTF8'）））VALUES（XMLType（bfilename（'XMLDIR'，'Invoice.xml'），nls_charset_id（'AL32UTF8'） ）））*第2行的错误：ORA-19007：架构 - 与预期的http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd不匹配。</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1">使用SQL约束实现参照完整性</a><br>您可以使用SQL约束和数据库触发器来确保数据完整性属性，例如唯一性和外键关系。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="transformation-and-validation-of-XMLType-data.html#GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" title="将基于XML模式的文档插入数据库时，可以部分或完全验证它们。">部分和完整XML模式验证</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4110"></a><a id="ADXDB6344"></a><a id="ADXDB6345"></a><a id="ADXDB4112"></a><a id="ADXDB4109"></a><div class="props_rev_3"><a id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" name="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1"></a><h4 id="ADXDB-GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" class="sect4"><span class="enumeration_section">3.4.1</span>使用SQL约束实现参照完整性</h4>
                  <div>
                     <p>您可以使用SQL约束和数据库触发器来确保数据完整性属性，例如唯一性和外键关系。</p>
                     <div class="section">
                        <p>W3C XML Schema Recommendation定义了一种用于定义XML文档内容的强大语言。但是，有一些简单的数据管理概念，W3C XML Schema Recommendation目前尚未解决这些概念。这些包括确保元素或属性的值具有以下任一属性的能力：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它在一组XML文档（ <code class="codeph">UNIQUE</code>约束）中是<code class="codeph">UNIQUE</code> 。
                              </p>
                           </li>
                           <li>
                              <p>它存在于当前文档之外的特定数据源中（ <code class="codeph">FOREIGN KEY</code>约束）。
                              </p>
                           </li>
                        </ul>
                        <p>但是，使用Oracle XML DB，您可以强制执行此类约束。用于强制XML数据完整性的机制与用于强制关系数据完整性的机制相同。可以通过指定SQL约束来强制执行简单规则，例如唯一性和外键关系。可以通过指定数据库触发器来实施更复杂的规则。</p>
                        <p>除了可以使用XML Schema构造指定的规则之外，Oracle XML DB还允许您使用数据库来强制执行XML内容的业务规则。无论XML是直接插入表还是使用Oracle XML DB Repository支持的协议之一上载，数据库都会强制执行这些业务规则。</p>
                        <p>XML数据有自己的结构，（ <code class="codeph">XMLType</code>对象关系存储除外）不直接反映在数据库数据结构中。对于存储为二进制XML的<code class="codeph">XMLType</code>数据，单个XML元素和属性不会映射到单个数据库列或表。
                        </p>
                        <p>因此，为了根据各个元素或属性的值约束二进制XML数据，关系数据的标准方法不适用。相反，你必须创建一个代表相关的XML数据<span class="italic">虚拟列</span> ，然后使用这些虚拟列来定义你所需要的约束。
                        </p>
                        <p>技术如下：</p>
                        <ol>
                           <li>
                              <p>定义与您感兴趣的XML元素或属性相对应的虚拟列。</p>
                           </li>
                           <li>
                              <p>使用这些列可以将<code class="codeph">XMLType</code>数据作为一个整体进行约束。
                              </p>
                           </li>
                        </ol>
                        <p>二进制XML数据可以位于关系表的<code class="codeph">XMLType</code>表或<code class="codeph">XMLType</code>列中。在前一种情况下，如果您愿意，可以包括创建约束作为<code class="codeph">CREATE TABLE</code>语句的一部分。对于后一种情况，必须在创建关系表后使用<code class="codeph">ALTER TABLE</code>语句创建约束。
                        </p>
                        <div class="infoboxnote" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__GUID-86132A6B-687F-46B6-981D-3A338085F5CD">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../errmg/index.html" target="_blank"><span><cite>Oracle数据库错误消息参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">
                        <p class="titleinexample">示例3-8使用虚拟列约束二进制XML表</p>
                        <p>此示例说明了<code class="codeph">XMLType</code>表的技术。它使用采购订单文档中的<code class="codeph">Reference</code>元素定义虚拟列<code class="codeph">c_xtabref</code> 。它在该列上定义了唯一性约束<code class="codeph">reference_is_unique</code> ，这确保了node <code class="codeph">/PurchaseOrder/Reference/text()</code>值在存储在表中的所有文档中是唯一的。它用<code class="codeph">OE.purchaseorder</code>的数据填充表格。然后它尝试插入一个违反唯一性约束的重复文档<code class="codeph">DuplicateReference.xml</code> ，从而引发错误。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_binaryxml OF XMLType（ <span class="bold">CONSTRAINT</span> reference_is_unique <span class="bold">UNIQUE</span> （ <span class="bold">c_xtabref</span> ））XMLTYPE STORE作为二进制XML <span class="bold">虚拟列</span> （ <span class="bold">c_xtabref</span> AS（XMLCast（XMLQuery（'/ PurchaseOrder / Reference'PASSING OBJECT_VALUE RETURNING CONTENT）AS VARCHAR2（32））））; INSERT INTO po_binaryxml SELECT OBJECT_VALUE FROM OE.purchaseorder;创建了132行。INSERT INTO po_binaryxml VALUES（XMLType（bfilename（'XMLDIR'，'DuplicateReference.xml'），nls_charset_id（'AL32UTF8'）））;在第1行INSERT INTO po_binaryxml * ERROR： <span class="bold">ORA-00001：违反了唯一约束（OE.REFERENCE_IS_UNIQUE）</span>
 </pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGHCEDI">
                        <p class="titleinexample">示例3-9使用虚拟列约束二进制XML列：唯一性</p>
                        <p>此示例说明了关系表的<code class="codeph">XMLType</code>列的技术。它定义了虚拟列<code class="codeph">c_xcolref</code>和唯一性约束<code class="codeph">fk_ref</code> ，它引用了<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">例3-8中</a>定义的唯一性约束。与<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">示例3-8中一样</a> ，这确保了node <code class="codeph">/PurchaseOrder/Reference/text()</code>值在存储在<code class="codeph">XMLType</code>列<code class="codeph">po_binxml_col</code>所有文档中是唯一的。
                        </p>
                        <p>该示例使用<code class="codeph">OE.purchaseorder</code>的相同数据填充<code class="codeph">XMLType</code>列。然后它尝试插入违反唯一性约束的重复文档<code class="codeph">DuplicateReference.xml</code> ，从而引发错误。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_reltab（po_binxml_col XMLType）XMLTYPE po_binxml_col存储为二进制XML虚拟列（ <span class="bold">c_xcolref</span> AS（XMLCast（XMLQuery（'/ PurchaseOrder / Reference'PASSING po_binxml_col RETURNING CONTENT）AS VARCHAR2（32））））; ALTER TABLE po_reltab <span class="bold">ADD CONSTRAINT</span> reference_is_unique <span class="bold">UNIQUE</span> （ <span class="bold">c_xcolref</span> ））; INSERT INTO po_reltab SELECT OBJECT_VALUE FROM OE.purchaseorder; INSERT INTO po_reltab VALUES（XMLType（bfilename（'XMLDIR'，'DuplicateReference.xml'），nls_charset_id（'AL32UTF8'）））;在第1行INSERT INTO po_reltab * ERROR： <span class="bold">ORA-00001：违反了唯一约束（OE.REFERENCE_IS_UNIQUE）</span>
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGDJJFJ">
                        <p class="titleinexample">示例3-10使用虚拟列约束二进制XML列：外键</p>
                        <p>此示例与<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CEGHCEDI">示例3-9</a>类似，但它使用外键约束<code class="codeph">fk_ref</code> ，该约束引用具有<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">示例3-8中</a>定义的唯一性约束的列。在文件<code class="codeph">DuplicateReference.xml</code>插入文档在此处成功，因为该文档位于表<code class="codeph">po_binaryxml</code> （虚拟）列<code class="codeph">c_tabref</code>中。插入与表<code class="codeph">po_binaryxml</code>中的任何文档都不匹配的文档。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE po_reltab（po_binxml_col XMLType）XMLTYPE po_binxml_col存储为二进制XML虚拟列（ <span class="bold">c_xcolref</span> AS（XMLCast（XMLQuery（'/ PurchaseOrder / Reference'PASSING po_binxml_col RETURNING CONTENT）AS VARCHAR2（32））））; ALTER TABLE po_reltab <span class="bold">ADD CONSTRAINT fk_ref FOREIGN KEY（c_xcolref）</span> <span class="bold">REFERENCES po_binaryxml（c_xtabref）;</span> INSERT INTO po_reltab VALUES（XMLType（bfilename（'XMLDIR'，'DuplicateReference.xml'），nls_charset_id（'AL32UTF8'）））; INSERT INTO po_reltab VALUES（' <span class="bold">&lt;PurchaseOrder&gt; &lt;Reference&gt; Not Compliant &lt;/ Reference&gt; &lt;/ PurchaseOrder&gt;</span> '）; INSERT INTO po_reltab VALUES（'&lt;PurchaseOrder&gt; &lt;Reference&gt; Not Compliant &lt;/ Reference&gt; &lt;/ PurchaseOrder&gt;'）*第1行的错误： <span class="bold">ORA-02291：违反完整性约束（OE.FK_REF） - 未找到父键</span>
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__BABHEHEG">
                        <p class="titleinexample">示例3-11使用FTP加载XML时强制执行数据库完整性</p>
                        <p>当基于XML模式的XML内容加载到Oracle XML DB Repository时，也会强制使用约束和触发器定义的完整性规则。此示例显示，当使用协议（如FTP）将基于XML模式的XML内容上载到Oracle XML DB存储库时，也会强制执行数据库完整性。在这种情况下，除了唯一性之外，还违反了其他约束。</p><pre class="oac_no_warn" dir="ltr">$ ftp localhost 2100已连接到localhost。220 mdrake-sun FTP服务器（Oracle XML DB / Oracle数据库10g企业版10.1.0.0.0版 -  Beta）准备就绪。名称（localhost：oracle10）：QUINE 331 QUINE密码所需的密码： <span class="italic">密码</span> 230 QUINE登录ftp&gt; cd / source / schemas 250 CWD命令成功ftp&gt; put InvalidReference.xml 200 PORT命令成功150 ASCII数据连接550-错误响应ORA -00604：递归SQL级别1发生错误ORA-31154：XML文档无效ORA-19202：XML处理错误LSX-00221：“SBELL-20021009”太短（最小长度为18）ORA-06512：at“ SYS.XMLTYPE“，第333行ORA-06512：at”QUINE.VALIDATE_PURCHASEORDER“，第3行ORA-04088：执行触发器'QUINE.VALIDATE_PURCHASEORDER'时出错550结束错误响应ftp&gt; put InvalidElement.xml 200 PORT命令成功150 ASCII数据连接550-错误响应ORA-30937：父“PurchaseOrder”中的“UserName”（命名空间“## local”）没有模式定义550结束错误响应ftp&gt; put DuplicateReference.xml 200 PORT命令成功150 ASCII数据连接550-错误响应ORA-00604：重复发生错误sive SQL级别1 ORA-00001：违反了唯一约束（QUINE.REFERENCE_IS_UNIQUE）550结束错误响应ftp&gt; put InvalidUser.xml 200 PORT命令成功150 ASCII数据连接550-错误响应ORA-00604：递归SQL级别1 ORA发生错误-02291：违反了完整性约束（QUINE.USER_IS_VALID） - 未找到父键550结束错误响应</pre><p>使用协议上载文档时发生错误时，Oracle XML DB会为客户端提供完整的SQL错误跟踪。如何解释错误并向您报告错误由客户端应用程序中内置的错误处理决定。某些客户端（如命令行FTP工具）报告Oracle XML DB返回的错误，而其他客户端（如Microsoft Windows资源管理器）则报告一般错误消息。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA" title="对于以对象关系存储的XMLType数据，您可以为在XML文档中仅出现一次的元素和属性指定典型的关系约束。">XMLType表和列的关系约束规范</a></li>
                           <li><a href="how-to-use-XML-DB.html#GUID-C516A75D-519D-4599-ACFF-2837EB4F3242" title="您只能为存储为二进制XML的XMLType数据创建虚拟列。这些列可用于分区或约束数据。">在存储为二进制XML的XMLType数据上创建虚拟列</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596" title="您可以将SQL和XML的强大功能与数据库强制执行规则的能力结合起来。">使用数据库强制执行XML数据完整性</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4048"></a><div class="props_rev_3"><a id="GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" name="GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B"></a><h3 id="ADXDB-GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" class="sect3"><span class="enumeration_section">3.5将</span> XML内容加载到Oracle XML DB中</h3>
               <div>
                  <p>有几种方法可以将XML内容加载到Oracle XML DB中。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-23956CE8-C61D-4178-968E-5686CAD80C08">使用SQL或PL / SQL加载XML内容</a><br></li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE">使用Java加载XML内容</a><br>使用DOM，您可以使用Java来加载<code class="codeph">SQLXML</code>实例。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-23802182-8EF2-46C5-966B-03D9F11A258D">使用C加载XML内容</a><br>使用DOM，您可以使用C代码加载<code class="codeph">XMLType</code>实例。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-B271C430-A1FB-4818-A3F4-056C59CC5553">加载包含小型XML文档的大型XML文件</a><br>在加载由一组较小的XML文档组成的大型XML文件时，使用Simple API for XML（SAX）解析将文件分解为一组较小的文档，然后插入这些文档通常会更有效。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-157EE50B-6004-4B30-BC85-AC60581C930E">使用SQL * Loader加载大型XML文件</a><br>您可以使用SQL * Loader将大量XML数据加载到Oracle数据库中。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B">使用DBMS_XDB_REPOS将XML文档加载到存储库中</a><br>您可以使用PL / SQL包<code class="codeph">DBMS_XDB_REPOS</code>将XML文档加载到Oracle XML DB存储库中。您可以使用基于路径的技术而不是基于表的技术来访问存储库文档（资源）。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-C4D83D80-7B69-4C57-B817-2699722D28A3">使用协议将文档加载到存储库</a><br>您可以使用流行的协议将文档（包括XML文档）从本地文件系统加载到Oracle XML DB Repository中。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5988"></a><a id="ADXDB4051"></a><a id="ADXDB4049"></a><div class="props_rev_3"><a id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08" name="GUID-23956CE8-C61D-4178-968E-5686CAD80C08"></a><h4 id="ADXDB-GUID-23956CE8-C61D-4178-968E-5686CAD80C08" class="sect4"><span class="enumeration_section">3.5.1</span>使用SQL或PL / SQL加载XML内容</h4>
                  <div>
                     <div class="section">
                        <p>您可以在SQL或PL / SQL中使用简单的<code class="codeph">INSERT</code>操作将XML文档加载到数据库中。
                        </p>
                        <p>在将文档存储为<code class="codeph">XMLType</code>列或表之前，必须使用其中一个<code class="codeph">XMLType</code>构造函数将其转换为<code class="codeph">XMLType</code>实例。
                        </p>
                        <p><code class="codeph">XMLType</code> <strong class="term">构造函数</strong>允许从不同的源创建<code class="codeph">XMLType</code>实例，包括<code class="codeph">VARCHAR</code> ， <code class="codeph">CLOB</code>和<code class="codeph">BFILE</code>值。构造函数接受其他参数，以减少与<code class="codeph">XMLType</code>创建相关的处理量。例如，如果您确定给定的源XML文档是有效的，则可以为构造函数提供一个参数，该参数禁用否则执行的类型检查。
                        </p>
                        <p>此外，如果源数据未在数据库字符集中编码，则可以使用<code class="codeph">BFILE</code>或<code class="codeph">BLOB</code>值构造<code class="codeph">XMLType</code>实例。源数据的编码通过构造函数的字符集id（ <code class="codeph">csid</code> ）参数指定。
                        </p>
                        <p>当您使用SQL <code class="codeph">INSERT</code>将包含集合的大型文档插入<code class="codeph">XMLType</code>表（但不会插入<code class="codeph">XMLType</code>列）时，Oracle XML DB会优化加载时间和内存使用情况。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-23956CE8-C61D-4178-968E-5686CAD80C08__BABBBGBB">示例3-13</a>显示了如何将XML内容插入<code class="codeph">XMLType</code>表。在进行此插入之前，必须创建一个数据库目录对象，该对象指向包含要处理的文件的目录。为此，您必须具有<code class="codeph">CREATE ANY DIRECTORY</code>权限。
                        </p>
                        <div class="infoboxnotealso" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__GUID-D6EE23F5-FEB6-4D98-B918-7C02B67091E3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../arpls/XMLTYPE.html#ARPLS369" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，以获取<code class="codeph">XMLType</code>构造函数的描述</p>
                              </li>
                              <li>
                                 <p> <code class="codeph">GRANT</code>下的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=SQLRF01603" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__GUID-76473048-4E3F-4B67-9223-3F92341984AE">
                        <p class="titleinexample">示例3-12创建数据库目录</p><pre class="oac_no_warn" dir="ltr">CREATE DIRECTORY xmldir AS <span class="italic">path_to_folder_containing_XML_file</span> ;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23956CE8-C61D-4178-968E-5686CAD80C08__BABBBGBB">
                        <p class="titleinexample">示例3-13将XML内容插入XMLType表</p><pre class="oac_no_warn" dir="ltr">INSERT INTO mytable2 VALUES（XMLType（bfilename（'XMLDIR'，'purchaseOrder.xml'），nls_charset_id（'AL32UTF8'）））;</pre><p>传递给<code class="codeph">nls_charset_id</code>的值表示要读取的文件的编码是UTF-8。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">查询和更新XML数据</a></li>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39" title="描述了XMLType的PL / SQL应用程序编程接口（API）。">XMLType的PL / SQL API：参考</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D" title="Oracle XML DB配置文件xdbconfig.xml具有控制加载操作使用的内存量的参数：xdbcore-loadableunit-size和xdbcore-xobmem-bound。">使用集合加载和检索大型文档的注意事项</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4053"></a><a id="ADXDB4052"></a><div class="props_rev_3"><a id="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE" name="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE"></a><h4 id="ADXDB-GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE" class="sect4"><span class="enumeration_section">3.5.2</span>使用Java加载XML内容</h4>
                  <div>
                     <p>使用DOM，您可以使用Java来加载<code class="codeph">SQLXML</code>实例。
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE__BABIEIAD">示例3-14</a>显示了如何在给定文档对象模型（ <a href="../adxdk/glossary.html#ADXDK9548" target="_blank">DOM</a> ）的情况下首先在Java中创建<code class="codeph">SQLXML</code>实例，从而将XML内容加载到Oracle XML DB中。
                        </p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">OTN</a>上的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">Oracle XML DB</a>提供了一个简单的批量加载器应用程序。它展示了如何使用Java数据库连接（JDBC）将XML文件目录加载到Oracle XML DB中。JDBC是Oracle数据库的一组Java接口。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D6D8A756-DA60-4E5F-8E62-C582959273BE__BABIEIAD">
                        <p class="titleinexample">示例3-14使用Java将内容插入XMLType表</p><pre class="pre codeblock"><code>public void doInsert（Connection conn，Document doc）抛出异常{String query =“ <span class="bold">INSERT INTO purchaseorder VALUES（？）</span>“; SQLXML SX =康恩<span class="bold">createSQLXML（）;</span> DOMResult DOM = sx.setResult（DOMResult.class）; dom.setNode（DOC）; PreparedStatement的语句= conn.prepareStatement（查询）;语句<span class="bold">setSQLXML（1，SX）;</span>语句。执行（）; }</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4055"></a><a id="ADXDB4054"></a><div class="props_rev_3"><a id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D" name="GUID-23802182-8EF2-46C5-966B-03D9F11A258D"></a><h4 id="ADXDB-GUID-23802182-8EF2-46C5-966B-03D9F11A258D" class="sect4"><span class="enumeration_section">3.5.3</span>使用C加载XML内容</h4>
                  <div>
                     <p>使用DOM，您可以使用C代码加载<code class="codeph">XMLType</code>实例。
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-23802182-8EF2-46C5-966B-03D9F11A258D__BJFGHJDC">示例3-15</a>显示了如何使用C代码将XML内容插入到<code class="codeph">XMLType</code>表中，方法是创建给定DOM的<code class="codeph">XMLType</code>实例（请参阅<a href="../adxdk/glossary.html#ADXDK9548" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> ）。有关此示例的完整列表，请参阅<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-E357126F-BFCE-4A51-A559-520FE64DA756" title="提供了将XML数据插入XMLType表的C程序的完整列表。">使用C（OCI）加载XML数据</a> 。
                        </p>
                        <div class="infoboxnote" id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D__GUID-594E0B44-DB29-4055-B4D4-4A241248D56B">
                           <p class="notep1">注意：</p>
                           <p>为了简化演示此功能，此示例不执行已部署系统通常使用的密码管理技术。在生产环境中，请遵循Oracle数据库密码管理准则，并禁用任何示例帐户。有关密码管理指南和其他安全建议，请参阅<a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span><cite>Oracle数据库安全指南</cite></span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23802182-8EF2-46C5-966B-03D9F11A258D__BJFGHJDC">
                        <p class="titleinexample">示例3-15使用C将内容插入XMLType表</p><pre class="pre codeblock"><code><span class="bold">。 。 。</span>void main（）{OCIType * xmltdo; xmldocnode * doc; ocixmldbparam params [1]; xmlerr错误; xmlctx * xctx; oratext * ins_stmt;剑的地位; xmlnode * root; oratext buf [10000]; / *初始化envhp，svchp，errhp，dur，stmthp * / init_oci_connect（）; / *获取XML上下文* / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆dur; xctx = <span class="bold">OCIXmlDbInitXmlCtx</span> （envhp，svchp，errhp，params，1）;如果（！（doc = XmlLoadDom（xctx，＆err，“file”，filename，“schema_location”，schemaloc，NULL）））{printf（“Parse failed。\ n”）;返回; } else printf（“Parse succeeded。\ n”）; root = <span class="bold">XmlDomGetDocElem</span> （xctx，doc）; printf（“xml文档是：\ n”）; XmlSaveDom（xctx，＆err，（xmlnode *）doc，“buffer”，buf，“buffer_length”，10000，NULL）; printf（“％s \ n”，buf）; / *将文档插入my_table * / ins_stmt =（oratext *）“insert into purchaseorder values（：1）”; status = OCITypeByName（envhp，errhp，svchp，（const text *）“SYS”，（ub4）strlen（（const char *）“SYS”），（const text *）“XMLTYPE”，（ub4）strlen（（const char *）“XMLTYPE”），（CONST text *）0，（ub4）0，OCI_DURATION_SESSION，OCI_TYPEGET_HEADER，（OCIType **）＆xmltdo）; if（status == OCI_SUCCESS）{status = exec_bind_xml（svchp，errhp，stmthp，（void *）doc，xmltdo，ins_stmt）; } if（status == OCI_SUCCESS）printf（“Insert successful \ n”）; else printf（“插入失败\ n”）; / *免费XML实例* / if（doc）XmlFreeDocument（（xmlctx *）xctx，（xmldocnode *）doc）; / * Free XML CTX * / <span class="bold">OCIXmlDbFreeXmlCtx</span> （xctx）; free_oci（）; }</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4056"></a><div class="props_rev_3"><a id="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553" name="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553"></a><h4 id="ADXDB-GUID-B271C430-A1FB-4818-A3F4-056C59CC5553" class="sect4"><span class="enumeration_section">3.5.4</span>加载包含小型XML文档的大型XML文件</h4>
                  <div>
                     <p>在加载由一组较小的XML文档组成的大型XML文件时，使用Simple API for XML（SAX）解析将文件分解为一组较小的文档，然后插入这些文档通常会更有效。</p>
                     <div class="section">
                        <p>SAX是XML解析器为基于事件的应用程序提供的XML标准接口。通过从节点集合创建单个文档，可以使用SAX从大小为30 MB或更大的XML文件加载数据库表。您还可以批量加载XML文件。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-B271C430-A1FB-4818-A3F4-056C59CC5553__GUID-9F5AF3AE-1805-4D38-9F83-B6B3F8803B42">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关SAX的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=sax_project_org" target="_blank">SAX项目</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">OTN上的Oracle XML DB</a> ，用于使用SAX加载大型文件的应用程序示例</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4058"></a><a id="ADXDB4057"></a><div class="props_rev_3"><a id="GUID-157EE50B-6004-4B30-BC85-AC60581C930E" name="GUID-157EE50B-6004-4B30-BC85-AC60581C930E"></a><h4 id="ADXDB-GUID-157EE50B-6004-4B30-BC85-AC60581C930E" class="sect4"><span class="enumeration_section">3.5.5</span>使用SQL * Loader加载大型XML文件</h4>
                  <div>
                     <p>您可以使用SQL * Loader将大量XML数据加载到Oracle数据库中。</p>
                     <div class="section">
                        <p>SQL * Loader以两种模式之一加载，即常规路径或直接路径。<a href="how-to-use-XML-DB.html#GUID-157EE50B-6004-4B30-BC85-AC60581C930E__BJFJFHIF" title="此表比较了SQL * Loader常规模式和直接加载模式。">表3-1</a>比较了这些模式。
                        </p>
                        <div class="tblformal" id="GUID-157EE50B-6004-4B30-BC85-AC60581C930E__BJFJFHIF">
                           <p class="titleintable">表3-1 SQL * Loader  - 常规和直接路径加载模式</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SQL * Loader  - 常规和直接路径加载模式" width="100%" border="1" summary="This tables compares SQL*Loader Conventional and Direct Load Modes." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="53%" id="d14886e1654">传统的加载模式</th>
                                    <th align="left" valign="bottom" width="47%" id="d14886e1657">直接路径加载模式</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1662" headers="d14886e1654 ">
                                       <p>使用SQL将数据加载到Oracle数据库中。这是<span class="italic">默认</span>模式。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1662 d14886e1657 ">
                                       <p>绕过SQL并将数据直接流式传输到Oracle数据库。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1672" headers="d14886e1654 ">
                                       <p><span class="italic">优点：</span>遵循SQL语义。例如触发触发器并检查约束。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1672 d14886e1657 ">
                                       <p><span class="italic">优点：</span>这比传统的负载模式更快地加载数据。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="53%" id="d14886e1683" headers="d14886e1654 ">
                                       <p><span class="italic">缺点：</span>加载数据的速度比直接加载模式慢。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="47%" headers="d14886e1683 d14886e1657 ">
                                       <p><span class="italic">缺点：</span>不遵守SQL语义。例如，不触发触发器，也不检查约束。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>使用SQL * Loader直接路径加载加载LOB时，可以使用大量内存。如果出现消息<code class="codeph">SQL*Loader 700 (out of memory)</code> ，则每次加载调用中可能包含的行数可能超过操作系统和进程内存可处理的行数。<span class="italic">解决方法：</span>使用<code class="codeph">ROWS</code>选项在每个数据保存中读取较少的行数。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="how-to-load-XML-data.html#GUID-B94D42C1-A20A-457A-8427-C01E39788EA1" title="将XML数据加载到Oracle XML DB的主要方法是使用SQL * Loader。">如何加载XML数据</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4060"></a><a id="ADXDB4059"></a><div class="props_rev_3"><a id="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B" name="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B"></a><h4 id="ADXDB-GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B" class="sect4"><span class="enumeration_section">3.5.6</span>使用DBMS_XDB_REPOS将XML文档加载到存储库</h4>
                  <div>
                     <p>您可以使用PL / SQL包<code class="codeph">DBMS_XDB_REPOS</code>将XML文档加载到Oracle XML DB存储库中。您可以使用基于路径的技术而不是基于表的技术来访问存储库文档（资源）。
                     </p>
                     <div class="section">
                        <p>要将XML文档加载到给定路径下的存储库中，请使用PL / SQL函数<code class="codeph">DBMS_XDB_REPOS.createResource</code> 。<a href="how-to-use-XML-DB.html#GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B__BJFICDCH">例3-16</a>说明了这一点。
                        </p>
                        <p>许多用于配置和使用Oracle XML DB的操作都基于处理一个或多个XML文档。示例包括注册XML模式和执行XSL转换。使这些XML文档可供Oracle数据库使用的最简单方法是将它们加载到Oracle XML DB Repository中。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C4F1105F-BB2F-4700-9EC1-5075EB0ED38B__BJFICDCH">
                        <p class="titleinexample">示例3-16使用CREATERESOURCE将XML内容插入存储库</p><pre class="pre codeblock"><code>DECLARE res BOOLEAN; BEGIN res：= DBMS_XDB_REPOS.createResource（'/ home / QUINE / purchaseOrder.xml'，bfilename（'XMLDIR'，'purchaseOrder.xml'），nls_charset_id（'AL32UTF8'））;结束;/</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4062"></a><a id="ADXDB4061"></a><div class="props_rev_3"><a id="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3" name="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3"></a><h4 id="ADXDB-GUID-C4D83D80-7B69-4C57-B817-2699722D28A3" class="sect4"><span class="enumeration_section">3.5.7</span>使用协议将文档加载到存储库</h4>
                  <div>
                     <p>您可以使用流行的协议将文档（包括XML文档）从本地文件系统加载到Oracle XML DB Repository中。</p>
                     <div class="section">
                        <p>Oracle XML DB Repository可以存储基于XML模式或非基于模式的XML文档。它还可以存储非XML数据的内容，例如HTML文件，图像文件和Microsoft Word文档。</p>
                        <p>您可以使用WebDAV，Windows资源管理器或支持WebDAV的其他工具等协议（如WebDAV）将XML文档从本地文件系统加载到Oracle XML DB Repository中。 <a href="how-to-use-XML-DB.html#GUID-C4D83D80-7B69-4C57-B817-2699722D28A3__CHDHJDAE">图3-1</a>显示了一个简单的拖放操作，用于将<code class="codeph">SCOTT</code>文件夹的内容从本地硬盘驱动器复制到Oracle XML DB Repository中的文件夹<code class="codeph">poSource</code> 。
                        </p>
                        <div class="figure" id="GUID-C4D83D80-7B69-4C57-B817-2699722D28A3__CHDHJDAE">
                           <p class="titleinfigure">图3-1使用Windows资源管理器将内容加载到存储库</p><img src="img/repo_load.gif" width="478" alt="下面是图3-1的描述" title="下面是图3-1的描述" longdesc="img_text/repo_load.html"><br><a href="img_text/repo_load.html">“图3-1使用Windows资源管理器将内容加载到存储库”的描述</a></div>
                        <!-- class="figure" -->
                        <p>复制的文件夹可能包含，例如，XML架构文档，HTML页面和一些XSLT样式表。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：将</strong> <a href="how-to-use-XML-DB.html#GUID-0FD6B1AD-DEB6-4493-859A-163F0711455B" title="有几种方法可以将XML内容加载到Oracle XML DB中。">XML内容加载到Oracle XML DB中</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4116"></a><div class="props_rev_3"><a id="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" name="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75"></a><h3 id="ADXDB-GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" class="sect3"><span class="enumeration_section">3.6</span>查询Oracle XML DB中存储的XML内容</h3>
               <div>
                  <p>有许多方法可以在Oracle XML DB中查询XML内容并检索它。</p>
                  <div class="infoboxnote" id="GUID-D937B3D1-BA54-41D0-9428-4739DA805D75__GUID-EBDA1BAC-73E1-44E9-AE6B-5DBC5D5855FD">
                     <p class="notep1">注意：</p>
                     <p>为了提高查询性能，通常需要创建索引。有关索引XML数据的信息，请参阅<a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="您可以在XML数据上创建索引，专注于经常查询的特定部分，从而提高性能。您可以通过多种方式索引XMLType数据，无论是基于XML模式还是非基于模式，无论您使用何种XMLType存储模型。">XMLType数据的索引</a> 。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C">示例中使用的PurchaseOrder XML文档</a><br>XML模式定义了示例中使用的采购订单文档。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-42EDC657-C53B-441F-96E3-31E755A7A30E">使用伪列OBJECT_VALUE检索XML文档的内容</a><br>伪列<code class="codeph">OBJECT_VALUE</code>可用作对象表值的别名。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C">使用XMLQUERY访问XML文档的片段或节点</a><br>您可以使用SQL / XML函数<code class="codeph">XMLQuery</code>来提取与XQuery表达式匹配的节点。结果作为<code class="codeph">XMLType</code>的实例返回。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3">使用XMLCAST和XMLQUERY访问文本节点和属性值</a><br>您可以使用SQL / XML标准函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLCast</code>访问文本节点和属性值。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F">使用XMLEXISTS，XMLCAST和XMLQUERY搜索XML文档</a><br>您可以在SQL <code class="codeph">WHERE</code>子句中使用SQL / XML标准函数<code class="codeph">XMLExists</code> ， <code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>来限制查询结果。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532">使用XMLTABLE在XMLType片段上执行SQL操作</a><br>您可以使用SQL / XML函数<code class="codeph">XMLTable</code>在与XQuery表达式匹配的一组节点上执行SQL操作。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4118"></a><a id="ADXDB4117"></a><div class="props_rev_3"><a id="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C" name="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C"></a><h4 id="ADXDB-GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C" class="sect4"><span class="enumeration_section">3.6.1</span>示例中使用的PurchaseOrder XML文档</h4>
                  <div>
                     <p>XML模式定义了示例中使用的采购订单文档。</p>
                     <div class="section">
                        <p>此处提供的示例基于<a href="how-to-use-XML-DB.html#GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C__BJFDAFHE">示例3-17中</a>显示的<code class="codeph">PurchaseOrder</code> XML文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-606F790D-41F5-4EF5-A9D6-2FC4587CE28C__BJFDAFHE">
                        <p class="titleinexample">示例3-17 PurchaseOrder XML实例文档</p><pre class="pre codeblock"><code>&lt;PurchaseOrder xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：noNamespaceSchemaLocation =“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”&gt; &lt;参考&gt; SBELL-2002100912333601PDT &lt;/ Reference&gt; &lt;Actions&gt; &lt;Action&gt; &lt;User&gt; SVOLLMAN &lt;/ User&gt; &lt;/ Action&gt; &lt;/ Actions&gt; &lt;Reject /&gt; &lt;Requestor&gt; Sarah J. Bell &lt;/ Requestor&gt; &lt;User&gt; SBELL &lt;/ User&gt; &lt;CostCenter&gt; S30 &lt;/ CostCenter&gt; &lt;ShippingInstructions&gt; &lt;name&gt; Sarah J. Bell &lt;/ name&gt; &lt;地址&gt; 400 Oracle Parkway Redwood Shores CA 94065 USA &lt;/ address&gt; &lt;telephone&gt; 650 506 7400 &lt;/ telephone &gt; &lt;/ ShippingInstructions&gt; &lt;SpecialInstructions&gt; Air Mail &lt;/ SpecialInstructions&gt; &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt;要记住的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity = “2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;Description&gt;难以忍受的轻盈&lt;/ Description&gt; &lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020”U nitPrice =“29.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; &lt;/ PurchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4120"></a><a id="ADXDB4119"></a><div class="props_rev_3"><a id="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E" name="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E"></a><h4 id="ADXDB-GUID-42EDC657-C53B-441F-96E3-31E755A7A30E" class="sect4"><span class="enumeration_section">3.6.2</span>使用伪列OBJECT_VALUE检索XML文档的内容</h4>
                  <div>
                     <p>伪列<code class="codeph">OBJECT_VALUE</code>可用作对象表值的别名。
                     </p>
                     <div class="section">
                        <p>对于由单个<code class="codeph">XMLType</code>列组成的<code class="codeph">XMLType</code>表，将检索整个XML文档。（ <code class="codeph">OBJECT_VALUE</code>替换Oracle Database 10g第1版之前的版本中使用的<code class="codeph">value(x)</code>和<code class="codeph">SYS_NC_ROWINFO$</code>别名。）
                        </p>
                        <p>在<a href="how-to-use-XML-DB.html#GUID-42EDC657-C53B-441F-96E3-31E755A7A30E__BJFCECGJ">示例3-18中</a> ，SQL * Plus设置<code class="codeph">PAGESIZE</code>和<code class="codeph">LONG</code>用于确保正确打印整个文档，而不会出现换行符。（输出已格式化以便于阅读。）
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-42EDC657-C53B-441F-96E3-31E755A7A30E__BJFCECGJ">
                        <p class="titleinexample">示例3-18使用OBJECT_VALUE检索整个XML文档</p><pre class="pre codeblock"><code>从购买订单中选择OBJECT_VALUE; OBJECT_VALUE ------------------------------------------------- ---------------------- &lt;PurchaseOrder xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：noNamespaceSchemaLocation =“ http：// localhost：8080 / source / schemas /poSource/xsd/purchaseOrder.xsd“&gt; &lt;参考&gt; SBELL-2002100912333601PDT &lt;/ Reference&gt; &lt;Actions&gt; &lt;Action&gt; &lt;User&gt; SVOLLMAN &lt;/ User&gt; &lt;/ Action&gt; &lt; /操作&gt; &lt;拒绝/&gt; &lt;请求者&gt; Sarah J. Bell &lt;/ Requestor&gt; &lt;用户&gt; SBELL &lt;/用户&gt; &lt;CostCenter&gt; S30 &lt;/ CostCenter&gt; &lt;ShippingInstructions&gt; &lt;name&gt; Sarah J. Bell &lt;/ name&gt; &lt;地址&gt; 400 Oracle Parkway Redwood Shores CA 94065 USA &lt;/ address&gt; &lt;telephone&gt; 650 506 7400 &lt;/ telephone&gt; &lt;/ ShippingInstructions&gt; &lt;SpecialInstructions&gt; Air Mail &lt;/ SpecialInstructions&gt; &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt;一个难忘的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;Description&gt;难以承受的轻盈&lt;/ Description &gt; &lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt; LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020”UnitPrice =“29.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; &lt;/ PurchaseOrder&gt;选择了1行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4122"></a><a id="ADXDB4121"></a><div class="props_rev_3"><a id="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C" name="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C"></a><h4 id="ADXDB-GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C" class="sect4"><span class="enumeration_section">3.6.3</span>使用XMLQUERY访问XML文档的片段或节点</h4>
                  <div>
                     <p>您可以使用SQL / XML函数<code class="codeph">XMLQuery</code>来提取与XQuery表达式匹配的节点。结果作为<code class="codeph">XMLType</code>的实例返回。
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">示例3-19</a>通过多个查询说明了这一点。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">
                        <p class="titleinexample">示例3-19使用XMLQUERY访问XML片段</p>
                        <p>以下查询返回包含与XPath表达式匹配的<code class="codeph">Reference</code>元素的<code class="codeph">XMLType</code>实例。
                        </p><pre class="pre codeblock"><code>来自purchaseorder的SELECT XMLQuery（'/ PurchaseOrder / Reference'PASSING OBJECT_VALUE RETURNING CONTENT）; XMLQUERY（'/ PURCHASEORDER / REFERENCE'PASSINGOBJECT_ ----------------------------------------- -------- &lt;参考&gt; SBELL-2002100912333601PDT &lt;/ Reference&gt;选择1行。
</code></pre><p>以下查询返回包含<code class="codeph">LineItems</code>集合中第一个<code class="codeph">LineItem</code>元素的<code class="codeph">XMLType</code>实例：</p><pre class="pre codeblock"><code>来自purchaseorder的SELECT XMLQuery（'/ PurchaseOrder / LineItems / LineItem [1]'PASSING OBJECT_VALUE RETURNING CONTENT）; XMLQUERY（'/ PURCHASEORDER / LINEITEMS / LINEITEM [1]'PASSINGOBJECT_ ------------------------------------ ------------------------- &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt;值得纪念的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058 “UnitPrice =”39.95“Quantity =”2“/&gt; &lt;/ LineItem&gt;选择了1行。
</code></pre><p>以下查询返回一个<code class="codeph">XMLType</code>实例，该实例包含与XPath表达式匹配的三个<code class="codeph">Description</code>元素。这些元素作为单个<code class="codeph">XMLType</code>实例中的节点返回。<code class="codeph">XMLType</code>实例没有单个根节点;它是一个XML <span class="italic">片段</span> 。
                        </p><pre class="pre codeblock"><code>从purchaseorder中选择XMLQuery（'/ / PurchaseOrder / LineItems / LineItem / Description'PASSING OBJECT_VALUE RETURNING CONTENT）; XMLQUERY（'/ PURCHASEORDER / LINEITEMS / LINEITEM / DESCRIPTION'PASSINGOBJECT_ ------------------------------------- --------------------------------- &lt;Description&gt;值得纪念的夜晚&lt;/ Description&gt; &lt;Description&gt;难以忍受的轻盈存在&lt;/ Description&gt; &lt;描述&gt;姐妹&lt;/ Description&gt;选择1行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532" title="您可以使用SQL / XML函数XMLTable在与XQuery表达式匹配的一组节点上执行SQL操作。">使用XMLTABLE在XMLType片段上执行SQL操作</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4124"></a><a id="ADXDB4123"></a><div class="props_rev_3"><a id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3" name="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3"></a><h4 id="ADXDB-GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3" class="sect4"><span class="enumeration_section">3.6.4</span>使用XMLCAST和XMLQUERY访问文本节点和属性值</h4>
                  <div>
                     <p>您可以使用SQL / XML标准函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLCast</code>访问文本节点和属性值。
                     </p>
                     <div class="section">
                        <p>为此，传递给<code class="codeph">XMLQuery</code>的XQuery表达式必须唯一地标识文档中的<span class="italic">单个</span>文本节点或属性值 - 即<span class="italic">叶</span>节点。<a href="how-to-use-XML-DB.html#GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__BJFCGHGB">示例3-20</a>使用多个查询说明了这一点。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__GUID-B49CF969-0A4E-4FF3-8DA9-7E3E36261A03">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB，</a>用于获取有关SQL / XML函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLCast</code></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E004C597-551E-4790-AEC5-4E27B27EEBA3__BJFCGHGB">
                        <p class="titleinexample">示例3-20使用XMLCAST和XMLQuery访问文本节点值</p>
                        <p>以下查询返回与<code class="codeph">Reference</code>元素关联的文本节点的值，该值与目标XPath表达式匹配。该值作为<code class="codeph">VARCHAR2</code>值返回。
                        </p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference / text（）'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（30））FROM purchaseorder; XMLCAST（XMLQUERY（'$ P / PURCHASEO ------------------------------ SBELL-2002100912333601PDT 1行选中。
</code></pre><p>以下查询返回与<code class="codeph">LineItem</code>元素中包含的<code class="codeph">Description</code>元素关联的文本节点的值。特定的<code class="codeph">LineItem</code>元素由其<code class="codeph">Id</code>属性值指定。标识<code class="codeph">LineItem</code>元素的谓词是<code class="codeph">[Part/@Id="715515011020"]</code> 。符号字符（ <code class="codeph">@</code> ）指定<code class="codeph">Id</code>是属性而不是元素。该值作为<code class="codeph">VARCHAR2</code>值返回。
                        </p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [Part / @ Id =“715515011020”] / Description / text（）'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）AS VARCHAR2（30））FROM purchaseorder; XMLCAST（XMLQUERY（'$ P / PURCHASEO ------------------------------选择姐妹1行。
</code></pre><p>以下查询返回与第一个<code class="codeph">LineItem</code>元素中包含的<code class="codeph">Description</code>元素关联的文本节点的值。第一个<code class="codeph">LineItem</code>元素由位置谓词<code class="codeph">[1]</code>指示。
                        </p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [1] / Description'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）AS VARCHAR2（4000））FROM purchaseorder; XMLCAST（XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [1] / DESCRIPTION'PASSINGOBJECT_VALUEAS“P”--------------------------- -------------------------------------------------- ----------------一个难忘的夜晚选择了一行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4126"></a><a id="ADXDB6413"></a><a id="ADXDB4125"></a><div class="props_rev_3"><a id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F" name="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F"></a><h4 id="ADXDB-GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F" class="sect4"><span class="enumeration_section">3.6.5</span>使用XMLEXISTS，XMLCAST和XMLQUERY搜索XML文档</h4>
                  <div>
                     <p>您可以在SQL <code class="codeph">WHERE</code>子句中使用SQL / XML标准函数<code class="codeph">XMLExists</code> ， <code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>来限制查询结果。
                     </p>
                     <div class="section">
                        <p>SQL / XML标准函数<code class="codeph">XMLExists</code>评估给定文档是否包含与W3C XPath表达式匹配的节点。如果文档包含由提供给函数的XPath表达式指定的节点，则返回布尔值<code class="codeph">true</code>如果不包含，则返回值<code class="codeph">false</code> 。由于XPath表达式可以包含谓词，因此<code class="codeph">XMLExists</code>可以确定文档中是否存在给定节点，以及文档中是否存在具有指定值的节点。
                        </p>
                        <p>类似地，函数<code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>允许您将查询结果限制为满足某些属性的文档。<a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__BJFJHBAE">示例3-21</a>说明了使用<code class="codeph">XMLExists</code> ， <code class="codeph">XMLCast</code>和<code class="codeph">XMLQuery</code>来搜索文档。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__CEGIICDB">示例3-22</a>基于XML文档中的节点的值和另一个关系表中的数据执行连接。
                        </p>
                        <div class="infoboxnotealso" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__GUID-B7C2D0CC-D99A-49E4-8981-86FBDBC54410">
                           <p class="notep1">也可以看看：</p>
                           <p>有关SQL / XML函数<code class="codeph">XMLQuery</code> ， <code class="codeph">XMLExists</code>和<code class="codeph">XMLCast</code>信息，请参阅<a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__BJFJHBAE">
                        <p class="titleinexample">示例3-21使用XMLExists，XMLCast和XMLQuery搜索XML内容</p>
                        <p>以下查询使用<code class="codeph">XMLExists</code>检查XML文档是否包含名为<code class="codeph">Reference</code>的元素，该元素是根元素<code class="codeph">PurchaseOrder</code>的子元素：</p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / Reference'PASSING OBJECT_VALUE AS“p”）; COUNT（*）---------- 132选择1行。
</pre><p>以下查询检查与<code class="codeph">Reference</code>元素关联的文本节点的值是否为<code class="codeph">SBELL-2002100912333601PDT</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder <span class="bold">[Reference =“SBELL-2002100912333601PDT”]</span> 'PASSING OBJECT_VALUE AS“p”）; COUNT（*）----------选择了1行。
</pre><p>该查询检查是否XML文档包含一个根元素<code class="codeph">PurchaseOrder</code>包含<code class="codeph">LineItems</code>包含元素<code class="codeph">LineItem</code>包含元素<code class="codeph">Part</code>与元素<code class="codeph">Id</code>属性。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / LineItems / LineItem / Part / <span class="bold">@</span> Id'PASSING OBJECT_VALUE AS“p”）; COUNT（*）---------- 132选择1行。
</pre><p>以下查询检查是否XML文档包含一个根元素<code class="codeph">PurchaseOrder</code>包含<code class="codeph">LineItems</code>包含元件<code class="codeph">LineItem</code>包含元件<code class="codeph">Part</code>与元件<code class="codeph">Id</code>属性值<code class="codeph">715515009058</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / LineItems / <span class="bold">LineItem / Part [@ Id =“715515009058”]</span> 'PASSING OBJECT_VALUE AS“p”）; COUNT（*）---------- 21</pre><p>以下查询检查XML文档是否包含根元素<code class="codeph">PurchaseOrder</code> ，该元素包含<code class="codeph">LineItems</code>元素，其<span class="italic">第三个</span> <code class="codeph">LineItem</code>元素包含具有<code class="codeph">Id</code>属性值<code class="codeph">715515009058</code>的<code class="codeph">Part</code>元素。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / LineItems / LineItem <span class="bold">[3]</span> / Part [@ Id =“715515009058”]'PASSING OBJECT_VALUE AS“p”）; COUNT（*）----------选择了1行。
</pre><p>以下查询将<code class="codeph">SELECT</code>语句的结果限制为与元素<code class="codeph">User</code>关联的文本节点以字母<code class="codeph">S</code>开头的行。 XQuery不包括对基于<code class="codeph">LIKE</code>的查询的支持。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLCAST（的XMLQuery（ '$ P / PurchaseOrder的/参考' PASSING OBJECT_VALUE为“P”回CONTENT）AS VARCHAR2（30））FROM定单WHERE XMLCAST（的XMLQuery（ '$ P / PurchaseOrder的/ <span class="bold">用户</span> '逝水OBJECT_VALUE为“P”回内容）如VARCHAR2（30）） <span class="bold">喜欢'％'</span> ; XMLCAST（XMLQUERY（'$ P / PURCHASEORDER ---------------------------------- SBELL-20021009123336231PDT SBELL-20021009123336331PDT SKING -20021009123336321PDT ...选择了36行。
</pre><p>以下查询使用<code class="codeph">XMLExists</code>将<code class="codeph">SELECT</code>语句的结果限制为元素<code class="codeph">User</code>的文本节点包含值<code class="codeph">SBELL</code> 。</p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（30））“Reference”FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [User =“ <span class="bold">SBELL</span> ”]' <span class="bold">PASSING</span> OBJECT_VALUE AS“p”）;参考------------------------------ SBELL-20021009123336231PDT SBELL-20021009123336331PDT SBELL-20021009123337353PDT SBELL-20021009123338304PDT SBELL-20021009123338505PDT SBELL-20021009123335771PDT SBELL -2002009123335280PDT SBELL-2002100912333763PDT SBELL-2002100912333601PDT SBELL-20021009123336362PDT SBELL-20021009123336532PDT SBELL-20021009123338204PDT SBELL-20021009123337673PDT 13行选择。
</pre><p>以下查询使用SQL / XML函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLExists</code>查找任何<code class="codeph">PurchaseOrder</code>元素的<code class="codeph">Reference</code>元素，该元素的第一个<code class="codeph">LineItem</code>元素包含具有<code class="codeph">Id</code> <code class="codeph">715515009058</code>的项目的订单。函数<code class="codeph">XMLExists</code>在<code class="codeph">WHERE</code>子句中用于确定选择哪些行，并且在<code class="codeph">SELECT</code>列表中使用<code class="codeph">XMLQuery</code>来控制所选文档的哪一部分出现在结果中。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（30））“Reference”FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / LineItems / LineItem [1] / Part [@ Id =“715515009058”]'PASSING OBJECT_VALUE AS“p”）;参考------------------------- SBELL-2002100912333601PDT选择1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-47898567-D968-4AFC-B7A7-18727D4C3C3F__CEGIICDB">
                        <p class="titleinexample">示例3-22从XMLType表和关系表中连接数据</p><pre class="oac_no_warn" dir="ltr">SELECT XMLCAST（的XMLQuery（ '$ P / PurchaseOrder的/参考' PASSING OBJECT_VALUE为“P”回CONTENT）AS VARCHAR2（30））FROM定单P，HR.EMPLOYEES e其中XMLCAST（的XMLQuery（ '$ P / PurchaseOrder的/ <span class="bold">用户</span> ' PASSING OBJECT_VALUE为“p”返回内容）AS VARCHAR2（30））= <span class="bold">e.email</span> AND <span class="bold">e.employee_id</span> = 100; XMLCAST（XMLQUERY（'$ P / PURCHASEOREDER ----------------------------------- SKING-20021009123336321PDT SKING-20021009123337153PDT选择SKING-20021009123335560PDT SKING-20021009123336952PDT SKING-20021009123336622PDT SKING-20021009123336822PDT SKING-20021009123336131PDT SKING-20021009123336392PDT SKING-20021009123337974PDT SKING-20021009123338294PDT SKING-20021009123337703PDT SKING-20021009123337383PDT SKING-20021009123337503PDT 13行。
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4131"></a><a id="ADXDB4132"></a><a id="ADXDB4133"></a><a id="ADXDB4130"></a><div class="props_rev_3"><a id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532" name="GUID-1F02303F-041C-42BF-9AE5-CE978496A532"></a><h4 id="ADXDB-GUID-1F02303F-041C-42BF-9AE5-CE978496A532" class="sect4"><span class="enumeration_section">3.6.6</span>使用XMLTABLE对XMLType片段执行SQL操作</h4>
                  <div>
                     <p>您可以使用SQL / XML函数<code class="codeph">XMLTable</code>在与XQuery表达式匹配的一组节点上执行SQL操作。
                     </p>
                     <div class="section">
                        <p><a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">示例3-19</a>演示了如何提取包含与XPath表达式匹配的节点的<code class="codeph">XMLType</code>实例。当文档包含与提供的XPath表达式匹配的<span class="italic">多个</span>节点时，此类查询将返回包含所有匹配节点的XML <span class="italic">片段</span> 。与XML文档不同，XML <strong class="term">片段</strong>没有单个元素作为<span class="italic">根</span>元素。
                        </p>
                        <p>在这些情况下，这种结果很常见：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当您检索集合中包含的元素<span class="italic">集时</span> ，在这种情况下，片段中的所有节点都具有相同的类型 - 请参阅<a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">示例3-23</a></p>
                           </li>
                           <li>
                              <p>当目标XPath表达式以<span class="italic">通配符</span>结束时，在这种情况下，片段中的节点可以是不同类型的 - 请参见<a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">示例3-25</a></p>
                           </li>
                        </ul>
                        <p>您可以使用SQL / XML函数<code class="codeph">XMLTable</code>来分解<code class="codeph">XMLType</code>实例中包含的XML片段，将集合元素数据插入到新的虚拟表中，然后可以在连接表达式中使用SQL进行查询。特别是，将XML片段转换为虚拟表可以更轻松地处理评估返回多个节点的<code class="codeph">XMLQuery</code>表达式的结果。
                        </p>
                        <div class="infoboxnotealso" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__GUID-AB568350-31DF-484C-BA1B-23BAC08E1BBE">
                           <p class="notep1">也可以看看：</p>
                           <p>有关SQL / XML函数<code class="codeph">XMLTable</code>更多信息，请参阅<a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB</a></p>
                        </div>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">示例3-23</a>显示了如何访问<code class="codeph">PurchaseOrder</code>文档中每个<code class="codeph">Description</code>元素的文本节点。它将<a href="how-to-use-XML-DB.html#GUID-4F9F6597-9B1F-4833-836B-DEC7674D264C__BABBGCHJ">示例3-19中</a>的单个XML Fragment输出分解为多个文本节点。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__BJFIDFFJ">例3-24</a>计算集合中元素的数量。它还显示了如何将SQL关键字（如<code class="codeph">ORDER BY</code>和<code class="codeph">GROUP BY</code>应用于由SQL / XML函数<code class="codeph">XMLTable</code>创建的虚拟表数据。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">例3-25</a>显示了如何使用SQL / XML函数<code class="codeph">XMLTable</code>来计算给定元素的<span class="italic">子</span>元素数。传递给<code class="codeph">XMLTable</code>的XPath表达式包含一个通配符（ <code class="codeph">*</code> ），它匹配作为<code class="codeph">PurchaseOrder</code>元素的直接后代的所有元素。<code class="codeph">XMLTable</code>创建的虚拟表的每一行都包含一个与XPath表达式匹配的节点。计算虚拟表中的行数可提供元素<code class="codeph">PurchaseOrder</code>的元素子元素数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDCFJAH">
                        <p class="titleinexample">示例3-23使用XMLTABLE访问描述节点</p><pre class="oac_no_warn" dir="ltr">SELECT des。COLUMN_VALUE来自purchaseorder p，XMLTable（'/ / PurchaseOrder / LineItems / LineItem / Description'PASSING p。OBJECT_VALUE）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; COLUMN_VALUE ------------ &lt;描述&gt;要记住的夜晚&lt;/ Description&gt; &lt;描述&gt;存在的难以忍受的亮度&lt;/ Description&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; <span class="bold">选择了3行。</span>
</pre><p>要使用SQL处理文本节点的内容，该示例使用SQL / XML函数<code class="codeph">XMLTable</code>将<code class="codeph">Description</code>节点的集合转换为<span class="italic">虚拟表</span> 。虚拟表有三行，每行包含一个带有单个<code class="codeph">Description</code>元素的<code class="codeph">XMLType</code>实例。
                        </p>
                        <p>XPath表达式以<code class="codeph">Description</code>元素为目标。的<code class="codeph">PASSING</code>子句表示使用内容（ <code class="codeph">OBJECT_VALUE</code>的） <code class="codeph">XMLType</code>表<code class="codeph">purchaseorder</code>作为上下文用于评估XPath表达式。
                        </p>
                        <p>因此， <code class="codeph">XMLTable</code>表达式<span class="italic">取决于</span> <code class="codeph">purchaseorder</code>表。这是<span class="italic">左侧连接</span> 。此相关联接确保访问的<code class="codeph">purchaseorder</code>行与<code class="codeph">XMLTable</code>生成的行之间的一对多（1：N）关系。由于此相关<code class="codeph">FROM</code> ， <code class="codeph">purchaseorder</code>表<span class="italic">必须出现在</span> <code class="codeph">FROM</code>列表中的<code class="codeph">XMLTable</code>表达式<span class="italic">之前</span> 。在<code class="codeph">PASSING</code>子句引用表的列的任何情况下，这是一般要求。
                        </p>
                        <p>虚拟表中的每个<code class="codeph">XMLType</code>实例都包含一个<code class="codeph">Description</code>元素。您可以使用<code class="codeph">XMLTable</code>的<code class="codeph">COLUMNS</code>子句将XPath表达式<code class="codeph">'Description'</code>针对的数据分解为名为SQL数据类型<code class="codeph">VARCHAR2(256)</code> <code class="codeph">description</code>的列。在<code class="codeph">'Description'</code>定义此列表达式是<span class="italic">相对于</span> <span class="italic">上下文</span> XPath表达式， <code class="codeph">'/PurchaseOrder/LineItems/LineItem'</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT des。 <span class="bold">描述</span> FROM purchaseorder p，XMLTable（'/ / PurchaseOrder / LineItems / LineItem'PASSING p。OBJECT_VALUE <span class="bold">COLUMNS description VARCHAR2（256）</span> PATH'Description <span class="bold">'</span> ）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）;描述---------------------------------一个难忘的夜晚成为姐妹的难以忍受的轻盈3行选择。
</pre><p><code class="codeph">COLUMNS</code>子句允许您指定精确的SQL数据类型，这可以使静态类型检查更有帮助。此示例仅使用单个列（ <code class="codeph">description</code> ）。要将<code class="codeph">XMLType</code>表中多个级别包含的数据公开为关系视图中的各个行， <code class="codeph">XMLTable</code>应用于要分解并存储在关系列中的每个文档级别。有关<a href="relational-views-over-XML-data.html#GUID-E550E7D4-0D19-47CA-B86F-76825EE54CE1__CHDEEIFD">示例</a> ，请参见<a href="relational-views-over-XML-data.html#GUID-E550E7D4-0D19-47CA-B86F-76825EE54CE1__CHDEEIFD">示例9-2</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__BJFIDFFJ">
                        <p class="titleinexample">示例3-24使用XMLTABLE计算集合中的元素数</p><pre class="oac_no_warn" dir="ltr">SELECT引用，count（*）FROM purchaseorder，XMLTable（'/ PurchaseOrder'PASSING OBJECT_VALUE COLUMNS <span class="bold">引用</span> VARCHAR2（32）PATH'Reference'， <span class="bold">lineitem</span> XMLType PATH'RineItems / LineItem'），XMLTable（'LineItem'PASSING lineitem）WHERE XMLExists（ '$ p / PurchaseOrder [User =“SBELL”]'PASSING OBJECT_VALUE AS“p”） <span class="bold">GROUP BY</span>引用<span class="bold">ORDER BY</span>引用;参考计数（*）-------------------------- -------- SBELL-20021009123335280PDT 20 SBELL-20021009123335771PDT 21 SBELL-2002100912333601PDT 3 SBELL-20021009123336231PDT 25 SBELL-20021009123336331PDT 10 SBELL-20021009123336362PDT 15 SBELL-20021009123336532PDT选择14 SBELL-20021009123337353PDT 10 SBELL-2002100912333763PDT 21 SBELL-20021009123337673PDT 10 SBELL-20021009123338204PDT 14 SBELL-20021009123338304PDT 24 SBELL-20021009123338505PDT 20个13行。
</pre><p>此示例中的查询将与XPath表达式匹配的XML文档集定位到SQL / XML函数<code class="codeph">XMLExists</code> 。它生成一个包含两列的虚拟表：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">reference</code> ，包含所选每个文档的<code class="codeph">Reference</code>节点</p>
                           </li>
                           <li>
                              <p><code class="codeph">lineitem</code> ，包含所选每个文档的<code class="codeph">LineItem</code>节点集</p>
                           </li>
                        </ul>
                        <p>它计算每个文档的<code class="codeph">LineItem</code>节点数。相关联接确保<code class="codeph">GROUP BY</code>正确地确定哪个<code class="codeph">LineItem</code>元素属于哪个<code class="codeph">PurchaseOrder</code>元素。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1F02303F-041C-42BF-9AE5-CE978496A532__CHDDCCFA">
                        <p class="titleinexample">示例3-25使用XMLTABLE计算元素中子元素的数量</p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM purchaseorder p，XMLTable（'/ PurchaseOrder / <span class="bold">*</span> 'PASSING p。OBJECT_VALUE）WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; COUNT（*）---------- 9选择1行。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-D937B3D1-BA54-41D0-9428-4739DA805D75" title="有许多方法可以在Oracle XML DB中查询XML内容并检索它。">查询Oracle XML DB中存储的XML内容</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4143"></a><a id="ADXDB4144"></a><a id="ADXDB4147"></a><a id="ADXDB4142"></a><div class="props_rev_3"><a id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8" name="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8"></a><h3 id="ADXDB-GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8" class="sect3"><span class="enumeration_section">3.7</span>更新Oracle XML DB中存储的XML内容</h3>
               <div>
                  <p>您可以更新XML内容，替换文档的全部内容或仅替换文档的特定部分。</p>
                  <div class="section">
                     <p>对XML文档执行部分更新的能力非常强大，尤其是当您对大型文档进行少量更改时，因为它可以显着减少执行更新所需的网络流量和磁盘输入输出量。</p>
                     <p>您可以在单个操作中对文档进行多项更改。每个更改都使用XQuery表达式来标识要更新的节点，并为该节点指定新值。</p>
                     <p><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__CHDBGCBG">示例3-26</a>更新与元素<code class="codeph">User</code>关联的文本节点。
                     </p>
                     <p><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFGFDGD">示例3-27</a>替换XML文档中的整个元素。XQuery表达式引用该元素，替换值作为<code class="codeph">XMLType</code>对象传递。
        
                     </p>
                     <p>您可以在一个语句中对文档进行多项更改。<a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFJGJAB">示例3-28</a>在单个SQL <code class="codeph">UPDATE</code>语句中更改属于<code class="codeph">CostCenter</code>和<code class="codeph">SpecialInstructions</code>元素的文本节点的值。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__CHDBGCBG">
                     <p class="titleinexample">示例3-26更新文本节点</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / User'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（60））FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; XMLCAST（XMLQUERY（'$ P / PURCHAS ---------------------------- SBELL 1行被选中。更新购买订单SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（对于$ i，$ i / PurchaseOrder / User返回节点$ j的替换值，带$ p2）返回$ i'PASSING OBJECT_VALUE AS“p1”，' <span class="bold">SKING'AS</span> “p2” <span class="bold">返回</span>内容）XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; 1行更新。SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / User'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（60））FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; XMLCAST（XMLQUERY（'$ P / PURCHAS ---------------------------- <span class="bold">SKING</span> 1行被选中。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFGFDGD">
                     <p class="titleinexample">示例3-27使用XQuery更新替换整个元素</p><pre class="pre codeblock"><code>SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [1]'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）from purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p “）; XMLQUERY（'$ P / PURCHAS -------------------- &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt;值得纪念的夜晚&lt;/ Description&gt; &lt;Part Id = “715515009058”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt;选择了1行。更新购买订单SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（$ i / PurchaseOrder / LineItems / LineItem [1]中的$ j返回替换节点$ j与$ p2）返回$ i'PASSING OBJECT_VALUE AS“p1 “， <span class="bold">XMLType（'&lt;LineItem ItemNumber =”1“&gt;</span> <span class="bold">&lt;Description&gt; Lady Vanishes &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =”37429122129“UnitPrice =”39.95“</span> <span class="bold">Quantity =”1“/&gt;</span> <span class="bold">&lt;/ LineItem&gt;'）</span> AS” p2“返回内容”XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; 1行更新。SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [1]'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）from purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p “）; XMLQUERY（'$ P / PURCHAS -------------------- <span class="bold">&lt;LineItem ItemNumber =“1”&gt;</span> <span class="bold">&lt;Description&gt; Lady Vanishes &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“ 37429122129“UnitPrice =”39.95“Quantity =”1“/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span>选择了1行。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__BJFJGJAB">
                     <p class="titleinexample">示例3-28使用XQuery更改更改文本节点值</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / CostCenter'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）AS VARCHAR2（4））“Cost Center”，XMLCast（XMLQuery（'$ p / PurchaseOrder / SpecialInstructions'PASSING OBJECT_VALUE AS“p “返回内容”作为VARCHAR2（2048））“指令”来自purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）;成本中心说明------------ ------------ S30 Air Mail 1行选中。UPDATE定单SET OBJECT_VALUE =的XMLQuery（'复制$ I：= $ P1修改（（用于在$ I /的PurchaseOrder / <span class="bold">CostCenter</span>返回$Ĵ <span class="bold"><span class="bold">替换</span></span> $ P2 <span class="bold">节点</span> $ j <span class="bold">的值</span> ），（对于在$ $ĴI /的PurchaseOrder / <span class="bold">SpecialInstructions</span> <span class="bold">使用</span> $ p3返回<span class="bold">节点</span> $ j的<span class="bold">替换值</span> ））返回$ i'PASSING OBJECT_VALUE AS“p1”， <span class="bold">'</span> B40'AS“p2”， <span class="bold">'优先隔夜服务'</span> AS“p3”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; 1行更新。SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / CostCenter'PASSING OBJECT_VALUE as“p”RETURNING CONTENT）AS VARCHAR2（4））“Cost Center”，XMLCast（XMLQuery（'$ p / PurchaseOrder / SpecialInstructions'PASSING OBJECT_VALUE AS“p “返回内容”作为VARCHAR2（2048））“指令”来自purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）;成本中心说明------------ -------------------------- <span class="bold">B40</span> <span class="bold">优先隔夜服务</span> 1行已选中。</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4163"></a><div class="props_rev_3"><a id="GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" name="GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B"></a><h3 id="ADXDB-GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" class="sect3"><span class="enumeration_section">3.8</span>从关系数据生成XML数据</h3>
               <div>
                  <p>您可以使用Oracle XML DB从关系数据生成XML数据。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7">使用SQL / XML函数从关系数据生成XML数据</a><br>您可以使用标准SQL / XML函数生成一个或多个XML文档。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3">使用DBURITYPE从关系数据生成XML数据</a><br>您可以使用SQL函数<code class="codeph">DBURIType</code>从关系数据生成XML数据。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB</a></li>
                        <li><a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4164"></a><a id="ADXDB4166"></a><a id="ADXDB4167"></a><a id="ADXDB5803"></a><div class="props_rev_3"><a id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7" name="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7"></a><h4 id="ADXDB-GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7" class="sect4"><span class="enumeration_section">3.8.1</span>使用SQL / XML函数从关系数据生成XML数据</h4>
                  <div>
                     <p>您可以使用标准SQL / XML函数生成一个或多个XML文档。</p>
                     <div class="section">
                        <p>SQL / XML函数<code class="codeph">XMLQuery</code>是执行此操作的最常用方法。您可以使用的其他SQL / XML函数如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">XMLElement</code>创建一个元素</p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLAttributes</code>将属性添加到元素</p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLForest</code>创建元素林</p>
                           </li>
                           <li>
                              <p><code class="codeph">XMLAgg</code>从元素集合中创建单个元素</p>
                           </li>
                        </ul>
                        <p><a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BJFJCFHF">示例3-29中</a>的查询使用这些函数生成XML文档，其中包含表<code class="codeph">departments</code> ， <code class="codeph">locations</code> ， <code class="codeph">countries</code> ， <code class="codeph">employees</code>和<code class="codeph">jobs</code> 。
                        </p>
                        <p>此查询为<code class="codeph">departments</code>表中的每一行生成元素<code class="codeph">Department</code> 。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每个<code class="codeph">Department</code>元素都包含属性<code class="codeph">DepartmentID</code> 。 <code class="codeph">DepartmentID</code>的值来自<code class="codeph">department_id</code>列。<code class="codeph">Department</code>元素包含子元素<code class="codeph">Name</code> ， <code class="codeph">Location</code>和<code class="codeph">EmployeeList</code> 。
                              </p>
                           </li>
                           <li>
                              <p>与<code class="codeph">Name</code>元素关联的文本节点来自<code class="codeph">departments</code>表中的<code class="codeph">name</code>列。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">Location</code>元素具有子元素<code class="codeph">Address</code> ， <code class="codeph">City</code> ， <code class="codeph">State</code> ， <code class="codeph">Zip</code>和<code class="codeph">Country</code> 。通过从<code class="codeph">locations</code>和<code class="codeph">countries</code>表中的列创建命名元素的林来构造这些元素。列中的值将成为命名元素的文本节点。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EmployeeList</code>元素包含<code class="codeph">Employee</code> Elements的聚合。<code class="codeph">EmployeeList</code>元素的内容由子查询创建，该子查询返回<code class="codeph">employees</code>表中与当前部门对应的行集。每个<code class="codeph">Employee</code>元素都包含有关该员工的信息。每个<code class="codeph">Employee</code>元素的元素和属性的内容取自表<code class="codeph">employees</code>和<code class="codeph">jobs</code> 。
                              </p>
                           </li>
                        </ul>
                        <p>SQL / XML函数生成的输出通常<span class="italic">不是</span>很漂亮。唯一的例外是函数<code class="codeph">XMLSerialize</code> - 使用<code class="codeph">XMLSerialize</code>进行漂亮打印。这使得其他SQL / XML函数（1）避免在生成所需输出时创建完整DOM，以及（2）减小生成文档的大小。大多数SQL / XML函数缺乏漂亮打印对大多数应用程序来说无关紧要。但是，它使得手动验证生成的输出更加困难。
                        </p>
                        <p>您还可以创建和查询使用SQL / XML生成函数构建的<code class="codeph">XMLType</code>视图。<a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABGGAIA">例3-30</a>和<a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">例3-31</a>说明了这一点。这种<code class="codeph">XMLType</code>视图具有将关系数据保存为XML内容的效果。<code class="codeph">XMLType</code>视图中的行也可以作为Oracle XML DB Repository中的文档保留。
                        </p>
                        <p>在<a href="how-to-use-XML-DB.html#GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">示例3-31中</a> ，传递给SQL / XML函数<code class="codeph">XMLExists</code>的XPath表达式将查询结果集限制为包含<code class="codeph">Executive</code>部门信息的节点。为清楚起见，结果显示在这里。
                        </p>
                        <div class="infoboxnote" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__GUID-C34EF579-9CFB-4ECC-AC17-C88A41DCA1AD">
                           <p class="notep1">注意：</p>
                           <p>只有当XPath表达式中引用的节点<span class="italic">不是</span>使用SQL函数<code class="codeph">XMLAgg</code>创建的元素的后代时，才支持对<code class="codeph">XMLType</code>表示操作的XML表达式的XPath重写。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BJFJCFHF">
                        <p class="titleinexample">示例3-29使用SQL / XML函数生成XML数据</p><pre class="pre codeblock"><code>SELECT XMLElement（“Department”，XMLAttributes（d。Department_id AS“DepartmentId”），XMLForest（d.department_name AS“Name”），XMLElement（“Location”，XMLForest（street_address AS“Address”，city AS“City”，state_province AS“State”，postal_code AS“Zip”， country_name AS“Country”）），XMLElement（“EmployeeList”，（SELECT XMLAgg（XMLElement（“Employee”，XMLAttributes（e.employee_id AS“employeeNumber”），XMLForest（e.first_name AS“FirstName”，e.last_name AS“ LastName“，e.email AS”EmailAddress“，e.phone_number AS”PHONE_NUMBER“，e.hire_date AS”StartDate“，j.job_title AS”JobTitle“，e.salary AS”Salary“，m.first_name ||'' || m.last_name AS“Manager”），XMLElement（“Commission”，e.commission_pct）））FROM hr.employees e，hr.employees m，hr.jobs j WHERE e.department_id = d.department_id AND j.job_id = e.job_id AND m.employee_id = e.manager_id）））AS XML FROM hr.departments d，hr.countries c，hr.locations l WHERE department_name ='Executive'AND d.location_id = l.location_id AND l.country_id = c.country_id;</code></pre><p>该查询返回以下XML：</p><pre class="pre codeblock"><code>XML ------------------------------------------------- ------------------------------- &lt;Department DepartmentId =“90”&gt; &lt;Name&gt; Executive &lt;/ Name&gt; &lt;Location&gt; &lt;地址&gt; 2004 Charade Rd &lt;/ Address&gt; &lt;City&gt; Seattle &lt;/ City&gt; &lt;State&gt; Washingto n &lt;/ State&gt; &lt;Zip&gt; 98199 &lt;/ Zip&gt; &lt;Country&gt; United States of America &lt;/ Country&gt; &lt;/ Location&gt; &lt;EmployeeList&gt; &lt;Employee employeeNumber =“101”&gt; &lt;FirstNa me&gt; Neena &lt;/ FirstName&gt; &lt;LastName&gt; Kochhar &lt;/ LastName&gt; &lt;EmailAddress&gt; NKOCHHAR &lt;/ EmailAdd ess&gt; &lt;PHONE_NUMBER&gt; 515.123.4568 &lt;/ PHONE_NUMBER&gt; &lt;开始日期&gt; 2005-09-21 &lt;/ StartDate&gt; &lt;JobTitle&gt;行政副总裁&lt;/ JobTitle&gt; &lt;薪水&gt; 17000 &lt;/薪水&gt; &lt;经理&gt;史蒂文·金&lt;/经理&gt; &lt;Com mission&gt; &lt;/ Commission&gt; &lt;/ Employee&gt; &lt;员工employeeNumber =“102”&gt; &lt;FirstName&gt; Lex &lt;/ FirstName&gt; &lt;LastName&gt; De Haan &lt;/ LastName&gt; &lt;EmailAddress&gt; L DEHAAN &lt;/ EmailAddress&gt; &lt;PHONE_NUMBER&gt; 515.123.4569 &lt;/ PHONE NUMBER&gt; &lt;StartDate&gt; 2001-01 -13 &lt;/ StartDate&gt; &lt;JobTitle&gt;管理副总裁&lt;/ JobTitle&gt; &lt;薪水&gt; 17000 &lt;/薪水&gt; &lt;经理&gt;史蒂芬金&lt;/经理&gt; &lt;佣金&gt; &lt;/佣金&gt; &lt;/员工&gt; &lt;/员工列表&gt; &lt;/系&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABGGAIA">
                        <p class="titleinexample">示例3-30通过常规关系表创建XMLType视图</p><pre class="pre codeblock"><code>CREATE OR REPLACE的XMLType的VIEW department_xml <span class="bold">WITH OBJECT <span class="bold">ID（SUBSTR（XMLCAST（</span></span> <span class="bold">的XMLQuery（ '$ P /部门/名称'</span> <span class="bold">PASSING OBJECT_VALUE为“P”回<span class="bold">CONTENT）AS</span></span> <span class="bold"><span class="bold"><span class="bold">VARCHAR2（30）），1，128））AS</span></span></span> SELECT的XMLElement（ “Department”，XMLAttributes（d.department_id AS“DepartmentId”），XMLForest（d.department_name AS“Name”），XMLElement（“Location”，XMLForest（street_address AS“Address”，city AS“City”，state_province AS“State” “，postal_code AS”Zip“，country_name AS”Country“）），XMLElement（”EmployeeList“，（SELECT XMLAgg（XMLElement（”Employee“，XMLAttributes（e.employee_id AS”employeeNumber“）），XMLForest（e.first_name AS” FirstName“，e.last_name AS”LastName“，e.email AS”EmailAddress“，e.phone_number AS”PHONE_NUMBER“，e.hire_date AS”StartDate“，j.job_title AS”JobTitle“，e.salary AS”Salary“ ，m.first_name ||''|| m.last_name AS“Manager”），XMLElement（“Commission”，e.commission_pct）））FROM hr.employees e，hr.employees m，hr.jobs j WHERE e.department_id = d.department_id AND j.job_id = e.job_id AND m.employee_id = e.manager_id）））。extract（'/ *'）AS XML FROM hr.departments d，hr.countries c，hr.locations l WHERE d.location_id = l.location_id AND l.country_id = c。 COUNTRY_ID;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D02157A1-7A55-4A11-BD29-10D041BD1FC7__BABJGAEG">
                        <p class="titleinexample">示例3-31查询XMLType视图</p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM department_xml WHERE XMLExists（'$ p / Department [Name =“Executive”]'PASSING OBJECT_VALUE AS“p”）; OBJECT_VALUE ------------------------------------------------ &lt; Department DepartmentId =“90”&gt; &lt;名称&gt;执行&lt;/名称&gt; &lt;位置&gt; &lt;地址&gt; 2004 Charade Rd &lt;/ Address&gt; &lt;City&gt; Seattle &lt;/ City&gt; &lt;State&gt; Washington &lt;/ State&gt; &lt;Zip&gt; 98199 &lt;/邮编&gt; &lt;国家&gt;美利坚合众国&lt;/ Country&gt; &lt;/ Location&gt; &lt;EmployeeList&gt; &lt;Employee employeeNumber =“101”&gt; &lt;FirstName&gt; Neena &lt;/ FirstName&gt; &lt;LastName&gt; Kochhar &lt;/ LastName&gt; &lt;EmailAddress&gt; NKOCHHAR &lt;/ EmailAddress&gt; &lt;PHONE_NUMBER&gt; 515.123.4568 &lt;/ PHONE_NUMBER&gt; &lt;StartDate&gt; 2005-09-21 &lt;/ StartDate&gt; &lt;JobTitle&gt;行政副总裁&lt;/ JobTitle&gt; &lt;薪水&gt; 17000 &lt;/薪水&gt; &lt;经理&gt; Steven King &lt;/ Manager &gt; &lt;佣金/&gt; &lt;/员工&gt; &lt;员工employeeNumber =“102”&gt; &lt;FirstName&gt; Lex &lt;/ FirstName&gt; &lt;LastName&gt; De Haan &lt;/ LastName&gt; &lt;EmailAddress&gt; LDEHAAN &lt;/ EmailAddress&gt; &lt;PHONE_NUMBER&gt; 515.123.4569 &lt;/ PHONE_NUMBER&gt; &lt;StartDate&gt; 2001-01-13 &lt;/ StartDate&gt; &lt;JobTitle&gt;行政副总裁&lt;/ JobTitle&gt; &lt;薪水&gt; 17000 &lt;/薪水&gt; &lt;经理&gt;史蒂芬金&lt;/经理&gt; &lt;佣金/&gt; &lt;/员工&gt; &lt; / EmployeeList&gt; &lt;/ Department&gt; 1行选择。
</code></pre><p>从以下执行计划输出中可以看出，Oracle XML DB能够将<code class="codeph">XMLExists</code>表达式中的XPath-expression参数正确地重写为底层关系表上的<code class="codeph">SELECT</code>语句。
                        </p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM department_xml WHERE XMLExists（'$ p / Department [Name =“Executive”]'PASSING OBJECT_VALUE AS“p”）; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- ---------计划哈希值：2414180351 ------------------------------------ -------------------------------------------------- ---------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------------------- -------- | 0 |选择声明| | 1 | 80 | 3（0）| 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 115 | | | | * 2 | HASH JOIN | | 10 | 1150 | 7（15）| 00:00:01 | | * 3 | HASH JOIN | | 10 | 960 | 5（20）| 00:00:01 | | 4 |通过INDEX ROWID BATCHED表的访问权限员工| 10 | 690 | 2（0）| 00:00:01 | | * 5 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 10 | | 1（0）| 00:00:01 | | 6 |表访问完全|工作| 19 | 513 | 2（0）| 00:00:01 | | 7 |表访问完全|员工| 107 | 2033年| 2（0）| 00:00:01 | | 8 | NESTED LOOPS | | 1 | 80 | 3（0）| 00:00:01 | | 9 | NESTED LOOPS | | 1 | 68 | 3（0）| 00:00:01 | | * 10 |表访问完全|部门| 1 | 19 | 2（0）| 00:00:01 | | 11 |按INDEX ROWID表的访问权限|地点| 1 | 49 | 1（0）| 00:00:01 | | * 12 | INDEX UNIQUE SCAN | LOC_ID_PK | 1 | | 0（0）| 00:00:01 | | * 13 | INDEX UNIQUE SCAN | COUNTRY_C_ID_PK | 1 | 12 | 0（0）| 00:00:01 | -------------------------------------------------- -------------------------------------------------- --------谓词信息（由操作ID标识）：--------------------------------- ------------------ 2  -  access（“M”。“EMPLOYEE_ID”=“E”。“MANAGER_ID”）3  - 访问（“J”。“JOB_ID”= “E”。“JOB_ID”）5  - 访问（“E”。“DEPARTMENT_ID”=：B1）10  - 过滤器（“D”。“DEPARTMENT_NAME”=“执行”）12  - 访问（“D”。“LOCATION_ID” =“L”。“LOCATION_ID”）13  - 访问（“L”。“COUNTRY_ID”=“C”。“COUNTRY_ID”）选择30行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" title="您可以使用Oracle XML DB从关系数据生成XML数据。">从关系数据生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4169"></a><a id="ADXDB4170"></a><a id="ADXDB5804"></a><a id="ADXDB4168"></a><div class="props_rev_3"><a id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3" name="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3"></a><h4 id="ADXDB-GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3" class="sect4"><span class="enumeration_section">3.8.2</span>使用DBURITYPE从关系数据生成XML数据</h4>
                  <div>
                     <p>您可以使用SQL函数<code class="codeph">DBURIType</code>从关系数据生成XML数据。
                     </p>
                     <div class="section">
                        <p>函数<code class="codeph">DBURIType</code>将给定表或视图中的一个或多个行公开为单个XML文档。根元素的名称源自表或视图的名称。根元素包含一组<code class="codeph">ROW</code>元素。表或视图中的每一行都有一个<code class="codeph">ROW</code>元素。每个<code class="codeph">ROW</code>元素的子元素都是从表或视图中的列派生的。每个子元素都包含一个文本节点，其中包含给定行的列值。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BABCGFBC">示例3-32</a>显示了如何使用SQL函数<code class="codeph">DBURIType</code>访问数据库模式<code class="codeph">HR</code>的表<code class="codeph">departments</code>的内容。它使用方法<code class="codeph">getXML()</code>将结果文档作为<code class="codeph">XMLType</code>实例返回。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFIFCCF">示例3-33</a>显示了如何使用XPath谓词来限制使用<code class="codeph">DBURIType</code>生成的XML文档中包含的行。示例中的XPath表达式将XML文档限制为值为<code class="codeph">10</code> <code class="codeph">DEPARTMENT_ID</code>列。
                        </p>
                        <p>SQL函数<code class="codeph">DBURIType</code>提供了一种将关系表中的部分或全部行作为一个或多个XML文档公开的简单方法。传递给函数<code class="codeph">DBURIType</code>的URL可以扩展为从视图或表中返回单个列，但在这种情况下，URL还必须包含标识目标表或视图中单个行的谓词。
                        </p>
                        <p><a href="how-to-use-XML-DB.html#GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFDCFGG">例3-34</a>说明了这一点。谓词<code class="codeph">[DEPARTMENT_ID="10"]</code>导致查询返回列的值<code class="codeph">department_name</code>为<code class="codeph">departments</code>行，其中柱<code class="codeph">department_id</code>具有值<code class="codeph">10</code> 。
                        </p>
                        <p>SQL函数<code class="codeph">DBURIType</code>不如SQL / XML函数灵活：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它无法控制生成的文档的形状。</p>
                           </li>
                           <li>
                              <p>数据只能来自单个表或视图。</p>
                           </li>
                           <li>
                              <p>生成的文档由一个或多个<code class="codeph">ROW</code>元素组成。每个<code class="codeph">ROW</code>元素包含目标表中每列的子项。
                              </p>
                           </li>
                           <li>
                              <p>子元素的名称来自列名。</p>
                           </li>
                        </ul>
                        <p>要控制XML元素的名称，包含来自多个表的列，或控制表中的哪些列出现在生成的文档中，请创建一个关系视图，将所需的列集显示为单行，然后使用函数<code class="codeph">DBURIType</code>从该视图的内容生成XML文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BABCGFBC">
                        <p class="titleinexample">示例3-32使用DBURIType和getXML（）从关系表生成XML数据</p><pre class="pre codeblock"><code>SELECT DBURIType（'/ HR / DEPARTMENTS'）。getXML（）FROM DUAL; DBURITYPE（ '/ HR /部门'）。GETXML（）----------------------------------------------- ------- &lt;？xml版本=“1.0”？&gt; &lt;DEPARTMENTS&gt; &lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 10 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;管理&lt;/ DEPARTMENT_NAME&gt; &lt;MANAGER_ID&gt; 200 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1700 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt; <span class="bold">...</span>&lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 20 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;营销&lt;/ DEPARTMENT_NAME&gt; &lt;MANAGER_ID&gt; 201 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1800 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt; &lt;/ DEPARTMENTS&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFIFCCF">
                        <p class="titleinexample">示例3-33使用XPath谓词限制行</p><pre class="pre codeblock"><code>SELECT DBURIType（'/ HR / DEPARTMENTS / ROW [DEPARTMENT_ID =“10”]'）。getXML（）FROM DUAL; DBURITYPE（ '/ HR /部门/ ROW [DEPARTMENT_ID = “10”]'）。GETXML（）----------------------------------------------- ------------------- &lt;？xml版本=“1.0”？&gt; &lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 10 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;管理&lt;/ DEPARTMENT_NAME&gt; &lt;MANAGER_ID&gt; 200 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1700 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt;选择了1行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-35D94A1F-4646-4208-9CCB-6C1F66E59FA3__BJFDCFGG">
                        <p class="titleinexample">示例3-34使用XPath谓词限制行和列</p><pre class="pre codeblock"><code>SELECT DBURIType（'/ HR / DEPARTMENTS / ROW [DEPARTMENT_ID =“10”] / <span class="bold">DEPARTMENT_NAME</span> '）。getXML（）FROM DUAL; DBURITYPE（ '/ HR /部门/ ROW [DEPARTMENT_ID = “10”] / DEPARTMENT_NAME'）。GETXML（）----------------------------------------------- ------------------------------ &lt;？xml版本=“1.0”？&gt; &lt;DEPARTMENT_NAME&gt;管理&lt;/ DEPARTMENT_NAME&gt;选择了1行。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-FF2D5AD9-0784-457B-8C06-D3E07F00C40B" title="您可以使用Oracle XML DB从关系数据生成XML数据。">从关系数据生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4063"></a><div class="props_rev_3"><a id="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" name="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D"></a><h3 id="ADXDB-GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" class="sect3"><span class="enumeration_section">3.9</span> XML文档的字符集</h3>
               <div>
                  <p>Oracle XML DB有几种方法可以确定哪些字符集用于XML文档</p>
                  <div class="infoboxnote" id="GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D__GUID-B9D7A6D2-33CB-459A-88D1-96CE08DEC78C">
                     <p class="notep1">警告：</p>
                     <p> <span class="italic">AL32UTF8</span>是适用于<code class="codeph">XMLType</code>数据的Oracle数据库字符集。它等同于IANA注册的标准UTF-8编码，该编码支持所有有效的XML字符。
                     </p>
                     <p>不要将Oracle数据库数据库字符集UTF8（无连字符）与数据库字符集AL32UTF8或字符<span class="italic">编码</span> UTF-8混淆。数据库字符集UTF8已被AL32UTF8 <span class="italic">取代</span> 。<span class="italic">不要</span>使用UTF8 XML数据。字符集UTF8仅支持Unicode 3.1及更早版本。它不支持所有有效的XML字符。AL32UTF8没有这样的限制。
                     </p>
                     <p>对XML数据使用数据库字符集UTF8可能会<span class="italic">阻止系统或对安全性产生负面影响</span> 。如果数据库字符集不支持的字符出现在输入文档元素名称中，则替换字符（通常为“ <code class="codeph">?</code>“）代替它。这会终止解析并引发异常。它可能导致无法恢复的错误。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-0AC0E511-7648-4B6B-A340-319D04EFD973">XML编码声明</a><br>您可以使用XML编码声明来显式指定要用于给定XML实体的字符编码。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1">将XML文档加载到数据库时的字符集确定</a><br>除了从<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR</code>值获取的XML数据之外，字符编码由文档加载到数据库时的编码声明确定。
                     </li>
                     <li class="ulchildlink"><a href="how-to-use-XML-DB.html#GUID-EED59501-929C-495A-B00F-6A9794ABF840">从数据库中检索XML文档时的字符集确定</a><br>除了存储在<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR</code>值中的XML数据之外，您可以指定使用SQL客户端，编程API或传输协议从Oracle XML DB检索时使用的编码。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4064"></a><div class="props_rev_3"><a id="GUID-0AC0E511-7648-4B6B-A340-319D04EFD973" name="GUID-0AC0E511-7648-4B6B-A340-319D04EFD973"></a><h4 id="ADXDB-GUID-0AC0E511-7648-4B6B-A340-319D04EFD973" class="sect4"><span class="enumeration_section">3.9.1</span> XML编码声明</h4>
                  <div>
                     <p>您可以使用XML编码声明来显式指定要用于给定XML实体的字符编码。</p>
                     <p>每个XML文档都由称为实体的单元组成。XML文档中的每个实体都可以对其字符使用不同的编码。以UTF-8或UTF-16以外的编码存储的实体必须以包含指示正在使用的字符编码的编码规范的XML声明开头。例如：</p><pre class="pre codeblock"><code>&lt;？xml version ='1.0'coding ='EUC-JP'？&gt;</code></pre><p>以UTF-16编码的实体必须以字节顺序标记（BOM）开头，如XML 1.0参考的附录F中所述。例如，在big-endian平台上，UTF-16数据流所需的BOM是<code class="codeph">#xFEFF</code> 。</p>
                     <p>在没有编码声明和BOM的情况下，假设XML实体以UTF-8编码。由于ASCII是UTF-8的子集，因此ASCII实体不需要编码声明。</p>
                     <p>在许多情况下，除XML数据外，还提供外部信息源，以提供正在使用的字符编码。例如，可以从HTTP（S）请求中的<code class="codeph">Content-Type</code>字段的<code class="codeph">charset</code>参数获取数据的编码，如下所示：</p><pre class="pre codeblock"><code>Content-Type：text / xml;字符集= ISO-8859-4</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="Oracle XML DB有几种方法可以确定哪些字符集用于XML文档">XML文档的字符集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4065"></a><div class="props_rev_3"><a id="GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1" name="GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1"></a><h4 id="ADXDB-GUID-8C49B304-2E88-4B18-BC7E-A5E11316E5D1" class="sect4"><span class="enumeration_section">3.9.2</span>将XML文档加载到数据库时确定字符集</h4>
                  <div>
                     <p>除了从<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR</code>值获取的XML数据之外，字符编码由文档加载到数据库时的编码声明确定。
                     </p>
                     <p>对于从<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR</code>值获取的XML数据，将<span class="italic">忽略</span>任何存在的编码声明，因为这两种数据类型<span class="italic">始终在数据库字符集中进行编码</span> 。
                     </p>
                     <p>此外，通过编程API或传输协议将数据加载到Oracle XML DB中时，您可以提供外部编码来覆盖文档编码声明。如果您尝试加载包含在确定的编码中不合法的字符的基于模式的XML文档，则会引发错误。</p>
                     <p>以下示例显示了指定外部编码的不同方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用PL / SQL函数<code class="codeph">DBMS_XDB_REPOS.createResource</code>从<code class="codeph">BFILE</code>创建文件资源，您可以使用<span class="italic"><code class="codeph">CSID</code></span>参数指定文件编码。如果指定了零<span class="italic"><code class="codeph">CSID</code></span>则从文档编码声明中自动检测文件编码。
                           </p><pre class="pre codeblock"><code>CREATE DIRECTORY xmldir AS'/ private / xmldir'; CREATE或REPLACE PROCEDURE loadXML（filename VARCHAR2，file_csid NUMBER）IS xbfile BFILE; RET BOOLEAN; BEGIN xbfile：= bfilename（'XMLDIR'，filename）; ret：= DBMS_XDB_REPOS.createResource（'/ public / mypurchaseorder.xml'，xbfile，file_csid）;结束;/</code></pre></li>
                        <li>
                           <p>使用FTP协议将文档加载到Oracle XML DB中。使用<code class="codeph">quote set_charset</code> FTP命令指示要加载的文件的编码。
                           </p><pre class="pre codeblock"><code>ftp&gt; quote set_charset Shift_JIS ftp&gt; put mypurchaseorder.xml</code></pre></li>
                        <li>
                           <p>使用HTTP（S）协议将文档加载到Oracle XML DB中。在请求标头中指定要传输到Oracle XML DB的数据的编码。</p><pre class="pre codeblock"><code>Content-Type：text / xml; charset = EUC-JP</code></pre></li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="Oracle XML DB有几种方法可以确定哪些字符集用于XML文档">XML文档的字符集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4066"></a><div class="props_rev_3"><a id="GUID-EED59501-929C-495A-B00F-6A9794ABF840" name="GUID-EED59501-929C-495A-B00F-6A9794ABF840"></a><h4 id="ADXDB-GUID-EED59501-929C-495A-B00F-6A9794ABF840" class="sect4"><span class="enumeration_section">3.9.3</span>从数据库中检索XML文档时的字符集确定</h4>
                  <div>
                     <p>除了存储在<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR</code>值中的XML数据之外，您可以指定使用SQL客户端，编程API或传输协议从Oracle XML DB检索时使用的编码。
                     </p>
                     <p>当XML数据存储为<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR2</code>值时，编码声明（如果存在）始终<span class="italic">被忽略</span>以进行检索，就像存储一样。因此，检索到的文档的编码可以与该文档中明确声明的编码不同。
                     </p>
                     <p>从数据库检索的XML文档的字符集通过以下方式确定：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQL客户端 - 如果使用SQL客户端（如SQL * Plus）检索XML数据，则字符集由客户端环境变量<code class="codeph">NLS_LANG</code> 。特别是，此设置将覆盖XML数据本身中的任何显式字符集声明。
                           </p>
                           <p>例如，如果将客户端<code class="codeph">NLS_LANG</code>变量设置为<code class="codeph">AMERICAN_AMERICA.AL32UTF8</code> ，然后检索带有声明<code class="codeph">&lt;?提供的编码<code class="codeph">EUC_JP</code>的XML文档<code class="codeph">&lt;?xml version =“1.0”encoding =“EUC-JP”？&gt;</code> ，检索到的文档的字符集是<code class="codeph">AL32UTF8</code> ， <span class="italic">而不是</span> <code class="codeph">EUC_JP</code> 。</p>
                        </li>
                        <li>
                           <p>PL / SQL和API  - 使用PL / SQL或编程API，您可以将XML数据检索为<code class="codeph">VARCHAR</code> ， <code class="codeph">CLOB</code>或<code class="codeph">XMLType</code>数据类型。对于SQL客户端，您可以通过设置<code class="codeph">NLS_LANG</code>来控制检索数据的编码。</p>
                           <p>您还可以使用<code class="codeph">XMLType</code>和<code class="codeph">URIType</code>方法将XML数据检索到<code class="codeph">BLOB</code>值。这些允许您指定返回的<code class="codeph">BLOB</code>值的字符集。这是一个例子：</p><pre class="pre codeblock"><code>创建或替换函数getXML（pathname VARCHAR2，charset VARCHAR2）RETURN BLOB是xblob BLOB; BEGIN SELECT XMLSERIALIZE（文件e。RES AS BLOB编码字符集）INTO xblob FROM RESOURCE_VIEW e WHERE equals_path（e。RES，pathname）= 1;返回xblob;结束; /</code></pre></li>
                        <li>
                           <p>FTP  - 您可以使用FTP <code class="codeph">quote set_nls_locale</code>命令设置字符集：</p><pre class="pre codeblock"><code>ftp&gt; quote set_nls_locale EUC-JP ftp&gt; get mypurchaseorder.xml</code></pre></li>
                        <li>
                           <p>HTTP（S） - 您可以在HTTP（S）请求中使用<code class="codeph">Accept-Charset</code>参数：</p><pre class="pre codeblock"><code>/httptest/mypurchaseorder.xml 1.1 HTTP /主机：localhost：2345接受：text / * Accept-Charset：iso-8859-1，utf-8</code></pre></li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="repository-access-using-protocols.html#GUID-79D2A8C3-3AD4-4479-847B-0F3771B322AE" title="Oracle数据库支持多种FTP引用方法，这些方法直接向Oracle XML DB提供信息。">FTP报价方法</a></li>
                           <li><a href="repository-access-using-protocols.html#GUID-3855422B-2846-40CB-9E49-298193DC333F" title="您可以控制用于使用HTTP（S）传输的数据的字符集。">HTTP（S）的字符集</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-EED59501-929C-495A-B00F-6A9794ABF840__GUID-0F0FC6BB-FDEB-49D9-80ED-17CECF2ABEE7">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">NLS_LANG</code>信息，请<code class="codeph">NLS_LANG</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=NLSPG-GUID-D5C74C82-8622-46F4-8760-0F8ABA28A816" target="_blank"><span><cite>“Oracle数据库全球化支持指南”</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="how-to-use-XML-DB.html#GUID-C3894902-B4FF-4191-AE22-BCCFADD7FE1D" title="Oracle XML DB有几种方法可以确定哪些字符集用于XML文档">XML文档的字符集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>基于XML模式的数据的<code class="codeph">XMLType</code>存储模型是在引用的XML模式的注册期间指定的任何内容。如果在注册期间未指定存储模型，则使用对象关系存储。
            </p><br></div>
      </article>
   </body>
</html>