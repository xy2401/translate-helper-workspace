<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>嵌入式SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="datatypes-and-host-variables.html" title="Previous" type="text/html"></link>
      <link rel="next" href="embedded-PLSQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="datatypes-and-host-variables.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="embedded-PLSQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">嵌入式SQL</li>
            </ol>
            <a id="GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC" name="GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC"></a><a id="LNPCB005"></a>
            
            <h2 id="LNPCB-GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC" class="sect2"><span class="enumeration_chapter">5</span>嵌入式SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍嵌入式SQL编程的基本技术。主题是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="embedded-SQL.html#GUID-C3271557-4474-435C-94DC-A00A8545CEE4">使用主机变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102">使用指标变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-3029ACCF-7284-4469-9A62-85615F9C3675">基本SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-3002FE30-7975-42DA-9A95-F6D085ACC5CD">游标</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611">可滚动游标</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-B871F7A4-D8FE-4D51-AF3E-ECC92B3C2E8B">灵活的B区长度</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724">修复执行计划</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-02630564-C8F8-49E8-8D9C-9746185723D3">示例程序2：光标操作</a> 
                     </p>
                  </li>
               </ul>
            </div><a id="LNPCB342"></a><div class="props_rev_3"><a id="GUID-C3271557-4474-435C-94DC-A00A8545CEE4" name="GUID-C3271557-4474-435C-94DC-A00A8545CEE4"></a><h3 id="LNPCB-GUID-C3271557-4474-435C-94DC-A00A8545CEE4" class="sect3"><span class="enumeration_section">5.1</span>使用主机变量</h3>
               <div>
                  <p>使用主机变量将数据和状态信息从数据库传递到程序，并将数据传递到数据库。 <a id="d35601e88" class="indexterm-anchor"></a><a id="d35601e90" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCB343"></a><div class="props_rev_3"><a id="GUID-A86260DA-0B6E-4CA6-AFF7-B9C297092D63" name="GUID-A86260DA-0B6E-4CA6-AFF7-B9C297092D63"></a><h4 id="LNPCB-GUID-A86260DA-0B6E-4CA6-AFF7-B9C297092D63" class="sect4"><span class="enumeration_section">5.1.1</span>输出与输入主机变量</h4>
                  <div>
                     <p>根据它们的使用方式，主变量称为输出或输入主变量。SELECT或FETCH语句的INTO子句中的主机变量称为<span class="italic">输出</span>主机变量，因为它们包含Oracle输出的列值。Oracle将列值分配给INTO子句中的相应输出主机变量。<a id="d35601e120" class="indexterm-anchor"></a><a id="d35601e122" class="indexterm-anchor"></a><a id="d35601e124" class="indexterm-anchor"></a></p>
                     <p>SQL语句中的所有其他主机变量都称为<span class="italic">输入</span>主机变量，因为您的程序将其值输入到Oracle。例如，您在INSERT语句的VALUES子句和UPDATE语句的SET子句中使用输入主机变量。它们也用在WHERE，HAVING和FOR子句中。事实上，只要允许值或表达式，输入主变量就可以出现在SQL语句中。<a id="d35601e131" class="indexterm-anchor"></a></p>
                     <p>您不能使用输入主机变量来提供SQL关键字或数据库对象的名称。因此，您不能在数据定义语句（有时称为<span class="italic">DDL</span> ）中使用输入主机变量，例如ALTER，CREATE和DROP。在以下示例中，DROP TABLE语句<span class="italic">无效</span> ：<a id="d35601e143" class="indexterm-anchor"></a><a id="d35601e147" class="indexterm-anchor"></a><a id="d35601e151" class="indexterm-anchor"></a><a id="d35601e153" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01表名称PIC X（30）变化。 ...EXEC SQL END DECLARE SECTION END-EXEC。 ...显示'表名？”。接受表名称。 EXEC SQL DROP TABLE：TABLE-NAME END-EXEC。 *  - 不允许使用主变量</pre><div class="infoboxnote" id="GUID-A86260DA-0B6E-4CA6-AFF7-B9C297092D63__GUID-84933B44-BB0B-478B-A505-8023D613B7C1">
                        <p class="notep1">注意：</p>
                        <p>在ORDER BY子句中，您<span class="italic">可以</span>使用主机变量，但它被视为常量或文字，因此主机变量的内容无效。例如，SQL语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，EMPNO INTO：NAME，：来自EMP ORDER BY的数字：ORD END-EXEC。</pre><p>似乎包含输入主机变量<span class="italic">ORD</span> 。但是，在这种情况下，宿主变量被视为常量，无论ORD的值如何，都不会进行排序。
                        </p>
                     </div>
                     <p>在Oracle执行包含输入主机变量的SQL语句之前，程序必须为它们分配值。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 EMP-NUMBER PIC S9（4）COMP。 01 EMP-NAME PIC X（20）变化。 EXEC SQL END DECLARE SECTION END-EXEC。 ...*  - 获取输入主变量的值DISPLAY'员工编号？”。接受EMP-NUMBER。显示'员工姓名？”。接受EMP-NAME。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME）值（：EMP-NUMBER，：EMP-NAME）END-EXEC。</pre><p>请注意，INSERT语句的VALUES子句中的输入主机变量以冒号为前缀。</p>
                  </div>
               </div>
            </div><a id="LNPCB344"></a><div class="props_rev_3"><a id="GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102" name="GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102"></a><h3 id="LNPCB-GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102" class="sect3"><span class="enumeration_section">5.2</span>使用指标变量</h3>
               <div>
                  <p>您可以将任何主机变量与可选的指示符变量相关联。每次在SQL语句中使用主机变量时，结果代码都存储在其关联的指示符变量中。因此，指标变量可让您监控主变量。<a id="d35601e202" class="indexterm-anchor"></a></p>
                  <p>您可以在VALUES或SET子句中使用指示符变量将NULL分配给输入主机变量，并在INTO子句中检测输出主机变量中的NULL或截断值。</p>
               </div><a id="LNPCB345"></a><div class="props_rev_3"><a id="GUID-582569AF-926D-4B29-BC42-F09571483380" name="GUID-582569AF-926D-4B29-BC42-F09571483380"></a><h4 id="LNPCB-GUID-582569AF-926D-4B29-BC42-F09571483380" class="sect4"><span class="enumeration_section">5.2.1</span>输入变量</h4>
                  <div>
                     <p>对于输入主变量，程序可以赋给指标变量的值具有以下含义：</p>
                     <div class="tblformal" id="GUID-582569AF-926D-4B29-BC42-F09571483380__GUID-FB405E0F-CBB4-4ED3-89C8-782F033A48C9">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d35601e238">变量</th>
                                 <th align="left" valign="bottom" width="71%" id="d35601e241">含义</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e246" headers="d35601e238 ">
                                    <p>-1</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e246 d35601e241 ">
                                    <p>Oracle将为列分配NULL，忽略主机变量的值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e253" headers="d35601e238 ">
                                    <p>&gt; = 0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e253 d35601e241 ">
                                    <p>Oracle会将主变量的值分配给列。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCB346"></a><div class="props_rev_3"><a id="GUID-0FFBA81A-BBB4-4E3D-998E-C284F0BFB41B" name="GUID-0FFBA81A-BBB4-4E3D-998E-C284F0BFB41B"></a><h4 id="LNPCB-GUID-0FFBA81A-BBB4-4E3D-998E-C284F0BFB41B" class="sect4"><span class="enumeration_section">5.2.2</span>输出变量</h4>
                  <div>
                     <p>对于输出主变量，Oracle可以分配给指标变量的值具有以下含义：</p>
                     <div class="tblformal" id="GUID-0FFBA81A-BBB4-4E3D-998E-C284F0BFB41B__GUID-ACA0AA12-8CFC-4167-96C8-1834D09E72D3">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d35601e297">变量</th>
                                 <th align="left" valign="bottom" width="71%" id="d35601e301">含义</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e306" headers="d35601e297 ">
                                    <p>-2</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e306 d35601e301 ">
                                    <p>Oracle为主变量分配了一个截断的列值，但无法将列值的原始长度分配给指示符变量，因为该数字太大。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e313" headers="d35601e297 ">
                                    <p>-1</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e313 d35601e301 ">
                                    <p>列值为NULL，因此宿主变量的值是不确定的。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e320" headers="d35601e297 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e320 d35601e301 ">
                                    <p>Oracle为主变量分配了完整的列值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d35601e327" headers="d35601e297 ">
                                    <p><span class="italic">&gt;</span> 0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d35601e327 d35601e301 ">
                                    <p>Oracle为主变量分配了一个截断的列值，将原始列长度（以字节，而不是字节表示，用于多字节全球化支持主机变量）分配给指示符变量，并将SQLCA中的SQLCODE设置为零。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>请记住，指示符变量必须声明为2字节整数，并且在SQL语句中，必须以冒号为前缀并附加到其主变量（除非使用关键字INDICATOR）。</p>
                  </div>
               </div><a id="LNPCB347"></a><div class="props_rev_3"><a id="GUID-7E5AE408-C87C-493F-AC87-A4D6841CD0EC" name="GUID-7E5AE408-C87C-493F-AC87-A4D6841CD0EC"></a><h4 id="LNPCB-GUID-7E5AE408-C87C-493F-AC87-A4D6841CD0EC" class="sect4"><span class="enumeration_section">5.2.3</span>插入NULL</h4>
                  <div>
                     <p>您可以使用指示符变量来插入NULL。在插入之前，对于要为NULL的每个列，将相应的指示符变量设置为-1，如以下示例所示：<a id="d35601e362" class="indexterm-anchor"></a><a id="d35601e366" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">移动-1到IND-COMM。 EXEC SQL INSERT INTO EMP（EMPNO，COMM）VALUES（：EMP-NUMBER，：COMMISSION：IND-COMM）END-EXEC。</pre><p>指示符变量<span class="italic">IND-COMM</span>指定将NULL存储在COMM列中。
                     </p>
                     <p>您可以改为对NULL进行硬编码，如下所示：<a id="d35601e379" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（EMPNO，COMM）值（：EMP-NUMBER，NULL）END-EXEC。</pre><p>但这不太灵活。</p>
                     <p>通常，您有条件地插入NULL，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">显示'输入员工编号，如果不可用则输入0：'没有进展。接受EMP-NUMBER。如果EMP-NUMBER = 0移动-1到IND-EMPNUM ELSE移动到IND-EMPNUM END-IF。 EXEC SQL INSERT INTO EMP（EMPNO，SAL）值（：EMP-NUMBER：IND-EMPNUM，：SALARY）END-EXEC。</pre></div>
               </div><a id="LNPCB348"></a><div class="props_rev_3"><a id="GUID-82A9A619-18A7-478E-B474-5DEEF7898585" name="GUID-82A9A619-18A7-478E-B474-5DEEF7898585"></a><h4 id="LNPCB-GUID-82A9A619-18A7-478E-B474-5DEEF7898585" class="sect4"><span class="enumeration_section">5.2.4</span>处理返回的NULL</h4>
                  <div>
                     <p>您还可以使用指示符变量来处理返回的NULL，如以下示例所示：<a id="d35601e415" class="indexterm-anchor"></a><a id="d35601e419" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL，COMM INTO：EMP-NAME，：SALARY，：COMMISSION：IND-COMM from EMP WHERE EMPNO =：EMP_NUMBER END-EXEC。如果IND-COMM = -1移动薪水支付。 *  - 佣金为空;忽略它ELSE加上佣金到委员会给予支付。万一。</pre></div>
               </div><a id="LNPCB349"></a><div class="props_rev_3"><a id="GUID-32136A82-D392-4A30-9F13-1A108F65DBEE" name="GUID-32136A82-D392-4A30-9F13-1A108F65DBEE"></a><h4 id="LNPCB-GUID-32136A82-D392-4A30-9F13-1A108F65DBEE" class="sect4"><span class="enumeration_section">5.2.5</span>获取NULL</h4>
                  <div>
                     <p>使用预编译器选项UNSAFE_NULL = YES，您可以在缺少指示符变量的主变量中选择或获取NULL，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">*  - 假设佣金为NULL EXEC SQL SELECT ENAME，SAL，COMM INTO：EMP-NAME，：SALARY，：来自EMP的EMPNO = EMP-NUMBER END-EXEC的委员会。</pre><p>SQLCA中的SQLCODE设置为零，表示Oracle在未检测到错误或异常的情况下执行了该语句。</p>
                     <p>如果没有指示符变量，则无法知道是否返回了NULL。主机变量的值未定义。如果不使用指示符变量，请设置预编译器选项UNSAFE_NULL = YES。因此，Oracle建议UNSAFE_NULL = YES仅用于升级现有程序，并且该指示符变量用于所有新程序。</p>
                     <p>当UNSAFE_NULL = NO时，如果在缺少指示符变量的主变量中选择或获取NULL，则Oracle会发出错误消息。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-FFCFA12A-0664-43E6-9F5E-6C47AEF514AC">UNSAFE_NULL</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB350"></a><div class="props_rev_3"><a id="GUID-BFB7E66F-7FC6-4487-A03C-89DEE1182BDF" name="GUID-BFB7E66F-7FC6-4487-A03C-89DEE1182BDF"></a><h4 id="LNPCB-GUID-BFB7E66F-7FC6-4487-A03C-89DEE1182BDF" class="sect4"><span class="enumeration_section">5.2.6</span>测试NULL</h4>
                  <div>
                     <p>您可以在WHERE子句中使用指示符变量来测试NULL，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL INTO：EMP-NAME，：来自EMP WHERE的SALARY：COMMISSION：IND-COMM为NULL ...
</pre><p>但是，您不能使用关系运算符来将NULL彼此或与其他值进行比较。例如，如果COMM列包含一个或多个NULL，则以下SELECT语句将失败： <a id="d35601e491" class="indexterm-anchor"></a><a id="d35601e495" class="indexterm-anchor"></a><a id="d35601e499" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL INTO：EMP-NAME，：来自EMP的SALARY COMMERE =：COMMISSION：IND-COMM END-EXEC。</pre><p>下一个示例显示了当一些值可能为NULL时如何比较相等的值：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL INTO：EMP_NAME，：来自EMP WHERE的SALARY（COMM =：COMMISSION）或（（COMM是NULL）AND（：COMMISSION：IND-COMM为空））END-EXEC。</pre></div>
               </div><a id="LNPCB351"></a><div class="props_rev_3"><a id="GUID-7B1B9FFC-FD91-4490-B93C-0500DFD38DD7" name="GUID-7B1B9FFC-FD91-4490-B93C-0500DFD38DD7"></a><h4 id="LNPCB-GUID-7B1B9FFC-FD91-4490-B93C-0500DFD38DD7" class="sect4"><span class="enumeration_section">5.2.7</span>获取截断值</h4>
                  <div>
                     <p>如果在获取主机变量时截断值，则不会生成错误。 <a id="d35601e534" class="indexterm-anchor"></a> 在所有情况下都会发出警告信号（参见<span class="q">“ <a href="error-handling-and-diagnostics.html#GUID-BAF262E2-F3CF-4EF7-A361-59C66949F999">警告标志</a> ”</span> ）。如果指示符变量与字符串一起使用，则在截断值时，指示符变量将设置为数据库中值的长度。请注意，如果数字值被截断，则不会标记警告。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCB352"></a><div class="props_rev_3"><a id="GUID-3029ACCF-7284-4469-9A62-85615F9C3675" name="GUID-3029ACCF-7284-4469-9A62-85615F9C3675"></a><h3 id="LNPCB-GUID-3029ACCF-7284-4469-9A62-85615F9C3675" class="sect3"><span class="enumeration_section">5.3</span>基本SQL语句</h3>
               <div>
                  <p>可执行的SQL语句使您可以查询，操作和控制Oracle数据，以及创建，定义和维护Oracle对象，例如表，视图和索引。本章重点介绍操作数据库表（有时称为<span class="italic">DML</span> ）和游标控制语句中的数据的语句。
                  </p>
                  <p>以下SQL语句允许您查询和操作Oracle数据：</p>
                  <div class="tblformal" id="GUID-3029ACCF-7284-4469-9A62-85615F9C3675__GUID-F2193996-48FC-46DC-98FC-0AB436163D8D">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d35601e582">SQL语句</th>
                              <th align="left" valign="bottom" width="71%" id="d35601e585">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e590" headers="d35601e582 ">
                                 <p>选择</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e590 d35601e585 ">
                                 <p>返回一个或多个表中的行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e597" headers="d35601e582 ">
                                 <p>插入</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e597 d35601e585 ">
                                 <p>向表中添加新行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e604" headers="d35601e582 ">
                                 <p>UPDATE</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e604 d35601e585 ">
                                 <p>修改表中的行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e611" headers="d35601e582 ">
                                 <p>删除</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e611 d35601e585 ">
                                 <p>从表中删除行。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>执行INSERT，UPDATE或DELETE等数据操作语句时，您想知道已更新的行数以及是否成功。要找到答案，您只需查看SQLCA即可。 （执行任何SQL语句都会设置SQLCA变量。）您可以通过以下两种方式办理登机手续：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用WHENEVER语句进行隐式检查</p>
                     </li>
                     <li>
                        <p>显式检查SQLCA变量</p>
                     </li>
                  </ul>
                  <p>或者，当MODE = {ANSI | ANSI14}，您可以检查状态变量SQLSTATE或SQLCODE。有关更多信息，请参见<span class="q">“ <a href="error-handling-and-diagnostics.html#GUID-539B0088-AFEC-4863-90DA-B5AA7205CBB5">ANSI SQLSTATE变量</a> ”</span> 。
                  </p>
                  <p>但是，在执行SELECT语句（查询）时，还必须处理它返回的数据行。查询可分为以下几类：<a id="d35601e635" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不返回任何行的查询（即仅检查是否存在）</p>
                     </li>
                     <li>
                        <p>只返回一行的查询</p>
                     </li>
                     <li>
                        <p>返回多行的查询</p>
                     </li>
                  </ul>
                  <p>返回多行的查询需要显式声明的游标或游标变量。以下嵌入式SQL语句允许您定义和控制显式游标：</p>
                  <div class="tblformal" id="GUID-3029ACCF-7284-4469-9A62-85615F9C3675__GUID-38065E53-B84D-446E-9EFE-04E943951193">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d35601e657">SQL语句</th>
                              <th align="left" valign="bottom" width="71%" id="d35601e660">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e665" headers="d35601e657 ">
                                 <p>宣布</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e665 d35601e660 ">
                                 <p>命名游标并将其与查询相关联。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e672" headers="d35601e657 ">
                                 <p>打开</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e672 d35601e660 ">
                                 <p>执行查询并标识活动集。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e679" headers="d35601e657 ">
                                 <p>取</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e679 d35601e660 ">
                                 <p>前进游标并逐个检索活动集中的每一行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d35601e686" headers="d35601e657 ">
                                 <p>关</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d35601e686 d35601e660 ">
                                 <p>禁用游标（活动集变为未定义。）</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a id="d35601e693" class="indexterm-anchor"></a>在接下来的部分中，首先将学习如何编写INSERT，UPDATE，DELETE和单行SELECT语句。然后，您将进入多行SELECT语句。 ，见</p>
                  <div class="infoboxnotealso" id="GUID-3029ACCF-7284-4469-9A62-85615F9C3675__GUID-BD50CD6A-9C2F-4E20-BECA-BBDDA6DF7542">
                     <p class="notep1">也可以看看：</p>有关语句及其子句的更多信息，请<a href="../sqlrf/index.html" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a> 。
                  </div>
               </div><a id="LNPCB353"></a><div class="props_rev_3"><a id="GUID-4A8596BF-5207-4D04-8AD2-4B136D156B99" name="GUID-4A8596BF-5207-4D04-8AD2-4B136D156B99"></a><h4 id="LNPCB-GUID-4A8596BF-5207-4D04-8AD2-4B136D156B99" class="sect4"><span class="enumeration_section">5.3.1</span>选择行</h4>
                  <div>
                     <p>查询数据库是一种常见的SQL操作。要发出查询，请使用SELECT语句。在以下示例中，您将查询EMP表： <a id="d35601e729" class="indexterm-anchor"></a><a id="d35601e733" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB，SAL + 2000 INTO：emp_name，：JOB-TITLE，：来自EMP的SALARY EMPNO =：EMP-NUMBER END-EXEC。</pre><p>关键字SELECT后面的列名和表达式构成<span class="italic">选择列表</span> 。我们示例中的选择列表包含三个项目。在WHERE子句（以及以下子句，如果存在）中指定的条件下，Oracle将列值返回到INTO子句中的主变量。选择列表中的项目数应该等于INTO子句中的主机变量数，因此可以存储每个返回的值。 <a id="d35601e745" class="indexterm-anchor"></a><a id="d35601e747" class="indexterm-anchor"></a><a id="d35601e751" class="indexterm-anchor"></a><a id="d35601e755" class="indexterm-anchor"></a> 
                     </p>
                     <p>在最简单的情况下，当查询返回一行时，其形式如上一个示例所示（其中EMPNO是唯一键）。但是，如果查询可以返回多行，则必须使用游标获取行或将其选择到主机数组中。 <a id="d35601e762" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果写入的查询只返回一行但实际上可能返回多行，则结果取决于您指定SELECT_ERROR选项的方式。当SELECT_ERROR = YES（缺省值）时，如果返回多行，Oracle会发出消息。 <a id="d35601e769" class="indexterm-anchor"></a> 
                     </p>
                     <p>当SELECT_ERROR = NO时，返回一行，Oracle不会生成错误。</p>
                  </div><a id="LNPCB354"></a><div class="props_rev_3"><a id="GUID-D2BC8FF5-4519-4FEC-978D-B8789B998046" name="GUID-D2BC8FF5-4519-4FEC-978D-B8789B998046"></a><h5 id="LNPCB-GUID-D2BC8FF5-4519-4FEC-978D-B8789B998046" class="sect5"><span class="enumeration_section">5.3.1.1</span>可用条款</h5>
                     <div>
                        <p>您可以在SELECT语句中使用以下所有标准SQL子句：INTO，FROM，WHERE，CONNECT BY，START WITH，GROUP BY，HAVING，ORDER BY和FOR UPDATE OF。 <a id="d35601e798" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB355"></a><div class="props_rev_3"><a id="GUID-646DE444-E6B3-4213-B633-411C1CBDDC87" name="GUID-646DE444-E6B3-4213-B633-411C1CBDDC87"></a><h4 id="LNPCB-GUID-646DE444-E6B3-4213-B633-411C1CBDDC87" class="sect4"><span class="enumeration_section">5.3.2</span>插入行</h4>
                  <div>
                     <p>您可以使用INSERT语句将行添加到表或视图中。在以下示例中，您向EMP表添加一行：<a id="d35601e827" class="indexterm-anchor"></a><a id="d35601e831" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（EMPNO，ENAME，SAL，DEPTNO）值（：EMP_NUMBER，：EMP-NAME，：SALARY，：DEPT-NUMBER）END-EXEC。</pre><p>您在列列表中指定的每个列都必须属于INTO子句中指定的表。VALUES子句指定要插入的值行。值可以是常量，主变量，SQL表达式或伪列，例如USER和SYSDATE。</p>
                     <p>VALUES子句中的值数必须等于列列表中的名称数。如果VALUES子句以与CREATE TABLE定义的顺序相同的顺序包含表中每列的值，则可以省略列列表，但不建议这样做，因为表的定义可能会更改。</p>
                  </div>
               </div><a id="LNPCB356"></a><div class="props_rev_3"><a id="GUID-672BB15A-1E0C-4179-8F2B-16012A02B325" name="GUID-672BB15A-1E0C-4179-8F2B-16012A02B325"></a><h4 id="LNPCB-GUID-672BB15A-1E0C-4179-8F2B-16012A02B325" class="sect4"><span class="enumeration_section">5.3.3</span> DML返还条款</h4>
                  <div>
                     <p><a id="d35601e871" class="indexterm-anchor"></a><a id="d35601e875" class="indexterm-anchor"></a><a id="d35601e877" class="indexterm-anchor"></a><a id="d35601e879" class="indexterm-anchor"></a><a id="d35601e883" class="indexterm-anchor"></a><a id="d35601e887" class="indexterm-anchor"></a><a id="d35601e891" class="indexterm-anchor"></a> INSERT，UPDATE和DELETE语句可以有一个可选项<a id="d35601e896" class="indexterm-anchor"></a> <span class="italic">DML</span> returns <span class="italic">子句</span> ，它将列值表达式<span class="italic">expr</span>返回到主变量<span class="italic">hv</span> ，带有主机指示变量<span class="italic">iv。</span>返回条款<span class="italic"> </span>有这种语法：</p><pre class="oac_no_warn" dir="ltr">{返回| RETURN} {expr [，expr]} INTO {：hv [[INDICATOR]：iv] [，：hv [[INDICATOR]：iv]]}</pre><p>表达式的数量必须等于主机变量的数量。此子句消除了在INSERT或UPDATE之后以及在您需要为应用程序记录该信息时在DELETE之前选择行的需要。<code class="codeph">DML returning clause</code>消除了低效的网络往返，额外处理和服务器内存。例如，您还会注意到触发器插入默认值或主键值时。
                     </p>
                     <p>子查询不允许returns_clause。只有在VALUES子句之后才允许它。</p>
                     <p>例如，我们的INSERT可以在其末尾有一个子句，例如：</p><pre class="oac_no_warn" dir="ltr">返回EMPNO，ENAME，DEPTNO INTO：NEW-EMP-NUMBER，：NEW-EMP-NAME，：DEPT</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-F5251483-48EC-4B39-8E14-68F65480B16B">嵌入式SQL语句和预编译器指令</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB357"></a><div class="props_rev_3"><a id="GUID-CEA14A82-933C-425C-BA9F-92CCF0A16924" name="GUID-CEA14A82-933C-425C-BA9F-92CCF0A16924"></a><h4 id="LNPCB-GUID-CEA14A82-933C-425C-BA9F-92CCF0A16924" class="sect4"><span class="enumeration_section">5.3.4</span>使用子查询</h4>
                  <div>
                     <p><span class="italic">子查询</span>是嵌套的SELECT语句。子查询允许您进行多部分搜索。他们可以习惯<a id="d35601e961" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>提供SELECT，UPDATE和DELETE语句的WHERE，HAVING和START WITH子句中的比较值</p>
                        </li>
                        <li>
                           <p>定义要由CREATE TABLE或INSERT语句插入的行集</p>
                        </li>
                        <li>
                           <p>定义UPDATE语句的SET子句的值</p>
                        </li>
                     </ul>
                     <p>例如，要将行从一个表复制到另一个表，请将INSERT语句中的VALUES子句替换为子查询，如下所示：<a id="d35601e975" class="indexterm-anchor"></a><a id="d35601e979" class="indexterm-anchor"></a><a id="d35601e983" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP2（EMPNO，ENAME，SAL，DEPTNO）从EMP中选择EMPNO，ENAME，SAL，DEPTNO，其中JOB =：JOB-TITLE END-EXEC。</pre><p>请注意INSERT语句如何使用子查询来获取中间结果。</p>
                  </div>
               </div><a id="LNPCB358"></a><div class="props_rev_3"><a id="GUID-0E6EAC73-1363-45C3-8E81-1D2CC9C7DFDF" name="GUID-0E6EAC73-1363-45C3-8E81-1D2CC9C7DFDF"></a><h4 id="LNPCB-GUID-0E6EAC73-1363-45C3-8E81-1D2CC9C7DFDF" class="sect4"><span class="enumeration_section">5.3.5</span>更新行</h4>
                  <div>
                     <p>您可以使用UPDATE语句更改表或视图中指定列的值。在以下示例中，您将更新EMP表中的SAL和COMM列：<a id="d35601e1015" class="indexterm-anchor"></a><a id="d35601e1019" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP SET SAL =：SALARY，COMM =：COMMISSION WHERE EMPNO =：EMP-NUMBER END-EXEC。</pre><p>您可以使用可选的WHERE子句指定更新行的条件。请参阅<span class="q">“ <a href="embedded-SQL.html#GUID-C25F4C09-B61C-4DAF-B594-6F2695073B2D">使用WHERE子句</a> ”</span> 。<a id="d35601e1032" class="indexterm-anchor"></a></p>
                     <p>SET子句列出了必须为其提供值的一个或多个列的名称。您可以使用子查询来提供值，如以下示例所示： <a id="d35601e1038" class="indexterm-anchor"></a><a id="d35601e1042" class="indexterm-anchor"></a><a id="d35601e1044" class="indexterm-anchor"></a><a id="d35601e1048" class="indexterm-anchor"></a><a id="d35601e1052" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP SET SAL =（从EMP中选择AVG（SAL）* 1.1，其中DEPTNO = 20）EMPNO = EMP-NUMBER END-EXEC。</pre></div>
               </div><a id="LNPCB359"></a><div class="props_rev_3"><a id="GUID-CD92DF46-32AC-4362-B354-780D8ABD1DC2" name="GUID-CD92DF46-32AC-4362-B354-780D8ABD1DC2"></a><h4 id="LNPCB-GUID-CD92DF46-32AC-4362-B354-780D8ABD1DC2" class="sect4"><span class="enumeration_section">5.3.6</span>删除行</h4>
                  <div>
                     <p>您使用DELETE语句从表或视图中删除行。在以下示例中，您将从EMP表中删除给定部门中的所有员工： <a id="d35601e1084" class="indexterm-anchor"></a><a id="d35601e1088" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE DEPTNO =：DEPT-NUMBER END-EXEC。</pre><p>您可以使用可选的WHERE子句指定删除行的条件。 <a id="d35601e1097" class="indexterm-anchor"></a><a id="d35601e1101" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCB360"></a><div class="props_rev_3"><a id="GUID-C25F4C09-B61C-4DAF-B594-6F2695073B2D" name="GUID-C25F4C09-B61C-4DAF-B594-6F2695073B2D"></a><h4 id="LNPCB-GUID-C25F4C09-B61C-4DAF-B594-6F2695073B2D" class="sect4"><span class="enumeration_section">5.3.7</span>使用WHERE子句</h4>
                  <div>
                     <p>您可以使用WHERE子句仅选择，更新或删除满足搜索条件的表或视图中的那些行。WHERE子句<span class="italic">搜索条件</span>是一个布尔表达式，可以包括标量主变量，主机数组（不在SELECT语句中）和子查询。 <a id="d35601e1133" class="indexterm-anchor"></a><a id="d35601e1135" class="indexterm-anchor"></a><a id="d35601e1139" class="indexterm-anchor"></a><a id="d35601e1141" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果省略WHERE子句，则处理表或视图中的所有行。如果省略UPDATE或DELETE语句中的WHERE子句，Oracle会将SQLCA中的SQLWARN（5）设置为“W”，以警告所有行都已处理。</p>
                  </div>
               </div>
            </div><a id="LNPCB361"></a><div class="props_rev_3"><a id="GUID-3002FE30-7975-42DA-9A95-F6D085ACC5CD" name="GUID-3002FE30-7975-42DA-9A95-F6D085ACC5CD"></a><h3 id="LNPCB-GUID-3002FE30-7975-42DA-9A95-F6D085ACC5CD" class="sect3"><span class="enumeration_section">5.4</span>游标</h3>
               <div>
                  <p>为了处理SQL语句，Oracle打开了一个名为<span class="italic">私有SQL区域</span>的工作<span class="italic">区</span> 。私有SQL区域存储执行SQL语句所需的信息。称为<span class="italic">游标</span>的标识符允许您命名SQL语句，访问其私有SQL区域中的信息，并在某种程度上控制其处理。<a id="d35601e1178" class="indexterm-anchor"></a><a id="d35601e1182" class="indexterm-anchor"></a></p>
                  <p>对于静态SQL语句，有两种类型的游标： <span class="italic">隐式</span>和<span class="italic">显式</span> 。Oracle隐式声明所有数据定义和数据操作语句的游标，包括使用INTO子句的SELECT语句。
                  </p>
                  <p>检索到的行集称为<span class="italic">结果集</span> ;它的大小取决于符合查询搜索条件的行数。您使用显式游标来标识当前正在处理的行，称为<span class="italic">当前行</span> 。 <a id="d35601e1202" class="indexterm-anchor"></a><a id="d35601e1206" class="indexterm-anchor"></a><a id="d35601e1210" class="indexterm-anchor"></a> 
                  </p>
                  <p>当查询返回多行时，您可以显式定义游标<a id="d35601e1215" class="indexterm-anchor"></a><a id="d35601e1217" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>处理超出查询返回的第一行</p>
                     </li>
                     <li>
                        <p>跟踪当前正在处理的行</p>
                     </li>
                  </ul>
                  <p>游标标识查询返回的行集中的当前行。这允许您的程序一次处理一行。以下语句允许您定义和操作游标： <a id="d35601e1230" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>宣布</p>
                     </li>
                     <li>
                        <p>打开</p>
                     </li>
                     <li>
                        <p>取</p>
                     </li>
                     <li>
                        <p>关</p>
                     </li>
                  </ul>
                  <p>首先，使用DECLARE语句（更确切地说，指令）来命名游标并将其与查询相关联。 <a id="d35601e1250" class="indexterm-anchor"></a><a id="d35601e1254" class="indexterm-anchor"></a> 
                  </p>
                  <p>OPEN语句执行查询并标识满足查询搜索条件的所有行。这些行形成一个称为光标活动集的集合。打开游标后，您可以使用它来检索其关联查询返回的行。 <a id="d35601e1261" class="indexterm-anchor"></a> 
                  </p>
                  <p>逐个检索活动集的行（除非您使用主机数组）。您使用FETCH语句来检索活动集中的当前行。您可以重复执行FETCH，直到检索到所有行。</p>
                  <p>完成从活动集中获取行后，使用CLOSE语句禁用游标，并且活动集变为未定义。</p>
               </div><a id="LNPCB362"></a><div class="props_rev_3"><a id="GUID-925C6FC9-58BB-4746-9351-F79C86C57D44" name="GUID-925C6FC9-58BB-4746-9351-F79C86C57D44"></a><h4 id="LNPCB-GUID-925C6FC9-58BB-4746-9351-F79C86C57D44" class="sect4"><span class="enumeration_section">5.4.1</span>声明游标</h4>
                  <div>
                     <p>您可以使用DECLARE语句通过为其指定名称来定义游标，如以下示例所示： <a id="d35601e1292" class="indexterm-anchor"></a><a id="d35601e1296" class="indexterm-anchor"></a><a id="d35601e1300" class="indexterm-anchor"></a><a id="d35601e1304" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE EMPCURSOR CURSOR用于SELECT ENAME，EMPNO，SAL来自EMP，其中DEPTNO =：DEPT_NUMBER END-EXEC。</pre><p>游标名称是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量，不应在COBOL语句中声明。因此，游标名称不能从一个预编译单元传递到另一个预编译单元。游标名称<span class="italic">不能</span>连字符。它们可以是任意长度，但只有前31个字符才有意义。对于ANSI兼容性，请使用不超过18个字符的游标名称。 <a id="d35601e1319" class="indexterm-anchor"></a><a id="d35601e1323" class="indexterm-anchor"></a>  
                     </p>
                     <p>提供预编译器选项CLOSE_ON_COMMIT以在命令行或配置文件中使用。当CLOSE_ON_COMMIT = YES时，任何未使用WITH HOLD子句声明的游标在COMMIT或ROLLBACK后关闭。<a id="d35601e1330" class="indexterm-anchor"></a><a id="d35601e1334" class="indexterm-anchor"></a></p>
                     <p>如果MODE的指定级别高于CLOSE_ON_COMMIT，则MODE优先。默认值为MODE = ORACLE，CLOSE_ON_COMMIT = NO。如果指定MODE = ANSI，则在COMMIT上将关闭不使用WITH HOLD子句的任何游标。应用程序将运行得更慢，因为游标已关闭并重新打开多次。当MODE = ANSI时设置CLOSE_ON_COMMIT = NO会导致性能提高。要查看MODE等宏选项如何影响微选项（如CLOSE_ON_COMMIT），请参阅<span class="q">“ <a href="precompiler-options.html#GUID-C30AEFAC-5CF7-46F2-AB53-7432BEE38F91">选项值的优先顺序</a> ”</span> 。
                     </p>
                     <p>与游标关联的SELECT语句不能包含INTO子句。相反，INTO子句和输出主机变量列表是FETCH语句的一部分。</p>
                     <p>因为它是声明性的，所以DECLARE语句必须在物理上（不仅仅是逻辑上）在引用游标的所有其他SQL语句之前。也就是说，不允许对游标的前向引用。在以下示例中，OPEN语句放错了位置： <a id="d35601e1349" class="indexterm-anchor"></a><a id="d35601e1353" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN EMPCURSOR END-EXEC。 *  -  MISPLACED OPEN STATEMENT EXEC SQL DECLARE EMPCURSOR CURSOR for SELECT ENAME，EMPNO，SAL from EMP，ENAME =：EMP-NAME END-EXEC。</pre><p>游标控制语句（DECLARE，OPEN，FETCH，CLOSE）必须全部出现在同一预编译单元中。例如，您不能在源文件A.PCO中声明游标，然后在源文件B.PCO中打开它。 <a id="d35601e1360" class="indexterm-anchor"></a><a id="d35601e1364" class="indexterm-anchor"></a> 
                     </p>
                     <p>您的宿主程序可以根据需要声明尽可能多的游标。但是，在给定文件中，每个DECLARE语句都必须是唯一的。也就是说，您不能在一个预编译单元中声明两个具有相同名称的游标，即使是跨块或过程也是如此，因为游标的范围在文件中是全局的。 <a id="d35601e1371" class="indexterm-anchor"></a><a id="d35601e1375" class="indexterm-anchor"></a> 
                     </p>
                     <p> <a id="d35601e1382" class="indexterm-anchor"></a>对于MODE = ANSI或CLOSE_ON_COMMIT = YES的用户，可以在DECLARE部分中使用WITH HOLD子句来覆盖由这两个选项定义的行为。设置这些选项后，将在发出COMMIT时关闭所有游标的行为。由于重新打开游标以继续处理的开销，这可能会对性能产生影响。仔细使用WITH HOLD可以加速在大多数方面需要符合ANSI标准的预编译程序。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-839B1E64-B28C-41BF-9355-783B003C0D81">CLOSE_ON_COMMIT</a></li>
                           <li><a href="database-concepts.html#GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06">DECLARE CURSOR语句中的WITH HOLD子句</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB363"></a><div class="props_rev_3"><a id="GUID-10E7EB5B-2F8F-4983-8F24-1B7824B05DD3" name="GUID-10E7EB5B-2F8F-4983-8F24-1B7824B05DD3"></a><h4 id="LNPCB-GUID-10E7EB5B-2F8F-4983-8F24-1B7824B05DD3" class="sect4"><span class="enumeration_section">5.4.2</span>打开光标</h4>
                  <div>
                     <p>使用OPEN语句执行查询并标识活动集。在以下示例中，将打开名为<span class="italic">EMPCURSOR</span>的游标。 <a id="d35601e1423" class="indexterm-anchor"></a><a id="d35601e1427" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN EMPCURSOR END-EXEC。</pre><p>OPEN将光标定位在活动集的第一行之前。但是，此时实际上没有检索到任何行。这将由FETCH语句完成。</p>
                     <p>打开游标后，在重新打开游标之前，不会重新检查查询的输入主变量。因此，活动集不会改变。要更改活动集，必须重新打开游标。 <a id="d35601e1438" class="indexterm-anchor"></a><a id="d35601e1442" class="indexterm-anchor"></a> 
                     </p>
                     <p>OPEN完成的工作量取决于三个预编译器选项的值：HOLD_CURSOR，RELEASE_CURSOR和MAXOPENCURSORS。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-4FAE1823-EDA0-4A86-B904-FC7FA3CD472B">使用Pro * COBOL预编译器选项</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB364"></a><div class="props_rev_3"><a id="GUID-B60A9158-0F22-4144-B939-1F559C1CC996" name="GUID-B60A9158-0F22-4144-B939-1F559C1CC996"></a><h4 id="LNPCB-GUID-B60A9158-0F22-4144-B939-1F559C1CC996" class="sect4"><span class="enumeration_section">5.4.3</span>从光标中获取</h4>
                  <div>
                     <p>您可以使用FETCH语句从活动集中检索行，并指定将包含结果的输出主机变量。回想一下，与游标关联的SELECT语句不能包含INTO子句。相反，INTO子句和输出主机变量列表是FETCH语句的一部分。在以下示例中，您将获取三个主机变量： <a id="d35601e1479" class="indexterm-anchor"></a><a id="d35601e1481" class="indexterm-anchor"></a><a id="d35601e1485" class="indexterm-anchor"></a><a id="d35601e1489" class="indexterm-anchor"></a><a id="d35601e1493" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME，：EMP-NUMBER，：SALARY END-EXEC。</pre><p>必须先声明并打开游标。第一次执行FETCH时，光标从活动集中的第一行之前移动到第一行。该行成为当前行。FETCH的每次后续执行都会将光标前进到活动集中的下一行，从而更改当前行。光标只能在活动集中向前移动。要返回已经获取的行，必须重新打开游标，然后在活动集的第一行再次开始。</p>
                     <p>如果要更改活动集，则必须将新值分配给与游标关联的查询中的输入主机变量，然后重新打开游标。当MODE = ANSI时，必须在重新打开之前关闭光标。 <a id="d35601e1504" class="indexterm-anchor"></a> 
                     </p>
                     <p>如下一个示例所示，您可以使用不同的输出主机变量集从同一游标中获取。但是，每个FETCH语句的INTO子句中的相应主机变量必须具有相同的数据类型。</p><pre class="oac_no_warn" dir="ltr">用于SELECT ENAME的EXEC SQL DECLARE EMPCURSOR CURSOR，来自EMP的SAL，其中DEPTNO = 20 END-EXEC。 ...EXEC SQL OPEN EMPCURSOR END-EXEC。 EXEC SQL WHENEVER NOT FOUND DO ...环。 EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME1，：SAL1 END-EXEC EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME2，：SAL2 END-EXEC EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME3，：SAL3 END-EXEC ...转到循环。 ...END-PERFORM。</pre><p>如果活动集为空或不包含更多行，则FETCH将“未找到数据”Oracle警告代码返回到SQLCA中的SQLCODE（如果MODE = ANSI，则还将设置可选的SQLSTATE变量。）输出主机变量的状态是不确定的。（在典型程序中，WHENEVER NOT FOUND语句检测到此错误。）要重新使用游标，必须重新打开它。 <a id="d35601e1515" class="indexterm-anchor"></a><a id="d35601e1519" class="indexterm-anchor"></a><a id="d35601e1523" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCB365"></a><div class="props_rev_3"><a id="GUID-7EFA839A-F40F-467B-B61A-26F2F2F24BA0" name="GUID-7EFA839A-F40F-467B-B61A-26F2F2F24BA0"></a><h4 id="LNPCB-GUID-7EFA839A-F40F-467B-B61A-26F2F2F24BA0" class="sect4"><span class="enumeration_section">5.4.4</span>关闭光标</h4>
                  <div>
                     <p>完成从活动集中获取行后，关闭游标以释放通过打开游标获取的资源，例如存储。关闭游标时，将释放解析锁。释放的资源取决于您如何指定HOLD_CURSOR和RELEASE_CURSOR选项。在以下示例中，您将关闭名为<span class="italic">EMPCURSOR</span>的游标： <a id="d35601e1553" class="indexterm-anchor"></a><a id="d35601e1557" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE EMPCURSOR END-EXEC。</pre><p>您无法从关闭的游标中获取，因为它的活动集变为未定义。如有必要，您可以重新打开游标（例如，使用输入主机变量的新值）。</p>
                     <p>当CLOSE_ON_COMMIT = NO（MODE = ORACLE时的默认值）时，发出COMMIT或ROLLBACK只会关闭使用FOR UPDATE子句声明或CURRENT OF子句引用的游标。其他不受COMMIT或ROLLBACK语句影响的游标，如果已经打开，则保持打开状态。但是，当CLOSE_ON_COMMIT = YES（MODE = ANSI时的默认值）时，发出COMMIT或ROLLBACK将关闭<span class="italic">所有</span>游标。<a id="d35601e1571" class="indexterm-anchor"></a></p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-839B1E64-B28C-41BF-9355-783B003C0D81">CLOSE_ON_COMMIT</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB366"></a><div class="props_rev_3"><a id="GUID-E0B72EA2-521D-4604-BD41-0B2B1BC59381" name="GUID-E0B72EA2-521D-4604-BD41-0B2B1BC59381"></a><h4 id="LNPCB-GUID-E0B72EA2-521D-4604-BD41-0B2B1BC59381" class="sect4"><span class="enumeration_section">5.4.5</span>使用CURRENT OF子句</h4>
                  <div>
                     <p>您可以在DELETE或UPDATE语句中使用CURRENT OF <span class="italic">cursor_name</span>子句来引用从命名游标中获取的最新行。光标必须打开并放在一行上。如果未执行提取或游标未打开，则CURRENT OF子句将导致错误并且不处理任何行。 <a id="d35601e1607" class="indexterm-anchor"></a><a id="d35601e1609" class="indexterm-anchor"></a> 
                     </p>
                     <p>声明在UPDATE或DELETE语句的CURRENT OF子句中引用的游标时，FOR UPDATE OF子句是可选的。CURRENT OF子句指示预编译器在必要时添加FOR UPDATE子句。</p>
                     <p>在以下示例中，您使用CURRENT OF子句来引用从名为<span class="italic">EMPCURSOR</span>的游标中获取的最新行： <a id="d35601e1619" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">用于SELECT ENAME的EXEC SQL DECLARE EMPCURSOR CURSOR，来自EMP的SAL，其中JOB ='CLERK'END-EXEC。 ...EXEC SQL OPEN EMPCURSOR END-EXEC。 EXEC SQL WHENEVER NOT FOUND DO ...环。 EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME，：SALARY END-EXEC。 ...EXEC SQL UPDATE EMP SET SAL =：当前EPCCURSOR END-EXEC当前的新SALARY。转到循环。</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前的条款</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB367"></a><div class="props_rev_3"><a id="GUID-F6BD466E-E25D-4238-BAA8-A2CDBDFC886B" name="GUID-F6BD466E-E25D-4238-BAA8-A2CDBDFC886B"></a><h4 id="LNPCB-GUID-F6BD466E-E25D-4238-BAA8-A2CDBDFC886B" class="sect4"><span class="enumeration_section">5.4.6</span>限制</h4>
                  <div>
                     <p>显式FOR UPDATE OF或隐式FOR UPDATE获取独占行锁。所有行都在打开时锁定，而不是在提取时锁定，并在提交或回滚时释放。如果在提交后尝试从FOR UPDATE游标获取，Oracle会生成错误。<a id="d35601e1656" class="indexterm-anchor"></a><a id="d35601e1660" class="indexterm-anchor"></a></p>
                     <p>您不能将CURRENT OF子句与使用连接声明的游标一起使用，因为内部，CURRENT OF机制使用ROWID伪列，并且无法指定ROWID与哪个表相关。有关替代方案，请参阅<span class="q">“ <a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前条款</a> ”</span> 。最后，您不能在动态SQL中使用CURRENT OF子句。</p>
                  </div>
               </div><a id="LNPCB368"></a><div class="props_rev_3"><a id="GUID-189E9DA4-7D12-4BCB-9CA6-23C58C079AFB" name="GUID-189E9DA4-7D12-4BCB-9CA6-23C58C079AFB"></a><h4 id="LNPCB-GUID-189E9DA4-7D12-4BCB-9CA6-23C58C079AFB" class="sect4"><span class="enumeration_section">5.4.7</span>典型的陈述顺序</h4>
                  <div>
                     <p>以下示例显示了使用CURRENT OF子句和FOR UPDATE OF子句的典型游标控制语句序列：</p><pre class="oac_no_warn" dir="ltr">*  - 定义光标。EXEC SQL DECLARE EMPCURSOR CURSOR for SELECT ENAME，JOB from EMP WHERE EMPNO =：EMP-NUMBER FOR JODATE OF JOB END-EXEC。 *  - 打开光标并识别活动集。EXEC SQL OPEN EMPCURSOR END-EXEC。 *  - 如果最后一行已被提取，则退出。EXEC SQL WHENEVER没有找到GOTO NO-MORE END-EXEC。 *  - 在循环中获取和处理数据。环。 <span class="bold">     </span> EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME，：JOB-TITLE END-EXEC。 *  - 对获取的数据进行操作的主机语言语句EXEC SQL UPDATE EMP SET JOB =：NEW-JOB-TITLE当前EMPCURSOR END-EXEC的当前状态。转到循环。 ...MO-MORE。 *  - 禁用光标。
   <span class="bold"> </span> EXEC SQL CLOSE EMPCURSOR END-EXEC。 EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。</pre></div>
               </div><a id="LNPCB369"></a><div class="props_rev_3"><a id="GUID-F775DB34-E155-452E-B970-2A2FAC3049C6" name="GUID-F775DB34-E155-452E-B970-2A2FAC3049C6"></a><h4 id="LNPCB-GUID-F775DB34-E155-452E-B970-2A2FAC3049C6" class="sect4"><span class="enumeration_section">5.4.8</span>定位更新</h4>
                  <div>
                     <p>以下骨架示例使用通用ROWID演示定位更新，该ROWID在<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-D466F3CE-BD79-4BB3-A8BA-49056190C6E1">Universal ROWIDs</a> ”中</span>定义：</p><pre class="oac_no_warn" dir="ltr">...01 MY-ROWID SQL-ROWID。 ...EXEC SQL ALLOCATE：MY-ROWID END-EXEC。 SELECT ROWID的EXEC SQL DECLARE C CURSOR，...从MYTABLE更新...END-EXEC。 EXEC SQL OPEN C END-EXEC。 EXEC SQL FETCH C INTO：MY-ROWID ......END-EXEC。 *处理检索到的数据。...EXEC SQL UPDATE MYTABLE SET ...WHERE ROWID =：MY-ROWID END-EXEC。 ...NO-MORE-DATA：EXEC SQL CLOSE C END-EXEC。 EXEC SQL FREE：MY-ROWID END-EXEC。 ...</pre></div>
               </div><a id="LNPCB370"></a><div class="props_rev_3"><a id="GUID-2A2D2374-4A18-406D-AA06-2DEA5A0A8E25" name="GUID-2A2D2374-4A18-406D-AA06-2DEA5A0A8E25"></a><h4 id="LNPCB-GUID-2A2D2374-4A18-406D-AA06-2DEA5A0A8E25" class="sect4"><span class="enumeration_section">5.4.9</span> PREFETCH预编译器选项</h4>
                  <div>
                     <p>预编译器选项PREFETCH通过预取行来实现更有效的查询。这减少了所需的服务器往返次数并减少了所需的内存。配置文件或命令行中PREFETCH选项值设置的行数用于涉及显式游标的所有查询，受标准优先级规则的约束。</p>
                     <p>在内联使用时，PREFETCH选项必须位于以下任何游标语句之前：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用<span class="italic">host_var_list</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用DESCRIPTOR <span class="italic">desc_name</span></p>
                        </li>
                     </ul>
                     <p>执行OPEN时，PREFETCH的值给出执行查询时要预取的行数。您可以将值设置为0（无预取）到9999。默认值为1。</p>
                     <div class="infoboxnote" id="GUID-2A2D2374-4A18-406D-AA06-2DEA5A0A8E25__GUID-D6C5FAA1-E9DB-43E2-BFFE-599DF0245226">
                        <p class="notep1">注意：</p>
                        <p>PREFETCH预编译器选项专门用于增强单行读取的性能。无论分配了哪个值，PREFETCH值在执行数组提取时都不起作用。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB371"></a><div class="props_rev_3"><a id="GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611" name="GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611"></a><h3 id="LNPCB-GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611" class="sect3"><span class="enumeration_section">5.5可</span>滚动游标</h3>
               <div>
                  <p>可滚动游标是Oracle执行SQL语句并存储在执行期间处理的信息的工作区。</p>
                  <p>执行游标时，查询结果将放入一组称为结果集的行中。结果集可以按顺序或非顺序获取。非顺序结果集称为可滚动游标。</p>
                  <p>可滚动游标使用户能够以前向，后向和随机方式访问数据库结果集的行。这使程序能够获取结果集中的任何行。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../lnoci/using-sql_statements-in-oci.html#LNOCI-GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" target="_blank">关于在OCI中使用可滚动游标</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB372"></a><div class="props_rev_3"><a id="GUID-AC00EAA0-5C2E-4E26-9287-EFDC5B36383B" name="GUID-AC00EAA0-5C2E-4E26-9287-EFDC5B36383B"></a><h4 id="LNPCB-GUID-AC00EAA0-5C2E-4E26-9287-EFDC5B36383B" class="sect4"><span class="enumeration_section">5.5.1</span>使用可滚动游标</h4>
                  <div>
                     <p>以下语句允许您定义和操作可滚动游标。</p>
                  </div><a id="LNPCB373"></a><div class="props_rev_3"><a id="GUID-4F0D9712-587E-4460-9AA3-EAE3FFF82788" name="GUID-4F0D9712-587E-4460-9AA3-EAE3FFF82788"></a><h5 id="LNPCB-GUID-4F0D9712-587E-4460-9AA3-EAE3FFF82788" class="sect5"><span class="enumeration_section">5.5.1.1</span> DECLARE SCROLL CURSOR</h5>
                     <div>
                        <p>您可以使用DECLARE &lt;游标名称&gt; SCROLL CURSOR语句来命名可滚动游标并将其与查询相关联。</p>
                     </div>
                  </div><a id="LNPCB374"></a><div class="props_rev_3"><a id="GUID-34ED7995-ECC8-44AB-95B2-3300A6A3E4F3" name="GUID-34ED7995-ECC8-44AB-95B2-3300A6A3E4F3"></a><h5 id="LNPCB-GUID-34ED7995-ECC8-44AB-95B2-3300A6A3E4F3" class="sect5"><span class="enumeration_section">5.5.1.2</span>开放</h5>
                     <div>
                        <p>您可以使用与不可滚动游标相同的方式使用OPEN语句。</p>
                     </div>
                  </div><a id="LNPCB375"></a><div class="props_rev_3"><a id="GUID-5FC11915-7DF1-4695-BE3C-964D8948C450" name="GUID-5FC11915-7DF1-4695-BE3C-964D8948C450"></a><h5 id="LNPCB-GUID-5FC11915-7DF1-4695-BE3C-964D8948C450" class="sect5"><span class="enumeration_section">5.5.1.3</span> FETCH</h5>
                     <div>
                        <p>您可以使用FETCH语句以随机方式获取所需的行。应用程序可以直接向上或向下获取行，第一行或最后一行，或以随机方式获取任何一行。</p>
                        <p>FETCH语句提供以下选项。</p>
                        <ol>
                           <li>
                              <p>FETCH FIRST</p>
                              <p>从结果集中获取第一行。</p>
                           </li>
                           <li>
                              <p>FETCH PRIOR</p>
                              <p>获取当前行之前的行。</p>
                           </li>
                           <li>
                              <p>FETCH NEXT</p>
                              <p>从当前位置获取下一行。这与不可滚动的游标FETCH相同。</p>
                           </li>
                           <li>
                              <p>FETCH LAST</p>
                              <p>从结果集中获取最后一行。</p>
                           </li>
                           <li>
                              <p>FETCH CURRENT</p>
                              <p>获取当前行。</p>
                           </li>
                           <li>
                              <p>FETCH RELATIVE <span class="italic">n</span> 
                              </p>
                              <p>取相对于当前行，其中<span class="italic">n</span>是偏移量的第<span class="italic">n</span>行。
                              </p>
                           </li>
                           <li>
                              <p>FETCH ABSOLUTE <span class="italic">n</span></p>
                              <p>获取第<span class="italic">n</span>行，其中<span class="italic">n</span>是结果集开头的偏移量。
                              </p>
                           </li>
                        </ol>
                        <p>以下示例描述如何从结果集中FETCH最后一条记录。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor用于SELECT ename的SCROLL CURSOR，sal FROM emp WHERE deptno = 20; ...EXEC SQL OPEN emp_cursor; EXEC SQL FETCH LAST emp_cursor INTO：emp_name，：sal; EXEC SQL CLOSE emp_cursor;</pre></div>
                  </div><a id="LNPCB376"></a><div class="props_rev_3"><a id="GUID-918D3EE6-A1EB-477B-9BCE-68CC709F9E0D" name="GUID-918D3EE6-A1EB-477B-9BCE-68CC709F9E0D"></a><h5 id="LNPCB-GUID-918D3EE6-A1EB-477B-9BCE-68CC709F9E0D" class="sect5"><span class="enumeration_section">5.5.1.4</span>关闭</h5>
                     <div>
                        <p>您可以使用CLOSE语句，方法与不可滚动游标的情况相同。</p>
                        <div class="infoboxnote" id="GUID-918D3EE6-A1EB-477B-9BCE-68CC709F9E0D__GUID-59C65F29-5A1C-4781-A12A-B002B8F65724">
                           <p class="notep1">注意：</p>
                           <p>您不能将可滚动游标用于REF游标。</p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB377"></a><div class="props_rev_3"><a id="GUID-6B608E46-B177-4560-BCDD-4FC38A057248" name="GUID-6B608E46-B177-4560-BCDD-4FC38A057248"></a><h4 id="LNPCB-GUID-6B608E46-B177-4560-BCDD-4FC38A057248" class="sect4"><span class="enumeration_section">5.5.2</span> CLOSE_ON_COMMIT预编译器选项</h4>
                  <div>
                     <p>CLOSE_ON_COMMIT微预编译器选项提供了在执行COMMIT时选择是否关闭所有游标以及宏选项MODE = ANSI的功能。当MODE = ANSI时，CLOSE_ON_COMMIT具有默认值YES。显式设置CLOSE_ON_COMMIT = NO会带来更好的性能，因为执行COMMIT时不会关闭游标，无需重新打开游标并产生额外的解析。</p>
                  </div>
               </div><a id="LNPCB378"></a><div class="props_rev_3"><a id="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C" name="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C"></a><h4 id="LNPCB-GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C" class="sect4"><span class="enumeration_section">5.5.3</span> PREFETCH预编译器选项</h4>
                  <div>
                     <p>预编译器选项PREFETCH通过预取给定数量的行来允许更有效的查询。这减少了所需的服务器往返次数并减少了总体内存使用量。PREFETCH选项值设置的行数用于涉及显式游标的所有查询，受标准优先级规则的约束。在内联使用时，PREFETCH选项必须位于以下任何游标语句之前：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用<span class="italic">host_var_list</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用DESCRIPTOR <span class="italic">desc_name</span></p>
                        </li>
                     </ul>
                     <p>执行OPEN时，PREFETCH的值给出执行查询时要预取的行数。您可以将值设置为0（无预取）到65535。默认值为1。</p>
                     <div class="infoboxnote" id="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C__GUID-D2FDE31F-3816-46F3-BFEB-74713549D99F">
                        <p class="notep1">注意：</p>
                        <p>PREFETCH选项的默认值为1  - 每次往返返回一行。如果选择不使用PREFETCH选项，则必须使用命令行，通过将PREFETCH选项设置为0来显式禁用它。</p>
                        <p>检索LONG或LOB列时会自动禁用PREFETCH。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C__GUID-A4FA1A47-B66D-41AA-AB1B-6F98AFDC2890">
                        <p class="notep1">注意：</p>
                        <p>PREFETCH主要用于增强单行读取的性能。使用数组提取时，PREFETCH无效。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C__GUID-12D32AF0-AF35-492A-9B59-ABAA5A0CBCC6">
                        <p class="notep1">注意：</p>
                        <p>应明智地使用PREFETCH选项，并根据具体情况使用。选择适当的预取值，以优化特定FETCH语句的性能。要完成此操作，请使用内联预取选项而不是命令行预取选项。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-EB38958F-94BE-4227-BAAB-FB5A77D0913C__GUID-531F6D29-4526-41D9-A5E6-B346F6F84A85">
                        <p class="notep1">注意：</p>
                        <p>通过在FETCH语句中使用带有主变量的指示符变量，可以简化许多大型应用程序的性能。</p>
                        <p>要使预编译器应用程序在单行读取时使用PREFETCH选项获得最大优势，强烈建议您使用指示符变量。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB379"></a><div class="props_rev_3"><a id="GUID-B871F7A4-D8FE-4D51-AF3E-ECC92B3C2E8B" name="GUID-B871F7A4-D8FE-4D51-AF3E-ECC92B3C2E8B"></a><h3 id="LNPCB-GUID-B871F7A4-D8FE-4D51-AF3E-ECC92B3C2E8B" class="sect3"><span class="enumeration_section">5.6</span>灵活的B区长度</h3>
               <div>
                  <p>当格式设置为ANSI时，Pro * Cobol程序的B区长度限制为72。 Cobol编译器现在可以支持B区长度高达253。这为程序员提供了键入超过72列的行的灵活性。Pro * Cobol现在支持B区域长度高达253，当Pro * Cobol应用程序预编译时</p>
                  <p><code class="codeph">FORMAT=VARIABLE</code> <code class="codeph">IRECLEN=300</code></p>
                  <p>选项。</p>
               </div>
            </div><a id="LNPCB381"></a><a id="LNPCB380"></a><div class="props_rev_3"><a id="GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724" name="GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724"></a><h3 id="LNPCB-GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724" class="sect3"><span class="enumeration_section">5.7</span>修复执行计划</h3>
               <div>
                  <p>在一个环境中开发模块，然后集成并部署到另一个环境中的应用程序开发环境中，应用程序的性能会受到影响。有时，预编译器应用程序的性能会受到数据库环境变化的影响。这些可能包括优化程序统计信息的更改，优化程序设置的更改或影响内存结构大小的参数更改。</p>
                  <p>要在开发环境中修复Pro * Cobol中使用的SQL的执行计划，您需要在预编译时使用Oracle的大纲功能。大纲实现为一组与SQL语句关联的优化程序提示。如果您为语句启用了大纲，Oracle会自动考虑存储的提示，并尝试根据这些提示生成执行计划。通过这种方式，您可以确保在将模块集成或部署到不同环境时不会影响性能。</p>
                  <p>您可以使用以下SQL语句在Pro * Cobol中创建轮廓：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">删除</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">插入...选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">创建表...选择</code></p>
                     </li>
                  </ul>
                  <p>如果设置了outline选项，则预编译器会在成功预编译结束时生成两个文件，一个SQL文件和一个LOG文件。命令行选项<code class="codeph">outline</code>和<code class="codeph">outlnprefix</code>控制<code class="codeph">outline</code>的生成。
                  </p>
                  <div class="infoboxnotealso" id="GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724__GUID-E9018AB1-F496-4B37-A768-7D9BD9C79741">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="precompiler-options.html#GUID-B0794F03-C488-4F87-92D2-6B4BEF74EBFB">预编译器选项</a>有关这些命令行选项的更多详细信息</p>
                  </div>
                  <p>每个生成的大纲名称都是唯一的由于应用程序中使用的文件名是唯一的，因此此信息用于生成大纲名称。此外，类别名称也是前缀。</p>
                  <div class="infoboxnote" id="GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724__GUID-8A316962-80EC-4D9F-8FB3-45FE55A16E83">
                     <p class="notep1">警告：</p>
                     <p>Oracle仅允许128个字节的大纲名称。如果超出限制，预编译器将标记错误。您可以使用<code class="codeph">outlnprefix</code>选项限制大纲名称的长度。
                     </p>
                  </div>
                  <div class="example" id="GUID-77A202B5-6C6B-4A54-9BDD-20B96A21F724__GUID-A7CFA253-DF24-4E8E-B6AB-1AC9423EAC40">
                     <p class="titleinexample">示例5-1生成包含轮廓的SQL文件</p>
                     <p>您需要使用outline选项预编译以下程序，以生成包含此程序中所有支持大纲的SQL语句的大纲的SQL文件。</p><pre class="oac_no_warn" dir="ltr">************************************************** *************** * outlndemo：* *将为以下SQL操作创建轮廓，* * 1。创建 ...SELECT * * 2。插入 ...SELECT * * 3。更新* * 4。删除* * 5。选择 * ************************************************ *****************识别部门。 PROGRAM-ID。 outlndemo。环境部门。配置部分。数据部门。工作储存部分。 * EMBEDDED COBOL（文件“OUTNDEMO.PCO”）EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 ENAME PIC X（10）。01 JOB PIC X（9）。01 SAL PIC X（6）。01 COMM PIC X（6）。EXEC SQL END DECLARE SECTION END-EXEC。 01 STRINGFIELDS。 02 STR PIC X（18）变化。 EXEC SQL包含SQLCA END-EXEC。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 EXEC SQL INSERT INON BONUS从EMP中选择ENAME，JOB，SAL，COMM，在那里工作就像'SALESMAN'END-EXEC。 EXEC SQL UPDATE BONUS SET SAL = SAL * 1.1 WHERE SAL &lt;1500 END-EXEC。 EXEC SQL DECLARE C1 CURSOR用于选择ENAME，JOB，SAL，COMM来自SAL END-EXEC的奖励订单。 EXEC SQL OPEN C1 END-EXEC。显示“更新的BONUS表的内容”。显示“ENAME JOB SAL COMM”。显示“”。EXEC SQL WHENEVER未找到GOTO END-FETCH END-EXEC。取回的数据。 EXEC SQL FETCH C1 INTO：ENAME，：JOB，：SAL，：COMM END-EXEC。显示ENAME，JOB，SAL，COMM。去FETCH-DATA。 END取得。 EXEC SQL CLOSE C1 END-EXEC。 EXEC SQL WHENEVER未找到执行SQL-ERROR END-EXEC。 EXEC SQL DELETE来自BONUS END-EXEC。 EXEC SQL CREATE TABLE OUTLNDEMO_TAB作为选择EMPNO，ENAME，SAL来自EMP，其中DEPTNO = 10 END-EXEC。 EXEC SQL DROP TABLE OUTLNDEMO_TAB END-EXEC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。登录。将“scott”移至USERNAME-ARR。移动5到USERNAME-LEN。将“老虎”移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。 *处理SQL错误条件SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPCB383"></a><a id="LNPCB382"></a><div class="props_rev_3"><a id="GUID-BE26D6FB-7ABF-4039-B417-C24183FEABBE" name="GUID-BE26D6FB-7ABF-4039-B417-C24183FEABBE"></a><h4 id="LNPCB-GUID-BE26D6FB-7ABF-4039-B417-C24183FEABBE" class="sect4"><span class="enumeration_section">5.7.1</span> SQL文件</h4>
                  <div>
                     <p>生成的文件名具有以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .SQL</pre><p>在Pro * Cobol中，对于文件“abc.pco”，生成的SQL文件将为abc_pco.sql。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-BE26D6FB-7ABF-4039-B417-C24183FEABBE__GUID-1EA9F869-8515-4CDC-8E16-6BA8ACB61805">生成的文件格式</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果未使用outlnprefix选项，则用作大纲名称和注释的唯一标识符的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;category_name&gt; _ &lt;filename&gt; _ &lt;filetype&gt; _ &lt;序列号&gt;</pre><p>如果使用outlnprefix选项（outlnprefix = &lt;prefix_name&gt;），则用作大纲名称和注释的唯一标识符的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;prefix_name&gt; _ &lt;序列号&gt;</pre><p>如果outline = yes，这是默认类别，则&lt;category_name&gt;将为DEFAULT，大纲名称将为：</p><pre class="oac_no_warn" dir="ltr">DEFAULT_ &lt;文件名&gt; _ &lt;文件类型&gt; _ &lt;序列号&gt;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">&lt;prefix_name&gt; _ &lt;序列号&gt;</pre><p><code class="codeph">&lt;sequence no.&gt;</code>的允许范围是0000到9999。
                        </p>
                        <p>生成的预编译文件中的SQL将附加注释，因为它出现在该SQL的大纲中。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB385"></a><a id="LNPCB386"></a><a id="LNPCB387"></a><a id="LNPCB388"></a><a id="LNPCB389"></a><a id="LNPCB390"></a><a id="LNPCB391"></a><a id="LNPCB392"></a><a id="LNPCB393"></a><a id="LNPCB384"></a><div class="props_rev_3"><a id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3" name="GUID-E6380A21-418E-4938-9831-01B9FACB40E3"></a><h5 id="LNPCB-GUID-E6380A21-418E-4938-9831-01B9FACB40E3" class="sect5"><span class="enumeration_section">5.7.1.1</span>例子</h5>
                     <div>
                        <p>请考虑以下示例。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-7B9BE638-E098-4D2D-9870-9290A7F3A21C">例1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pco有这些陈述</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var END-EXEC。 EXEC SQL select * from dept END-EXEC。</pre><p>如果未使用outline = mycat1和outlnprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-4F7D7E74-7949-4306-913A-766E6D94BD4C">abc_pco.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* mycat1_abc_pco_0000 */;</code>为mycat1类别创建或替换大纲mycat1_abc_pco_0000， <code class="codeph">select * from emp where empno=:b1 /* mycat1_abc_pco_0000 */;</code></p>
                           <p>在<code class="codeph">select * from dept /* mycat1_abc_pco_0001 */;</code>上为类别mycat1创建或替换大纲mycat1_abc_pco_0001 <code class="codeph">select * from dept /* mycat1_abc_pco_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-41EC0FA3-C77A-4C24-9F39-A17172BE15F8">abc.cob的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">01 SQ0001全球。 02 FILLER PIC X（60）VALUE“select * from emp where empno =：b1  -  / * mycat1_abc_pco_0000 * /  - ”“。
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-59DA2F51-F9D6-4D4E-A29C-F4E09945A177">例2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pco有这些陈述</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var END-EXEC。 EXEC SQL select * from dept END-EXEC。</pre><p>如果outline = mycat1和outlnprefix = myprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-0CA0E1D6-441E-4AA1-ABF1-D576394633AF">abc_pco.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code>为类别mycat1创建或替换大纲myprefix_0000， <code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
                           <p>在<code class="codeph">select * from dept /* myprefix_0001 */;</code>上为类别mycat1创建或替换大纲myprefix_0001 <code class="codeph">select * from dept /* myprefix_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-C59CA6D8-7671-4575-B485-D66D2426CA0E">abc.cob的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">01 SQ0001全球。 02 FILLER PIC X（60）VALUE“select * from emp where empno =：b1  -  / * myprefix_0000 * /  - ”“。
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-7595EA80-395F-4033-970D-45E4B1C79DA0">例3</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pco有这些陈述</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var END-EXEC。 EXEC SQL select * from dept END-EXEC。</pre><p>如果outline = yes和outlnprefix = myprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-066D45B8-F8ED-49AA-AFF1-6612392F8791">abc_pco.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code>创建或替换大纲myprefix_0000， <code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
                           <p>在<code class="codeph">select * from dept /* myprefix_0001 */;</code>上创建或替换outline myprefix_0001 <code class="codeph">select * from dept /* myprefix_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E6380A21-418E-4938-9831-01B9FACB40E3__GUID-7DC4A16D-AA9E-4970-90D4-BAAD24181841">abc.cob的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">01 SQ0001全球。 03 FILLER PIC X（60）VALUE“select * from emp where empno =：b1  -  / * myprefix_0000 * /  - ”“。
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB395"></a><a id="LNPCB396"></a><a id="LNPCB394"></a><div class="props_rev_3"><a id="GUID-569E55D5-2E15-4FC5-8C3F-9C8BD9E25232" name="GUID-569E55D5-2E15-4FC5-8C3F-9C8BD9E25232"></a><h4 id="LNPCB-GUID-569E55D5-2E15-4FC5-8C3F-9C8BD9E25232" class="sect4"><span class="enumeration_section">5。1。2</span>日志文件</h4>
                  <div>
                     <p>生成的文件名具有以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .log中</pre><p>在Pro * Cobol中，对于文件“abc.pco”，生成的LOG文件将为abc_pco.log。</p>
                     <p>请考虑以下示例。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-569E55D5-2E15-4FC5-8C3F-9C8BD9E25232__GUID-3061C338-1828-4F51-B4B4-065E4F2E71D9">例1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果abc.pco有声明</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp END-EXEC。</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-569E55D5-2E15-4FC5-8C3F-9C8BD9E25232__GUID-8AEC1070-CB2C-44E2-B7CB-94E165C632E9">abc_pco.log的内容</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CATEGORY &lt;Category_name&gt;源SQL_0 SELECT * FROM emp OUTLINE NAME abc_pco_0000 OUTLINE SQL_0选择* from emp / * abc_pco_0000 * /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB397"></a><div class="props_rev_3"><a id="GUID-02630564-C8F8-49E8-8D9C-9746185723D3" name="GUID-02630564-C8F8-49E8-8D9C-9746185723D3"></a><h3 id="LNPCB-GUID-02630564-C8F8-49E8-8D9C-9746185723D3" class="sect3"><span class="enumeration_section">5.8</span>示例程序2：光标操作</h3>
               <div>
                  <p>该程序登录到Oracle，声明并打开游标，获取所有销售人员的姓名，工资和佣金，显示结果，然后关闭游标</p>
                  <p>除最后一个之外的所有提取都返回一行，如果在提取期间没有检测到错误，则返回成功状态代码。最终获取失败并将“无数据发现”Oracle警告代码返回到SQLCA中的SQLCODE。实际获取的累计行数可在SQLCA的SQLERRD（3）中找到。</p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序2：光标操作* * * *此程序登录到ORACLE，声明并打开游标，* *获取名称，工资和佣金所有* *销售人员，显示结果，然后关闭光标。* ************************************************* ****************身份识别部门。 PROGRAM-ID。 CURSOR-OPS。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 EMP-REC-VARS。 05 EMP-NAME PIC X（10）变化。 05 SALARY PIC S9（6）V99显示标志领先独立。 05委员会PIC S9（6）V99显示标志领先分离。 EXEC SQL VAR SALARY是显示（8,2）END-EXEC。 EXEC SQL VAR COMMISSION是显示（8,2）END-EXEC。 EXEC SQL END DECLARE SECTION END-EXEC。 EXEC SQL包含SQLCA END-EXEC。 01 DISPLAY-VARIABLES。 05 D-EMP-NAME PIC X（10）。05 D-SALARY PIC Z（4）9.99。05 D-COMMISSION PIC Z（4）9.99。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 EXEC SQL DECLARE SALESPEOPLE CURSOR for SELECT ENAME，SAL，COMM from EMP JOB LIKE'RESES％'END-EXEC。 EXEC SQL OPEN SALESPEOPLE END-EXEC。显示“”。展示“销售人员薪酬委员会”。显示“----------- ---------- ----------”。FETCH-LOOP。 EXEC SQL无法找到执行签名END-EXEC。 EXEC SQL FETCH SALESPEOPLE INTO：EMP-NAME，：SALARY，：COMMISSION END-EXEC。将EMP-NAME-ARR移动到D-EMP-NAME。将薪酬转移到D-SALARY。向D-COMMISSION转移委员会。显示D-EMP-NAME，“”，D-SALARY，“”，D-COMMISSION。向EMP-NAME-ARR移动空间。去FETCH-LOOP。登录。将“SCOTT”移至USERNAME-ARR。移动5到USERNAME-LEN。将“TIGER”转移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE作为用户：”，USERNAME-ARR。登出。 EXEC SQL CLOSE SALESPEOPLE END-EXEC。显示“”。显示“有一个好日子。”显示“”。EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。 SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
            </div>
         </div>
      </article>
   </body>
</html>