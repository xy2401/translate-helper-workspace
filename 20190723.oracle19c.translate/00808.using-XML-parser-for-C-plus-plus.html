<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C++."></meta>
      <meta name="description" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C++."></meta>
      <title>使用XML Parser for C ++</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C++."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="adx_cp_unified.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-XSLT-processor-for-C-plus-plus.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="adx_cp_unified.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-XSLT-processor-for-C-plus-plus.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-C-plus-plus.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for C ++</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用XML Parser for C ++</li>
            </ol>
            <a id="GUID-CB096401-717C-4EF3-B136-82846BE7F453" name="GUID-CB096401-717C-4EF3-B136-82846BE7F453"></a><a id="ADXDK1049"></a><a id="ADXDK1900"></a>
            
            <h2 id="ADXDK-GUID-CB096401-717C-4EF3-B136-82846BE7F453" class="sect2"><span class="enumeration_chapter">28</span>使用XML Parser for C ++</h2>
         </header>
         <div class="ind">
            <div>
               <p>解释了如何使用C ++的可扩展标记语言（XML）解析器。</p>
               <div class="section"></div>
               <!-- class="section" -->
               <div class="infoboxnote" id="GUID-CB096401-717C-4EF3-B136-82846BE7F453__GUID-527B9164-857A-4F2B-8724-5146FD455736">
                  <p class="notep1">注意：</p>
                  <p>在<code class="codeph">xml.hpp</code>使用统一的C ++应用程序编程接口（API），用于Oracle XML Developer's Kit（XDK）应用程序。在较旧的，nonunified C ++ API <code class="codeph">oraxml.hpp</code>已被废弃，仅支持向后兼容。它将在以后的版本中删除。
                  </p>
               </div>
            </div><a id="ADXDK19903"></a><div class="props_rev_3"><a id="GUID-FACA5EE5-5773-445A-BD9F-E4CB137BE28A" name="GUID-FACA5EE5-5773-445A-BD9F-E4CB137BE28A"></a><h3 id="ADXDK-GUID-FACA5EE5-5773-445A-BD9F-E4CB137BE28A" class="sect3">Oracle XML Parser for C ++简介</h3>
               <div>
                  <p>用于C ++的Oracle XML解析器确定XML文档是否格式正确，并可选择根据文档类型定义（DTD）或可扩展标记语言（XML）架构对其进行验证。解析器构造一个可以通过以下两个XML API之一访问的对象树：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>文档对象模型（DOM）：基于树的API。基于树的API将XML文档编译为内部树结构，然后允许应用程序使用DOM（一种用于XML和HTML文档的标准基于树的API）导航该树。</p>
                     </li>
                     <li>
                        <p>简单的XML API（SAX）：基于事件的API。基于事件的API报告通过用户定义的SAX甚至处理程序将事件（例如元素的开始和结束）直接解析到应用程序，并且通常不构建内部树。该应用程序实现处理程序以处理不同的事件，就像处理图形用户界面中的事件一样。</p>
                     </li>
                  </ul>
                  <p>基于树的API对于广泛的应用程序非常有用，但是它们经常给系统资源带来很大的压力，特别是如果文档很大（在非常受控的情况下，可以以懒惰的方式构造树以避免一些这个问题）。此外，一些应用程序必须构建自己的不同数据树，并且构建解析节点树仅将其映射到新树上效率非常低。</p>
               </div>
            </div><a id="ADXDK19904"></a><div class="props_rev_3"><a id="GUID-2A6EE952-2F44-44C6-A46B-69FC1524B93E" name="GUID-2A6EE952-2F44-44C6-A46B-69FC1524B93E"></a><h3 id="ADXDK-GUID-2A6EE952-2F44-44C6-A46B-69FC1524B93E" class="sect3">DOM命名空间</h3>
               <div>
                  <p>DOM命名空间是DOM相关类型和接口的命名空间。</p>
                  <p>DOM接口表示为对DOM规范的不同实现的通用引用。它们由<code class="codeph">Node</code>参数化，支持各种特化和实例化。其中，最重要的是<code class="codeph">xmlnode</code> ，它对应于当前的C实现</p>
                  <p>这些泛型引用没有类似<code class="codeph">NULL</code>的值。任何实现都不能创建没有状态的引用（如<code class="codeph">NULL</code> ）。如果有必要发出某些事情没有状态的信号，那么实现必须抛出异常。
                  </p>
                  <p>如果DOM树<code class="codeph">UNDEFINED_ERR</code>不正确，许多方法可能抛出<code class="codeph">SYNTAX_ERR</code>异常，或者遇到错误的参数或意外的<code class="codeph">NULL</code>指针时，它们可能抛出<code class="codeph">UNDEFINED_ERR</code> 。如果这些是特定方法可能抛出的唯一错误，则不会反映在方法签名中。
                  </p>
                  <p>实际DOM树<span class="italic">不</span>依赖于上下文<code class="codeph">TCtx</code> 。但是，在当前基于<code class="codeph">xmlctx</code>的实现中对DOM树的操作需要访问当前上下文<code class="codeph">TCtx</code> 。这是通过将上下文指针传递给<code class="codeph">DOMImplRef</code>的构造函数来<code class="codeph">DOMImplRef</code> 。在多线程环境中， <code class="codeph">DOMImplRef</code>始终在线程上下文中创建，因此具有指向正确上下文的指针。
                  </p>
                  <p><code class="codeph">DOMImplRef</code>提供了一种创建DOM树的方法。<code class="codeph">DomImplRef</code>是实际参考<code class="codeph">DOMImplementation</code>的规律，noncopy构造函数时所创建的对象<code class="codeph">DomImplRef</code>被调用。这在必须共享DOM树的多线程环境中运行良好，并且每个线程都有一个<code class="codeph">TCtx</code>关联的单独<code class="codeph">TCtx</code> 。这在单线程环境中同样有效。
                  </p>
                  <p><code class="codeph">DOMString</code>是Oracle实现支持的一种编码。其他编码的支持是Oracle扩展。<code class="codeph">oratext*</code>数据类型用于所有编码。接口表示根据<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_dom_level2_core" target="_blank"><span class="italic">文档对象模型核心的</span></a> DOM级别2核心接口。这些C ++接口尽可能地支持DOM规范。但是，Oracle无法保证我们的实现完全支持该规范，因为万维网联盟（W3C）规范不涉及C ++绑定。
                  </p>
               </div><a id="ADXDK19905"></a><div class="props_rev_3"><a id="GUID-FF71CC52-CA6F-4A84-BA28-43F823272E0F" name="GUID-FF71CC52-CA6F-4A84-BA28-43F823272E0F"></a><h4 id="ADXDK-GUID-FF71CC52-CA6F-4A84-BA28-43F823272E0F" class="sect4">DOM数据类型</h4>
                  <div>
                     <p><code class="codeph">DomNodeType</code>定义DOM节点的类型。<code class="codeph">DomExceptionCode</code>定义DOM API返回的异常代码。</p>
                  </div>
               </div><a id="ADXDK19906"></a><div class="props_rev_3"><a id="GUID-86DC22CC-D2C0-47B8-B3B7-66BFFC7CEAA6" name="GUID-86DC22CC-D2C0-47B8-B3B7-66BFFC7CEAA6"></a><h4 id="ADXDK-GUID-86DC22CC-D2C0-47B8-B3B7-66BFFC7CEAA6" class="sect4">DOM接口</h4>
                  <div>
                     <p>描述了DOM接口。</p>
                     <p><code class="codeph">DOMException</code>接口 - 请参阅W3C DOM文档中的异常<code class="codeph">DOMException</code> 。DOM操作仅在“异常”情况下引发异常：当操作无法执行时（出于逻辑原因，因为数据丢失，或者因为实现变得不稳定）。XMLException的功能可用于更广泛的异常。
                     </p>
                     <p><code class="codeph">NodeRef</code>接口 - 请参阅W3C文档中的接口<code class="codeph">Node</code> 。
                     </p>
                     <p><code class="codeph">DocumentRef</code>界面-请参阅接口<code class="codeph">Document</code>的W3C文档。
                     </p>
                     <p><code class="codeph">DocumentFragmentRef</code>接口 - 请参阅W3C文档中的接口<code class="codeph">DocumentFragment</code> 。
                     </p>
                     <p><code class="codeph">ElementRef</code>接口 - 请参阅W3C文档中的接口<code class="codeph">Element</code> 。
                     </p>
                     <p><code class="codeph">AttrRef</code>接口 - 请参阅W3C文档中的接口<code class="codeph">Attr</code> 。
                     </p>
                     <p><code class="codeph">CharacterDataRef</code>接口 - 请参阅W3C文档中的接口<code class="codeph">CharacterData</code> 。
                     </p>
                     <p><code class="codeph">TextRef</code> Interface  - 请参阅W3C文档中的<code class="codeph">Text</code>节点。
                     </p>
                     <p><code class="codeph">CDATASectionRef</code>接口 - 请参阅W3C文档中的<code class="codeph">CDATASection</code>节点。
                     </p>
                     <p><code class="codeph">CommentRef</code>接口 - 请参阅W3C文档中的<code class="codeph">Comment</code>节点。
                     </p>
                     <p><code class="codeph">ProcessingInstructionRef</code>接口 - 请参阅W3C文档中的<code class="codeph">PI</code>节点。
                     </p>
                     <p><code class="codeph">EntityRef</code>接口 - 请参阅W3C文档中的<code class="codeph">Entity</code>节点。
                     </p>
                     <p><code class="codeph">EntityReferenceRef</code>接口 - 请参阅W3C文档中的<code class="codeph">EntityReference</code>节点。
                     </p>
                     <p><code class="codeph">NotationRef</code>接口 - 请参阅W3C文档中的<code class="codeph">Notation</code>节点。
                     </p>
                     <p><code class="codeph">DocumentTypeRef</code>接口 - 请参阅W3C文档中的<code class="codeph">DTD</code>节点。
                     </p>
                     <p><code class="codeph">DOMImplRef</code>接口 - 请参阅W3C DOM文档中的接口<code class="codeph">DOMImplementation</code> 。<code class="codeph">DOMImplementation</code>是操作DOM树的基础。每个DOM树都附加到特定的DOM实现对象。可以将多个DOM树附加到同一DOM实现对象。可以通过删除文档对象来删除和取消分配每个DOM树。删除此对象时，将删除附加到特定DOM实现对象的所有DOM树。<code class="codeph">DOMImplementation</code>对象直接对用户不可见。它通过类<code class="codeph">DOMImplRef</code>可见。由于多线程环境的要求，因此需要此功能。
                     </p>
                     <p><code class="codeph">NodeListRef</code>接口 - 节点列表的抽象实现。请参阅W3C文档中的接口NodeList。
                     </p>
                     <p><code class="codeph">NamedNodeMapRef</code>接口 - 节点映射的抽象实现。请参阅W3C文档中的接口NamedNodeMap。
                     </p>
                  </div>
               </div><a id="ADXDK19907"></a><div class="props_rev_3"><a id="GUID-ABFE9393-9C68-4D03-94E4-A607E19760DB" name="GUID-ABFE9393-9C68-4D03-94E4-A607E19760DB"></a><h4 id="ADXDK-GUID-ABFE9393-9C68-4D03-94E4-A607E19760DB" class="sect4">DOM遍历和范围数据类型</h4>
                  <div>
                     <p><code class="codeph">AcceptNodeCode</code>是迭代器和树步行者的节点过滤器返回的值的数据类型。<code class="codeph">WhatToShowCode</code>是用于过滤节点的代码的数据类型。<code class="codeph">RangeExceptionCode</code>是接口<code class="codeph">Range</code>可以抛出的异常的数据类型。<code class="codeph">CompareHowCode</code>是范围比较的数据类型。
                     </p>
                  </div>
               </div><a id="ADXDK19908"></a><div class="props_rev_3"><a id="GUID-11DCC153-8E20-4625-AE08-83B729E36C53" name="GUID-11DCC153-8E20-4625-AE08-83B729E36C53"></a><h4 id="ADXDK-GUID-11DCC153-8E20-4625-AE08-83B729E36C53" class="sect4">DOM遍历和范围接口</h4>
                  <div>
                     <p>DOM 2遍历和范围接口是<code class="codeph">NodeFilter</code> ， <code class="codeph">NodeIterator</code> ， <code class="codeph">TreeWalker</code> ， <code class="codeph">DocumentTraversal</code> ， <code class="codeph">RangeException</code> ， <code class="codeph">Range</code>和<code class="codeph">DocumentRange</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="ADXDK19909"></a><div class="props_rev_3"><a id="GUID-6302F695-48C0-476C-934B-D899B85181E4" name="GUID-6302F695-48C0-476C-934B-D899B85181E4"></a><h3 id="ADXDK-GUID-6302F695-48C0-476C-934B-D899B85181E4" class="sect3">解析器命名空间</h3>
               <div>
                  <p>描述了与解析器命名空间相关联的接口。</p>
                  <p><code class="codeph">DOMParser</code> Interface-DOM解析器根类。
                  </p>
                  <p><code class="codeph">GParser</code> Interface-XML类解析器的根类。
                  </p>
                  <p><code class="codeph">ParserException</code>接口 - 解析器和验证器的异常类。
                  </p>
                  <p><code class="codeph">SAXHandler</code>接口 - 用于当前SAX处理程序实现的Root类。
                  </p>
                  <p>所有SAX处理程序的<code class="codeph">SAXHandlerRoot</code>接口 - 根类。
                  </p>
                  <p><code class="codeph">SAXParser</code> Interface-Root类适用于所有SAX解析器。
                  </p>
                  <p><code class="codeph">SchemaValidator</code>接口 -  XML模式感知验证器。
                  </p>
               </div><a id="ADXDK19910"></a><div class="props_rev_3"><a id="GUID-6C9A9704-C1F3-4AF3-AE0A-ED7885716DE4" name="GUID-6C9A9704-C1F3-4AF3-AE0A-ED7885716DE4"></a><h4 id="ADXDK-GUID-6C9A9704-C1F3-4AF3-AE0A-ED7885716DE4" class="sect4">GParser接口</h4>
                  <div>
                     <p>接口<code class="codeph">GParser</code>是所有XML解析器接口和实现的根类。它不是一个抽象的类;也就是说，它不是一个界面。它是一个真正的类，可用于设置和检查解析器参数。
                     </p>
                  </div>
               </div><a id="ADXDK19911"></a><div class="props_rev_3"><a id="GUID-DB125AE0-9DD3-4B34-9C57-D8E836D99F27" name="GUID-DB125AE0-9DD3-4B34-9C57-D8E836D99F27"></a><h4 id="ADXDK-GUID-DB125AE0-9DD3-4B34-9C57-D8E836D99F27" class="sect4">DOMParser接口</h4>
                  <div>
                     <p>接口<code class="codeph">DOMParser</code>是DOM解析器根抽象类或接口。除了解析和检查文档是否格式正确之外，它还提供了根据文档类型定义（DTD）或XML模式验证文档的方法。
                     </p>
                  </div>
               </div><a id="ADXDK19912"></a><div class="sect3"><a id="GUID-60D4D681-62BC-42BC-9DA2-3497CE960472" name="GUID-60D4D681-62BC-42BC-9DA2-3497CE960472"></a><h4 id="ADXDK-GUID-60D4D681-62BC-42BC-9DA2-3497CE960472" class="sect4">SAXParser接口</h4>
                  <div>
                     <p>接口<code class="codeph">SAXParser</code>是所有SAX解析器的根抽象类。
                     </p>
                  </div><a id="ADXDK19913"></a><div class="props_rev_3"><a id="GUID-534185D2-CA00-47E5-989B-4900793A8594" name="GUID-534185D2-CA00-47E5-989B-4900793A8594"></a><h5 id="ADXDK-GUID-534185D2-CA00-47E5-989B-4900793A8594" class="sect5">SAX事件处理程序</h5>
                     <div>
                        <p>要使用SAX，SAX事件处理程序类必须由用户提供，并在<code class="codeph">parse()</code>调用中传递给SAXParser或在此类调用之前设置。
                        </p>
                        <p><code class="codeph">SAXHandlerRoot</code>所有SAX处理程序的接口 - 根类。
                        </p>
                        <p><code class="codeph">SAXHandler</code>接口 - 用于当前SAX处理程序实现的根类。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK19914"></a><div class="props_rev_3"><a id="GUID-3E0065D7-B674-4F97-BD6B-4E4711EFE5A1" name="GUID-3E0065D7-B674-4F97-BD6B-4E4711EFE5A1"></a><h3 id="ADXDK-GUID-3E0065D7-B674-4F97-BD6B-4E4711EFE5A1" class="sect3">用于C ++的XML解析器的线程安全性</h3>
               <div>
                  <p>如果线程在init-parse-term调用序列中分叉，则可能发生不可预测的行为或结果。</p>
               </div>
            </div><a id="ADXDK19915"></a><div class="props_rev_3"><a id="GUID-1C72388D-34C9-4F0E-B221-2AEFD3A208E5" name="GUID-1C72388D-34C9-4F0E-B221-2AEFD3A208E5"></a><h3 id="ADXDK-GUID-1C72388D-34C9-4F0E-B221-2AEFD3A208E5" class="sect3">用于C ++用法的XML Parser</h3>
               <div>
                  <p>调用<code class="codeph">Tools::Factory</code>来创建解析器并初始化解析过程。XML输入可以是一种<code class="codeph">InputSource</code> （请参阅<code class="codeph">IO</code>命名空间）。<code class="codeph">DOMParser</code>调用生成DOM树。<code class="codeph">SAXParser</code>调用会生成SAX事件。调用<code class="codeph">parser</code>析构函数会终止进程。
                  </p>
               </div>
            </div><a id="ADXDK19916"></a><div class="props_rev_3"><a id="GUID-C7D1B9F8-D34F-4080-984A-DCA51B1E2A84" name="GUID-C7D1B9F8-D34F-4080-984A-DCA51B1E2A84"></a><h3 id="ADXDK-GUID-C7D1B9F8-D34F-4080-984A-DCA51B1E2A84" class="sect3">用于C ++默认行为的XML解析器</h3>
               <div>
                  <p>描述了C ++的XML解析器的默认行为。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>字符集编码是Unicode（UTF-8）的8位编码。如果您的所有文档都是ASCII，则建议您将编码设置为US-ASCII以获得更好的性能。</p>
                     </li>
                     <li>
                        <p>除非指定了<code class="codeph">msghdlr</code> ，否则消息将打印到<code class="codeph">stderr</code> 。
                        </p>
                     </li>
                     <li>
                        <p>用于C ++的XML解析器确定XML文档是否格式正确，并可选择根据DTD对其进行验证。解析器构造一个对象树，可以通过DOM接口访问或通过SAX接口串行操作。</p>
                     </li>
                     <li>
                        <p>除非将<code class="codeph">saxcb</code>设置为使用SAX回调API，否则将构建可由DOM API访问的解析树。如果不需要，您可以将任何SAX回调函数设置为<code class="codeph">NULL</code> 。
                        </p>
                     </li>
                     <li>
                        <p>解析器的默认行为是检查输入是否格式正确，但不检查它是否有效。可以设置标志<code class="codeph">XML_FLAG_VALIDATE</code>以验证输入。白色空间处理的默认行为是完全符合XML 1.0规范，也就是说，所有空白区域都会报告给应用程序，但会指出哪个空白区域是可忽略的。但是，某些应用程序可能更喜欢设置<code class="codeph">XML_FLAG_DISCARD_WHITESPACE</code> ，它会丢弃end-element标记和此start-element标记之间的所有空格。
                        </p>
                        <div class="infoboxnote" id="GUID-C7D1B9F8-D34F-4080-984A-DCA51B1E2A84__GUID-D804EB74-5807-49A0-945B-EC24157C5266">
                           <p class="notep1">注意：</p>
                           <p>如果仅使用单字节字符集（例如US-ASCII或任何ISO-8859字符集），Oracle建议您显式设置默认编码，其性能比使用多字节字符集（如UTF-）快25％ 8。</p>
                        </div>
                     </li>
                     <li>
                        <p>在这两种情况下，基于事件的API提供对XML文档的更简单，更低级别的访问：您可以解析比可用系统内存大得多的文档，并且可以使用回调事件处理程序构建自己的数据结构。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADXDK19918"></a><a id="ADXDK19917"></a><div class="props_rev_3"><a id="GUID-E287D069-7900-478E-9C0F-B14EFD1818B4" name="GUID-E287D069-7900-478E-9C0F-B14EFD1818B4"></a><h3 id="ADXDK-GUID-E287D069-7900-478E-9C0F-B14EFD1818B4" class="sect3">C ++示例文件</h3>
               <div>
                  <p>目录<code class="codeph">xdk/demo/cpp/parser/</code>包含几个XML应用程序，它们展示了如何使用带有DOM和SAX接口的C ++ XML解析器。
                  </p>
                  <div class="section">
                     <p>将目录更改为示例目录（例如，在Solaris上为<code class="codeph">$ORACLE_HOME/xdk/demo/cpp</code> ）并读取<code class="codeph">README</code>文件。本文档介绍了如何构建示例程序。
                     </p>
                     <p><a href="using-XML-parser-for-C-plus-plus.html#GUID-E287D069-7900-478E-9C0F-B14EFD1818B4__G1026908" title="此表列出了目录中的示例文件。每个文件* Main.cpp都有一个相应的* Gen.cpp和* Gen.hpp。示例文件名称和描述是列。">表28-1</a>列出了目录中的示例文件。每个文件<code class="codeph">*Main.cpp</code>都有一个相应的<code class="codeph">*Gen.cpp</code>和<code class="codeph">*Gen.hpp</code> 。
                     </p>
                     <div class="tblformal" id="GUID-E287D069-7900-478E-9C0F-B14EFD1818B4__G1026908">
                        <p class="titleintable">表28-1 C ++示例文件的XML解析器</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="用于C ++示例文件的XML解析器" width="100%" border="1" summary="This table  lists the sample files in the directory. Each file *Main.cpp has a corresponding *Gen.cpp and *Gen.hpp. Sample File Name and Description are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d110083e1662">示例文件名</th>
                                 <th align="left" valign="bottom" width="70%" id="d110083e1665">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d110083e1670" headers="d110083e1662 "><pre class="oac_no_warn" dir="ltr">DOMSampleMain.cpp</pre></td>
                                 <td align="left" valign="top" width="70%" headers="d110083e1670 d110083e1665 ">
                                    <p>XML解析器和DOM的C ++接口的示例用法。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d110083e1677" headers="d110083e1662 "><pre class="oac_no_warn" dir="ltr">FullDOMSampleMain.cpp</pre></td>
                                 <td align="left" valign="top" width="70%" headers="d110083e1677 d110083e1665 ">
                                    <p>手动构建DOM然后运动。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d110083e1684" headers="d110083e1662 "><pre class="oac_no_warn" dir="ltr">SAXSampleMain.cpp</pre></td>
                                 <td align="left" valign="top" width="70%" headers="d110083e1684 d110083e1665 ">
                                    <p>SAXSample程序的来源。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-E287D069-7900-478E-9C0F-B14EFD1818B4__GUID-236FE91A-A45B-4B00-BE6D-44151AFDC190">
                        <p class="notep1">也可以看看：</p>
                        <p>用于C ++的解析器包API的<a href="../cpxml/package-Parser-API.html#CPXML01600" target="_blank"><span><cite>Oracle Database XML C ++ API参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>