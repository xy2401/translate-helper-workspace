<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>性能和调试</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="translator-run-time-functionality.html" title="Previous" type="text/html"></link>
      <link rel="next" href="appendix.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="translator-run-time-functionality.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="appendix.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">性能和调试</li>
            </ol>
            <a id="GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375" name="GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375"></a><a id="JSQLJ740"></a>
            
            <h2 id="JSQLJ-GUID-374DA5FF-73F5-40FC-BFA6-02FAB44FC375" class="sect2"><span class="enumeration_chapter">11</span>性能和调试</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论增强SQLJ应用程序性能以及在运行时调试SQLJ源代码的功能，实用程序和技巧。讨论了以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C">性能增强功能</a></p>
                  </li>
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-630E713D-C1AA-4ED8-8061-153B6880EB61">SQLJ调试功能</a></p>
                  </li>
                  <li>
                     <p><a href="performance-and-debugging.html#GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585">SQLJ支持Oracle性能监视</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ741"></a><div class="props_rev_3"><a id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C" name="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C"></a><h3 id="JSQLJ-GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C" class="sect3">性能增强功能</h3>
               <div>
                  <p>Oracle SQLJ实现包括通过提高数据访问效率来增强性能的功能。这些包括以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-BB73F408-2751-4050-A174-F9B2AD525AD7">行预取</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A">声明缓存</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803">更新批处理</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50">列定义</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D">参数大小定义</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-39C2B05E-C724-4617-903D-AFEFC3726565">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../jjdbc/data-access-and-manipulation.html#JJDBC-GUID-C4FB8486-E19B-4EF3-BC67-053EF49E6FF4" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                  </div>
                  <p>您的应用程序可能会受益于默认的Oracle特定代码生成。生成的代码将通过直接调用Oracle Java Database Connectivity（JDBC）驱动程序进行优化，从而消除了对SQLJ运行时的中间调用的开销，而SQLJ运行时又调用JDBC。</p>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-20E7B340-7A2E-43A6-BD2A-56544588B676">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="key-programming-considerations.html#GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD">特定于Oracle的代码生成（无配置文件）</a> ”</span></p>
                  </div>
                  <div class="infoboxnote" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-62CCE6F3-8B47-49F1-8C4E-56872FAA16D3">
                     <p class="notep1">注意：</p>
                     <p>甲骨文SQLJ实现<span class="italic">不</span>支持批量取，这是行集合的取出入值的阵列。但是，您可以使用Oracle行预取来获取批量提取的一些好处。
                     </p>
                  </div>
                  <p>除了前面的SQLJ性能增强之外，您还可以在SQLJ程序的SQL操作中使用优化程序提示，就像在任何Oracle SQL操作中一样。</p>
                  <p>Ora cle SQL实现使您可以使用“ <code class="codeph">/*+</code> ”或“ <code class="codeph">--+</code> ”注释表示法来调整SQL语句，以便将提示传递给Oracle SQL优化程序。SQLJ转换程序识别并支持这些优化程序提示，并在运行时将它们作为SQL语句的一部分传递。
                  </p>
                  <p>您还可以使用Oracle Database 12 <span class="italic">c</span>第2版（12.2）中SQL优化的可扩展性功能，为任何其他存储函数定义SQLJ存储函数的成本和选择性信息。在SQL执行期间，优化器调用存储函数的成本和选择性方法，评估执行的备用策略，并选择有效的执行计划。
                  </p>
                  <div class="infoboxnotealso" id="GUID-96E6408D-EAB0-488B-83ED-7CC40F4F7D2C__GUID-3D110D49-2610-47DD-A416-C83821564928">
                     <p class="notep1">也可以看看：</p>
                     <p>有关更多信息，请<a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF-GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">参见Oracle数据库SQL语言参</span></a></p>
                  </div>
                  <p>请注意，在代码中使用Oracle性能扩展需要以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用Oracle JDBC驱动程序之一。</p>
                     </li>
                     <li>
                        <p>使用默认的Oracle特定代码生成，或适当地自定义配置文件。</p>
                        <p>对于ISO标准代码生成，默认自定义程序<code class="codeph">oracle.sqlj.runtime.util.建议使用OraCustomizer</code> 。
                        </p>
                     </li>
                     <li>
                        <p>在应用程序运行时使用Oracle SQLJ运行时。</p>
                     </li>
                  </ul>
                  <p>每当您使用Oracle自定义程序自定义配置文件时，您的应用程序都需要Oracle SQLJ运行时和Oracle JDBC驱动程序，即使您实际上没有在代码中使用Oracle扩展。</p>
               </div><a id="JSQLJ742"></a><div class="props_rev_3"><a id="GUID-BB73F408-2751-4050-A174-F9B2AD525AD7" name="GUID-BB73F408-2751-4050-A174-F9B2AD525AD7"></a><h4 id="JSQLJ-GUID-BB73F408-2751-4050-A174-F9B2AD525AD7" class="sect4">行预取</h4>
                  <div>
                     <p>标准JDBC一次接收一行查询结果，每行需要单独往返数据库。行预取使您可以更高效地接收结果，每组包含多行。</p>
                     <p>使用<code class="codeph">ExecutionContext</code>实例的<code class="codeph">setFetchSize()</code>方法设置每次执行<code class="codeph">SELECT</code>语句时要预取的行数（对于使用特定<code class="codeph">ExecutionContext</code>实例的SQLJ语句）。
                     </p>
                     <p><code class="codeph">ExecutionContext</code>实例的<code class="codeph">getFetchSize()</code>方法返回当前的预取大小，作为<code class="codeph">int</code>值。
                     </p>
                     <p>以下是通过获取默认连接上下文实例的默认执行上下文实例并调用<code class="codeph">setFetchSize()</code>方法将预取大小设置为20的示例：</p><pre class="oac_no_warn" dir="ltr">。DefaultContext.getDefaultContext（）getExecutionContext（）的setFetchSize（20）。</pre><p>也可以使用JDBC应用程序编程接口（API）直接在底层<code class="codeph">OracleConnection</code>对象上设置预取大小，但在SQLJ中不鼓励这样做。
                     </p>
                     <p>要为使用给定连接上下文实例的查询指定预取的行数，请使用基础JDBC连接，强制转换为Oracle <code class="codeph">Connection</code>实例。以下是将默认连接的预取值设置为20的示例：</p><pre class="oac_no_warn" dir="ltr">（（的OracleConnection）DefaultContext.getDefaultContext（）的getConnection（））setDefaultRowPrefetch（20）。</pre><pre class="oac_no_warn" dir="ltr"></pre><p>另请注意，SQLJ连接上下文中设置的预取大小会覆盖基础JDBC连接上设置的预取大小。</p>
                     <p><span>您使用的每个附加连接上下文实例必须根据需要单独设置。</span>需要在每个单独的连接上下文上设置预取值。例如，如果<code class="codeph">ctx</code>是声明的连接上下文类的实例，请按如下所示设置其预取值：</p><pre class="oac_no_warn" dir="ltr">（（连接）ctx.getConnection（））setDefaultRowPrefetch（20）。</pre><pre class="oac_no_warn" dir="ltr">ctx.getExecutionContext（）的setFetchSize（20）。</pre><p>没有最大行预取值。JDBC中的默认值为10，这是SQLJ继承的。此值在典型情况下有效，但如果您收到大量行，则可能需要增加该值。</p>
                  </div>
               </div><a id="JSQLJ744"></a><a id="JSQLJ745"></a><a id="JSQLJ746"></a><a id="JSQLJ747"></a><a id="JSQLJ748"></a><a id="JSQLJ749"></a><a id="JSQLJ750"></a><a id="JSQLJ743"></a><div class="props_rev_3"><a id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A" name="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A"></a><h4 id="JSQLJ-GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A" class="sect4">声明缓存</h4>
                  <div>
                     <p>SQLJ提供了一种语句缓存功能，通过保存重复使用的可执行语句（例如循环或重复调用的方法）来提高性能。在重新执行语句之前缓存语句时，不必重新分析代码（在服务器上或客户端上），不必重新创建语句对象，并且不必重新计算参数大小定义。如果没有此功能，则必须在客户端上重新声明重复的语句，也可能在服务器中重新声明，具体取决于在再次遇到语句时是否仍然可以在通用服务器端SQL缓存中使用该语句。</p>
                     <p>对于特定于Oracle的代码生成，SQLJ语句高速缓存依赖于Oracle JDBC驱动程序，使用JDBC显式高速缓存机制。这与JDBC隐式缓存机制不同，尽管存在相互依赖关系。使用特定于Oracle的代码，语句缓存通过连接方法进行控制。</p>
                     <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-3EB4E6B4-DA9C-4350-8295-54BFDC464A39">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/statement-and-resultset-caching.html#JJDBC-GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                     </div>
                     <p>对于ISO代码生成，SQLJ通过SQLJ运行时的功能有自己的语句缓存机制。使用ISO代码，语句缓存通过Oracle customizer <code class="codeph">stmtcache</code>选项进行控制。
                     </p>
                     <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-81A8E895-AEC2-4D36-BF1E-90C31CB19B31">
                        <p class="notep1">注意：</p>
                        <p>对于特定于Oracle的代码生成，显式缓存是唯一可以通过SQLJ API操作的语句缓存机制。对于本文档中的讨论，它将被称为SQLJ /显式语句缓存。</p>
                     </div>
                     <p>在Oracle Database <span class="italic">12c</span>第1版（12.1）中，如果连接上下文正在创建JDBC连接，则默认语句高速缓存大小将设置为5。如果使用已经可用的JDBC连接或数据源创建连接上下文，则语句高速缓存大小将设置为JDBC连接或数据源的大小。
                     </p>
                     <div class="section" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__I1005665">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-D305621B-3E5E-4F5B-846B-4C93F934729E">语句缓存的连接上下文方法（特定于Oracle的代码）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果使用特定于Oracle的代码生成（SQLJ转换器的默认情况下为<code class="codeph">-codegen=oracle</code>设置），请使用连接上下文方法进行语句缓存功能。请注意，任何大于0的语句高速缓存大小都会导致启用SQLJ /显式语句高速缓存。默认情况下，它的缓存大小为5，即五个语句。
                        </p>
                        <p><code class="codeph">sqlj.runtime.ref.添加了以下特定于Oracle的（非标准）静态方法<code class="codeph">sqlj.runtime.ref.DefaultContext</code>类，也包含在您声明的任何连接上下文类中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">static void setDefaultStmtCacheSize（int）</code></p>
                              <p>这将为<span class="italic">所有</span>连接上下文设置默认语句高速缓存大小。这将成为任何后续创建的<span class="italic">任何</span>连接上下文类实例的初始语句高速缓存大小，而不仅仅是您调用该方法的类。方法调用不会影响已存在的连接上下文实例。
                              </p>
                              <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-D02D50B6-5271-452A-8FA0-07E43C4E003E">
                                 <p class="notep1">注意：</p>
                                 <p><code class="codeph">setDefaultStmtCacheSize(int)</code>仅影响使用SQLJ连接上下文创建的连接的语句高速缓存大小。它不会影响使用JDBC连接创建的连接的语句高速缓存大小。
                                 </p>
                                 <p>请考虑以下两个代码段：</p>
                                 <p>例1：</p><pre class="oac_no_warn" dir="ltr">...MyContext.setDefaultStmtCacheSize（10）; OracleConnection conn = DriverManager.getConnection（url，user，passwd）; myctx = new MyContext（conn）;</pre><p>例2：</p><pre class="oac_no_warn" dir="ltr">...MyContext.setDefaultStmtCacheSize（10）; myctx = new MyContext（url，user，passwd，true）;</pre><p>在前面两个示例中，语句高速缓存大小仅在第二个示例中设置为10。在第一个示例中，与此连接对应的语句高速缓存大小不会受到影响，因为使用JDBC规范中的<code class="codeph">DriverManager</code>接口的<code class="codeph">getConnection</code>方法创建连接。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p><code class="codeph">static int getDefaultStmtCacheSize（）</code></p>
                              <p>这将检索连接上下文的当前默认语句高速缓存大小。</p>
                           </li>
                        </ul>
                        <p>并且以下特定于Oracle的实例方法也已添加到<code class="codeph">DefaultContext</code>类中，并包含在任何其他连接上下文类中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">void setStmtCacheSize（int）抛出java.sql。的SQLException</code></p>
                              <p>这将为特定连接上下文实例的基础连接设置语句高速缓存大小（覆盖缺省值）。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-F0F1BFCE-4D45-4727-8835-B970BDDC9CFB">
                           <p class="notep1">注意：</p>
                           <p>如果已禁用SQLJ /显式缓存，则将大小设置为0会使其禁用。如果已经启用，则将大小设置为0会使其保持启用状态，但会使其无效。</p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">int getStmtCacheSize（）</code></p>
                              <p>这将验证是否为连接上下文的基础连接启用了SQLJ /显式语句高速缓存。如果是，则返回当前语句高速缓存大小。它还可以返回以下任何一个整数常量：</p><pre class="oac_no_warn" dir="ltr">static int STMT_CACHE_NOT_ENABLED static int STMT_CACHE_EXCEPTION</pre><p><code class="codeph">getStmtCacheSize()</code>调用可能会导致SQL异常。但是，为了向后兼容，此方法不会直接抛出异常。发生异常时，该方法返回常量<code class="codeph">STMT_CACHE_EXCEPTION</code> 。在这种情况下，您可以调用<code class="codeph">getStmtCacheException()</code>方法来找出发生了什么异常。
                              </p>
                              <p>如果在禁用SQLJ /显式缓存时调用<code class="codeph">getStmtCacheSize()</code> ，则该方法返回常量<code class="codeph">STMT_CACHE_NOT_ENABLED</code> 。这与高速缓存大小0不同。从技术上讲，SQLJ /显式缓存可以启用（尽管无用），缓存大小为0。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql中。异常getStmtCacheException（）</code></p>
                              <p>查看是否存在语句缓存异常。使用此方法有两种方案：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果<code class="codeph">getStmtCacheSize()</code>调用返回<code class="codeph">STMT_CACHE_EXCEPTION</code> ，则调用它。</p>
                                 </li>
                                 <li>
                                    <p>每当您创建要使用语句缓存的连接上下文实例时，请调用它。这是因为无论何时创建连接上下文实例，都会对语句高速缓存大小进行自动操作。如果您关心连接上下文实例的语句缓存，请在创建实例后调用<code class="codeph">getStmtCacheException()</code> ，以验证没有问题。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__I1005700">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-626710D2-E6D5-40D8-9899-4212999D004D">启用和禁用语句缓存（特定于Oracle的代码）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用特定于Oracle的代码，重申前面所述的内容，任何非零语句高速缓存大小都会导致启用SQLJ /显式高速缓存。由于默认大小为5，因此默认情况下启用语句缓存。</p>
                        <p>您不能通过SQLJ API显式禁用SQLJ /显式语句缓存，尽管您可以通过将语句高速缓存大小设置为0来有效地禁用它（使其无法正常工作）。在这种情况下，连接上下文<code class="codeph">getStmtCacheSize()</code>方法可能返回0， <span class="italic">而不是</span> <code class="codeph">STMT_CACHE_NOT_ENABLED</code> 。</p>
                        <p>您<span class="italic">可以</span>通过JDBC连接API显式禁用SQLJ /显式语句缓存或JDBC隐式缓存。由于SQLJ /显式缓存和JDBC隐式缓存使用相同的缓存大小，因此有时可能有理由这样做。<code class="codeph">OracleConnection</code>类提供以下方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">void setExplicitCachingEnabled（boolean）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean getExplicitCachingEnabled（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">void setImplicitCachingEnabled（boolean）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean getImplicitCachingEnabled（）</code></p>
                           </li>
                        </ul>
                        <p>如果从SQLJ连接上下文实例中检索<code class="codeph">OracleConnection</code>实例，则可以访问这些方法。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-79B5E5ED-8797-466E-8A48-CBB5F433BC71">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310">SQLJ连接上下文和JDBC连接互操作性</a> ”</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-ABEC7041-B798-41AD-B9FE-33EE3C84066E">
                           <p class="notep1">注意：</p>
                           <p>在SQLJ中，默认情况下禁用JDBC隐式缓存，除非通过<code class="codeph">setImplicitCachingEnabled()</code>方法显式启用它，否则将保持禁用状态。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-2CF05912-E06A-4997-ABAC-B0D535406903">SQLJ /显式缓存与JDBC隐式缓存之间的关键交互</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>关于Oracle特定代码中的语句缓存，本文档自然强调SQLJ /显式缓存而不是JDBC隐式缓存。如果您不在应用程序中使用JDBC代码，则SQLJ /显式缓存是唯一相关的语句缓存。但是，在某些情况下，您可能希望在应用程序中同时使用SQLJ和JDBC代码，在这些情况下，您可能还希望使用隐式缓存。</p>
                        <p>SQLJ /显式缓存和JDBC隐式缓存是相互独立启用的。此外，您无法通过SQLJ访问隐式缓存。但是，两者之间存在密钥交互，因为它们共享相同的缓存大小。例如，如果语句高速缓存大小为5，则最多可以为SQLJ /显式高速缓存和隐式高速缓存组合缓存五个语句。</p>
                        <p>与此相关的一个重点是，如果您选择通过将高速缓存大小设置为0来有效地禁用SQLJ /显式语句高速缓存，那么您还有效地禁用了隐式高速缓存。</p>
                        <p>另请注意，如果禁用SQLJ /显式缓存，则将缓存大小更改为大于0的值将启用它，但这不会影响是否启用了隐式缓存。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-9BE5E251-69D2-4230-9CF3-D32B25053D1B">JDBC支持语句缓存（ISO代码）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通过SQLJ转换器<code class="codeph">-codegen=iso</code>设置指定的ISO标准代码生成，语句缓存是一种标准的SQLJ功能，不需要任何特定的JDBC驱动程序。但是，使用实现<code class="codeph">sqlj.runtime.profile.ref.的驱动程序<code class="codeph">sqlj.runtime.profile.ref.ClientDataSupport</code>接口支持更强大的缓存。Oracle Database 12 <span class="italic">c</span>第1版（12.1）JDBC驱动程序实现此接口，提供以下功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每个数据库连接的单独缓存，而不是整个应用程序的单个静态缓存</p>
                           </li>
                           <li>
                              <p>能够在共享相同底层连接的连接上下文类的多个实例之间共享高速缓存语句</p>
                           </li>
                        </ul>
                        <p>当使用单个缓存时，就像没有实现<code class="codeph">ClientDataSupport</code>的通用JDBC驱动程序一样，在一个连接中执行的语句可以导致刷新来自另一个连接的缓存语句（如果语句缓存大小，则最大数量为超出了可以缓存的语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-5C735039-390C-4F4F-81BB-484B6328812F">用于语句缓存大小的Oracle Customizer选项（ISO代码）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用ISO标准代码生成时，默认情况下在应用程序中启用语句缓存，当您使用Oracle自定义程序时，缓存大小为5（与Oracle特定代码的默认大小相同），Oracle自定义程序通常作为Oracle SQLJ转换的一部分执行。</p>
                        <p>您可以根据需要更改语句高速缓存大小，或通过Oracle定制程序<code class="codeph">stmtcache</code>选项有效地禁用高速缓存大小为0的语句高速缓存。这被设置为<code class="codeph">-P-Cstmtcache=</code> <span class="italic"><code class="codeph">n</code></span> ，其中<span class="italic"><code class="codeph">n</code></span>是整数。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-B7DD5DBC-BB84-47E9-BF98-D634CD2BEC1B">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="appendix.html#GUID-2EF347A8-53D3-404B-8702-A9C6E8ECFF8B">Oracle Customizer语句缓存大小选项（stmtcache）</a> ”</span></p>
                        </div>
                        <p>如果使用多个连接上下文类，因此具有多个配置文件，则可以通过为每个配置文件单独运行SQLJ（实际上是自定义程序）来单独设置其语句高速缓存大小。</p>
                        <p>在运行时，相应的SQLJ概要文件确定连接的语句高速缓存大小。这将是与为此连接实例化的第一个连接上下文类对应的配置文件。其语句高速缓存大小设置（如果有）是根据您在自定义配置文件时设置Oracle定制程序<code class="codeph">stmtcache</code>选项的方式确定的。当执行该连接上的第一个语句时，将设置连接的运行时语句高速缓存大小。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-1E818457-7BC9-4DF1-A294-41E60D066193">附加语句缓存行为</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>实例化SQLJ连接上下文对象时，如果基础JDBC连接上的语句高速缓存大小小于连接上下文类的缺省大小，则SQLJ运行时将尝试将JDBC语句高速缓存大小增加到连接上下文缺省值值。即使使用ISO代码生成也会发生此操作，从而在过程中启用显式语句缓存，尽管这在ISO代码案例中实际上没有相关性。</p>
                        <p>另一方面，如果实际的JDBC语句高速缓存大小较大，则SQLJ运行时将不会尝试执行高速缓存大小的更改。只要SQLJ运行时创建SQLJ连接上下文实例，它就会根据默认大小集检查实际的JDBC高速缓存大小。</p>
                        <p>值得注意的是，无论发布它们的上下文类如何，这些方法都具有相同的效果，因为它们修改或报告相同的底层静态字段。</p>
                        <p>作为示例，假设以下连接上下文类声明：</p><pre class="oac_no_warn" dir="ltr">#sql context CtxtA; #sql context CtxtB;</pre><p>在这种情况下，以下三个代码指令中的每一个都会产生这样的效果：无论何时随后创建新的SQLJ连接上下文实例，它都<span class="italic">不会</span>尝试启用SQLJ /显式语句缓存：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ref。DefaultContext.setDefaultStmtCacheSize（0）;</pre><pre class="oac_no_warn" dir="ltr">CtxtA.setDefaultStmtCacheSize（0）;</pre><pre class="oac_no_warn" dir="ltr">CtxtB.setDefaultStmtCacheSize（0）;</pre><div class="infoboxnote" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-4199F5FE-3D1B-4189-9C90-97B56673CA29">
                           <p class="notep1">注意：</p>
                           <p>如果在基础JDBC池连接上创建SQLJ连接上下文实例，则SQLJ将无法更改JDBC语句高速缓存大小。对于特定于Oracle的代码，您可以通过连接上下文<code class="codeph">getStmtCacheException()</code>方法检索生成的异常。在这种情况下，必须在底层物理连接上显式设置所需的JDBC语句高速缓存大小。对于数据源，缓存大小是通过特定于供应商的数据源属性设置的。
                           </p>
                        </div>
                        <p>SQLJ /显式缓存和JDBC隐式缓存功能具有不同的语义和行为。如前所述，SQLJ语句缓存仅适用于重复使用的单个语句，例如循环或通过重复调用同一方法。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">...#sql { <span class="italic">相同的SQL</span> operaton}; //发生＃1 ...
<span class="italic">Java代码</span> ......#sql { <span class="italic">相同的SQL</span> operaton}; //发生＃2 ...
<span class="italic">Java代码</span> ......#sql { <span class="italic">相同的SQL</span> operaton}; //发生＃3 ......
</pre><p>假设三个SQL操作是相同的，包括空格。</p>
                        <p>SQLJ缓存会将同一SQL操作的这三种情况视为三种不同的语句。它们将占用缓存中的三个独立插槽。但是，JDBC隐式缓存会将这些语句识别为完全相同的语句，仅对所有三个语句使用单个缓存槽。该语句将在第2次出现和第3次出现时重复使用。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A__GUID-9ABD8A04-8109-42E5-BE59-51FCD21FF2EA">语句缓存限制和注释</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用语句缓存，即使是1号，也可以提高几乎所有SQLJ应用程序的性能。但请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果每个语句只执行一次，则没有任何好处。</p>
                           </li>
                           <li>
                              <p>尽量避免使用多次执行的语句对一次执行的语句进行交错。仅执行一次的语句将不必要地占用语句高速缓存中的空间，这在达到语句高速缓存大小限制时会成为问题。作为替代方案，如果使用ISO代码生成，则可以对仅执行一次的语句使用单独的连接上下文类，并禁用该连接上下文类的语句缓存。</p>
                           </li>
                           <li>
                              <p>具有相同SQL操作的不同语句的处理方式与任何不同的语句相同。每个都分别处理和缓存。作为替代方法，将SQL操作放在方法中并重复调用该方法，而不是使用不同的语句。</p>
                           </li>
                           <li>
                              <p>在选择适当的语句高速缓存大小时要小心。如果它太小，则缓存可能会填满，导致语句在重新执行之前被刷新。如果它太大，则数据库资源或程序资源可能会耗尽。</p>
                           </li>
                        </ul>
                        <p>还要注意以下关于语句缓存的一般注意事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用特定于Oracle的代码生成时，如果连接上下文共享相同的基础JDBC连接实例，则使用单独的SQLJ连接上下文实例来具有单独的语句缓存行为将不起作用。这是因为在特定于Oracle的代码生成下，SQLJ使用JDBC语句缓存。</p>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于Oracle应用程序，语句高速缓存大小加上应用程序中的最大开放JDBC语句数（直接和通过SQLJ）应小于会话可用的最大游标数。这是因为最大游标数定义了可以同时打开的最大语句数。</p>
                           </li>
                           <li>
                              <p>使用语句高速缓存通常不会更改操作本身的执行语义，尽管在某些情况下会这样做。例如，如果您的语句在其资源被释放时抛出异常，那么使用缓存意味着在关闭连接或从缓存中刷新语句之前不会抛出异常，这在缓存时发生超过了大小。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ752"></a><a id="JSQLJ753"></a><a id="JSQLJ754"></a><a id="JSQLJ755"></a><a id="JSQLJ756"></a><a id="JSQLJ757"></a><a id="JSQLJ758"></a><a id="JSQLJ759"></a><a id="JSQLJ760"></a><a id="JSQLJ761"></a><a id="JSQLJ762"></a><a id="JSQLJ751"></a><div class="props_rev_3"><a id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803" name="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803"></a><h4 id="JSQLJ-GUID-E764E87E-1320-4DBE-B59E-7B03150BF803" class="sect4">更新批处理</h4>
                  <div>
                     <p>更新批处理（在Sun Microsystems JDBC 2.0规范中称为批处理更新）允许将可批处理和兼容的<code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>和<code class="codeph">INSERT</code>语句收集到批处理中并立即发送到数据库执行，从而节省了到数据库。此功能包含在JDBC和SQLJ规范中，并受Oracle JDBC和SQLJ实现的支持。更新批处理通常用于在循环内重复执行的操作。
                     </p>
                     <p>在SQLJ中，更新批处理与执行上下文使用相关联。在每个执行上下文中启用或禁用此功能，与任何其他执行上下文无关，并且每个执行上下文实例都维护自己的批处理。</p>
                     <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-4A529E01-5F5A-4BE5-AB61-4871B12353EB">
                        <p class="notep1">注意：</p>
                        <p>请注意以下更新批处理：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您必须使用默认的Oracle特定代码生成，或者，对于ISO代码生成，使用Oracle定制程序自定义应用程序。</p>
                           </li>
                           <li>
                              <p>禁止自动提交模式是非常明智的。这使您可以控制在批处理执行期间发生错误时要提交的内容以及回滚的内容。</p>
                           </li>
                        </ul>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-F1F14248-C158-463E-BA4B-3741C20617B9">可混合和兼容的声明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>两个标准确定是否可以将语句添加到现有批语句中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它可以打包吗？在任何情况下都不能批量处理某些类型的语句。</p>
                           </li>
                           <li>
                              <p>它是否与现有批次中的语句兼容？</p>
                           </li>
                        </ul>
                        <p>对于SQLJ，以下类型的语句是可处理的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">UPDATE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">插入</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">删除</code></p>
                           </li>
                        </ul>
                        <p>但是，具有一个或多个流主机表达式的<code class="codeph">UPDATE</code>和<code class="codeph">INSERT</code>语句<span class="italic">不可</span>配置。
                        </p>
                        <p>在SQLJ中，只有同一语句的多个实例是兼容的。这可以在以下两种情况中发生：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>语句在循环中重复执行。</p>
                           </li>
                           <li>
                              <p>语句在方法中执行，并且该方法被重复调用。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-F319E347-1236-4AD9-9387-C0C5C1079F76">启用和禁用更新批处理</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>SQLJ分别为每个执行上下文实例执行更新批处理。每个人都可以独立于其他执行上下文实例启用更新批处理，并且每个实例都维护自己的批处理。</p>
                        <p>要为特定执行上下文实例启用或禁用更新批处理，请使用该执行上下文实例的<code class="codeph">setBatching()</code>方法。此方法采用布尔输入，如下所示：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ...
</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（假）; ...
</pre><p>默认情况下禁用更新批处理。</p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-2C21EBA5-95C9-4E44-BF8B-D41130CAF60B">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">setBatching()</code>方法不会影响现有的语句批处理。启用或禁用更新批处理都不会导致现有批处理被执行或取消。
                           </p>
                        </div>
                        <p>使用执行上下文实例的<code class="codeph">isBatching()</code>方法确定是否为该执行上下文启用了更新批处理：</p><pre class="oac_no_warn" dir="ltr">ExecutionContext ec = new ExecutionContext（）; ...boolean batchingOn = ec.isBatching（）;</pre><p>但是，这并不表示批次当前是否处于待处理状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1005910">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-5D1F6F28-8AAE-4E70-854E-6968FFF7D847">显式和隐式批量执行</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您可以根据需要显式执行挂起的更新批处理，但在某些情况下也可能会隐式执行。</p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-CAA4C8A0-2209-4256-A438-934AED734B56">
                           <p class="notep1">注意：</p>
                           <p>重要的是要知道在批处理执行过程中发生异常时会发生什么。</p>
                        </div>
                        <p>使用执行上下文实例的<code class="codeph">executeBatch()</code>方法显式执行更新批处理。此方法返回更新计数的<code class="codeph">int</code>数组。
                        </p>
                        <p>以下是显式执行批处理的示例：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE employees SET salary = :( sals [i]）WHERE employee_id = :( empnos [i]）}; } int [] updateCounts = ec.executeBatch（）; ...
</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-B7037974-B3D0-49F6-9B62-E13D3DB6219F">
                           <p class="notep1">注意：</p>
                           <p>如果在执行上下文实例没有挂起批处理时调用<code class="codeph">executeBatch()</code> ，则该方法返回<code class="codeph">null</code> 。
                           </p>
                        </div>
                        <p>当存在挂起的更新批处理时，它会在以下情况下隐式执行：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>遇到无法处理的可执行语句。在这种情况下，首先执行现有批处理，然后执行nonbatchable语句。</p>
                           </li>
                           <li>
                              <p>遇到可更改的更新语句，但与现有批处理中的语句不兼容，换句话说，它不是同一语句的实例。在这种情况下，执行批处理，然后从不兼容的语句开始创建新的批处理。</p>
                           </li>
                           <li>
                              <p>达到预定义的批量限制，即指定数量的语句。</p>
                           </li>
                        </ul>
                        <p>以下是一个例子。当遇到unbatchable语句时，首先创建并隐式执行一个批处理，然后在遇到可绑定但不兼容的语句时创建并隐式执行新批处理：</p><pre class="oac_no_warn" dir="ltr">ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; .../ *以下循环中的语句将被置于批处理* / double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE employees SET salary = :( sals [i]）WHERE employee_id = :( empnos [i]）}; } / * SELECT是不可分配的，因此导致批处理执行* / double avg; #sql [ec] {SELECT avg（salary）INTO：avg FROM employees}; / *以下循环中的语句将放在新批处理中* / double [] comms = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE employees SET commission_pct = :( comms [i]）WHERE employee_id = :( empnos [i]）}; / *以下更新与第二批不兼容，因此导致它被执行* / int smithdeptno = ...; #sql [ec] {UPDATE employees SET department_no =：deptno WHERE first_name ='Smith'};</pre><p>要获取隐式执行的批处理的更新计数数组，请调用执行上下文实例的<code class="codeph">getBatchUpdateCounts()</code>方法。这将返回在此执行上下文实例中成功执行的最后一批的更新计数。可以在<code class="codeph">SELECT</code>之后和最后一次<code class="codeph">UPDATE</code>之后插入以下代码语句：</p><pre class="oac_no_warn" dir="ltr">int [] updateCounts = ec.getBatchUpdateCounts（）;</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-9B6FEFB5-D57A-4761-9053-A6AC4B3DA370">
                           <p class="notep1">注意：</p>
                           <p>如果没有为执行上下文实例成功执行更新批处理，则<code class="codeph">getBatchUpdateCounts()</code>将返回<code class="codeph">null</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006005">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A6CA4450-1862-4346-B0FF-7E8DB241019A">取消批次</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要取消执行上下文中挂起的批处理，请使用执行上下文实例的<code class="codeph">cancel()</code>方法。例如，如果在批处理执行期间发生异常，您可以取消已执行但尚未提交的批处理。以下是一个例子：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE employees SET salary = :( sals [i]）WHERE employee_id = :( empnos [i]）};如果（！check（sals [i]，empnos [i]））//假设“check”是用户提供的函数{ec.cancel（）;抛出新的SQLException（“进程已取消。”）; try {int [] updateCounts = ec.executeBatch（）; } catch（SQLException exception）{ec.cancel（）; } ...
</pre><p>取消批处理时，下一个batchable语句将启动新批处理。</p>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-E269016C-CA32-414B-A9B7-C8AAC3EF5562">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>调用<code class="codeph">cancel()</code>也将取消当前正在执行的任何语句。
                                 </p>
                              </li>
                              <li>
                                 <p>取消批<span class="italic">不会</span>禁用更新配料。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006039">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-736D0F9D-35E9-4EA9-9899-EC8A56949D36">执行上下文更新计数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在Oracle数据库12 <span class="italic">c</span>解除1（12.1）SQLJ实现中，更新计数由所述返回的数组<code class="codeph">executeBatch()</code>或<code class="codeph">getBatchUpdateCounts()</code>的执行上下文实例<span class="italic">不</span>包含由所述批处理的语句更新的行的数目的计数的方法，但只是表明每个陈述是否成功的值。因此，其功能不同于未启用批处理时执行上下文实例的<code class="codeph">getUpdateCount()</code>方法返回的单个更新计数。由于语句是批处理的，批处理执行后， <code class="codeph">getUpdateCount()</code>返回的单个更新计数也会受到影响。
                        </p>
                        <p>在启用批处理的环境中，在遇到每个语句后，将修改执行上下文实例的<code class="codeph">getUpdateCount()</code>方法中可用的值。它将使用几个<code class="codeph">ExecutionContext</code>类中的一个静态<code class="codeph">int</code>常量值进行更新，如下所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">NEW_BATCH_COUNT</code> ：表示为遇到的最后一个语句创建了一个新批处理。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ADD_BATCH_COUNT</code> ：表示遇到的最后一个语句已添加到现有批处理中。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EXEC_BATCH_COUNT</code> ：表示在遇到最后一个语句后，显式或隐式执行了挂起的批处理。
                              </p>
                           </li>
                        </ul>
                        <p>如果要引用这些常量，请使用以下限定名称：</p><pre class="oac_no_warn" dir="ltr">执行上下文。NEW_BATCH_COUNT个ExecutionContext。ADD_BATCH_COUNT个ExecutionContext。EXEC_BATCH_COUNT</pre><p>在显式或隐式执行批处理之后， <code class="codeph">executeBatch()</code>或<code class="codeph">getBatchUpdateCounts()</code>返回的值数组仅指示语句是否成功执行。每个批处理语句都有一个数组元素。根据JDBC 2.0规范，数组元素的值<code class="codeph">-2</code>表示相应的语句已成功完成，但它影响的行数未知。
                        </p>
                        <p>执行批处理后检查所有数组值没有意义。正如目前实现的那样，这个数组唯一有用的测试是通过在成功执行后检查数组中的元素数来验证执行前批处理中的语句数（实际上，在执行批处理之后）不产生例外）。</p>
                        <p>请注意，只有在批处理时才会修改更新计数数组，因为只有批处理才会执行。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006064">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-799B803A-A09C-4F5B-9703-69A97AE24225">设置批量限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在添加下一个语句之前，您可以指定在批处理预定义数量的语句之后执行每个更新批处理。使用执行上下文实例的<code class="codeph">setBatchLimit()</code>方法，输入正的非零整数，如下所示：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ec.setBatchLimit（10）; ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;20; i ++）{#sql [ec] {UPDATE emp1 SET sal = :( sals [i]）WHERE empno = :( empnos [i]）}; }</pre><p>此循环执行20次，其中语句被批处理，批处理在第11次循环期间执行，之后第11个语句将添加到批处理中。但是请注意，批处理不会在循环中第二次执行。当您的应用程序退出循环时，最后十个语句仍然在批处理中，并且在遇到另一个语句或您明确执行批处理之前不会执行。</p>
                        <p>您可以使用<code class="codeph">ExecutionContext</code>类的两个特殊静态<code class="codeph">int</code>常量作为<code class="codeph">setBatchLimit()</code>方法的输入：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">AUTO_BATCH</code> ：启用SQLJ运行时以确定批次限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">UNLIMITED_BATCH</code> （默认值）：指定没有批次限制。
                              </p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ec.setBatchLimit（执行上下文。AUTO_BATCH）; ...
</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">ec.setBatchLimit（执行上下文。UNLIMITED_BATCH）; ...
</pre><p>要检查当前批处理限制，请使用执行上下文实例的<code class="codeph">getBatchLimit()</code>方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-858CDEA9-304B-4472-9210-2ED966190C2D">批处理不兼容的语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果要批处理与现有批处理中的语句不兼容的语句，而不隐式执行现有批处理，则必须使用单独的执行上下文实例。以下是一个例子：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec1 = new ExecutionContext（）; ec1.setBatching（真）; ExecutionContext ec2 = new ExecutionContext（）; ec2.setBatching（真）; ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec1] {UPDATE emp1 SET sal = :( sals [i]）WHERE empno = :( empnos [i]）}; #sql [ec2] {UPDATE emp2 SET sal = :( sals [i]）WHERE empno = :( empnos [i]）}; } int [] updateCounts1 = ec1.executeBatch（）; int [] updateCounts2 = ec2.executeBatch（）; ...
</pre><div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-018A97CE-20B5-4156-A760-C6A268DA8F13">
                           <p class="notep1">注意：</p>
                           <p>此示例假定两个<code class="codeph">UPDATE</code>语句完全相互独立。不要在不同的执行上下文中批处理相互依赖的语句，因为您无法完全确定它们的执行顺序。
                           </p>
                        </div>
                        <p>另一种方法是使用单个执行上下文和单独的循环，以便在<code class="codeph">EMP2</code>更新之前批量处理并执行所有<code class="codeph">EMP1</code>更新：</p><pre class="oac_no_warn" dir="ltr">...ExecutionContext ec = new ExecutionContext（）; ec.setBatching（真）; ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE emp1 SET sal = :( sals [i]）WHERE empno = :( empnos [i]）}; } for（int i = 0; i &lt;empnos.length; i ++）{#sql [ec] {UPDATE emp2 SET sal = :( sals [i]）WHERE empno = :( empnos [i]）}; ec.executeBatch（）; ...
</pre><p>此示例显式执行第一个批处理和第二个批处理。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-507081B0-2691-4FDC-BFDA-0382143BF567">使用隐式执行上下文进行更新批处理</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>到目前为止，所有更新批处理示例都已创建并指定了显式执行上下文实例。但是，这并不是必需的，因为每个连接上下文实例都有一个隐式执行上下文实例。例如，您可以访问默认连接的隐式执行上下文实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">。DefaultContext.getDefaultContext（）getExecutionContext（）setBatching（真）。 ...double [] sals = ...; String [] empnos = ...; for（int i = 0; i &lt;empnos.length; i ++）{#sql {UPDATE employees SET salary = :( sals [i]）WHERE employee_id = :( empnos [i]）}; } //隐式执行批处理并提交#sql {COMMIT};</pre><p>或者，您可以显式执行批处理，如下所示：</p><pre class="oac_no_warn" dir="ltr">。DefaultContext.getDefaultContext（）getExecutionContext（）则ExecuteBatch（）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-23DC0E98-FFED-43CF-A525-E15722C90E8D">有关更新批处理的一般注意事项</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果使用更新批处理，特别是如果使用未分页执行上下文实例将语句与使用批处理执行上下文实例的语句混合，则请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果unbatched语句依赖于批处理语句，那么请确保在unbatched语句之前执行批处理。</p>
                           </li>
                           <li>
                              <p>JDBC <code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作（即自动提交或任何显式使用JDBC <code class="codeph">Connection</code>实例的<code class="codeph">commit()</code>或<code class="codeph">rollback()</code>方法<code class="codeph">rollback()</code>不会批量执行挂起语句。
                              </p>
                              <p>但是，请务必注意，使用SQLJ <code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>语句（如下所示） <span class="italic">将</span>批量执行挂起语句：</p><pre class="oac_no_warn" dir="ltr">#sql {COMMIT};</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">#sql {ROLLBACK};</pre><p>这是您应该始终使用<code class="codeph">#sql</code>语法提交或回滚更改的另一个原因，这会清除SQLJ资源和JDBC资源。
                              </p>
                           </li>
                           <li>
                              <p>当由于遇到不可访问或不兼容的语句而隐式执行批处理时，批处理在执行unbatchable或不兼容语句<span class="italic">之前</span>执行，但<span class="italic">在</span>评估该语句的输入参数并将其传递给语句之后。
                              </p>
                           </li>
                           <li>
                              <p>如果您不再打算使用特定的批处理启用的执行上下文实例，则显式执行或取消其挂起的批处理以释放资源。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006173">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-9D77ED43-AAFE-43C3-9D3B-B1B1AFC35D70">批处理执行期间的错误条件</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果语句在批处理执行过程中导致异常，请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic">不</span>执行导致异常的语句之后的批处理语句。
                              </p>
                           </li>
                           <li>
                              <p>在异常之前已经执行的批处理语句<span class="italic">不会</span>回滚。
                              </p>
                           </li>
                           <li>
                              <p>如果由于遇到另一个（不可访问或不兼容）语句而隐式执行发生异常的批处理， <span class="italic">则不</span>执行该语句。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A83607A9-3148-4EE6-BD76-1EAFE11CA42D">
                           <p class="notep1">注意：</p>
                           <p>假设您在使用更新批处理时已禁用自动提交模式。这可以在批处理执行期间出现错误时提供提交/回滚控制。</p>
                        </div>
                        <p>在JDBC 2.0或更高版本下批处理执行期间发生异常时，它通常是标准<code class="codeph">java.sql.的实例<code class="codeph">java.sql.BatchUpdateException</code>类， <code class="codeph">java.sql.的子类<code class="codeph">java.sql.SQLException</code>类。<code class="codeph">BatchUpdateException</code>类具有<code class="codeph">getUpdateCounts()</code>方法，对于在发生异常之前成功执行的批处理语句，该方法返回的更新计数数组等于<code class="codeph">ExecutionContext</code>类的<code class="codeph">executeBatch()</code>或<code class="codeph">getBatchUpdateCounts()</code>方法返回的更新计数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__GUID-A7CE4C74-ABF1-4F86-8829-AC234982E270">递归调用和更新批处理</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>执行SQLJ存储过程（其中一个调用另一个）可能导致两个过程同时使用相同的执行上下文实例。使用执行上下文实例的<code class="codeph">setBatching()</code>方法设置的update-batching标志将以与其他执行上下文属性相同的方式起作用。无论哪个存储过程设置它，它都会影响任一存储过程中的下一个可执行语句。
                        </p>
                        <p>因此，每当发生递归调用时，都会在服务器中自动禁用更新批处理。执行挂起的批处理，并且在递归调用的过程中不会发生批处理。要避免此行为，请在启用批处理的存储过程中使用显式执行上下文实例。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ764"></a><a id="JSQLJ765"></a><a id="JSQLJ763"></a><div class="props_rev_3"><a id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50" name="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50"></a><h4 id="JSQLJ-GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50" class="sect4">列定义</h4>
                  <div>
                     <p>Oracle SQLJ实现反映了Oracle JDBC对列类型和大小定义的支持。根据驱动程序实现（在不同的Oracle JDBC驱动程序中有所不同），注册列类型和大小可以为每个查询保存数据库的行程。特别是，Oracle JDBC Thin驱动程序和位置迭代器的使用也是如此。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50__GUID-DCC0030F-C486-40D5-BBD9-24CFDA877839">Oracle实现列定义</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果启用列定义，则Oracle SQLJ实现将采用以下步骤自动注册列类型和大小：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在自定义期间或在使用默认的Oracle特定代码生成的转换期间，SQLJ连接到指定的数据库模式以确定要检索的列的类型和大小。使用ISO标准SQLJ代码生成，列默认值成为SQLJ配置文件的一部分。这可以在源代码转换的定制步骤期间或在现有配置文件的单独定制期间完成。</p>
                           </li>
                           <li>
                              <p>当您的应用程序执行时，SQLJ运行时将使用列信息通过JDBC驱动程序注册列类型和大小，方法是调用Oracle JDBC语句类中提供的<code class="codeph">defineColumnType()</code>方法。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-68162E09-5D50-43BE-B39D-6CFCC90B5D50__GUID-8044C763-F4AC-4E23-A1D0-E1D7212B91F3">列定义的定制器和转换器选项</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要启用列定义，请按如下方式设置SQLJ选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>启用<code class="codeph">optcols</code>标志。对于Oracle特定的代码生成，请使用SQLJ转换器<code class="codeph">-optcols</code>选项。对于ISO标准代码生成，请使用转换程序选项或Oracle自定义程序选项（SQLJ命令行上的<code class="codeph">-P-Coptcols</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>设置数据库连接的用户，密码和URL。对于Oracle特定的代码生成，这是通过SQLJ转换器<code class="codeph">-user</code> ， <code class="codeph">-password</code>和<code class="codeph">-url</code>选项。对于ISO标准代码生成，可以通过转换程序选项，也可以单独使用自定义程序选项（SQLJ命令行上的<code class="codeph">-P-user</code> ， <code class="codeph">-P-password</code>和<code class="codeph">-P-url</code> ）。此外，如果未使用默认的<code class="codeph">OracleDriver</code>类，请设置JDBC驱动程序类（SQLJ命令行上的<code class="codeph">-P-driver</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>有关自定义程序选项的信息，请参阅<span class="q">“ <a href="appendix.html#GUID-0BBEA4C2-0474-40DE-9082-D55813F8BE02">自定义程序特定选项概述</a> ”</span>下的<span class="q">“</span> <code class="codeph">optcols</code>部分，以及<span class="q">“ <a href="appendix.html#GUID-4E316F9C-E16F-45D4-A5ED-B77B7BCF44A6">自定义程序线束选项概述</a> ”</span>下的<code class="codeph">user</code> ， <code class="codeph">password</code> ， <code class="codeph">url</code>和<code class="codeph">driver</code>部分。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ767"></a><a id="JSQLJ768"></a><a id="JSQLJ769"></a><a id="JSQLJ766"></a><div class="props_rev_3"><a id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D" name="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D"></a><h4 id="JSQLJ-GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D" class="sect4">参数大小定义</h4>
                  <div>
                     <p>Oracle JDBC和SQLJ实现使您可以通过定义用作以下任何一项的参数大小（Java主机变量的大小）来优化JDBC资源分配：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>存储过程或函数调用中的输入或输出参数</p>
                        </li>
                        <li>
                           <p>从存储的函数调用返回值</p>
                        </li>
                        <li>
                           <p>SET语句中的输入或输出参数</p>
                        </li>
                        <li>
                           <p>PL / SQL块中的输入或输出参数</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-6213773C-5889-48A8-A081-850606DDEEE2">Oracle实现参数大小定义</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle通过选项设置实现参数大小定义，并结合源代码注释中嵌入的提示。对于ISO标准SQLJ代码生成，可以使用Oracle定制程序选项。对于默认的Oracle特定代码生成，可以使用等效的SQLJ转换器选项。</p>
                        <p>使用选项和提示如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过SQLJ转换程序或Oracle定制程序参数定义标志启用参数大小定义。</p>
                           </li>
                           <li>
                              <p>通过SQLJ转换程序或Oracle customizer参数默认大小选项指定特定数据类型的默认大小。</p>
                           </li>
                           <li>
                              <p>通过在源代码注释中嵌入提示，按照规定的格式覆盖特定参数的数据类型默认大小。</p>
                           </li>
                        </ul>
                        <p>对于任何给定的主机变量，当启用参数大小定义时，如果存在资源，则根据源代码提示分配资源。如果没有源代码提示，则使用相应数据类型的默认大小（如果指定了一个）。如果没有源代码提示或适当的默认大小，则根据JDBC实现分配最大资源。</p>
                        <p>应用程序执行时，通过调用Oracle JDBC语句类中可用的<code class="codeph">defineParameterType()</code>和<code class="codeph">registerOutParameter()</code>方法来注册参数大小。
                        </p>
                        <div class="infoboxnote" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-33D99FBA-07BA-432F-802F-8547894645B8">
                           <p class="notep1">注意：</p>
                           <p>如果未启用参数定义标志，则将忽略参数大小缺省值和源代码提示，并根据JDBC实现分配最大或缺省资源。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-6B4EE248-90F4-4984-AB56-EC9EABE3BD2F">参数大小定义的定制器和转换器选项</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对参数大小定义使用以下SQLJ选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<code class="codeph">optparams</code>标志启用参数大小定义。对于特定于Oracle的代码生成，请使用SQLJ转换器<code class="codeph">-optparams</code>选项。对于ISO标准代码生成， <code class="codeph">-P-Coptparams</code>在SQLJ命令行上使用转换程序选项或Oracle自定义程序选项<code class="codeph">-P-Coptparams</code> 。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">optparamdefaults</code>为特定数据类型设置默认大小。对于特定于Oracle的代码生成，请使用SQLJ转换程序<code class="codeph">-optparamdefaults=</code> <span class="italic"><code class="codeph">xxxx</code></span>选项。对于ISO标准代码生成，请在SQLJ命令行上使用转换程序选项或Oracle自定义程序选项<code class="codeph">-P-Coptparamdefaults=</code> <span class="italic"><code class="codeph">xxxx</code></span> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-1D3BD376-A9A2-436C-B77B-B7548CFCD96A">参数大小定义的源代码提示</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下列格式在SQLJ语句中嵌入参数大小定义的源代码提示（您可以根据需要在注释中添加空格）：</p><pre class="oac_no_warn" dir="ltr">/ *（ <span class="italic">大小</span> ）* /</pre><p>大小以字节为单位。如果禁用<code class="codeph">optparams</code>标志，则忽略提示。
                        </p>
                        <p>您可以覆盖默认参数大小，而无需指定新大小（将大小分配给JDBC实现），如下所示：</p><pre class="oac_no_warn" dir="ltr">/ *（）* /</pre><p>这是一个例子：</p><pre class="oac_no_warn" dir="ltr">byte [] hash;字符串名称= Tyrone; String street = 2020梅丽尔街; String city = Wichita;弦乐州=堪萨斯州; String zipcode = 77777; #sql hash = {/ *（5）* / VALUES（ADDR_HASH（：name / *（20）* /，：street / *（）* /，：city，：state，：INOUT zipcode / *（10）* /））};</pre><p>结果表达式的提示（例如示例中的结果表达式<code class="codeph">hash</code>必须是出现在SQLJ语句括号内的第一个项目，如图所示。输入和输出主变量的提示必须紧跟变量，如图所示。
                        </p>
                        <p>该示例设置参数大小如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">hash</code> ：5个字节</p>
                           </li>
                           <li>
                              <p><code class="codeph">name</code> ：20个字节</p>
                           </li>
                           <li>
                              <p><code class="codeph">street</code> ：覆盖默认值，但没有设置（将分配保留到JDBC）</p>
                           </li>
                           <li>
                              <p><code class="codeph">city</code> ：none（使用适当的数据类型默认，如果有的话）</p>
                           </li>
                           <li>
                              <p><code class="codeph">state</code> ：none（使用适当的数据类型default，如果有的话）</p>
                           </li>
                           <li>
                              <p><code class="codeph">zipcode</code> ：10个字节</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-51188B99-AF1F-4F26-8826-1F5CAB03122D__GUID-C63A6FF8-4F21-4D98-89C1-34E967D7CCBC">
                           <p class="notep1">注意：</p>
                           <p>如果更改任何参数大小以使其实际大小在运行时超过其注册大小，则将引发SQL异常。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ770"></a><div class="props_rev_3"><a id="GUID-630E713D-C1AA-4ED8-8061-153B6880EB61" name="GUID-630E713D-C1AA-4ED8-8061-153B6880EB61"></a><h3 id="JSQLJ-GUID-630E713D-C1AA-4ED8-8061-153B6880EB61" class="sect3">SQLJ调试功能</h3>
               <div>
                  <p>本节总结了Oracle SQLJ实现中的调试功能。它包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-35667B8F-391D-4B14-BE21-0C76BE642D14">用于调试的SQLJ -linemap标志</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4">AuditorInstaller专业定制器概述</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-4D44802F-CF56-4C60-BFA3-F783570806F4">Oracle10g JDeveloper中的开发和调试概述</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ771"></a><div class="props_rev_3"><a id="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14" name="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14"></a><h4 id="JSQLJ-GUID-35667B8F-391D-4B14-BE21-0C76BE642D14" class="sect4">用于调试的SQLJ -linemap标志</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">-linemap</code>标志指示SQLJ将SQLJ源代码文件中的行号映射到相应<code class="codeph">.class</code>文件中的位置。这将是在编译由SQLJ转换器生成的<code class="codeph">.java</code>文件期间创建的<code class="codeph">.class</code>文件。因此，当发生Java运行时错误时，Java虚拟机（JVM）报告的行号是SQLJ源代码中的行号，使调试更容易。
                        </p>
                        <p>如果您使用的是Sun Microsystems <code class="codeph">jdb</code>调试器，则使用<code class="codeph">-jdblinemap</code>选项而不是<code class="codeph">-linemap</code>选项。这些选项是等效的，除了<code class="codeph">-jdblinemap</code>执行一些特殊处理，因为<code class="codeph">jdb</code>不支持文件扩展名不是<code class="codeph">.java</code>扩展名的Java源文件。
                        </p>
                        <div class="infoboxnote" id="GUID-35667B8F-391D-4B14-BE21-0C76BE642D14__GUID-6DA504C7-6AD4-41AC-AE9E-F9BB1FCF5FFF">
                           <p class="notep1">注意：</p>
                           <p>如果要在服务器中进行转换，则在服务器端转换期间创建的类模式对象会自动引用映射到SQLJ源代码的行号。这相当于在客户端上进行翻译时启用<code class="codeph">-linemap</code>选项。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ773"></a><div class="props_rev_3"><a id="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4" name="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4"></a><h4 id="JSQLJ-GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4" class="sect4">AuditorInstaller专业定制器概述</h4>
                  <div>
                     <p>对于ISO代码生成，SQLJ提供了一个特殊的自定义程序<code class="codeph">AuditorInstaller</code> 。此定制程序将在SQLJ命令行中指定的概要文件中插入称为审计程序的调试语句集。这些配置文件必须已存在于以前的自定义中。调试语句将在SQLJ运行时（当有人运行您的应用程序时）执行，显示一系列方法调用和返回的值。
                     </p>
                     <p>使用自定义程序线束<code class="codeph">debug</code>选项（前缀为<code class="codeph">-P-</code>与任何常规自定义选项一样）来插入调试语句。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C7C84438-BA07-44C9-B7E4-329F9B36E0C4__GUID-5FBFE829-924C-4830-AECE-B52F4891DE33">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="appendix.html#GUID-B820810A-DDDF-4E42-A3C9-AF04F4DC7075">用于调试的AuditorInstaller定制器</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ774"></a><div class="props_rev_3"><a id="GUID-4D44802F-CF56-4C60-BFA3-F783570806F4" name="GUID-4D44802F-CF56-4C60-BFA3-F783570806F4"></a><h4 id="JSQLJ-GUID-4D44802F-CF56-4C60-BFA3-F783570806F4" class="sect4">Oracle10 <span class="italic">g</span> JDeveloper中的开发和调试概述</h4>
                  <div>
                     <p>甲骨文SQLJ产品完全集成到ORACLE10 <span class="italic">摹</span> JDeveloper的可视化编程工具。
                     </p>
                     <p>JDeveloper还包括一个支持SQLJ的集成调试器。与标准Java语句一样，SQLJ语句可以在应用程序执行时进行内联调试。报告的行号根据SQLJ源代码中的行号（与生成的Java代码相反）。</p>
                  </div>
               </div>
            </div><a id="JSQLJ775"></a><div class="props_rev_3"><a id="GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585" name="GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585"></a><h3 id="JSQLJ-GUID-0CAF88FB-C905-43AF-AB6B-2FE983615585" class="sect3">SQLJ支持Oracle性能监视</h3>
               <div>
                  <p>FUTURE（10i / 10.1之后）：SQLJ DMS监控本地存储为层次结构; -sqlmonitor.dms = false设置（用于本地存储而不是发送到DMS）;使用SQLJ DMS API（访问本地存储的结果）。</p>
                  <p>FUTURE（10i / 10.1之后）：SQLJ -components = append; DMS的多次翻译运行。</p>
                  <p>未来：适当时将Oracle9iAS更新为Oracle10iAS。</p>
                  <p>以下部分讨论Oracle动态监视服务（DMS）的Oracle SQLJ实现支持：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-5C441E4C-075B-46E3-A518-A5D6E8745764">SQLJ DMS支持概述</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661">DMS的SQLJ命令行选项摘要</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-2AE24805-697C-4C28-9E27-1301DBD100C7">DMS的SQLJ运行时命令和属性文件设置</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-994A9604-3FD1-4A2E-9378-4606E1863B33">SQLJ DMS传感器和度量标准</a></p>
                     </li>
                     <li>
                        <p><a href="performance-and-debugging.html#GUID-AB176F74-4B1D-478E-A896-99FB750805F2">SQLJ DMS示例</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ776"></a><div class="props_rev_3"><a id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764" name="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764"></a><h4 id="JSQLJ-GUID-5C441E4C-075B-46E3-A518-A5D6E8745764" class="sect4">SQLJ DMS支持概述</h4>
                  <div>
                     <p>DMS使用户能够测量SQLJ程序的性能统计信息。对SQL的SQLJ支持侧重于每个SQL语句的整体性能，例如其执行时间，但也可以提供方法级或类级性能信息，例如Oracle对Oracle的JDBC支持。您可以选择客户端透视图，例如每个<code class="codeph">#sql</code>语句的整体性能，服务器端透视图，例如每个SQL操作的服务器端跟踪，或两者。
                     </p>
                     <p>为了启用DMS设置，需要检测通过SQLJ选项在转换时指定的程序。具体而言，检测是将DMS调用插入系统或应用程序代码以测量其性能的过程。</p>
                     <p>在运行时，根据SQLJ DMS属性文件中的指示，可以在执行期间监视在转换期间检测的任何组件。在运行时，统计信息通过DMS API发送到DMS。这需要在您的环境中运行DMS系统。然后，您可以通过DMS工具访问统计信息。</p>
                     <p>统计信息旨在帮助您跟踪和理解SQL语句性能，并根据以下层次结构（从上到下）进行报告：</p>
                     <ol>
                        <li>
                           <p>应用程序：在此上下文中，应用程序被定义为由SQLJ命令行中指定的SQLJ和Java组件进行转换。但是，只能检测SQLJ组件。</p>
                        </li>
                        <li>
                           <p>模块：模块对应于Java包。</p>
                        </li>
                        <li>
                           <p>操作：操作映射到SQLJ程序中定义的Java类。</p>
                        </li>
                        <li>
                           <p>声明：语句是SQLJ程序中的SQL语句。</p>
                        </li>
                     </ol>
                     <p>测量以下DMS统计信息以进行客户端监视：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>每个<code class="codeph">#sql</code>语句的经过时间，包括解析和执行</p>
                        </li>
                        <li>
                           <p>获取下一次执行每个<code class="codeph">next()</code>调用的时间</p>
                        </li>
                        <li>
                           <p>Get-XXX时间，通过每次<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>调用提取数据库列的时间</p>
                        </li>
                     </ul>
                     <p>这些统计信息要求DMS库在转换时和运行时都位于类路径中，因此DMS库不可用的服务器不支持。无法以客户端代码的方式监视服务器端SQLJ代码。</p>
                     <p>测量SQLJ客户端程序的服务器端SQL监视的以下统计信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>解析时间</p>
                        </li>
                        <li>
                           <p>执行时间处理时间</p>
                        </li>
                        <li>
                           <p>获取时间</p>
                        </li>
                     </ul>
                     <p>这些统计信息可通过SQL跟踪功能从Oracle Database 12 <span class="italic">c</span>第1版（12.1）跟踪文件中获得。这与DMS无关，但您可以通过SQLJ DMS属性文件<code class="codeph">sqlmonitor.servertracing</code>设置启用它。
                     </p>
                     <div class="infoboxnotealso" id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764__GUID-877289C4-84BE-49AB-8D63-E824BF1D598A">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="performance-and-debugging.html#GUID-2AE24805-697C-4C28-9E27-1301DBD100C7">DMS的SQLJ运行时命令和属性文件设置</a> ”</span></p>
                     </div>
                     <p>对于客户端SQLJ程序，您可以使用DMS统计信息和服务器端跟踪。例如，从DMS中，您可以获得由查询组成的<code class="codeph">#sql</code>语句所需的总时间，然后从服务器端跟踪中可以了解在服务器中执行SQL查询实际花费了多少时间。
                     </p>
                     <div class="infoboxnote" id="GUID-5C441E4C-075B-46E3-A518-A5D6E8745764__GUID-2E4EA613-E409-4225-B644-E16F60A02F79">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>DMS支持目前需要特定于Oracle的代码生成，默认情况下已启用。</p>
                           </li>
                           <li>
                              <p>在Oracle Database 12 <span class="italic">c</span>第1版（12.1）中，已检测的代码需要Java Development Kit（JDK）6。
                              </p>
                           </li>
                           <li>
                              <p>仅检测SQLJ声明和语句。</p>
                           </li>
                           <li>
                              <p>DMS库位于文件<code class="codeph">dms.jar</code> ，位于Oracle Database 12 <span class="italic">c</span>第1版（12.1）的<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/oc4j/lib</code>中</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ777"></a><div class="props_rev_3"><a id="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661" name="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661"></a><h4 id="JSQLJ-GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661" class="sect4">DMS的SQLJ命令行选项摘要</h4>
                  <div>
                     <p>未来（10i / 10.1之后）： - 组件=追加;多次翻译。</p>
                     <p>Oracle SQLJ实现提供以下转换器前端选项以支持DMS：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">-instrument</code> ：启用检测并为应用程序指定名称（要转换的组件的集合）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-components</code> ：指定要检测的组件（包和类）。
                           </p>
                        </li>
                     </ul>
                     <p>通常，您可以通过在<code class="codeph">-instrument</code>设置中指定所需的应用程序名称来启用检测，也可以选择指定包。或者将设置指定为<code class="codeph">true</code>以使用默认应用程序<code class="codeph">defaultApp</code> 。对于DMS检测，术语应用程序是指在SQLJ命令行中为转换指定的所有SQLJ和Java组件。
                     </p>
                     <p>如果启用了检测，则根据<code class="codeph">-instrument</code>设置创建SQLJ DMS属性文件，从当前目录开始，并根据SQLJ <code class="codeph">-d</code>选项的任何设置创建。对于设置为<code class="codeph">true</code> ，属性文件在当前目录中命名为<code class="codeph">sqlmonitor.properties</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-79B630D1-4ED7-4F6F-80C2-D03CCEE44661__GUID-B556D9B1-8919-421F-A5C4-58C0C5DBCE7C">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">-instrument</code>的设置相当于<code class="codeph">-instrument=true</code> 。<code class="codeph">-instrument=false</code> （默认值）的设置会禁用检测。
                        </p>
                     </div>
                     <p>举个简单的例子， <code class="codeph">-instrument=myapp</code>的设置将导致创建属性文件<code class="codeph">myapp.properties</code> 。现在考虑以下示例，对于<code class="codeph">stock</code>的应用程序名称和<code class="codeph">com.acme</code>的包名称：</p><pre class="oac_no_warn" dir="ltr">％sqlj -instrument = com.acme / stock -d / home Stock.sqlj Trading.sqlj</pre><p>由于<code class="codeph">-d</code>选项，将创建<code class="codeph">/home/com/acme/stock.properties</code>文件。
                     </p>
                     <p>通过<code class="codeph">-instrument</code>选项启用检测时，使用<code class="codeph">-components</code>选项指定要为DMS监视检测的已翻译组件的子集，通常是大部分或全部，以便在运行时可以灵活监视。指定以逗号分隔的包列表（用于检测每个包中的所有类）或特定类，或使用default <code class="codeph">all</code>设置来检测所有正在转换的组件。
                     </p>
                     <p>例如，要检查<code class="codeph">Stock</code>和<code class="codeph">Trading</code>类：</p><pre class="oac_no_warn" dir="ltr">％sqlj ... -components = com.acme。股票，com.acme。贸易</pre><p>在运行时，将根据SQLJ DMS属性文件中指定的内容监视已检测的组件。无论在属性文件中指定了什么，在运行期间都无法监视在转换期间未检测的任何组件。</p>
                  </div>
               </div><a id="JSQLJ778"></a><div class="props_rev_3"><a id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7" name="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7"></a><h4 id="JSQLJ-GUID-2AE24805-697C-4C28-9E27-1301DBD100C7" class="sect4">DMS的SQLJ运行时命令和属性文件设置</h4>
                  <div>
                     <p>虽然SQLJ <code class="codeph">-instrument</code>选项指定SQLJ转换器是否监视文件以进行监视功能，但SQLJ DMS属性文件实际上是在运行时确定监视的内容以及方式。
                     </p>
                     <p>此属性文件由SQLJ在翻译期间创建，然后您可以根据需要进行修改。请注意，如果再次运行SQLJ，SQLJ会覆盖属性文件。您所做的任何更改都将丢失。</p>
                     <p>SQLJ DMS属性文件中的设置如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">sqlmonitor.components</code> ：这是一个以逗号分隔的已检测组件（包或类）的列表。这由翻译器自动设置，以反映SQLJ <code class="codeph">-components</code>选项的设置。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.monitorcomp</code> ：这是一个以逗号分隔的要监视的组件（包或类）列表，表示<code class="codeph">sqlmonitor.components</code>设置中组件的子集。<code class="codeph">sqlmonitor.monitorcomp</code>的设置最初在转换期间确定，以反映<code class="codeph">sqlmonitor.components</code>设置，但您可以根据需要进行调整。<code class="codeph">all</code>设置<code class="codeph">all</code>可以监视<code class="codeph">sqlmonitor.components</code>设置中列出的所有组件。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.dms</code> ：此布尔标志，默认值为<code class="codeph">true</code> ，指定是否将收集的统计信息传递给DMS。这需要运行Oracle Application Server <span class="italic">10g</span>实例，您可以在其中使用DMS工具。统计信息可以通过Web浏览器访问或写入文件。
                           </p>
                           <div class="infoboxnote" id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7__GUID-0539F721-4034-4FBE-9A24-80C3C9EF7C21">
                              <p class="notep1">注意：</p>
                              <p>目前不支持<code class="codeph">sqlmonitor.dms=false</code>设置。
                              </p>
                           </div>
                           <p>FUTURE（10i / 10.1之后）：支持sqlmonitor.dms = false。（如果sqlmonitor.dms = false，是否还需要DMS库？）</p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.sysurl</code> ：对于服务器端跟踪，它指定数据库URL。</p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.sysuser</code> ：对于服务器端跟踪，它指定数据库用户。该用户必须具有<code class="codeph">sysdba</code>权限。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.syspassword</code> ：对于服务器端跟踪，它指定<code class="codeph">sysuser</code>的密码。
                           </p>
                           <div class="infoboxnote" id="GUID-2AE24805-697C-4C28-9E27-1301DBD100C7__GUID-38EC633F-2F20-4B73-BC0D-AEA922DA8F1D">
                              <p class="notep1">注意：</p>
                              <p>对于<code class="codeph">sysurl</code> ， <code class="codeph">sysuser</code>和<code class="codeph">syspassword</code> ，默认值根据提供给SQLJ的<code class="codeph">user</code> ， <code class="codeph">password</code>和<code class="codeph">url</code>值，通过SQLJ命令行或通过SQLJ属性文件。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.servertracing</code> ：使用此命令启用服务器端跟踪，以收集服务器中的性能统计信息，例如SQL操作。支持的设置为<code class="codeph">true</code>或<code class="codeph">false</code> （默认值）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">sqlmonitor.dumpfile</code> ：如果向DMS提供统计信息，则可以使用此选项指定DMS工具将统计信息写入的文件。默认值为<span class="italic"><code class="codeph">application_name</code></span> <code class="codeph">.mtr</code> ，其中<span class="italic"><code class="codeph">application_name</code></span>根据<code class="codeph">-instrument</code>选项设置（默认情况下为<code class="codeph">defaultApp</code> ）。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ779"></a><div class="props_rev_3"><a id="GUID-994A9604-3FD1-4A2E-9378-4606E1863B33" name="GUID-994A9604-3FD1-4A2E-9378-4606E1863B33"></a><h4 id="JSQLJ-GUID-994A9604-3FD1-4A2E-9378-4606E1863B33" class="sect4">SQLJ DMS传感器和度量标准</h4>
                  <div>
                     <p>DMS使用传感器来计算执行检测的SQLJ程序期间的性能指标并将其传送到DMS。它们被组织为层次结构，每个传感器都具有路径名称。以下是典型的传感器格式：</p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">sensor_name</span> / SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">sensor_name</span> / SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">sensor_name</span> / SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / <span class="italic">sensor_name</span>
</pre><p>传感器是<code class="codeph">oracle.dms.instrument.一个实例<code class="codeph">oracle.dms.instrument.Sensor</code>类，具有计算和组织性能统计信息的方法。例如，有一些方法可以指示传感器导出其他指标并获取其中一个指标的值。
                     </p>
                     <p>请注意，在已检测的应用程序结束之前，必须调用<code class="codeph">oracle.sqlj.runtime.sqlmonitor.的<code class="codeph">close()</code>方法<code class="codeph">oracle.sqlj.runtime.sqlmonitor.SQLMonitor</code>类，如下面的示例（其中还使用<code class="codeph">Oracle</code>类<code class="codeph">close()</code>方法来关闭连接上下文）：</p><pre class="oac_no_warn" dir="ltr">试试{Oracle.close（）; oracle.sqlj.runtime.sqlmonitor。SQLMonitor.close（）; } catch（Throwable e）{...}</pre><p>请注意以下条款：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">application_name</code></span>是根据SQLJ <code class="codeph">-instrument</code>选项的应用程序名称，默认情况下是<code class="codeph">defaultApp</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果传感器与包关联，则项<span class="italic"><code class="codeph">module</code></span>是包名。如果包名称为空，则使用设置<code class="codeph">*TopLevel*</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果传感器与类关联，则<span class="italic"><code class="codeph">class</code></span>是类名。
                           </p>
                        </li>
                        <li>
                           <p>如果传感器与SQL语句关联，则<span class="italic"><code class="codeph">linenum</code></span>表示正在检测的SQLJ程序中的SQL语句的行号。如果多个SQL语句出现在同一行中，则它们的起始列位置用于区分它们。例如， <span class="italic"><code class="codeph">linenum</code></span>值8.13表示8是行号，13是列号。
                           </p>
                        </li>
                     </ul>
                     <p>以下传感器和相关指标通常特别重要：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>传感器名称： <code class="codeph">ContextType</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / ContextType</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">value</code> ：表示连接上下文类型的字符串</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">SQLString</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / SQLString</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">value</code> ：由SQL语句组成的字符串</p>
                                 <p>这是传递给JDBC的确切字符串，包括从原始<code class="codeph">#sql</code>语句进行的任何转换。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">Execute</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / Execute</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">time</code> ：此语句的JDBC <code class="codeph">execute()</code>方法的所有执行的总时间（以毫秒为单位<code class="codeph">execute()</code></p>
                                 <p>例如，如果语句执行五次，那么<code class="codeph">time</code>将是<code class="codeph">execute()</code>五次执行的<code class="codeph">execute()</code>方法所花费的总时间。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">completed</code> ：已<code class="codeph">completed</code>的执行次数（如5）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minTime</code> ：任何单次执行的最短时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxTime</code> ：任何单次执行的最长时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">avg</code> ：平均执行时间，即<code class="codeph">time</code>除以<code class="codeph">completed</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">active</code> ：程序执行结束时执行语句的线程数，通常为0。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxActive</code> ：程序执行期间执行语句的最大线程数</p>
                              </li>
                           </ul>
                           <p>要测量JDBC语句的执行时间，时钟将在语句执行之前立即启动，并在获取结果集或语句完成执行时或捕获异常时停止。</p>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">ServerExecute</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / ServerExecute</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">value</code> ：此SQL语句的所有执行的服务器中的总执行时间（以毫秒为单位）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code> ：已完成的执行次数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code> ：任何单次执行的最短时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code> ：任何单次执行的最长时间</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">ServerFetch</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / ServerFetch</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">value</code> ：此SQL语句的所有执行的服务器总提取时间（以毫秒为单位）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code> ：已完成的执行次数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code> ：任何单次执行的最短时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code> ：任何单次执行的最长时间</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">ServerParse</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / ServerParse</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">value</code> ：对于此SQL语句的所有执行，在服务器中解析SQL语句所花费的总时间（以毫秒为单位）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">count</code> ：已完成的执行次数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minValue</code> ：任何单次执行的最短时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxValue</code> ：任何单次执行的最长时间</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>传感器名称： <code class="codeph">Next</code></p><pre class="oac_no_warn" dir="ltr">/ SQLJ / <span class="italic">application_name</span> / <span class="italic">module</span> / <span class="italic">class</span> / <span class="italic">linenum</span> / Next</pre><p>指标：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">time</code> ：此SQL语句的所有执行的结果集迭代器的<code class="codeph">next()</code>方法花费的总时间（以毫秒为单位<code class="codeph">next()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">completed</code> ：已<code class="codeph">completed</code>的执行次数（如5）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minTime</code> ：任何单次执行的最短时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxTime</code> ：任何单次执行的最长时间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">avg</code> ：平均执行时间，即<code class="codeph">time</code>除以<code class="codeph">count</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">active</code> ：程序执行结束时执行语句的线程数，通常为0。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxActive</code> ：程序执行期间执行语句的最大线程数</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ781"></a><a id="JSQLJ782"></a><a id="JSQLJ783"></a><a id="JSQLJ784"></a><a id="JSQLJ780"></a><div class="props_rev_3"><a id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2" name="GUID-AB176F74-4B1D-478E-A896-99FB750805F2"></a><h4 id="JSQLJ-GUID-AB176F74-4B1D-478E-A896-99FB750805F2" class="sect4">SQLJ DMS示例</h4>
                  <div>
                     <div class="section">
                        <p>以下是用于检测SQLJ程序<code class="codeph">ExprDemo.sqlj</code>的示例命令行（单个环绕行）：</p><pre class="oac_no_warn" dir="ltr">％sqlj -dir =。 -instrument = abc / app -components = all -user = HR -url = jdbc：oracle：oci：@ExprDemo.sqlj密码： <span class="italic">密码</span>
</pre><div class="infoboxnote" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-88E82C9D-46C6-4E2B-A977-742F2D148C9F">
                           <p class="notep1">注意：</p>
                           <p>确保<code class="codeph">dms.jar</code>位于类路径中。
                           </p>
                        </div>
                        <p>此命令导致生成以下文件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">./a/b/c/ExprDemo.java</code> （由于<code class="codeph">-dir</code>选项设置，因为包<code class="codeph">abc</code>在<code class="codeph">ExprDemo.sqlj</code>声明）</p>
                           </li>
                           <li>
                              <p><code class="codeph">./a/b/c/app.properties</code> （由于<code class="codeph">-instrument</code>选项设置）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-4433A73D-AF98-4C06-8259-5EF894333864">示例SQLJ DMS属性文件</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是<code class="codeph">app.properties</code>示例内容。这假定您在SQLJ创建文件后编辑了文件，因为这里的一些设置是非默认的。
                        </p><pre class="oac_no_warn" dir="ltr">sqlmonitor.components = all sqlmonitor.monitorcomp = all sqlmonitor.dms = true sqlmonitor.servertracing = true sqlmonitor.sysurl = jdbc：oracle：oci：@sqlmonitor.sysuser = HR sqlmonitor.syspassword = hr sqlmonitor.dumpfile = a / b / c /app.mtr</pre><div class="infoboxnote" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-5224214C-04D9-49FB-B7E1-1B1ABCCAC17D">
                           <p class="notep1">注意：</p>
                           <p>如果再次运行SQLJ转换器，则会覆盖<code class="codeph">app.properties</code> ，您将丢失所做的任何更改。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-F6F65F5E-A897-4EEF-BF8F-562B902F45D9">样本统计</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">sqlmonitor.dms=true</code>设置指定将监视统计信息传递给DMS。给定<code class="codeph">sqlmonitor.dumpfile</code>值，DMS工具在编译和运行程序时将统计信息写入<code class="codeph">./a/b/c/app.mtr</code>文件。
                        </p>
                        <p>要检查特定代码示例的统计信息，以下是<code class="codeph">ExprDemo.sqlj</code> ：</p><pre class="oac_no_warn" dir="ltr">#sql {DECLARE n NUMBER;的数字; BEGIN n：= 0; s：= 0;当n &lt;100 LOOP n：= n + 1; s：= s +：IN（indx ++）;结束循环; ：OUT总数：= s;结束; };</pre><p>以下是<code class="codeph">app.mtr</code>的一段统计信息，与前面的代码示例相关，并显示执行时间和服务器执行时间：</p><pre class="oac_no_warn" dir="ltr">SQLString.value：DECLARE n NUMBER;的数字; BEGIN n：= 0; s：= 0;当n &lt;100 LOOP n：= n + 1; s：= s +：1;结束循环; ：2：= s;结束;语句SQL字符串ServerExecute.maxValue：20.0 server_execute_time ServerExecute.minValue：20.0 server_execute_time ServerExecute.count：0 ops ServerExecute.value：20.0服务器执行时间ServerFetch.maxValue：0.0 server_fetch_time ServerFetch.minValue：0.0 server_fetch_time ServerFetch.count：0 ops ServerFetch.value ：0.0服务器获取时间ServerParse.maxValue：0.0 server_parse_time ServerParse.minValue：0.0 server_parse_time ServerParse.count：0 ops ServerParse.value：0.0服务器解析时间193.5 ContextType.value：class sqlj.runtime.ref。DefaultContext语句连接上下文Execute.maxActive：1个线程Execute.active：0个线程Execute.avg：37.0 msecs Execute.maxTime：37 msecs Execute.minTime：37 msecs Execute.completed：1 ops Execute.time:37 msecs</pre><p>这些统计信息表明JDBC客户端的总执行时间为37毫秒（在一次执行中），而服务器中的执行时间为20毫秒。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-8802F6C4-6A70-4BAF-BF5F-949C6C7E4662">迭代器的样本统计信息</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">ExprDemo.sqlj</code>还定义并执行迭代器类型<code class="codeph">Iter</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql public static iterator Iter（String ename）; ....I it iter; #sql iter = {select first_name from employees}; while（iter.next（））{System.out.println（iter.ename（））; }</pre><p>对于迭代器，DMS收集<code class="codeph">next()</code>操作的执行时间。以下是迭代器类型<code class="codeph">Iter</code> DMS结果示例：</p><pre class="oac_no_warn" dir="ltr">Iter Next.time：5毫秒</pre><p>这表明迭代<code class="codeph">Iter</code>实例时在<code class="codeph">next()</code>操作上花费的总时间是5毫秒。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AB176F74-4B1D-478E-A896-99FB750805F2__GUID-672B51D7-7549-4FFF-BEEA-8E9E80A655CC">连接上下文的样本统计信息</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>该<code class="codeph">#sql</code>陈述<code class="codeph">ExprDemo.sqlj</code>使用默认的连接上下文。对于整个程序中使用的<code class="codeph">DefaultContext</code>实例，DMS返回以下统计信息：</p><pre class="oac_no_warn" dir="ltr">class_sqlj.runtime.ref。DefaultContext StmtCacheSize.value：5语句高速缓存大小StmtsExecuted.count：7 ops StmtsCacheExecuted.count：7 ops</pre><p>这表明上下文的语句缓存大小为五个语句。总共执行了七个SQL语句。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>