<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>编写用户退出</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-dynamic-SQL.html" title="Previous" type="text/html"></link>
      <link rel="next" href="new-features.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-dynamic-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="new-features.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">编写用户退出</li>
            </ol>
            <a id="GUID-B7C64641-93A1-4F04-8DAA-03187A91300C" name="GUID-B7C64641-93A1-4F04-8DAA-03187A91300C"></a><a id="ZZPRE910"></a>
            
            <h2 id="ZZPRE-GUID-B7C64641-93A1-4F04-8DAA-03187A91300C" class="sect2"><span class="enumeration_chapter">11</span>编写用户退出</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章包含以下内容：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="writing-user-exits.html#GUID-840004FC-6F29-4046-961A-6155BD9F6927">什么是用户退出？</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-587366A7-08C6-47AE-B6D3-E05377581E24">为什么写用户退出？</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5">开发用户出口</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-CC5745DB-7907-449A-B9B7-412EE286231C">写一个用户退出</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-A952614C-B862-4B3C-A466-BC6B002A0899">呼叫用户退出</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-FFE01920-2950-4847-BE2E-0CD2B184A028">将参数传递给用户出口</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D">将值返回到表单</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-16350EA4-0AF0-4800-8852-A44BF707247E">一个例子</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9">关于预编译和编译用户出口</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55">关于使用GENXTB Utility</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C">关于将用户出口链接到SQL *表单</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E">SQL *表单用户退出指南</a></p>
                  </li>
                  <li>
                     <p><a href="writing-user-exits.html#GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178">执行工具声明</a></p>
                  </li>
               </ul>
               <p>本章重点介绍如何为SQL * Forms和Oracle Forms应用程序编写用户出口。首先，您将学习允许SQL * Forms应用程序与用户出口连接的EXEC IAF语句。然后，您将学习如何编写和链接SQL * Forms用户出口。您还将学习如何在Oracle Forms中使用EXEC TOOLS语句。（SQL * Forms不支持EXEC TOOLS。）这样，您可以使用EXEC IAF语句来增强现有应用程序和EXEC TOOLS语句以构建新应用程序。涵盖以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>用户出口的常见用途</p>
                  </li>
                  <li>
                     <p>编写用户出口</p>
                  </li>
                  <li>
                     <p>在SQL * Forms和用户出口之间传递值</p>
                  </li>
                  <li>
                     <p>实现用户出口</p>
                  </li>
                  <li>
                     <p>调用用户出口</p>
                  </li>
                  <li>
                     <p>SQL * Forms用户出口指南</p>
                  </li>
                  <li>
                     <p>在Oracle Forms中使用EXEC TOOLS语句</p>
                  </li>
               </ul>
               <p>本章是补充的。有关用户出口的更多信息，请参阅<span class="italic">SQL * Forms Designer的参考</span> ， <span class="italic">Oracle Forms参考手册，卷。 2</span> ，和您的系统特定的Oracle手册。
               </p>
            </div><a id="ZZPRE912"></a><a id="ZZPRE911"></a><div class="props_rev_3"><a id="GUID-840004FC-6F29-4046-961A-6155BD9F6927" name="GUID-840004FC-6F29-4046-961A-6155BD9F6927"></a><h3 id="ZZPRE-GUID-840004FC-6F29-4046-961A-6155BD9F6927" class="sect3"><span class="enumeration_section">11.1</span>什么是用户退出？
               </h3>
               <div>
                  <p><a id="d73980e141" class="indexterm-anchor"></a> <span class="italic">用户出口</span>是由您编写的主机语言子例程，由SQL * Forms调用以执行特殊用途处理。您可以在用户出口中嵌入SQL命令和PL / SQL块，然后像宿主程序一样预编译它。
                  </p>
                  <p>当由SQL * Forms触发器调用时，用户出口运行，然后将状态代码返回到SQL * Forms（请参阅<a href="writing-user-exits.html#GUID-840004FC-6F29-4046-961A-6155BD9F6927__CHDHCGFF">图11-1</a> ）。您的用户出口可以显示消息<a id="d73980e151" class="indexterm-anchor"></a> SQL * Forms状态行，获取和放置字段值，操作Oracle数据，执行高速计算和表查找 - 甚至登录到不同的数据库。
                  </p>
                  <div class="figure" id="GUID-840004FC-6F29-4046-961A-6155BD9F6927__CHDHCGFF">
                     <p class="titleinfigure">图11-1 SQL *表单</p><img src="img/image014.gif" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/image014.html"><br><a href="img_text/image014.html">“图11-1 SQL *表单”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ZZPRE913"></a><div class="props_rev_3"><a id="GUID-587366A7-08C6-47AE-B6D3-E05377581E24" name="GUID-587366A7-08C6-47AE-B6D3-E05377581E24"></a><h3 id="ZZPRE-GUID-587366A7-08C6-47AE-B6D3-E05377581E24" class="sect3"><span class="enumeration_section">11.2</span>为什么写用户退出？
               </h3>
               <div>
                  <p>SQL * Forms Version 3允许在触发器中使用PL / SQL块。因此，在大多数情况下，您可以使用PL / SQL的过程功能，而不是调用用户出口。如果需要，您可以使用<code class="codeph">USER_EXIT</code>函数从PL / SQL块调用用户出口。
                  </p>
                  <p>用户出口比SQL，PL / SQL或SQL * Forms命令更难编写和实现。因此，您可能只会将它们用于超出SQL，PL / SQL和SQL * Forms范围的处理。一些<a id="d73980e188" class="indexterm-anchor"></a>常见用途如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在C和FORTRAN等第三代语言中更快速或更轻松地执行操作（例如，数字集成）</p>
                     </li>
                     <li>
                        <p>控制实时设备或进程（例如，向打印机或图形设备发出一系列指令）</p>
                     </li>
                     <li>
                        <p>需要扩展过程功能的数据操作（例如，递归排序）</p>
                     </li>
                     <li>
                        <p>特殊文件I / O操作</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE914"></a><div class="props_rev_3"><a id="GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5" name="GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5"></a><h3 id="ZZPRE-GUID-DCCE0F0B-A049-4FAA-99FE-6B92B4AEBBB5" class="sect3"><span class="enumeration_section">11.3</span>开发用户出口</h3>
               <div>
                  <div class="section">
                     <p>本节概述了开发SQL * Forms用户出口的方法;后面的部分将详细介绍。有关Oracle Forms提供的EXEC TOOLS语句的信息，请参阅<a href="writing-user-exits.html#GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178">EXEC TOOLS语句</a> ''</p>
                     <p>要将用户出口合并到表单中，请执行以下步骤：</p>
                     <p>1。以支持的主机语言编写用户出口。</p>
                     <p>2。预编译源代码。</p>
                     <p>3。编译修改后的源代码。</p>
                     <p>4。使用GENXTB实用程序创建数据库表IAPXTB。</p>
                     <p>5。使用SQL * Forms中的GENXTB表单将用户出口信息插入数据库表。</p>
                     <p>6。使用GENXTB实用程序从表中读取信息并创建IAPXIT源模块。然后，编译源模块。</p>
                     <p>7。通过链接标准IAP对象模块，用户出口对象模块和在步骤6中创建的IAPXIT对象模块，创建新的IAP（运行表单的SQL * Forms组件）。</p>
                     <p>8。在表单中，定义一个触发器来调用用户出口。</p>
                     <p>9。指示操作员在运行表单时使用新的IAP。如果新IAP取代标准IAP，则不需要这样做。有关详细信息，请参阅特定于系统的Oracle手册。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE915"></a><div class="props_rev_3"><a id="GUID-CC5745DB-7907-449A-B9B7-412EE286231C" name="GUID-CC5745DB-7907-449A-B9B7-412EE286231C"></a><h3 id="ZZPRE-GUID-CC5745DB-7907-449A-B9B7-412EE286231C" class="sect3"><span class="enumeration_section">11.4</span>写入用户出口</h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e282" class="indexterm-anchor"></a>您可以使用以下类型的语句来编写SQL * Forms用户出口：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>主持人语</p>
                        </li>
                        <li>
                           <p>EXEC SQL</p>
                        </li>
                        <li>
                           <p>EXEC ORACLE</p>
                        </li>
                        <li>
                           <p>EXEC IAF GET</p>
                        </li>
                        <li>
                           <p>EXEC IAF PUT</p>
                        </li>
                     </ul>
                     <p>本节重点介绍EXEC IAF <code class="codeph">GET</code>和<code class="codeph">PUT</code>语句，它们允许您在SQL * Forms和用户出口之间传递值。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE916"></a><div class="props_rev_3"><a id="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C" name="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C"></a><h4 id="ZZPRE-GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C" class="sect4"><span class="enumeration_section">11.4.1</span>变量要求</h4>
                  <div>
                     <p><a id="d73980e339" class="indexterm-anchor"></a> EXEC IAF语句中使用的变量必须与表单定义中使用的字段名称相对应。如果由于未指定块名称而导致字段引用不明确，则会出现错误。对表单字段的无效或模糊引用会生成错误。
                     </p>
                     <p>主机变量必须在用户出口Declare Section中命名，并且必须在EXEC IAF语句中以冒号（:)为前缀。</p>
                     <div class="infoboxnote" id="GUID-8FFF40AA-170C-43E4-B7DC-55928B6BDE3C__GUID-D120B469-EAA8-4D64-8E1D-ED5026DF1334">
                        <p class="notep1">注意：</p>
                        <p>：指标变量<span class="italic">不是</span>在EXEC IAF允许<code class="codeph">GET</code>和<code class="codeph">PUT</code>语句。
                        </p>
                     </div>
                  </div>
               </div><a id="ZZPRE917"></a><div class="props_rev_3"><a id="GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5" name="GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5"></a><h4 id="ZZPRE-GUID-42CCA518-ECF5-4A7C-8C0E-791DB51772B5" class="sect4"><span class="enumeration_section">11.4.2</span> IAF GET声明</h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e386" class="indexterm-anchor"></a>此语句允许用户退出以从表单上的字段“获取”值并将其分配给主机变量。然后，用户出口可以使用计算，数据操作，更新等中的值。<code class="codeph">GET</code>语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">EXEC IAF GET field_name1，field_name2，...INTO：host_variable1，：host_variable2，...;</pre><p>其中<span class="italic">field_name</span>可以是以下任何SQL * Forms变量：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>领域</p>
                           </li>
                           <li>
                              <p>block.field中</p>
                           </li>
                           <li>
                              <p>系统变量</p>
                           </li>
                           <li>
                              <p>全局变量</p>
                           </li>
                           <li>
                              <p>主变量（以冒号为前缀），包含字段，块。字段，系统变量或全局变量的值</p>
                           </li>
                        </ul>
                        <p>如果<span class="italic">field_name</span>不合格，则它必须是唯一的。
                        </p>
                        <p><a id="d73980e423" class="indexterm-anchor"></a>以下示例显示用户如何退出GET字段值并将其分配给主机变量：</p><pre class="oac_no_warn" dir="ltr">EXEC IAF GET employee.job INTO：new_job;</pre><p>所有字段值都是字符串。如果可以， <code class="codeph">GET</code>将字段值转换为相应主机变量的数据类型。如果尝试进行非法或不受支持的数据类型转换，则会生成错误。
                        </p>
                        <p><a id="d73980e436" class="indexterm-anchor"></a>在最后一个示例中，常量用于指定<span class="italic">block.field</span> 。您还可以使用主机字符串指定块名称和字段名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">set blkfld ='employee.job'; EXEC IAF GET：blkfld INTO：new_job;</pre><p>除非该字段是唯一的，否则主机字符串必须包含具有中间周期的完整<span class="italic">block.field</span>引用。例如，以下用法<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">set blk ='employee'; set fld ='job'; EXEC IAF GET：blk。：fld INTO：new_job;</pre><p>您可以在<code class="codeph">GET</code>语句字段列表中混合使用显式和存储的字段名称，但不能在单个字段引用中混合使用。例如，以下用法<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">set fld ='job'; EXEC IAF GET employee.:fld INTO：new_job;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE918"></a><div class="props_rev_3"><a id="GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA" name="GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA"></a><h4 id="ZZPRE-GUID-872C1D9B-E2FA-493A-9186-10896ED68DCA" class="sect4"><span class="enumeration_section">11.4.3</span> IAF PUT声明</h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e490" class="indexterm-anchor"></a>此语句允许用户退出，将常量和主变量的值放入表单的字段中。因此，用户出口可以在SQL * Forms屏幕上显示您喜欢的任何值或消息。<code class="codeph">PUT</code>语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">EXEC IAF PUT field_name1，field_name2，...VALUES（：host_variable1，：host_variable2，...）;</pre><p>其中<span class="italic">field_name</span>可以是以下任何SQL * Forms变量：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>领域</p>
                           </li>
                           <li>
                              <p>block.field中</p>
                           </li>
                           <li>
                              <p>系统变量</p>
                           </li>
                           <li>
                              <p>全局变量</p>
                           </li>
                           <li>
                              <p>主变量（以冒号为前缀），包含字段，块。字段，系统变量或全局变量的值</p>
                           </li>
                        </ul>
                        <p><a id="d73980e522" class="indexterm-anchor"></a>以下示例显示用户如何将数值常量，字符串常量和主机变量的值PUT到表单上的字段中：</p><pre class="oac_no_warn" dir="ltr">EXEC IAF PUT employee.number，employee.name，employee.job VALUES（7934，'MILLER'，：new_job）;</pre><p><a id="d73980e530" class="indexterm-anchor"></a>与<code class="codeph">GET</code>一样， <code class="codeph">PUT</code>允许您使用主机字符串来指定块名和字段名，如下所示：</p><pre class="oac_no_warn" dir="ltr">set blkfld ='employee.job'; EXEC IAF PUT：blkfld VALUES（：new_job）;</pre><p>在字符模式终端上，如果字段在当前显示页面上，则在用户出口返回时显示字段值<code class="codeph">PUT</code> ，而不是在进行分配时显示。在块模式终端上，下次从设备读取字段时会显示该值。
                        </p>
                        <p>如果用户出口多次更改字段的值，则只有最后一次更改生效。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE919"></a><div class="props_rev_3"><a id="GUID-A952614C-B862-4B3C-A466-BC6B002A0899" name="GUID-A952614C-B862-4B3C-A466-BC6B002A0899"></a><h3 id="ZZPRE-GUID-A952614C-B862-4B3C-A466-BC6B002A0899" class="sect3"><span class="enumeration_section">11.5</span>呼叫用户退出</h3>
               <div>
                  <div class="section">
                     <p>使用名为<code class="codeph">USER_EXIT</code> （随SQL * Forms提供）的打包过程从SQL * Forms触发器调用用户出口。您使用的语法是</p><pre class="oac_no_warn" dir="ltr">USER_EXIT（user_exit_string [，error_string]）;</pre><p>其中<span class="italic">user_exit_string</span>包含用户出口的名称加上可选参数， <span class="italic">error_string</span>包含SQL * Forms在用户出口失败时发出的错误消息。例如，以下trigger命令调用名为<code class="codeph">LOOKUP</code>的用户出口：</p><pre class="oac_no_warn" dir="ltr">USER_EXIT（ 'LOOKUP'）;</pre><p>请注意，用户出口字符串由单引号（非双引号）括起来。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE920"></a><div class="props_rev_3"><a id="GUID-FFE01920-2950-4847-BE2E-0CD2B184A028" name="GUID-FFE01920-2950-4847-BE2E-0CD2B184A028"></a><h3 id="ZZPRE-GUID-FFE01920-2950-4847-BE2E-0CD2B184A028" class="sect3"><span class="enumeration_section">11.6将</span>参数传递给用户出口</h3>
               <div>
                  <div class="section">
                     <p>当您调用用户出口时，SQL * Forms会自动向其传递以下参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>命令行是用户出口字符串。</p>
                        </li>
                        <li>
                           <p>命令行长度是用户出口字符串的长度（以字符为单位）。</p>
                        </li>
                        <li>
                           <p>如果定义了错误消息，则错误消息是错误字符串（失败消息）。</p>
                        </li>
                        <li>
                           <p>错误消息长度是错误字符串的长度。</p>
                        </li>
                        <li>
                           <p>In-Query是一个布尔值，指示退出是在正常模式还是查询模式下调用。</p>
                        </li>
                     </ul>
                     <p>但是，用户出口字符串允许将其他参数传递给用户出口。例如，以下触发器命令将两个参数和一条错误消息传递给用户出口<code class="codeph">LOOKUP</code> ：</p><pre class="oac_no_warn" dir="ltr">USER_EXIT（'LOOKUP 2025 A'，'Lookup failed'）;</pre><p>您可以使用此功能将字段名称传递给用户出口，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">USER_EXIT（'CONCAT firstname，lastname，address'）;</pre><p>但是，由用户出口而不是SQL * Forms来解析用户出口字符串。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE921"></a><div class="props_rev_3"><a id="GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D" name="GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D"></a><h3 id="ZZPRE-GUID-ADA39C73-2CB9-40A7-BB8B-352CD2BB9E6D" class="sect3"><span class="enumeration_section">11.7</span>将值返回到表单</h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e686" class="indexterm-anchor"></a>当用户出口将控制权返回给SQL * Forms时，它还必须返回一个代码，指示它是成功，失败还是遭受了无法恢复的错误。返回码是一个整数<a id="d73980e691" class="indexterm-anchor"></a>由预编译器生成的常量（参见本节： <a href="writing-user-exits.html#GUID-16350EA4-0AF0-4800-8852-A44BF707247E">示例</a> ）。这三个结果具有以下含义：</p>
                     <p>成功：用户出口没有遇到任何错误。SQL * Forms继续执行<span class="italic">成功</span>标签或下一步，除非<a id="d73980e703" class="indexterm-anchor"></a>反向返回代码开关由调用触发器步骤设置。
                     </p>
                     <p>失败：用户出口检测到错误，例如字段中的值无效。退出处传递的可选消息显示在底部的消息行上<a id="d73980e710" class="indexterm-anchor"></a> SQL * Forms屏幕和显示错误屏幕。SQL * Forms会像对不影响任何行的SQL语句一样响应。
                     </p>
                     <p>致命错误：用户出口检测到无法进一步处理的情况，例如SQL语句中的执行错误。退出传递的可选错误消息显示在SQL *窗体显示错误屏幕上。SQL * Forms会对不可恢复的SQL错误做出响应。</p>
                     <p>如果用户退出改变字段的值，然后返回一个<span class="italic">失败</span>或<span class="italic">致命错误</span>代码，SQL *窗体<span class="italic">不</span>放弃改变。当设置了反向返回代码开关并返回<span class="italic">成功</span>代码时，SQL * Forms也不会丢弃更改。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE922"></a><div class="props_rev_3"><a id="GUID-F68AC490-6AE3-43FD-977B-865FC3B93169" name="GUID-F68AC490-6AE3-43FD-977B-865FC3B93169"></a><h4 id="ZZPRE-GUID-F68AC490-6AE3-43FD-977B-865FC3B93169" class="sect4"><span class="enumeration_section">11.7.1</span> IAP常量</h4>
                  <div>
                     <p>预编译器生成三个符号常量以用作返回码。它们以IAP为前缀。例如，三个常量可能是IAPSUCC，IAPFAIL和IAPFTL。</p>
                  </div>
               </div><a id="ZZPRE923"></a><div class="props_rev_3"><a id="GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E" name="GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E"></a><h4 id="ZZPRE-GUID-4D68A8C8-3B7F-4028-A7F2-A8D5A0ED1C3E" class="sect4"><span class="enumeration_section">11.7.2</span>使用SQLIEM函数</h4>
                  <div>
                     <div class="section">
                        <p>通过调用函数SQLIEM，您的用户出口可以指定一条错误消息，如果触发步骤失败，SQL * Forms将在消息行上显示，或者如果该步骤导致不可恢复的错误，则在显示错误屏幕上。指定的消息将替换为该步骤定义的任何消息。</p>
                        <p>SQLIEM函数调用的语法是</p><pre class="oac_no_warn" dir="ltr">SQLIEM（error_message，message_length）;</pre><p>其中<span class="italic">error_message</span>和<span class="italic">message_length</span>分别是字符和整数变量。Oracle预编译器为您生成适当的外部函数声明。您通过引用传递两个参数;也就是说，你传递他们的地址，而不是他们的价值。SQLIEM是一个SQL * Forms函数;它无法从其他Oracle工具调用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE924"></a><div class="props_rev_3"><a id="GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3" name="GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3"></a><h4 id="ZZPRE-GUID-93468FAF-919A-4AB4-BB0F-B7A9370EBDE3" class="sect4"><span class="enumeration_section">11.7.3</span>使用WHENEVER</h4>
                  <div>
                     <div class="section">
                        <p>您可以在出口中使用<code class="codeph">WHENEVER</code>语句来检测无效的数据类型转换（SQLERROR），将截断的值<code class="codeph">PUT</code>到表单字段（SQLWARNING），以及不返回任何行的查询（ <code class="codeph">NOT</code> <code class="codeph">FOUND</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE925"></a><div class="props_rev_3"><a id="GUID-16350EA4-0AF0-4800-8852-A44BF707247E" name="GUID-16350EA4-0AF0-4800-8852-A44BF707247E"></a><h3 id="ZZPRE-GUID-16350EA4-0AF0-4800-8852-A44BF707247E" class="sect3"><span class="enumeration_section">11.8</span>一个例子</h3>
               <div>
                  <p>以下示例显示了典型用户出口的编码方式。请注意，与宿主程序一样，用户出口具有Declare Section和SQLCA。</p><pre class="oac_no_warn" dir="ltr">- 子程序MYEXIT EXEC SQL BEGIN DECLARE SECTION; field1 CHARACTER（20）; field2 CHARACTER（20）; value1 CHARACTER（20）; value2 CHARACTER（20）; result_val CHARACTER（20）; EXEC SQL END DECLARE SECTION; errmsg CHARACTER（80）; errlen INTEGER; EXEC SQL包含SQLCA;执行SQL WHENEVER SQLERROR GOTO sqlerror; - 从表格EXEC获取字段值IAF GET：field1，：field2 INTO：value1，：value2; - 操作值以获取result_val  - 将result_val放入表单字段EXEC IAF PUT结果VALUES（：result_val）;返回（IAPSUCC）; - 触发步骤成功sqlerror：set errmsg = CONCAT（'MYEXIT：'，sqlca.sqlerrm.sqlerrmc）; set errlen = LENGTH（errmsg）; sqliem（errmsg，errlen）; - 将错误消息传递给SQL * Forms return（IAPFAIL）; - 触发步骤失败</pre><p>有关完整的主机语言示例，请参阅主机 - 语言补充。</p>
               </div>
            </div><a id="ZZPRE926"></a><div class="props_rev_3"><a id="GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9" name="GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9"></a><h3 id="ZZPRE-GUID-DB27D538-05BE-4259-873A-E09C26E1B3F9" class="sect3"><span class="enumeration_section">11.9</span>关于预编译和编译用户出口</h3>
               <div>
                  <p>用户出口预编译为独立主机程序。请参阅<a href="running-Oracle-precompilers.html#GUID-203DF8C5-3073-4914-8B92-9F81AF09CB92">运行Oracle预编译器</a></p>
                  <p>有关编译用户出口的说明，请参阅特定于系统的Oracle手册。</p>
               </div>
            </div><a id="ZZPRE927"></a><div class="props_rev_3"><a id="GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55" name="GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55"></a><h3 id="ZZPRE-GUID-742A360D-C91F-4C91-A7D2-8A7EDDBCBD55" class="sect3"><span class="enumeration_section">11.10</span>关于使用GENXTB Utility</h3>
               <div>
                  <p><a id="d73980e929" class="indexterm-anchor"></a>模块IAPXIT中的IAP程序表IAPXTB包含链接到IAP的每个用户出口的条目。 IAPXTB告诉IAP每个用户出口的名称，位置和主机语言。向IAP添加新用户出口时，必须向IAPXTB添加相应的条目。</p>
                  <p>IAPXTB派生自数据库表，也称为IAPXTB。您可以通过在操作系统命令行上运行GENXTB表单来修改数据库表，如下所示：</p><pre class="oac_no_warn" dir="ltr">RUNFORM GENXTB用户名/密码</pre><p>将显示一个表单，使您可以为您定义的每个用户出口输入以下信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>退出名称</p>
                     </li>
                     <li>
                        <p>主机语言代码（ <code class="codeph">COB</code> ， <code class="codeph">FOR</code> ， <code class="codeph">PAS</code>或<code class="codeph">PLI</code> ）</p>
                     </li>
                     <li>
                        <p>创建日期</p>
                     </li>
                     <li>
                        <p>日期最后修改</p>
                     </li>
                     <li>
                        <p>评论</p>
                     </li>
                  </ul>
                  <p>修改IAPXTB数据库表后，使用GENXTB实用程序读取表并创建Assembler或C源程序，该程序定义它包含的模块IAPXIT和IAPXTB程序表。使用的源语言取决于您的操作系统。用于运行GENXTB实用程序的语法是</p><pre class="oac_no_warn" dir="ltr">GENXTB用户名/密码输出文件</pre><p>其中<span class="italic">outfile</span>是您为GENXTB创建的汇编程序或源程序提供的名称。
                  </p>
               </div>
            </div><a id="ZZPRE928"></a><div class="props_rev_3"><a id="GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C" name="GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C"></a><h3 id="ZZPRE-GUID-FD1CA0F6-27E7-49DD-AD82-432FF5E7E04C" class="sect3"><span class="enumeration_section">11.11</span>关于将用户出口链接到SQL *表单</h3>
               <div>
                  <p>在运行调用用户出口的表单之前，必须将用户出口链接到IAP。用户出口可以链接到标准版本的IAP，也可以链接到调用出口的表单的特殊版本。</p>
                  <p>生成新的可执行副本<a id="d73980e1005" class="indexterm-anchor"></a> IAP，链接您的用户出口对象模块，标准IAP模块，IAPXIT模块以及Oracle和主机语言链接库所需的任何模块。链接的详细信息取决于系统，因此请查看特定于系统的Oracle手册。
                  </p>
               </div>
            </div><a id="ZZPRE929"></a><div class="props_rev_3"><a id="GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E" name="GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E"></a><h3 id="ZZPRE-GUID-B6B6DAB2-818C-4EB7-93F6-7D21EFB0297E" class="sect3"><span class="enumeration_section">11.12</span> SQL *表单用户退出指南</h3>
               <div>
                  <p><a id="d73980e1036" class="indexterm-anchor"></a>本节中的指南将帮助您避免一些常见的陷阱。
                  </p>
               </div><a id="ZZPRE930"></a><div class="props_rev_3"><a id="GUID-96F68A68-8094-4E66-9299-745EEA516478" name="GUID-96F68A68-8094-4E66-9299-745EEA516478"></a><h4 id="ZZPRE-GUID-96F68A68-8094-4E66-9299-745EEA516478" class="sect4"><span class="enumeration_section">11.12.1</span>命名退出</h4>
                  <div>
                     <p><a id="d73980e1068" class="indexterm-anchor"></a>用户出口的名称不能是Oracle保留字。还要避免使用与SQL * Forms命令，函数代码和SQL * Forms使用的外部定义名称冲突的名称。
                     </p>
                     <p>在搜索出口之前，SQL * Forms将用户出口的名称转换为大写。因此，如果您的宿主语言区分大小写，则退出名称必须在源代码中为大写。</p>
                     <p>源代码中的用户出口入口点的名称将成为用户出口本身的名称。退出名称必须是主机语言和操作系统的有效文件名。</p>
                  </div>
               </div><a id="ZZPRE931"></a><div class="props_rev_3"><a id="GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028" name="GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028"></a><h4 id="ZZPRE-GUID-5D6B3CB0-C737-4FB0-8FA1-114454D0C028" class="sect4"><span class="enumeration_section">11.12.2</span>连接到Oracle</h4>
                  <div>
                     <p>用户出口通过SQL * Forms的连接与Oracle进行通信。但是，用户出口可以通过SQL * Net与任何数据库建立其他连接。有关更多信息，请参阅“ <a href="meeting-program-requirements.html#GUID-288DC379-A0FE-404F-971A-4919D35325DD">并发登录</a> ”。
                     </p>
                  </div>
               </div><a id="ZZPRE932"></a><div class="props_rev_3"><a id="GUID-BA84171D-01BF-4B54-8732-B704AF20D57C" name="GUID-BA84171D-01BF-4B54-8732-B704AF20D57C"></a><h4 id="ZZPRE-GUID-BA84171D-01BF-4B54-8732-B704AF20D57C" class="sect4"><span class="enumeration_section">11.12.3</span>发出I / O呼叫</h4>
                  <div>
                     <p>SQL * Forms I / O例程可能与主机语言打印机I / O例程冲突。如果他们这样做，您的用户出口将无法发出打印机I / O调用。支持文件I / O但不支持屏幕I / O.</p>
                  </div>
               </div><a id="ZZPRE933"></a><div class="props_rev_3"><a id="GUID-E0E1427C-A353-43AB-B376-A1034572C396" name="GUID-E0E1427C-A353-43AB-B376-A1034572C396"></a><h4 id="ZZPRE-GUID-E0E1427C-A353-43AB-B376-A1034572C396" class="sect4"><span class="enumeration_section">11.12.4</span>使用主机变量</h4>
                  <div>
                     <p>在独立程序中使用主机变量的限制也适用于用户出口。主机变量必须在用户出口Declare Section中命名，并且必须在EXEC SQL和EXEC IAF语句中以冒号为前缀。但是，EXEC IAF语句中不允许使用主机阵列。</p>
                  </div>
               </div><a id="ZZPRE934"></a><div class="props_rev_3"><a id="GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241" name="GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241"></a><h4 id="ZZPRE-GUID-3538AF83-8250-44D1-9E96-C3B4A80DA241" class="sect4"><span class="enumeration_section">11.12.5</span>更新表</h4>
                  <div>
                     <p>通常，用户出口不应该<code class="codeph">UPDATE</code>与表单关联的数据库表。例如，假设操作员更新SQL * Forms工作空间中的记录，然后用户退出<code class="codeph">UPDATEs</code>相关数据库表中的相应行。当事务是<code class="codeph">COMMITted</code> ，SQL * Forms工作空间中的记录将应用于表，覆盖用户出口<code class="codeph">UPDATE</code> 。</p>
                  </div>
               </div><a id="ZZPRE935"></a><div class="props_rev_3"><a id="GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776" name="GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776"></a><h4 id="ZZPRE-GUID-F47A6B88-3AC9-49AD-BB57-1623621F3776" class="sect4"><span class="enumeration_section">11.12.6</span>发布命令</h4>
                  <div>
                     <p>避免从用户出口发出<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>命令，因为Oracle将提交或回滚SQL * Forms运算符开始的工作，而不仅仅是用户出口完成的工作。而是从SQL * Forms触发器发出<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> 。这也适用于数据定义命令（例如<code class="codeph">ALTER</code> <code class="codeph">and CREATE</code> ），因为它们在执行之前和之后发出隐式<code class="codeph">COMMIT</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE936"></a><div class="props_rev_3"><a id="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178" name="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178"></a><h3 id="ZZPRE-GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178" class="sect3"><span class="enumeration_section">11.13</span> EXEC工具声明</h3>
               <div>
                  <div class="section">
                     <p><a id="d73980e1257" class="indexterm-anchor"></a> EXEC <code class="codeph">TOOLS</code>语句支持基本<a id="d73980e1265" class="indexterm-anchor"></a> Oracle Toolset（ <a id="d73980e1268" class="indexterm-anchor"></a> Oracle Forms，Oracle Reports和Oracle Graphics）提供了一种处理来自用户出口的get，set和exception回调的通用方法。以下讨论侧重于Oracle Forms，但相同的概念适用于Oracle Reports和Oracle Graphics。
                     </p>
                     <p>除了EXEC SQL，EXEC ORACLE和宿主语言语句之外，您还可以使用以下EXEC TOOLS语句编写Oracle Forms用户出口：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">组</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">得到</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">设置背景</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">获取上下文</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">信息</code></p>
                        </li>
                     </ul>
                     <p>EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code>和<code class="codeph">SET</code>语句替换了与SQL * Forms一起使用的EXEC IAF <code class="codeph">GET</code>和<code class="codeph">PUT</code>语句。与IAF GET和<code class="codeph">PUT</code> ， <code class="codeph">TOOLS</code> <code class="codeph">GET</code>和<code class="codeph">SET</code> <a id="d73980e1324" class="indexterm-anchor"></a>接受指标变量。EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code>语句取代了消息处理函数SQLIEM。 EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> <code class="codeph">CONTEXT</code>和<code class="codeph">GET</code> <code class="codeph">CONTEXT</code>语句是新的，不适用于SQL * Forms，Version 3。
                     </p>
                     <div class="infoboxnote" id="GUID-B44C8B08-C0A8-4656-8B66-D84DB3016178__GUID-BBADC839-B133-478D-9F3A-C106D3FE48DC">
                        <p class="notep1">注意：</p>
                        <p>COBOL和FORTRAN没有指针数据类型，因此您无法在Pro * COBOL或Pro * FORTRAN程序中使用<code class="codeph">SET</code> <code class="codeph">CONTEXT</code>和<code class="codeph">GET</code> <code class="codeph">CONTEXT</code>语句。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ZZPRE937"></a><div class="props_rev_3"><a id="GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB" name="GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB"></a><h4 id="ZZPRE-GUID-F184D9FE-3D1C-42F0-BB1A-0DFB9C0D45AB" class="sect4"><span class="enumeration_section">11.13.1</span> EXEC工具集</h4>
                  <div>
                     <div class="section">
                        <p><a id="d73980e1394" class="indexterm-anchor"></a> EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code>语句将值从用户出口传递到Oracle Forms。具体来说，它将主变量和常量的值分配给Oracle Forms变量和项。用户出口将控件返回到窗体后显示值。
                        </p>
                        <p>要编写EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code>语句，请使用语法</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS SET form_variable [，...]VALUES（{：host_variable [：indicator] | constant} [，...]）;</pre><p>其中<span class="italic">form_variable</span>是Oracle Forms字段，参数，系统变量或全局变量，或者包含上述项之一的名称的主机变量（以冒号为前缀）。
                        </p>
                        <p>在以下Pro * C示例中，您的用户出口将员工姓名（带有可选指示符）传递给Oracle Forms：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...char ename [20];简短的ename_ind; EXEC SQL END DECLARE SECTION; ...strcpy（ename，“MILLER”）; ename_ind = 0; EXEC TOOLS SET emp.ename VALUES（：ename：ename_ind）;</pre><p>在此示例中， <span class="italic">emp.ename</span>是Oracle Forms block.field。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE938"></a><div class="props_rev_3"><a id="GUID-65EFD031-F206-49D0-B70C-581B899C801A" name="GUID-65EFD031-F206-49D0-B70C-581B899C801A"></a><h4 id="ZZPRE-GUID-65EFD031-F206-49D0-B70C-581B899C801A" class="sect4"><span class="enumeration_section">11.13.2</span>执行工具获取</h4>
                  <div>
                     <div class="section">
                        <p>EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code>语句将值从Oracle Forms传递到用户出口。具体来说，它将Oracle Forms变量和项的值分配给主变量。一旦传递了值，用户出口就可以将它们用于任何目的。
                        </p>
                        <p>要编写EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code>语句的代码，请使用语法</p><pre class="oac_no_warn" dir="ltr">执行工具获取form_variable [，...]INTO：host_variable [：指标] [，...];</pre><p>其中<span class="italic">form_variable</span>是Oracle Forms字段，参数，系统变量或全局变量，或包含上述项之一的名称的主机变量。
                        </p>
                        <p>在以下示例中，Oracle Forms将block.field <span class="italic">emp.ename中</span>的员工姓名<span class="italic">传递</span>给您的用户出口：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...char ename [20]; EXEC SQL END DECLARE SECTION; ...EXEC TOOLS GET emp.ename INTO：ename;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE939"></a><div class="props_rev_3"><a id="GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB" name="GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB"></a><h4 id="ZZPRE-GUID-D2E32A14-29DF-42E0-9FCE-E2ACBD1637DB" class="sect4"><span class="enumeration_section">11.13.3</span> EXEC工具设置上下文</h4>
                  <div>
                     <div class="section">
                        <p>EXEC <code class="codeph">TOOLS</code> <code class="codeph">SE</code> T <code class="codeph">CONTEXT</code>语句允许您将一个用户出口呼叫的上下文信息保存到另一个用户出口呼叫。<code class="codeph">SET</code> <code class="codeph">CONTEXT</code>命名一个主机语言指针变量，稍后您可以在EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code>语句中引用该变量。指针变量指向存储上下文信息的存储器块。使用<code class="codeph">SET</code> <code class="codeph">CONTEXT</code>语句，您无需声明全局变量来保存信息。
                        </p>
                        <p>要编写EXEC <code class="codeph">TOOLS</code> <code class="codeph">SET</code> <code class="codeph">CONTEXT</code>语句，请使用语法</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS SET语境：host_pointer_variable [IDENTIFIED] BY context_name;</pre><p>其中可选关键字IDENTIFIED可用于提高可读性， <span class="italic">context_name</span>是未声明的标识符或命名上下文区域的字符主机变量。
                        </p>
                        <p>在以下示例中，您的用户出口保存上下文信息以供以后使用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...char context1 [30]; EXEC SQL END DECLARE SECTION; ...strcpy（context1，“这是context1”）; EXEC TOOLS SET语境：context1 BY my_app1;</pre><p>在此示例中，上下文名称<span class="italic">my_app1</span>是未声明的标识符。请注意，在C中，当char数组用作参数时，数组名称与指向该数组的指针同义。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE940"></a><div class="props_rev_3"><a id="GUID-D12653C0-F09A-48A6-AE47-128850AACD85" name="GUID-D12653C0-F09A-48A6-AE47-128850AACD85"></a><h4 id="ZZPRE-GUID-D12653C0-F09A-48A6-AE47-128850AACD85" class="sect4"><span class="enumeration_section">11.13.4</span>执行工具获取背景</h4>
                  <div>
                     <div class="section">
                        <p>EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code>语句将主机语言指针变量的值检索到用户出口。指针变量指向存储上下文信息的存储器块。
                        </p>
                        <p>要编写EXEC <code class="codeph">TOOLS</code> <code class="codeph">GET</code> <code class="codeph">CONTEXT</code>语句，请使用语法</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS获取语境context_name INTO：host_pointer_variable;</pre><p>其中<span class="italic">context_name</span>是未声明的标识符或用于命名上下文区域的字符主机变量。
                        </p>
                        <p>在下面的Pro * C示例中，您的用户出口检索指向前面保存的上下文信息的指针：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...char * ctx_ptr; EXEC SQL END DECLARE SECTION; ...EXEC TOOLS获取上下文my_app1 INTO：ctx_ptr;</pre><p>在此示例中，上下文名称<span class="italic">my_app1</span>是未声明的标识符。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE941"></a><div class="props_rev_3"><a id="GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3" name="GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3"></a><h4 id="ZZPRE-GUID-4C436F12-D2C3-4800-A8E7-8E65686862C3" class="sect4"><span class="enumeration_section">11.13.5</span>执行工具消息</h4>
                  <div>
                     <div class="section">
                        <p>EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code>语句将消息从用户出口传递到Oracle Forms。在用户出口将控制权返回给表单后，该消息将显示在Oracle Forms消息行上。
                        </p>
                        <p>要编写EXEC <code class="codeph">TOOLS</code> <code class="codeph">MESSAGE</code>语句，请使用语法</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS MESSAGE message_text [severity_code];</pre><p>其中<span class="italic">message_text</span>是带引号的字符串或字符主机变量，可选的<span class="italic">severity_code</span>是整数常量或主机变量。该<code class="codeph">MESSAGE</code>语句<span class="italic">不</span>接受指示变量。
                        </p>
                        <p>在以下Pro * C示例中，您的用户出口将错误消息和严重性代码传递给Oracle Forms：</p><pre class="oac_no_warn" dir="ltr">EXEC TOOLS MESSAGE'糟糕的字段名称！请重新输入。'15;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>