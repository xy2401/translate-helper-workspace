<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The in-memory analyst feature of Oracle Spatial and Graph supports a set of analytical functions."></meta>
      <meta name="description" content="The in-memory analyst feature of Oracle Spatial and Graph supports a set of analytical functions."></meta>
      <title>使用内存分析器（PGX）</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Property Graph Developer’s Guide"></meta>
      <meta property="og:description" content="The in-memory analyst feature of Oracle Spatial and Graph supports a set of analytical functions."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Property Graph Developer’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T15:23:57-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94800-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-property-graphs-oracle-database.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sql-based-property-graph-query-analytics.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="SPGDG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-property-graphs-oracle-database.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sql-based-property-graph-query-analytics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用内存分析器（PGX）</li>
            </ol>
            <a id="GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" name="GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C"></a><a id="BDSPA264"></a>
            
            <h2 id="SPGDG-GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" class="sect2"><span class="enumeration_chapter">3</span>使用内存分析器（PGX）</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Spatial and Graph的内存分析器功能支持一组分析功能。</p>
               <p>本章提供了使用内存分析器的示例（也称为Property Graph In-Memory Analytics，在Javadoc中通常缩写为PGX，命令行，路径描述，错误消息和示例）。它包含以下主要主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-254F911A-2750-4CF7-A895-E0B9E027B18C">将图形读入内存</a><br>本主题提供了使用shell接口以交互方式将图形读入内存的示例。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF">读取自定义图形数据</a><br>您可以阅读自己的自定义图表数据。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7">在磁盘上存储图形数据</a><br>使用Java或Shell将图形读入内存后，可以将其以不同的格式存储在磁盘上。然后，您可以在以后使用存储的图形数据作为内存分析器的输入。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4">执行内置算法</a><br>内存分析器包含一组可用作Java API的内置算法。</li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361">创建子图</a><br>您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C">使用自动增量刷新处理数据库更改</a><br>您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-1732BD3C-F120-449B-9FED-90E638A6097A">部署到Apache Tomcat</a><br>您可以将内存分析程序部署到Apache Tomcat或Oracle WebLogic。此示例显示如何使用Apache Tomcat将In-Memory Analytics部署为Web应用程序。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9">部署到Oracle WebLogic Server</a><br>您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5">连接到内存分析服务器</a><br>在运行Oracle数据库的计算机中安装属性图内存分析程序之后 - 或者在没有Oracle数据库服务器软件作为Apache Tomcat或Oracle WebLogic Server上的Web应用程序的客户机系统上安装 - 您可以连接到内存分析程序服务器。
                  </li>
                  <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-3AB6A64B-7E50-493F-A896-6812243D7841">管理属性图快照</a><br>Oracle Spatial and Graph Property Graph允许您管理属性图快照。
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" name="GUID-254F911A-2750-4CF7-A895-E0B9E027B18C"></a><h3 id="SPGDG-GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" class="sect3"><span class="enumeration_section">3.1</span>将图形读入内存</h3>
               <div>
                  <p>本主题提供了使用shell接口以交互方式将图形读入内存的示例。</p>
                  <p>这些是主要步骤：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-9660AEF0-DD32-4882-87BE-749C0C7FE102">连接到内存分析服务器实例</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-7E6E3198-28DC-484E-9AE1-0339799AD4B7">使用Shell帮助</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">在配置文件中提供图元数据</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">将图形数据读入内存</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-9660AEF0-DD32-4882-87BE-749C0C7FE102" name="GUID-9660AEF0-DD32-4882-87BE-749C0C7FE102"></a><h4 id="SPGDG-GUID-9660AEF0-DD32-4882-87BE-749C0C7FE102" class="sect4"><span class="enumeration_section">3.1.1</span>连接到内存分析服务器实例</h4>
                  <div>
                     <div class="section">
                        <p>要启动内存分析器shell：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在安装了属性图支持的系统上打开终端会话。</span></li>
                        <li class="stepexpand"><span>启动本地（嵌入式）内存分析器实例或连接到远程内存分析器实例</span><ul>
                              <li>启动本地（嵌入）实例的Java示例：<pre class="pre codeblock"><code>import java.util。地图; import java.util。HashMap的; import oracle.pgx.api。*; import oracle.pgx.config。PgxConfig。领域; String url = Pgx。EMBEDDED_URL; //本地JVM ServerInstance实例= Pgx.getInstance（url）; instance.startEngine（）; //将使用默认配置PgxSession session = instance.createSession（“test”）;</code></pre></li>
                              <li>连接到远程实例的Java示例：<pre class="pre codeblock"><code>import java.util。地图; import java.util。HashMap的; import oracle.pgx.api。*; import oracle.pgx.config。PgxConfig。领域; String url =“http://my-server.com:8080/pgx”//替换为您的设置ServerInstance实例的基本URL = Pgx.getInstance（url）; PgxSession session = instance.createSession（“test”）;</code></pre></li>
                           </ul>
                        </li>
                        <li class="stepexpand"><span>在shell中，输入以下命令，但只选择其中一个命令来启动或连接到所需的实例类型：</span><div><pre class="pre codeblock"><code>export PGX_HOME = $ ORACLE_HOME / md / property_graph / pgx cd $ PGX_HOME ./bin/pgx --help ./bin/pgx --version #start embedded shell ./bin/pgx#start remote shell ./bin/pgx- base_url http://my-server.com:8080/pgx</code></pre><p>对于嵌入式shell，输出应类似于以下内容：</p><pre class="pre codeblock"><code>10：43：46,666 [main] INFO Ctrl $ 2  -  &gt;&gt;&gt; PGX引擎正在运行。PGX&gt;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>（可选）显示预定义变量：</span><div><pre class="pre codeblock"><code>pgx&gt; instance ==&gt; PGX服务器实例在嵌入式模式下运行pgx&gt; session ==&gt; PGX会话pgxShell在PGX服务器上注册实例在嵌入式模式下运行pgx&gt;分析师==&gt;分析师用于PGX会话pgxShell在PGX服务器上注册实例在嵌入式模式下运行模式pgx&gt;</code></pre><p>其他一些主题中的示例假定实例和会话变量已设置如此处所示。</p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>如果内存分析软件安装正确，您将看到引擎运行日志消息和内存<code class="codeph">pgx&gt;</code> shell提示符（ <code class="codeph">pgx&gt;</code> ）：</p>
                        <p>变量<code class="codeph">instance</code> ， <code class="codeph">session</code>和<code class="codeph">analyst</code>随时可以使用。
                        </p>
                        <p>在本主题的前面示例中，shell启动了本地实例，因为<code class="codeph">pgx</code>命令未指定远程URL。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" title="本主题提供了使用shell接口以交互方式将图形读入内存的示例。">将图形读入内存</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-7E6E3198-28DC-484E-9AE1-0339799AD4B7" name="GUID-7E6E3198-28DC-484E-9AE1-0339799AD4B7"></a><h4 id="SPGDG-GUID-7E6E3198-28DC-484E-9AE1-0339799AD4B7" class="sect4"><span class="enumeration_section">3.1.2</span>使用Shell帮助</h4>
                  <div>
                     <p>内存分析器shell提供了一个帮助系统，您可以使用<code class="codeph">:help</code>命令访问该系统。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" title="本主题提供了使用shell接口以交互方式将图形读入内存的示例。">将图形读入内存</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D" name="GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D"></a><h4 id="SPGDG-GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D" class="sect4"><span class="enumeration_section">3.1.3</span>在配置文件中提供图元数据</h4>
                  <div>
                     <p>本主题提供了在配置文件中提供图元数据的示例。按照以下步骤操作oo创建目录和一些示例文件。</p>
                     <ol>
                        <li>
                           <p>创建一个目录来保存您将创建的示例文件。例如：</p><pre class="oac_no_warn" dir="ltr">mkdir -p $ {ORACLE_HOME} / md / property_graph / examples / pgx / graphs /</pre></li>
                        <li>
                           <p>在该目录中，创建一个名为<code class="codeph">sample.adj.json</code>的文本文件，其中<code class="codeph">sample.adj.json</code>图形配置文件的以下内容。此配置文件描述了内存分析器如何读取图形。
                           </p><pre class="oac_no_warn" dir="ltr">{“uri”：“sample.adj”，“format”：“adj_list”，“node_props”：[{“name”：“prop”，“type”：“integer”}]，“edge_props”：[{“ name“：”cost“，”type“：”double“}]，”separator“：”“}</pre></li>
                        <li>
                           <p>在同一目录中，创建一个名为<code class="codeph">sample.adj</code>的文本文件，其中<code class="codeph">sample.adj</code>以下图形数据内容：</p><pre class="oac_no_warn" dir="ltr">128 10 1908 27.03 99 8.51 99 2 333 338.0 1908 889 333 6 128 51.09</pre></li>
                     </ol>
                     <p>在配置文件中， <code class="codeph">uri</code>字段提供图形数据的位置。此路径相对于配置文件的父目录进行解析。当内存分析器加载图形时，它会搜索包含图形数据的名为<code class="codeph">sample.adj</code>的文件。
                     </p>
                     <p>配置文件中的其他字段表示图形数据以邻接列表格式提供，由一个类型为<code class="codeph">integer</code>节点属性和一个类型为<code class="codeph">double</code> edge属性组成。
                     </p>
                     <p>下图显示了根据数据创建的属性图：</p>
                     <div class="figure" id="GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D__BABFEEHB">
                        <p class="titleinfigure">图3-1由sample.adj数据渲染的属性图</p><img src="img/pgx-sample-graph-2.png" alt="下面是图3-1的描述" title="下面是图3-1的描述" longdesc="img_text/pgx-sample-graph-2.html"><br><a href="img_text/pgx-sample-graph-2.html">“图3-1由sample.adj数据渲染的属性图”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" title="本主题提供了使用shell接口以交互方式将图形读入内存的示例。">将图形读入内存</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06" name="GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06"></a><h4 id="SPGDG-GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06" class="sect4"><span class="enumeration_section">3.1.4将</span>图形数据读入内存</h4>
                  <div>
                     <p>要将图形读入内存，您必须传递以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>图形配置文件的路径，用于指定图形元数据</p>
                        </li>
                        <li>
                           <p>可用于引用图形的唯一字母数字名称</p>
                           <p>如果您之前加载了具有相同名称的其他图形，则会出现错误。</p>
                        </li>
                     </ul>
                     <p><span class="bold">示例：使用命令行管理程序读取图表</span></p><pre class="oac_no_warn" dir="ltr">pgx&gt; graph = session.readGraphWithProperties（“&lt;ORACLE_HOME&gt; /md/property_graph/examples/pgx/graphs/sample.adj.json”，“sample”）; ==&gt; PGX Graph命名样本绑定到PGX会话pgxShell ...pgx&gt; graph.getNumVertices（）==&gt; 4</pre><p><span class="bold">示例：使用Java读取图形</span></p><pre class="oac_no_warn" dir="ltr">import oracle.pgx.api。*; PgxGraph graph = session.readGraphWithProperties（“&lt;ORACLE_HOME&gt; /md/property_graph/examples/pgx/graphs/sample.adj.json”）;</pre><p>以下主题包含将属性图读入内存的其他示例：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-B8619BEA-4827-4175-9A0A-427C3020927C">将Oracle数据库中存储的图形读入内存</a><br></li>
                        <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-55CDDB76-EC55-4169-82AD-ED6E9116A4AD">将本地文件系统中存储的图形读入内存</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-254F911A-2750-4CF7-A895-E0B9E027B18C" title="本主题提供了使用shell接口以交互方式将图形读入内存的示例。">将图形读入内存</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-B8619BEA-4827-4175-9A0A-427C3020927C" name="GUID-B8619BEA-4827-4175-9A0A-427C3020927C"></a><h5 id="SPGDG-GUID-B8619BEA-4827-4175-9A0A-427C3020927C" class="sect5"><span class="enumeration_section">3.1.4.1</span>将Oracle数据库中存储的图形读入内存</h5>
                     <div>
                        <p>要读取存储在Oracle数据库中的属性图，可以按如下方式创建基于JSON的配置文件。请注意，必须为您自己的设置自定义主机，商店名称，图形名称和其他信息。</p><pre class="oac_no_warn" dir="ltr">％cat /tmp/my_graph_oracle.json {“loading”：{“load_edge_label”：false}，“vertex_props”：[{“default”：“default_name”，“name”：“name”，“type”：“string” }]，“password”：“&lt;YOUR_PASSWORD&gt;”，“db_engine”：“RDBMS”，“max_num_connections”：8，“username”：“scott”，“error_handling”：{}，“format”：“pg”， “jdbc_url”：“jdbc：oracle：thin：@ 127.0.0.1：1521：&lt;SID&gt;”，“name”：“connections”，“edge_props”：[{“default”：“1000000”，“name”：“成本“，”类型“：”double“}]}</pre><p>然后，将配置文件读入内存。以下示例代码段将文件读入内存，从原始数据生成无向图（名为<code class="codeph">U</code> ），并计算三角形的数量。
                        </p><pre class="oac_no_warn" dir="ltr">pgx&gt; g = session.readGraphWithProperties（“/ tmp / my_graph_oracle.json”，“connections”）pgx&gt; analyst.countTriangles（g，false）==&gt; 8</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：将</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">图形数据读入内存</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-55CDDB76-EC55-4169-82AD-ED6E9116A4AD" name="GUID-55CDDB76-EC55-4169-82AD-ED6E9116A4AD"></a><h5 id="SPGDG-GUID-55CDDB76-EC55-4169-82AD-ED6E9116A4AD" class="sect5"><span class="enumeration_section">3.1.4.2</span>将本地文件系统中存储的图形读入内存</h5>
                     <div>
                        <p>以下命令使用配置文件中<a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">提供图元数据的配置文件</a>和名称<code class="codeph">my-graph</code> ：</p><pre class="oac_no_warn" dir="ltr">pgx&gt; g = session.readGraphWithProperties &lt;ORACLE_HOME&gt; /md/property_graph/examples/pgx/graphs/sample.adj.json“，”my-graph“）</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：将</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">图形数据读入内存</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" name="GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF"></a><h3 id="SPGDG-GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" class="sect3"><span class="enumeration_section">3.2</span>读取自定义图形数据</h3>
               <div>
                  <p>您可以阅读自己的自定义图表数据。</p>
                  <p>此示例创建一个图形，对其进行更改，并显示如何正确读取它。此图使用邻接列表格式，但内存分析器支持多种图形格式。</p>
                  <p>主要步骤是：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-262F412D-51A7-4EB3-8842-76C6892B63A4">创建一个简单的图形文件</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE">添加顶点属性</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A">使用字符串作为顶点标识符</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-DA144BD7-6133-498F-BFED-BED9F84182BD">添加边缘属性</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-262F412D-51A7-4EB3-8842-76C6892B63A4" name="GUID-262F412D-51A7-4EB3-8842-76C6892B63A4"></a><h4 id="SPGDG-GUID-262F412D-51A7-4EB3-8842-76C6892B63A4" class="sect4"><span class="enumeration_section">3.2.1</span>创建简单的图形文件</h4>
                  <div>
                     <p>此示例以邻接列表格式创建一个小而简单的图形，没有顶点或边缘属性。每行包含顶点（节点）ID，后跟其传出边指向的顶点ID：</p><pre class="oac_no_warn" dir="ltr">1 2 2 3 4 3 4 4 2</pre><p>在此列表中，单个空格分隔各个标记。内存分析器支持其他分隔符，您可以在图形配置文件中指定它们。</p>
                     <p>下图显示了呈现为具有4个顶点和5个边的属性图的数据。（顶点2和顶点4之间有两条边，每条边指向与另一条相反的方向。）</p>
                     <div class="figure" id="GUID-262F412D-51A7-4EB3-8842-76C6892B63A4__BABCGCGG">
                        <p class="titleinfigure">图3-2简单自定义属性图</p><img src="img/pgx_custom_graph.png" alt="下面是图3-2的描述" title="下面是图3-2的描述" longdesc="img_text/pgx_custom_graph.html"><br><a href="img_text/pgx_custom_graph.html">“图3-2简单自定义属性图”的说明</a></div>
                     <!-- class="figure" -->
                     <p>将图形读入内存分析程序需要图形配置。您可以使用以下任一方法提供图形配置：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将JSON格式的配置设置写入文件</p>
                        </li>
                        <li>
                           <p>使用Java <code class="codeph">GraphConfigBuilder</code>对象。
                           </p>
                        </li>
                     </ul>
                     <p>以下示例显示了这两种方法。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-262F412D-51A7-4EB3-8842-76C6892B63A4__GUID-D3762C48-11F5-4AFA-82A7-0C880893779B">JSON配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">{“uri”：“graph.adj”，“format”：“adj_list”，“separator”：“”}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-262F412D-51A7-4EB3-8842-76C6892B63A4__GUID-130100E4-C99A-427F-AE5C-A17E0210650A">Java配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import oracle.pgx.config。FileGraphConfig; import oracle.pgx.config。格式; import oracle.pgx.config。GraphConfigBuilder; FileGraphConfig config = GraphConfigBuilder .forFileFormat（格式。ADJ_LIST）。setUri（“graph.adj”）。setSeparator（“”）。build（）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" title="您可以阅读自己的自定义图表数据。">读取自定义图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE" name="GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE"></a><h4 id="SPGDG-GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE" class="sect4"><span class="enumeration_section">3.2.2</span>添加顶点属性</h4>
                  <div>
                     <p>“ <a href="using-inmemory-analyst-oracle-database.html#GUID-262F412D-51A7-4EB3-8842-76C6892B63A4">创建简单图形文件”中的图形</a>由顶点和边组成，没有顶点或边属性。顶点属性直接位于每行中的源顶点ID之后。如果向图中添加了值为0.1,2.0,0.3和4.56789的<code class="codeph">double</code>顶点（节点）属性，则图形数据将如下所示：</p><pre class="oac_no_warn" dir="ltr">1 0.1 2 2 2.0 3 4 3 0.3 4 4 4.56789 2</pre><div class="infoboxnote" id="GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE__GUID-E1749BB1-E9E1-4713-AD9C-2BFE62D488F4">
                        <p class="notep1">注意：</p>
                        <p>内存分析器仅支持同构图，其中所有顶点具有相同数量和类型的属性。</p>
                     </div>
                     <p>要使内存分析程序读取已修改的数据文件，必须在配置文件或构建器代码中添加顶点（节点）属性。以下示例提供属性的描述性名称，并将类型设置为<code class="codeph">double</code> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE__GUID-FCBD55DD-3057-44AE-AD2B-86B7D375D737">JSON配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">{“uri”：“graph.adj”，“format”：“adj_list”，“separator”：“”，“node_props”：[{“name”：“double-prop”，“type”：“double”} ]}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8282B436-9946-4CCE-A42E-5C91CE0F2FAE__GUID-9B820741-1B78-4132-B564-3F7A4EE5D1EA">Java配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">导入oracle.pgx.common.types。财产类型; import oracle.pgx.config。FileGraphConfig; import oracle.pgx.config。格式; import oracle.pgx.config。GraphConfigBuilder; FileGraphConfig config = GraphConfigBuilder.forFileFormat（格式。ADJ_LIST）。setUri（“graph.adj”）。setSeparator（“”）。addNodeProperty（“double-prop”，PropertyType。DOUBLE）.build（）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" title="您可以阅读自己的自定义图表数据。">读取自定义图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A" name="GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A"></a><h4 id="SPGDG-GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A" class="sect4"><span class="enumeration_section">3.2.3</span>使用字符串作为顶点标识符</h4>
                  <div>
                     <p>前面的示例使用<code class="codeph">integer</code>顶点（节点）ID。In-Memory Analytics中的默认值是<code class="codeph">integer</code>顶点ID，但您可以定义图形以使用<code class="codeph">string</code>顶点ID。
                     </p>
                     <p>此数据文件使用“节点1”，“节点2”等，而不仅仅是数字：</p><pre class="oac_no_warn" dir="ltr">“节点1”0.1“节点2”“节点2”2.0“节点3”“节点4”“节点3”0.3“节点4”“节点4”4.56789“节点2”</pre><p>同样，您必须修改图形配置以匹配数据文件：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A__GUID-5FC09CF5-883C-4975-90D6-6D7C15789A13">JSON配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">{“uri”：“graph.adj”，“format”：“adj_list”，“separator”：“”，“node_props”：[{“name”：“double-prop”，“type”：“double”} ]，“node_id_type”：“string”}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A__GUID-4D60EAC8-5743-41EE-9667-C67BA1C68251">Java配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">导入oracle.pgx.common.types。IdType;导入oracle.pgx.common.types。财产类型; import oracle.pgx.config。FileGraphConfig; import oracle.pgx.config。格式; import oracle.pgx.config。GraphConfigBuilder; FileGraphConfig config = GraphConfigBuilder.forFileFormat（格式。ADJ_LIST）。setUri（“graph.adj”）。setSeparator（“”）。addNodeProperty（“double-prop”，PropertyType。DOUBLE）。setNodeIdType（IdType。STRING）.build（）;</pre><div class="infoboxnote" id="GUID-808D6ABB-9048-41E1-A4C1-E232A9B6664A__GUID-4A343CCB-E55C-4F84-8B5E-CDEF540C55F4">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">string</code>顶点ID比<code class="codeph">integer</code>顶点ID消耗更多内存。
                           </p>
                           <p>必须使用反斜杠（\）对字符串中的任何单引号或双引号进行转义。</p>
                           <p>不支持字符串内的换行符（\ n）。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" title="您可以阅读自己的自定义图表数据。">读取自定义图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-DA144BD7-6133-498F-BFED-BED9F84182BD" name="GUID-DA144BD7-6133-498F-BFED-BED9F84182BD"></a><h4 id="SPGDG-GUID-DA144BD7-6133-498F-BFED-BED9F84182BD" class="sect4"><span class="enumeration_section">3.2.4</span>添加边缘属性</h4>
                  <div>
                     <p>此示例向图形添加<code class="codeph">string</code>类型的edge属性。边属性位于目标顶点（节点）ID之后。</p><pre class="oac_no_warn" dir="ltr">“node1”0.1“node2”“edge_prop_1_2”“node2”2.0“node3”“edge_prop_2_3”“node4”“edge_prop_2_4”“node3”0.3“node4”“edge_prop_3_4”“node4”4.56789“node2”“edge_prop_4_2”</pre><p>图形配置必须与数据文件匹配：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-DA144BD7-6133-498F-BFED-BED9F84182BD__GUID-07B4B201-6355-451A-A8DE-A975AB98D8F8">JSON配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">{“uri”：“graph.adj”，“format”：“adj_list”，“separator”：“”，“node_props”：[{“name”：“double-prop”，“type”：“double”} ]，“node_id_type”：“string”，“edge_props”：[{“name”：“edge-prop”，“type”：“string”}]}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DA144BD7-6133-498F-BFED-BED9F84182BD__GUID-50FAFBD4-5CC8-40CC-B3A3-7A5A09611166">Java配置</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">导入oracle.pgx.common.types。IdType;导入oracle.pgx.common.types。财产类型; import oracle.pgx.config。FileGraphConfig; import oracle.pgx.config。格式; import oracle.pgx.config。GraphConfigBuilder; FileGraphConfig config = GraphConfigBuilder.forFileFormat（格式。ADJ_LIST）。setUri（“graph.adj”）。setSeparator（“”）。addNodeProperty（“double-prop”，PropertyType。DOUBLE）。setNodeIdType（IdType。STRING）。addEdgeProperty（“edge-prop”，PropertyType。STRING）.build（）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-06D546D0-FF3A-45E2-B30E-A78B52871DFF" title="您可以阅读自己的自定义图表数据。">读取自定义图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7" name="GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7"></a><h3 id="SPGDG-GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7" class="sect3"><span class="enumeration_section">3.3</span>在磁盘上存储图形数据</h3>
               <div>
                  <p>使用Java或Shell将图形读入内存后，可以将其以不同的格式存储在磁盘上。然后，您可以在以后使用存储的图形数据作为内存分析器的输入。</p>
                  <p>目前不支持在HTTP / REST上存储图表。</p>
                  <p>选项包括：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3">将分析结果存储在顶点属性中</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C">在磁盘上以边缘列表格式存储图表</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3" name="GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3"></a><h4 id="SPGDG-GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3" class="sect4"><span class="enumeration_section">3.3.1</span>在顶点属性中存储分析结果</h4>
                  <div>
                     <p>此示例将图形读入内存并使用Pagerank算法对其进行分析。此分析创建一个新的顶点属性来存储PageRank值。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3__GUID-57C7FA78-52AF-4655-A217-0EB1FEA29F8C">使用Shell运行PageRank</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">pgx&gt; g = session.readGraphWithProperties（“&lt;ORACLE_HOME&gt; /md/property_graph/examples/pgx/graphs/sample.adj.json”，“my-graph”）==&gt; ...pgx&gt; rank = analyst.pagerank（g，0.001,0.85,100）</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D9143A2A-BA3B-4390-A485-65E3ADBF00E3__GUID-6F036C98-BE65-42EA-8D14-5DEDEBD67090">使用Java运行PageRank</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">PgxGraph g = session.readGraphWithProperties（“&lt;ORACLE_HOME&gt; / md /property_graph/examples/pgx/graphs/sample.adj.json”，“my-graph”）; VertexProperty &lt;Integer，Double&gt; rank = session.createAnalyst（）。pagerank（g，0.001,0.85,100）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7" title="使用Java或Shell将图形读入内存后，可以将其以不同的格式存储在磁盘上。然后，您可以在以后使用存储的图形数据作为内存分析器的输入。">在磁盘上存储图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C" name="GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C"></a><h4 id="SPGDG-GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C" class="sect4"><span class="enumeration_section">3.3.2</span>在磁盘上以边缘列表格式存储图表</h4>
                  <div>
                     <p>此示例将图形，Pagerank分析的结果以及所有原始边缘属性存储为磁盘上的边缘列表格式的文件。</p>
                     <p>要存储图形，您必须指定：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>图表格式</p>
                        </li>
                        <li>
                           <p>将存储文件的路径</p>
                        </li>
                        <li>
                           <p>要存储的属性。指定VertexProperty。<code class="codeph">ALL</code>或EdgeProperty。<code class="codeph">ALL</code>用于存储所有属性或VertexProperty。<code class="codeph">NONE</code>或EdgePropery。<code class="codeph">NONE</code>不存性。要指定单个属性，请传入要存储的VertexProperty或EdgeProperty对象。
                           </p>
                        </li>
                        <li>
                           <p>一个标志，指示是否覆盖具有相同名称的现有文件</p>
                        </li>
                     </ul>
                     <p>以下示例使用<code class="codeph">/tmp/sample_pagerank.elist.json</code>配置文件将图形数据存储在<code class="codeph">/tmp/sample_pagerank.elist</code> 。返回值是存储文件的图形配置。您可以使用它再次读取图形。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C__GUID-1FFDBB1E-C795-4B3C-BF64-57F06579A26D">使用命令行管理程序存储图表</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">pgx&gt; config = g.store（格式。EDGE_LIST，“/ tmp / sample_pagerank.elist”，[rank]，EdgeProperty。ALL，false）==&gt; {“uri”：“/ tmp / sample_pagerank.elist”，“edge_props”：[{“type”：“double”，“name”：“cost”}]，“vertex_id_type”：“整数 “ ”加载“：{}， ”格式“： ”edge_list“， ”属性“：{}， ”vertex_props“：[{ ”类型“： ”双“， ”名称“： ”的PageRank“}]，” error_handling“：{}}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6397CA9F-F60B-46E8-BE24-E23B702E187C__GUID-C8B377C0-410A-449A-A944-D215CB4C63E7">使用Java存储图表</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import oracle.pgx.api。*; import oracle.pgx.config。*; FileGraphConfig config = g.store（格式。EDGE_LIST，“/ tmp / sample_pagerank.elist”，Collections.singletonList（rank），EdgeProperty。ALL，false）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-8E32C3CB-4546-49C0-8262-1C8FF92FD0F7" title="使用Java或Shell将图形读入内存后，可以将其以不同的格式存储在磁盘上。然后，您可以在以后使用存储的图形数据作为内存分析器的输入。">在磁盘上存储图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4" name="GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4"></a><h3 id="SPGDG-GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4" class="sect3"><span class="enumeration_section">3.4</span>执行内置算法</h3>
               <div>
                  <p>内存分析器包含一组可用作Java API的内置算法。</p>
                  <p>本主题描述了使用Triangle Counting和Pagerank分析作为示例的内存分析师的使用。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-0EB00328-1272-4F00-ADCB-8F88CB1B334D">关于内存分析师</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-7314197C-DFBC-4F64-A383-D32441D7E821">运行三角计数算法</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC">运行Pagerank算法</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-0EB00328-1272-4F00-ADCB-8F88CB1B334D" name="GUID-0EB00328-1272-4F00-ADCB-8F88CB1B334D"></a><h4 id="SPGDG-GUID-0EB00328-1272-4F00-ADCB-8F88CB1B334D" class="sect4"><span class="enumeration_section">3.4.1</span>关于内存分析师</h4>
                  <div>
                     <p>内存分析器包含一组可用作Java API的内置算法。 API的详细信息记录在产品文档库中包含的Javadoc中。具体来说，请参阅<code class="codeph">BuiltinAlgorithms</code>接口方法摘要以获取支持的内存中分析方法的列表。
                     </p>
                     <p>例如，这是Pagerank过程签名：</p><pre class="oac_no_warn" dir="ltr">/ ** *经典的pagerank算法。时间复杂度：O（E * K），E =边数，K是给定常数（max * iterations）* * @param graph * graph * @param e *终止迭代的最大误差* @param d *阻尼factor * @param max *最大迭代次数* @return Vertex Property将结果保存为double * / public &lt;ID extends Comparable &lt;ID &gt;&gt; VertexProperty &lt;ID，Double&gt; pagerank（PgxGraph graph，double e，double d，int最大）;</pre><pre class="oac_no_warn" dir="ltr"></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4" title="内存分析器包含一组可用作Java API的内置算法。">执行内置算法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-7314197C-DFBC-4F64-A383-D32441D7E821" name="GUID-7314197C-DFBC-4F64-A383-D32441D7E821"></a><h4 id="SPGDG-GUID-7314197C-DFBC-4F64-A383-D32441D7E821" class="sect4"><span class="enumeration_section">3.4.2</span>运行三角计数算法</h4>
                  <div>
                     <p>对于三角形计数， <code class="codeph">countTriangles()</code>的<code class="codeph">sortByDegree</code>布尔参数允许您控制图形是否应首先按度（ <code class="codeph">true</code> ）或不按（ <code class="codeph">false</code> ）排序。如果为<code class="codeph">true</code> ，将使用更多内存，但算法运行速度更快;但是，如果您的图表非常大，您可能希望关闭此优化以避免内存不足。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-7314197C-DFBC-4F64-A383-D32441D7E821__GUID-A8DB3A08-7313-4FAF-9CE1-B1234634A183">使用Shell运行三角计数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">pgx&gt; analyst.countTriangles（graph，true）==&gt; 1</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7314197C-DFBC-4F64-A383-D32441D7E821__GUID-BA146FD9-5200-4C0A-8355-0F4202C8ABA5">使用Java运行三角计数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import oracle.pgx.api。*;分析师分析师= session.createAnalyst（）; long triangles = analyst.countTriangles（graph，true）;</pre><p>该算法在样本图中找到一个三角形。</p>
                        <div class="infobox-tip" id="GUID-7314197C-DFBC-4F64-A383-D32441D7E821__GUID-09303ED3-A1D3-4655-AF28-69EC7B641678">
                           <p class="notep1">小费：</p>
                           <p>使用内存分析程序shell时，可以通过更改日志记录级别来增加执行期间的日志输出量。有关<code class="codeph">:loglevel</code>命令的信息，请参阅<code class="codeph">:h :loglevel</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4" title="内存分析器包含一组可用作Java API的内置算法。">执行内置算法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC" name="GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC"></a><h4 id="SPGDG-GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC" class="sect4"><span class="enumeration_section">3.4.3</span>运行Pagerank算法</h4>
                  <div>
                     <p>Pagerank为图中的每个顶点（节点）计算<code class="codeph">0</code>到<code class="codeph">1</code>之间的等级值，并将值存储在<code class="codeph">double</code>属性中。因此，该算法为输出创建<code class="codeph">double</code>类型的<span class="italic">顶点属性</span> 。
                     </p>
                     <p>在内存分析器中，有两种类型的顶点和边缘属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">持久属性</span> ：从数据源加载图形的属性是磁盘上数据的固定内存副本，因此是持久的。持久属性是只读的，不可变的并在会话之间共享。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">瞬态属性</span> ：值只能写入临时属性，这些属性是会话专用的。您可以通过在<code class="codeph">PgxGraph</code>对象上调用<code class="codeph">createVertexProperty</code>和<code class="codeph">createEdgeProperty</code>来创建瞬态属性。
                           </p>
                        </li>
                     </ul>
                     <p>此示例获取具有最高Pagerank值的前三个顶点。它使用<code class="codeph">double</code>类型的瞬态顶点属性来保存计算的Pagerank值。Pagerank算法对输入参数使用以下默认值：error（容差= 0.001，阻尼因子= 0.85，最大迭代次数= 100）。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC__GUID-F7288B95-E43F-4C09-AD01-8DC923760DBA">使用Shell运行Pagerank</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">pgx&gt; rank = analyst.pagerank（graph，0.001,0.85,100）; ==&gt; ......pgx&gt; rank.getTopKValues（3）==&gt; 128 = 0.1402019732468347 ==&gt; 333 = 0.12002296283541904 ==&gt; 99 = 0.09708583862990475</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E5C3E18-A0B7-43FF-AE69-688F900311BC__GUID-538F4205-62DA-4872-8048-EDD984636A32">使用Java运行Pagerank</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import java.util。地图。条目; import oracle.pgx.api。*;分析师分析师= session.createAnalyst（）; VertexProperty &lt;Integer，Double&gt; rank = analyst.pagerank（graph，0.001,0.85,100）; for（Entry &lt;Integer，Double&gt; entry：rank.getTopKValues（3））{System.out.println（entry.getKey（）+“=”+ entry.getValue（））; }</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-71FC3DB6-62F1-42E6-B711-A32958FC53D4" title="内存分析器包含一组可用作Java API的内置算法。">执行内置算法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" name="GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361"></a><h3 id="SPGDG-GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" class="sect3"><span class="enumeration_section">3.5</span>创建子图</h3>
               <div>
                  <p>您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。</p>
                  <p>有关将图形读入内存的信息，请参阅将<a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">图形数据读入内存</a> 。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-4A25C497-319F-4760-988B-8CD45EA109D3">关于过滤器表达式</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5">使用简单过滤器创建子图</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1">使用复杂过滤器创建子图</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6">使用顶点集创建一个二分子图</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-4A25C497-319F-4760-988B-8CD45EA109D3" name="GUID-4A25C497-319F-4760-988B-8CD45EA109D3"></a><h4 id="SPGDG-GUID-4A25C497-319F-4760-988B-8CD45EA109D3" class="sect4"><span class="enumeration_section">3.5.1</span>关于过滤器表达式</h4>
                  <div>
                     <p>过滤器表达式是针对每个边缘计算的表达式。表达式可以定义边缘必须满足的谓词，以包含在结果中，在本例中是子图。</p>
                     <p>考虑<a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">在配置文件</a>中<a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">提供图表元数据</a>的图表，该图表由四个顶点（节点）和四个边缘组成。对于匹配过滤器表达式<code class="codeph">src.prop == 10</code> ，源顶点<code class="codeph">prop</code>属性必须等于10。两条边匹配该过滤器表达式，如下图所示。
                     </p>
                     <div class="figure" id="GUID-4A25C497-319F-4760-988B-8CD45EA109D3__EDGESMATCHINGSRC.PROP10-1138F71B">
                        <p class="titleinfigure">图3-3边缘匹配src.prop == 10</p><img src="img/pgx_sub_highlight1.png" alt="下面是图3-3的描述" title="下面是图3-3的描述" longdesc="img_text/pgx_sub_highlight1.html"><br><a href="img_text/pgx_sub_highlight1.html">“图3-3边缘匹配src.prop == 10”的描述</a></div>
                     <!-- class="figure" -->
                     <p>下图显示了应用过滤器时产生的图表。滤镜排除与顶点333相关的边和顶点本身。</p>
                     <div class="figure" id="GUID-4A25C497-319F-4760-988B-8CD45EA109D3__GRAPHCREATEDBYTHESIMPLEFILTER-11390B0B">
                        <p class="titleinfigure">图3-4简单过滤器创建的图形</p><img src="img/pgx_subgraph1.png" alt="下面是图3-4的描述" title="下面是图3-4的描述" longdesc="img_text/pgx_subgraph1.html"><br><a href="img_text/pgx_subgraph1.html">“图3-4由简单过滤器创建的图形”的描述</a></div>
                     <!-- class="figure" -->
                     <p>使用过滤器表达式来选择单个顶点或一组顶点是很困难的。例如，仅选择具有属性值<code class="codeph">10</code>的顶点是不可能的，因为匹配顶点的唯一方法是匹配其中<code class="codeph">10</code>是源或目标属性值的边。但是，匹配边时，会自动在结果中包含源顶点，目标顶点和边缘本身。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" title="您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。">创建子图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5" name="GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5"></a><h4 id="SPGDG-GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5" class="sect4"><span class="enumeration_section">3.5.2</span>使用简单过滤器创建子图</h4>
                  <div>
                     <p>以下示例创建<a href="using-inmemory-analyst-oracle-database.html#GUID-4A25C497-319F-4760-988B-8CD45EA109D3">关于过滤器表达式中</a>描述的子图。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5__GUID-B985D9C6-1FC0-4CF6-B411-EC956E663EB5">使用Shell创建子图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">subgraph = graph.filter（new VertexFilter（“vertex.prop == 10”））</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-01A8BB3D-6410-40CD-98E0-0621FCC30BC5__GUID-615A8ECA-FC32-4440-992C-94C9002BF255">使用Java创建子图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import oracle.pgx.api。*; import oracle.pgx.api.filter。*; PgxGraph graph = session.readGraphWithProperties（...）; PgxGraph subgraph = graph.filter（new VertexFilter（“vertex.prop == 10”））;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" title="您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。">创建子图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1" name="GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1"></a><h4 id="SPGDG-GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1" class="sect4"><span class="enumeration_section">3.5.3</span>使用复杂过滤器创建子图</h4>
                  <div>
                     <p>此示例使用稍微复杂的过滤器。它使用<code class="codeph">outDegree</code>函数，该函数计算标识符（source <code class="codeph">src</code>或destination <code class="codeph">dst</code> ）的传出边数。以下过滤器表达式匹配<code class="codeph">cost</code>属性值大于50的所有边以及<code class="codeph">outDegree</code>大于1的目标顶点（节点）。
                     </p><pre class="oac_no_warn" dir="ltr">dst.outDegree（）&gt; 1 &amp;&amp; edge.cost&gt; 50</pre><p>示例图中的一条边与此过滤器表达式匹配，如下图所示。</p>
                     <div class="figure" id="GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1__EDGESMATCHINGTHEOUTDEGREEFILTER-113934AF">
                        <p class="titleinfigure">图3-5匹配outDegree过滤器的边缘</p><img src="img/pgx_sub_highlight2.png" alt="下面是图3-5的描述" title="下面是图3-5的描述" longdesc="img_text/pgx_sub_highlight2.html"><br><a href="img_text/pgx_sub_highlight2.html">“图3-5边缘匹配outDegree过滤器”的描述</a></div>
                     <!-- class="figure" -->
                     <p>下图显示了应用过滤器时产生的图表。滤波器排除与顶点99和1908相关联的边，因此也排除那些顶点。</p>
                     <div class="figure" id="GUID-90AE8A8F-EDFD-4847-96E4-35C5F26984B1__GRAPHCREATEDBYTHEOUTDEGREEFILTER-11394310">
                        <p class="titleinfigure">图3-6 outDegree过滤器创建的图形</p><img src="img/pgx_subgraph2.png" alt="下面是图3-6的描述" title="下面是图3-6的描述" longdesc="img_text/pgx_subgraph2.html"><br><a href="img_text/pgx_subgraph2.html">“图3-6 outdegree过滤器创建的图形”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" title="您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。">创建子图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6" name="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6"></a><h4 id="SPGDG-GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6" class="sect4"><span class="enumeration_section">3.5.4</span>使用顶点集创建二分子图</h4>
                  <div>
                     <p>您可以通过指定一组顶点（节点）来创建二分子图，这些顶点用作左侧。二分子图仅在左顶点集和右顶点集之间具有边。这些集合中没有边缘，例如左侧的两个节点之间。在内存分析器中，由于所有传入和传出边缘都被删除而被隔离的顶点不是二分子图的一部分。</p>
                     <p>下图显示了一个二分子图。没有显示任何属性。</p>
                     <div class="figure" id="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6__FIG-123-11396058"><img src="img/pgx_bipartite_graph.png" alt="pgx_bipartite_graph.png的描述如下" title="pgx_bipartite_graph.png的描述如下" longdesc="img_text/pgx_bipartite_graph.html"><br><a href="img_text/pgx_bipartite_graph.html">插图描述pgx_bipartite_graph.png</a></div>
                     <!-- class="figure" -->
                     <p>以下示例从<a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">在配置文件</a>中<a href="using-inmemory-analyst-oracle-database.html#GUID-BE3E5A99-896A-458D-BF2F-270CC82EA43D">提供图形元数据中</a>创建的简单图形创建二分子图。它们创建一个顶点集合并用左侧的顶点填充它。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6__GUID-2F2257D8-79BA-48A1-8438-B499DEBACD88">使用Shell创建一个二分子图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">pgx&gt; s = graph.createVertexSet（）==&gt; ...pgx&gt; s.addAll（[graph.getVertex（333），graph.getVertex（99）]）==&gt; ...pgx&gt; s.size（）==&gt; 2 pgx&gt; bGraph = graph.bipartiteSubGraphFromLeftSet（s）==&gt; PGX Bipartite Graph命名为sample-sub-graph-4</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6__GUID-B425C7D2-29DE-4B7B-9BC1-E1EEFF2EB633">使用Java创建一个二分子图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import oracle.pgx.api。*; VertexSet &lt;Integer&gt; s = graph.createVertexSet（）; s.addAll（graph.getVertex（333），graph.getVertex（99））; BipartiteGraph bGraph = graph.bipartiteSubGraphFromLeftSet（s）;</pre><p>创建子图时，内存分析器会自动创建一个布尔顶点（节点）属性，指示顶点是否在左侧。您可以为属性指定唯一名称。</p>
                        <p>由此产生的二分子图如下所示：</p>
                        <div class="figure" id="GUID-E3B9CF35-09D6-43B7-86E2-7D4A3B01FBC6__FIG-1284-11396D53"><img src="img/pgx_bipartite_subgraph.png" alt="pgx_bipartite_subgraph.png的描述如下" title="pgx_bipartite_subgraph.png的描述如下" longdesc="img_text/pgx_bipartite_subgraph.html"><br><a href="img_text/pgx_bipartite_subgraph.html">插图描述pgx_bipartite_subgraph.png</a></div>
                        <!-- class="figure" -->
                        <p>Vertex 1908被排除在二分子图之外。连接该顶点的唯一边缘从128扩展到1908。边缘被移除，因为它违反了子图的二分属性。Vertex 1908没有其他边缘，因此也被删除了。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D3134FE8-E17D-40F0-A32D-4CA40B60F361" title="您可以根据已加载到内存中的图形创建子图。您可以使用过滤器表达式或基于指定二分图左侧集的顶点（节点）集合创建二分子图。">创建子图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" name="GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C"></a><h3 id="SPGDG-GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" class="sect3"><span class="enumeration_section">3.6</span>使用自动增量刷新处理数据库更改</h3>
               <div>
                  <p>您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-1DF8FA80-DB74-4268-9AAA-86177542F3AC">配置内存服务器以进行自动刷新</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-1A2AEB12-DD53-4CBA-9558-14CDA5DFC768">配置基本自动刷新</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-7FCED2D4-B678-488B-A0D4-6E87871172D2">使用内存分析器或Java应用程序读取图形</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-578DB065-E3A7-4834-A48E-EFC09C795284">签出图表的特定快照</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-0815347C-919C-4478-A96A-246ACED61A66">高级自动刷新配置</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-1DF8FA80-DB74-4268-9AAA-86177542F3AC" name="GUID-1DF8FA80-DB74-4268-9AAA-86177542F3AC"></a><h4 id="SPGDG-GUID-1DF8FA80-DB74-4268-9AAA-86177542F3AC" class="sect4"><span class="enumeration_section">3.6.1</span>配置内存服务器进行自动刷新</h4>
                  <div>
                     <p>由于自动刷新可以创建许多快照，因此可能会导致内存使用率过高，因此默认情况下，只有管理员才能使用启用图表自动刷新的选项。</p>
                     <p>要允许所有用户自动刷新图形，必须在内存分析程序配置文件（位于<code class="codeph">$ORACLE_HOME/md/property_graph/pgx/conf/pgx.conf</code> ）中包含以下行：</p><pre class="pre codeblock"><code>{“allow_user_auto_refresh”：true}</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" title="您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。">使用自动增量刷新处理数据库更改</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-1A2AEB12-DD53-4CBA-9558-14CDA5DFC768" name="GUID-1A2AEB12-DD53-4CBA-9558-14CDA5DFC768"></a><h4 id="SPGDG-GUID-1A2AEB12-DD53-4CBA-9558-14CDA5DFC768" class="sect4"><span class="enumeration_section">3.6.2</span>配置基本自动刷新</h4>
                  <div>
                     <p>自动刷新在图形配置的加载部分中配置。本主题中的示例设置自动刷新以每分钟检查更新，并在数据源发生更改时创建新快照。</p>
                     <p>以下块（JSON格式）启用示例图的配置文件中的自动刷新功能：</p><pre class="pre codeblock"><code>{“format”：“pg”，“jdbc_url”：“jdbc：oracle：thin：@mydatabaseserver：1521 / dbName”，“username”：“scott”，“password”：“&lt;password&gt;”，“name”： “my_graph”，“vertex_props”：[{“name”：“prop”，“type”：“integer”}]，“edge_props”：[{“name”：“cost”，“type”：“double”} ]，“separator”：“”，“loading”：{“auto_refresh”：true，“update_interval_sec”：60}，}</code></pre><p>请注意包含自动刷新设置的附加<code class="codeph">loading</code>部分。您还可以使用Java API以编程方式构建相同的图形配置：</p><pre class="pre codeblock"><code>GraphConfig config = GraphConfigBuilder.forPropertyGraphRdbms（）。setJdbcUrl（“jdbc：oracle：thin：@mydatabaseserver：1521 / dbName”）。setUsername（“scott”）。setPassword（“&lt;password&gt;”）。setName（“my_graph”）。 addVertexProperty（“prop”，PropertyType。INTEGER）。addEdgeProperty（“cost”，PropertyType。DOUBLE）。setAutoRefresh（true）。setUpdateIntervalSec（60）.build（）;</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" title="您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。">使用自动增量刷新处理数据库更改</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-7FCED2D4-B678-488B-A0D4-6E87871172D2" name="GUID-7FCED2D4-B678-488B-A0D4-6E87871172D2"></a><h4 id="SPGDG-GUID-7FCED2D4-B678-488B-A0D4-6E87871172D2" class="sect4"><span class="enumeration_section">3.6.3</span>使用内存分析器或Java应用程序读取图形</h4>
                  <div>
                     <p>创建图形配置后，您可以使用常规API将图形加载到内存分析程序中。</p><pre class="pre codeblock"><code>pgx&gt; G = session.readGraphWithProperties（“graphs / my-config.pg.json”）</code></pre><p>加载图形后，后台任务会自动启动，并定期检查数据源是否有更新。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" title="您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。">使用自动增量刷新处理数据库更改</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-578DB065-E3A7-4834-A48E-EFC09C795284" name="GUID-578DB065-E3A7-4834-A48E-EFC09C795284"></a><h4 id="SPGDG-GUID-578DB065-E3A7-4834-A48E-EFC09C795284" class="sect4"><span class="enumeration_section">3.6.4</span>签出图的特定快照</h4>
                  <div>
                     <p>每分钟都会查询数据库以进行更新。如果在经过时间间隔后数据库中的图形已更改，则会重新加载图形并自动在内存中创建新快照。</p>
                     <p>您可以使用<code class="codeph">PgxSession</code>的<code class="codeph">getAvailableSnapshots()</code>方法“检出”（移动指向不同版本的指针）图形的可用内存中快照。示例输出如下：</p><pre class="pre codeblock"><code>pgx&gt; session.getAvailableSnapshots（G）==&gt; GraphMetaData [getNumVertices（）= 4，getNumEdges（）= 4，memoryMb = 0，dataSourceVersion = 1453315103000，creationRequestTimestamp = 1453315122669（2016-01-20 10：38：42.669），creationTimestamp = 1453315122685（2016-01-20 10：38：42.685），vertexIdType = integer，edgeIdType = long] ==&gt; GraphMetaData [getNumVertices（）= 5，getNumEdges（）= 5，memoryMb = 3，dataSourceVersion = 1452083654000，creationRequestTimestamp = 1453314938744（2016-01-20 10：35：38.744），creationTimestamp = 1453314938833（2016-01-20 10：35：38.833），vertexIdType = integer，edgeIdType = long]</code></pre><p>前面的示例输出包含两个条目，一个用于最初加载的图形，具有4个顶点和4个边缘，另一个用于通过自动刷新创建的图形，具有5个顶点和5个边缘。</p>
                     <p>要检出图表的特定快照，请使用PgxSession的setSnapshot（）方法，并为其提供要加载的快照的creationTimestamp。</p>
                     <p>例如，如果G指向具有5个顶点和5个边的较新图形，但是您想要分析旧版本的图形，则需要将快照设置为1453315122685。在内存分析器shell中：</p><pre class="pre codeblock"><code>pgx&gt; G.getNumVertices（）==&gt; 5 pgx&gt; G.getNumEdges（）==&gt; 5 pgx&gt; session.setSnapshot（G，1453315122685）==&gt; null pgx&gt; G.getNumVertices（）==&gt; 4 pgx&gt; G .getNumEdges（）==&gt; 4</code></pre><p>也可以直接加载使用的曲线图的一个特定快照<code class="codeph">readGraphAsOf()</code>的方法<code class="codeph">PgxSession</code> 。这是为加载与图中的快捷方式<code class="codeph">readGraphWithProperty()</code>后跟一个<code class="codeph">setSnapshot()</code> 。例如：</p><pre class="pre codeblock"><code>pgx&gt; G = session.readGraphAsOf（config，1453315122685）</code></pre><p>如果您不了解或不关心内存中当前可用的快照，您还可以通过指定允许的最大年龄来指定快照可以接受的“旧”时间跨度。例如，要指定最长快照年龄为60分钟，您可以使用以下内容：</p><pre class="pre codeblock"><code>pgx&gt; G = session.readGraphWithProperties（config，60l，TimeUnit。分钟 ）</code></pre><p>如果内存中的一个或多个快照比指定的最大年龄更新（更新），则将返回最新（最新）的快照。如果所有可用快照都早于指定的最大期限，或者根本没有可用的快照，则将自动创建新快照。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" title="您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。">使用自动增量刷新处理数据库更改</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-0815347C-919C-4478-A96A-246ACED61A66" name="GUID-0815347C-919C-4478-A96A-246ACED61A66"></a><h4 id="SPGDG-GUID-0815347C-919C-4478-A96A-246ACED61A66" class="sect4"><span class="enumeration_section">3.6.5</span>高级自动刷新配置</h4>
                  <div>
                     <p>您可以为自动刷新配置指定高级选项。</p>
                     <p>在内部，内存分析器从数据库上次检查后获取更改，并通过将增量（更改）应用于上一个快照来创建新快照。有两个计时器：一个用于从数据库中提取和缓存增量，另一个用于实际应用增量和创建新快照。</p>
                     <p>此外，您可以指定缓存增量数的阈值。如果缓存更改的数量超过此阈值，则会自动创建新快照。缓存更改的数量是顶点更改数加边数更改数的简单总和。</p>
                     <p>这些增量会定期获取并缓存在内存分析服务器上，原因有两个：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>加快实际的快照创建过程</p>
                        </li>
                        <li>
                           <p>为了说明数据库可以在一段时间后“忘记”更改的情况</p>
                        </li>
                     </ul>
                     <p>您可以指定阈值和更新计时器，这意味着在创建新快照之前将检查这两个条件。必须至少指定其中一个参数（阈值或更新计时器）以防止增量缓存变得太大。不得省略查询源更改的时间间隔。</p>
                     <p>以下参数显示了一个配置，其中每5分钟查询一次新增量的数据源。每20分钟创建一次新快照，或者如果缓存的增量达到1000个更改的大小。</p><pre class="pre codeblock"><code>{“format”：“pg”，“jdbc_url”：“jdbc：oracle：thin：@mydatabaseserver：1521 / dbName”，“username”：“scott”，“password”：“&lt;your_password&gt;”，“name”： “my_graph”，“loading”：{“auto_refresh”：true，“fetch_interval_sec”：300，“update_interval_sec”：1200，“update_threshold”：1000，“create_edge_id_index”：true，“create_edge_id_mapping”：true}}</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-D2C0F3CF-2B00-4712-9375-E40985C26C7C" title="您可以定期自动刷新（自动刷新）图形，以使内存中的图形与数据库中基础属性图的更改保持同步。">使用自动增量刷新处理数据库更改</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-1732BD3C-F120-449B-9FED-90E638A6097A" name="GUID-1732BD3C-F120-449B-9FED-90E638A6097A"></a><h3 id="SPGDG-GUID-1732BD3C-F120-449B-9FED-90E638A6097A" class="sect3"><span class="enumeration_section">3.7</span>部署到Apache Tomcat</h3>
               <div>
                  <p>您可以将内存分析程序部署到Apache Tomcat或Oracle WebLogic。此示例显示如何使用Apache Tomcat将In-Memory Analytics部署为Web应用程序。</p>
                  <div class="section">
                     <p>内存分析师附带<code class="codeph">BASIC Auth</code> ，这需要一个安全领域。Tomcat支持许多不同类型的领域。此示例配置最简单的一个<code class="codeph">MemoryRealm</code> 。有关其他类型的信息，请参阅Tomcat领域配置方法。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>将内存分析程序WAR文件复制到Tomcat <code class="codeph">webapps</code>目录中。例如：</span><div><pre class="oac_no_warn" dir="ltr">cp $ PGX_HOME / server / pgx-webapp- &lt;VERSION&gt; .war $ CATALINA_HOME / webapps / pgx.war</pre><div class="p">其中<code class="codeph">PGX_HOME</code>应定义为：<pre class="oac_no_warn" dir="ltr">export PGX_HOME = $ ORACLE_HOME / md / property_graph / pgx</pre></div>
                           <p><span class="bold">不要</span>复制一个文件名为<code class="codeph">pgx-webapp-&lt;VERSION&gt; <span class="bold">-wls</span> .war</code> ，这是具体到WebLogic Server。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>在编辑器中打开<code class="codeph">$CATALINA_HOME/conf/server.xml</code> ，并在<code class="codeph">&lt;Engine&gt;</code>元素下添加以下realm类声明：</span><div><pre class="oac_no_warn" dir="ltr">&lt;Realm className =“org.apache.catalina.realm。MemoryRealm“/&gt;</pre></div>
                     </li>
                     <li class="stepexpand"><span>在编辑器中打开<code class="codeph">CATALINA_HOME/conf/tomcat-users.xml</code> ，并为<code class="codeph">USER</code>角色定义用户。使用适当的用户名和密码替换此示例中的<code class="codeph">scott</code>和<code class="codeph">&lt;password&gt;</code> ：</span><div><pre class="oac_no_warn" dir="ltr">&lt;role rolename =“USER”/&gt; &lt;user username =“scott”password =“&lt;password&gt;”roles =“USER”/&gt;</pre></div>
                     </li>
                     <li class="stepexpand"><span>确保端口8080尚未使用。</span></li>
                     <li class="stepexpand"><span>启动Tomcat：</span><div><pre class="oac_no_warn" dir="ltr">cd $ CATALINA_HOME ./bin/startup.sh</pre></div>
                     </li>
                     <li class="stepexpand"><span>验证Tomcat是否正常工作：</span><div><pre class="oac_no_warn" dir="ltr">cd $ PGX_HOME ./bin/pgx --base_url http：// scott：&lt;password&gt; @localhost：8080 / pgx</pre></div>
                     </li>
                  </ol>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-1732BD3C-F120-449B-9FED-90E638A6097A__GUID-E09BE13B-838C-47AB-9C66-F1542857E5F4">
                        <p class="notep1">注意：</p>
                        <p>Oracle建议仅将<code class="codeph">BASIC Auth</code>用于测试。对所有其他类型的部署使用更强的身份验证机制。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-B3CBF04E-4A80-401E-9101-26833BF881AF">关于身份验证机制</a><br></li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="http://tomcat.apache.org/" target="_blank">Tomcat文档（选择所需版本）</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-B3CBF04E-4A80-401E-9101-26833BF881AF" name="GUID-B3CBF04E-4A80-401E-9101-26833BF881AF"></a><h4 id="SPGDG-GUID-B3CBF04E-4A80-401E-9101-26833BF881AF" class="sect4"><span class="enumeration_section">3.7.1</span>关于认证机制</h4>
                  <div>
                     <p>内存分析师Web部署默认使用<code class="codeph">BASIC Auth</code> 。您应该为生产部署更改为更安全的身份验证机制。
                     </p>
                     <p>要更改身份验证机制，请在Web应用程序归档（WAR）文件中修改<code class="codeph">web.xml</code>部署描述符的<code class="codeph">security-constraint</code>元素。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-1732BD3C-F120-449B-9FED-90E638A6097A" title="您可以将内存分析程序部署到Apache Tomcat或Oracle WebLogic。此示例显示如何使用Apache Tomcat将In-Memory Analytics部署为Web应用程序。">部署到Apache Tomcat</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" name="GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9"></a><h3 id="SPGDG-GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" class="sect3"><span class="enumeration_section">3.8</span>部署到Oracle WebLogic Server</h3>
               <div>
                  <p>您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-E0C8D78D-B4D4-4F27-88B5-80D392A7928A">安装Oracle WebLogic Server</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-F5F8D8AE-B5CE-4383-B349-B8926D5932D5">部署内存分析器</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-AAC79296-F768-4997-A57F-EF62E50FB71C">验证服务器是否正常工作</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#unique_270712142">关于身份验证机制</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-E0C8D78D-B4D4-4F27-88B5-80D392A7928A" name="GUID-E0C8D78D-B4D4-4F27-88B5-80D392A7928A"></a><h4 id="SPGDG-GUID-E0C8D78D-B4D4-4F27-88B5-80D392A7928A" class="sect4"><span class="enumeration_section">3.8.1</span>安装Oracle WebLogic Server</h4>
                  <div>
                     <p>要下载并安装最新版本的Oracle WebLogic Server，请参阅</p>
                     <p><a href="http://www.oracle.com/technetwork/middleware/weblogic/documentation/index.html" target="_blank"><code class="codeph">http://www.oracle.com/technetwork/middleware/weblogic/documentation/index.html</code></a></p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" title="您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。">部署到Oracle WebLogic Server</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-F5F8D8AE-B5CE-4383-B349-B8926D5932D5" name="GUID-F5F8D8AE-B5CE-4383-B349-B8926D5932D5"></a><h4 id="SPGDG-GUID-F5F8D8AE-B5CE-4383-B349-B8926D5932D5" class="sect4"><span class="enumeration_section">3.8.2</span>部署内存分析器</h4>
                  <div>
                     <p>要将内存分析程序部署到Oracle WebLogic，请使用如下命令。将管理凭据和WAR文件替换为此示例中显示的值：</p><pre class="oac_no_warn" dir="ltr">。$ MW_HOME / user_projects / domains / mydomain / bin / setDomainEnv.sh。$ MW_HOME / wlserver / server / bin / setWLSEnv.sh java weblogic。Deployer -adminurl http：// localhost：7001 -username username -password password -deploy -source $ PGX_HOME / server / pgx-webapp- &lt;version&gt; -wls.war</pre><div class="p">其中<code class="codeph">PGX_HOME</code>应定义为：<pre class="oac_no_warn" dir="ltr">export PGX_HOME = $ ORACLE_HOME / md / property_graph / pgx</pre></div>
                     <p>如果脚本成功运行，您将看到如下消息：</p><pre class="oac_no_warn" dir="ltr">目标状态：在Server myserver上完成部署</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" title="您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。">部署到Oracle WebLogic Server</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-AAC79296-F768-4997-A57F-EF62E50FB71C" name="GUID-AAC79296-F768-4997-A57F-EF62E50FB71C"></a><h4 id="SPGDG-GUID-AAC79296-F768-4997-A57F-EF62E50FB71C" class="sect4"><span class="enumeration_section">3.8.3</span>验证服务器是否正常工作</h4>
                  <div>
                     <p>通过以下列格式输入命令，验证您是否可以连接到服务器：</p><pre class="oac_no_warn" dir="ltr">$ PGX_HOME / bin / pgx --base_url http：// scott： <span class="italic">&lt;password&gt;</span> @localhost：7001 / pgx</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" title="您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。">部署到Oracle WebLogic Server</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="unique_270712142" name="unique_270712142"></a><h4 id="SPGDG-unique_270712142" class="sect4"><span class="enumeration_section">3.8.4</span>关于认证机制</h4>
                  <div>
                     <p>内存分析师Web部署默认使用<code class="codeph">BASIC Auth</code> 。您应该为生产部署更改为更安全的身份验证机制。
                     </p>
                     <p>要更改身份验证机制，请在Web应用程序归档（WAR）文件中修改<code class="codeph">web.xml</code>部署描述符的<code class="codeph">security-constraint</code>元素。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-BFE7B780-7841-4DAC-88E9-84C45D160DE9" title="您可以将内存分析器部署到Apache Tomcat或Oracle WebLogic Server。此示例显示如何使用Oracle WebLogic Server将内存分析程序部署为Web应用程序。">部署到Oracle WebLogic Server</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5" name="GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5"></a><h3 id="SPGDG-GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5" class="sect3"><span class="enumeration_section">3.9</span>连接到内存分析服务器</h3>
               <div>
                  <p>在运行Oracle数据库的计算机中安装属性图内存分析程序之后 - 或者在没有Oracle数据库服务器软件作为Apache Tomcat或Oracle WebLogic Server上的Web应用程序的客户机系统上安装 - 您可以连接到内存分析程序服务器。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-11783F8D-6375-493B-B29A-5BA6E4B21A6A">连接内存分析器Shell</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-CAB8198A-B9DB-4781-8FAB-44CE35B6B6CB">用Java连接</a><br></li>
                     <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4">连接PGX REST API</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-11783F8D-6375-493B-B29A-5BA6E4B21A6A" name="GUID-11783F8D-6375-493B-B29A-5BA6E4B21A6A"></a><h4 id="SPGDG-GUID-11783F8D-6375-493B-B29A-5BA6E4B21A6A" class="sect4"><span class="enumeration_section">3.9.1</span>与内存分析器Shell连接</h4>
                  <div>
                     <p>连接到内存分析器实例的最简单方法是指定服务器的基本URL。以下基本URL可以将SCOTT用户连接到侦听端口8080的本地实例：</p>
                     <p><code class="codeph">HTTP：//斯科特：&lt;密码&gt; @localhost：8080 / PGX</code></p>
                     <p>要使用此基本URL启动内存分析程序shell，请使用<code class="codeph">--base_url</code>命令行参数</p><pre class="oac_no_warn" dir="ltr">cd $ PGX_HOME ./bin/pgx --base_url http：// scott：&lt;password&gt; @localhost：8080 / pgx</pre><p>您可以以相同的方式连接到远程实例。但是，内存分析师目前不提供对Control API的远程支持。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-inmemory-analyst-oracle-database.html#GUID-44ABBB96-31EE-4831-B37E-BD7001A06C04">关于记录HTTP请求</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5" title="在运行Oracle数据库的计算机中安装属性图内存分析程序之后 - 或者在没有Oracle数据库服务器软件作为Apache Tomcat或Oracle WebLogic Server上的Web应用程序的客户机系统上安装 - 您可以连接到内存分析程序服务器。">连接到内存分析服务器</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-44ABBB96-31EE-4831-B37E-BD7001A06C04" name="GUID-44ABBB96-31EE-4831-B37E-BD7001A06C04"></a><h5 id="SPGDG-GUID-44ABBB96-31EE-4831-B37E-BD7001A06C04" class="sect5"><span class="enumeration_section">3.9.1.1</span>关于记录HTTP请求</h5>
                     <div>
                        <p>内存分析器shell默认禁止所有调试消息。要查看执行了哪些HTTP请求，请将<code class="codeph">oracle.pgx</code>的日志级别设置为<code class="codeph">DEBUG</code> ，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">pgx&gt; <span class="bold">：loglevel oracle.pgx DEBUG</span> ===&gt; oracle.pgx logger的日志级别设置为DEBUG pgx&gt; <span class="bold">session.readGraphWithProperties（“sample_http.adj.json”，“sample”）</span> 10：24：25,056 [main] DEBUG RemoteUtils - 请求POST http：// scott：&lt;password&gt; @localhost：8080 / pgx / core / session / session-shell-6nqg5dd / graph HTTP / 1.1 with payload {“graphName”：“sample”，“graphConfig”：{“ uri“：”http：//path.to.some.server/pgx/sample.adj“，”separator“：”“，”edge_props“：[{”type“：”double“，”name“：”cost “}]，”node_props“：[{”type“：”integer“，”name“：”prop“}]，”format“：”adj_list“}} 10：24：25,088 [main] DEBUG RemoteUtils  - 收到HTTP状态201 10：24：25,089 [main] DEBUG RemoteUtils  -  {“futureId”：“87d54bed-bdf9-4601-98b7-ef632ce31463”} 10：24：25,091 [pool-1-thread-3] DEBUG PgxRemoteFuture $ 1  - 请求GET http：// scott：&lt;password&gt; @localhost：8080 / pgx / future / session / session-shell-6nqg5dd / result / 87d54bed-bdf9-4601-98b7-ef632ce31463 HTTP / 1.1 10：24：25,300 [pool-1- thread-3] DEBUG RemoteUtils  - 收到HTTP状态200 10：24：25,301 [pool-1-thread- 3] DEBUG RemoteUtils  -  {“stats”：{“loadingTimeMillis”：0，“estimatedMemoryMegabytes”：0，“numEdges”：4，“numNodes”：4}，“graphName”：“sample”，“nodeProperties”：{“丙 “：” 整数 “}，” edgeProperties “：{” 成本 “：” 双“}}</pre><p>此示例要求图形URI指向内存分析服务器可以使用HTTP或HDFS访问的文件。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-11783F8D-6375-493B-B29A-5BA6E4B21A6A">与内存分析程序Shell连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-CAB8198A-B9DB-4781-8FAB-44CE35B6B6CB" name="GUID-CAB8198A-B9DB-4781-8FAB-44CE35B6B6CB"></a><h4 id="SPGDG-GUID-CAB8198A-B9DB-4781-8FAB-44CE35B6B6CB" class="sect4"><span class="enumeration_section">3.9.2</span>使用Java连接</h4>
                  <div>
                     <p>使用Java初始化内存分析器时，可以指定基本URL。一个例子如下。内存分析服务器的URL提供给<code class="codeph">getInMemAnalyst</code> API调用。
                     </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.rdbms。*; import oracle.pgx.api。*; PgRdbmsGraphConfigcfg = GraphConfigBuilder.forPropertyGraphRdbms（）。setJdbcUrl（“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”）。setUsername（“scott”）。setPassword（“&lt;password&gt;”）。setName（“mygraph”） .setMaxNumConnections（2）.setLoadEdgeLabel（false）.addVertexProperty（“name”，PropertyType。STRING，“default_name”）。addEdgeProperty（“weight”，PropertyType。DOUBLE，“1000000”）。build（）; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（cfg）; ServerInstance remoteInstance = Pgx.getInstance（“http：// scott：&lt;password&gt; @hostname：port / pgx”）; PgxSession session = remoteInstance.createSession（“my-session”）; PgxGraph graph = session.readGraphWithProperties（opg.getConfig（））;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5" title="在运行Oracle数据库的计算机中安装属性图内存分析程序之后 - 或者在没有Oracle数据库服务器软件作为Apache Tomcat或Oracle WebLogic Server上的Web应用程序的客户机系统上安装 - 您可以连接到内存分析程序服务器。">连接到内存分析服务器</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4" name="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4"></a><h4 id="SPGDG-GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4" class="sect4"><span class="enumeration_section">3.9.3</span>使用PGX REST API进行连接</h4>
                  <div>
                     <p>您可以使用REST API PGX端点连接到内存分析器实例。这使您能够使用Java以外的语言与内存分析器进行交互，以实现您自己的客户端。</p>
                     <p>本主题中的示例假定：</p>
                     <ul id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__UL_JJP_GKG_5FB" style="list-style-type:disc">
                        <li>安装了curl的Linux。 <a href="https://curl.haxx.se/download.html" target="_blank">curl</a>是一个与REST端点交互的简单命令行实用程序。）
                        </li>
                        <li>PGX服务器已启动并在<code class="codeph">http://localhost:7007</code> 。</li>
                        <li>PGX服务器禁用了身份验证/授权;也就是说， <code class="codeph">$ORACLE_HOME/md/property_graph/pgx/conf/server.conf</code>包含<code class="codeph">"enable_tls": false</code> 。（这是非默认设置， <span class="bold">不建议</span>用于生产）。
                        </li>
                        <li>PGX允许从本地文件系统读取图形;也就是说， <code class="codeph">$ORACLE_HOME/md/property_graph/pgx/conf/pgx.conf</code>包含<code class="codeph">"allow_local_filesystem": true</code> 。（这是非默认设置， <span class="bold">不建议</span>用于生产）。
                        </li>
                     </ul>
                     <p>对于Swagger规范，您可以通过在浏览器中打开<code class="codeph">http://localhost:7007/swagger.json</code>来查看JSON中支持的端点的完整列表。
                     </p>
                     <ul id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__UL_FTZ_ZBH_5FB" style="list-style-type:disc">
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_OHY_L3H_5FB">第1步：获取CSRF令牌</a></li>
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_EKZ_M3H_5FB">第2步：创建会话</a></li>
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_VLM_N3H_5FB">第3步：阅读图表</a></li>
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_NBH_43H_5FB">第4步：创建一个属性</a></li>
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_L4R_43H_5FB">步骤5：在加载的图上运行PageRank算法</a></li>
                        <li><a href="using-inmemory-analyst-oracle-database.html#GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_RCJ_P3H_5FB">第6步：执行PGQL查询</a></li>
                     </ul>
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_OHY_L3H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-7F6AE87A-25FB-4DCB-9C33-42231FD2D6DA">第1步：获取CSRF令牌</p>
                        <p>申请CSRF令牌：</p><pre class="pre codeblock"><code>curl -v http：// localhost：7007 / token</code></pre><p>响应将如下所示：</p><pre class="oac_no_warn" dir="ltr">*尝试127.0.0.1 ...*连接到localhost（127.0.0.1）端口7007（＃0）&gt; GET /令牌HTTP / 1.1&gt;主机：localhost：7007&gt; User-Agent：curl / 7.47.0&gt;接受：* / *&gt; &lt;HTTP / 1.1 201 &lt;SET-COOKIE：_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0; Version = 1; HttpOnly &lt;Content-Length：0</pre><p>正如您在响应中看到的，这会将cookie <code class="codeph">_csrf_token</code>设置为标记值。 <code class="codeph">9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0</code>用作以下请求的示例标记。对于任何写请求，PGX服务器需要在cookie和有效负载中都存在相同的令牌。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_EKZ_M3H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-A68D27B7-E5F6-4028-81EA-035189297375">第2步：创建会话</p>
                        <p>要创建新会话，请发送JSON有效内容：</p><pre class="pre codeblock"><code>curl -v --cookie'_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0'-H'content-type：application / json'-X POST http：// localhost：7007 / core / v1 / sessions -d'{ “source”：“my-application”，“idleTimeout”：0，“taskTimeout”：0，“timeUnitName”：“MILLISECONDS”，“_ csff_token”：“9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0”}'</code></pre><p>将<code class="codeph">my-application</code>替换为描述您正在运行的应用程序的值。服务器管理员可以使用此值将会话映射到其应用程序。将空闲和任务超时设置为<code class="codeph">0</code>意味着服务器将确定会话和提交的任务何时超时。您必须在cookie头和JSON有效内容中提供相同的CSRF令牌。
                        </p>
                        <p>响应将类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">*尝试127.0.0.1 ...*连接到localhost（127.0.0.1）端口7007（＃0）&gt; POST / core / v1 / sessions HTTP / 1.1&gt;主机：localhost：7007&gt; User-Agent：curl / 7.47.0&gt;接受：* / *&gt; Cookie ：_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0&gt; content-type：application / json&gt; Content-Length：159&gt; * upload完全发送：159个字节中的159个&lt;HTTP / 1.1 201 &lt;SET-COOKIE：SID = abae2811-6dd2-48b0-93a8-8436e078907d;版本= 1; HttpOnly &lt;Content-Length：0</pre><p>响应将cookie设置为为我们创建的会话ID值。会话ID <code class="codeph">abae2811-6dd2-48b0-93a8-8436e078907d</code>用作后续请求的示例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_VLM_N3H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-31795076-C434-4A59-97FE-DAAE8D91DAE4">第3步：阅读图表</p>
                        <div class="infoboxnote" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-963FEB0D-7EF0-432F-8E5C-87646E07E20C">
                           <p class="notep1">注意：</p>
                           <p>如果要分析预先加载的图形或已由另一个会话发布的图形，则可以跳过此步骤。访问预加载或已发布图形所需的只是图形的名称。</p>
                        </div>
                        <p>要读取图形，请将图形配置作为JSON发送到服务器，如以下示例所示（将<code class="codeph">&lt;graph-config&gt;</code>替换为实际PGX图形配置的JSON表示）。
                        </p><pre class="pre codeblock"><code>curl -v -X POST --cookie'_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0; SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / loadGraph -H' content-type：application / json'-d'{“graphConfig”：&lt;graph-config&gt;，“graphName”：null，“csrf_token”：“9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0”}'</code></pre><p>这是一个图形配置示例，它从Oracle数据库中读取属性图：</p><pre class="pre codeblock"><code>{“format”：“pg”，“db_engine”：“RDBMS”，“jdbc_url”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl122”，“username”：“scott”，“password”： “tiger”，“max_num_connections”：8，“name”：“connections”，“vertex_props”：[{“name”：“name”，“type”：“string”}，{“name”：“role”， “type”：“string”}，{“name”：“占用”，“type”：“string”}，{“name”：“country”，“type”：“string”}，{“name”： “政党”，“类型”：“字符串”}，{“名称”：“宗教”，“类型”：“字符串”}]，“edge_props”：[{“name”：“weight”，“type” ：“double”，“default”：“1”}]，“edge_label”：true，“loading”：{“load_edge_label”：true}}</code></pre><p>传递<code class="codeph">"graphName": null</code>告诉服务器生成一个名称。
                        </p>
                        <p>服务器将回复如下内容：</p><pre class="oac_no_warn" dir="ltr">*完全上传已发送：315个字节中的315个&lt;HTTP / 1.1 202 &lt;位置：http：// localhost：7007 / core / v1 / futures / 8a46ef65-01a9-4bd0-87d3-ffe9dfd2ce3c / status &lt;Content-Type：application / json; charset = utf-8 &lt;Content-Length：51 &lt;Date：Mon，05 Nov 2018 17:22:22 GMT &lt;* Connection＃0 to host localhost left intact {{futureId“：”8a46ef65-01a9-4bd0- 87d3-ffe9dfd2ce3c“}</pre><p><span class="bold">关于异步请求</span></p>
                        <p>大多数PGX REST端点都是异步的。PGX服务器提交任务并立即返回状态代码为200的未来ID，而不是在结果准备好之前保持连接打开，然后客户端可以使用该ID定期请求任务状态或请求结果值一次完成。</p>
                        <p>从前面的响应中，您可以请求以下状态：</p><pre class="pre codeblock"><code>curl -v --cookie'SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / futures / 8a46ef65-01a9-4bd0-87d3-ffe9dfd2ce3c / status</code></pre><p>哪个会返回如下内容：</p><pre class="oac_no_warn" dir="ltr">&lt;HTTP / 1.1 200 &lt;Content-Type：application / json; charset = utf-8 &lt;Content-Length：730 &lt;Date：Mon，05 Nov 2018 17:35:19 GMT &lt;* Connection＃0 to host localhost left intact { “ID”： “eb17f75b-e4c1-4a66-81a0-4ff0f8b4cb92”， “链接”：[{ “HREF”：“HTTP：//本地主机：7007 /型芯/ V1 /期货/ eb17f75b-e4c1-4a66-81a0-4ff0f8b4cb92 /状态 “： ”相对“： ”自“， ”方法“： ”GET“， ”相互作用“：[ ”异步轮询“]}，{ ”HREF“：” HTTP：//本地主机：7007 /核心/ V1 /期货/ eb17f75b-e4c1-4a66-81a0-4ff0f8b4cb92" ， “相对”： “中止”， “方法”： “DELETE”， “相互作用”：[ “异步轮询”]}，{ “HREF”：“HTTP ：//本地主机：7007 /型芯/ V1 /期货/ eb17f75b-e4c1-4a66-81a0-4ff0f8b4cb92 /状态 “ ”相对“： ”规范“， ”方法“： ”GET“， ”相互作用“：[” async-轮询 “]}，{” HREF “：” HTTP：//本地主机：7007 /型芯/ V1 /期货/ eb17f75b-e4c1-4a66-81a0-4ff0f8b4cb92 /值”， “相对”： “关联”， “方法”： “GET”， “相互作用”：[ “异步轮询”]}]， “进度”： “成功”， “已完成”：真 “intervalToPoll”：1}</pre><p>除了状态（在这种情况下<code class="codeph">succeeded</code> ），此输出还包括取消任务（ <code class="codeph">DELETE</code> ）和完成任务结果（ <code class="codeph">GET &lt;future-id&gt;/value</code> ）后的链接：</p><pre class="pre codeblock"><code>curl -X GET --cookie'SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / futures / cdc15a38-3422-42a1-baf4-343c140cf95d / value</code></pre><p>这将返回有关已加载图形的详细信息，包括服务器生成的名称（ <code class="codeph">sample</code> ）：</p><pre class="oac_no_warn" dir="ltr">{ “ID”： “样品”， “链接”：[{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 /图形/样品”， “相对”： “自”， “方法”：” GET”， “相互作用”：[ “异步轮询”]}，{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 /图形/样品”， “相对”： “规范”， “方法” ： “GET”， “相互作用”：[ “异步轮询”]}]， “nodeProperties”：{ “PROP1”：{ “ID”： “PROP1”， “链接”：[{ “HREF”：“HTTP： //本地主机：7007 /型芯/ V1 /图形/样品/属性/ PROP1" ， “相对”： “自”， “方法”： “GET”， “相互作用”：[ “异步轮询”]}，{” HREF “：” HTTP：//本地主机：7007 /型芯/ V1 /图形/样品/属性/ PROP1" ， “相对”： “规范”， “方法”： “GET”， “相互作用”：[“异步轮询“]}]，” 尺寸 “：0，” 名称 “：” PROP1" ， “的EntityType”： “顶点”， “类型”： “整数”， “瞬变”：假}}， “vertexLabels”：NULL，” edgeLabel “：空，” 元数据 “：{” ID “：空，” 链接 “：NULL，” numVertices “：4”，numEdges “：4”，memoryMb “：0”，dataSourceVersion “：” 1536029578000" ，“配置“：{”format“：”adj_list“，”separator“：”“，”edge_props“：[{”type“：”double“，”name“：”cost“}]，”error_handling“：{}，” vertex_props “：[{” 类型 “：” 整数 “ ”名称“： ”PROP1“}]， ”vertex_uris“：[” PAT H_TO_FILE “]，” vertex_id_type “：” 整数 “ ”加载“：{}}， ”creationRequestTimestamp“：1541242100335 ”creationTimestamp“：1541242100774 ”vertexIdType“： ”整数“， ”edgeIdType“： ”长“，” 定向“：真}，” graphName “：” 样品 “ ”edgeProperties“：{ ”成本“：{ ”ID“： ”成本“， ”链接“：[{ ”HREF“：” HTTP：//本地主机：7007 /芯/ V1 /图形/样品/性能/成本 “ ”相对“： ”自“， ”方法“： ”GET“， ”相互作用“：[ ”异步轮询“]}，{ ”HREF“：” HTTP： //本地主机：7007 /型芯/ V1 /图形/样品/性能/成本 “ ”相对“： ”规范“， ”方法“： ”GET“， ”相互作用“：[ ”异步轮询“]}]，”尺寸 “：0，” 姓名 “：” 成本”， “的EntityType”： “边缘”， “类型”： “双”， “瞬变”：假}}， “ageMs”：0， “瞬时”：假}</pre><p>为简单起见，其余步骤省略了请求异步任务的状态或值的其他请求。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_NBH_43H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-7277972F-6679-467E-804C-45FC08EE617A">第4步：创建一个属性</p>
                        <p>在加载的图形上运行PageRank算法之前，必须在图形上创建类型为DOUBLE的顶点属性，该属性可以保存计算的排名值：</p><pre class="pre codeblock"><code>curl -v -X POST --cookie'_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0; SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / graphs / sample / properties -H'content-type：application / json'-d'{“entityType”：“vertex”，“type”：“double”，“name”：“pagerank”，“hardName”：false，“dimension”： 0， “_ csrf_token”： “9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0”}”</code></pre><p>请求返回的未来结果将返回如下内容：</p><pre class="oac_no_warn" dir="ltr">{ “ID”： “的PageRank”， “链接”：[{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 /图形/样品/属性/的PageRank”， “相对”： “自”，”方法 “：” GET”， “相互作用”：[ “异步轮询”]}，{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 /图形/样品/属性/的PageRank”， “相对” ： “规范”， “方法”： “GET”， “相互作用”：[ “异步轮询”]}]， “尺寸”：0， “名称”： “的PageRank”， “的EntityType”： “顶点”，”键入“：”双”，‘短暂的’：真正}</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_L4R_43H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-BEF23B8A-0658-43AA-8EC0-4E5ECBB0D172">步骤5：在加载的图上运行PageRank算法</p>
                        <p>以下示例显示了如何运行算法（在本例中为PageRank）。算法ID是URL的一部分，要传递给算法的参数是JSON有效负载的一部分：</p><pre class="pre codeblock"><code>curl -v -X POST --cookie'_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0; SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / analyze / pgx_builtin_k1a_pagerank / run -H'content-type：application / json'-d'{“args”：[{“type”：“GRAPH”，“value”：“sample”}，{“type”：“DOUBLE_IN”，“value “：0.001}，{” 类型 “：” DOUBLE_IN”， “值”：0.85}，{ “类型”： “INT_IN”， “值”：100}，{ “类型”： “BOOL_IN”， “值”：真}，{ “类型”： “NODE_PROPERTY”， “值”： “的PageRank”}]， “expectedReturnType”： “无效”， “workloadCharacteristics”：[ “PARALLELISM.PARALLEL”]， “_ csrf_token”：“9bf51c8f-1c75 -455e-9b57-ec3ca1c63cc0" }”</code></pre><p>一旦未来完成，结果将如下所示：</p><pre class="oac_no_warn" dir="ltr">{ “成功”：真实的， “取消”：假的， “异常”：空 “的returnValue”：空， “executionTimeMs”：50}</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__SECTION_RCJ_P3H_5FB">
                        <p class="subhead3" id="GUID-93FB57BD-C898-45BF-BAF7-581C33591BB4__GUID-BA79C3BD-01AB-4266-B65C-9E13B316B307">第6步：执行PGQL查询</p>
                        <p>要查询PageRank算法的结果，可以运行PGQL查询，如以下示例所示：</p><pre class="pre codeblock"><code>curl -v -X POST --cookie'_csrf_token = 9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0; SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / pgql / run  - H'content-type：application / json'-d'{“pgqlQuery”：“SELECT x.pagerank MATCH（x）WHERE x.pagerank&gt; 0”，“semantic”：“HOMOMORPHISM”，“schemaStrictnessMode”：true，“ graphName“：”sample“，”_ csff_token“：”9bf51c8f-1c75-455e-9b57-ec3ca1c63cc0“}'</code></pre><p>结果是一组链接，您可以使用它们与查询的结果集进行交互：</p><pre class="oac_no_warn" dir="ltr">{ “ID”： “pgql_1”， “链接”：[{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 / pgqlProxies / pgql_1”， “相对”： “自”， “方法”：” GET”， “相互作用”：[ “同步”]}，{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 / pgqlResultProxies / pgql_1 /元件”， “相对”： “关联”， “方法” ： “GET”， “相互作用”：[ “同步”]}，{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 / pgqlResultProxies / pgql_1 /结果”， “相对”： “关联”，”方法 “：” GET “ ”相互作用“：[ ”同步“]}，{ ”HREF“： ”HTTP：//本地主机：7007 /型芯/ V1 / pgqlProxies / pgql_1“， ”相对“： ”规范“，”方法 “：” GET”， “相互作用”：[ “异步轮询”]}]， “存在”：真 “graphName”： “样品”， “resultSetId”： “pgql_1”， “numResults”：4}</pre><p>要请求结果集的前2048个元素，请发送：</p><pre class="pre codeblock"><code>curl -X GET --cookie'SID = abae2811-6dd2-48b0-93a8-8436e078907d'http：// localhost：7007 / core / v1 / pgqlProxies / pgql_1 / results？size = 2048</code></pre><p>响应看起来像这样：</p><pre class="oac_no_warn" dir="ltr">{ “ID”： “/ PGX /型芯/ V1 / pgqlProxies / pgql_1 /结果”， “链接”：[{ “HREF”： “HTTP：//本地主机：7007 /型芯/ V1 / pgqlProxies / pgql_1 /结果”， “相对”： “自”， “方法”： “GET”， “相互作用”：[ “同步”]}，{ “HREF”：“HTTP：//本地主机：7007 /型芯/ V1 / pgqlProxies / pgql_1 /结果”， “相对”： “规范”， “方法”： “GET”， “相互作用”：[ “异步轮询”]}]， “计数”：4 “TOTALITEMS”：4 “项”：[[ 0.3081206521195582]，[0.21367103988538017]，[0.21367103988538017]，[0.2645372681096815]]， “hasMore”：假， “偏移”：0， “限制”：4 “showTotalResults”：真}</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-ABA81274-29A0-4D9A-BA1A-A241C0539BF5" title="在运行Oracle数据库的计算机中安装属性图内存分析程序之后 - 或者在没有Oracle数据库服务器软件作为Apache Tomcat或Oracle WebLogic Server上的Web应用程序的客户机系统上安装 - 您可以连接到内存分析程序服务器。">连接到内存分析服务器</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-3AB6A64B-7E50-493F-A896-6812243D7841" name="GUID-3AB6A64B-7E50-493F-A896-6812243D7841"></a><h3 id="SPGDG-GUID-3AB6A64B-7E50-493F-A896-6812243D7841" class="sect3"><span class="enumeration_section">3.10</span>管理属性图快照</h3>
               <div>
                  <p>Oracle Spatial and Graph Property Graph允许您管理属性图快照。</p>
                  <p>您可以将不同版本的属性图保留为数据库中的二进制快照。二进制快照表示在运行时计算的图形数据的子图，可能需要将来使用。快照可以稍后作为内存分析的输入读回，或者作为并行属性图数据加载器可以使用的输出流。</p>
                  <div class="infoboxnote" id="GUID-3AB6A64B-7E50-493F-A896-6812243D7841__GUID-ECF65B7C-2829-4D09-BFF0-EAA57278BF92">
                     <p class="notep1">注意：</p>
                     <p>管理属性图快照适用于高级用户。</p>
                  </div>
                  <p>您可以使用Java API <code class="codeph">OraclePropertyGraphUtils.storeBinaryInMemoryGraphSnapshot</code> <span class="bold">将</span>二进制快照<span class="bold">存储</span>在属性图的&lt;graph_name&gt; SS $表中。此操作需要连接到保存属性图实例的Oracle数据库，图的名称及其所有者，快照的ID以及可从中读取二进制快照的输入流。您还可以指定快照的时间戳以及在表中存储快照时要使用的并行度。
                  </p>
                  <p>您可以使用<code class="codeph">oraclePropertyGraphUtils.readBinaryInMemGraphSnapshot</code> <span class="bold">读取</span>存储的二进制快照。此操作需要连接到Oracle数据库，其中包含属性图实例，图形名称及其所有者，要读取的快照的ID以及将写入二进制文件快照的输出流。您还可以指定从表中读取快照二进制文件时要使用的并行度。
                  </p>
                  <p>以下代码段以Oracle平面文件格式从数据文件创建属性图，添加新顶点，并使用GraphML格式将图形导出为输出流。此输出流表示二进制文件快照，并存储在属性图快照表中。最后，此示例从快照表中读回文件，并从其内容创建第二个图。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000， true，“PDML = T，PDDL = T，NO_DUP = T，”）; //添加新顶点Vertex v = opg.addVertex（Long.valueOf（“1000”））; v.setProperty（“name”，“ Alice“）; opg.commit（）; System.out.pritnln（”Graph“+ szGraphName +”total vertices：“+ opg.countVertices（dop））; System.out.pritnln（”Graph“+ szGraphName +”total edges：“+ opg.countEdges（dop））; //以graphML格式获取当前图形的快照。OutputStream os = new ByteArrayOutputStream（）; OraclePropertyGraphUtils.exportGraphML（opg，os / *输出流* /，System.out / *流来显示进度* /）; //将快照保存到SS $表中InputStream is = new ByteArrayInputStream（os.toByteArray（））; OraclePropertyGraphUtils.storeBinaryInMemGraphSnapshot（szGraphName，szGraphOwner / *属性图的所有者* /，conn / *数据库连接* /，是，（长）1 / *快照ID * /，1 / * dop * /）; os.close（）; is.close（）; //从SS $表中读回快照OutputStream snapshotOS = new ByteArrayOutputStream（）; OraclePropertyGraphUtils.readBinaryInMemGraphSnapshot（szGraphName，szGraphOwner / *属性图的所有者* /，conn / *数据库连接* /，新的OutputStream [] {snapshotOS}，（长）1 / *快照ID * /，1 / * dop * / ）; InputStream snapshotIS = new ByteArrayInputStream（snapshotOS.toByteArray（））; String szGraphNameSnapshot = szGraphName +“_snap”; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphNameSnapshot）; OraclePropertyGraphUtils.importGraphML（opg，snapshotIS / *输入流* /，System.out / *流来显示进度* /）; snapshotOS.close（）; snapshotIS.close（）; System.out.pritnln（“Graph”+ szGraphNameSnapshot +“total vertices：”+ opg.countVertices（dop））; System.out.pritnln（“Graph”+ szGraphNameSnapshot +“total edges：”+ opg.countEdges（dop））;</code></pre><p>前面的示例将生成类似于以下内容的输出：</p><pre class="oac_no_warn" dir="ltr">图测试总顶点：79图测试总边：164图test_snap总顶点：79图test_snap总边：164</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析器（PGX）</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>